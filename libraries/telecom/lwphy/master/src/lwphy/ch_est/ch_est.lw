/*
 * Copyright (c) 2020, LWPU CORPORATION.  All rights reserved.
 *
 * LWPU CORPORATION and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from LWPU CORPORATION is strictly prohibited.
 */

#include <algorithm>
#include "lwComplex.h"
#include <cooperative_groups.h>
#include "descrambling.lwh"
#include "GOLD_2_COALESCED_P_LUT.h"
#include "GOLD_1_SEQ_LUT.h"
#include "ch_est.hpp"
#include "type_colwert.hpp"
#include <vector>

using namespace cooperative_groups;
using namespace descrambling;

namespace ch_est
{
// #define ENABLE_PROFILING
// #define ENABLE_DEBUG

// PRB size in tones
static constexpr uint32_t N_TONES_PER_PRB    = 12;
static constexpr uint32_t N_THREADS_PER_WARP = 32; // lwdaDeviceProp::warpSize;

template <typename TElem, int NDim>
struct tensor_ref
{
    TElem* addr;
    int    dim[NDim];
    int    strides[NDim];
    size_t n_elem = 1;
    tensor_ref(tensor_pair& tp) :
        addr(static_cast<TElem*>(tp.second)),
        n_elem(1)
    {
        const tensor_layout_any& layout = tp.first.get().layout();
#pragma unroll
        for(int i = 0; i < NDim; ++i)
        {
            dim[i]     = (layout.rank() > i) ? layout.dimensions[i] : 1;
            strides[i] = (layout.rank() > i) ? layout.strides[i] : 0;
            n_elem *= dim[i];
        }
    }
    tensor_ref(const_tensor_pair& tp) :
        addr(static_cast<TElem*>(tp.second)),
        n_elem(1)
    {
        const tensor_layout_any& layout = tp.first.get().layout();
#pragma unroll
        for(int i = 0; i < NDim; ++i)
        {
            dim[i]     = (layout.rank() > i) ? layout.dimensions[i] : 1;
            strides[i] = (layout.rank() > i) ? layout.strides[i] : 0;
            n_elem *= dim[i];
        }
    }
    LWDA_BOTH long offset(int i0) const
    {
        return (strides[0] * (long)i0);
    }
    LWDA_BOTH long offset(int i0, int i1) const
    {
        return (strides[0] * (long)i0) + (strides[1] * (long)i1);
    }
    LWDA_BOTH long offset(int i0, int i1, int i2) const
    {
        return (strides[0] * (long)i0) + (strides[1] * (long)i1) + (strides[2] * (long)i2);
    };
    LWDA_BOTH long offset(int i0, int i1, int i2, int i3) const
    {
        return (strides[0] * (long)i0) + (strides[1] * (long)i1) + (strides[2] * (long)i2) + (strides[3] * (long)i3);
    };
    // clang-format off
    LWDA_BOTH TElem&       operator()(int i0)                               { return *(addr + offset(i0));         }
    LWDA_BOTH TElem&       operator()(int i0, int i1)                       { return *(addr + offset(i0, i1));     }
    LWDA_BOTH TElem&       operator()(int i0, int i1, int i2)               { return *(addr + offset(i0, i1, i2)); }
    LWDA_BOTH TElem&       operator()(int i0, int i1, int i2, int i3)       { return *(addr + offset(i0, i1, i2, i3)); }

    LWDA_BOTH const TElem& operator()(int i0) const                         { return *(addr + offset(i0));         }
    LWDA_BOTH const TElem& operator()(int i0, int i1) const                 { return *(addr + offset(i0, i1));     }
    LWDA_BOTH const TElem& operator()(int i0, int i1, int i2) const         { return *(addr + offset(i0, i1, i2)); }
    LWDA_BOTH const TElem& operator()(int i0, int i1, int i2, int i3) const { return *(addr + offset(i0, i1, i2, i3)); }
    // clang-format on
#if 0    
    if(std::is_const<TElem>::value) {
      LWDA_BOTH const TElem& operator()(int i0) const                         { return __ldg(addr + offset(i0));         }
      LWDA_BOTH const TElem& operator()(int i0, int i1) const                 { return __ldg(addr + offset(i0, i1));     }
      LWDA_BOTH const TElem& operator()(int i0, int i1, int i2) const         { return __ldg(addr + offset(i0, i1, i2)); }
      LWDA_BOTH const TElem& operator()(int i0, int i1, int i2, int i3) const { return __ldg(addr + offset(i0, i1, i2, i3)); }
    }
    else {
      LWDA_BOTH const TElem& operator()(int i0) const                         { return *(addr + offset(i0));         }
      LWDA_BOTH const TElem& operator()(int i0, int i1) const                 { return *(addr + offset(i0, i1));     }
      LWDA_BOTH const TElem& operator()(int i0, int i1, int i2) const         { return *(addr + offset(i0, i1, i2)); }
      LWDA_BOTH const TElem& operator()(int i0, int i1, int i2, int i3) const { return *(addr + offset(i0, i1, i2, i3)); }
    }
#endif

    LWDA_BOTH size_t num_elem()
    {
        return n_elem;
    };
};

template <typename T, int M>
struct block_1D
{
    T         data[M];
    LWDA_BOTH T& operator[](int idx) { return data[idx]; }
};

template <typename T, int M, int N>
struct block_2D
{
    T         data[M * N];
    LWDA_BOTH T& operator()(int m, int n) { return data[(n * M) + m]; }
};

template <typename T, int L, int M, int N>
struct block_3D
{
    T         data[L * M * N];
    LWDA_BOTH T& operator()(int l, int m, int n) { return data[((n * M) + m) * L + l]; }
};

// Partial specialization of block_1D to use shared memory pointers
template <typename T, int M>
struct block_1D<T*, M>
{
    LWDA_BOTH block_1D(T* pData) :
        m_pData(pData){}; // static_assert(std::is_pointer<T>::value, "Must be a pointer type")
    block_1D()                    = delete;
    block_1D(block_1D const& blk) = delete;
    LWDA_BOTH block_1D& operator  =(block_1D const& block) { m_pData = block.m_pData; };
    ~block_1D()                   = default;

    LWDA_BOTH T&               operator[](int idx) { return m_pData[idx]; }
    static constexpr LWDA_BOTH size_t num_elem() { return M; }

private:
    T* m_pData = nullptr;
};

// Partial specialization of block_2D to use shared memory pointers
template <typename T, int M, int N>
struct block_2D<T*, M, N>
{
    LWDA_BOTH block_2D(T* pData) :
        m_pData(pData){};
    block_2D()                    = delete;
    block_2D(block_2D const& blk) = delete;
    LWDA_BOTH block_2D& operator  =(block_2D const& block) { m_pData = block.m_pData; };
    ~block_2D()                   = default;

    LWDA_BOTH T&               operator()(int m, int n) { return m_pData[(n * M) + m]; }
    static constexpr LWDA_BOTH size_t num_elem() { return M * N; }

private:
    T* m_pData = nullptr;
};

// Partial specialization of block_3D to use shared memory pointers
template <typename T, int L, int M, int N>
struct block_3D<T*, L, M, N>
{
    LWDA_BOTH block_3D(T* pData) :
        m_pData(pData){};
    block_3D()                    = delete;
    block_3D(block_3D const& blk) = delete;
    LWDA_BOTH block_3D& operator  =(block_3D const& block) { m_pData = block.m_pData; };
    ~block_3D()                   = default;

    LWDA_BOTH T&               operator()(int l, int m, int n) { return m_pData[((n * M) + m) * L + l]; }
    static constexpr LWDA_BOTH size_t num_elem() { return L * M * N; }

private:
    T* m_pData = nullptr;
};

// clang-format off
template <typename T> LWDA_BOTH_INLINE constexpr T     lwGet(uint32_t);
template<>            LWDA_BOTH_INLINE constexpr float lwGet(uint32_t x) { return(float(x)); }

template <typename T> LWDA_BOTH_INLINE T         lwGet(int);
template<>            LWDA_BOTH_INLINE float     lwGet(int x) { return(float(x)); }
template<>            LWDA_BOTH_INLINE lwComplex lwGet(int x) { return(make_lwComplex(float(x), 0.0f)); }

template <typename T> LWDA_BOTH_INLINE T         lwGet(float);
template<>            LWDA_BOTH_INLINE lwComplex lwGet(float x) { return(make_lwComplex(x, 0.0f)); }

template <typename T> LWDA_BOTH_INLINE T         lwGet(float,float);
template <>           LWDA_BOTH_INLINE lwComplex lwGet<lwComplex>(float x, float y) { return make_lwComplex(x,y); }

static LWDA_BOTH_INLINE lwComplex operator+=(lwComplex &x, lwComplex y)       { x = lwCaddf(x, y); return x; };
static LWDA_BOTH_INLINE lwComplex operator*(lwComplex x, int y)               { return(make_lwComplex(lwCrealf(x)*float(y), lwCimagf(x)*float(y))); }
static LWDA_BOTH_INLINE lwComplex operator*(lwComplex x, float y)             { return(make_lwComplex(lwCrealf(x)*y, lwCimagf(x)*y)); }
static LWDA_BOTH_INLINE lwComplex operator*=(lwComplex &x, const lwComplex y) { x = lwCmulf(x, y); return x; };

// #ifdef ENABLE_DEBUG
static LWDA_BOTH_INLINE lwComplex operator*(lwComplex x, lwComplex y) { return(lwCmulf(x, y)); }
// #endif

static LWDA_BOTH_INLINE float lwReal(lwComplex x) { return(lwCrealf(x)); }
static LWDA_BOTH_INLINE float lwImag(lwComplex x) { return(lwCimagf(x)); }
static LWDA_BOTH_INLINE lwComplex lwConj(lwComplex x) { return(lwConjf(x)); }

#if 0
static LWDA_BOTH_INLINE float lwReal(lwComplex x) { return(lwCrealf(x)); }
static LWDA_BOTH_INLINE float lwImag(lwComplex x) { return(lwCimagf(x)); }
static LWDA_BOTH_INLINE lwComplex lwAdd(lwComplex x, lwComplex y) { return(lwCaddf(x, y)); }
static LWDA_BOTH_INLINE lwComplex lwMul(lwComplex x, lwComplex y) { return(lwCmulf(x, y)); }
static LWDA_BOTH_INLINE lwComplex lwDiv(lwComplex x, lwComplex y) { return(lwCdivf(x, y)); }
static LWDA_BOTH_INLINE lwComplex operator+(lwComplex x, lwComplex y) { return(lwCaddf(x, y)); }
static LWDA_BOTH_INLINE lwComplex operator-(lwComplex x, lwComplex y) { return(lwCsubf(x, y)); }
static LWDA_BOTH_INLINE lwComplex operator+=(lwComplex x, lwComplex y) { return(lwCaddf(x, y)); };
static LWDA_BOTH_INLINE lwComplex operator-=(lwComplex x, lwComplex y) { return(lwCsubf(x, y)); }
static LWDA_BOTH_INLINE lwComplex operator*(lwComplex x, float y) { return(make_lwComplex(lwCrealf(x)*y, lwCimagf(x)*y)); }
static LWDA_BOTH_INLINE lwComplex operator/(lwComplex x, float y) { return(make_lwComplex(lwCrealf(x)/y, lwCimagf(x)/y)); }
static LWDA_BOTH_INLINE lwComplex operator*(lwComplex x, lwComplex y) { return(lwCmulf(x, y)); }
static LWDA_BOTH_INLINE lwComplex operator*(const lwComplex x, const lwComplex y) { return(lwCmulf(x, y)); }
static LWDA_BOTH_INLINE lwComplex operator*=(lwComplex &x, float y) { x = make_lwComplex(lwCrealf(x)*y, lwCimagf(x)*y); return x; }
static LWDA_BOTH_INLINE lwComplex operator*=(lwComplex &x, lwComplex y) { x = lwCmulf(x, y); return x; };
static LWDA_BOTH_INLINE lwComplex lwFma(lwComplex x, lwComplex y, lwComplex a) { return lwCfmaf(x,y,a); }// a = (x*y) + a;

// lwda_fp16.hpp
//__device__ __forceinline__ __half operator*(const __half &lh, const __half &rh) { return __hmul(lh, rh); }  
// __device__ __forceinline__ __half2& operator*=(__half2 &lh, const __half2 &rh) { lh = __hmul2(lh, rh); return lh; } 

// static LWDA_BOTH_INLINE __half2 lwConj(__half2 &hc) { __half2 t; t.x = hc.x; t.y = -hc.y; return t; }
// static LWDA_BOTH_INLINE __half2 lwGet(int x) {  __half2 t; t.x = __half(x); t.y = __float2half(0.0f); return t; } 
#endif
// clang-format on

LWDA_INLINE constexpr uint32_t get_inter_dmrs_grid_freq_shift(const uint32_t nDMRSGridsPerPRB)
{
    return (2 == nDMRSGridsPerPRB) ? 1 : 2;
}

LWDA_INLINE constexpr uint32_t get_inter_dmrs_grid_freq_shift_idx(const uint32_t nDMRSGridsPerPRB, const uint32_t gridIdx)
{
    return ((nDMRSGridsPerPRB - 1) - gridIdx) * get_inter_dmrs_grid_freq_shift(nDMRSGridsPerPRB);
}

LWDA_INLINE constexpr uint32_t get_smem_dmrs_tone_idx(const uint32_t nDMRSGridsPerPRB, const uint32_t nInterDMRSGridFreqShift, const uint32_t tIdx)
{
    return (2 == nDMRSGridsPerPRB) ? (tIdx / nDMRSGridsPerPRB) :
                                     (nInterDMRSGridFreqShift * (tIdx / (nInterDMRSGridFreqShift * nDMRSGridsPerPRB)) +
                                      (tIdx % nInterDMRSGridFreqShift));
}

LWDA_INLINE constexpr uint32_t get_smem_dmrs_grid_idx(const uint32_t nDMRSGridsPerPRB, const uint32_t nInterDMRSGridFreqShift, const uint32_t tIdx)
{
    return (2 == nDMRSGridsPerPRB) ? (tIdx % nDMRSGridsPerPRB) :
                                     (tIdx / nInterDMRSGridFreqShift) % nDMRSGridsPerPRB;
}

// Channel Estimation kernel:
// Performs frequency domain interpolation: Uses DMRS tones in N_DMRS_PRB_IN_PER_CLUSTER PRBs and generates
// channel estimate over N_DMRS_INTERP_PRB_OUT_PER_CLUSTER PRBs for all the layers present in N_DMRS_PRB_IN_PER_CLUSTER PRBs
// Each thread block consumes a pilot chunk: N_DMRS_PRB_IN_PER_CLUSTER x N_DMRS_SYMS pilot and outputs H as:
// N_DMRS_SYMS_FOCC x N_DMRS_SYMS_TOCC x N_DMRS_GRIDS_PER_PRB x N_DMRS_INTERP_PRB_OUT_PER_CLUSTER = N_LAYERS x N_DMRS_INTERP_PRB_OUT_PER_CLUSTER
// Inputs and outputs assumed to be column major

// Note: The shift and unshift sequences are the same for all DMRS time resources (symbols) but different for
// DMRS frequency resources (tones). The descrambling sequence is different for each time (symbol) and
// frequencey (tone) resource

// Since each thread block estimates channel H for a PRB cluster of size N_DMRS_INTERP_PRB_OUT_PER_CLUSTER PRBs
// # of thread blocks needed = gridDim = N_DATA_PRB/N_DMRS_INTERP_PRB_OUT_PER_CLUSTER
// dimBlock: (N_DMRS_PRB_IN_PER_CLUSTER*N_TONES_PER_PRB) dimGrid: (N_DATA_PRB/N_DMRS_INTERP_PRB_OUT_PER_CLUSTER, nBSAnt)
// Tested for: N_DATA_PRB = 64, N_DMRS_INTERP_PRB_OUT_PER_CLUSTER = 4, N_DMRS_PRB_IN_PER_CLUSTER = 8, dimBlock(96) and dimGrid(68, 16)
// where N_DATA_PRB is the total # of PRBs bearing data i.e. total number interpolatd DMRS PRBs produced by

static constexpr uint32_t N_MAX_DMRS_SYMS = 4;

// Channel estimates from only the active DMRS grids are saved. Table below contains mapping of active DMRS grid 
// index bitmask to DMRS grid write index (-1 for inactive grids). Choose data type to be smallest possible type  
// to save on table size (and hence the memory foot print)
__constant__ int8_t DMRS_GRID_WR_IDX_TBL[][N_MAX_DMRS_SYMS] 
{{-1,-1,-1}, {0,-1,-1}, {-1,0,-1}, {0,1,-1}, {-1,-1,0}, {0,-1,1}, {-1,0,1}, {0,1,2}}; 

// Compute 32 bits of the Gold sequence starting from bit n//32
__device__ inline uint32_t gold32(uint32_t seed2, uint32_t n)
{
    uint32_t prod2;

    //    uint32_t state1 = 0x40000000;         // reverse of 0x1
    uint32_t state2 = __brev(seed2) >> 1; // reverse 31 bits

    state2 = polyMulHigh31(state2, POLY_2);

    prod2 = mulModPoly31_Coalesced(state2,
                                   &GOLD_2_COALESCED_P_LUT[(n) / WORD_SIZE],
                                   GOLD_2_COALESCED_P_LUT_OFFSET,
                                   POLY_2);

    uint32_t fstate2 = galois31LFSRWord(prod2, POLY_2_GMASK, 31);

    uint32_t output2 = fibonacciLFSR2_1bit(fstate2);

    //    return output1 ^ output2;
    return GOLD_1_SEQ_LUT[n / WORD_SIZE] ^ output2;
}

template <typename TStorage,
          typename TDataRx,
          typename TCompute,
          uint32_t N_BS_ANTS,                         // # of BS antenna (# of rows in H matrix)
          uint32_t N_LAYERS,                          // # of layers (# of cols in H matrix)
          uint32_t N_DMRS_GRIDS_PER_PRB,              // # of DMRS grids per PRB (2 or 3)
          uint32_t N_DMRS_PRB_IN_PER_CLUSTER,         // # of PRBs bearing DMRS tones to be processed by each thread block (i.e. used in channel estimation)
          uint32_t N_DMRS_INTERP_PRB_OUT_PER_CLUSTER, // # of PRBs bearing channel estimates (interpolated tones) at output
          uint32_t N_DMRS_SYMS>                       // # of time domain DMRS symbols (1,2 or 4)
__global__ void
windowed_ch_est_kernel(uint32_t                                                          cellId,
                       uint32_t                                                          slotNum,
                       uint32_t                                                          activeDMRSGridBmsk,
                       tensor_ref<const typename complex_from_scalar<TDataRx>::type, 3>  tDataRx,        // (NF, ND, N_BS_ANTS)
                       tensor_ref<const TStorage, 3>                                     tWFreq,         // (N_TOTAL_DMRS_INTERP_GRID_TONES_PER_CLUSTER + N_INTER_DMRS_GRID_FREQ_SHIFT, N_TOTAL_DMRS_GRID_TONES_PER_CLUSTER, 3), 3 filters: 1 for middle, 1 lower edge and 1 upper edge
                       tensor_ref<const typename complex_from_scalar<TStorage>::type, 2> tShiftSeq, // (N_DATA_PRB*N_DMRS_GRID_TONES_PER_PRB, N_DMRS_SYMS)
                       tensor_ref<const typename complex_from_scalar<TStorage>::type, 1> tUnShiftSeq,    // (N_DATA_PRB*N_DMRS_INTERP_TONES_PER_GRID*N_DMRS_GRIDS_PER_PRB + N_INTER_DMRS_GRID_FREQ_SHIFT)
                       tensor_ref<typename complex_from_scalar<TStorage>::type, 4>       tHEst,          // (N_BS_ANTS, N_LAYERS, N_DATA_PRB*N_TONES_PER_PRB, NH)
                       tensor_ref<typename complex_from_scalar<TStorage>::type, 4>       tDbg)

{
    //--------------------------------------------------------------------------------------------------------
    // Dimensions and indices

    // Only 1 estimate of H in time supported
    constexpr uint32_t NH_IDX = 0;

    // Channel estimation expands tones in a DMRS grid (4 or 6, given by N_DMRS_GRID_TONES_PER_PRB) into a full PRB
    constexpr uint32_t N_DMRS_INTERP_TONES_PER_GRID = N_TONES_PER_PRB;

    // # of tones per DMRS grid in a PRB
    constexpr uint32_t N_DMRS_GRID_TONES_PER_PRB = N_TONES_PER_PRB / N_DMRS_GRIDS_PER_PRB;
    // Max permissible DMRS grids within a PRB based on spec
    constexpr uint32_t N_DMRS_TYPE1_GRIDS_PER_PRB = 2;
    constexpr uint32_t N_DMRS_TYPE2_GRIDS_PER_PRB = 3;
    static_assert(((N_DMRS_TYPE1_GRIDS_PER_PRB == N_DMRS_GRIDS_PER_PRB) || (N_DMRS_TYPE2_GRIDS_PER_PRB == N_DMRS_GRIDS_PER_PRB)),
                  "DMRS grid count exceeds max value");

    // Within a PRB, successive DMRS grids are shifted by 2 tones
    constexpr uint32_t N_INTER_DMRS_GRID_FREQ_SHIFT = get_inter_dmrs_grid_freq_shift(N_DMRS_GRIDS_PER_PRB);

    // Per grid tone counts present in input and output PRB clusters. These tones counts are expected to be equal
    constexpr uint32_t N_TOTAL_DMRS_GRID_TONES_PER_CLUSTER        = N_DMRS_GRID_TONES_PER_PRB * N_DMRS_PRB_IN_PER_CLUSTER;
    constexpr uint32_t N_TOTAL_DMRS_INTERP_GRID_TONES_PER_CLUSTER = N_DMRS_INTERP_TONES_PER_GRID * N_DMRS_INTERP_PRB_OUT_PER_CLUSTER;

    // Total # of DMRS tones consumed by this thread block (this number should equal number of threads in
    // thread block since each DMRS tone is processed by a thread)
    constexpr uint32_t N_DMRS_TONES = N_TOTAL_DMRS_GRID_TONES_PER_CLUSTER * N_DMRS_GRIDS_PER_PRB; // blockDim.x
    // Total # of interpolated DMRS tones produced by this thread block (this number should also equal number
    // of threads in thread block)
    constexpr uint32_t N_INTERP_TONES = N_TOTAL_DMRS_INTERP_GRID_TONES_PER_CLUSTER * N_DMRS_GRIDS_PER_PRB; // blockDim.x

    static_assert((N_DMRS_PRB_IN_PER_CLUSTER * N_TONES_PER_PRB == N_DMRS_TONES),
                  "Mismatch in expected vs callwalted DMRS tone count");
    static_assert((N_DMRS_TONES == N_INTERP_TONES),
                  "Thread allocation assumes input DMRS tone count and interpolated tone count are equal, ensure sufficient threads are allocated for interpoloation etc");

    // Ensure configured symbol count does not exceed max value prescribed by spec
    static_assert((N_DMRS_SYMS <= N_MAX_DMRS_SYMS), "DMRS symbol count exceeds max value");

    // DMRS symbol locations in time
    constexpr uint32_t DMRS_SYM_IDX[N_MAX_DMRS_SYMS] = {2, 3, 8, 9};

    // # of symbols produced after time domain cover code removal
    constexpr uint32_t N_DMRS_SYMS_TOCC = (1 == N_DMRS_SYMS) ? 1 : 2;
    // # of symbols produced after frequency domain cover code removal
    constexpr uint32_t N_DMRS_SYMS_FOCC = (1 == N_LAYERS) ? 1 : 2;
    // Total # of symbols after tOCC and fOCC removal
    constexpr uint32_t N_DMRS_SYMS_OCC = N_DMRS_SYMS_TOCC * N_DMRS_SYMS_FOCC;

    // Interpolation filter indices for middle and edge PRBs
    constexpr uint32_t MIDDLE_INTERP_FILT_IDX     = 0;
    constexpr uint32_t LOWER_EDGE_INTERP_FILT_IDX = 1;
    constexpr uint32_t UPPER_EDGE_INTERP_FILT_IDX = 2;

    // DMRS descrambling
    constexpr uint32_t N_DMRS_DESCR_BITS_PER_TONE    = 2; // 1bit for I and 1 bit for Q
    constexpr uint32_t N_DMRS_DESCR_BITS_PER_CLUSTER = N_DMRS_DESCR_BITS_PER_TONE * N_TOTAL_DMRS_GRID_TONES_PER_CLUSTER;
    // # of DMRS descrambler bits generated at one time
    constexpr uint32_t N_DMRS_DESCR_BITS_GEN         = 32;
    // Round up to the next multiple of N_DMRS_DESCR_BITS_GEN plus 1 (+1 because DMRS_DESCR_PRB_CLUSTER_START_BIT_OFFSET
    // may be large enough to spill the descrambler bits to the next word)
    constexpr uint32_t N_DMRS_DESCR_WORDS            = 
       ((N_DMRS_DESCR_BITS_PER_CLUSTER + N_DMRS_DESCR_BITS_GEN - 1)/N_DMRS_DESCR_BITS_GEN) + 1; 
      // round_up_to_next(N_DMRS_DESCR_BITS_PER_CLUSTER, N_DMRS_DESCR_BITS_GEN) + 1;

    const uint32_t ACTIVE_DMRS_GRID_BMSK = bit(N_MAX_DMRS_SYMS) - 1;

    // Total number of PRB clusers to be processed (N_PRB_CLUSTERS*N_DMRS_INTERP_PRB_OUT_PER_CLUSTER = N_DATA_PRB)
    const uint32_t N_PRB_CLUSTERS = gridDim.x;
    // PRB cluster being processed by this thread block
    const uint32_t PRB_CLUSTER_IDX = blockIdx.x;
    // BS antenna being processed by this thread block
    const uint32_t BS_ANT_IDX = blockIdx.y;

#ifdef ENABLE_DEBUG
    // printf("Block(%d %d %d) Thread(%d %d %d)\n", blockIdx.x, blockIdx.y, blockIdx.z, threadIdx.x, threadIdx.y, threadIdx.z);
    if((0 != BS_ANT_IDX) || (0 != PRB_CLUSTER_IDX)) return;
#endif

    const uint32_t THREAD_IDX = threadIdx.x;

    // # of PRBs for which channel must be estimated
    const uint32_t N_DATA_PRB = N_PRB_CLUSTERS * N_DMRS_INTERP_PRB_OUT_PER_CLUSTER;
    const uint32_t N_EDGE_PRB = 2; // Lower and Upper edge PRBs

    // Determine first PRB in the cluster being processed
    uint32_t prbAbsStartIdx = (PRB_CLUSTER_IDX * N_DMRS_INTERP_PRB_OUT_PER_CLUSTER) - N_EDGE_PRB;
    if(0 == PRB_CLUSTER_IDX) prbAbsStartIdx = 0;                                                         // Lower edge
    if((N_PRB_CLUSTERS - 1) == PRB_CLUSTER_IDX) prbAbsStartIdx = N_DATA_PRB - N_DMRS_PRB_IN_PER_CLUSTER; // Upper edge

    // Absolute index of DMRS tone within the input OFDM symbol (used as index when loading tone from OFDM
    // symbol)
    const uint32_t DMRS_ABS_TONE_IDX = prbAbsStartIdx * N_TONES_PER_PRB + THREAD_IDX;

    // This index callwlation intends to divvy up threads in the thread block for processing as follows:
    // the first group of N_TOTAL_DMRS_GRID_TONES_PER_CLUSTER to process the first DMRS grid, the second group
    // to process the second DMRS grid and so on
    // Relative index of DMRS tone (within a DMRS grid) being processed by this thread
    const uint32_t DMRS_TONE_IDX        = THREAD_IDX % N_TOTAL_DMRS_GRID_TONES_PER_CLUSTER;
    const uint32_t DMRS_INTERP_TONE_IDX = THREAD_IDX % N_TOTAL_DMRS_INTERP_GRID_TONES_PER_CLUSTER;

    // Index of DMRS grid in which the DMRS tone being processed by this thread resides
    // Note: although the grid index is callwlated using total number of DMRS grid tones in the cluster, its
    // used as an index in context of both input DMRS tones and interpolated DMRS tones under the assumption:
    // N_TOTAL_DMRS_GRID_TONES_PER_CLUSTER == N_TOTAL_DMRS_INTERP_GRID_TONES_PER_CLUSTER
    const uint32_t DMRS_GRID_IDX = THREAD_IDX / N_TOTAL_DMRS_GRID_TONES_PER_CLUSTER;

    // Index which enables extraction of DMRS tones of a given DMRS grid scattered within the PRB into one
    // contiguous set for processing. Note that the read from GMEM is coalesced and write into SMEM is scattered
    // @todo: check if index callwlation can be simplified
    const uint32_t SMEM_DMRS_TONE_IDX = get_smem_dmrs_tone_idx(N_DMRS_GRIDS_PER_PRB, N_INTER_DMRS_GRID_FREQ_SHIFT, THREAD_IDX);
    const uint32_t SMEM_DMRS_GRID_IDX = get_smem_dmrs_grid_idx(N_DMRS_GRIDS_PER_PRB, N_INTER_DMRS_GRID_FREQ_SHIFT, THREAD_IDX);

    // Absolute index of descrambling + shift sequence element
    const uint32_t DMRS_DESCR_SHIFT_SEQ_START_IDX = prbAbsStartIdx * N_DMRS_GRID_TONES_PER_PRB;
    const uint32_t DMRS_DESCR_SHIFT_SEQ_ABS_IDX   = DMRS_DESCR_SHIFT_SEQ_START_IDX + DMRS_TONE_IDX;

    // Absolute index of interpolated tone produced by this thread
    const uint32_t INTERP_PRB_CLUSTER_IDX   = blockIdx.x;
    const uint32_t INTERP_DMRS_ABS_TONE_IDX = INTERP_PRB_CLUSTER_IDX * N_DMRS_INTERP_PRB_OUT_PER_CLUSTER * N_TONES_PER_PRB + DMRS_INTERP_TONE_IDX;

    // Select one of 3 interpolation filters for middle section, lower and upper edges of the frequency band
    uint32_t filtIdx = MIDDLE_INTERP_FILT_IDX;                                        // All tones in between lower and upper edges
    if(0 == PRB_CLUSTER_IDX) filtIdx = LOWER_EDGE_INTERP_FILT_IDX;                    // Lower edge
    if((N_PRB_CLUSTERS - 1) == PRB_CLUSTER_IDX) filtIdx = UPPER_EDGE_INTERP_FILT_IDX; // Upper edge

    // Select the shift in interpolation filter coefficients and delay shift based on grid index
    // (for e.g. for 2 DMRS grids and 48 tones per grid, multiply DMRS tone vector with top 48 rows for
    // DMRS_GRID_IDX 0 and bottom 48 rows for DMRS_GRID_IDX 1 to acheieve the effect of shift)
    uint32_t gridShiftIdx = get_inter_dmrs_grid_freq_shift_idx(N_DMRS_GRIDS_PER_PRB, DMRS_GRID_IDX);

    // Section 5.2.1 in 3GPP TS 38.211
    // The fast-forward of 1600 prescribed by spec is already baked into the gold sequence generator
    constexpr uint32_t DMRS_DESCR_FF = 0; // 1600;

    // First descrambler bit index needed by this thread block
    // Note:The DMRS scrambling sequence is the same for all the DMRS grids. There are 2 sequences one for 
    // scid 0 and other for scid 1 but the same sequences is reused for all DMRS grids 
    const uint32_t DMRS_DESCR_PRB_CLUSTER_START_BIT =
       DMRS_DESCR_FF + (DMRS_DESCR_SHIFT_SEQ_START_IDX * N_DMRS_DESCR_BITS_PER_TONE);

    // The descrambling sequence generator outputs 32 descrambler bits at a time. Thus, compute the earliest
    // multiple of 32 bits which contains the descrambler bit of the first tone in the PRB cluster as the 
    // start index
    const uint32_t DMRS_DESCR_GEN_ALIGNED_START_BIT  =
       (DMRS_DESCR_PRB_CLUSTER_START_BIT / N_DMRS_DESCR_BITS_GEN) * N_DMRS_DESCR_BITS_GEN;
    // Offset to descrambler bit of the first tone in the PRB cluster
    const uint32_t DMRS_DESCR_PRB_CLUSTER_START_BIT_OFFSET =
        DMRS_DESCR_PRB_CLUSTER_START_BIT - DMRS_DESCR_GEN_ALIGNED_START_BIT;

    // DMRS descrambling bits generated correspond to subcarriers across frequency
    // e.g. 2 bits for tone0(grid 0) | 2 bits for tone1(grid 1) | 2 bits for tone 2(grid 0) | 2 bits for tone 3(grid 1) | ... 
    const uint32_t DMRS_TONE_DESCR_BIT_IDX = DMRS_DESCR_PRB_CLUSTER_START_BIT_OFFSET +
                                             (DMRS_TONE_IDX * N_DMRS_DESCR_BITS_PER_TONE);
    const uint32_t DMRS_DESCR_SEQ_RD_BIT_IDX  = DMRS_TONE_DESCR_BIT_IDX % N_DMRS_DESCR_BITS_GEN;
    const uint32_t DMRS_DESCR_SEQ_RD_WORD_IDX = DMRS_TONE_DESCR_BIT_IDX / N_DMRS_DESCR_BITS_GEN;

    const uint32_t DMRS_DESCR_SEQ_WR_WORD_IDX = THREAD_IDX % N_DMRS_DESCR_WORDS;
    const uint32_t DMRS_DESCR_SEQ_WR_SYM_IDX  = THREAD_IDX / N_DMRS_DESCR_WORDS;

#if 0
    if((0 == blockIdx.x) && (0 == blockIdx.y) && (0 == blockIdx.z))
       printf("N_DMRS_DESCR_BITS_PER_CLUSTER %d N_DMRS_DESCR_WORDS %d DMRS_DESCR_PRB_CLUSTER_START_BIT %d DMRS_DESCR_GEN_ALIGNED_START_BIT %d, "
              "DMRS_DESCR_SEQ_RD_WORD_IDX %d, DMRS_DESCR_SEQ_RD_BIT_IDX %d, DMRS_DESCR_SEQ_WR_WORD_IDX %d, DMRS_DESCR_SEQ_WR_SYM_IDX %d\n",
              N_DMRS_DESCR_BITS_PER_CLUSTER, N_DMRS_DESCR_WORDS, DMRS_DESCR_PRB_CLUSTER_START_BIT, DMRS_DESCR_GEN_ALIGNED_START_BIT, 
              DMRS_DESCR_SEQ_RD_WORD_IDX, DMRS_DESCR_SEQ_RD_BIT_IDX, DMRS_DESCR_SEQ_WR_WORD_IDX, DMRS_DESCR_SEQ_WR_SYM_IDX);
#endif
    
    // Data layouts:
    // Global memory read into shared memory
    // N_DMRS_TONES x N_DMRS_SYMS -> N_TOTAL_DMRS_GRID_TONES_PER_CLUSTER x N_DMRS_SYMS x N_DMRS_GRIDS_PER_PRB

    // tOCC removal
    // N_TOTAL_DMRS_GRID_TONES_PER_CLUSTER x N_DMRS_SYMS x N_DMRS_GRIDS_PER_PRB ->
    // N_TOTAL_DMRS_GRID_TONES_PER_CLUSTER x N_DMRS_SYMS_TOCC x N_DMRS_GRIDS_PER_PRB

    // fOCC removal
    // N_TOTAL_DMRS_GRID_TONES_PER_CLUSTER x N_DMRS_SYMS_TOCC x N_DMRS_GRIDS_PER_PRB ->
    // N_TOTAL_DMRS_GRID_TONES_PER_CLUSTER x N_DMRS_SYMS_FOCC x NUM_DMRS_SYMS_TOCC x N_DMRS_GRIDS_PER_PRB

    // Interpolation
    // N_TOTAL_DMRS_GRID_TONES_PER_CLUSTER x N_DMRS_SYMS_FOCC x NUM_DMRS_SYMS_TOCC x N_DMRS_GRIDS_PER_PRB ->
    // N_TOTAL_DMRS_INTERP_GRID_TONES_PER_CLUSTER x N_DMRS_SYMS_FOCC x NUM_DMRS_SYMS_TOCC x N_DMRS_GRIDS_PER_PRB =
    // N_TOTAL_DMRS_INTERP_GRID_TONES_PER_CLUSTER x N_LAYERS x N_DMRS_GRIDS_PER_PRB

    //--------------------------------------------------------------------------------------------------------
    // Allocate shared memory
    typedef typename complex_from_scalar<TCompute>::type TComplexCompute;
    typedef typename complex_from_scalar<TStorage>::type TComplexStorage;

    constexpr uint32_t N_SMEM_ELEMS1 = N_DMRS_TONES * N_DMRS_SYMS; // (N_DMRS_TONES + N_DMRS_GRIDS_PER_PRB)*N_DMRS_SYMS;
    constexpr uint32_t N_SMEM_ELEMS2 = N_INTERP_TONES * N_DMRS_SYMS_OCC;
    constexpr uint32_t N_SMEM_ELEMS  = (N_SMEM_ELEMS1 > N_SMEM_ELEMS2) ? N_SMEM_ELEMS1 : N_SMEM_ELEMS2;
    // constexpr uint32_t N_SMEM_ELEMS  = (N_SMEM_ELEMS1 + N_SMEM_ELEMS2);
    // constexpr uint32_t N_SMEM_ELEMS  = max(N_SMEM_ELEMS1, N_SMEM_ELEMS2);

    __shared__ TComplexCompute smemBlk[N_SMEM_ELEMS];
    // overlay1
    block_3D<TComplexCompute*, N_TOTAL_DMRS_GRID_TONES_PER_CLUSTER, N_DMRS_SYMS, N_DMRS_GRIDS_PER_PRB> shPilots(&smemBlk[0]);
    // overlay2
    block_3D<TComplexCompute*, N_TOTAL_DMRS_INTERP_GRID_TONES_PER_CLUSTER, N_DMRS_SYMS_OCC, N_DMRS_GRIDS_PER_PRB> shH(&smemBlk[0]);
    // block_3D<TComplexCompute*, N_TOTAL_DMRS_INTERP_GRID_TONES_PER_CLUSTER, N_DMRS_SYMS_OCC, N_DMRS_GRIDS_PER_PRB> shH(&smemBlk[shPilots.num_elem()]);
    static_assert((shPilots.num_elem() <= N_SMEM_ELEMS) && (shH.num_elem() <= N_SMEM_ELEMS), "Insufficient shared memory");

    __shared__ uint32_t descrWords[N_DMRS_SYMS][N_DMRS_DESCR_WORDS];

    //--------------------------------------------------------------------------------------------------------
    // Read DMRS tones into shared memory (separate the tones into different DMRS grids during the write)

    // Cache shift sequence in register
    TComplexCompute shiftSeq = type_colwert<TComplexCompute>(tShiftSeq(DMRS_DESCR_SHIFT_SEQ_ABS_IDX, 0));

#pragma unroll
    for(uint32_t i = 0; i < N_DMRS_SYMS; ++i)
    {
        shPilots(SMEM_DMRS_TONE_IDX, i, SMEM_DMRS_GRID_IDX) =
            type_colwert<TComplexCompute>(tDataRx(DMRS_ABS_TONE_IDX, DMRS_SYM_IDX[i], BS_ANT_IDX));

#ifdef ENABLE_DEBUG
        printf("Pilots[%d][%d][%d] -> shPilots[%d][%d][%d] = %f+j%f, ShiftSeq[%d][%d] = %f+j%f\n",
               DMRS_ABS_TONE_IDX,
               DMRS_SYM_IDX[i],
               BS_ANT_IDX,
               SMEM_DMRS_TONE_IDX,
               i,
               SMEM_DMRS_GRID_IDX,
               shPilots(SMEM_DMRS_TONE_IDX, i, SMEM_DMRS_GRID_IDX).x,
               shPilots(SMEM_DMRS_TONE_IDX, i, SMEM_DMRS_GRID_IDX).y,
               DMRS_DESCR_SHIFT_SEQ_ABS_IDX,
               0,
               shiftSeq.x,
               shiftSeq.y);
#endif
    }

    // Compute the descsrambler sequence
    // uint32_t cellId  = 40; // 10bit cell ID
    // int32_t slotNum = 8; // ? bit slot number
    uint32_t scId    = 0; 
    const uint32_t TWO_POW_17 = bit(17);

    if(DMRS_DESCR_SEQ_WR_SYM_IDX < N_DMRS_SYMS)
    {
        uint32_t symIdx = DMRS_SYM_IDX[DMRS_DESCR_SEQ_WR_SYM_IDX]; 

        // see 38.211 section 6.4.1.1.1.1
        uint32_t cInit = TWO_POW_17*(slotNum*OFDM_SYMBOLS_PER_SLOT + symIdx + 1)*(2*cellId + 1) + (2*cellId) + scId;
        cInit &= ~bit(31);

        // descrWords[DMRS_DESCR_SEQ_WR_SYM_IDX][DMRS_DESCR_SEQ_WR_WORD_IDX] = 
        //  __brev(gold32(cInit, (DMRS_DESCR_GEN_ALIGNED_START_BIT + DMRS_DESCR_SEQ_WR_WORD_IDX*N_DMRS_DESCR_BITS_GEN)));

        descrWords[DMRS_DESCR_SEQ_WR_SYM_IDX][DMRS_DESCR_SEQ_WR_WORD_IDX] = 
          gold32(cInit, (DMRS_DESCR_GEN_ALIGNED_START_BIT + DMRS_DESCR_SEQ_WR_WORD_IDX*N_DMRS_DESCR_BITS_GEN));
#if 0
        printf("symIdx %d, DMRS_DESCR_SEQ_WR_WORD_IDX %d, cInit 0x%08x, DMRS_DESCR_GEN_ALIGNED_START_BIT %d, descrWords[%d][%d] 0x%08x\n", 
               symIdx, DMRS_DESCR_SEQ_WR_WORD_IDX, cInit, 
               (DMRS_DESCR_GEN_ALIGNED_START_BIT + DMRS_DESCR_SEQ_WR_WORD_IDX*N_DMRS_DESCR_BITS_GEN), 
               DMRS_DESCR_SEQ_WR_SYM_IDX, DMRS_DESCR_SEQ_WR_WORD_IDX, descrWords[DMRS_DESCR_SEQ_WR_SYM_IDX][DMRS_DESCR_SEQ_WR_WORD_IDX]);
#endif
    }

    // To ensure coalesced reads, input DMRS tones are read preserving input order but swizzled while writing
    // to shared memory. Thus each thread may not process the same tone which it wrote to shared memory
    thread_block const& thisThrdBlk = this_thread_block();
    thisThrdBlk.sync();

    //--------------------------------------------------------------------------------------------------------
    // Apply de-scrambling + delay domain centering sequence for tone index processed by this thread across all
    // DMRS symbols
    const TCompute RECIPROCAL_SQRT2 = 0.7071068f;

#pragma unroll
    for(uint32_t i = 0; i < N_DMRS_SYMS; ++i)
    {
        int8_t descrIBit = (descrWords[i][DMRS_DESCR_SEQ_RD_WORD_IDX] >> DMRS_DESCR_SEQ_RD_BIT_IDX) & 0x1;
        int8_t descrQBit = (descrWords[i][DMRS_DESCR_SEQ_RD_WORD_IDX] >> (DMRS_DESCR_SEQ_RD_BIT_IDX + 1)) & 0x1;

        TComplexCompute descrCode = 
           lwConj(lwGet<TComplexCompute>((1 - 2*descrIBit)*RECIPROCAL_SQRT2, (1 - 2*descrQBit)*RECIPROCAL_SQRT2));
        TComplexCompute descrShiftSeq = shiftSeq * descrCode;

#ifdef ENABLE_DEBUG
        TComplexCompute descrShiftPilot = shPilots(DMRS_TONE_IDX, i, DMRS_GRID_IDX) * descrShiftSeq;
        printf("descrShiftAbsIdx: %d, shPilots[%d][%d][%d] (%f+j%f) * DescrShiftSeq[%d][%d] (%f+j%f) = %f+j%f, ShiftSeq = %f+j%f, DescrCode = %f+j%f, descrIQ (%d,%d) descrWordIdx %d descrBitIdx %d\n",
               DMRS_DESCR_SHIFT_SEQ_ABS_IDX,
               DMRS_TONE_IDX,
               i,
               DMRS_GRID_IDX,
               shPilots(DMRS_TONE_IDX, i, DMRS_GRID_IDX).x,
               shPilots(DMRS_TONE_IDX, i, DMRS_GRID_IDX).y,
               DMRS_TONE_IDX,
               i,
               descrShiftSeq.x,
               descrShiftSeq.y,
               descrShiftPilot.x,
               descrShiftPilot.y,
               shiftSeq.x,
               shiftSeq.y,
               descrCode.x,
               descrCode.y,
               descrIBit,
               descrQBit,
               DMRS_DESCR_SEQ_RD_WORD_IDX,
               DMRS_DESCR_SEQ_RD_BIT_IDX);
        if((0 == DMRS_GRID_IDX) && ( ((0 == prbAbsStartIdx) && (DMRS_TONE_IDX < (N_EDGE_PRB*N_DMRS_GRID_TONES_PER_PRB))) || ((0 != prbAbsStartIdx) && (prbAbsStartIdx + N_DMRS_PRB_IN_PER_CLUSTER) <= N_DATA_PRB)))
        {
#if 0
           TComplexCompute descrShiftPilot = shPilots(DMRS_TONE_IDX, i, DMRS_GRID_IDX) * descrShiftSeq;
           printf("descrShiftAbsIdx: %d shPilots[%d][%d][%d] (%f+j%f) * DescrShiftSeq[%d][%d] (%f+j%f) = %f+j%f, ShiftSeq = %f+j%f, DescrCode = %f+j%f, descrIQ (%d,%d) descrWordIdx %d descrBitIdx %d\n",
                 DMRS_DESCR_SHIFT_SEQ_ABS_IDX,
                 DMRS_TONE_IDX,
                 i,
                 DMRS_GRID_IDX,
                 shPilots(DMRS_TONE_IDX, i, DMRS_GRID_IDX).x,
                 shPilots(DMRS_TONE_IDX, i, DMRS_GRID_IDX).y,
                 DMRS_TONE_IDX,
                 i,
                 descrShiftSeq.x,
                 descrShiftSeq.y,
                 descrShiftPilot.x,
                 descrShiftPilot.y,
                 shiftSeq.x,
                 shiftSeq.y,
                 descrCode.x,
                 descrCode.y,
                 descrIBit,
                 descrQBit,
                 DMRS_DESCR_SEQ_RD_WORD_IDX,
                 DMRS_DESCR_SEQ_RD_BIT_IDX);
#endif
               
             // tDbg(DMRS_DESCR_SHIFT_SEQ_ABS_IDX, i, 0, 0) = type_colwert<TComplexStorage>(shiftSeq);
             // tDbg(DMRS_DESCR_SHIFT_SEQ_ABS_IDX, i, 0, 0) = type_colwert<TComplexStorage>(descrShiftSeq);
             tDbg(DMRS_DESCR_SHIFT_SEQ_ABS_IDX, i, 0, 0) = type_colwert<TComplexStorage>(descrCode);
        }
#endif // ENABLE_DEBUG

        shPilots(DMRS_TONE_IDX, i, DMRS_GRID_IDX) *= descrShiftSeq;
    }

    //--------------------------------------------------------------------------------------------------------
    // Time domain cover code removal
    constexpr TCompute AVG_SCALE = lwGet<TCompute>(1u) / lwGet<TCompute>(N_DMRS_SYMS);
    TComplexCompute avg[N_DMRS_SYMS_TOCC]{};

#pragma unroll
    for(int32_t i = 0; i < N_DMRS_SYMS_TOCC; ++i)
    {
#pragma unroll
        for(int32_t j = 0; j < N_DMRS_SYMS; ++j)
        {
            // For first tOCC (i = 0) output, multiply all DMRS symbols with +1 and average
            // For second tOCC (i = 1) output, multiply even DMRS symbols with +1, odd DMRS symbols with -1 and average
            int32_t sign = (-(i & j)) | 1;
            avg[i] += (shPilots(DMRS_TONE_IDX, j, DMRS_GRID_IDX) * (sign * AVG_SCALE));
#ifdef ENABLE_DEBUG
            TComplexCompute prod = (shPilots(DMRS_TONE_IDX, j, DMRS_GRID_IDX) * (sign * AVG_SCALE));
            printf("sign*AVG_SCALE %f Pilot[%d][%d][%d] = %f+j%f avg[%d] = %f+j%f, prod = %f+j%f\n",
                   sign * AVG_SCALE,
                   DMRS_TONE_IDX,
                   j,
                   DMRS_GRID_IDX,
                   shPilots(DMRS_TONE_IDX, j, DMRS_GRID_IDX).x,
                   shPilots(DMRS_TONE_IDX, j, DMRS_GRID_IDX).y,
                   i,
                   avg[i].x,
                   avg[i].y,
                   prod.x,
                   prod.y);
#endif
        }
    }

    // shPilots and shH are overlaid in shared memory and can have different sizes (based on config). For this reason
    // ensure shPilots access from all threads is completed before writing into shH
    thisThrdBlk.sync();

    //--------------------------------------------------------------------------------------------------------
    // Apply frequecy domain cover code and store inplace in shared memory
    // Multiply even tones with +1 and odd tones with -1

    // Note that the loop termination count below is tOCC symbol count
#pragma unroll
    for(int32_t i = 0; i < N_DMRS_SYMS_TOCC; ++i)
    {
#pragma unroll
        for(int32_t j = 0; j < N_DMRS_SYMS_FOCC; ++j)
        {
           // First fOCC output: multiply all tones by +1s
           // Second fOCC output: multiply even tones by +1s and odd tones by -1s
           int32_t sign = (-(DMRS_TONE_IDX & j)) | 1;
           shH(DMRS_TONE_IDX, (N_DMRS_SYMS_FOCC * i) + j, DMRS_GRID_IDX) = avg[i] * sign;

#ifdef ENABLE_DEBUG
           printf("PilotsPostOCC[%d][%d][%d] = %f+j%f\n",
                  DMRS_TONE_IDX,
                  (N_DMRS_SYMS_FOCC * i) + j,
                  DMRS_GRID_IDX,
                  lwReal(shH(DMRS_TONE_IDX, (N_DMRS_SYMS_FOCC * i) + j, DMRS_GRID_IDX)),
                  lwImag(shH(DMRS_TONE_IDX, (N_DMRS_SYMS_FOCC * i) + j, DMRS_GRID_IDX)));
#endif
        }
   }

    // Ensure all threads complete writing results to shared memory since each thread computing an inner product
    // during interpolation stage will use results from other threads in the thread block
    thisThrdBlk.sync();

    //--------------------------------------------------------------------------------------------------------
    // Interpolate (matrix-vector multiply)
    for(uint32_t i = 0; i < N_DMRS_SYMS_OCC; ++i)
    {
        TComplexCompute innerProd{};

        // H = W x Y: (N_INTERP_TONES x N_DMRS_TONES) x (N_TOTAL_DMRS_GRID_TONES_PER_CLUSTER x N_DMRS_SYMS_OCC)
        // Each thread selects one row of W and computes N_DMRS_TONES length inner product to produce one interpolated
        // tone of H
        for(uint32_t j = 0; j < N_TOTAL_DMRS_GRID_TONES_PER_CLUSTER; ++j)
        {
            TCompute interpCoef = type_colwert<TCompute>(tWFreq(DMRS_INTERP_TONE_IDX + gridShiftIdx, j, filtIdx));
            innerProd += (shH(j, i, DMRS_GRID_IDX) * interpCoef);
        }
        // Wait for all threads to complete their inner products before updating the shared memory inplace
        // The sync is needed because shPilots and shH are overlaid
        thisThrdBlk.sync();

        shH(DMRS_INTERP_TONE_IDX, i, DMRS_GRID_IDX) = innerProd;

#ifdef ENABLE_DEBUG
        printf("InterpPilots[%d][%d][%d] = %f+j%f\n", DMRS_INTERP_TONE_IDX, i, DMRS_GRID_IDX, innerProd.x, innerProd.y);
#endif
    }

    // Wait for shared memory writes to complete from all threads
    thisThrdBlk.sync();

    // Write channel estimates for active grids only
    const int32_t DMRS_GRID_WR_IDX = DMRS_GRID_WR_IDX_TBL[activeDMRSGridBmsk & ACTIVE_DMRS_GRID_BMSK][DMRS_GRID_IDX];
    // if(!is_set(bit(DMRS_GRID_IDX), activeDMRSGridBmsk) || (DMRS_GRID_WR_IDX < 0)) return;
    if(DMRS_GRID_WR_IDX < 0) return;

    //--------------------------------------------------------------------------------------------------------
    // Unshift the channel in delay back to its original location and write to GMEM. This is a scattered write
    // (@todo: any opportunities to make it coalesced?)
    // Output format is N_BS_ANT x (N_DMRS_SYMS_FOCC x N_DMRS_SYMS_TOCC x N_DMRS_GRIDS_PER_PRB) x N_DMRS_INTERP_PRB_OUT_PER_CLUSTER
    // where N_DMRS_SYMS_FOCC x N_DMRS_SYMS_TOCC x N_DMRS_GRIDS_PER_PRB = N_LAYERS
    const uint32_t DMRS_GRID_OFFSET_H = DMRS_GRID_WR_IDX * N_DMRS_SYMS_OCC;

#ifdef CH_EST_COALESCED_WRITE
    // H (N_DATA_PRB*N_TONES_PER_PRB, N_LAYERS, N_BS_ANTS, NH)
    TComplexStorage* pHEst = tHEst.addr + ((NH_IDX * N_BS_ANTS + BS_ANT_IDX) * N_LAYERS * N_DATA_PRB * N_TONES_PER_PRB);
#endif

#pragma unroll
    for(uint32_t i = 0; i < N_DMRS_SYMS_OCC; ++i)
    {
        shH(DMRS_INTERP_TONE_IDX, i, DMRS_GRID_IDX) *=
            type_colwert<TComplexCompute>(tUnShiftSeq(INTERP_DMRS_ABS_TONE_IDX + gridShiftIdx));

#ifndef CH_EST_COALESCED_WRITE
        tHEst(BS_ANT_IDX, DMRS_GRID_OFFSET_H + i, INTERP_DMRS_ABS_TONE_IDX, NH_IDX) =
            type_colwert<TComplexStorage>(shH(DMRS_INTERP_TONE_IDX, i, DMRS_GRID_IDX));
#else
        pHEst[(DMRS_GRID_OFFSET_H + i) * N_DATA_PRB * N_TONES_PER_PRB + INTERP_DMRS_ABS_TONE_IDX] =
            type_colwert<TComplexStorage>(shH(DMRS_INTERP_TONE_IDX, i, DMRS_GRID_IDX));
#endif

#ifdef ENABLE_DEBUG
#if 0 
     printf("shH[%d][%d][%d] = %f+j%f\n", DMRS_INTERP_TONE_IDX, i, DMRS_GRID_IDX,
         shH(DMRS_INTERP_TONE_IDX, i, DMRS_GRID_IDX).x, shH(DMRS_INTERP_TONE_IDX, i, DMRS_GRID_IDX).y);
#endif
#if 0     
      printf("tH[%d][%d][%d][%d] = %f+j%f\n", BS_ANT_IDX, DMRS_GRID_OFFSET_H + i, INTERP_DMRS_ABS_TONE_IDX, NH_IDX,
         tHEst(BS_ANT_IDX, DMRS_GRID_OFFSET_H + i, INTERP_DMRS_ABS_TONE_IDX, NH_IDX).x,
         tHEst(BS_ANT_IDX, DMRS_GRID_OFFSET_H + i, INTERP_DMRS_ABS_TONE_IDX, NH_IDX).y);
#endif
#if 0
       printf("tUnshift[%d] = %f+j%f\n", INTERP_DMRS_ABS_TONE_IDX + gridShiftIdx,tUnShiftSeq(INTERP_DMRS_ABS_TONE_IDX + gridShiftIdx).x, tUnShiftSeq(INTERP_DMRS_ABS_TONE_IDX + gridShiftIdx).y);
 
       printf("tH[%d][%d][%d][%d] = %f+j%f\n", BS_ANT_IDX, DMRS_GRID_OFFSET_H + i, INTERP_DMRS_ABS_TONE_IDX, NH_IDX,
         tHEst(BS_ANT_IDX, DMRS_GRID_OFFSET_H + i, INTERP_DMRS_ABS_TONE_IDX, NH_IDX).x,
         tHEst(BS_ANT_IDX, DMRS_GRID_OFFSET_H + i, INTERP_DMRS_ABS_TONE_IDX, NH_IDX).y);
#endif
#endif
    }
}

template <typename TStorage,
          typename TDataRx,
          typename TCompute,
          uint32_t N_BS_ANTS,                         // # of BS antenna (# of rows in H matrix)
          uint32_t N_LAYERS,                          // # of layers (# of cols in H matrix)
          uint32_t N_DMRS_GRIDS_PER_PRB,              // # of DMRS grids per PRB (2 or 3)
          uint32_t N_DMRS_PRB_IN_PER_CLUSTER,         // # of PRBs bearing DMRS tones to be processed by each thread block (i.e. used in channel estimation)
          uint32_t N_DMRS_INTERP_PRB_OUT_PER_CLUSTER, // # of PRBs bearing interpolated tones at output
          uint32_t N_DMRS_SYMS>                       // # of time domain DMRS symbols (1,2 or 4)
void
windowed_ch_est_kernel_launch(uint32_t           cellId,
                              uint32_t           slotNum,
                              uint32_t           activeDMRSGridBmsk,
                              uint32_t           nTotalDMRSPRB,
                              uint32_t           nTotalDataPRB,
                              const_tensor_pair& tDataRx,
                              const_tensor_pair& tWFreq,
                              const_tensor_pair& tShiftSeq,
                              const_tensor_pair& tUnShiftSeq,
                              tensor_pair&       tHEst,
                              tensor_pair&       tDbg,
                              lwdaStream_t       strm)
{
    constexpr uint32_t N_TOTAL_INPUT_TONES = N_DMRS_PRB_IN_PER_CLUSTER * N_TONES_PER_PRB;
    static_assert((N_TOTAL_INPUT_TONES % N_THREADS_PER_WARP == 0),
                  "Expect total number of input tones to be a multiple of warp size");
    constexpr uint32_t N_TOTAL_OUTPUT_TONES = N_DMRS_INTERP_PRB_OUT_PER_CLUSTER * N_DMRS_GRIDS_PER_PRB * N_TONES_PER_PRB;
    static_assert((N_TOTAL_OUTPUT_TONES % N_THREADS_PER_WARP == 0),
                  "Expect total number of output tones to be a multiple of warp size");
    static_assert((N_TOTAL_INPUT_TONES == N_TOTAL_OUTPUT_TONES),
                  "Thread allocation assumes input DMRS tone count and interpolated tone count are equal, ensure sufficient threads are allocated for interpoloation etc");

    const uint32_t N_THREAD_BLKS_PER_BS_ANT = nTotalDataPRB / N_DMRS_INTERP_PRB_OUT_PER_CLUSTER;
    dim3           gridDim(N_THREAD_BLKS_PER_BS_ANT, N_BS_ANTS);
    dim3           blockDim(N_TOTAL_OUTPUT_TONES);

#ifdef ENABLE_DEBUG
    printf("blockDim (%d,%d,%d), gridDim (%d,%d,%d)\n", blockDim.x, blockDim.y, blockDim.z, gridDim.x, gridDim.y, gridDim.z);
#endif

    typedef typename complex_from_scalar<TStorage>::type TComplexStorage;
    typedef typename complex_from_scalar<TDataRx>::type  TComplexDataRx;

    tensor_ref<const TComplexDataRx, 3>  DataRx(tDataRx);
    tensor_ref<const TStorage, 3>        WFreq(tWFreq);
    tensor_ref<const TComplexStorage, 2> ShiftSeq(tShiftSeq);
    tensor_ref<const TComplexStorage, 1> UnShiftSeq(tUnShiftSeq);

    tensor_ref<TComplexStorage, 4> HEst(tHEst);
    tensor_ref<TComplexStorage, 4> Dbg(tDbg);

    windowed_ch_est_kernel<TStorage,
                           TDataRx,
                           TCompute,
                           N_BS_ANTS,
                           N_LAYERS,
                           N_DMRS_GRIDS_PER_PRB,
                           N_DMRS_PRB_IN_PER_CLUSTER,
                           N_DMRS_INTERP_PRB_OUT_PER_CLUSTER,
                           N_DMRS_SYMS>
        <<<gridDim, blockDim, 0, strm>>>(cellId,
                                         slotNum,
                                         activeDMRSGridBmsk,
                                         DataRx,
                                         WFreq,
                                         ShiftSeq,
                                         UnShiftSeq,
                                         HEst,
                                         Dbg);

#ifdef ENABLE_PROFILING
    lwdaEvent_t eStart, eStop;

    LWDA_CHECK(lwdaEventCreateWithFlags(&eStart, lwdaEventBlockingSync));
    LWDA_CHECK(lwdaEventCreateWithFlags(&eStop, lwdaEventBlockingSync));

    constexpr uint32_t N_ITER = 1000;
    LWDA_CHECK(lwdaEventRecord(eStart));

    for(uint32_t i = 0; i < N_ITER; ++i)
    {
        windowed_ch_est_kernel<TStorage,
                               TDataRx,
                               TCompute,
                               N_BS_ANTS,
                               N_LAYERS,
                               N_DMRS_GRIDS_PER_PRB,
                               N_DMRS_PRB_IN_PER_CLUSTER,
                               N_DMRS_INTERP_PRB_OUT_PER_CLUSTER,
                               N_DMRS_SYMS>
            <<<gridDim, blockDim, 0, strm>>>(activeDMRSGridBmsk,
                                             DataRx,
                                             WFreq,
                                             ShiftSeq,
                                             UnShiftSeq,
                                             HEst,
                                             Dbg);
    }

    LWDA_CHECK(lwdaEventRecord(eStop));
    LWDA_CHECK(lwdaEventSynchronize(eStop));

    float elapsedMs = 0.0f;
    lwdaEventElapsedTime(&elapsedMs, eStart, eStop);

    printf("Average elapsed time in usec (LWCA event) = %.0f\n", elapsedMs * 1000 / N_ITER);

    LWDA_CHECK(lwdaEventDestroy(eStart));
    LWDA_CHECK(lwdaEventDestroy(eStop));
#endif
}

template <typename TStorage, typename TDataRx, typename TCompute>
void ch_est_kernel_launch(uint32_t           cellId,
                          uint32_t           slotNum,
                          uint32_t           nBSAnts,
                          uint32_t           nLayers,
                          uint32_t           nDMRSSyms,
                          uint32_t           nDMRSGridsPerPRB,
                          uint32_t           activeDMRSGridBmsk,
                          uint32_t           nTotalDMRSPRB,
                          uint32_t           nTotalDataPRB,
                          uint32_t           Nh,
                          const_tensor_pair& tDataRx,
                          const_tensor_pair& tWFreq,
                          const_tensor_pair& tShiftSeq,
                          const_tensor_pair& tUnShiftSeq,
                          tensor_pair&       tHEst,
                          tensor_pair&       tDbg,
                          lwdaStream_t       strm)
{
    // Check below ensures the parameters match the dimensions assumed in the kernel. Among others it ensures
    // that nTotalDMRSPRB is divisible by N_DMRS_PRB_IN_PER_CLUSTER and nTotalDataPRB is divisible by N_DMRS_INTERP_PRB_OUT_PER_CLUSTER
    if(((16 == nBSAnts) || (8 == nBSAnts)) && (8 == nLayers) && (2 == nDMRSGridsPerPRB) && (0 == (nTotalDMRSPRB % 8)) &&
       (4 == nDMRSSyms) && (1 == Nh) && (0 == (nTotalDataPRB % 4)))
    {
        constexpr uint32_t N_LAYERS                          = 8;  // # of layers (# of cols in H matrix)
        constexpr uint32_t N_DMRS_GRIDS_PER_PRB              = 2;  // 2 grids => 6 grid tones per PRB
        constexpr uint32_t N_DMRS_PRB_IN_PER_CLUSTER         = 8;  // # of DMRS PRBs processed by a thread block
        constexpr uint32_t N_DMRS_INTERP_PRB_OUT_PER_CLUSTER = 4;  // # of DMRS interpolated PRBs produced by a thread block
        constexpr uint32_t N_DMRS_SYMS                       = 4;  // # of DMRS symbols

        switch(nBSAnts)
        {
           case 16:
           {
              constexpr uint32_t N_BS_ANTS = 16; // # of BS antenna (# of rows in H matrix)
              windowed_ch_est_kernel_launch<TStorage,
                                            TDataRx,
                                            TCompute,
                                            N_BS_ANTS,
                                            N_LAYERS,
                                            N_DMRS_GRIDS_PER_PRB,
                                            N_DMRS_PRB_IN_PER_CLUSTER,
                                            N_DMRS_INTERP_PRB_OUT_PER_CLUSTER,
                                            N_DMRS_SYMS>(cellId,
                                                         slotNum,
                                                         activeDMRSGridBmsk,
                                                         nTotalDMRSPRB,
                                                         nTotalDataPRB,
                                                         tDataRx,
                                                         tWFreq,
                                                         tShiftSeq,
                                                         tUnShiftSeq,
                                                         tHEst,
                                                         tDbg,
                                                         strm);
              break;
           } // nBSAnts = 16

           case 8:
           {
              constexpr uint32_t N_BS_ANTS = 8; // # of BS antenna (# of rows in H matrix)
              windowed_ch_est_kernel_launch<TStorage,
                                            TDataRx,
                                            TCompute,
                                            N_BS_ANTS,
                                            N_LAYERS,
                                            N_DMRS_GRIDS_PER_PRB,
                                            N_DMRS_PRB_IN_PER_CLUSTER,
                                            N_DMRS_INTERP_PRB_OUT_PER_CLUSTER,
                                            N_DMRS_SYMS>(cellId,
                                                         slotNum,
                                                         activeDMRSGridBmsk,
                                                         nTotalDMRSPRB,
                                                         nTotalDataPRB,
                                                         tDataRx,
                                                         tWFreq,
                                                         tShiftSeq,
                                                         tUnShiftSeq,
                                                         tHEst,
                                                         tDbg,
                                                         strm);
              break;
           } // nBSAnts = 8
        }
    }
    else if((8 == nBSAnts) && (4 == nLayers) && (2 == nDMRSGridsPerPRB) && (0 == (nTotalDMRSPRB % 8)) &&
            (2 == nDMRSSyms) && (1 == Nh) && (0 == (nTotalDataPRB % 4)))
    {
        constexpr uint32_t N_BS_ANTS                         = 8; // # of BS antenna (# of rows in H matrix)
        constexpr uint32_t N_LAYERS                          = 4; // # of layers (# of cols in H matrix)
        constexpr uint32_t N_DMRS_GRIDS_PER_PRB              = 2; // 2 grids => 6 grid tones per PRB
        constexpr uint32_t N_DMRS_PRB_IN_PER_CLUSTER         = 8; // # of DMRS PRBs processed by a thread block
        constexpr uint32_t N_DMRS_INTERP_PRB_OUT_PER_CLUSTER = 4; // # of DMRS interpolated PRBs produced by a thread block
        constexpr uint32_t N_DMRS_SYMS                       = 2; // # of DMRS symbols

        windowed_ch_est_kernel_launch<TStorage,
                                      TDataRx,
                                      TCompute,
                                      N_BS_ANTS,
                                      N_LAYERS,
                                      N_DMRS_GRIDS_PER_PRB,
                                      N_DMRS_PRB_IN_PER_CLUSTER,
                                      N_DMRS_INTERP_PRB_OUT_PER_CLUSTER,
                                      N_DMRS_SYMS>(cellId,
                                                   slotNum,
                                                   activeDMRSGridBmsk,
                                                   nTotalDMRSPRB,
                                                   nTotalDataPRB,
                                                   tDataRx,
                                                   tWFreq,
                                                   tShiftSeq,
                                                   tUnShiftSeq,
                                                   tHEst,
                                                   tDbg,
                                                   strm);
    }
    else if(((4 == nBSAnts) || (8 == nBSAnts)) && ((4 == nLayers) || (2 == nLayers) || (1 == nLayers)) && 
            (2 == nDMRSGridsPerPRB) && (0 == (nTotalDMRSPRB % 8)) &&
            (1 == nDMRSSyms) && (1 == Nh) && (0 == (nTotalDataPRB % 4)))
    {
        constexpr uint32_t N_DMRS_GRIDS_PER_PRB              = 2; // 2 grids => 6 grid tones per PRB
        constexpr uint32_t N_DMRS_PRB_IN_PER_CLUSTER         = 8; // # of DMRS PRBs processed by a thread block
        constexpr uint32_t N_DMRS_INTERP_PRB_OUT_PER_CLUSTER = 4; // # of DMRS interpolated PRBs produced by a thread block
        constexpr uint32_t N_DMRS_SYMS                       = 1; // # of DMRS symbols

        switch(nBSAnts)
        {
            case 8:
            {
                constexpr uint32_t N_BS_ANTS = 8; // # of BS antenna (# of rows in H matrix)
                switch(nLayers)
                {
                    case 4:
                    case 2:
                    {  
                       constexpr uint32_t N_LAYERS = 4;  // # of layers (# of cols in H matrix)
                       windowed_ch_est_kernel_launch<TStorage,
                                                     TDataRx,
                                                     TCompute,
                                                     N_BS_ANTS,
                                                     N_LAYERS,
                                                     N_DMRS_GRIDS_PER_PRB,
                                                     N_DMRS_PRB_IN_PER_CLUSTER,
                                                     N_DMRS_INTERP_PRB_OUT_PER_CLUSTER,
                                                     N_DMRS_SYMS>(cellId,
                                                                  slotNum,
                                                                  activeDMRSGridBmsk,
                                                                  nTotalDMRSPRB,
                                                                  nTotalDataPRB,
                                                                  tDataRx,
                                                                  tWFreq,
                                                                  tShiftSeq,
                                                                  tUnShiftSeq,
                                                                  tHEst,
                                                                  tDbg,
                                                                  strm);
         
                        break;
                    } // nLayers = 2,4
        
                    case 1:
                    {
                       constexpr uint32_t N_LAYERS = 1;  // # of layers (# of cols in H matrix)
                       windowed_ch_est_kernel_launch<TStorage,
                                                     TDataRx,
                                                     TCompute,
                                                     N_BS_ANTS,
                                                     N_LAYERS,
                                                     N_DMRS_GRIDS_PER_PRB,
                                                     N_DMRS_PRB_IN_PER_CLUSTER,
                                                     N_DMRS_INTERP_PRB_OUT_PER_CLUSTER,
                                                     N_DMRS_SYMS>(cellId,
                                                                  slotNum,
                                                                  activeDMRSGridBmsk,
                                                                  nTotalDMRSPRB,
                                                                  nTotalDataPRB,
                                                                  tDataRx,
                                                                  tWFreq,
                                                                  tShiftSeq,
                                                                  tUnShiftSeq,
                                                                  tHEst,
                                                                  tDbg,
                                                                  strm);
         
        
        
                       break;
                    } // nLayers = 1
                } // nLayers
                break;
            } // nBSAnts = 8
            
            case 4:
            {
                constexpr uint32_t N_BS_ANTS = 4; // # of BS antenna (# of rows in H matrix)
                switch(nLayers)
                {
                    case 4:
                    case 2:
                    {  
                       constexpr uint32_t N_LAYERS = 4;  // # of layers (# of cols in H matrix)
                       windowed_ch_est_kernel_launch<TStorage,
                                                     TDataRx,
                                                     TCompute,
                                                     N_BS_ANTS,
                                                     N_LAYERS,
                                                     N_DMRS_GRIDS_PER_PRB,
                                                     N_DMRS_PRB_IN_PER_CLUSTER,
                                                     N_DMRS_INTERP_PRB_OUT_PER_CLUSTER,
                                                     N_DMRS_SYMS>(cellId,
                                                                  slotNum,
                                                                  activeDMRSGridBmsk,
                                                                  nTotalDMRSPRB,
                                                                  nTotalDataPRB,
                                                                  tDataRx,
                                                                  tWFreq,
                                                                  tShiftSeq,
                                                                  tUnShiftSeq,
                                                                  tHEst,
                                                                  tDbg,
                                                                  strm);
         
                        break;
                    } // nLayers = 2,4
        
                    case 1:
                    {
                       constexpr uint32_t N_LAYERS = 1;  // # of layers (# of cols in H matrix)
                       windowed_ch_est_kernel_launch<TStorage,
                                                     TDataRx,
                                                     TCompute,
                                                     N_BS_ANTS,
                                                     N_LAYERS,
                                                     N_DMRS_GRIDS_PER_PRB,
                                                     N_DMRS_PRB_IN_PER_CLUSTER,
                                                     N_DMRS_INTERP_PRB_OUT_PER_CLUSTER,
                                                     N_DMRS_SYMS>(cellId,
                                                                  slotNum,
                                                                  activeDMRSGridBmsk,
                                                                  nTotalDMRSPRB,
                                                                  nTotalDataPRB,
                                                                  tDataRx,
                                                                  tWFreq,
                                                                  tShiftSeq,
                                                                  tUnShiftSeq,
                                                                  tHEst,
                                                                  tDbg,
                                                                  strm);
         
        
        
                       break;
                    } // nLayers = 1
                } // nLayers
                break;
            } // nBSAnts = 4 
        }
    }
    else
    {
        printf("Channel est: No kernel available to launch with requested configuration: nBSAnts %d nLayers %d "
               "nDMRSGridsPerPRB %d TotalDMRSPRB %d nDMRSSyms %d Nh %d nTotalDataPRB %d \n",
               nBSAnts,
               nLayers,
               nDMRSGridsPerPRB,
               nTotalDMRSPRB,
               nDMRSSyms,
               Nh,
               nTotalDataPRB);
    }
}

void estimate_channel(uint32_t           cellId,
                      uint32_t           slotNum,
                      uint32_t           nBSAnts,
                      uint32_t           nLayers,
                      uint32_t           nDMRSSyms,
                      uint32_t           nDMRSGridsPerPRB,
                      uint32_t           activeDMRSGridBmsk,
                      uint32_t           nTotalDMRSPRB,
                      uint32_t           nTotalDataPRB,
                      uint32_t           Nh,
                      const_tensor_pair& tDataRx,
                      const_tensor_pair& tWFreq,
                      const_tensor_pair& tShiftSeq,
                      const_tensor_pair& tUnShiftSeq,
                      tensor_pair&       tH,
                      tensor_pair&       tDbg,
                      lwdaStream_t       strm)
{
    //printf("ch_est::estimate_channel() begin()\n");
    using TCompute = float;
    if(LWPHY_C_32F == tH.first.get().type())
    {
        using TStorage = scalar_from_complex<data_type_traits<LWPHY_C_32F>::type>::type;
        if(LWPHY_C_32F == tDataRx.first.get().type())
        {
            using TDataRx = scalar_from_complex<data_type_traits<LWPHY_C_32F>::type>::type;
            ch_est_kernel_launch<TStorage, TDataRx, TCompute>(cellId,
                                                              slotNum,
                                                              nBSAnts,
                                                              nLayers,
                                                              nDMRSSyms,
                                                              nDMRSGridsPerPRB,
                                                              activeDMRSGridBmsk,
                                                              nTotalDMRSPRB,
                                                              nTotalDataPRB,
                                                              Nh,
                                                              tDataRx,
                                                              tWFreq,
                                                              tShiftSeq,
                                                              tUnShiftSeq,
                                                              tH,
                                                              tDbg,
                                                              strm);
        }
        else if(LWPHY_C_16F == tDataRx.first.get().type())
        {
            using TDataRx = scalar_from_complex<data_type_traits<LWPHY_C_16F>::type>::type;
            ch_est_kernel_launch<TStorage, TDataRx, TCompute>(cellId,
                                                              slotNum,
                                                              nBSAnts,
                                                              nLayers,
                                                              nDMRSSyms,
                                                              nDMRSGridsPerPRB,
                                                              activeDMRSGridBmsk,
                                                              nTotalDMRSPRB,
                                                              nTotalDataPRB,
                                                              Nh,
                                                              tDataRx,
                                                              tWFreq,
                                                              tShiftSeq,
                                                              tUnShiftSeq,
                                                              tH,
                                                              tDbg,
                                                              strm);
 
        }
        else
        {
            printf("Channel Est: No kernel available to launch with requested date type\n");
        }
    }
    else if((LWPHY_C_16F == tH.first.get().type()) && (LWPHY_C_16F == tDataRx.first.get().type()))
    {
        using TStorage = scalar_from_complex<data_type_traits<LWPHY_C_16F>::type>::type;
        using TDataRx = scalar_from_complex<data_type_traits<LWPHY_C_16F>::type>::type;
        ch_est_kernel_launch<TStorage, TDataRx, TCompute>(cellId,
                                                          slotNum,
                                                          nBSAnts,
                                                          nLayers,
                                                          nDMRSSyms,
                                                          nDMRSGridsPerPRB,
                                                          activeDMRSGridBmsk,
                                                          nTotalDMRSPRB,
                                                          nTotalDataPRB,
                                                          Nh,
                                                          tDataRx,
                                                          tWFreq,
                                                          tShiftSeq,
                                                          tUnShiftSeq,
                                                          tH,
                                                          tDbg,
                                                          strm);
   }
   else
   {
       printf("Channel Est: No kernel available to launch with requested date type\n");
   }
    //printf("ch_est::estimate_channel() end()\n");
}

} // namespace ch_est
