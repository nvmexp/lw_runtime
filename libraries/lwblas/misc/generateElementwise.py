from lwtensorUtil import *
import os
import sys

def generateElementwise(candidates, cc, ccMin, ccMax):

    code = "/* THIS FILE IS AUTO-GENERATED by generateElementwise.py */\n"
    code += "#include<lwtensor/internal/candidateEW.h>\n"
    code += "#include<lwtensor/internal/candidateContainer.h>\n"
    code += "#include<lwtensor/internal/computeEngine.h>\n"
    code += "#include<lwtensor/internal/defines.h>\n"
    code += "namespace LWTENSOR_NAMESPACE\n{\n"

    nLwda11 = 0
    skipped = 0
    calls = ""
    containers = ""
    declarations = ""
    for dataTypes in sorted(candidates):
        typesStr = "%s%s%s%s"%(typeToChar(dataTypes[0]),typeToChar(dataTypes[1]),typeToChar(dataTypes[2]),typeToChar(dataTypes[3]))
        requiresLwda11 = ('b' in typesStr) or cc >= 80
        if (requiresLwda11):
            if (cc < 80):
                skipped += 1
                continue # don't generate bf16 kernels for cc smaler than 80
            nLwda11 += 1
            code += "#if LWTENSOR_LWDA_VERSION_MAJOR >= 11\n"
            containers += "#if LWTENSOR_LWDA_VERSION_MAJOR >= 11\n"

        code += "using Traits_%d_%s = ElementwiseTraits<%s, %s, %s, %s, %d, %d, %d>;\n"%(cc, typesStr, dataTypes[0],dataTypes[1],dataTypes[2],dataTypes[3],cc, ccMin, ccMax)

        code += "static const CandidateContainerTyped<\n"
        code += "    Traits_%d_%s, ElementwiseParameters, CandidateInfoEW, HeuristicEW\n"%(cc,typesStr)
        for kernel in candidates[dataTypes]:
            if len(kernel) == 8:
                ndim, tile1, tile2, tile3, nThreads, vec, transpose, opPacks = kernel
                lbmc = None
            else:
                ndim, tile1, tile2, tile3, nThreads, vec, transpose, opPacks, lbmc = kernel
            transpose = str(transpose).lower()
            for opPack in opPacks:
                if lbmc:
                    code += "    ,CandidateEW<Traits_%d_%s, ElementwiseConfig3D<%d, /*tilesize0*/%d, /*tilesize1*/%d, /*tilesize2*/%d, /*threads*/%d, /*vec*/%d, /*transpose*/%s, %s, %d>>\n"%(cc, typesStr, ndim, tile1, tile2, tile3, nThreads, vec, transpose, opPack, lbmc)
                else:
                    code += "    ,CandidateEW<Traits_%d_%s, ElementwiseConfig3D<%d, /*tilesize0*/%d, /*tilesize1*/%d, /*tilesize2*/%d, /*threads*/%d, /*vec*/%d, /*transpose*/%s, %s>>\n"%(cc, typesStr, ndim, tile1, tile2, tile3, nThreads, vec, transpose, opPack)
        code += "    > candidates_ew_%d_%s;\n"%(cc,typesStr)

        call = "getElementwiseContainer_sm%d_%s()"%(cc, typesStr)
        declaration = "   CandidateContainer<ElementwiseParameters>* %s"%(call)

        if (requiresLwda11):
            calls += "#if LWTENSOR_LWDA_VERSION_MAJOR >= 11\n"
            declarations += "#if LWTENSOR_LWDA_VERSION_MAJOR >= 11\n"
        calls += call + ",\n"
        declarations += declaration + ";\n"
        if (requiresLwda11):
            calls += "#endif\n"
            declarations += "#endif\n"
        code += "   \n%s\n"%(declaration)
        code += "   {\n"
        code += "       return (CandidateContainer<ElementwiseParameters>*) &candidates_ew_%d_%s;\n"%(cc,typesStr)
        code += "   }\n\n"

        containers += "   getElementwiseContainer_sm%d_%s(),\n"%(cc, typesStr)

        if (requiresLwda11):
            code += "#endif\n"
            containers += "#endif\n"

    code += "} // end LWTENSOR_NAMESPACE"

    return code, len(candidates) - skipped, len(candidates) - nLwda11 - skipped, declarations, calls

def generateAll(elem, smem=48*1024):
    TILE = [4, 8, 16, 32, 64, 128, 256, 512]
    result = []
    for vec in [i for i in [2, 4, 8, 16, 32] if i <= 16 // elem]:
        for transpose in [True, False]:
            for dim in [1,2,3]:
                if dim == 1 and transpose: continue
                if dim != 1 and not transpose: continue
                for threads in [32, 64, 128, 256, 512]:
                    for tile1 in TILE:
                        for tile2 in (TILE if dim >= 2 else [1]):
                            for tile3 in (TILE if dim >= 3 else [1]):
                                ntile = tile1 * tile2 * tile3
                                if ntile < vec * threads: continue
                                if (dim >= 2) and (tile1 > vec * threads): continue
                                if (dim >= 2) and (tile2 > vec * threads): continue
                                if transpose and (ntile * elem > smem): continue
                                if (dim > 1) and (ntile // vec // threads > 8): continue
                                if tile1 < vec: continue
                                if (dim >= 2) and (tile2 < vec) and transpose: continue
                                if ntile // vec // threads < 2: continue
                                result.append((dim, tile1, tile2, tile3, threads, vec, transpose, ["OpPackIdentity"]))
    return result

def targetForGenerate(cc, l, type_name):
    RECORD = False
    INJECT = True
    if RECORD:
        f = open('./misc/kernels/fallback/ew.%s.sm%d.kernels' % (type_name, cc), 'w+')
        for elem in l:
            for n in encodeKernelName(elem, cc):
                f.write(n + "\n")
        f.close()
    elif INJECT:
        pass
        f = open('./misc/kernels/ew.%s.sm%d.kernels' % (type_name, cc), 'r+')
        l.clear()
        for elem in f:
            l.append(decodeKernelName(elem)[0])
        f.close()
    else:
        ELW = 'LWTENSOR_GENERATE_TARGET'
        if ELW not in os.elwiron: return
        name, step = os.elwiron[ELW].split(',')
        step = int(step)
        if name != type_name: return
        STEP_SIZE = 100
        step *= STEP_SIZE
        type_size = getDataTypeSize(lwdaToType(type_name[-1]))
        g = generateAll(type_size)[step:step+STEP_SIZE]
        if not g: sys.exit(-1)
        l.clear()
        l.extend(g)

def decodeKernelName(kernel_name):
    elems = [elem for elem in kernel_name.split(";") if elem.strip()]
    if len(elems) == 6:
        dims, blocking, op, vec, threads, cc = elems
        lbmc = None
    else:
        dims, blocking, op, vec, threads, cc, lbmc = elems
    dims = int(dims)
    blocking = blocking.split(":")
    assert blocking[0] == "b"
    dim1, dim2, dim3 = map(int, blocking[1].split(','))
    op = op.split(":")
    assert op[0] == "op"
    op = int(op[1])
    op = ["OpPackIdentity", "OpPackGeneric"][op]
    vec = vec.split(":")
    assert vec[0] == "v"
    vec = int(vec[1])
    threads = threads.split(":")
    assert threads[0] == "t"
    threads = int(threads[1])
    cc = cc.split(":")
    assert cc[0] == "cc"
    cc = int(cc[1])
    if lbmc:
        lbmc = lbmc.split(":")
        assert lbmc[0] == "lbmc"
        lbmc = int(lbmc[1])
    if lbmc:
        return (dims, dim1, dim2, dim3, threads, vec, True, [op], lbmc), cc
    return (dims, dim1, dim2, dim3, threads, vec, True, [op]), cc


def encodeKernelName(kernel, cc):
    if len(kernel) == 8:
        ndim, dim1, dim2, dim3, threads, vec, transpose, packs = kernel
    else:
        ndim, dim1, dim2, dim3, threads, vec, transpose, packs, launchboundsMinCTA = kernel
    kernel_name = ""
    kernel_name += "%d;" % ndim
    kernel_name += "b:%d,%d,%d;" % (dim1, dim2, dim3)
    kernel_name += "op:%d;"
    kernel_name += "v:%d;" % vec
    kernel_name += "t:%d;" % threads
    kernel_name += "cc:%d;" % cc
    if launchboundsMinCTA:
        kernel_name += "lbmc:%d" % launchboundsMinCTA
    for p in packs:
        if p == "OpPackIdentity":
            yield kernel_name % 0
        else:
            yield kernel_name % 1


def main():
    binaryCompatibility = {}
    binaryCompatibility[61] = {60, 10000}
    binaryCompatibility[70] = {70, 72}
    binaryCompatibility[75] = {75}
    binaryCompatibility[80] = {80, 89}

    ccFuture = 0 # the minimal compute arch is the one for which we supply ptx code (i.e., the one that is used for future dispatch)
    ccMax = 0
    for cc in binaryCompatibility:
        if (max(binaryCompatibility[cc]) > ccMax):
            ccMax = max(binaryCompatibility[cc])
            ccFuture = cc
    #for cc in allowedCandidates:
    computeCapabilities = sorted(binaryCompatibility)
    computeCapabilities.remove(ccFuture)
    computeCapabilities.append(ccFuture) # move to last

    code = "/* THIS FILE IS AUTO-GENERATED by generateElementwise.py */\n"
    code += "#include<lwtensor/internal/candidateEW.h>\n"
    code += "#include<lwtensor/internal/candidateContainer.h>\n"
    code += "#include<lwtensor/internal/computeEngine.h>\n"
    code += "#include<lwtensor/internal/defines.h>\n"
    code += "namespace LWTENSOR_NAMESPACE {\n"
    calls = ""
    decls = ""
    ew_containers_ge_11 = 0
    ew_containers_le_11 = 0

    for cc in computeCapabilities:
        candidates = {}
        dataTypes = ("BFloat16", "BFloat16", "BFloat16", "BFloat16")
        candidates[dataTypes] = [
                             (1, 512,   1, 1,  64, 8, True, ["OpPackIdentity","OpPackGeneric"])
                            ,(2,  32,  32, 1,  64, 4, True, ["OpPackIdentity"])
                            ,(2, 128, 128, 1, 256, 8, True, ["OpPackIdentity","OpPackGeneric"])
                            ]
        targetForGenerate(cc, candidates[dataTypes], 'bbbb')
        dataTypes = ("half", "half", "half", "half")
        candidates[dataTypes] = [
                              (1, 512,   1, 1,  64, 8, True, ["OpPackIdentity","OpPackGeneric"])
                             ,(2,  32,  32, 1,  64, 4, True, ["OpPackIdentity"])
                             ,(2,  64,  64, 1, 256, 8, True, ["OpPackIdentity","OpPackGeneric"])
                             ,(2,   8, 128, 1,  64, 2, True, ["OpPackIdentity"])
                             ]
        targetForGenerate(cc, candidates[dataTypes], 'hhhh')
        dataTypes = ("float", "float", "float", "float")
        candidates[dataTypes] = [
                             (1, 256,  1, 1,  64, 2,  True, ["OpPackIdentity","OpPackGeneric"])
                            ,(2, 16,  16, 1,  32, 4,  True, ["OpPackIdentity","OpPackGeneric"])
                            ,(3,  4,   4, 8,  32, 2,  True, ["OpPackIdentity"])
                            ,(3, 32,  32, 4, 512, 4,  True, ["OpPackIdentity"])
                            ,(3, 16,  16,16, 512, 4,  True, ["OpPackIdentity"])
                            ,(2, 32,  32, 1, 128, 4,  True, ["OpPackIdentity"])
                            ,(3,  8,   8, 4,  32, 4,  True, ["OpPackIdentity"])
                            ,(3,  8,   8, 4,  64, 2,  True, ["OpPackIdentity"])
                            ]
        targetForGenerate(cc, candidates[dataTypes], 'ssss')
        dataTypes = ("double", "double", "double", "double")
        candidates[dataTypes] = [
                             (1, 128, 128, 1,  64, 2, True, ["OpPackIdentity","OpPackGeneric"])
                            ,(2,  16,  16, 1,  64, 2, True, ["OpPackIdentity"])
                            ,(2,  32,  32, 1, 256, 2, True, ["OpPackIdentity","OpPackGeneric"])
                            ]
        targetForGenerate(cc, candidates[dataTypes], 'dddd')
        dataTypes = ("lwComplex", "lwComplex", "lwComplex", "lwComplex")
        candidates[dataTypes] = [
                             (1, 128, 128, 1,  64, 2, True, ["OpPackIdentity","OpPackGeneric"])
                            ,(2,  16,  16, 1,  64, 2, True, ["OpPackIdentity"])
                            ,(2,  32,  32, 1, 256, 2, True, ["OpPackIdentity","OpPackGeneric"])
                            ]
        targetForGenerate(cc, candidates[dataTypes], 'cccc')
        dataTypes = ("lwDoubleComplex", "lwDoubleComplex", "lwDoubleComplex", "lwDoubleComplex")
        candidates[dataTypes] = [
                             (1, 256, 256, 1,  64, 1, True, ["OpPackIdentity","OpPackGeneric"])
                            ,(2,  16,  16, 1, 128, 1, True, ["OpPackIdentity"])
                            ,(2,  32,  32, 1, 256, 1, True, ["OpPackIdentity","OpPackGeneric"])
                            ]
        targetForGenerate(cc, candidates[dataTypes], 'zzzz')
        dataTypes = ("half", "half", "half", "float")
        candidates[dataTypes] = [
                             (1, 512, 512, 1,  64, 8, True, ["OpPackIdentity","OpPackGeneric"])
                            ,(2,  32,  32, 1, 256, 4, True, ["OpPackIdentity"])
                            ,(2,  64,  64, 1, 256, 8, True, ["OpPackIdentity","OpPackGeneric"])
                            ,(2,   8, 128, 1, 256, 2, True, ["OpPackIdentity"])
                            ]
        targetForGenerate(cc, candidates[dataTypes], 'hhhs')
        dataTypes = ("BFloat16", "BFloat16", "BFloat16", "float")
        candidates[dataTypes] = [
                             (1, 512, 512, 1,  64, 8, True, ["OpPackIdentity","OpPackGeneric"])
                            ,(2,  32,  32, 1, 256, 4, True, ["OpPackIdentity"])
                            ,(2,  64,  64, 1, 256, 8, True, ["OpPackIdentity","OpPackGeneric"])
                            ]
        targetForGenerate(cc, candidates[dataTypes], 'bbbs')
        dataTypes = ("float", "float", "half", "float")
        candidates[dataTypes] = [
                             (1, 256, 256, 1,  64, 4, True, ["OpPackIdentity","OpPackGeneric"])
                            ,(2,  16,  16, 1,  64, 4, True, ["OpPackIdentity"])
                            ,(2,  64,  64, 1, 256, 4, True, ["OpPackIdentity","OpPackGeneric"])
                            ]
        targetForGenerate(cc, candidates[dataTypes], 'sshs')
        dataTypes = ("double", "double", "float", "double")
        candidates[dataTypes] = [
                             (1, 128, 128, 1,  64, 2, True, ["OpPackIdentity","OpPackGeneric"])
                            ,(2,  16,  16, 1,  64, 2, True, ["OpPackIdentity"])
                            ,(2,  32,  32, 1, 256, 2, True, ["OpPackIdentity","OpPackGeneric"])
                            ]
        targetForGenerate(cc, candidates[dataTypes], 'ddsd')
        dataTypes = ("lwDoubleComplex", "lwDoubleComplex", "lwComplex", "lwDoubleComplex")
        candidates[dataTypes] = [
                             (1, 256, 256, 1,  64, 1, True, ["OpPackIdentity","OpPackGeneric"])
                            ,(2,  16,  16, 1, 128, 1, True, ["OpPackIdentity"])
                            ,(2,  32,  32, 1, 256, 1, True, ["OpPackIdentity","OpPackGeneric"])
                            ]
        targetForGenerate(cc, candidates[dataTypes], 'zzcz')

        f = open("./src/elementwise_sm%d.lw"%(cc), "w+")
        code_tmp, ew_containers_ge_11_tmp, ew_containers_le_11_tmp, decl, call = generateElementwise(candidates, cc, min(binaryCompatibility[cc]), max(binaryCompatibility[cc]))
        f.write(code_tmp)
        f.close()
        ew_containers_ge_11 += ew_containers_ge_11_tmp
        ew_containers_le_11 += ew_containers_le_11_tmp
        decls += decl
        calls += call


    f = open("./src/elementwise_auto.lw", "w+")
    code += decls
    code += "#if LWTENSOR_LWDA_VERSION_MAJOR >= 11\n"
    code += "static const int kNumContainersEW = %d;\n"%(ew_containers_ge_11)
    code += "#else\n"
    code += "static const int kNumContainersEW = %d;\n"%(ew_containers_le_11)
    code += "#endif\n"

    code += "static ComputeEngine<kNumContainersEW, ElementwiseParameters> _elementwiseEngine({\n" + calls[0:-2] + "\n});\n"

    code += "\nconst ComputeEngineBase<ElementwiseParameters>* getElementwiseEngine()\n"
    code += "{\n"
    code += "    _elementwiseEngine.init();\n"
    code += "    return &_elementwiseEngine;\n"
    code += "}\n"
    code += "} // end namespace\n"
    f.write(code)
    f.close()

if __name__ == "__main__":
    main()
