#************************ BEGIN COPYRIGHT NOTICE ***************************#
#                                                                           #
#          Copyright (c) LWPU Corporation.  All rights reserved.          #
#                                                                           #
# All information contained herein is proprietary and confidential to       #
# LWPU Corporation.  Any use, reproduction, or disclosure without the     #
# written permission of LWPU Corporation is prohibited.                   #
#                                                                           #
#************************** END COPYRIGHT NOTICE ***************************#

#***************************************************************************#
#                            Module : dbzen                                 #
#         Generates database of DOCs from definition Files or changes       #
#                            in defintion Files                             #
#                                                                           #
#***************************************************************************#

$:.unshift File.dirname(__FILE__)

# these load the class definition files 

require 'unit_suite'
require 'suite_tree'

#
# this is used for loading the input file which
# would have linkages to parents.rb
#
require '../suitedefs/parents.rb'


defFile = ARGV[0]

# ensure the file is in proper format
raise "Invalid input Definition File, Must be in the <filename>.rb format" unless defFile =~ /\w+\.rb/

# here we load the input definition file
require "#{defFile}"


# load the daatabase only, if it exists
if File.exist?("#{$unizenPath}/generatedDocDb.rb")
	require 'generatedDocDb'
else
	$fileList = {}
end

# this is used to store the file paths of each newly added file 
triggerFileList = []
triggerMockFileList = []

p4root =String.new( ELW["P4ROOT"])
p4root = p4root.gsub("\\","/")

#lwrrentWorkingDir = Dir.pwd
#Dir.chdir("#{p4root}/sw/dev/gpu_drv/chips_a/diag/unittest/unizen")

writeFile = File.new("#{$unitPath}/unizen/generatedDocDb.rb", "a")

# write header information only if the database is not already present
if $fileList.empty?
	writeFile.puts "# "
	writeFile.puts "# This is an autogenerated file "
	writeFile.puts "# Please modify only if you are confident about what you are doing "
	writeFile.puts "# "
	writeFile.puts "require 'unit_suite'"
	writeFile.puts "require 'suite_tree'"
	writeFile.puts
	writeFile.puts "$fileList = {}"
	writeFile.puts
end



$thisSuite.forEachEnabled do |suite|


	suite.node.fileList.each do |fileEntry|

		unless $fileList[(fileEntry.path)] 

			triggerFileList.push(fileEntry.path)
			triggerMockFileList.push(fileEntry.path)

			writeFile.puts "# File : #{fileEntry.path.scan(/\/([\w\-]+\.c)/)[0]} "
			writeFile.puts  "#{fileEntry.objectName} = FileToBeWrapped.new(\"#{fileEntry.path}\")"
			writeFile.puts 

			obj = FileToBeWrapped.new(fileEntry.path)

			fileEntry.doc.each do |key, doc|

				writeFile.puts "#{fileEntry.objectName}.addDoc(
															   \"#{doc.returnType}\",
															   \"#{doc.name}\"
															   )"

				obj.addDoc(doc.returnType, doc.name)

			end

			fileEntry.sut.each do |key, sut|

				writeFile.puts "#{fileEntry.objectName}.addSut(
															   \"#{sut.returnType}\",
															   \"#{sut.name}\"
															   )"

				obj.addSut(sut.returnType, sut.name)

			end

			writeFile.puts 
			writeFile.puts "$fileList[\"#{fileEntry.path}\"] = #{fileEntry.objectName}"
			writeFile.puts "\n\n"

			$fileList[(fileEntry.path)] = obj

		else

			fileEntry.doc.each do |key, doc|

				unless $fileList[fileEntry.path].doc[doc.name] 

					triggerMockFileList.push(fileEntry.path) unless triggerMockFileList.include?(fileEntry.path)

					writeFile.puts "#{fileEntry.objectName}.addDoc(
																   \"#{doc.returnType}\",
																   \"#{doc.name}\"
																   )"

					$fileList[fileEntry.path].addDoc(doc.returnType, doc.name)

				end

			end

			fileEntry.sut.each do |key, sut|

				unless $fileList[fileEntry.path].sut[sut.name] 

					triggerMockFileList.push(fileEntry.path) unless triggerMockFileList.include?(fileEntry.path)

					writeFile.puts "#{fileEntry.objectName}.addSut(
																   \"#{sut.returnType}\",
																   \"#{sut.name}\"
																   )"

					$fileList[fileEntry.path].addSut(sut.returnType, sut.name)

				end

			end

		end

	end

end

writeFile.flush

makeFile = File.new("#{$unitPath}/mocksrc.mk", "a")
triggerFileList.each{ |f|

	if (f =~ /\/kernel\/(\w+)\//)
	makeFile.puts "mockFiles += " + f + "\n"
	end

}
makeFile.flush

generationThread = []

triggerMockFileList.each{ |f|

	generationThread.push( Thread.new{ system("#{$rubyApp} #{$unitPath}/unizen/mockzen.rb #{$unitBranch}/#{f}") } )

}

generationThread.each {|t| t.join}



#Dir.chdir(lwrrentWorkingDir)

#
# commented : for debugging 
# print $fileList.each {|key, file| file.doc.each {|d| print d }}
# print "#{triggerMockFileList}\n"
#
