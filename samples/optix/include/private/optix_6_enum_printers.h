//
//  Copyright (c) 2021 LWPU Corporation.  All rights reserved.
//
//  LWPU Corporation and its licensors retain all intellectual property and proprietary
//  rights in and to this software, related documentation and any modifications thereto.
//  Any use, reproduction, disclosure or distribution of this software and related
//  documentation without an express license agreement from LWPU Corporation is strictly
//  prohibited.
//
//  TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, THIS SOFTWARE IS PROVIDED *AS IS*
//  AND LWPU AND ITS SUPPLIERS DISCLAIM ALL WARRANTIES, EITHER EXPRESS OR IMPLIED,
//  INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
//  PARTICULAR PURPOSE.  IN NO EVENT SHALL LWPU OR ITS SUPPLIERS BE LIABLE FOR ANY
//  SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, WITHOUT
//  LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF
//  BUSINESS INFORMATION, OR ANY OTHER PELWNIARY LOSS) ARISING OUT OF THE USE OF OR
//  INABILITY TO USE THIS SOFTWARE, EVEN IF LWPU HAS BEEN ADVISED OF THE POSSIBILITY OF
//  SUCH DAMAGES
//

#pragma once

// Generated by apps/optix/make/enum-printer.py -- DO NOT EDIT!
// Command: enum-printer.py optix6Declarations

#include <o6/optix.h>

#include <iostream>
#include <string>


#if !defined( EMIT_FLAG_DEFINED )
inline void emitFlag( std::string& result, bool& emitted, unsigned long flags, unsigned long flag, const char* enumerant )
{
    if( flags & flag )
    {
        if( emitted )
        {
            result += " | ";
        }
        result += enumerant;
        emitted = true;
    }
}
#endif // EMIT_FLAG_DEFINED
#define EMIT_FLAG_DEFINED

struct RTinstanceflagSet
{
    unsigned int flags;
};

inline std::string toString( RTinstanceflagSet flags )
{
    bool emitted = false;
    std::string result;
    emitFlag( result, emitted, flags.flags, RT_INSTANCE_FLAG_DISABLE_TRIANGLE_LWLLING, "RT_INSTANCE_FLAG_DISABLE_TRIANGLE_LWLLING" );
    emitFlag( result, emitted, flags.flags, RT_INSTANCE_FLAG_FLIP_TRIANGLE_FACING, "RT_INSTANCE_FLAG_FLIP_TRIANGLE_FACING" );
    emitFlag( result, emitted, flags.flags, RT_INSTANCE_FLAG_DISABLE_ANYHIT, "RT_INSTANCE_FLAG_DISABLE_ANYHIT" );
    emitFlag( result, emitted, flags.flags, RT_INSTANCE_FLAG_FORCE_ANYHIT, "RT_INSTANCE_FLAG_FORCE_ANYHIT" );
    if( !emitted )
    {
        result = "RT_INSTANCE_FLAG_NONE";
    }
    return result;
}

inline std::ostream& operator<<( std::ostream& str, RTinstanceflagSet flags )
{
    return str << toString( flags );
}

inline std::string toString( RTdeviceattribute value )
{
    switch( value )
    {
        case RT_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK: return "RT_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK";
        case RT_DEVICE_ATTRIBUTE_CLOCK_RATE: return "RT_DEVICE_ATTRIBUTE_CLOCK_RATE";
        case RT_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT: return "RT_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT";
        case RT_DEVICE_ATTRIBUTE_EXELWTION_TIMEOUT_ENABLED: return "RT_DEVICE_ATTRIBUTE_EXELWTION_TIMEOUT_ENABLED";
        case RT_DEVICE_ATTRIBUTE_MAX_HARDWARE_TEXTURE_COUNT: return "RT_DEVICE_ATTRIBUTE_MAX_HARDWARE_TEXTURE_COUNT";
        case RT_DEVICE_ATTRIBUTE_NAME: return "RT_DEVICE_ATTRIBUTE_NAME";
        case RT_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY: return "RT_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY";
        case RT_DEVICE_ATTRIBUTE_TOTAL_MEMORY: return "RT_DEVICE_ATTRIBUTE_TOTAL_MEMORY";
        case RT_DEVICE_ATTRIBUTE_TCC_DRIVER: return "RT_DEVICE_ATTRIBUTE_TCC_DRIVER";
        case RT_DEVICE_ATTRIBUTE_LWDA_DEVICE_ORDINAL: return "RT_DEVICE_ATTRIBUTE_LWDA_DEVICE_ORDINAL";
        case RT_DEVICE_ATTRIBUTE_PCI_BUS_ID: return "RT_DEVICE_ATTRIBUTE_PCI_BUS_ID";
        case RT_DEVICE_ATTRIBUTE_COMPATIBLE_DEVICES: return "RT_DEVICE_ATTRIBUTE_COMPATIBLE_DEVICES";
        case RT_DEVICE_ATTRIBUTE_RTCORE_VERSION: return "RT_DEVICE_ATTRIBUTE_RTCORE_VERSION";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTdeviceattribute value )
{
    return str << toString( value );
}

inline std::string toString( RTresult value )
{
    switch( value )
    {
        case RT_SUCCESS: return "RT_SUCCESS";
        case RT_TIMEOUT_CALLBACK: return "RT_TIMEOUT_CALLBACK";
        case RT_ERROR_ILWALID_CONTEXT: return "RT_ERROR_ILWALID_CONTEXT";
        case RT_ERROR_ILWALID_VALUE: return "RT_ERROR_ILWALID_VALUE";
        case RT_ERROR_MEMORY_ALLOCATION_FAILED: return "RT_ERROR_MEMORY_ALLOCATION_FAILED";
        case RT_ERROR_TYPE_MISMATCH: return "RT_ERROR_TYPE_MISMATCH";
        case RT_ERROR_VARIABLE_NOT_FOUND: return "RT_ERROR_VARIABLE_NOT_FOUND";
        case RT_ERROR_VARIABLE_REDECLARED: return "RT_ERROR_VARIABLE_REDECLARED";
        case RT_ERROR_ILLEGAL_SYMBOL: return "RT_ERROR_ILLEGAL_SYMBOL";
        case RT_ERROR_ILWALID_SOURCE: return "RT_ERROR_ILWALID_SOURCE";
        case RT_ERROR_VERSION_MISMATCH: return "RT_ERROR_VERSION_MISMATCH";
        case RT_ERROR_OBJECT_CREATION_FAILED: return "RT_ERROR_OBJECT_CREATION_FAILED";
        case RT_ERROR_NO_DEVICE: return "RT_ERROR_NO_DEVICE";
        case RT_ERROR_ILWALID_DEVICE: return "RT_ERROR_ILWALID_DEVICE";
        case RT_ERROR_ILWALID_IMAGE: return "RT_ERROR_ILWALID_IMAGE";
        case RT_ERROR_FILE_NOT_FOUND: return "RT_ERROR_FILE_NOT_FOUND";
        case RT_ERROR_ALREADY_MAPPED: return "RT_ERROR_ALREADY_MAPPED";
        case RT_ERROR_ILWALID_DRIVER_VERSION: return "RT_ERROR_ILWALID_DRIVER_VERSION";
        case RT_ERROR_CONTEXT_CREATION_FAILED: return "RT_ERROR_CONTEXT_CREATION_FAILED";
        case RT_ERROR_RESOURCE_NOT_REGISTERED: return "RT_ERROR_RESOURCE_NOT_REGISTERED";
        case RT_ERROR_RESOURCE_ALREADY_REGISTERED: return "RT_ERROR_RESOURCE_ALREADY_REGISTERED";
        case RT_ERROR_OPTIX_NOT_LOADED: return "RT_ERROR_OPTIX_NOT_LOADED";
        case RT_ERROR_DENOISER_NOT_LOADED: return "RT_ERROR_DENOISER_NOT_LOADED";
        case RT_ERROR_SSIM_PREDICTOR_NOT_LOADED: return "RT_ERROR_SSIM_PREDICTOR_NOT_LOADED";
        case RT_ERROR_DRIVER_VERSION_FAILED: return "RT_ERROR_DRIVER_VERSION_FAILED";
        case RT_ERROR_DATABASE_FILE_PERMISSIONS: return "RT_ERROR_DATABASE_FILE_PERMISSIONS";
        case RT_ERROR_LAUNCH_FAILED: return "RT_ERROR_LAUNCH_FAILED";
        case RT_ERROR_NOT_SUPPORTED: return "RT_ERROR_NOT_SUPPORTED";
        case RT_ERROR_CONNECTION_FAILED: return "RT_ERROR_CONNECTION_FAILED";
        case RT_ERROR_AUTHENTICATION_FAILED: return "RT_ERROR_AUTHENTICATION_FAILED";
        case RT_ERROR_CONNECTION_ALREADY_EXISTS: return "RT_ERROR_CONNECTION_ALREADY_EXISTS";
        case RT_ERROR_NETWORK_LOAD_FAILED: return "RT_ERROR_NETWORK_LOAD_FAILED";
        case RT_ERROR_NETWORK_INIT_FAILED: return "RT_ERROR_NETWORK_INIT_FAILED";
        case RT_ERROR_CLUSTER_NOT_RUNNING: return "RT_ERROR_CLUSTER_NOT_RUNNING";
        case RT_ERROR_CLUSTER_ALREADY_RUNNING: return "RT_ERROR_CLUSTER_ALREADY_RUNNING";
        case RT_ERROR_INSUFFICIENT_FREE_NODES: return "RT_ERROR_INSUFFICIENT_FREE_NODES";
        case RT_ERROR_ILWALID_GLOBAL_ATTRIBUTE: return "RT_ERROR_ILWALID_GLOBAL_ATTRIBUTE";
        case RT_ERROR_UNKNOWN: return "RT_ERROR_UNKNOWN";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTresult value )
{
    return str << toString( value );
}

inline std::string toString( RTformat value )
{
    switch( value )
    {
        case RT_FORMAT_UNKNOWN: return "RT_FORMAT_UNKNOWN";
        case RT_FORMAT_FLOAT: return "RT_FORMAT_FLOAT";
        case RT_FORMAT_FLOAT2: return "RT_FORMAT_FLOAT2";
        case RT_FORMAT_FLOAT3: return "RT_FORMAT_FLOAT3";
        case RT_FORMAT_FLOAT4: return "RT_FORMAT_FLOAT4";
        case RT_FORMAT_BYTE: return "RT_FORMAT_BYTE";
        case RT_FORMAT_BYTE2: return "RT_FORMAT_BYTE2";
        case RT_FORMAT_BYTE3: return "RT_FORMAT_BYTE3";
        case RT_FORMAT_BYTE4: return "RT_FORMAT_BYTE4";
        case RT_FORMAT_UNSIGNED_BYTE: return "RT_FORMAT_UNSIGNED_BYTE";
        case RT_FORMAT_UNSIGNED_BYTE2: return "RT_FORMAT_UNSIGNED_BYTE2";
        case RT_FORMAT_UNSIGNED_BYTE3: return "RT_FORMAT_UNSIGNED_BYTE3";
        case RT_FORMAT_UNSIGNED_BYTE4: return "RT_FORMAT_UNSIGNED_BYTE4";
        case RT_FORMAT_SHORT: return "RT_FORMAT_SHORT";
        case RT_FORMAT_SHORT2: return "RT_FORMAT_SHORT2";
        case RT_FORMAT_SHORT3: return "RT_FORMAT_SHORT3";
        case RT_FORMAT_SHORT4: return "RT_FORMAT_SHORT4";
        case RT_FORMAT_UNSIGNED_SHORT: return "RT_FORMAT_UNSIGNED_SHORT";
        case RT_FORMAT_UNSIGNED_SHORT2: return "RT_FORMAT_UNSIGNED_SHORT2";
        case RT_FORMAT_UNSIGNED_SHORT3: return "RT_FORMAT_UNSIGNED_SHORT3";
        case RT_FORMAT_UNSIGNED_SHORT4: return "RT_FORMAT_UNSIGNED_SHORT4";
        case RT_FORMAT_INT: return "RT_FORMAT_INT";
        case RT_FORMAT_INT2: return "RT_FORMAT_INT2";
        case RT_FORMAT_INT3: return "RT_FORMAT_INT3";
        case RT_FORMAT_INT4: return "RT_FORMAT_INT4";
        case RT_FORMAT_UNSIGNED_INT: return "RT_FORMAT_UNSIGNED_INT";
        case RT_FORMAT_UNSIGNED_INT2: return "RT_FORMAT_UNSIGNED_INT2";
        case RT_FORMAT_UNSIGNED_INT3: return "RT_FORMAT_UNSIGNED_INT3";
        case RT_FORMAT_UNSIGNED_INT4: return "RT_FORMAT_UNSIGNED_INT4";
        case RT_FORMAT_USER: return "RT_FORMAT_USER";
        case RT_FORMAT_BUFFER_ID: return "RT_FORMAT_BUFFER_ID";
        case RT_FORMAT_PROGRAM_ID: return "RT_FORMAT_PROGRAM_ID";
        case RT_FORMAT_HALF: return "RT_FORMAT_HALF";
        case RT_FORMAT_HALF2: return "RT_FORMAT_HALF2";
        case RT_FORMAT_HALF3: return "RT_FORMAT_HALF3";
        case RT_FORMAT_HALF4: return "RT_FORMAT_HALF4";
        case RT_FORMAT_LONG_LONG: return "RT_FORMAT_LONG_LONG";
        case RT_FORMAT_LONG_LONG2: return "RT_FORMAT_LONG_LONG2";
        case RT_FORMAT_LONG_LONG3: return "RT_FORMAT_LONG_LONG3";
        case RT_FORMAT_LONG_LONG4: return "RT_FORMAT_LONG_LONG4";
        case RT_FORMAT_UNSIGNED_LONG_LONG: return "RT_FORMAT_UNSIGNED_LONG_LONG";
        case RT_FORMAT_UNSIGNED_LONG_LONG2: return "RT_FORMAT_UNSIGNED_LONG_LONG2";
        case RT_FORMAT_UNSIGNED_LONG_LONG3: return "RT_FORMAT_UNSIGNED_LONG_LONG3";
        case RT_FORMAT_UNSIGNED_LONG_LONG4: return "RT_FORMAT_UNSIGNED_LONG_LONG4";
        case RT_FORMAT_UNSIGNED_BC1: return "RT_FORMAT_UNSIGNED_BC1";
        case RT_FORMAT_UNSIGNED_BC2: return "RT_FORMAT_UNSIGNED_BC2";
        case RT_FORMAT_UNSIGNED_BC3: return "RT_FORMAT_UNSIGNED_BC3";
        case RT_FORMAT_UNSIGNED_BC4: return "RT_FORMAT_UNSIGNED_BC4";
        case RT_FORMAT_BC4: return "RT_FORMAT_BC4";
        case RT_FORMAT_UNSIGNED_BC5: return "RT_FORMAT_UNSIGNED_BC5";
        case RT_FORMAT_BC5: return "RT_FORMAT_BC5";
        case RT_FORMAT_UNSIGNED_BC6H: return "RT_FORMAT_UNSIGNED_BC6H";
        case RT_FORMAT_BC6H: return "RT_FORMAT_BC6H";
        case RT_FORMAT_UNSIGNED_BC7: return "RT_FORMAT_UNSIGNED_BC7";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTformat value )
{
    return str << toString( value );
}

inline std::string toString( RTobjecttype value )
{
    switch( value )
    {
        case RT_OBJECTTYPE_UNKNOWN: return "RT_OBJECTTYPE_UNKNOWN";
        case RT_OBJECTTYPE_GROUP: return "RT_OBJECTTYPE_GROUP";
        case RT_OBJECTTYPE_GEOMETRY_GROUP: return "RT_OBJECTTYPE_GEOMETRY_GROUP";
        case RT_OBJECTTYPE_TRANSFORM: return "RT_OBJECTTYPE_TRANSFORM";
        case RT_OBJECTTYPE_SELECTOR: return "RT_OBJECTTYPE_SELECTOR";
        case RT_OBJECTTYPE_GEOMETRY_INSTANCE: return "RT_OBJECTTYPE_GEOMETRY_INSTANCE";
        case RT_OBJECTTYPE_BUFFER: return "RT_OBJECTTYPE_BUFFER";
        case RT_OBJECTTYPE_TEXTURE_SAMPLER: return "RT_OBJECTTYPE_TEXTURE_SAMPLER";
        case RT_OBJECTTYPE_OBJECT: return "RT_OBJECTTYPE_OBJECT";
        case RT_OBJECTTYPE_MATRIX_FLOAT2x2: return "RT_OBJECTTYPE_MATRIX_FLOAT2x2";
        case RT_OBJECTTYPE_MATRIX_FLOAT2x3: return "RT_OBJECTTYPE_MATRIX_FLOAT2x3";
        case RT_OBJECTTYPE_MATRIX_FLOAT2x4: return "RT_OBJECTTYPE_MATRIX_FLOAT2x4";
        case RT_OBJECTTYPE_MATRIX_FLOAT3x2: return "RT_OBJECTTYPE_MATRIX_FLOAT3x2";
        case RT_OBJECTTYPE_MATRIX_FLOAT3x3: return "RT_OBJECTTYPE_MATRIX_FLOAT3x3";
        case RT_OBJECTTYPE_MATRIX_FLOAT3x4: return "RT_OBJECTTYPE_MATRIX_FLOAT3x4";
        case RT_OBJECTTYPE_MATRIX_FLOAT4x2: return "RT_OBJECTTYPE_MATRIX_FLOAT4x2";
        case RT_OBJECTTYPE_MATRIX_FLOAT4x3: return "RT_OBJECTTYPE_MATRIX_FLOAT4x3";
        case RT_OBJECTTYPE_MATRIX_FLOAT4x4: return "RT_OBJECTTYPE_MATRIX_FLOAT4x4";
        case RT_OBJECTTYPE_FLOAT: return "RT_OBJECTTYPE_FLOAT";
        case RT_OBJECTTYPE_FLOAT2: return "RT_OBJECTTYPE_FLOAT2";
        case RT_OBJECTTYPE_FLOAT3: return "RT_OBJECTTYPE_FLOAT3";
        case RT_OBJECTTYPE_FLOAT4: return "RT_OBJECTTYPE_FLOAT4";
        case RT_OBJECTTYPE_INT: return "RT_OBJECTTYPE_INT";
        case RT_OBJECTTYPE_INT2: return "RT_OBJECTTYPE_INT2";
        case RT_OBJECTTYPE_INT3: return "RT_OBJECTTYPE_INT3";
        case RT_OBJECTTYPE_INT4: return "RT_OBJECTTYPE_INT4";
        case RT_OBJECTTYPE_UNSIGNED_INT: return "RT_OBJECTTYPE_UNSIGNED_INT";
        case RT_OBJECTTYPE_UNSIGNED_INT2: return "RT_OBJECTTYPE_UNSIGNED_INT2";
        case RT_OBJECTTYPE_UNSIGNED_INT3: return "RT_OBJECTTYPE_UNSIGNED_INT3";
        case RT_OBJECTTYPE_UNSIGNED_INT4: return "RT_OBJECTTYPE_UNSIGNED_INT4";
        case RT_OBJECTTYPE_USER: return "RT_OBJECTTYPE_USER";
        case RT_OBJECTTYPE_PROGRAM: return "RT_OBJECTTYPE_PROGRAM";
        case RT_OBJECTTYPE_COMMANDLIST: return "RT_OBJECTTYPE_COMMANDLIST";
        case RT_OBJECTTYPE_POSTPROCESSINGSTAGE: return "RT_OBJECTTYPE_POSTPROCESSINGSTAGE";
        case RT_OBJECTTYPE_LONG_LONG: return "RT_OBJECTTYPE_LONG_LONG";
        case RT_OBJECTTYPE_LONG_LONG2: return "RT_OBJECTTYPE_LONG_LONG2";
        case RT_OBJECTTYPE_LONG_LONG3: return "RT_OBJECTTYPE_LONG_LONG3";
        case RT_OBJECTTYPE_LONG_LONG4: return "RT_OBJECTTYPE_LONG_LONG4";
        case RT_OBJECTTYPE_UNSIGNED_LONG_LONG: return "RT_OBJECTTYPE_UNSIGNED_LONG_LONG";
        case RT_OBJECTTYPE_UNSIGNED_LONG_LONG2: return "RT_OBJECTTYPE_UNSIGNED_LONG_LONG2";
        case RT_OBJECTTYPE_UNSIGNED_LONG_LONG3: return "RT_OBJECTTYPE_UNSIGNED_LONG_LONG3";
        case RT_OBJECTTYPE_UNSIGNED_LONG_LONG4: return "RT_OBJECTTYPE_UNSIGNED_LONG_LONG4";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTobjecttype value )
{
    return str << toString( value );
}

inline std::string toString( RTmotionbordermode value )
{
    switch( value )
    {
        case RT_MOTIONBORDERMODE_CLAMP: return "RT_MOTIONBORDERMODE_CLAMP";
        case RT_MOTIONBORDERMODE_VANISH: return "RT_MOTIONBORDERMODE_VANISH";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTmotionbordermode value )
{
    return str << toString( value );
}

inline std::string toString( RTbufferflag value )
{
    switch( value )
    {
        case RT_BUFFER_GPU_LOCAL: return "RT_BUFFER_GPU_LOCAL";
        case RT_BUFFER_COPY_ON_DIRTY: return "RT_BUFFER_COPY_ON_DIRTY";
        case RT_BUFFER_DISCARD_HOST_MEMORY: return "RT_BUFFER_DISCARD_HOST_MEMORY";
        case RT_BUFFER_LAYERED: return "RT_BUFFER_LAYERED";
        case RT_BUFFER_LWBEMAP: return "RT_BUFFER_LWBEMAP";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTbufferflag value )
{
    return str << toString( value );
}

struct RTgeometrybuildflagSet
{
    unsigned int flags;
};

inline std::string toString( RTgeometrybuildflagSet flags )
{
    bool emitted = false;
    std::string result;
    emitFlag( result, emitted, flags.flags, RT_GEOMETRY_BUILD_FLAG_RELEASE_BUFFERS, "RT_GEOMETRY_BUILD_FLAG_RELEASE_BUFFERS" );
    if( !emitted )
    {
        result = "RT_GEOMETRY_BUILD_FLAG_NONE";
    }
    return result;
}

inline std::ostream& operator<<( std::ostream& str, RTgeometrybuildflagSet flags )
{
    return str << toString( flags );
}

inline std::string toString( RTgltarget value )
{
    switch( value )
    {
        case RT_TARGET_GL_TEXTURE_2D: return "RT_TARGET_GL_TEXTURE_2D";
        case RT_TARGET_GL_TEXTURE_RECTANGLE: return "RT_TARGET_GL_TEXTURE_RECTANGLE";
        case RT_TARGET_GL_TEXTURE_3D: return "RT_TARGET_GL_TEXTURE_3D";
        case RT_TARGET_GL_RENDER_BUFFER: return "RT_TARGET_GL_RENDER_BUFFER";
        case RT_TARGET_GL_TEXTURE_1D: return "RT_TARGET_GL_TEXTURE_1D";
        case RT_TARGET_GL_TEXTURE_1D_ARRAY: return "RT_TARGET_GL_TEXTURE_1D_ARRAY";
        case RT_TARGET_GL_TEXTURE_2D_ARRAY: return "RT_TARGET_GL_TEXTURE_2D_ARRAY";
        case RT_TARGET_GL_TEXTURE_LWBE_MAP: return "RT_TARGET_GL_TEXTURE_LWBE_MAP";
        case RT_TARGET_GL_TEXTURE_LWBE_MAP_ARRAY: return "RT_TARGET_GL_TEXTURE_LWBE_MAP_ARRAY";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTgltarget value )
{
    return str << toString( value );
}

inline std::string toString( RTtexturereadmode value )
{
    switch( value )
    {
        case RT_TEXTURE_READ_ELEMENT_TYPE: return "RT_TEXTURE_READ_ELEMENT_TYPE";
        case RT_TEXTURE_READ_NORMALIZED_FLOAT: return "RT_TEXTURE_READ_NORMALIZED_FLOAT";
        case RT_TEXTURE_READ_ELEMENT_TYPE_SRGB: return "RT_TEXTURE_READ_ELEMENT_TYPE_SRGB";
        case RT_TEXTURE_READ_NORMALIZED_FLOAT_SRGB: return "RT_TEXTURE_READ_NORMALIZED_FLOAT_SRGB";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTtexturereadmode value )
{
    return str << toString( value );
}

inline std::string toString( RTprogramidnull value )
{
    switch( value )
    {
        case RT_PROGRAM_ID_NULL: return "RT_PROGRAM_ID_NULL";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTprogramidnull value )
{
    return str << toString( value );
}

inline std::string toString( RTmotionkeytype value )
{
    switch( value )
    {
        case RT_MOTIONKEYTYPE_NONE: return "RT_MOTIONKEYTYPE_NONE";
        case RT_MOTIONKEYTYPE_MATRIX_FLOAT12: return "RT_MOTIONKEYTYPE_MATRIX_FLOAT12";
        case RT_MOTIONKEYTYPE_SRT_FLOAT16: return "RT_MOTIONKEYTYPE_SRT_FLOAT16";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTmotionkeytype value )
{
    return str << toString( value );
}

inline std::string toString( RTbuffermapflag value )
{
    switch( value )
    {
        case RT_BUFFER_MAP_READ: return "RT_BUFFER_MAP_READ";
        case RT_BUFFER_MAP_READ_WRITE: return "RT_BUFFER_MAP_READ_WRITE";
        case RT_BUFFER_MAP_WRITE: return "RT_BUFFER_MAP_WRITE";
        case RT_BUFFER_MAP_WRITE_DISCARD: return "RT_BUFFER_MAP_WRITE_DISCARD";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTbuffermapflag value )
{
    return str << toString( value );
}

struct RTgeometryflagSet
{
    unsigned int flags;
};

inline std::string toString( RTgeometryflagSet flags )
{
    bool emitted = false;
    std::string result;
    emitFlag( result, emitted, flags.flags, RT_GEOMETRY_FLAG_DISABLE_ANYHIT, "RT_GEOMETRY_FLAG_DISABLE_ANYHIT" );
    emitFlag( result, emitted, flags.flags, RT_GEOMETRY_FLAG_NO_SPLITTING, "RT_GEOMETRY_FLAG_NO_SPLITTING" );
    if( !emitted )
    {
        result = "RT_GEOMETRY_FLAG_NONE";
    }
    return result;
}

inline std::ostream& operator<<( std::ostream& str, RTgeometryflagSet flags )
{
    return str << toString( flags );
}

inline std::string toString( RTpostprocessingstagenull value )
{
    switch( value )
    {
        case RT_POSTPROCESSING_STAGE_ID_NULL: return "RT_POSTPROCESSING_STAGE_ID_NULL";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTpostprocessingstagenull value )
{
    return str << toString( value );
}

inline std::string toString( RTtextureidnull value )
{
    switch( value )
    {
        case RT_TEXTURE_ID_NULL: return "RT_TEXTURE_ID_NULL";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTtextureidnull value )
{
    return str << toString( value );
}

struct RTrayflagSet
{
    unsigned int flags;
};

inline std::string toString( RTrayflagSet flags )
{
    bool emitted = false;
    std::string result;
    emitFlag( result, emitted, flags.flags, RT_RAY_FLAG_DISABLE_ANYHIT, "RT_RAY_FLAG_DISABLE_ANYHIT" );
    emitFlag( result, emitted, flags.flags, RT_RAY_FLAG_FORCE_ANYHIT, "RT_RAY_FLAG_FORCE_ANYHIT" );
    emitFlag( result, emitted, flags.flags, RT_RAY_FLAG_TERMINATE_ON_FIRST_HIT, "RT_RAY_FLAG_TERMINATE_ON_FIRST_HIT" );
    emitFlag( result, emitted, flags.flags, RT_RAY_FLAG_DISABLE_CLOSESTHIT, "RT_RAY_FLAG_DISABLE_CLOSESTHIT" );
    emitFlag( result, emitted, flags.flags, RT_RAY_FLAG_LWLL_BACK_FACING_TRIANGLES, "RT_RAY_FLAG_LWLL_BACK_FACING_TRIANGLES" );
    emitFlag( result, emitted, flags.flags, RT_RAY_FLAG_LWLL_FRONT_FACING_TRIANGLES, "RT_RAY_FLAG_LWLL_FRONT_FACING_TRIANGLES" );
    emitFlag( result, emitted, flags.flags, RT_RAY_FLAG_LWLL_DISABLED_ANYHIT, "RT_RAY_FLAG_LWLL_DISABLED_ANYHIT" );
    emitFlag( result, emitted, flags.flags, RT_RAY_FLAG_LWLL_ENABLED_ANYHIT, "RT_RAY_FLAG_LWLL_ENABLED_ANYHIT" );
    if( !emitted )
    {
        result = "RT_RAY_FLAG_NONE";
    }
    return result;
}

inline std::ostream& operator<<( std::ostream& str, RTrayflagSet flags )
{
    return str << toString( flags );
}

inline std::string toString( RTcommandlistidnull value )
{
    switch( value )
    {
        case RT_COMMAND_LIST_ID_NULL: return "RT_COMMAND_LIST_ID_NULL";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTcommandlistidnull value )
{
    return str << toString( value );
}

inline std::string toString( RTtextureindexmode value )
{
    switch( value )
    {
        case RT_TEXTURE_INDEX_NORMALIZED_COORDINATES: return "RT_TEXTURE_INDEX_NORMALIZED_COORDINATES";
        case RT_TEXTURE_INDEX_ARRAY_INDEX: return "RT_TEXTURE_INDEX_ARRAY_INDEX";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTtextureindexmode value )
{
    return str << toString( value );
}

inline std::string toString( RTfiltermode value )
{
    switch( value )
    {
        case RT_FILTER_NEAREST: return "RT_FILTER_NEAREST";
        case RT_FILTER_LINEAR: return "RT_FILTER_LINEAR";
        case RT_FILTER_NONE: return "RT_FILTER_NONE";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTfiltermode value )
{
    return str << toString( value );
}

inline std::string toString( RTbufferattribute value )
{
    switch( value )
    {
        case RT_BUFFER_ATTRIBUTE_STREAM_FORMAT: return "RT_BUFFER_ATTRIBUTE_STREAM_FORMAT";
        case RT_BUFFER_ATTRIBUTE_STREAM_BITRATE: return "RT_BUFFER_ATTRIBUTE_STREAM_BITRATE";
        case RT_BUFFER_ATTRIBUTE_STREAM_FPS: return "RT_BUFFER_ATTRIBUTE_STREAM_FPS";
        case RT_BUFFER_ATTRIBUTE_STREAM_GAMMA: return "RT_BUFFER_ATTRIBUTE_STREAM_GAMMA";
        case RT_BUFFER_ATTRIBUTE_PAGE_SIZE: return "RT_BUFFER_ATTRIBUTE_PAGE_SIZE";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTbufferattribute value )
{
    return str << toString( value );
}

inline std::string toString( RTbufferidnull value )
{
    switch( value )
    {
        case RT_BUFFER_ID_NULL: return "RT_BUFFER_ID_NULL";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTbufferidnull value )
{
    return str << toString( value );
}

inline std::string toString( RTcontextattribute value )
{
    switch( value )
    {
        case RT_CONTEXT_ATTRIBUTE_MAX_TEXTURE_COUNT: return "RT_CONTEXT_ATTRIBUTE_MAX_TEXTURE_COUNT";
        case RT_CONTEXT_ATTRIBUTE_CPU_NUM_THREADS: return "RT_CONTEXT_ATTRIBUTE_CPU_NUM_THREADS";
        case RT_CONTEXT_ATTRIBUTE_USED_HOST_MEMORY: return "RT_CONTEXT_ATTRIBUTE_USED_HOST_MEMORY";
        case RT_CONTEXT_ATTRIBUTE_GPU_PAGING_ACTIVE: return "RT_CONTEXT_ATTRIBUTE_GPU_PAGING_ACTIVE";
        case RT_CONTEXT_ATTRIBUTE_GPU_PAGING_FORCED_OFF: return "RT_CONTEXT_ATTRIBUTE_GPU_PAGING_FORCED_OFF";
        case RT_CONTEXT_ATTRIBUTE_DISK_CACHE_ENABLED: return "RT_CONTEXT_ATTRIBUTE_DISK_CACHE_ENABLED";
        case RT_CONTEXT_ATTRIBUTE_PREFER_FAST_RECOMPILES: return "RT_CONTEXT_ATTRIBUTE_PREFER_FAST_RECOMPILES";
        case RT_CONTEXT_ATTRIBUTE_FORCE_INLINE_USER_FUNCTIONS: return "RT_CONTEXT_ATTRIBUTE_FORCE_INLINE_USER_FUNCTIONS";
        case RT_CONTEXT_ATTRIBUTE_OPTIX_SALT: return "RT_CONTEXT_ATTRIBUTE_OPTIX_SALT";
        case RT_CONTEXT_ATTRIBUTE_VENDOR_SALT: return "RT_CONTEXT_ATTRIBUTE_VENDOR_SALT";
        case RT_CONTEXT_ATTRIBUTE_PUBLIC_VENDOR_KEY: return "RT_CONTEXT_ATTRIBUTE_PUBLIC_VENDOR_KEY";
        case RT_CONTEXT_ATTRIBUTE_DISK_CACHE_LOCATION: return "RT_CONTEXT_ATTRIBUTE_DISK_CACHE_LOCATION";
        case RT_CONTEXT_ATTRIBUTE_DISK_CACHE_MEMORY_LIMITS: return "RT_CONTEXT_ATTRIBUTE_DISK_CACHE_MEMORY_LIMITS";
        case RT_CONTEXT_ATTRIBUTE_PREFER_WATERTIGHT_TRAVERSAL: return "RT_CONTEXT_ATTRIBUTE_PREFER_WATERTIGHT_TRAVERSAL";
        case RT_CONTEXT_ATTRIBUTE_MAX_CONLWRRENT_LAUNCHES: return "RT_CONTEXT_ATTRIBUTE_MAX_CONLWRRENT_LAUNCHES";
#ifdef OPTIX_OPTIONAL_FEATURE_DEPRECATED_ATTRIBUTES
        case RT_CONTEXT_ATTRIBUTE_DEMAND_LOAD_NUM_THREADS: return "RT_CONTEXT_ATTRIBUTE_DEMAND_LOAD_NUM_THREADS";
#endif // OPTIX_OPTIONAL_FEATURE_DEPRECATED_ATTRIBUTES
        case RT_CONTEXT_ATTRIBUTE_DEMAND_LOAD_MULTITHREADED_CALLBACKS_ENABLED: return "RT_CONTEXT_ATTRIBUTE_DEMAND_LOAD_MULTITHREADED_CALLBACKS_ENABLED";
        case RT_CONTEXT_ATTRIBUTE_USE_HARDWARE_SPARSE_TEXTURES: return "RT_CONTEXT_ATTRIBUTE_USE_HARDWARE_SPARSE_TEXTURES";
#ifdef OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
        case RT_CONTEXT_INTERNAL_ATTRIBUTE_DEMAND_LOAD_FORCE_SYNCHRONOUS: return "RT_CONTEXT_INTERNAL_ATTRIBUTE_DEMAND_LOAD_FORCE_SYNCHRONOUS";
#endif // OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
#ifdef OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
        case RT_CONTEXT_INTERNAL_ATTRIBUTE_DEMAND_LOAD_USE_ASYNC_COPIES: return "RT_CONTEXT_INTERNAL_ATTRIBUTE_DEMAND_LOAD_USE_ASYNC_COPIES";
#endif // OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
#ifdef OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
        case RT_CONTEXT_INTERNAL_ATTRIBUTE_DEMAND_LOAD_STAMP_MEMORY_BLOCKS: return "RT_CONTEXT_INTERNAL_ATTRIBUTE_DEMAND_LOAD_STAMP_MEMORY_BLOCKS";
#endif // OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
#ifdef OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
        case RT_CONTEXT_INTERNAL_ATTRIBUTE_SUBFRAME_INDEX: return "RT_CONTEXT_INTERNAL_ATTRIBUTE_SUBFRAME_INDEX";
#endif // OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
#ifdef OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
        case RT_CONTEXT_INTERNAL_ATTRIBUTE_RESERVE_PROGRAM_ID: return "RT_CONTEXT_INTERNAL_ATTRIBUTE_RESERVE_PROGRAM_ID";
#endif // OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
#ifdef OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
        case RT_CONTEXT_INTERNAL_ATTRIBUTE_RESERVE_BUFFER_ID: return "RT_CONTEXT_INTERNAL_ATTRIBUTE_RESERVE_BUFFER_ID";
#endif // OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
#ifdef OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
        case RT_CONTEXT_INTERNAL_ATTRIBUTE_RESERVE_TEXTURE_SAMPLER_ID: return "RT_CONTEXT_INTERNAL_ATTRIBUTE_RESERVE_TEXTURE_SAMPLER_ID";
#endif // OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
#ifdef OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
        case RT_CONTEXT_INTERNAL_ATTRIBUTE_PROGRAM_ID_HINT: return "RT_CONTEXT_INTERNAL_ATTRIBUTE_PROGRAM_ID_HINT";
#endif // OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
#ifdef OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
        case RT_CONTEXT_INTERNAL_ATTRIBUTE_BUFFER_ID_HINT: return "RT_CONTEXT_INTERNAL_ATTRIBUTE_BUFFER_ID_HINT";
#endif // OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
#ifdef OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
        case RT_CONTEXT_INTERNAL_ATTRIBUTE_TEXTURE_SAMPLER_ID_HINT: return "RT_CONTEXT_INTERNAL_ATTRIBUTE_TEXTURE_SAMPLER_ID_HINT";
#endif // OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
#ifdef OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
        case RT_CONTEXT_INTERNAL_ATTRIBUTE_STACK_SIZE: return "RT_CONTEXT_INTERNAL_ATTRIBUTE_STACK_SIZE";
#endif // OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
#ifdef OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
#ifdef OPTIX_OPTIONAL_FEATURE_DEPRECATED_ATTRIBUTES
        case RT_CONTEXT_INTERNAL_ATTRIBUTE_FORCE_DEMAND_LOAD_WHOLE_MIP_LEVEL: return "RT_CONTEXT_INTERNAL_ATTRIBUTE_FORCE_DEMAND_LOAD_WHOLE_MIP_LEVEL";
#endif // OPTIX_OPTIONAL_FEATURE_DEPRECATED_ATTRIBUTES
#endif // OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
        case RT_CONTEXT_ATTRIBUTE_AVAILABLE_DEVICE_MEMORY: return "RT_CONTEXT_ATTRIBUTE_AVAILABLE_DEVICE_MEMORY";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTcontextattribute value )
{
    return str << toString( value );
}

inline std::string toString( RTexception value )
{
    switch( value )
    {
        case RT_EXCEPTION_PAYLOAD_ACCESS_OUT_OF_BOUNDS: return "RT_EXCEPTION_PAYLOAD_ACCESS_OUT_OF_BOUNDS";
        case RT_EXCEPTION_USER_EXCEPTION_CODE_OUT_OF_BOUNDS: return "RT_EXCEPTION_USER_EXCEPTION_CODE_OUT_OF_BOUNDS";
        case RT_EXCEPTION_TRACE_DEPTH_EXCEEDED: return "RT_EXCEPTION_TRACE_DEPTH_EXCEEDED";
        case RT_EXCEPTION_PROGRAM_ID_ILWALID: return "RT_EXCEPTION_PROGRAM_ID_ILWALID";
        case RT_EXCEPTION_TEXTURE_ID_ILWALID: return "RT_EXCEPTION_TEXTURE_ID_ILWALID";
        case RT_EXCEPTION_BUFFER_ID_ILWALID: return "RT_EXCEPTION_BUFFER_ID_ILWALID";
        case RT_EXCEPTION_INDEX_OUT_OF_BOUNDS: return "RT_EXCEPTION_INDEX_OUT_OF_BOUNDS";
        case RT_EXCEPTION_STACK_OVERFLOW: return "RT_EXCEPTION_STACK_OVERFLOW";
        case RT_EXCEPTION_BUFFER_INDEX_OUT_OF_BOUNDS: return "RT_EXCEPTION_BUFFER_INDEX_OUT_OF_BOUNDS";
        case RT_EXCEPTION_ILWALID_RAY: return "RT_EXCEPTION_ILWALID_RAY";
        case RT_EXCEPTION_INTERNAL_ERROR: return "RT_EXCEPTION_INTERNAL_ERROR";
        case RT_EXCEPTION_USER: return "RT_EXCEPTION_USER";
        case RT_EXCEPTION_USER_MAX: return "RT_EXCEPTION_USER_MAX";
        case RT_EXCEPTION_ALL: return "RT_EXCEPTION_ALL";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTexception value )
{
    return str << toString( value );
}

inline std::string toString( RTglobalattribute value )
{
    switch( value )
    {
        case RT_GLOBAL_ATTRIBUTE_DISPLAY_DRIVER_VERSION_MAJOR: return "RT_GLOBAL_ATTRIBUTE_DISPLAY_DRIVER_VERSION_MAJOR";
        case RT_GLOBAL_ATTRIBUTE_DISPLAY_DRIVER_VERSION_MINOR: return "RT_GLOBAL_ATTRIBUTE_DISPLAY_DRIVER_VERSION_MINOR";
        case RT_GLOBAL_ATTRIBUTE_DEMAND_LOAD_NUM_VIRTUAL_PAGES: return "RT_GLOBAL_ATTRIBUTE_DEMAND_LOAD_NUM_VIRTUAL_PAGES";
#ifdef OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
        case RT_GLOBAL_INTERNAL_ATTRIBUTE_FORCE_DEMAND_LOAD_WHOLE_MIP_LEVEL: return "RT_GLOBAL_INTERNAL_ATTRIBUTE_FORCE_DEMAND_LOAD_WHOLE_MIP_LEVEL";
#endif // OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
#ifdef OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
        case RT_GLOBAL_INTERNAL_ATTRIBUTE_SUBFRAME_INDEX: return "RT_GLOBAL_INTERNAL_ATTRIBUTE_SUBFRAME_INDEX";
#endif // OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
#ifdef OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
        case RT_GLOBAL_INTERNAL_ATTRIBUTE_RESERVE_PROGRAM_ID: return "RT_GLOBAL_INTERNAL_ATTRIBUTE_RESERVE_PROGRAM_ID";
#endif // OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
#ifdef OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
        case RT_GLOBAL_INTERNAL_ATTRIBUTE_RESERVE_BUFFER_ID: return "RT_GLOBAL_INTERNAL_ATTRIBUTE_RESERVE_BUFFER_ID";
#endif // OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
#ifdef OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
        case RT_GLOBAL_INTERNAL_ATTRIBUTE_RESERVE_TEXTURE_SAMPLER_ID: return "RT_GLOBAL_INTERNAL_ATTRIBUTE_RESERVE_TEXTURE_SAMPLER_ID";
#endif // OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
#ifdef OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
        case RT_GLOBAL_INTERNAL_ATTRIBUTE_PROGRAM_ID_HINT: return "RT_GLOBAL_INTERNAL_ATTRIBUTE_PROGRAM_ID_HINT";
#endif // OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
#ifdef OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
        case RT_GLOBAL_INTERNAL_ATTRIBUTE_BUFFER_ID_HINT: return "RT_GLOBAL_INTERNAL_ATTRIBUTE_BUFFER_ID_HINT";
#endif // OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
#ifdef OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
        case RT_GLOBAL_INTERNAL_ATTRIBUTE_TEXTURE_SAMPLER_ID_HINT: return "RT_GLOBAL_INTERNAL_ATTRIBUTE_TEXTURE_SAMPLER_ID_HINT";
#endif // OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
#ifdef OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
        case RT_GLOBAL_INTERNAL_ATTRIBUTE_STACK_SIZE: return "RT_GLOBAL_INTERNAL_ATTRIBUTE_STACK_SIZE";
#endif // OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
#ifdef OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
#ifdef OPTIX_OPTIONAL_FEATURE_DEPRECATED_ATTRIBUTES
        case RT_GLOBAL_INTERNAL_ATTRIBUTE_FORCE_DEMAND_LOAD_WHOLE_MIP_LEVEL_BACK_COMPAT: return "RT_GLOBAL_INTERNAL_ATTRIBUTE_FORCE_DEMAND_LOAD_WHOLE_MIP_LEVEL_BACK_COMPAT";
#endif // OPTIX_OPTIONAL_FEATURE_DEPRECATED_ATTRIBUTES
#endif // OPTIX_OPTIONAL_FEATURE_INTERNAL_ATTRIBUTES
        case RT_GLOBAL_ATTRIBUTE_ENABLE_RTX: return "RT_GLOBAL_ATTRIBUTE_ENABLE_RTX";
        case RT_GLOBAL_ATTRIBUTE_DEVELOPER_OPTIONS: return "RT_GLOBAL_ATTRIBUTE_DEVELOPER_OPTIONS";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTglobalattribute value )
{
    return str << toString( value );
}

inline std::string toString( RTwrapmode value )
{
    switch( value )
    {
        case RT_WRAP_REPEAT: return "RT_WRAP_REPEAT";
        case RT_WRAP_CLAMP_TO_EDGE: return "RT_WRAP_CLAMP_TO_EDGE";
        case RT_WRAP_MIRROR: return "RT_WRAP_MIRROR";
        case RT_WRAP_CLAMP_TO_BORDER: return "RT_WRAP_CLAMP_TO_BORDER";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTwrapmode value )
{
    return str << toString( value );
}

inline std::string toString( RTbuffertype value )
{
    switch( value )
    {
        case RT_BUFFER_INPUT: return "RT_BUFFER_INPUT";
        case RT_BUFFER_OUTPUT: return "RT_BUFFER_OUTPUT";
        case RT_BUFFER_INPUT_OUTPUT: return "RT_BUFFER_INPUT_OUTPUT";
        case RT_BUFFER_PROGRESSIVE_STREAM: return "RT_BUFFER_PROGRESSIVE_STREAM";
    }
    return std::to_string( static_cast<unsigned long>( value ) );
}

inline std::ostream& operator<<( std::ostream& str, RTbuffertype value )
{
    return str << toString( value );
}

