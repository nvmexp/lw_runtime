#
#  Copyright (c) 2020 LWPU Corporation.  All rights reserved.
#
#  LWPU Corporation and its licensors retain all intellectual property and proprietary
#  rights in and to this software, related documentation and any modifications thereto.
#  Any use, reproduction, disclosure or distribution of this software and related
#  documentation without an express license agreement from LWPU Corporation is strictly
#  prohibited.
#
#  TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, THIS SOFTWARE IS PROVIDED *AS IS*
#  AND LWPU AND ITS SUPPLIERS DISCLAIM ALL WARRANTIES, EITHER EXPRESS OR IMPLIED,
#  INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
#  PARTICULAR PURPOSE.  IN NO EVENT SHALL LWPU OR ITS SUPPLIERS BE LIABLE FOR ANY
#  SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, WITHOUT
#  LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF
#  BUSINESS INFORMATION, OR ANY OTHER PELWNIARY LOSS) ARISING OUT OF THE USE OF OR
#  INABILITY TO USE THIS SOFTWARE, EVEN IF LWPU HAS BEEN ADVISED OF THE POSSIBILITY OF
#  SUCH DAMAGES
#

# enum-printer.py
#
# Parse OptiX 7 header file and generate functions to get strings from
# enums and flags.  The parsing assumes certain colwentions followed by the header
# files with respect to identifier colwentions of enum types and their enumerants
# as well as colwentions regarding conditional compilation of enumerants via
# #ifdef/#endif blocks.  Deviating from those assumptions will result in missing
# enumerants or missing enum types in the output.
#
# For flags enums, generate a data type that can be used to manipulate the flag set
# in a typesafe manner.
#
# Usage:
#
# make/enum-printer.py optix7Types > include/private/optix_7_enum_printers.h
#
# make/enum-printer.py rtCoreInterfaceTypes > include/private/rtcore_enum_printers.h
#
# make/enum-printer.py optix6Declarations > include/private/optix_6_enum_printers.h
#
from datetime import date
import os
import re
import sys

enums = {}
conditionalEnums = {}
conditionalEnumerants = {}
flagsHelpersPrinted = False
# Set to True to emit binary operators for "flags" set enums
emitOperators = False
generateCommand = ""

# Special case these enumerants and prevent them from being emitted.
# The values of these enumerants are identical to other values and
# cause duplicate value errors in the switch/case if they are emitted.
blackList = ['RTC_ABI_VARIANT_V1','OPTIX_PAYLOAD_SEMANTICS_CH_NONE','OPTIX_PAYLOAD_SEMANTICS_MS_NONE','OPTIX_PAYLOAD_SEMANTICS_AH_NONE','OPTIX_PAYLOAD_SEMANTICS_IS_NONE']

def emitPrologue(defines, includes):
    global generateCommand
    print "//"
    print "//  Copyright (c) " + str(date.today().year) + " LWPU Corporation.  All rights reserved."
    print "//"
    print "//  LWPU Corporation and its licensors retain all intellectual property and proprietary"
    print "//  rights in and to this software, related documentation and any modifications thereto."
    print "//  Any use, reproduction, disclosure or distribution of this software and related"
    print "//  documentation without an express license agreement from LWPU Corporation is strictly"
    print "//  prohibited."
    print "//"
    print "//  TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, THIS SOFTWARE IS PROVIDED *AS IS*"
    print "//  AND LWPU AND ITS SUPPLIERS DISCLAIM ALL WARRANTIES, EITHER EXPRESS OR IMPLIED,"
    print "//  INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A"
    print "//  PARTICULAR PURPOSE.  IN NO EVENT SHALL LWPU OR ITS SUPPLIERS BE LIABLE FOR ANY"
    print "//  SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, WITHOUT"
    print "//  LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF"
    print "//  BUSINESS INFORMATION, OR ANY OTHER PELWNIARY LOSS) ARISING OUT OF THE USE OF OR"
    print "//  INABILITY TO USE THIS SOFTWARE, EVEN IF LWPU HAS BEEN ADVISED OF THE POSSIBILITY OF"
    print "//  SUCH DAMAGES"
    print "//"
    print ""
    print "#pragma once"
    print ""
    print "// Generated by apps/optix/make/enum-printer.py -- DO NOT EDIT!"
    print "// Command: " + generateCommand
    print ""
    for define in defines:
        print "#if !defined( " + define + " )"
        print "#define " + define
        print "#endif // " + define
    for include in includes:
        print "#include <" + include + ">"
    print ""
    print "#include <iostream>"
    print "#include <string>"
    print ""

def emitFlagsHelpers():
    print ""
    print "#if !defined( EMIT_FLAG_DEFINED )"
    print "inline void emitFlag( std::string& result, bool& emitted, unsigned long flags, unsigned long flag, const char* enumerant )"
    print "{"
    print "    if( flags & flag )"
    print "    {"
    print "        if( emitted )"
    print "        {"
    print "            result += \" | \";"
    print "        }"
    print "        result += enumerant;"
    print "        emitted = true;"
    print "    }"
    print "}"
    print "#endif // EMIT_FLAG_DEFINED"
    print "#define EMIT_FLAG_DEFINED"
    print ""

def emitEnumIfDef(enumName):
    global conditionalEnums
    if enumName in conditionalEnums:
        for define in conditionalEnums[enumName]:
            print "#if " + define

def emitEnumEndIf(enumName):
    global conditionalEnums
    if enumName in conditionalEnums:
        for define in reversed(conditionalEnums[enumName]):
            print "#endif // " + define

def emitEnumerantIfDef(enumName, enumerant):
    global conditionalEnums, conditionalEnumerants
    if enumerant in conditionalEnumerants:
        for define in conditionalEnumerants[enumerant]:
            if not enumName in conditionalEnums or not define in conditionalEnums[enumName]:
                print "#if " + define

def emitEnumerantEndIf(enumName, enumerant):
    global conditionalEnums, conditionalEnumerants
    if enumerant in conditionalEnumerants:
        for define in reversed(conditionalEnumerants[enumerant]):
            if not enumName in conditionalEnums or not define in conditionalEnums[enumName]:
                print "#endif // " + define

def emitFlagsToString(enumName):
    global flagsHelpersPrinted, emitOperators, enums, conditionalEnums, conditionalEnumerants
    if not flagsHelpersPrinted:
        emitFlagsHelpers()
        flagsHelpersPrinted = True
    setName = enumName[0:len(enumName)-1] + "Set";
    emitEnumIfDef(enumName)
    print "struct " + setName
    print "{"
    print "    unsigned int flags;"
    print "};"
    print ""
    if emitOperators:
        for binOp in ["|", "^", "&"]:
            print "inline " + setName + " operator" + binOp + "( " + setName + " flags, " + enumName + " flag )"
            print "{"
            print "    flags.flags " + binOp + "= flag;"
            print "    return flags;"
            print "}"
            print ""
            print "inline " + setName + " operator" + binOp + "( " + enumName + " flag, " + setName + " flags )"
            print "{"
            print "    return flags | flag;"
            print "}"
            print ""
        print "inline " + setName + " operator~( " + setName + " flags )"
        print "{"
        for enumerant in enums[enumName]:
            # Skip 'none' flags
            if not enumerant.endswith("_NONE"):
                print "    flags.flags ^= " + enumerant + ";"
        print "    return flags;"
        print "}"
        print ""
    print "inline std::string toString( " + setName + " flags )"
    print "{"
    print "    bool emitted = false;"
    print "    std::string result;"
    noneFlag = "0"
    for enumerant in enums[enumName]:
        if enumerant.endswith("_NONE"):
            noneFlag = enumerant
        else:
            emitEnumerantIfDef(enumName, enumerant)
            print "    emitFlag( result, emitted, flags.flags, " + enumerant + ", \"" + enumerant + "\" );"
            emitEnumerantEndIf(enumName, enumerant)
    print "    if( !emitted )"
    print "    {"
    print "        result = \"" + noneFlag + "\";"
    print "    }"
    print "    return result;"
    print "}"
    print ""
    print "inline std::ostream& operator<<( std::ostream& str, " + setName + " flags )"
    print "{"
    print "    return str << toString( flags );"
    print "}"
    emitEnumEndIf(enumName)
    print ""

def emitEnumToString(enumName):
    global enums, conditionalEnums, conditionalEnumerants
    emitEnumIfDef(enumName)
    # Special case for OptixResult to lookup the name via a function
    if enumName == "OptixResult":
        print "inline std::string toString( OptixResult value )"
        print "{"
        print "    return optixGetErrorName( value );"
        print "}"
    else:
        print "inline std::string toString( " + enumName + " value )"
        print "{"
        print "    switch( value )"
        print "    {"
        for enumerant in enums[enumName]:
            emitEnumerantIfDef(enumName, enumerant)
            print "        case " + enumerant + ": return \"" + enumerant + "\";"
            emitEnumerantEndIf(enumName, enumerant)
        print "    }"
        print "    return std::to_string( static_cast<unsigned long>( value ) );"
        print "}"
    print ""
    print "inline std::ostream& operator<<( std::ostream& str, " + enumName + " value )"
    print "{"
    print "    return str << toString( value );"
    print "}"
    emitEnumEndIf(enumName)
    print ""

def emitHeader(defines, includes, enums):
    emitPrologue(defines, includes)
    for enumName in enums:
        if enumName.endswith('Flags') or enumName.endswith('flags'):
            emitFlagsToString(enumName)
        else:
            emitEnumToString(enumName)

def mergeDefines(dict, key, conditionals):
    if not key in dict:
        dict[key] = []
    for conditional in conditionals:
        if not conditional in dict[key]:
            dict[key].append(conditional)
    return dict

def parse(typePrefix, enumPrefix, path, defines, skipIfs):
    global blackList, enums, conditionalEnums, conditionalEnumerants
    lineNum = 0;
    foundEnum = False
    foundAnon = False
    skipToEndIf = False
    IfStack = []

    with open(path, "r") as file:
        for line in file:
            line = line.strip()
            lineNum = lineNum + 1
            if len(line) == 0:
                continue
            if line.startswith("#ifdef"):
                foundConditional = True
                define = line.split(' ')[1]
                if not define in skipIfs:
                    IfStack.append("defined( " + define + " )")
            if line.startswith("#ifndef"):
                foundConditional = True
                define = line.split(' ')[1]
                if not define in skipIfs:
                    IfStack.append("!defined( " + define + " )")
            elif line.startswith("#if "):
                foundConditional = True
                lineTokens = line.split(' ')
                if len(lineTokens) == 2:
                    define = lineTokens[1]
                    if not define in skipIfs:
                        IfStack.append(define)
                else:
                    define = line[4:]
                    if not define in skipIfs:
                        IfStack.append("( " + define + " )")

            elif line.startswith("#endif"):
                lineTokens = line.split(' ')
                foundSkipEndif = False
                for t in lineTokens:
                    if t in skipIfs:
                        foundSkipEndif = True
                if not foundSkipEndif:
                    IfStack.pop()
                foundConditional = len(IfStack) > 0
            else:
                match = re.match("typedef enum (" + typePrefix + "[^\s]+)", line)
                if match:
                    enumName = match.group(1)
                    if foundConditional:
                        conditionalEnums = mergeDefines(conditionalEnums, enumName, IfStack)
                    enums[enumName] = []
                    foundEnum = True
                    continue

                match = re.match("typedef enum", line)
                if match:
                    anonEnum = []
                    foundAnon = True
                    continue

                if foundAnon or foundEnum:
                    match = re.match("[\s,]*(" + enumPrefix + "_[^\s,=]*)", line)
                    if match:
                        enumerantName = match.group(1)
                        # Skip blacklisted enumerants
                        if not enumerantName in blackList:
                            if foundEnum:
                                enums[enumName].append(enumerantName)
                            else:
                                anonEnum.append(enumerantName)
                            if foundConditional:
                                conditionalEnumerants = mergeDefines(conditionalEnumerants, enumerantName, IfStack)
                    else:
                        match = re.match("} (" + typePrefix + "[^\s]+);", line)
                        if match and foundAnon:
                            enumName = match.group(1);
                            if foundConditional:
                                conditionalEnums = mergeDefines(conditionalEnums, enumName, IfStack)
                            enums[enumName] = anonEnum
                            foundAnon = False
                        elif re.match("}.*;", line):
                            foundEnum = False

def checkLocation(location, file):
    if not os.path.exists(file) and os.path.exists(location + file):
        return location + file
    return file

def process(typePrefix, enumPrefix, defines, includes, file, skipIfs):
    file = checkLocation('apps/optix/', file)
    file = checkLocation('../', file)
    parse(typePrefix, enumPrefix, file, defines, skipIfs)
    emitHeader(defines, includes, enums)

def optix7Types():
    process("Optix", "OPTIX", [], ["optix_host.h"], "include/optix_7_types.h", ["__optix_optix_7_types_h__"])

def rtCoreInterfaceTypes():
    process("Rtc", "RTC", [], ["rtcore/interface/types.h"], "../../drivers/rtcore/rtcore/interface/types.h", ["RTCORE_INTERFACE_TYPES_H"])

def optix6Declarations():
    process("RT", "RT", [], ["o6/optix.h"], "include/internal/optix_declarations.h", ["__optix_optix_declarations_h__"])

def main():
    global generateCommand
    generateCommand = 'enum-printer.py ' + ' '.join(sys.argv[1:])
    if sys.argv[-1] == "optix7Types":
        optix7Types()
    elif sys.argv[-1] == "rtCoreInterfaceTypes":
        rtCoreInterfaceTypes()
    elif sys.argv[-1] == "optix6Declarations":
        optix6Declarations()
    else:
        typePrefix = "Optix"
        enumPrefix = "OPTIX"
        defines = []
        includes = ["optix_host.h"]
        if len(sys.argv) == 5:
            typePrefix = sys.argv[-4]
            enumPrefix = sys.argv[-3]
            defines = []
            includes = [sys.argv[-2]]
        file = sys.argv[-1]
        process(typePrefix, enumPrefix, defines, includes, file)

main()
