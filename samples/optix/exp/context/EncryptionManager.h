/*
 * Copyright (c) 2019, LWPU CORPORATION.  All rights reserved.
 *
 * LWPU Corporation and its licensors retain all intellectual property and proprietary
 * rights in and to this software, related documentation and any modifications thereto.
 * Any use, reproduction, disclosure or distribution of this software and related
 * documentation without an express license agreement from LWPU Corporation is strictly
 * prohibited.
 *
 * TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, THIS SOFTWARE IS PROVIDED *AS IS*
 * AND LWPU AND ITS SUPPLIERS DISCLAIM ALL WARRANTIES, EITHER EXPRESS OR IMPLIED,
 * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE.  IN NO EVENT SHALL LWPU OR ITS SUPPLIERS BE LIABLE FOR ANY
 * SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, WITHOUT
 * LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF
 * BUSINESS INFORMATION, OR ANY OTHER PELWNIARY LOSS) ARISING OUT OF THE USE OF OR
 * INABILITY TO USE THIS SOFTWARE, EVEN IF LWPU HAS BEEN ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGES
 */

#pragma once

#include <cstddef>
#include <memory>
#include <mutex>
#include <string>
#include <vector>

#define __OPTIX_INCLUDE_INTERNAL_HEADERS__
#include <optix_7_types.h>
#undef __OPTIX_INCLUDE_INTERNAL_HEADERS__

#include <exp/context/ErrorHandling.h>

#include <prodlib/misc/String.h>

namespace optix_exp {

class EncryptionManager
{
  public:
    /// Default constructor.
    ///
    /// Generates the OptiX salt. Encryption is still disabled.
    EncryptionManager();

    /// \name API functions to set encryption data
    //@{

    /// Returns the OptiX salt.
    ///
    /// Note that OptiX salt might contain null bytes.
    OptixResult getOptixSalt( void* salt, size_t saltLength, ErrorDetails& errDetails );

    /// Sets the OptiX salt.
    ///
    /// Note that OptiX salt might contain null bytes. This method fails if vendor salt and public
    /// vendor key have already been set.
    OptixResult setOptixSalt( const void* salt, size_t saltLength, ErrorDetails& errDetails );

    /// Sets the vendor salt.
    ///
    /// As soon as vendor salt and public vendor key have been set, a session key is generated and
    /// encryption is enabled. Afterwards, the vendor salt cannot be changed anymore.
    ///
    /// Note that vendor salt might contain null bytes.
    OptixResult setVendorSalt( const void* salt, size_t saltLength, ErrorDetails& errDetails );

    /// Sets the public vendor key in a hexadecimal encoded form.
    ///
    /// As soon as vendor salt and public vendor key have been set, a session key is generated and
    /// encryption is enabled. Afterwards, the public vendor key cannot be changed anymore.
    OptixResult setPublicVendorKey( const void* key, size_t keyLength, ErrorDetails& errDetails );

    //@}
    /// \name Internal functions
    //@{

    /// Indicates whether encryption is enabled.
    ///
    /// This happens as soon as vendor salt and public vendor key have been set. There is no way to
    /// disable encryption again (except for replacing this instance in its context by a new one).
    bool isEncryptionEnabled() const;

    /// Indicates whether the weak variant is used (OptiX salt was set instead of being generated by
    /// this class).
    bool isWeakVariant() const;

    /// Returns true if the string has a known prefix used for all encrypted strings.
    bool hasEncryptionPrefix( const prodlib::StringView& input ) const;

    /// Decrypts the given string using the generated session key.
    ///
    /// Requires that isEncryptionEnabled() and hasEncryptionPrefix(encrypted) return true.
    ///
    /// Note that the decrypted output is not necessarily null-terminated.
    OptixResult decrypt( const prodlib::StringView& encrypted, std::vector<char>& decryptedData, ErrorDetails& errDetails ) const;

    /// Decrypts the given string partially using the generated session key.
    ///
    /// At most windowSize decrypted bytes will be added to decryptedData. The number of processed
    /// bytes (from the encryptedStr) will be returned inside the out parameter consumed.
    /// Requires that isEncryptionEnabled() and hasEncryptionPrefix(encrypted) return true and false respectively.
    OptixResult decryptString( const prodlib::StringView& encryptedStr, char* decryptedData, size_t& decryptedDataSize, size_t windowSize, size_t& consumed, ErrorDetails& errDetails );
    
    /// Decrypts the given string partially using the generated session key taking the encryption
    /// prefix into account.
    ///
    /// At most windowSize decrypted bytes will be added to decryptedData. The number of processed
    /// bytes (from the encryptedStr) including the encryption prefix will be returned inside the
    /// out parameter consumed.
    /// Requires that isEncryptionEnabled() and hasEncryptionPrefix(encrypted) return true.
    OptixResult decryptStringWithPrefix( const prodlib::StringView& encryptedStr,
                                         char*                      decryptedData,
                                         size_t&                    decryptedDataSize,
                                         size_t                     windowSize,
                                         size_t&                    consumed,
                                         ErrorDetails&              errDetails );
    //@}

    /// Reverts the encoding done in PtxEncryption::encode().
    ///
    /// Note that outputData might contain null bytes.
    static OptixResult decode( const prodlib::StringView& input, std::vector<char>& outputData, ErrorDetails& errDetails );
    static OptixResult decodeString( const prodlib::StringView& encryptedStr, char* decodedData, size_t& decoded, size_t windowSize, size_t& consumed, ErrorDetails& errDetails );

    static const std::string& getEncryptionPrefix() { return s_prefix; }

  private:
    /// Indicates whether encryption is enabled.
    ///
    /// This happens as soon as vendor salt and public vendor key have been set. There is no way to
    /// disable encryption again (except for replacing this instance in its context by a new one).
    /// Caller needs to lock m_mutex.
    bool isEncryptionEnabledLocked() const;

    /// Returns the length of the vendor salt.
    size_t getVendorSaltLength() const;

    /// Returns the length of the public vendor key.
    size_t getPublicVendorKeyLength() const;

    /// Generates the session key.
    void generateSessionKey();

    /// Reverts the encryption done in PtxEncryption::encryptTea().
    void decryptTea( char* data, size_t length ) const;

    /// Clears the buffer of the given length, preferably in a way that is not optimized out.
    static void clearMemory( void* buffer, size_t length );

    /// Colwerts the input into hexadecimal notation and writes it to buffer[0] and buffer[1].
    static void hexify( unsigned char* buffer, unsigned char input );

    /// Returns the LWPU secret key.
    ///
    /// The buffer must have a length of 64 bytes.
    ///
    /// Note that the LWPU secret key might contain null bytes (but the current choice does not).
    void getSecretLwidiaKey( void* buffer, size_t bufferLength );

    /// The length of the OptiX and vendor salt.
    static const size_t s_saltLength = 32;

    /// Magic prefix for encrypted PTX strings.
    static const std::string s_prefix;

    unsigned char              m_optixSalt[s_saltLength];
    unsigned char              m_vendorSalt[s_saltLength];
    std::vector<unsigned char> m_publicVendorKey;

    bool m_vendorSaltSet      = false;
    bool m_publicVendorKeySet = false;
    bool m_weakVariant        = false;

    std::vector<unsigned char> m_sessionKey;

    /// Mutex that protects all member variables.
    mutable std::mutex m_mutex;
};

}  // namespace optix_exp

// Providing C interface
bool decryptString( void* encrypter, const char* encrypted, size_t encrypted_len, char* decrypted, size_t* decrypted_len, size_t window_size, size_t* consumed );
