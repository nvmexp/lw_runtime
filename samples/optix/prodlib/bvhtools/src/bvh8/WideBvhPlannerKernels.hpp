// Copyright LWPU Corporation 2015
// TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, THIS SOFTWARE IS PROVIDED
// *AS IS* AND LWPU AND ITS SUPPLIERS DISCLAIM ALL WARRANTIES, EITHER EXPRESS
// OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL LWPU OR ITS SUPPLIERS
// BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES
// WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
// BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PELWNIARY LOSS)
// ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE, EVEN IF LWPU HAS
// BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES

#pragma once
#include <prodlib/bvhtools/src/common/TypesInternal.hpp>
#include <prodlib/bvhtools/src/bounds/ApexPointMap.hpp>

namespace prodlib
{
namespace bvhtools
{
//------------------------------------------------------------------------
// Binary BVH node used as the input/output of WideBvhPlanner.
//
// Produced by AacBuilder,
// annotated by WideBvhPlanner,
// consumed by XxxConstructor.
//
// - Sibling nodes are stored in pairs: leftSiblingIdx = pairIdx + 0, rightSiblingIdx = pairIdx + 1, pairIdx is always even.
// - The root node is not stored; the child node pair of the root is at index 0.
// - Each leaf node contains exactly one primitive.

struct PlannerBinaryNode                // 16 bytes
{
    int childPairIdx;                   // Internal node: childPairIdx = index of the left child node. The right child node is at childPairId +1.
                                        // Leaf node:     childPairIdx = ~(index of the PrimitiveAABB).
                                        // Unused node:   childPairIdx = INT_MIN.

    struct BeforePlan                   // WideBvhPlanner input/temp:
    {                                   
        float   halfArea;               // Input: Surface area of the normalized AABB of this node.
        int     parentIdx;              // Input: Index of the parent node, or -1 if the parent is root.
        float   primitiveCost;          // Temp: SAH cost of creating a separate leaf node for each primitive in the subtree.
    };                                  
                                        
    struct AfterPlan                    // WideBvhPlanner output:
    {                                   
        float   subtreeCost;            // Total SAH cost of this subtree, excluding the effect of multiple roots.
        int     subtreePrims;           // Total number of primitives in this subtree. Highest bit = should the subtree be collapsed into a leaf node?
        int     ownerSubtreePrims;      // ownerSubtreePrims >= wideNodeSubtreePrims iff this node is an internal node of a given hypothetical wide node.
    };
    
    union
    {
        BeforePlan beforePlan;
        AfterPlan afterPlan;
    };
};

//------------------------------------------------------------------------
// Temporary data associated with each pair of binary BVH nodes for
// WideBvhPlanner. The data is split into two sub-arrays to facilitate
// buffer layout in top-level builder classes.

struct PlannerTempA                 // 8 bytes
{
    union
    {
        int visitCount;             // Before processing the node: How many threads have visited the node so far?
        int subtreeWideNodes;       // After  processing the node: Total number of wide nodes in this subtree, excluding the effect of multiple roots.
    };

    int     squeezeTag;             // Instructions for squeezing any given subtree so that it satisfies minWideNodesAfterSqueeze().
                                    // Generated by PlannerExec, consumed by PlannerSqueeze.
                                    // -1 = This pair of binary nodes should act as the root of a squeezed wide node.
                                    //  N = This subtree is a part of a squeezed wide node, and it consumes the total primitive budget by N.
};

struct PlannerTempB                 // 8 bytes
{
    float   subtreeCostRoots;       // Total SAH cost of this subtree, including the effect of multiple roots.
    int     subtreeWideNodesRoots;  // Total number of wide nodes in this subtree, including the effect of multiple roots.
};

//------------------------------------------------------------------------
// Task specification for the squeeze pass.
// Overlaid on top of PlannerTempB.

struct PlannerSqueezeTask           // 8 bytes
{
    int     subtreeRootPair;        // Subtree of binary nodes yet to be processed.
    int     wideNodeBudget;         // Maximum number of wide nodes that we afford for this subtree.
};

//------------------------------------------------------------------------

#define PLANNER_EXEC_WARPS_PER_BLOCK    2
#define PLANNER_EXEC_BLOCKS_PER_SM      NUMBLOCKS_MAXWELL(32)
#define PLANNER_EXEC_MAX_DEPTH          5   // At most 5, higher is better.
#define PLANNER_EXEC_SIMD_MIN_LANES     1   // Fetch more work when # of lanes doing BVH traversal drops below this.
#define PLANNER_EXEC_SIMD_MAX_LANES     32  // Never use more than this many lanes for BVH traversal. Reduce to avoid L2 trashing.

//------------------------------------------------------------------------

struct PlannerExecParams
{
    int*                    outNumWideNodes;    // [1]
    int*                    outNumRoots;        // [1], may be NULL
    int*                    outSubtreeRoots;    // [maxBinaryNodes], cleared to zero
    PlannerBinaryNode*      ioBinaryNodes;      // [maxBinaryNodes]
    int*                    workCounter;        // [1], cleared to zero
    PlannerTempA*           tempA;              // [maxBinaryNodes / 2], cleared to zero
    PlannerTempB*           tempB;              // [maxBinaryNodes / 2]

    const Range*            inPrimRange;        // [1]
    const ApexPointMap*     inApexPointMap;

    int                     maxBranchingFactor;
    int                     maxLeafSize;
    float                   minAreaPerRoot;
    float                   sahNodeCost;
    float                   sahPrimCost;
    float                   sahRootCost;
    float                   sahTopLevelCost;
};

//------------------------------------------------------------------------

#define PLANNER_SQUEEZE_WARPS_PER_BLOCK 2
#define PLANNER_SQUEEZE_BLOCKS_PER_SM   NUMBLOCKS_MAXWELL(32)
#define PLANNER_SQUEEZE_MAX_BFACTOR     16
#define PLANNER_SQUEEZE_MAX_LEAF_SIZE   16

//------------------------------------------------------------------------

struct PlannerSqueezeParams
{
    int*                    ioNumWideNodes;     // [1]
    int*                    ioNumRoots;         // [1], may be NULL
    PlannerBinaryNode*      ioBinaryNodes;      // [maxBinaryNodes]
    PlannerSqueezeTask*     squeezeTasks;       // [maxBinaryNodes / 2], cleared to -1
    int*                    workCounter;        // [1], cleared to 0
    int*                    taskCounter;        // [1]
    int*                    primCounter;        // [1], cleared to -1

    const Range*            inPrimRange;        // [1]
    const PlannerTempA*     inTempA;            // [maxBinaryNodes / 2]

    int                     maxBranchingFactor;
    int                     maxLeafSize;
    int                     maxWideNodes;
};

//------------------------------------------------------------------------
// Launcher funcs.
//------------------------------------------------------------------------

bool launchPlannerExec      (dim3 gridDim, dim3 blockDim, lwdaStream_t stream, const PlannerExecParams& p);
bool launchPlannerSqueeze   (dim3 gridDim, dim3 blockDim, lwdaStream_t stream, const PlannerSqueezeParams& p);

//------------------------------------------------------------------------
// Function to callwlate the minimum number of wide nodes that we are guaranteed
// to achieve in the squeeze pass. The squeeze pass is based on a simple bottom-up
// algorithm that revolves around the concept of "primitive budget". The algorithm
// itself is exelwted during PlannerExec and the results are stored in
// PlannerTempA::squeezeTag. This allows PlannerSqueeze to then look at the results
// and make informed choices on whether to squeeze each specific subtree, and how.
//
// - Each wide node has a maximum primitive budget of maxBranchingFactor*maxLeafSize,
//   meaning that it is able to represent an entire subtree consisting of at most
//   that many primitives. Each
// - Each leaf node consumes the budget by the number of primitives it contains.
// - Each child of the wide node consumes the budget by maxLeafSize.
// - Traversing the binary nodes in bottom-up order, we track the total budget
//   at each node, and choose to create a wide node whenever we have consumed more
//   than half of its maximum budget.
//
// The point behind this algorithm is that it always produces a valid set of
// wide nodes whose number is guaranteed to stay below the following formula.

static INLINE int minWideNodesAfterSqueeze(int numPrims, int maxBranchingFactor, int maxLeafSize)
{
    return max(numPrims - (maxLeafSize + 1), 0) * 2 / ((maxBranchingFactor - 2) * maxLeafSize + 2) + 1;
}

//------------------------------------------------------------------------
} // namespace bvhtools
} // namespace prodlib
