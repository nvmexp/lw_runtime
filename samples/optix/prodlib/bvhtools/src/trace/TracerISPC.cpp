/*
 *  Copyright (c) 2012, LWPU Corporation
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *      * Redistributions of source code must retain the above copyright
 *        notice, this list of conditions and the following disclaimer.
 *      * Redistributions in binary form must reproduce the above copyright
 *        notice, this list of conditions and the following disclaimer in the
 *        documentation and/or other materials provided with the distribution.
 *      * Neither the name of LWPU Corporation nor the
 *        names of its contributors may be used to endorse or promote products
 *        derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 *  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROLWREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "TracerISPC.hpp"

// These headers are generated by ispc compiler
#include "TracerISPCKernels_ispc.h"
#include "TracerISPCKernels64_ispc.h"

#include <prodlib/exceptions/UnknownError.h>
#include <prodlib/exceptions/Assert.h>

using namespace prodlib::bvhtools;
using namespace prodlib;

//------------------------------------------------------------------------

#define EntrypointSentinel  0x76543210  // Bottom-most stack entry, indicating the end of traversal.

TracerISPC::TracerISPC(void)
{
    m_bvhLayout.storeOnGPU        = false;
    m_bvhLayout.arrayAlign        = 64;
    m_bvhLayout.reorderTriangles  = true;
    m_bvhLayout.optixNodes        = false;


    switch (ispc::getTargetISPC())
    {
    case 0:  m_backendName = "CPU multicore SIMD (SSE2)"; break;
    case 1:  m_backendName = "CPU multicore SIMD (SSE4)"; break;
    case 2:  m_backendName = "CPU multicore SIMD (AVX)"; break;
    case 3:  m_backendName = "CPU multicore SIMD (AVX2)"; break;
    default: m_backendName = "CPU multicore SIMD"; break;
    }
}

//------------------------------------------------------------------------

TracerISPC::~TracerISPC(void)
{
}

//------------------------------------------------------------------------

bool meshNeeds64BitSupport( const TracerDataMesh& tdm )
{
  return 
    ((size_t)tdm.numNodes * sizeof(BvhNode))>0xFFFFFFFF               || 
    ((size_t)tdm.numWoopTriangles * sizeof(WoopTriangle))>0xFFFFFFFF  ||
    ((size_t)tdm.mesh.numTriangles * tdm.mesh.indexStride)>0xFFFFFFFF ||
    ((size_t)tdm.mesh.numVertices * tdm.mesh.vertexStride)>0xFFFFFFFF;
}

bool raysNeed64BitSupport( int rayFormat, int /*hitFormat*/, int numRays )
{
  // Note: assume a ray always takes more bytes than a hit, so can ignore hitFormat
  const size_t raySizeInBytes = (rayFormat == RAY_ORIGIN_DIRECTION) ? 6*sizeof(float) : 8*sizeof(float);
  return (raySizeInBytes * numRays) > 0xFFFFFFFF;
}

//------------------------------------------------------------------------

void TracerISPC::launch1LevelBvh(const TracerDataMesh& tdm, const void* const rays, const int rayFormat, void* const hits, const int hitFormat, const int numRays, const bool anyHit, const bool watertight)
{
  // when the model is empty, set the nodes ptr to 0, so the traverser can skip traversal and intersection
  BvhNode* nodes = tdm.mesh.numTriangles == 0 ? 0 : tdm.nodes;

  const bool call64BitKernel = meshNeeds64BitSupport(tdm) || raysNeed64BitSupport(rayFormat, hitFormat, numRays);

  if( tdm.woopTriangles ) {
    (call64BitKernel ? ispc::traceISPCWoopTriangles64 : ispc::traceISPCWoopTriangles32)(
        (const ispc::float4*)rays,
        (ispc::float4*)hits,
        (const ispc::float4*)nodes,
        (const ispc::float4*)tdm.woopTriangles,
        tdm.remap,
        numRays,
        anyHit,
        rayFormat,
        hitFormat);
  } else if( tdm.mesh.indices ) {
    bool useMasking  = (rayFormat == RAY_ORIGIN_MASK_DIRECTION_TMAX);
    (call64BitKernel ? ispc::traceISPCIndexedTriangleList64 : ispc::traceISPCIndexedTriangleList32)(
        (const ispc::float4*)rays,
        (ispc::float4*)hits,
        (const ispc::float4*)nodes,
        tdm.mesh.indices,
        tdm.mesh.vertices,
        tdm.mesh.indexStride,
        tdm.mesh.vertexStride,
        tdm.remap,
        numRays,
        anyHit,
        watertight,
        rayFormat,
        hitFormat,
        useMasking);
  } else {
    (call64BitKernel ? ispc::traceISPCTriangleList64 : ispc::traceISPCTriangleList32)(
        (const ispc::float4*)rays,
        (ispc::float4*)hits,
        (const ispc::float4*)nodes,
        tdm.mesh.vertices,
        tdm.mesh.vertexStride,
        tdm.remap,
        numRays,
        anyHit,
        watertight,
        rayFormat,
        hitFormat);
  }
  
}

//------------------------------------------------------------------------

static void copyMesh( TracerParamsMesh* to, const TracerDataMesh& src )
{
  to->nodes        = (float4*)src.nodes;
  to->triangles    = (float4*)src.woopTriangles;
  to->indices      = src.mesh.indices;
  to->vertices     = src.mesh.vertices;
  to->remap        = src.remap;
  to->indexStride  = src.mesh.indexStride;
  to->vertexStride = src.mesh.vertexStride;
  to->rootNode     = (src.nodes) ? 0 : EntrypointSentinel;
  to->numEntities  = src.mesh.numTriangles;
}

//------------------------------------------------------------------------

void TracerISPC::launch2LevelBvh(const TracerDataGroup& tdg, const void* const rays, const int rayFormat, void* const hits, const int hitFormat, const int numRays, const bool anyHit, const bool watertight)
{

  tracerIspcParams params;

  // fill m_group
  m_group.nodes        = (const float4*)tdg.nodes;
  m_group.remap        = tdg.remap;
  m_group.ilwMatrices  = tdg.group.ilwMatrices;
  m_group.modelId      = tdg.group.modelIds;
  m_group.rootNode     = (tdg.nodes) ? 0 : EntrypointSentinel;
  m_group.numEntities  = tdg.group.numInstances;
  m_group.matrixStride = tdg.group.matrixStride / 4;

  // fill m_meshes
  if( tdg.meshes.size()!=m_meshes.size() )
    m_meshes.resize( tdg.meshes.size() );
  int isecMode = INTERSECT_WOOP;
  bool call64bitkernel = raysNeed64BitSupport(rayFormat, hitFormat, numRays);
  for( size_t i = 0; i < tdg.meshes.size(); i++ )
  {
    const TracerDataMesh& mesh = dynamic_cast<const TracerDataMesh&>(tdg.meshes[i]);

    call64bitkernel |= meshNeeds64BitSupport( mesh );

    if(i==0)
    {
      if( mesh.woopTriangles ) {
        isecMode = INTERSECT_WOOP;
      } else if( mesh.mesh.indices ) {
        isecMode = INTERSECT_INDEXED_LIST;
      } else {
        isecMode = INTERSECT_VERTEX_LIST;
      }
    }

    copyMesh( &m_meshes[i], mesh );
  }

  // fill rest
  params.rays       = rays;
  params.hits       = hits;
  params.numRays    = numRays;
  params.rayFormat  = rayFormat;
  params.hitFormat  = hitFormat;
  params.anyhit     = anyHit;
  params.watertight = watertight;
  params.group      = &m_group;
  params.meshes     = m_meshes.data();
  params.isecMode   = isecMode;
  params.useMasking = (rayFormat == RAY_ORIGIN_MASK_DIRECTION_TMAX);

  if( !call64bitkernel ) {
    ispc::traceISPC2LevelBvh32((const ispc::tracerIspcParams*)&params);
  } else {
    ispc::traceISPC2LevelBvh64((const ispc::tracerIspcParams*)&params);
  }
}

//------------------------------------------------------------------------

void TracerISPC::traceFromHostMem(const TracerData& td, const void* const rays, const int rayFormat, void* const hits, const int hitFormat, const int numRays, const bool anyHit, const bool watertight, const void* const unused)
{
  if( td.inDeviceMem )
    throw UnknownError( RT_EXCEPTION_INFO, "Can't trace GPU bvh on host" );

  if( const TracerDataMesh* tdm = dynamic_cast<const TracerDataMesh*>(&td) ) {
    launch1LevelBvh( *tdm, rays, rayFormat, hits, hitFormat, numRays, anyHit, watertight );
  } else {
    const TracerDataGroup& tdg = dynamic_cast<const TracerDataGroup&>(td);
    launch2LevelBvh( tdg, rays, rayFormat, hits, hitFormat, numRays, anyHit, watertight );
  }
}

//------------------------------------------------------------------------
