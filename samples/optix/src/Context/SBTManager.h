#pragma once

#include <Context/UpdateManager.h>
#include <ExelwtionStrategy/RTX/CompiledProgramCache.h>
#include <Memory/Allocator.h>
#include <Memory/DeviceSpecificTableBase.h>
#include <Memory/MBuffer.h>
#include <Objects/Group.h>

#include <map>
#include <vector>

namespace cort {
union SBTRecordData;
};

namespace optix {
class Context;
class LWDADevice;
class Geometry;
class GeometryGroup;
class LexicalScope;
class Material;
class Program;
class RTXFrameTask;
class RTXPlan;

// This Manager is WIP.
// The SBT Manager is responsible for the following tasks:
// * Allocate SBT.
// * Write to the device the SBT content before launch: both the Record Header and the Record Data.
// * Keep track of when it needs to update the SBT
//
// See spec-sbt.txt for more info.
//
// The SBT Manager has to match the SBT Record Header and the SBT Record Data sections.
//
// SBT Record Header: contains information generated by rtcore during compile. Optix
//                    queries this info via rtcPackSbtRecordHeader.
//
// SBT Record Data: contains the ObjectRecord offset of the LexicalScope associated with
//                  the current record.
//
// The two parts are filled in at the same time based on the state of the graph and which
// parts need to be updated.  We also keep track of all the GeometryGroups that need to be
// fill in their GeometryInstances.

class SBTManager
{
  public:
    SBTManager( Context* context );
    virtual ~SBTManager();

    // make sure that GeometryGroups with delayed update are current. Synchronizes to devices.
    void finalizeBeforeLaunch();

  private:
    // Write the data section of the specified SBT record.
    //
    // Refer to spec-sbt.txt for a complete description.
    //
    // Example: 2 GIs, GIA has 3 materials, GIB has 2 materials.
    //          Two ray types.
    // The value after the 's' is the Skip.
    //
    // This is how the current algorithm lays the SBT records.
    //
    // | First MATs for all GIs| Other MATs for GIA    | Other MATs for GIB
    // +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
    // | GIA | GIA | GIB | GIB | GIA | GIA | GIA | GIA | GIB | GIB |
    // | M0  | M0  | M0  | M0  | M1  | M1  | M2  | M2  | M1  | M1  |
    // | R0  | R1  | R0  | R1  | R0  | R1  | R0  | R1  | R0  | R1  |
    // | s2  | s2  | s3  | s3  | s0  | s0  | s0  | s0  | s0  | s0  |
    // +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
    //int fillSBTMaterials( unsigned int         numRayTypes,
    //                      const GeometryGroup* gg,
    //                      int                  ggStartIndex,
    //                      int ( *getSkip )( const GeometryGroup*, int, int ),
    //                      const Device* device,
    //                      int           firstMaterialIndex,
    //                      int           lastMaterialIndex,
    //                      int           hitIndex );
    void fillSBTMaterials( unsigned int numRayTypes, const GeometryGroup* gg, int ggStartIndex, const Device* device );

    // Force a synchronization of the SBTs to the devices.
    void syncSBTForLaunch();

    // When the active devices change, this is used to reallocate the SBT on new devices
    // and to fill the data section on those.
    void rebuildSBT();

    void rebuildEntryPointData( Device* device );

    // The recordsToBuild parameter is necessary because while in the process
    // of increasing the number of ray types, we have noone to ask how many
    // miss programs there actually are (the Context will give us the new value
    // while the GlobalScope doesn't have it allocated, yet). So, when growing
    // we only fill as many miss programs as we had before.
    void rebuildMissProgramData( Device* device, unsigned int recordsToBuild );
    void rebuildCPData( Device* device );

  public:
    void launchCompleted();

    // Allocate space in the SBT for the given GeometryGroup.  Returns a handle to an index
    // to the first SBTRecord.  If no records are produces (e.g. size of 0) then the handle
    // returned will be invalid.
    typedef std::shared_ptr<size_t> Handle;
    Handle allocateInstances( GeometryGroup* gg, unsigned int numRayTypes );
    void freeInstanceCallback( size_t index, size_t size );

    size_t getSBTRecordSize();

    // Getters for device addresses.
    void* getRaygenSBTRecordDevicePtr( const Device* device, unsigned int entryPoint );
    void* getExceptionSBTRecordDevicePtr( const Device* device, unsigned int entryPoint );
    void* getMissSBTRecordDevicePtr( const Device* device );
    void* getInstancesSBTRecordDevicePtr( const Device* device );
    void* getCallableProgramSBTRecordDevicePtr( const Device* device );

    ////////////////////////////////////////////////////////////
    // Events SBTManager cares about (not associated with the UpdateManager)
    ////////////////////////////////////////////////////////////

    void preSetActiveDevices( const DeviceArray& removedDevices );
    void postSetActiveDevices();

    /////////
    // Count changes not associated with GeometryGroup objects
    void rayTypeCountDidChange();
    void entryPointCountDidChange();

    /////////
    // Program changes

    // From GlobalScope
    void rayGenerationProgramDidChange( const Program* program, unsigned int index );
    void exceptionProgramDidChange( const Program* program, unsigned int index );
    void missProgramDidChange( const Program* program, unsigned int index );
    Handle callableProgramDidChange( const Program* program );
    void updateBoundCallableProgramEntry( const Program* program, SemanticType inheritedSemanticType );

    // From Group
    void intersectionProgramDidChange( const GeometryGroup* gg, unsigned int instanceIndex );
    void closestHitProgramDidChange( const GeometryGroup* gg, unsigned int instanceIndex, unsigned int materialIndex, unsigned int rayTypeIndex );
    void anyHitProgramDidChange( const GeometryGroup* gg, unsigned int instanceIndex, unsigned int materialIndex, unsigned int rayTypeIndex );

    ////////
    // Node Changes
    void geometryInstanceDidChange( const GeometryGroup* gg, unsigned int instanceIndex );
    void geometryDidChange( const GeometryGroup* gg, unsigned int instanceIndex );
    void materialDidChange( const GeometryGroup* gg, unsigned int instanceIndex, unsigned int materialIndex );

    ///////
    // Offset Changes
    void rayGenerationProgramOffsetDidChange( const Program* program, unsigned int index );
    void exceptionProgramOffsetDidChange( const Program* program, unsigned int index );
    void missProgramOffsetDidChange( const Program* program, unsigned int index );
    void geometryInstanceOffsetDidChange( const AbstractGroup* gg, unsigned int instanceIndex );
    void materialOffsetDidChange( const GeometryGroup* gg, unsigned int instanceIndex, unsigned int materialIndex );
    void callableProgramOffsetDidChange( const Program* prog );

  private:
    void unmapSBTFromHost();

    char* getSBTBaseDevicePtr( const Device* device );
    char* getSBTRecordDevicePtr( const Device* device, int recordIndex );

    // Get the pointer to the device independent section of the given SBT record
    cort::SBTRecordData* getSBTDiDataHostPointer( int recordIndex );
    const cort::SBTRecordData* getSBTDiDataHostPointerReadOnly( int recordIndex );

    // Get the pointer to the device dependent section of the given SBT record on a specific device
    char* getSBTDdDataHostPointer( int recordIndex, int deviceIndex );
    const char* getSBTDdDataHostPointerReadOnly( int recordIndex, int deviceIndex );

  private:
    void registerGeometryGroup( const GeometryGroup* gg );
    void unregisterGeometryGroup( const GeometryGroup* gg );

    void registerGeometryGroupForUpdate( const GeometryGroup* gg );

  public:
    // Note this was PerPlanCompiledProgramCacheKey found in RTXFrameTask
    struct CompiledProgramKey
    {
        CanonicalProgramID cpID;
        SemanticType       stype;
        SemanticType       inheritedStype;
        unsigned int       allDeviceListIndex;
        bool operator<( const CompiledProgramKey& other ) const;
    };
    using CompiledProgramMap = std::map<CompiledProgramKey, ModuleEntryRefPair>;

    // Updates the programs known to the SBTManager and fills in the SBT record headers
    // if the program is used by any of them.
    void updatePrograms( const CompiledProgramMap& lwrrentPlansCompiledPrograms );

    // Removes all programs compiled for the specified devices.
    void removeProgramsForDevices( const DeviceArray& devices );

  private:
    // Holds all compiled programs lwrrently known to the SBT.
    CompiledProgramMap m_lwrrentPrograms;

    // Structure to keep track of which SBT records reference which programs.
    // Each program (defined by CPID and SemanticType) maps to a list of SBTIndex
    // which allows fast traversal of affected records if a program changes.
    struct SBTIndex
    {
        mutable int index       = -1;
        size_t      recordIndex = 0;
        struct Get
        {
            int& operator()( const SBTIndex* i ) { return i->index; }
        };

        ~SBTIndex() { reset(); }

        void reset();

        // This is used to efficiently remove an entry from the Program/Index mapping
        IndexedVector<SBTIndex*, SBTIndex::Get>* m_lwrrentParent = nullptr;
    };
    using SBTIndices = IndexedVector<SBTIndex*, SBTIndex::Get>;

    // Maps programs to indices that reference the program
    struct ProgramEntriesKey
    {
        CanonicalProgramID cpID;
        SemanticType       stype;
        SemanticType       inheritedStype;
        bool operator<( const ProgramEntriesKey& other ) const;
    };
    std::map<ProgramEntriesKey, SBTIndices> m_programEntries;

    // In order to allow removing indices from the mapping above (if an allocation changes)
    // and to optimize filling of Instance records an additional structure is kept
    // that allows direct access to the indices stored in m_programEntries by their
    // record index.

    struct SBTEntry
    {
        // This is used to keep the CPIDs of AH, CH, IS together,
        // so those three can be updated in one go in updatePrograms.
        // It is unused for RG, EX, MS, CP.
        struct CPIds
        {
            CanonicalProgramID ahCPID, chCPID, isCPID;
        };
        // The CPIds needed for this entry for each device
        std::vector<CPIds> cpIds;
        SBTIndex           AHorP;
        SBTIndex           CHorBCP;
        SBTIndex           IS;
    };

    // maps recordIndex to SBTEntry for fast removal
    std::vector<std::unique_ptr<SBTEntry>> m_SBTEntries;

    // Updates mapping of CP to record index (and reverse) and fills the SBT header for the given device.
    // The inheritedSemantic type is only needed for bound callable programs. If it is not set
    // the value of stype is used for its value.
    void updateProgramEntries( size_t recordIndex, const Program* program, const Device* device, SemanticType stype, SemanticType inheritedStype = ST_ILWALID );

    void fillProgramSBTRecordHeader( char* hostPtr, CanonicalProgramID cpID, SemanticType stype, SemanticType inheritedStype, const LWDADevice* device );

    void fillProgramSBTRecordHeader( char*              hostPtr,
                                     CanonicalProgramID isCPID,
                                     CanonicalProgramID ahCPID,
                                     CanonicalProgramID chCPID,
                                     const LWDADevice*  device );

    /* Regions in the SBT are allocated with padding to avoid unnecessary reallocations,
   * so load holds how many records are actually in use
   */
    struct SBTRange
    {
        Allocator::Handle index;
        size_t            capacity;
        size_t            size;
        void              reset();
    };

    /* Determines whether the given range is large enough to hold the requested number of records and re-allocates
   * (with padding) if necessary. Returns true, if the allocation has moved.
   */
    bool growSBTRegion( SBTRange& range, size_t count );

    /* Allocates the SBT on the devices */
    bool growDeviceSpecificSBT();

    /* Updates the data section of the record at recordIndex for RGs, EXs, MSs, and CPs */
    void updateSBTProgramOffset( size_t recordIndex, const Program* program, SemanticType stype, SemanticType inheritedStype = ST_ILWALID );

    bool geometryGroupHasDelayedUpdate( const GeometryGroup* gg );

    // Helper enum used when printing the SBT
    enum SBTRecordType
    {
        Raygen = 0,
        Exception,
        Miss,
        Instance,
        Callable
    };

    // Only used for printing the SBT
    struct SBTRecordRegion
    {
        SBTRange      range;
        SBTRecordType type;
    };

    void dumpSBT( std::ostream& out );

    // Returns the Ranges of SBT records based on their starting index.
    std::vector<SBTRecordRegion> getSortedRegions();

    // Printing helpers
    void printDeviceValues( std::ostream& out, size_t recordIndex, size_t headerEntry, const std::vector<unsigned>& devs );

    size_t printRecordHeader( std::ostream&                out,
                              size_t                       recordBase,
                              size_t                       lwrrentOffset,
                              size_t                       recordIndex,
                              SBTRecordType                type,
                              const std::vector<unsigned>& deviceIndices );

    size_t printRecordData( std::ostream& out, size_t recordBase, size_t lwrrentOffset, size_t recordIndex, SBTRecordType type );

    std::unique_ptr<DeviceSpecificTableBase> m_sbt;

    // The OptiX context.
    Context* m_context = nullptr;

    // The record header size as defined by RTCore.
    size_t m_sbtRecordHeaderSize = 0;
    size_t m_sbtRecordDataSize   = 0;

    // This flag is true if the SBT needs to be rebuilt at the next call to
    // updateSBT(), false otherwise.
    bool m_needsSync = false;

    // The allocator keeps track of which parts of the SBT are in use and which
    // ones are free to be reused.
    Allocator m_allocator;

    // The range indices and sizes for each of the disjoint SBT regions.
    // The raygen/exception/miss allocation don't necessarily need to be
    // initialized since there is always at least one entry point when
    // updateSBT() is called, so there is always something allocated.
    SBTRange m_rayGenAllocation    = {nullptr, 0, 0};
    SBTRange m_exceptionAllocation = {nullptr, 0, 0};
    SBTRange m_missAllocation      = {nullptr, 0, 0};

    // Structure to keep track of registered GeometryGroups and how often they were re-allocated
    // to allow delayed allocations for frequently changing groups.
    struct GeometryGroupRegistration
    {
        const GeometryGroup* gg                = nullptr;
        mutable int          reallocationCount = 0;
        GeometryGroupRegistration( const GeometryGroup* g )
            : gg( g )
        {
        }

        struct IndexFunction
        {
            int& operator()( const GeometryGroupRegistration& g )
            {
                return AbstractGroup::SBTManagerIndex_fn()( g.gg );
            }
        };
    };

    typedef IndexedVector<GeometryGroupRegistration, GeometryGroupRegistration::IndexFunction> GGListType;

    GGListType m_GGregistrations;

    typedef IndexedVector<const GeometryGroup*, AbstractGroup::SBTManagerUpdateIndex_fn> GGUpdateListType;

    GGUpdateListType m_GGupdateList;

    // A cache of the printed SBT to avoid unnecessary printing when nothing has changed.
    std::string m_printedLayoutCache;

    static constexpr int m_ggReallocationLimit = 2;
};

}  // namespace optix
