// Copyright (c) 2019, LWPU CORPORATION.
// TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, THIS SOFTWARE IS PROVIDED
// *AS IS* AND LWPU AND ITS SUPPLIERS DISCLAIM ALL WARRANTIES, EITHER EXPRESS
// OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL LWPU OR ITS SUPPLIERS
// BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES
// WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
// BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PELWNIARY LOSS)
// ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE, EVEN IF LWPU HAS
// BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES

#include <FrontEnd/PTX/CorrectVprintfTypePass.h>

#include <prodlib/exceptions/Assert.h>

#include <llvm/IR/Constants.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/GlobalValue.h>
#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/Module.h>
#include <llvm/Pass.h>

using namespace llvm;

namespace {
class CorrectVprintfTypePass : public ModulePass
{
  public:
    static char ID;

    CorrectVprintfTypePass()
        : ModulePass( ID )
    {
    }

    void getAnalysisUsage( AnalysisUsage& AU ) const override { AU.setPreservesAll(); }

    bool runOnModule( Module& module ) override
    {
        Function* oldVprintf = module.getFunction( "vprintf" );
        if( oldVprintf == nullptr )
            return false;

        Type*        i32Ty   = IntegerType::get( module.getContext(), 32 );
        Type*        i64Ty   = IntegerType::get( module.getContext(), 64 );
        Type*        i8Ty    = IntegerType::get( module.getContext(), 8 );
        PointerType* i8PtrTy = PointerType::get( i8Ty, 0 );

        Type* existingType = oldVprintf->getFunctionType();

        // We expect the vprintfs generated by the PTX parser to be of type i32 (i64, i64)
        std::vector<Type*> expectedArgs = {i64Ty, i64Ty};
        Type*              expectedType = FunctionType::get( i32Ty, expectedArgs, false );

        std::vector<Type*> desiredArgs = {i8PtrTy, i8PtrTy};
        FunctionType*      desiredType = FunctionType::get( i32Ty, desiredArgs, false );

        // If vprintf's type is already correct, don't bother changing it.
        if( existingType == desiredType )
            return false;

        // Otherwise, make sure it has the type we think it does.
        RT_ASSERT( expectedType == existingType );

        // Create a new function declaration with the signature i32 (i8*, i8*).
        Function* newVprintf = Function::Create( desiredType, GlobalValue::ExternalLinkage, "newvprintf", &module );

        std::vector<CallInst*> callsToRemove;

        // Replace every call to vprintf with a call to the function with the proper signature.
        for( auto lwrrUse = oldVprintf->user_begin(), end = oldVprintf->user_end(); lwrrUse != end; ++lwrrUse )
        {
            CallInst* oldVprintfCall = dyn_cast<CallInst>( *lwrrUse );
            RT_ASSERT_MSG( oldVprintfCall != nullptr, "indirect call to vprintf" );

            callsToRemove.push_back( oldVprintfCall );

            IRBuilder<> irb( oldVprintfCall );

            Value* firstArg    = oldVprintfCall->getArgOperand( 0 );
            Value* newFirstArg = irb.CreateIntToPtr( firstArg, i8PtrTy );

            Value* secondArg    = oldVprintfCall->getArgOperand( 1 );
            Value* newSecondArg = irb.CreateIntToPtr( secondArg, i8PtrTy );

            std::vector<Value*> newCallArgs    = {newFirstArg, newSecondArg};
            CallInst*           newVprintfCall = irb.CreateCall( newVprintf, newCallArgs );

            oldVprintfCall->replaceAllUsesWith( newVprintfCall );
            newVprintfCall->takeName( oldVprintfCall );
        }

        for( CallInst* oldVprintfCall : callsToRemove )
            oldVprintfCall->eraseFromParent();

        oldVprintf->eraseFromParent();
        newVprintf->setName( "vprintf" );

        return true;
    };
};

char CorrectVprintfTypePass::ID = 0;
}

namespace optix {

ModulePass* createCorrectVprintfTypePass()
{
    return new CorrectVprintfTypePass();
}
}
