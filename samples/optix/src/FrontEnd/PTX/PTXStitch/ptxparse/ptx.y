/*
 * LWIDIA_COPYRIGHT_BEGIN
 *
 * Copyright (c) 2006-2021, LWPU CORPORATION.  All rights reserved.
 *
 * LWPU CORPORATION and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from LWPU CORPORATION is strictly prohibited.
 *
 * LWIDIA_COPYRIGHT_END
 */

/*
 *  Module name              : ptx.y
 *
 *  Description              :
 *
 */

%{

/*--------------------------------- Includes ---------------------------------*/

#include "ctLog.h"
#include <g_lwconfig.h>
#include "ptx.h"
#include "ptxInstructions.h"   //This file has enums defined for available PTX instructions. 
#include "ptxparseMessageDefs.h"
#include "gpuInfo.h"
#include "API.h"
#include "ptxMacroUtils.h"
#include <stdlib.h>
#include <stdRangeMap.h>
#include "DebugInfo.h"
#include "stdBitSet.h"
#include "zlib.h"   // For checksum callwlation
#include "ptxPragmaUtils.h"

// FIXME : Hack for optix, in JIT path
// - allow ld.global.nc with PTX ISA 3.0
// - .target sm_35 with PTX ISA 3.0 
// - indirect texture access with PTX ISA 3.0
#ifdef GPGPUCOMP_DRV_BUILD
#define ENABLE_OPTIX_HACK 1
#endif

/*------------------------------- Exported Functions  -------------------------*/

// NOTE: the following function is defined here as the error ptxMsgVersionUnsupported is defined in ptxparse/...
/*
 * Function         : Checks whether the unsupported PTX version error is hit.
 * Function Result  : return True, if an unsupported PTX version is seen.
 */
Bool isUnsupportedPTXVersionSet()
{
    return stdGetThreadContext()->raisedException == ptxMsgVersionUnsupported;
}


/*------------------------------- Parser State -------------------------------*/

#define WARP_SIZE        32  // lwrrently 32 for all SM versions


#ifdef GPGPUCOMP_DRV_BUILD
#define emitNoSyncWarningOnce True
#else
#define emitNoSyncWarningOnce False
#endif



static void initPtxToSourceMapRecord(ptxParsingState gblState, ptxCodeLocation lwrSourceCodeLocation);
static void insertPtxToSourceMapRecord(ptxParsingState gblState);
static void setSourceLocForPrologue(ptxParsingState gblState, msgSourcePos_t startPos, msgSourcePos_t endPos,
                                         ptxCodeLocation prologueLoc);

String getPtxVersionString(ptxParseData parseData)
{
    return parseData->version;
}

String getTargetArchString(ptxParseData parseData)
{
    return parseData->target_arch;
}

/*---------------------- Supported SM targets and corresponding PTX ISA ---------------------*/

typedef struct {
    int smVersion;
    int minPtxMajorVersion;
    int minPtxMinorVersion;
} smIsaMapping;

static int compareSmVersions( const void *first, const void *second )
{
    smIsaMapping *f = (smIsaMapping *)first;
    smIsaMapping *s = (smIsaMapping *)second;
    return (f->smVersion - s->smVersion);
}

/*
* check compatibility with PTX ISA .version:
* . sm_90 requires ISA version 7.0 or later (FIXME : will be exposed in subsequent release)
* . sm_89 requires ISA version 7.3 or later (FIXME : will be exposed in subsequent release) 
* . sm_88 requires ISA version 7.3 or later (FIXME : will be exposed in subsequent release) 
* . sm_87 requires ISA version 7.4 or later
* . sm_86 requires ISA version 7.1 or later
* . sm_80 requires ISA version 7.0 or later
* . sm_75 requires ISA version 6.3 or later
* . sm_73 requires ISA version 6.3 or later
* . sm_72 requires ISA version 6.1 or later
* . sm_70 requires ISA version 5.1 or later
* . sm_62 requires ISA version 5.0 or later
* . sm_61 requires ISA version 5.0 or later
* . sm_60 requires ISA version 5.0 or later
* . sm_53 requires ISA version 4.2 or later
* . sm_52 requires ISA version 4.1 or later
* . sm_50 requires ISA version 4.0 or later
* . sm_37 requires ISA version 4.1 or later
* . sm_35 requires ISA version 3.1 or later
* . sm_32 requires ISA version 4.0 or later
* . sm_30 requires ISA version 3.0 or later
* . sm_20 requires ISA version 2.0 or later
* . sm_{12,13} require ISA version 1.2 or later
* . sm_{10,11} supported by all ISA versions
*/

smIsaMapping const SmIsaMap[] = {
// should be sorted in ascending order for binary search
                    { 10, 1, 0},
                    { 11, 1, 0},
                    { 12, 1, 2},
                    { 13, 1, 2},
                    { 20, 2, 0},
                    { 21, 2, 0},
                    { 30, 3, 0},
                    { 32, 4, 0},
#ifdef ENABLE_OPTIX_HACK
                    { 35, 3, 0},
#else
                    { 35, 3, 1},
#endif
                    { 37, 4, 1},
                    { 50, 4, 0},
                    { 52, 4, 1},
                    { 53, 4, 2},
                    { 60, 5, 0},
                    { 61, 5, 0},
                    { 62, 5, 0},
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
                    { 70, 6, 0},
#if (LWCFG(GLOBAL_CHIP_T194) || LWCFG(GLOBAL_GPU_IMPL_GV11B))
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
                    { 72, 6, 0}, // FIXME: In internal builds support sm_72 with 6.0
#else
                    { 72, 6, 1},
#endif
#endif
#endif
#if LWCFG(GLOBAL_ARCH_TURING)
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
#if LWCFG(GLOBAL_GPU_IMPL_SM73)
                    { 73, 6, 0}, // FIXME: In internal builds support sm_73 with 6.0
#endif // GLOBAL_GPU_IMPL_SM73
                    { 75, 6, 0}, // FIXME: In internal builds support sm_75 with 6.0
#else
#if LWCFG(GLOBAL_GPU_IMPL_SM73)
                    { 73, 6, 3},
#endif // GLOBAL_GPU_IMPL_SM73
                    { 75, 6, 3},
#endif // GLOBAL_FEATURE_PTX_ISA_INTERNAL
#endif // GLOBAL_ARCH_TURING
#if LWCFG(GLOBAL_ARCH_AMPERE)
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
                    { 80, 6, 2},
#else
                    { 80, 7, 0},
#endif // GLOBAL_FEATURE_PTX_ISA_INTERNAL
                    { 82, 6, 2}, // FIXME: expose in later release
#if LWCFG(GLOBAL_GPU_FAMILY_GA10X)
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
                    { 86, 6, 4}, // In internal builds support sm_86 with 6.4
#else
                    { 86, 7, 1},
#endif // GLOBAL_FEATURE_PTX_ISA_INTERNAL
#if LWCFG(GLOBAL_GPU_IMPL_GA10B) || LWCFG(GLOBAL_FAMILY_T23X)
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
                    { 87, 6, 4}, // In internal builds support sm_86 with 6.4
#else
                    { 87, 7, 4},
#endif
#endif // GLOBAL_GPU_IMPL_GA10B || GLOBAL_FAMILY_T23X
#if LWCFG(GLOBAL_GPU_IMPL_GA10F) || LWCFG(GLOBAL_CHIP_T239)
                    { 88, 7, 3}, // FIXME: expose in later release
#endif // GLOBAL_GPU_IMPL_GA10F || GLOBAL_CHIP_T239
#endif // GLOBAL_GPU_FAMILY_GA10X
#endif // GLOBAL_ARCH_AMPERE
#if LWCFG(GLOBAL_ARCH_ADA)
#if LWCFG(GLOBAL_GPU_FAMILY_AD10X)
                    { 89, 7, 3}, // FIXME: expose in later release
#endif // GLOBAL_GPU_FAMILY_AD10X
#endif // GLOBAL_ARCH_ADA
#if LWCFG(GLOBAL_ARCH_HOPPER)
                    { 90, 7, 0},
#endif // GLOBAL_ARCH_HOPPER
                };

#if LWCFG(GLOBAL_ARCH_TURING)
#if LWCFG(GLOBAL_GPU_IMPL_SM73)
    const uInt  minTuringArch = 73;
    const String minTuringArchStr = "sm_73";
#else
    const uInt minTuringArch = 75;
    const String minTuringArchStr = "sm_75";
#endif // GLOBAL_GPU_IMPL_SM73
#else
    const uInt minTuringArch = 0;
    const String minTuringArchStr = "";
#endif // GLOBAL_ARCH_TURING



/*---------------------- Miscellaneous Utility Functions ---------------------*/

String typeToString( ptxParseData parseData, ptxType t )
{
    return getTYPEAsString(parseData->deobfuscatedStringMapPtr, t);
}

String sType( ptxParseData parseData, ptxInstruction instr, uInt idx )
{
  if (idx >= instr->tmplate->nrofInstrTypes) return "";

  return typeToString(parseData, instr->type[idx]);
}

static Bool ptxVersionIs(ptxParsingState gblState, int major, int minor )
{
    if (gblState->version) {
        int m, n;

        // OPTIX_HAND_EDIT use preparsed version values
#if 0
        sscanf(gblState->version, "%d.%d", &m, &n);
#else
        m = gblState->version_major;
        n = gblState->version_minor;
#endif
        return (m == major && n == minor);
    } else
        return False;
}

static Bool checkFeatureVersion1(ptxParsingState gblState, uInt major, uInt minor)
{

    // Disable check if we are processing a macro. Macro bodies are
    // free to use any PTX instruction that has an implementation on
    // the target architecture.
    if (ptxIsExpandedInternally(gblState->lwrInstrSrc)) return True;
    if (gblState->allowAllPtxFeatures) return True;

    return ptxVersionAtLeast(major, minor, gblState);
}

static void checkFeatureVersion(ptxParsingState gblState, uInt major, uInt minor, cString  msg,
                                msgSourcePos_t sourcePos)
{
    // OPTIX_HAND_EDIT use stdCHECK_WITH_POS_LAZY
    stdCHECK_WITH_POS_LAZY(checkFeatureVersion1(gblState, major, minor),
    char version[100];
    sprintf(version, "%d.%d", major, minor);
                           ,
                      (ptxMsgFeatureRequiresPTXVersion, sourcePos, msg, version));
}

static Bool checkTargetArch(ptxParsingState gblState,  uInt32 minTarget );
static void checkFeatureTarget(ptxParsingState gblState,  uInt target, cString msg, msgSourcePos_t sourcePos)
{
    // OPTIX_HAND_EDIT use stdCHECK_WITH_POS_LAZY
    stdCHECK_WITH_POS_LAZY(checkTargetArch(gblState, target),
    char targetStr[8];
    sprintf(targetStr, "sm_%d", target);
                           ,
                      (ptxMsgFeatureRequiresSMVersion, sourcePos,
                       msg, targetStr));
}

static void setAddressSize(ptxParsingState gblState,  int size, msgSourcePos_t sourcePos )
{
    checkFeatureVersion(gblState, 2, 3, ".address_size directive", sourcePos);
    stdCHECK_WITH_POS( (size==32 || size==64), (ptxMsgIllegalAddressSize,sourcePos,size));
    gblState->addr_size = size;
}


static void setVersion(ptxParsingState gblState,  String version, msgSourcePos_t sourcePos )
{
    Int major, minor;
    Int latestMajorVersion, latestMinorVersion;
    String latestVersionString;

    latestMajorVersion = ptxGetLatestMajorVersion();
    latestMinorVersion = ptxGetLatestMinorVersion();

    sscanf(version, "%d.%d", &major, &minor);

    // OPTIX_HAND_EDIT: Need to accept later ptx versions - using new instructions will produce a parsing error.
    if( major * 10 + minor > 75 )
    {
        major   = 7;
        minor   = 5;
        version = "7.5";
    }

    latestVersionString = stdMALLOC(2 + 1 + 1 + 1);
    stdASSERT(latestMajorVersion < 100 && latestMinorVersion < 10, ("too big version, need to extend allocated space"));
    sprintf(latestVersionString, "%d.%d", latestMajorVersion, latestMinorVersion);

    stdCHECK_WITH_POS(ptxIsSupportedIsaVersion(major * 10 + minor),
                      (ptxMsgVersionUnsupported, sourcePos,version,latestVersionString));
    stdFREE(latestVersionString);

    gblState->parseData->version = gblState->version = version;
    // OPTIX_HAND_EDIT add preparsed values
    gblState->version_major = major;
    gblState->version_minor = minor;
}

static Bool checkCompilationArch(ptxParsingState gblState, uInt32 minArch)
{
    uInt32 arch;
    sscanf(gblState->gpuInfo->internalName, "%*[^0-9]%d", &arch);
    return (arch >= minArch);
}

static Bool checkTargetArch(ptxParsingState gblState,  uInt32 minTarget )
{
    // OPTIX_HAND_EDIT
    //uInt32 target;

    // Disable check if we are processing a macro. Macro bodies are
    // free to use any PTX instruction that has an implementation on
    // the target architecture.
    if (ptxIsExpandedInternally(gblState->lwrInstrSrc)) return True;
    if (gblState->target_arch == NULL) return False;

    // OPTIX_HAND_EDIT use target_arch_int
    return (gblState->target_arch_int >= minTarget);
}

Bool checkTargetOpts(ptxParsingState gblState,  String opt )
{
  return (mapApply(gblState->target_opts, opt)!=NULL);
}

static void setTarget(String target, msgSourcePos_t *srcPos, ptxParsingState gblState )
{
    msgSourcePos_t sourcePos = *srcPos;

    if (strstr(target, "sm_") || strstr(target, "compute_")) {
        uInt   n;
        smIsaMapping *smIsaMapPtr;
        String version = (gblState->version != NULL) ? gblState->version : "";
        gblState->parseData->target_arch = gblState->target_arch = target;

        sscanf(gblState->target_arch, "%*[^0-9]%d", &n);
        // OPTIX_HAND_EDIT set target_arch_int
        gblState->target_arch_int = n;
        if (n > gblState->max_target) {
            gblState->max_target = n;
        }
        // TODO
        // OPTIX_HAND_EDIT: Need to accept later targets for now, though if new instructions used
        // the parser will produce an error.
        if( n > 86 )
        {
            n = 86;
        }

        smIsaMapPtr = bsearch(&n, SmIsaMap, sizeof(SmIsaMap) / sizeof(SmIsaMap[0]), sizeof(SmIsaMap[0]), compareSmVersions);
        if (!smIsaMapPtr) {
            stdCHECK_WITH_POS( False, (ptxMsgTargetUnsupported,sourcePos,target) );
        } else {
            // PTXAS should not report version-target mismatch error if input PTX is Empty.
            // This is required to prevent error when input LWCA file contains only host-code.
            // Refer Bug 3246931 for details.
            gblState->isVersionTargetMismatch = !ptxVersionAtLeast(smIsaMapPtr->minPtxMajorVersion,
                                                                      smIsaMapPtr->minPtxMinorVersion,
                                                                      gblState);
            gblState->targetDirectivePos = sourcePos;
        }
    } else {
        stdCHECK_WITH_POS(gblState->target_arch!=NULL, (ptxMsgTargetNotDefined,sourcePos,gblState->parseData->ptxfilename) );

        if (stdEQSTRING(target, "map_f64_to_f32")) {
            stdCHECK_WITH_POS( !checkTargetArch(gblState, 13), (ptxMsgSquashingNotSupported,sourcePos) );
            mapDefine(gblState->target_opts, target, (Pointer)True);
            gblState->parseData->isF64Allowed |= True; 
        } else if (stdEQSTRING(target, "texmode_unified")) {
            // no PTX ISA version check, since unified is default mode
            stdCHECK_WITH_POS( !checkTargetOpts(gblState, "texmode_independent"), (ptxMsgTargetConflict,sourcePos,target) );
            mapDefine(gblState->target_opts, target, (Pointer)True);
        } else if (stdEQSTRING(target, "texmode_independent")) {
            checkFeatureVersion(gblState, 1, 5, "texmode_independent", sourcePos);
            stdCHECK_WITH_POS( !checkTargetOpts(gblState, "texmode_unified"), (ptxMsgTargetConflict,sourcePos,target) );
            mapDefine(gblState->target_opts, target, (Pointer)True);
            gblState->parseData->isTexModeIndependent  = True;
        } else if (stdEQSTRING(target, "debug")) {
            checkFeatureVersion(gblState, 3, 0, "debug", sourcePos);
            mapDefine(gblState->target_opts, target, (Pointer)True);
            gblState->enablePtxDebug = True;
            gblState->foundDebugInfo = False;
            gblState->ptxDebugInfo = True;
        } else {
            stdCHECK_WITH_POS( False, (ptxMsgTargetUnsupported,sourcePos,target) );
        }
    }
    gblState->parseData->isF64Allowed |= checkTargetArch(gblState, 13);
}

/*
 * Set texture mode to default value of texmode_unified if we've finished parsing .target directives
 * in user input without setting texmode_independent.
 */
static void setTexModeDefault(ptxParsingState gblState,  msgSourcePos_t sourcePos )
{
    if (isPtxUserInput(gblState->parseData->ptxfilename) && !checkTargetOpts(gblState, "texmode_independent")) {
        // Check if "texmode_independent" is set through command-line option
        if (gblState->setTexmodeIndependent) {
            setTarget("texmode_independent", &sourcePos, gblState);
        } else {
            setTarget("texmode_unified",&sourcePos, gblState);
        }
    }
}

static void setEmptyUserPTX(ptxParsingState gblState, Bool isEmpty, msgSourcePos_t sourcePos)
{
    cString fileName = msgGetFileName(sourcePos);
    if (isPtxUserInput(fileName)) {
        gblState->isEmptyUserPTX = isEmpty;
    }
}

static void checkAbiParamRegPragma(ptxParsingState gblState, String pragma, int abiParamReg, int firstParamReg,
                                   msgSourcePos_t sourcePos,
                                   Bool isModuleScopePragma);

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
static void checkRetAddrRegPragma(ptxParsingState gblState, String pragma, int retAddrReg,
                                  msgSourcePos_t sourcePos,
                                  Bool isModuleScopePragma,
                                  Bool *isRetAddrInUReg);

static void checkScratchRegsPragma(ptxParsingState gblState, String pragma, stdList_t scratchRegs,
                                   msgSourcePos_t sourcePos, Bool isRReg,
                                   Bool isModuleScopePragma);
#endif // ISA_63

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkRelativeRetAddrRegPragma(ptxParsingState gblState, String pragma, int retAddrReg,
                                          msgSourcePos_t sourcePos,
                                          Bool isModuleScopePragma);
#endif // ISA_70

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void ptxCheckCoroutineVersionTarget(ptxParsingState gblState, String pragma, msgSourcePos_t sourcePos,
                                    Bool isModuleScopePragma);
#endif

static void setPragma(String line, msgSourcePos_t *sourcePos, ptxParsingState gblState)
{
    String pragma = line;
    checkFeatureVersion(gblState, 2, 0, ".pragma directive", *sourcePos);

    if (stdIS_PREFIX(getLWSTOMABIPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxAbiParamReg_PRG), pragma)) {
        int numParams, firstParamReg;
        ptxGetAbiParamRegPragma(pragma, &numParams, &firstParamReg, gblState);
        checkAbiParamRegPragma(gblState, pragma, numParams, firstParamReg, *sourcePos, True);
        gblState->parseData->moduleScopeNumAbiParamReg = numParams;
        if (firstParamReg != UNSPECIFIED_ABI_REG) {
            gblState->parseData->moduleScopeFirstParamReg = firstParamReg;
        }
        return;
    }

    if (stdIS_PREFIX(getLWSTOMABIPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxRetAddrRegBeforeParamReg_PRG), pragma)) {
        gblState->parseData->moduleScopeRetAddrBeforeParams = 1;
        return;
    }

    if (stdIS_PREFIX(getLWSTOMABIPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxRetAddrRegRRel32_PRG), pragma)) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
        int relRetAddrReg = ptxGetPragmaValue(gblState->parseData, pragma);
        checkRelativeRetAddrRegPragma(gblState, pragma, relRetAddrReg, *sourcePos, True);
        gblState->parseData->moduleScopeRelRetAddrReg = relRetAddrReg;
#else
        stdCHECK_WITH_POS(False, (ptxMsgUnknownPragma, sourcePos, pragma));
#endif
        return;
    }

    if (stdIS_PREFIX(getLWSTOMABIPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxRetAddrReg_PRG), pragma)) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
        Bool usesUReg = False;
        int retAddrReg = ptxGetPragmaValue(gblState->parseData, pragma);
        checkRetAddrRegPragma(gblState, pragma, retAddrReg, *sourcePos, True, &usesUReg);
        if (usesUReg) {
            gblState->parseData->moduleScopeRetAddrUReg = retAddrReg;
        } else {
            gblState->parseData->moduleScopeRetAddrReg = retAddrReg;
        }
#else
        stdCHECK_WITH_POS(False, (ptxMsgUnknownPragma, sourcePos, pragma));
#endif
        return;
    }

    if (stdIS_PREFIX(getLWSTOMABIPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxScratchRegsR_PRG), pragma)) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
        stdList_t scratchRegs = ptxGetPragmaValueList(gblState->parseData, pragma, True, True);
        checkScratchRegsPragma(gblState, pragma, scratchRegs, *sourcePos, True, True);
        gblState->parseData->moduleScopeScratchRRegs = ptxGetPragmaValueList(gblState->parseData, pragma, True, True);
#else
        stdCHECK_WITH_POS(False, (ptxMsgUnknownPragma, sourcePos, pragma));
#endif
        return;
    }

    if (stdIS_PREFIX(getLWSTOMABIPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxScratchRegsB_PRG), pragma)) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
        stdList_t scratchRegs = ptxGetPragmaValueList(gblState->parseData, pragma, True, True);
        checkScratchRegsPragma(gblState, pragma, scratchRegs, *sourcePos, False, True);
        gblState->parseData->moduleScopeScratchBRegs = ptxGetPragmaValueList(gblState->parseData, pragma, True, True);
#else
        stdCHECK_WITH_POS(False, (ptxMsgUnknownPragma, sourcePos, pragma));
#endif
        return;
    }

    if (stdIS_PREFIX(getCOROUTINEPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxCoroutine_PRG), pragma)) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        ptxCheckCoroutineVersionTarget(gblState, pragma, *sourcePos, True);
        gblState->parseData->moduleScopeCoroutinePragma = True;
#else
        stdCHECK_WITH_POS(False, (ptxMsgUnknownPragma, *sourcePos, pragma));
#endif
        return;
    }


    if (gblState->parseData->lwrFunc) {
        listXPutAfter( gblState->parseData->lwrFunc->aux->pragmas, line );
    } else {
        listXPutAfter( gblState->pragmas, line );
    }
}


#define NUM_LOGICAL_CONST_BANKS        11  // expose a set of logical banks, remapped to physical banks

static uInt checkConstBank(ptxParsingState gblState,  uInt n, msgSourcePos_t sourcePos )
{
    stdCHECK_WITH_POS( stdIMPLIES( n!=0xffffffff, !ptxVersionAtLeast(2,2, gblState) ), (ptxMsgDeprecatedFeature,sourcePos,"explicit constant banks","2.2") );
    n = (n==0xffffffff) ? 0 : n;  // remap special "no bank" value to bank zero

    if (n!=0)
        checkFeatureVersion(gblState, 1, 5, "banked constants", sourcePos);

    stdCHECK_WITH_POS( n>=0 && n<NUM_LOGICAL_CONST_BANKS, (ptxMsgIllegalConstBank,sourcePos,n) );

    return n;
}

static Bool checkBasicType(ptxExpression expr, msgSourcePos_t sourcePos)
{
    stdString_t s;
    String name;
    if (ptxIsBasicType(expr->type)) return True;

    s = stringNEW();
    ptxPrintExpression(expr, s);
    name = stringStripToBuf(s);
    stdCHECK_WITH_POS(False, (ptxMsgIllegalExpression,
                              sourcePos, name));
    stdFREE(name);
    return False;
}

static ptxType inferVectorElementType(ptxParsingState gblState, stdList_t elements, msgSourcePos_t sourcePos)
{
    ptxType inferredType;
    ptxExpression prevExpr, lwrExpr;

    inferredType = NULL;
    prevExpr = NULL;
    for (; elements; elements = elements->tail) {
        lwrExpr = elements->head;

        if (lwrExpr->kind == ptxSinkExpression) {
            continue;
        }
        if (!checkBasicType(lwrExpr, sourcePos)) {
            continue;
        }
        if (prevExpr == NULL) {
            prevExpr = lwrExpr;
            inferredType = lwrExpr->type;
            continue;
        }
        if (ptxGetTypeSizeInBits(prevExpr->type) != ptxGetTypeSizeInBits(lwrExpr->type)) {
            if (!(ptxIsImmediateExpr(prevExpr) || ptxIsImmediateExpr(lwrExpr))) {
                // if neither of the expression are immediate, then error out if expression size don't match
                stdCHECK_WITH_POS( 0, (ptxMsgElementsMismatch, sourcePos) );
            } else if (ptxIsImmediateExpr(prevExpr)) {
                // if prevExpr was immediate, set inferredType based on lwrExpr
                inferredType = lwrExpr->type;
            } else {
                // if lwrExpr was immediate, set inferredType based on prevExpr
                inferredType = prevExpr->type;
            }
        }
        if (isBitTypeKind(prevExpr->type->kind) || isBitTypeKind(lwrExpr->type->kind)) {
            // BitType compatible with all types
            // If any type is bitType used in vector, promote entire vector to bitType.
            // This is needed in tex instructions with vector {index, b0, b1, b2} 
            // where index is u32 and bX is b32 but are used in tex instruction with .f32 as type.

            // create new type so that original type of element itself is not modified
            inferredType = ptxCreateBitType(ptxGetTypeSizeInBits(inferredType), gblState);
        } else if (prevExpr->type->kind != lwrExpr->type->kind) {
            // if element types don't match, promote vector type to ptxBitType
            // Can happen for vectors in texture array accesses, later parts of
            // the parser do checking for those.

            // create new type so that original type of element itself is not modified
            inferredType = ptxCreateBitType(ptxGetTypeSizeInBits(inferredType), gblState);
        }
    }
    if (!inferredType) {
        stdCHECK_WITH_POS(False, (ptxMsgVectorNoTypeInferred, sourcePos));
        inferredType = ptxCreateBitType(8, gblState);
    }
    return inferredType;
}

static ptxExpression createVectorExpr(ptxParsingState gblState,  stdList_t elements, msgSourcePos_t sourcePos )
{
    uInt N = listSize( elements );
    ptxType inferredType;
    Bool isPredVec = False;
    Bool allowVarSizeVec = False;

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    allowVarSizeVec = True;
#endif

    inferredType = inferVectorElementType(gblState, elements, sourcePos);

    // Allow vector of any size less than 8 if it contains predicates
    // as the instruction P2R/R2P operates on such predicate vector
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_62)
    isPredVec = inferredType->kind == ptxTypePred && N < 8;
#endif

#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    if (!(N==1 || N==2 || N==4 || N==8 || isPredVec || allowVarSizeVec)) {
#else
    if (!(N==1 || N==2 || N==4 || isPredVec)) {
#endif
        stdCHECK_WITH_POS( False, (ptxMsgIllegalVectorSize,sourcePos,N) );
        N = 4;
    }


    return ptxCreateVectorExpr(elements, ptxCreateVectorType(N, ptxCreateBasicType( inferredType->kind, ptxGetTypeSizeInBits(inferredType), gblState) , gblState) );
}

static void checkVectorSelector( String field, ptxVectorSelector *selectors, uInt *dimension, msgSourcePos_t sourcePos )
{
    uInt i=0;

    // skip '.' at start of field
    while (field[i+1]) {
        if (i>0) {
            stdCHECK_WITH_POS( False, (ptxMsgUnimplementedFeature,sourcePos,"vector swizzle") );
            break;
        }
        switch (field[i+1]) {
        case 'x' : selectors[i]= ptxComp_X; break;
        case 'y' : selectors[i]= ptxComp_Y; break;
        case 'z' : selectors[i]= ptxComp_Z; break;
        case 'w' : selectors[i]= ptxComp_W; break;

        case 'r' : selectors[i]= ptxComp_X; break;
        case 'g' : selectors[i]= ptxComp_Y; break;
        case 'b' : selectors[i]= ptxComp_Z; break;
        case 'a' : selectors[i]= ptxComp_W; break;

        default  : stdCHECK_WITH_POS( False, (ptxMsgUnknowlwectorSelector,sourcePos,field[i+1]) );
        }
        i++;
    }

   *dimension= i;
}

static void checkVectorExprModifier(cString modifier, ptxExpression vecExpr, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_64)
    if (stdEQSTRING(modifier,".reverse")) {
        vecExpr->cases.Vector.reverseMod = True; // will reverse the list later
        return;
    }
#endif

    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, modifier));
}

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_62)
static void colwertVideoToByteSelectorForP2RandR2P(ptxExpression arg, uInt index,
                                                   String name,
                                                   msgSourcePos_t sourcePos)
{
    // For instructions p2r and r2p only one byte selector is allowed
    switch (arg->cases.VideoSelect->selector[0]) {
    case ptxCOMP_B0 :  arg->cases.ByteSelect->selector[0] = ptxBYTE_B0; break;
    case ptxCOMP_B1 :  arg->cases.ByteSelect->selector[0] = ptxBYTE_B1; break;
    case ptxCOMP_B2 :  arg->cases.ByteSelect->selector[0] = ptxBYTE_B2; break;
    case ptxCOMP_B3 :  arg->cases.ByteSelect->selector[0] = ptxBYTE_B3; break;
    default :          arg->cases.ByteSelect->selector[0] = ptxBYTE_NONE; break;
    }

    // checks are combined to prevent reporting of duplicate error messages
    stdCHECK_WITH_POS(!(arg->cases.ByteSelect->N != 1 ||
                        arg->cases.ByteSelect->selector[0] == ptxBYTE_NONE),
                      (ptxMsgIncorrectByteSelector, sourcePos, index, name));
}
#endif
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
// TODO: Use generic function to colwert video selector to byte selector and
//       perform checks at instruction level
static uInt colwertVideoToByteSelectorForAmpereInstr(ptxExpression arg)
{
    // For instruction spmetadata only one byte selector is allowed
    switch (arg->cases.VideoSelect->selector[0]) {
    case ptxCOMP_B0 :  return ptxBYTE_B0;
    case ptxCOMP_B1 :  return ptxBYTE_B1;
    case ptxCOMP_B2 :  return ptxBYTE_B2;
    case ptxCOMP_B3 :  return ptxBYTE_B3;
    case ptxCOMP_H0 :  return ptxBYTE_H0;
    case ptxCOMP_H1 :  return ptxBYTE_H1;
    default :          return ptxBYTE_NONE;
    }
}
#endif // ampere, 70

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void createByteSelector(String field, ptxByteSelector *selector, msgSourcePos_t sourcePos )
{

    if (stdEQSTRING(field, ".b01")) { *selector = ptxBYTE_B01; return; }
    if (stdEQSTRING(field, ".b12")) { *selector = ptxBYTE_B12; return; }
    if (stdEQSTRING(field, ".b23")) { *selector = ptxBYTE_B23; return; }
    stdCHECK_WITH_POS(False, (ptxMsgUnknowlwideoSelector,sourcePos,field));

}
#endif

static void checkVideoSelector( String field, ptxVideoSelector *selectors, uInt *N, msgSourcePos_t sourcePos )
{
    uInt  i = 0;
    char  c = field[1];

    // skip '.' at start of field; capture first character which determines selector type
    stdCHECK_WITH_POS (c=='b' || c=='h', (ptxMsgUnknowlwideoSelector,sourcePos,field) ) {
        while (field[i+2]) {
            if (i==4) {
                stdCHECK_WITH_POS( False, (ptxMsgUnknowlwideoSelector,sourcePos,field) );
                break;
            }
            switch (field[i+2]) {
            case '0' : selectors[i] = (c=='b' ? ptxCOMP_B0 : ptxCOMP_H0); break;
            case '1' : selectors[i] = (c=='b' ? ptxCOMP_B1 : ptxCOMP_H1); break;
            case '2' : selectors[i] = (c=='b' ? ptxCOMP_B2 : ptxCOMP_H2); break;
            case '3' : selectors[i] = (c=='b' ? ptxCOMP_B3 : ptxCOMP_H3); break;
            case '4' : selectors[i] = ptxCOMP_B4; stdCHECK_WITH_POS( c=='b', (ptxMsgUnknowlwideoSelector,sourcePos,field) ); break;
            case '5' : selectors[i] = ptxCOMP_B5; stdCHECK_WITH_POS( c=='b', (ptxMsgUnknowlwideoSelector,sourcePos,field) ); break;
            case '6' : selectors[i] = ptxCOMP_B6; stdCHECK_WITH_POS( c=='b', (ptxMsgUnknowlwideoSelector,sourcePos,field) ); break;
            case '7' : selectors[i] = ptxCOMP_B7; stdCHECK_WITH_POS( c=='b', (ptxMsgUnknowlwideoSelector,sourcePos,field) ); break;
              
            default  : stdCHECK_WITH_POS( False, (ptxMsgUnknowlwideoSelector,sourcePos,field) );
            }
            i++;
        }
    }
    *N= i;
}

static Bool isVideoScalarSelector( ptxExpression arg, uInt i )
{
    if (arg->kind != ptxVideoSelectExpression)  return True;   //no defaults
    if (arg->cases.VideoSelect->N != 1)          return False;

    switch (arg->cases.VideoSelect->selector[0]) {
    case ptxCOMP_NONE:
    case ptxCOMP_H0:
    case ptxCOMP_H1:
    case ptxCOMP_B0:
    case ptxCOMP_B1:
    case ptxCOMP_B2:
    case ptxCOMP_B3: return True;
    default:         return False;
    }
    return False;
}

static Bool isVideoSIMD2Selector( ptxExpression *p_arg, uInt i )
{
    ptxExpression arg = *p_arg;
    if (arg->kind != ptxVideoSelectExpression) {
        //if symbol expression create the default selectors
        if (arg->kind == ptxSymbolExpression && arg->cases.Symbol.symbol->storage.kind == ptxRegStorage && ptxGetTypeSizeInBits(arg->type) == 32) {
            ptxVideoSelector selectors[4];
            uInt             N;
            String field;
            switch(i) {
                case 0:
                case 1: field = ".h10"; break;
                case 2: field = ".h32"; break;
                case 3: return True;        //no need to do anything for operand 'c'
                default: return False;
            }
            checkVideoSelector(field,selectors,&N,arg->cases.Symbol.symbol->symbol->sourcePos);
            *p_arg = ptxCreateVideoSelectExpr(arg,N,selectors);
        }
        else {
            return False;
        }
    }
    arg = *p_arg;

    if (i == 0) {
        uInt i;
        uInt val = 0xf;  // marker to allow checking for (illegal) leading zeros on destination video selector/mask

        stdASSERT(arg->kind == ptxVideoSelectExpression, ("Video select expression expected"));
        if (arg->cases.VideoSelect->N < 1 || arg->cases.VideoSelect->N > 2)  return False;

        for (i=0; i<arg->cases.VideoSelect->N; i++) {
            switch (arg->cases.VideoSelect->selector[i]) {
            case ptxCOMP_H0:  val = (val << 4) + 0x0;  break;
            case ptxCOMP_H1:  val = (val << 4) + 0x1;  break;
            default:          return False;
            }
        }
        switch (val) {
        case 0xf0:                   // X
        case 0xf1:                   // Y
        case 0xf10:    return True;  // XY
        default:       return False;
        }
    } else {
        uInt  i;
        stdASSERT(arg->kind == ptxVideoSelectExpression, ("Video select expression expected"));
        if (arg->cases.VideoSelect->N != 2)      return False;

        for (i=0; i<arg->cases.VideoSelect->N; i++) {
            switch (arg->cases.VideoSelect->selector[i]) {
            case ptxCOMP_H0: 
            case ptxCOMP_H1: 
            case ptxCOMP_H2: 
            case ptxCOMP_H3: return True;
            default:         return False;
            }
        }
    }
    return False;
}

static Bool isVideoSIMD4Selector( ptxExpression *p_arg, uInt i )
{
    ptxExpression arg = *p_arg;
    if (arg->kind != ptxVideoSelectExpression) {
        //if symbol expression create the default selectors
        if (arg->kind == ptxSymbolExpression && arg->cases.Symbol.symbol->storage.kind == ptxRegStorage && ptxGetTypeSizeInBits(arg->type) == 32) {
            ptxVideoSelector selectors[4];
            uInt             N;
            String field;
            switch(i) {
                case 0:
                case 1: field = ".b3210"; break;
                case 2: field = ".b7654"; break;
                case 3: return True;        //no need to do anything for operand 'c'
                default: return False;
            }
            checkVideoSelector(field,selectors,&N,arg->cases.Symbol.symbol->symbol->sourcePos);
            *p_arg = ptxCreateVideoSelectExpr(arg,N,selectors);
        }
        else {
            return False;
        }
    }
    arg = *p_arg;

    if (i == 0) {
        uInt i;
        uInt val = 0xf;  // marker to allow checking for (illegal) leading zeros on destination video selector/mask

        stdASSERT(arg->kind == ptxVideoSelectExpression, ("Video select expression expected"));
        if (arg->cases.VideoSelect->N < 1 || arg->cases.VideoSelect->N > 4)  return False;

        for (i=0; i<arg->cases.VideoSelect->N; i++) {
            switch (arg->cases.VideoSelect->selector[i]) {
            case ptxCOMP_B0:  val = (val << 4) + 0x0;  break;
            case ptxCOMP_B1:  val = (val << 4) + 0x1;  break;
            case ptxCOMP_B2:  val = (val << 4) + 0x2;  break;
            case ptxCOMP_B3:  val = (val << 4) + 0x3;  break;
            default:          return False;
            }
        }
        switch (val) {
        case 0xf0:                   // X
        case 0xf1:                   // Y
        case 0xf2:                   // Z
        case 0xf3:                   // W
        case 0xf10:                  // XY
        case 0xf20:                  // XZ
        case 0xf30:                  // XW
        case 0xf21:                  // YZ
        case 0xf31:                  // YW
        case 0xf32:                  // ZW
        case 0xf210:                 // XYZ
        case 0xf310:                 // XYW
        case 0xf320:                 // XZW
        case 0xf321:                 // YZW
        case 0xf3210:  return True;  // XYZW
        default:       return False;
        }
    } else {
        uInt  i;
        stdASSERT(arg->kind == ptxVideoSelectExpression, ("Video select expression expected"));
        if (arg->cases.VideoSelect->N != 4)      return False;

        for (i=0; i<arg->cases.VideoSelect->N; i++) {
            switch (arg->cases.VideoSelect->selector[i]) {
            case ptxCOMP_B0: 
            case ptxCOMP_B1: 
            case ptxCOMP_B2: 
            case ptxCOMP_B3: 
            case ptxCOMP_B4: 
            case ptxCOMP_B5: 
            case ptxCOMP_B6: 
            case ptxCOMP_B7: return True;
            default:         return False;
            }
        }
    }
    return False;
}

static ptxExpression createParamListExpr(ptxParsingState gblState,  stdList_t elements, msgSourcePos_t sourcePos )
{
    return ptxCreateParamListExpr(elements, gblState);
}


static ptxExpression createInitValExpr(ptxParsingState gblState,  String name, msgSourcePos_t sourcePos )
{
    if (stdEQSTRING(name, "wrap"))                  return ptxCreateIntConstantExpr( ptxTexWrap,        True, gblState);
    else if (stdEQSTRING(name, "mirror"))           return ptxCreateIntConstantExpr( ptxTexMirror,      True, gblState);
    else if (stdEQSTRING(name, "clamp_ogl"))        return ptxCreateIntConstantExpr( ptxTexClampOGL,    True, gblState);
    else if (stdEQSTRING(name, "clamp_to_edge"))    return ptxCreateIntConstantExpr( ptxTexClampEdge,   True, gblState);
    else if (stdEQSTRING(name, "clamp_to_border"))  return ptxCreateIntConstantExpr( ptxTexClampBorder, True, gblState);
    else if (stdEQSTRING(name, "nearest"))          return ptxCreateIntConstantExpr( ptxTexNearest,     True, gblState);
    else if (stdEQSTRING(name, "linear"))           return ptxCreateIntConstantExpr( ptxTexLinear,      True, gblState);

    stdCHECK_WITH_POS( False, (ptxMsgInitValUnrecognized,sourcePos,name) );
    return NULL;
}


static void setLwrAlignment(ptxParsingState gblState, uInt alignment, msgSourcePos_t sourcePos )
{
    // TODO: Probably change message to use ptxMsgWrongValue
    stdCHECK_WITH_POS( alignment>0 && stdISPOW2((Int)alignment), ( ptxMsgWrongAlignmentValue, sourcePos) ) {
        uInt logAlignment= stdLOG2(alignment);
        gblState->parseData->lwrLogAlignment= stdMAX( gblState->parseData->lwrLogAlignment, logAlignment );
    }
}

static void setResourceInfoFromType(ptxParsingState gblState, ptxType type)
{
    if (!gblState) return;
    gblState->ptxResourceInfo.isTextureUsed |= isTEXREF(type);
    gblState->ptxResourceInfo.isSamplerUsed |= isSAMPLERREF(type);
    gblState->ptxResourceInfo.isSurfaceUsed |= isSURFREF(type);
}

static void setResourceInfoFromStorage(ptxParsingState gblState, ptxStorageClass s)
{
    if (!gblState) return;
    switch (s.kind) {
    case ptxSharedStorage:
        gblState->ptxResourceInfo.isSharedMemUsed = True;
        break;
    case ptxTexStorage:
        gblState->ptxResourceInfo.isTextureUsed = True;
        break;
    case ptxConstStorage:
        gblState->ptxResourceInfo.isConstUsed = True;
        break;
    case ptxSurfStorage:
        gblState->ptxResourceInfo.isSurfaceUsed = True;
        break;
    default:
        break;
    }
}

static void setLwrStorageClass(ptxParsingState gblState,  ptxStorageClass storage, msgSourcePos_t sourcePos )
{
    stdCHECK_WITH_POS( gblState->parseData->lwrStorageClass.kind==ptxUNSPECIFIEDStorage, ( ptxMsgMultipleSpace, sourcePos ) ) {
        gblState->parseData->lwrStorageClass= storage;
    }
    setResourceInfoFromStorage(gblState, storage);
}

static void setLwrSymbolAttribute(ptxParsingState gblState,  ptxSymbolAttribute attribute, msgSourcePos_t sourcePos )
{
    checkFeatureVersion(gblState, 4, 0, ".attribute", sourcePos);
    if (attribute == ptxAttributeManaged) {
        // .managed requires sm_30+
        stdCHECK_WITH_POS(checkTargetArch(gblState, 30), (ptxMsgFeatureRequiresSMVersion,sourcePos,".managed","sm_30") );
    }

    gblState->parseData->lwrSymbolAttributes |= attribute;
}

static ptxPointerAttr checkKernelParamAttr(ptxParsingState gblState,  ptxPointerAttr attr, msgSourcePos_t sourcePos )
{
    checkFeatureVersion(gblState, 2, 2, "kernel parameter pointer attribute", sourcePos);
    if (attr == ptxPtrTexref || attr == ptxPtrSamplerref || attr == ptxPtrSurfref) {
        checkFeatureVersion(gblState, 4, 3, "kernel parameter pointers to opaque types", sourcePos);
    }
    stdCHECK_WITH_POS( gblState->parseData->lwrIsEntry, (ptxMsgIllegalKernelAttr,sourcePos) );

    return attr;
}

static ptxPointerAttr getPtxPtrForOpaque( ptxType type, msgSourcePos_t sourcePos )
{
    if (isTEXREF(type)) {
        return ptxPtrTexref;
    } else if (isSAMPLERREF(type)) {
        return ptxPtrSamplerref;
    } else if (isSURFREF(type)) {
        return ptxPtrSurfref;
    } else {
        stdCHECK_WITH_POS( False, (ptxMsgParsingError,sourcePos,".ptr","syntax error") );
    }
    return ptxPtrNone;
}
    
static uInt checkKernelParamAlignAttr(ptxParsingState gblState,  uInt alignment, msgSourcePos_t sourcePos )
{
    stdCHECK_WITH_POS( gblState->parseData->lwrIsEntry, (ptxMsgIllegalKernelAttr,sourcePos) );
    // TODO: Probably change message to use ptxMsgWrongValue
    stdCHECK_WITH_POS( alignment>0 && stdISPOW2((Int)alignment), ( ptxMsgWrongAlignmentValue, sourcePos) ) {
        return stdLOG2(alignment);
    }
    return 0;
}

static int checkAllocNoAttr(ptxParsingState gblState,  int allocno, msgSourcePos_t sourcePos )
{
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    checkFeatureVersion(gblState, 6, 0, ".allocno attribute", sourcePos);
    stdCHECK_WITH_POS( checkTargetArch(gblState, 30),
                      (ptxMsgFeatureRequiresSMVersion,sourcePos,
                      ".allocno attribute", "sm_30") );

    // OPTIX_HAND_EDIT Fix signed/unsigned comparison warnings
    if (allocno > (int)gblState->gpuInfo->maxRegsPerThread) {
        stdCHECK_WITH_POS(False, (ptxMsgWrongValue, sourcePos, ".allocno",
                                  allocno, gblState->gpuInfo->profileName));
        return -1;
    }
    stdCHECK_WITH_POS(gblState->parseData->lwrStorageClass.kind == ptxRegStorage,
                      (ptxMsgIlwalidStorage, sourcePos,
                      "Parameters with .allocno", ".reg"));
    return allocno;
#else
    stdCHECK_WITH_POS(False, (ptxMsgParsingError, sourcePos,
                              ".allocno", "syntax error"));
    return -1;
#endif
}

static int checkRetAddrAllocNoAttr(ptxParsingState gblState,  int allocno, msgSourcePos_t sourcePos )
{
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    checkFeatureVersion(gblState, 6, 0, ".retaddr_allocno attribute", sourcePos);
    stdCHECK_WITH_POS( checkTargetArch(gblState, 30),
                      (ptxMsgFeatureRequiresSMVersion,sourcePos,
                      ".retaddr_allocno attribute", "sm_30") );

    // OPTIX_HAND_EDIT Fix signed/unsigned comparison warnings
    if (allocno > (int)gblState->gpuInfo->maxRegsPerThread) {
        stdCHECK_WITH_POS(0, (ptxMsgWrongValue, sourcePos, ".retaddr_allocno",
                              allocno, gblState->gpuInfo->profileName));
        return -1;
    }
    return allocno;
#else
    stdCHECK_WITH_POS(False, (ptxMsgParsingError, sourcePos,
                                ".retaddr_allocno", "syntax error"));
    return -1;
#endif
}


static stdList_t checkScratchRegs(ptxParsingState gblState,  stdList_t scratchRegs, msgSourcePos_t sourcePos )
{
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    // OPTIX_HAND_EDIT Fix signed/unsigned comparison warnings
    uInt numScratchEntries;
    checkFeatureVersion(gblState, 6, 0, ".scratch attribute", sourcePos);
    stdCHECK_WITH_POS( checkTargetArch(gblState, 30),
                      (ptxMsgFeatureRequiresSMVersion,sourcePos,
                      ".scratch attribute", "sm_30") );

    numScratchEntries = stdROUNDUP(gblState->gpuInfo->maxRegsPerThread, 4) / 64;
    stdCHECK_WITH_POS( listSize(scratchRegs) <= numScratchEntries,
                       (ptxMsgTooManyValues,sourcePos,".scratch"));

    return scratchRegs;
#else
    stdCHECK_WITH_POS(False, (ptxMsgParsingError, sourcePos,
                                ".scratch", "syntax error"));
    return NULL;
#endif
}

static int checkNoReturn(ptxParsingState gblState, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_64)
    checkFeatureVersion(gblState, 6, 4, ".noreturn", sourcePos);
    stdCHECK_WITH_POS(checkTargetArch(gblState, 30),
                      (ptxMsgFeatureRequiresSMVersion,sourcePos,
                      ".noreturn", "sm_30"));
    return 1;
#else
    stdCHECK_WITH_POS(False, (ptxMsgParsingError, sourcePos,
                                ".noreturn", "syntax error"));
    return 0;
#endif
}

static Bool argIsOpaqueType( ptxExpression arg, Bool (*fptr)( ptxType ) )
{
    switch (arg->kind) {
    case ptxSymbolExpression:       return (fptr(arg->type));
    case ptxAddressOfExpression:    return (argIsOpaqueType(arg->cases.AddressOf.lhs, fptr));
    case ptxAddressRefExpression:   return (argIsOpaqueType(arg->cases.AddressRef.arg, fptr));
    default:                        return False;
    }
    return False;
 }
static Bool argIsI64Reg( ptxExpression arg )
{
    switch (arg->kind) {
    case ptxSymbolExpression:       return ( (isB64(arg->type) || isI64(arg->type)) && arg->cases.Symbol.symbol->storage.kind == ptxRegStorage );
    case ptxAddressOfExpression:    return (argIsI64Reg(arg->cases.AddressOf.lhs));
    case ptxAddressRefExpression:   return (argIsI64Reg(arg->cases.AddressRef.arg));
    default:                        return False;
    }
    return False;
 }

/*-------------------- Symbol Table Manipulation Functions -------------------*/

static Bool isOutermostScope( ptxDeclarationScope scope )
{
    return (scope == ptxGlobalScope || scope == ptxWeakScope || scope == ptxExternalScope || scope == ptxCommonScope);
}

// Return true iff we are at module scope.
static Bool atModuleScope(ptxParsingState gblState)
{
    return gblState->lwrSymbolTable == gblState->objectSymbolTable;
}

static void checkInitializerAddressOfExpression(ptxParsingState gblState, ptxExpression expr, ptxType type,
                                                uInt64 mask, msgSourcePos_t sourcePos)
{
    ptxStorageClass storage = ptxGetStorage(expr->cases.AddressOf.lhs);
    checkFeatureVersion(gblState, 2, 1, "addresses as initial values", sourcePos);
    stdCHECK_WITH_POS((storage.kind == ptxGlobalStorage
                       || storage.kind == ptxConstStorage),
                      (ptxMsgInitValIllegalSpace, sourcePos) );
    stdCHECK_WITH_POS(isU32(type) || isU64(type) || (mask != ~0 && isU8(type)),
                      (ptxMsgInitValTypeMismatch, sourcePos) );
}

static void checkInitialValue(ptxInitializer initVal, ptxType type, ptxParsingState gblState)
{
    msgSourcePos_t sourcePos = initVal->sourcePos;

    stdCHECK_WITH_POS( !isF16(type), (ptxMsgNoF16InitValAllowed,sourcePos) );

    switch (initVal->kind) {
    case ptxExpressionInitializer :
    {
        ptxExpression expr= initVal->cases.Expression.expr;

        if (initVal->cases.Expression.isGeneric) {
            checkFeatureVersion(gblState, 3, 1, "generic() operator", sourcePos);
            stdCHECK_WITH_POS(expr->kind == ptxBinaryExpression || expr->kind == ptxAddressOfExpression,
                              (ptxMsgInitValIlwalidExpression, sourcePos));
        }

        switch (expr->kind) {
        case ptxIntConstantExpression:
        case ptxFloatConstantExpression:
            stdCHECK_WITH_POS( ptxAssignmentCompatible(type,expr->type, isImmediate(expr)),
                               (ptxMsgInitValTypeMismatch, sourcePos));
            break;

        case ptxLabelReferenceExpression:
            stdCHECK_WITH_POS(False, (ptxMsgInitValIlwalidSymbol, sourcePos,
                                      expr->cases.LabelReference->name));
            break;

        case ptxSymbolExpression:
            {
                ptxSymbolTableEntry symbol = expr->cases.Symbol.symbol;
                uInt64 mask = initVal->cases.Expression.mask;

                // Fatal error.
                stdCHECK_WITH_POS(symbol->kind == ptxFunctionSymbol,
                                  (ptxMsgInitValIlwalidSymbol, sourcePos,
                                   symbol->symbol->name));

                checkFeatureVersion(gblState, 2, 1, "functions as initial values", sourcePos);
                stdCHECK_WITH_POS( checkTargetArch(gblState, 20), (ptxMsgFeatureRequiresSMVersion,sourcePos,"functions as initial values","sm_20") );
                stdCHECK_WITH_POS( isU32(type) || isU64(type)
                                   || (mask != ~0 && isU8(type)), (ptxMsgInitValTypeMismatch, sourcePos) );
                if (symbol->aux->isEntry) {
                    checkFeatureVersion(gblState, 3, 1, "entry functions as initial values", sourcePos);
                    stdCHECK_WITH_POS( checkTargetArch(gblState, 35), (ptxMsgFeatureRequiresSMVersion,sourcePos,
                                                             "entry functions as initial values","sm_35") );
                }
            }
            break;

        case ptxBinaryExpression:
            // if base+offset expression, check base consistency
            expr = expr->cases.Binary->left;

            // Fatal error.
            stdCHECK_WITH_POS(expr->kind == ptxAddressOfExpression,
                              (ptxMsgInitValTypeMismatch, sourcePos));
            checkInitializerAddressOfExpression(gblState, expr, type, initVal->cases.Expression.mask, sourcePos);
            break;

        case ptxAddressOfExpression: {
            checkInitializerAddressOfExpression(gblState, expr, type, initVal->cases.Expression.mask, sourcePos);
            break;
        }

        default:
            stdCHECK_WITH_POS( False, (ptxMsgInitValIlwalidExpression,sourcePos,"unsupported initializer kind"));
        }

        break;
    }

    case ptxStructuredInitializer :
    {
      stdList_t initList = initVal->cases.Structured.list;

      switch (type->kind) {
      case ptxTypeB8              :
      case ptxTypeB16             :
      case ptxTypeB32             :
      case ptxTypeB64             :
      case ptxTypeB128            :
      case ptxTypeF16             :
      case ptxTypeF32             :
      case ptxTypeF64             :
      case ptxTypeU8              :
      case ptxTypeU16             :
      case ptxTypeU32             :
      case ptxTypeU64             :
      case ptxTypeS8              :
      case ptxTypeS16             :
      case ptxTypeS32             :
      case ptxTypeS64             :
      case ptxLabelType           :
      case ptxMacroType           :
      case ptxTypePred            :
      case ptxIncompleteArrayType :
          stdCHECK_WITH_POS( False, (ptxMsgInitValTypeMismatch, sourcePos) );
          break;

      case ptxOpaqueType    :
        {
          stdList_t f, fields= type->cases.Opaque.fields;

          checkFeatureVersion(gblState, 1,5,"opaque type initializers",sourcePos);
          stdCHECK_WITH_POS( listSize(initList) <= listSize(fields), (ptxMsgOpaqueSizeMismatch, sourcePos) );

          while (initList) {
              ptxInitializer initVal = initList->head;
              ptxExpression  expr;
              ptxSymbol      field = NULL;

              // Fatal error.
              stdCHECK_WITH_POS(initVal->kind==ptxNamedFieldInitializer,
                                (ptxMsgOpaqueRequiresNamedFields, sourcePos));

              expr = initVal->cases.NamedField.expr;

              // find named field in opaque structure typedef
              for (f=fields; f; f=f->tail) {
                  if (stdEQSTRING(initVal->cases.NamedField.name, ((ptxSymbol)(f->head))->unMangledName)) { field = f->head; break; }
              }

              // Fatal error.
              stdCHECK_WITH_POS( field, (ptxMsgOpaqueNameMismatch,sourcePos,initVal->cases.NamedField.name));
              stdASSERT(field, ("expected matching field"));

              if (stdEQSTRING(field->unMangledName, "channel_data_type"))
                  checkFeatureVersion(gblState, 2, 1, "channel_data_type attribute", sourcePos);
              if (stdEQSTRING(field->unMangledName, "channel_order"))
                  checkFeatureVersion(gblState, 2, 1, "channel_order attribute", sourcePos);
              if (stdEQSTRING(field->unMangledName, "force_unnormalized_coords"))
                  checkFeatureVersion(gblState, 2, 2, "force_unnormalized_coords attribute", sourcePos);

              stdCHECK_WITH_POS(ptxAssignmentCompatible(field->type, expr->type, isImmediate(expr)),
                                (ptxMsgInitValTypeMismatch, sourcePos));

              // warn if texref variable has samplerref field initialized in .tex_independent mode, since field will be ignored
              if (isTEXREF(type) && checkTargetOpts(gblState, "texmode_independent")) {
                  stdCHECK_WITH_POS( !stdEQSTRING(field->unMangledName,"filter_mode"), (ptxMsgTexrefFieldIgnored,sourcePos,field->unMangledName) );
                  stdCHECK_WITH_POS( !stdEQSTRING(field->unMangledName,"addr_mode_0"), (ptxMsgTexrefFieldIgnored,sourcePos,field->unMangledName) );
                  stdCHECK_WITH_POS( !stdEQSTRING(field->unMangledName,"addr_mode_1"), (ptxMsgTexrefFieldIgnored,sourcePos,field->unMangledName) );
                  stdCHECK_WITH_POS( !stdEQSTRING(field->unMangledName,"addr_mode_2"), (ptxMsgTexrefFieldIgnored,sourcePos,field->unMangledName) );
              }
              initList = initList->tail;
          }
          break;
        }

      case ptxVectorType    :
        {
          uInt vectorSize= type->cases.Vector.N;

          stdCHECK_WITH_POS( listSize(initList) == vectorSize, (ptxMsgVectorSizeMismatch, sourcePos) );
          LIST_TRAVERSE_MULTI_ARGS( initList, checkInitialValue, type->cases.Vector.base, gblState);
          break;
        }

      case ptxArrayType     :
        {
          uInt64 arraySize= type->cases.Array.N;
          //allow partial array initialization (similar to C)
          stdCHECK_WITH_POS( listSize(initList) <= arraySize, (ptxMsgArraySizeLarge,sourcePos) );
          LIST_TRAVERSE_MULTI_ARGS( initList, checkInitialValue, type->cases.Array.base, gblState );
          break;
        }

      default : stdASSERT( False, ("Case label out of bounds") );
      }
      break;
    }
    default : stdASSERT( False, ("Case label out of bounds") );
    }
}


static Bool typeResolve( ptxType *t1, ptxType *t2)
{
    if (*t1 == *t2) { return True; }

    if ((*t2)->kind == ptxIncompleteArrayType) {
        stdSWAP(t1,t2,Pointer);
    }

    if ( (*t1)->kind == ptxIncompleteArrayType
      && (*t2)->kind == ptxArrayType
      && (*t1)->cases.IncompleteArray.base == (*t2)->cases.Array.base
       ) {
       *t1= *t2;
       return True;
    }

    return False;
}

static void checkType(ptxParsingState gblState, msgSourcePos_t sourcePos) {
    // If an opaque type is used, ensure that it is at module scope,
    // or inside the parameter list of an entry function. Note that
    // ".tex" need not be covered since it is a storage class allowed
    // only at module scope. This is checked in defineVar(gblState).
    if (gblState->parseData->lwrType->kind == ptxOpaqueType) {
        if (!atModuleScope(gblState)) {
            stdCHECK_WITH_POS(gblState->parseData->lwrIsEntry && gblState->parsingParameters,
                              (ptxMsgOpaqueModuleOrEntryScope, sourcePos));
        }
    } else if (isF16x2(gblState->parseData->lwrType)) {
        stdCHECK_WITH_POS(checkTargetArch(gblState, 53),
                          (ptxMsgFeatureRequiresSMVersion,
                           sourcePos, ".f16x2 packed data-type", "sm_53"));
        checkFeatureVersion(gblState, 4, 2, ".f16x2 packed data-type", sourcePos);
    }
}

static void setSymbolType( ptxSymbol symbol, ptxType type )
{
    symbol->type = type;
    symbol->logAlignment = stdMAX(symbol->logAlignment, ptxGetTypeLogAlignment(type));
}

static void setArrayInitializer(ptxParsingState gblState, ptxSymbol symbol, ptxSymbolTableEntry func, ptxVariableInfo varinfo)
{
    char *name;
    String mangledName;

    if (!func) {
        name = stdCOPYSTRING(symbol->name);
    } else {
      if( ptxIsManglingNeeded(varinfo->storage) ) {
          mangledName = stdCOPYSTRING(symbol->name);
      }
      else {
        mangledName = stdCOPYSTRING(symbol->unMangledName);
      }

        name = stdMALLOC (strlen(func->symbol->name) + strlen(mangledName) + 3);
        sprintf (name, "$%s$%s", func->symbol->name, mangledName);
        
        stdFREE(mangledName);
    }
    mapDefine(gblState->arrayInit, name, varinfo);
}

static void defineVar(ptxVariableInfo varI, Bool *isParamPtr,ptxParsingState gblState)
{
    ptxSymbol      texref  = ptxLookupOpaque(gblState->globalSymbolTable, ".texref", True);
    ptxSymbol      var;
    ptxInitializer initVal;
    uInt           range;
    ptxSymbolTable insertInto;
    Bool           isParam = *isParamPtr;
    // OPTIX_HAND_EDIT remove unused variable arch
    //int            arch;
    uInt           idx, suffixStart;
    Bool           isTypeNotRestricted;

    var             = varI->symbol;
    initVal         = varI->initializer;
    range           = varI->range;        // non-zero for parameterized variables
    gblState->parseData->lwrStorageClass = varI->storage;      // storage class saved for each variable; needed for post-processing of parameters

    // Error out for unspecified storage class
    stdCHECK_WITH_POS( gblState->parseData->lwrStorageClass.kind != ptxUNSPECIFIEDStorage, (ptxMsgUnspecifiedVarStorage, var->sourcePos) );

    //
    // handle legacy .tex declarations
    //

    //  these must be at global/module scope and of type .u32 or .u64
    stdCHECK_WITH_POS( stdIMPLIES( (gblState->parseData->lwrStorageClass.kind==ptxSurfStorage || gblState->parseData->lwrStorageClass.kind==ptxTexStorage), (isU32(var->type) || isU64(var->type)) ),
                       (ptxMsgU32orU64TypeRequired,var->sourcePos,var->unMangledName) );
    stdCHECK_WITH_POS( stdIMPLIES(gblState->parseData->lwrStorageClass.kind==ptxTexStorage, atModuleScope(gblState)), (ptxMsgTexRequiresModuleScope,var->sourcePos) );

    // .tex deprecated for PTX 1.5 and later; .surf unimplemented; check opaque-type version requirement before colwerting .tex to .texref
    stdCHECK_WITH_POS( stdIMPLIES(gblState->parseData->lwrStorageClass.kind==ptxTexStorage, !ptxVersionAtLeast(1,5, gblState)), (ptxMsgDeprecatedFeature,var->sourcePos,".tex","1.5") );
    stdCHECK_WITH_POS( gblState->parseData->lwrStorageClass.kind!=ptxSurfStorage, (ptxMsgUnimplementedFeature,var->sourcePos,".surf") );
    if (var->type->kind==ptxOpaqueType) checkFeatureVersion(gblState, 1, 5, "opaque type", var->sourcePos);

    //  colwert .tex {.b32/.b64} to .global .texref
    if (gblState->parseData->lwrStorageClass.kind == ptxTexStorage) {
        gblState->parseData->lwrStorageClass = ptxCreateStorageClass(ptxGlobalStorage, -1);
        setSymbolType(var, texref->type);
    }

    // set information about resource used
    setResourceInfoFromType(gblState, var->type);

    // general checks

    stdCHECK_WITH_POS( stdIMPLIES( initVal, ptxIsInitializableStorage(gblState->parseData->lwrStorageClass) ), (ptxMsgSpaceNotInitializable, var->sourcePos, var->unMangledName) );

    isTypeNotRestricted = !isB128(var->type);
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    isTypeNotRestricted = isTypeNotRestricted && !isF8(var->type) && !isF8x2(var->type);
#endif
    stdCHECK_WITH_POS( isTypeNotRestricted, (ptxMsgTypeRestricted, var->sourcePos, getTypeEnumAsString(gblState->parseData->deobfuscatedStringMapPtr, var->type->kind)) );

    if (initVal) { checkInitialValue(initVal, var->type, gblState); }

    if (ptxIsRegisterStorage(gblState->parseData->lwrStorageClass) ) {
        stdCHECK_WITH_POS( ptxIsRegisterType(var->type), (ptxMsgNotInRegister,var->sourcePos,var->unMangledName) );
    }

    stdCHECK_WITH_POS( stdIMPLIES( gblState->parseData->lwrStorageClass.kind==ptxParamStorage, ptxIsParameterType(var->type, gblState->parseData->lwrIsEntry)), (ptxMsgNotInParameter,var->sourcePos,var->unMangledName) );
    stdCHECK_WITH_POS( stdIMPLIES( gblState->parseData->lwrStorageClass.kind==ptxParamStorage && !(gblState->parseData->lwrIsEntry && isParam), var->logAlignment<=7), (ptxMsgFunctionArgAlignError,var->sourcePos,var->unMangledName) );

    stdCHECK_WITH_POS( stdIMPLIES( initVal,                      gblState->parseData->lwrScope!=ptxExternalScope), (ptxMsgNoExternInitAllowed, var->sourcePos, var->unMangledName) );
    stdCHECK_WITH_POS( stdIMPLIES( !ptxIsCompleteType(var->type),gblState->parseData->lwrScope==ptxExternalScope || isParam), (ptxMsgIncompleteType,      var->sourcePos, var->unMangledName) );

    stdCHECK_WITH_POS( (gblState->parseData->lwrStorageClass.kind != ptxSregStorage), (ptxMsgSregSpaceNodecl, var->sourcePos) );

    stdCHECK_WITH_POS( stdIMPLIES( isPRED(var->type), gblState->parseData->lwrStorageClass.kind==ptxRegStorage), (ptxMsgPredVarMustBeInRegister, var->sourcePos, var->unMangledName) );

    stdCHECK_WITH_POS( stdIMPLIES(var->type->kind==ptxOpaqueType && atModuleScope(gblState), gblState->parseData->lwrStorageClass.kind==ptxGlobalStorage), (ptxMsgRequiresGlobalSpace,var->sourcePos, "Texture and surface") );
    stdCHECK_WITH_POS( stdIMPLIES(isSAMPLERREF(var->type), checkTargetOpts(gblState, "texmode_independent")), (ptxMsgTexModeViolation,var->sourcePos,"unified") );

    stdCHECK_WITH_POS( stdIMPLIES(ptxCheckSymbolAttribute(var, ptxAttributeManaged), (gblState->parseData->lwrStorageClass.kind == ptxGlobalStorage)),
                       (ptxMsgIllegalAttribute,var->sourcePos,".managed",var->name) );

    if (gblState->parseData->lwrScope == ptxCommonScope) {
        stdCHECK_WITH_POS( (gblState->parseData->lwrStorageClass.kind == ptxGlobalStorage), (ptxMsgRequiresGlobalSpace,var->sourcePos,".common") );
        stdCHECK_WITH_POS( var->type->kind!=ptxOpaqueType, (ptxMsgIllegalType,var->sourcePos,".common symbol") );
    }
    /*
     *  In PTX 2.0 with target sm_2x, .param can occur as kernel and function parameters, and also as locally-scoped variables
     *  within kernels and functions.  For target sm_1x, .param can occur only as kernel functions.
     *
     *  Prior to PTX 1.4, entry params were declared in the entry kernel body
     *  - handle legacy PTX .param variables by adding them to the function's fparam list
     */
    stdCHECK_WITH_POS( stdIMPLIES(gblState->parseData->lwrStorageClass.kind==ptxParamStorage, !atModuleScope(gblState)), (ptxMsgParamIllegalAtModuleScope,var->sourcePos) );
    if (!ptxVersionAtLeast(2,0, gblState)) {
        stdCHECK_WITH_POS( stdIMPLIES(gblState->parseData->lwrStorageClass.kind==ptxParamStorage, gblState->parseData->lwrIsEntry), (ptxMsgParamRequiresEntryScope,var->sourcePos) );
        stdCHECK_WITH_POS( stdIMPLIES(gblState->parseData->lwrStorageClass.kind==ptxParamStorage && ptxVersionAtLeast(1,4, gblState), isParam), (ptxMsgEntryParamListRequired,var->sourcePos) );

        // handle legacy PTX .param variables declared within kernel body by adding them to function's fparam list
        // Note: this list will be reversed at end of kernel body parsing
        if (!ptxVersionAtLeast(1,4, gblState) && gblState->parseData->lwrStorageClass.kind==ptxParamStorage && !isParam) {
          gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->fparams = listCons(varI, gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->fparams);
        }
    }

    // Constant banks 1..NUM_LOGICAL_CONST_BANKS are reserved for extern unsized constant arrays
    // Check incomplete constant arrays are in constant 1..11 for PTX ISA version < 2.2
    if ( !ptxVersionAtLeast(2, 2, gblState) && gblState->parseData->lwrStorageClass.kind == ptxConstStorage ) {
        stdCHECK_WITH_POS( stdEQUIV( (gblState->parseData->lwrStorageClass.bank!=0), (gblState->parseData->lwrScope==ptxExternalScope && var->type->kind==ptxIncompleteArrayType) ),
                           (ptxMsgConstBankReserved,var->sourcePos,NUM_LOGICAL_CONST_BANKS) );
    }

    // module-scoped .reg and .local variables are illegal when compiling with ABI for PTX 3.0 or later
    // ABI compilation is disabled for legacy PTX containing module-scoped .reg or .local variables

    // FIXME : Emit this error only for offline compilation but not in JIT compilation for optix use case(bug 1024026).
    //         CompileProgram() issues warning for turning off ABI due to use to module-scoped .reg and .local. 
    //         Change this to error again once a proper way is implemented to pass options to JIT ptxas.
    if (atModuleScope(gblState) && (gblState->parseData->lwrStorageClass.kind==ptxRegStorage || gblState->parseData->lwrStorageClass.kind==ptxLocalStorage) ) {
#ifndef GPGPUCOMP_DRV_BUILD
        if (ptxVersionAtLeast(3,0, gblState)) {
#else
        if (False) {
#endif
            stdCHECK_WITH_POS( gblState->parseData->lwrStorageClass.kind != ptxRegStorage,   (ptxMsgModuleScopeWithABI,var->sourcePos,".reg") );
            stdCHECK_WITH_POS( gblState->parseData->lwrStorageClass.kind != ptxLocalStorage, (ptxMsgModuleScopeWithABI,var->sourcePos,".local") );
        } else {
            gblState->usesModuleScopedRegOrLocalVars = True;
            if (!gblState->moduleScopedRegOrLocalVarName) {
                gblState->moduleScopedRegOrLocalVarName = stdCOPYSTRING(varI->symbol->unMangledName);
            }
        }
    }

    // if variable has a numeric suffix, check to see if it's already implicitly defined as a parameterized variable in the same scope
    if (ptxIsParameterizedVariableName(var->unMangledName, &idx, &suffixStart)) {
        ptxSymbolTableEntry previous;
        ptxParamVarSaveRec save;

        ptxGetParameterizedVariableName(var->unMangledName, suffixStart, &save);
        previous = ptxLookupSymbol(  gblState->lwrSymbolTable, var->unMangledName, False, gblState );
        ptxRestoreParameterizedVariableName(var->unMangledName, suffixStart, &save);

        stdCHECK_WITH_POS( !(previous && previous->range > idx), (ptxMsgDuplicateVariable, var->sourcePos, var->unMangledName) );
    }

    // if defining a parameterized variable, check for predefined variables in the specified range in the same scope
    if (range) {
        stdString_t tmp = stringNEW(), base = stringNEW();
        uInt i;
        uInt len = strlen(var->unMangledName) - 1; 
        // get base of parameterized variable name (i.e., chop off '<' suffix)
        stdASSERT( var->unMangledName[len] == '<', ("Ill-formed parameterized variable") );
        stringAddBufLen(base, var->unMangledName, len);
        
        for (i=0; i<range; i++) {
            stringEmpty(tmp);
            stringAddString(tmp, base);
            stringAddFormat(tmp, "%d", i);
            stdCHECK_WITH_POS( ptxLookupSymbol( gblState->lwrSymbolTable, stringToBuf(tmp), False, gblState ) == NULL, (ptxMsgDuplicateVariable, var->sourcePos, stringToBuf(tmp)) );
        }
        stringDelete(tmp);
        stringDelete(base);
    }

    if (atModuleScope(gblState)) {
        ptxSymbolTableEntry previous= ptxLookupSymbol( gblState->lwrSymbolTable, var->unMangledName, True, gblState );

        if (previous) {
            stdCHECK_WITH_POS( previous->kind == ptxVariableSymbol
                               && typeResolve( &previous->symbol->type, &var->type ),
                              (ptxMsgInconsistentRedef, var->sourcePos, var->unMangledName)
            );

            previous->symbol->logAlignment= stdMAX( previous->symbol->logAlignment, gblState->parseData->lwrLogAlignment );

            if (previous->scope == ptxExternalScope) {
                stdCHECK_WITH_POS (gblState->parseData->lwrScope == ptxGlobalScope || gblState->parseData->lwrScope == ptxWeakScope || gblState->parseData->lwrScope == ptxCommonScope,   (ptxMsgMustBeGlobal, var->sourcePos, var->unMangledName) );
                previous->symbol = var;
                previous->scope  = gblState->parseData->lwrScope;
                previous->initialValue= initVal;
            } else {
                stdCHECK_WITH_POS (gblState->parseData->lwrScope == ptxExternalScope, (ptxMsgDuplicateVariable, var->sourcePos, var->unMangledName) );
            }
            goto finish;

        } else
        if (isOutermostScope(gblState->parseData->lwrScope)) {
            insertInto= gblState->globalSymbolTable;
        } else {
            insertInto= gblState->lwrSymbolTable;
        }
    } else {
        stdCHECK_WITH_POS( !isOutermostScope(gblState->parseData->lwrScope), (ptxMsgIllegalScope, var->sourcePos, var->unMangledName) );
        insertInto= gblState->lwrSymbolTable;
    }

    stdCHECK_WITH_POS(
         ptxAddVariableSymbol( insertInto, var, gblState->parseData->lwrScope, gblState->parseData->lwrStorageClass, initVal, range ),
         (ptxMsgDuplicateVariable, var->sourcePos, var->unMangledName)
    );

  finish:
    ptxSetVariableDebugInfo( var->unMangledName, gblState->lwrSymbolTable, gblState->parseData->lwrScope, gblState->parseData->lwrStorageClass, gblState );

    // OPTIX_HAND_EDIT - remove unused use of arch
    //sscanf(globalState->gpuInfo->profileName, "%*[^0-9]%d", &arch);
}

// TODO: Probably combine these checks as part of checkParamsUsingAllocNo
static void checkNoIncompleteParamForEntry(ptxParsingState gblState, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(!gblState->parseData->sawIncompleteParam,
                      (ptxMsgNoIncompleteArray, sourcePos,
                       "Parameter to entry function"));
}

static void checkNoIncompleteParamAtOutput(ptxParsingState gblState, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(!gblState->parseData->sawIncompleteParam,
                      (ptxMsgNoIncompleteArray, sourcePos,
                       "Output parameter"));
}

static void checkIncompleteParam(ptxParsingState gblState, ptxType type, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(!gblState->parseData->sawIncompleteParam,
                      (ptxMsgIncompleteArrayIsLastInput, sourcePos));

    if (type->kind == ptxIncompleteArrayType) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
        const char name[] = "Unsized Array Parameter";

        stdCHECK_WITH_POS(checkTargetArch(gblState, 30), (ptxMsgFeatureRequiresSMVersion,
                                                sourcePos, name,"sm_30"));
        checkFeatureVersion(gblState, 6, 0, name, sourcePos);

        stdCHECK_WITH_POS(gblState->parseData->lwrStorageClass.kind == ptxParamStorage,
                          (ptxMsgIlwalidStorage, sourcePos,
                          "Incomplete array parameters", ".param"));

        gblState->parseData->sawIncompleteParam = True;
#else
        stdCHECK_WITH_POS(False, (ptxMsgParsingError, sourcePos,
                                  "[]", "syntax error"));
#endif
    }
}

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void matchScratchRegs(stdList_t prevScratchRegs, stdList_t scratchRegs,
                             String name, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(listSize(prevScratchRegs) == listSize(scratchRegs),
                      (ptxMsgFunctionArgsDiffer, sourcePos, name,
                      "number of scratch registers"));

    while (prevScratchRegs && scratchRegs) {
        uInt64 s1 = (uInt64)(Address)prevScratchRegs->head;
        uInt64 s2 = (uInt64)(Address)scratchRegs->head;

        stdCHECK_WITH_POS(s1 == s2, (ptxMsgFunctionArgsDiffer, sourcePos,
                                     name, "scratch registers"));

        prevScratchRegs = prevScratchRegs->tail;
        scratchRegs = scratchRegs->tail;
    }
}
#endif

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)

// TODO: Common out matchAliasPrototypes and matchParams
//       into a generic and yet easily maintainable code
static void matchAliasPrototypes(stdList_t l, stdList_t m,
                                 ptxSymbolTableEntry aliasSym,
                                 ptxSymbolTableEntry aliaseeSym,
                                 msgSourcePos_t sourcePos)
{
    String alias   = aliasSym->symbol->name;
    String aliasee = aliaseeSym->symbol->name;

    stdCHECK_WITH_POS(listSize(l) == listSize(m),
                      (ptxMsgAliasPrototypeMismatch, sourcePos, alias, aliasee,
                       "number of parameters"));

    while (l && m) {
        ptxVariableInfo s1 = l->head;
        ptxVariableInfo s2 = m->head;
        ptxSymbol       p1 = s1->symbol;
        ptxSymbol       p2 = s2->symbol;
        Bool            typeMatchCheck = False;
        Bool            isLastParam    = (l->tail == NULL);
        Bool            relaxArraySizeCheck = isLastParam &&
                                             ((aliaseeSym->aux->funcProtoAttrInfo->numAbiParamRegs > 0) ||
                                              (aliasSym->aux->funcProtoAttrInfo->numAbiParamRegs   > 0));

        if (relaxArraySizeCheck && isArray(p1->type) && isArray(p2->type)) {
            // alias's Array.N <= aliasee's Array.N
            typeMatchCheck = (p1->type->cases.Array.base == p2->type->cases.Array.base) &&
                             (p1->type->cases.Array.N    <= p2->type->cases.Array.N);
        } else {
            typeMatchCheck = (p1->type == p2->type);
        }
        stdCHECK_WITH_POS(typeMatchCheck,
                          (ptxMsgAliasPrototypeMismatch, sourcePos, alias, aliasee,
                          "parameter types"));

        stdCHECK_WITH_POS(p1->logAlignment == p2->logAlignment,
                          (ptxMsgAliasPrototypeMismatch, sourcePos, alias, aliasee,
                          "parameter alignment"));
        stdCHECK_WITH_POS(s1->storage.kind == s2->storage.kind,
                          (ptxMsgAliasPrototypeMismatch, sourcePos, alias, aliasee,
                          "parameter state space"));
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        stdCHECK_WITH_POS(s1->allocno == s2->allocno,
                          (ptxMsgAliasPrototypeMismatch, sourcePos, alias, aliasee,
                          "parameter allocno"));
#endif

        l = l->tail;
        m = m->tail;
    }
}

#endif

static void matchParams(stdList_t l, stdList_t m, String name,
                        msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(listSize(l) == listSize(m),
                      (ptxMsgFunctionArgsDiffer, sourcePos, name,
                       "number of parameters"));

    while (l && m) {
        ptxVariableInfo s1 = l->head;
        ptxVariableInfo s2 = m->head;
        ptxSymbol       p1 = s1->symbol;
        ptxSymbol       p2 = s2->symbol;

        stdCHECK_WITH_POS(p1->type == p2->type, (ptxMsgFunctionArgsDiffer,
                          sourcePos, name, "parameter types"));
        stdCHECK_WITH_POS(p1->logAlignment == p2->logAlignment,
                          (ptxMsgFunctionArgsDiffer, sourcePos, name,
                          "parameter alignment"));
        stdCHECK_WITH_POS(s1->storage.kind == s2->storage.kind,
                          (ptxMsgFunctionArgsDiffer, sourcePos, name,
                          "parameter state space"));
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        stdCHECK_WITH_POS(s1->allocno == s2->allocno,
                          (ptxMsgFunctionArgsDiffer, sourcePos, name,
                          "parameter allocno"));
#endif

        l = l->tail;
        m = m->tail;
    }
}

typedef struct {
    msgSourcePos_t sourcePos;
    stdBitSet_t usedRegs;
    Bool isMulRetAllReg;
    Bool scanningRetParams;
    Bool isAnyUsingAllocNo;
    Bool areAllUsingAllocNo;
    stdMap_t* deobfuscatedStrMap;
} deviceFuncArgInfo;

static void checkParamsUsingAllocNo(ptxVariableInfo VarI,
                                    deviceFuncArgInfo *pinfo)
{
    int i, usedReg, totalRegs;
    pinfo->isAnyUsingAllocNo  |= (VarI->allocno >= 0);
    pinfo->areAllUsingAllocNo &= (VarI->allocno >= 0);

    if (VarI->allocno >= 0) {
        stdASSERT(!isArray(VarI->symbol->type), ("Datatype Array not expected"));
        // Check if unaligned allocno is specified
        if (VarI->allocno % ((int) ptxGetTypeSizeInBytes(VarI->symbol->type) / 4)) {
            String s;
            stdString_t typeName = stringNEW();

            ptxPrintType(pinfo->deobfuscatedStrMap, VarI->symbol->type, typeName);
            s = stringStripToBuf(typeName);

            stdCHECK_WITH_POS(False, (ptxMsgUnalignedAllocNo, pinfo->sourcePos,
                                      VarI->symbol->name, VarI->allocno, s));
            stdFREE(s);
        }
        stdASSERT(!isArray(VarI->symbol->type), ("Datatype Array not expected"));
        // Check for overlapping allocno
        totalRegs = (int) ptxGetTypeSizeInBytes(VarI->symbol->type) / 4;
        usedReg = VarI->allocno;
        for (i = 0; i < totalRegs; ++i, ++usedReg) {
            Bool alreadyUsed = bitSetInsert(pinfo->usedRegs, usedReg);

            stdCHECK_WITH_POS(!alreadyUsed, (ptxMsgOverlappedAllocno,
                              pinfo->sourcePos, VarI->symbol->name,
                              usedReg));
        }
    }
}

static void checkParam(ptxVariableInfo VarI, deviceFuncArgInfo *pinfo)
{
    if (pinfo->scanningRetParams) {
        pinfo->isMulRetAllReg &= (VarI->storage.kind == ptxRegStorage);
    }
    checkParamsUsingAllocNo(VarI, pinfo);
}

static deviceFuncArgInfo* getDeviceFuncArgInfo(ptxParsingState gblState, String name, stdList_t fparams,
                                               stdList_t rparams, Bool allowMultipleReturn,
                                               msgSourcePos_t sourcePos)
{
    deviceFuncArgInfo *pinfo;
    Bool reqMulRetCheck;

    // check function with multiple return values
    reqMulRetCheck = (listSize(rparams) > 1);

    stdNEW(pinfo);
    pinfo->sourcePos          = sourcePos;
    pinfo->isAnyUsingAllocNo  = False;
    pinfo->areAllUsingAllocNo = True;
    pinfo->isMulRetAllReg     = reqMulRetCheck;

    pinfo->usedRegs           = bitSetCreate();
    pinfo->scanningRetParams  = True;
    pinfo->deobfuscatedStrMap           = gblState->parseData->deobfuscatedStringMapPtr;
    listTraverse(rparams, (stdEltFun)checkParam, pinfo);
    bitSetDelete(pinfo->usedRegs);

    pinfo->usedRegs           = bitSetCreate();
    pinfo->scanningRetParams  = False;
    listTraverse(fparams, (stdEltFun)checkParam, pinfo);
    bitSetDelete(pinfo->usedRegs);

    // Check if any parameter uses .allocno then all parameters have .allocno
    stdCHECK_WITH_POS(stdIMPLIES(pinfo->isAnyUsingAllocNo,
                                 pinfo->areAllUsingAllocNo),
                     (ptxMsgFunctionArgsAllOrNoAllocNo, sourcePos, name));

    allowMultipleReturn |= pinfo->areAllUsingAllocNo;

    if (reqMulRetCheck) {
        // check if function has multiple returns all are in reg storage
        stdCHECK_WITH_POS(pinfo->isMulRetAllReg,
                        (ptxMsgMultiReturnMustBeRegister,sourcePos) );

        // Set state that program has function with multiple return parameters.
        // This is used to disable ABI. However if encountered function with
        // multiple parameters but all are using .allocno then don't set this
        // state since function will be compiled through lwstomABI
        if (name && !allowMultipleReturn) {
            gblState->usesFuncWithMultipleRets = True;
            if (!gblState->funcWithMultipleRetsName) {
                gblState->funcWithMultipleRetsName = stdCOPYSTRING(name);
            }
        }
    }
    return pinfo;
}

static void initExtendedPrototype(ptxParsingState gblState, ptxSymbolTableEntry lwrFunc, String name)
{
    if (IsMacroFunc(name, gblState))
        return;

    // abi_param_reg :
    if (gblState->parseData->moduleScopeNumAbiParamReg != UNSPECIFIED_ABI_PARAM_REGS) {
        lwrFunc->aux->funcProtoAttrInfo->numAbiParamRegs = gblState->parseData->moduleScopeNumAbiParamReg;
        gblState->parseData->moduleScopeNumAbiParamReg = UNSPECIFIED_ABI_PARAM_REGS; // reset for next .pragma abi_param_reg
    }
    if (gblState->parseData->moduleScopeFirstParamReg != UNSPECIFIED_ABI_REG) {
        lwrFunc->aux->funcProtoAttrInfo->firstParamReg = gblState->parseData->moduleScopeFirstParamReg;
        gblState->parseData->moduleScopeFirstParamReg = UNSPECIFIED_ABI_REG; // reset for next .pragma abi_param_reg
    }

    // retaddr_reg_before_param_reg :
    if (gblState->parseData->moduleScopeRetAddrBeforeParams != UNSPECIFIED_RET_ADDR_BEFORE_PARAMS) {
        lwrFunc->aux->funcProtoAttrInfo->retAddrBeforeParams = gblState->parseData->moduleScopeRetAddrBeforeParams;
    } else {
        lwrFunc->aux->funcProtoAttrInfo->retAddrBeforeParams = 0; // set to 0 if havent seen pragma so far
    }
    gblState->parseData->moduleScopeRetAddrBeforeParams = UNSPECIFIED_RET_ADDR_BEFORE_PARAMS; // reset for next .pragma retaddr_reg_before_param_reg

    // retaddr_reg :
    if (gblState->parseData->moduleScopeRetAddrReg != UNSPECIFIED_ABI_REG) {
        lwrFunc->aux->funcProtoAttrInfo->retAddrReg = gblState->parseData->moduleScopeRetAddrReg;
        gblState->parseData->moduleScopeRetAddrReg = UNSPECIFIED_ABI_REG;
    }
    if (gblState->parseData->moduleScopeRetAddrUReg != UNSPECIFIED_ABI_REG) {
        lwrFunc->aux->funcProtoAttrInfo->retAddrUReg = gblState->parseData->moduleScopeRetAddrUReg;
        gblState->parseData->moduleScopeRetAddrUReg = UNSPECIFIED_ABI_REG;
    }
    if (gblState->parseData->moduleScopeRelRetAddrReg != UNSPECIFIED_ABI_REG) {
        lwrFunc->aux->funcProtoAttrInfo->relRetAddrReg = gblState->parseData->moduleScopeRelRetAddrReg;
        gblState->parseData->moduleScopeRelRetAddrReg = UNSPECIFIED_ABI_REG;
    }

    // scratch_regs :
    if (gblState->parseData->moduleScopeScratchRRegs != UNSPECIFIED_ABI_REGS) {
        lwrFunc->aux->funcProtoAttrInfo->scratchRRegs = gblState->parseData->moduleScopeScratchRRegs;
        gblState->parseData->moduleScopeScratchRRegs = UNSPECIFIED_ABI_REGS;
    }

    if (gblState->parseData->moduleScopeScratchBRegs != UNSPECIFIED_ABI_REGS) {
        lwrFunc->aux->funcProtoAttrInfo->scratchBRegs = gblState->parseData->moduleScopeScratchBRegs;
        gblState->parseData->moduleScopeScratchBRegs = UNSPECIFIED_ABI_REGS;
    }

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    if (gblState->parseData->moduleScopeCoroutinePragma) {
        lwrFunc->aux->funcProtoAttrInfo->isCoroutine  = gblState->parseData->moduleScopeCoroutinePragma;
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_COMPUTE_COMPILER_INTERNAL)
        ptxSetNonMercFeatureUsed(gblState, ptxCoroutine);
#endif
        gblState->parseData->moduleScopeCoroutinePragma = False;
    }
#endif
}

static ptxSymbolTableEntry declFunction(ptxParsingState gblState, ptxDeclarationScope scope, String name,
                                        stdList_t rparams, stdList_t fparams,
                                        Bool isEntry, Bool isInlineFunc,
                                        stdList_t scratchRegs, int retAddrAllocno,
                                        Bool hasNoReturn, Bool isUnique,
                                        msgSourcePos_t sourcePos)
{
    ptxSymbolTable insertInto;
    Bool hasAllocatedParams = False;
    deviceFuncArgInfo *pinfo;
    ptxSymbolTableEntry lwrFunc;

    ptxType             type     = ptxCreateLabelType(gblState);
    ptxSymbol           fun      = ptxCreateSymbol(gblState, type, name, 0, 0, sourcePos );
    // note function declarations are always entered in objectSymbolTable or
    // globalSymbolTable so look up in objectSymbolTable(with inspectParent)
    // and not lwrSymbolTable
    ptxSymbolTableEntry previous = ptxLookupSymbol( gblState->objectSymbolTable, name, True, gblState );

    if (isEntry && fparams != NULL) checkFeatureVersion(gblState, 1, 4, "kernel parameter list", sourcePos);

    stdCHECK_WITH_POS (stdIMPLIES(isInlineFunc, !isPtxUserInput(msgGetFileName(sourcePos))),
                       (ptxMsgParsingError, sourcePos, ".FORCE_INLINE", "syntax error"));

    if (!isEntry) {
        pinfo = getDeviceFuncArgInfo(gblState, name, fparams, rparams, isInlineFunc, sourcePos);
        hasAllocatedParams = pinfo->isAnyUsingAllocNo && pinfo->areAllUsingAllocNo;
        stdFREE(pinfo);
    }

    if (previous) {
        stdCHECK_WITH_POS((previous->kind == ptxFunctionSymbol
                           && previous->symbol->type == type),
                           (ptxMsgInconsistentRedef, sourcePos, name))
        {
            stdCHECK_WITH_POS(previous->aux->isEntry == isEntry,
                              (ptxMsgEntryMismatch, sourcePos, name));
            stdCHECK_WITH_POS(previous->aux->body == NULL,
                              (ptxMsgDuplicateFunction, sourcePos, name));
            // allow missing '.visible' directive on subsequent function
            // declarations (analagous to C's rule for 'static')
            stdCHECK_WITH_POS((previous->scope == scope)
                               || (previous->scope == ptxGlobalScope
                                   && scope == ptxStaticScope)
                               || (previous->scope == ptxWeakScope
                                   && scope == ptxStaticScope),
                              (ptxMsgInconsistentRedef, sourcePos, name));
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_64)
            stdCHECK_WITH_POS(previous->aux->funcProtoAttrInfo->hasNoReturn == hasNoReturn,
                              (ptxMsgInconsistentRedef, sourcePos, name));
#endif

            // check parameters
            matchParams(previous->aux->funcProtoAttrInfo->rparams, rparams, name, sourcePos);
            matchParams(previous->aux->funcProtoAttrInfo->fparams, fparams, name, sourcePos);

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
            // check scratch registers
            matchScratchRegs(previous->aux->funcProtoAttrInfo->scratchRegs, scratchRegs, name,
                             sourcePos);
            // check return address allocno
            stdCHECK_WITH_POS(previous->aux->funcProtoAttrInfo->retAddrAllocno == retAddrAllocno,
                              (ptxMsgFunctionArgsDiffer, sourcePos, name,
                               "retaddr_allocno"));

#endif
            // update symtab entry with current parameter names, if previous
            // prototype exists
            previous->aux->funcProtoAttrInfo->rparams = rparams;
            previous->aux->funcProtoAttrInfo->fparams = fparams;

            return previous;
        }
    }

    if (isOutermostScope(scope)) {
        insertInto= gblState->globalSymbolTable;
    } else {
        // Function declarations of static scope even if appear in local scope
        // are added in objectSymbolTable to ensure all instances of function
        // declarations appear in different local scopes resolve to same
        // instance.
        insertInto= gblState->objectSymbolTable;
    }

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_64)
    if (hasNoReturn) {
        stdCHECK_WITH_POS(rparams == NULL, (ptxMsgIlwalidDirective, sourcePos,
                                           ".noreturn", name));
        stdASSERT(!isEntry, ("Entry function not expected"));
    }
#endif

    if (isUnique) {
        stdCHECK_WITH_POS(IsMacroFunc(name, gblState) , (ptxMsgParsingError, sourcePos,
                         ".unique", "syntax error"));
        stdCHECK_WITH_POS(scope == ptxWeakScope, (ptxMsgDirectiveUnsupportedScope,
                          sourcePos, ".unique", getORDERAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxWEAK_MOD)));
    }

    stdCHECK_WITH_POS(
        ptxAddFunctionSymbol( insertInto, fun, isEntry, isInlineFunc, scope,
                              NULL, rparams, fparams, hasAllocatedParams,
                              hasNoReturn, isUnique, retAddrAllocno, scratchRegs ),
        (ptxMsgDuplicateFunction, sourcePos, name)
    );

    if (isEntry && scope != ptxExternalScope) {
        listAddTo((Pointer)(Address)fun->index, &gblState->entryPointsIndicies);
    }

    lwrFunc = ptxLookupSymbol( gblState->lwrSymbolTable, name, True, gblState );
#if 0
    // OPTIX_HAND_EDIT - we don't need to call this, since we disabled all the prototypes,
    // and we haven't initialized the macroUtilFuncMapFermi map with
    // initMacroUtilFuncMapFermi.
    initExtendedPrototype( gblState, lwrFunc, name );
#endif

    return lwrFunc;
}

static void initializeRandomGenerationSeed (ptxParsingState gblState, ptxSymbolTableEntry fn)
{
    if (gblState->generatePrefetchSizeSeed != 0) {
        // If seed for random generation of prefetch size is specified, salt it
        // with function name checksum and initialize srand using the new seed.
        unsigned int seed = gblState->generatePrefetchSizeSeed;
        unsigned long adler = adler32(0L, NULL, 0); // Initialize checksum
        int  funcNameLen = strlen(fn->symbol->unMangledName);
        adler = adler32(adler, (Byte*)fn->symbol->unMangledName, funcNameLen); // Callwlate the actual checksum
        seed += (unsigned int)(adler % 65535); // Salt the seed with checksum
        srand(seed);
    }
}

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)

static void checkVersionTargetForAlias(ptxParsingState gblState, msgSourcePos_t sourcePos)
{
    checkFeatureVersion(gblState, 6, 3, ".alias", sourcePos);
    checkFeatureTarget(gblState, 30,   ".alias", sourcePos);
}

static void checkAliasSymbolDefinition(ptxSymbolTableEntry alias,
                                       ptxSymbolTableEntry aliasee,
                                       msgSourcePos_t aliasPos,
                                       msgSourcePos_t aliaseePos)
{
    String aliasName   = alias->symbol->name;
    String aliaseeName = aliasee->symbol->name;

    stdCHECK_WITH_POS(alias->aux->body == NULL,
                      (ptxMsgAliasFunctionDefined, aliasPos, aliasName));

    stdCHECK_WITH_POS(alias->aux->isEntry == False,
                      (ptxMsgAliasToEntryFunction, aliasPos, aliasName));

    stdCHECK_WITH_POS(aliasee->aux->isEntry == False,
                      (ptxMsgAliasToEntryFunction, aliaseePos, aliaseeName));
}

static void checkAliasSymbolReDefinition(ptxSymbolTableEntry alias,
                                         msgSourcePos_t aliasPos,
                                         msgSourcePos_t aliaseePos)
{
    String aliasName   = alias->symbol->name;

    if (alias->aux->aliasee != NULL) {
        ptxSymbolTableEntry originalAliasee = alias->aux->aliasee;
        stdCHECK_WITH_POS(False, (ptxMsgReAliasingNotAllowed, aliaseePos,
                                  aliasName, originalAliasee->symbol->name));
    }
}

static void checkSelfAliasing(ptxSymbolTableEntry alias,
                              ptxSymbolTableEntry aliasee,
                              msgSourcePos_t aliasPos)
{
    String aliasName   = alias->symbol->name;
    String aliaseeName = aliasee->symbol->name;

    stdCHECK_WITH_POS(!stdEQSTRING(aliasName, aliaseeName),
                      (ptxMsgAliasToSelf, aliasPos));
}

static void checkPrototypeCompatibilty(ptxSymbolTableEntry alias,
                                       ptxSymbolTableEntry aliasee,
                                       msgSourcePos_t sourcePos)
{
    matchAliasPrototypes(alias->aux->funcProtoAttrInfo->fparams,   aliasee->aux->funcProtoAttrInfo->fparams,
                         alias, aliasee, sourcePos);
    matchAliasPrototypes(alias->aux->funcProtoAttrInfo->rparams,   aliasee->aux->funcProtoAttrInfo->rparams,
                         alias, aliasee, sourcePos);

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_64)
    stdCHECK_WITH_POS(aliasee->aux->funcProtoAttrInfo->hasNoReturn == alias->aux->funcProtoAttrInfo->hasNoReturn,
                      (ptxMsgAliasPrototypeMismatch, sourcePos,
                       alias->symbol->name, aliasee->symbol->name, ".noreturn directive"));
#endif

}

static void checkAliaseeScopes(ptxParsingState gblState, ptxSymbolTableEntry aliasee,
                               msgSourcePos_t aliaseePos)
{
    String aliasName   = aliasee->symbol->name;

    stdCHECK_WITH_POS( aliasee->scope != ptxWeakScope,
                       (ptxMsgIlwalidAliaseeScope, aliaseePos,
                        aliasName, getORDERAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxWEAK_MOD)));

    stdCHECK_WITH_POS( aliasee->scope != ptxExternalScope,
                       (ptxMsgIlwalidAliaseeScope, aliaseePos,
                        aliasName, ".extern"));
}

static Bool checkAliasSymbolValidity(ptxSymbolTableEntry alias,
                                     ptxSymbolTableEntry aliasee,
                                     msgSourcePos_t aliasPos,
                                     msgSourcePos_t aliaseePos)
{
    String aliasName   = alias->symbol->name;
    String aliaseeName = aliasee->symbol->name;
    Bool   isAliasFuncSymbol   = alias->kind   == ptxFunctionSymbol;
    Bool   isAliaseeFuncSymbol = aliasee->kind == ptxFunctionSymbol;

    stdCHECK_WITH_POS (isAliasFuncSymbol,
                       (ptxMsgAliasToNonFunctions, aliasPos, aliasName));
    stdCHECK_WITH_POS (isAliaseeFuncSymbol,
                       (ptxMsgAliasToNonFunctions, aliaseePos, aliaseeName));

    return !isAliasFuncSymbol || !isAliaseeFuncSymbol;  // is error found ?
}

#endif

static void defineAlias(ptxParsingState gblState, String aliasName,   msgSourcePos_t aliasPos,
                        String aliaseeName, msgSourcePos_t aliaseePos,
                        msgSourcePos_t  sourcePos)
{
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    ptxSymbolTableEntry alias;
    ptxSymbolTableEntry aliasee;

    checkVersionTargetForAlias(gblState, sourcePos);
    alias   = ptxLookupSymbol(gblState->lwrSymbolTable, aliasName, True, gblState);
    aliasee = ptxLookupSymbol(gblState->lwrSymbolTable, aliaseeName, True, gblState);

    if (!alias) {
        stdCHECK_WITH_POS(False, (ptxMsgUnknownSymbol, aliasPos,   aliasName)  );
        return;
    }
    if (!aliasee) {
        stdCHECK_WITH_POS(False, (ptxMsgUnknownSymbol, aliaseePos, aliaseeName));
        return;
    }

    if (checkAliasSymbolValidity (alias, aliasee, aliasPos, aliaseePos))
        return;

    checkAliasSymbolDefinition  (alias, aliasee, aliasPos, aliaseePos);
    checkAliasSymbolReDefinition(alias, aliasPos, aliaseePos);
    checkSelfAliasing(alias, aliasee, aliasPos);
    checkPrototypeCompatibilty(alias, aliasee, sourcePos);
    checkAliaseeScopes(gblState, aliasee, aliaseePos);

    alias->aux->aliasee = aliasee;
#else
    stdCHECK_WITH_POS(False, (ptxMsgParsingError, sourcePos,
                              ".alias", "syntax error"));
#endif
}

static void defineFunction(ptxParsingState gblState,  ptxSymbolTableEntry fn, ptxSymbolTable body, msgSourcePos_t startPos, msgSourcePos_t sourcePos )
{
    stdCHECK_WITH_POS( fn->scope != ptxExternalScope, (ptxMsgIllegalExternFunction,sourcePos,fn->symbol->unMangledName) );

    fn->aux->body     = body;
    fn->aux->mbodyPos = sourcePos;
    fn->aux->startPos = startPos;
    ptxSetUniqueFuncIndex(fn, gblState);


    setSourceLocForPrologue(gblState, startPos, sourcePos,  gblState->parseData->prologueSourceLocation);

    insertPtxToSourceMapRecord(gblState); // insert record of ptxline To sourceline from last .LOC to end of function
    // Reset source code location for next entry/device function
    gblState->parseData->lwrSourceCodeLocation->lwrLoc.fileIndex = 0;
    gblState->parseData->lwrSourceCodeLocation->lwrLoc.lineNo    = 0;
    gblState->parseData->lwrSourceCodeLocation->lwrLoc.linePos   = 0;
    gblState->parseData->lwrSourceCodeLocation->functionName     = NULL;
    gblState->parseData->lwrSourceCodeLocation->inlineAtLoc      = NULL;
    gblState->parseData->prologueSourceLocation = NULL;
    gblState->parseData->nextSourceCodeLocation = NULL;
}


static ptxSymbolTableEntry defineLabel(ptxParsingState gblState,  String name, Bool reservePadding, msgSourcePos_t sourcePos, Bool IsSourceCodeLocNeeded )
{
    Pointer locMapKey;
    stdCHECK_WITH_POS(
          ptxAddLabelSymbol( gblState->lwrSymbolTable, ptxCreateSymbol(gblState, ptxCreateLabelType(gblState), name, 0, 0, sourcePos ) ),
          (ptxMsgDuplicateLabel, sourcePos, name)
    );

    if (gblState->ptxDebugInfo && isPtxUserInput(msgGetFileName(sourcePos)) && IsSourceCodeLocNeeded) {
        // allocate a new source code location for label, which will be later assigned with the location of its associated instruction
        if (gblState->parseData->nextSourceCodeLocation == NULL) {
            stdNEW(gblState->parseData->nextSourceCodeLocation);
        }
        mapDefine(gblState->ptxToSourceLine.labelMap, (void*)(uintptr_t)sourcePos->lineNo, gblState->parseData->nextSourceCodeLocation);
        locMapKey = ptxCreateKeyFromLoc(gblState->parseData->nextSourceCodeLocation->lwrLoc.fileIndex,
                                        gblState->parseData->nextSourceCodeLocation->lwrLoc.lineNo,
                                        gblState->parseData->nextSourceCodeLocation->lwrLoc.linePos);
        mapDefine(gblState->ptxToSourceLine.inlinedLocMap, locMapKey,
                  gblState->parseData->nextSourceCodeLocation);
    }

    return ptxLookupSymbol(gblState->lwrSymbolTable, name, True, gblState);
}


static void defineVars( stdList_t vars, Bool isParam, ptxParsingState gblState)
{
    LIST_TRAVERSE_MULTI_ARGS( vars, defineVar, &isParam, gblState);
}

static void defineParams( ptxSymbolTableEntry fun, ptxParsingState gblState)
{
    defineVars(fun->aux->funcProtoAttrInfo->rparams, True,  gblState);
    defineVars(fun->aux->funcProtoAttrInfo->fparams, True,  gblState);
}

static ptxSymbolTable pushSymbolTable(ptxParsingState gblState)
{
    gblState->lwrSymbolTable= ptxCreateSymbolTable(gblState->lwrSymbolTable);
    return gblState->lwrSymbolTable;
}

// Resolve pending references to labels declared in the current
// statement block.
//
// When the parser exits a statement block, the labels declared inside
// the block will go out of scope. This is the last opportunity to
// resolve label references that point to such labels. Any remaining
// labels are carried forward, to be resolved against the parent block.
static void resolveLabels(ptxParsingState gblState, ptxSymbolTable T)
{
    stdList_t iter;

    stdASSERT(T != gblState->globalSymbolTable, ("global symbol table is never popped"));
    if (T == gblState->objectSymbolTable) return;

    for (iter = T->LabelRefSeq; iter; iter = iter->tail) {
        ptxExpression L = (ptxExpression)iter->head;
        ptxSymbolTableEntry result;

        stdASSERT(L->kind == ptxLabelReferenceExpression,
                  ("Label reference expression expected"));

        result = ptxLookupSymbol(T, L->cases.LabelReference->name,
                                 /* inspectParent = */ True, gblState);

        if (!result) {
            // If we popped a function, then report the unresolved
            // label reference, else propagate it to the parent scope.
            if (T->parent == gblState->objectSymbolTable) {
                msgReportWithPos(ptxMsgUnknownSymbol,
                                 L->cases.LabelReference->sourcePos,
                                 L->cases.LabelReference->name);
            } else {
                listXPutAfter(T->parent->LabelRefSeq, L);
            }
            continue;
        }

        stdCHECK_WITH_POS(result->kind == ptxLabelSymbol,
                          (ptxMsgIllegalLabelReference,
                           L->cases.LabelReference->sourcePos,
                           L->cases.LabelReference->name));

        ptxInitSymbolExpr(L, result);
    }

    listDelete(T->LabelRefSeq);
    listXInit(T->LabelRefSeq);
}

// Initialize statement count from parent.
//
// Statements encountered in the current statement block will be
// appended to the list of statements in the parents. So we initialize
// the current block with the statement count in the parent.
static void initializeNumStatements(ptxParsingState gblState, ptxSymbolTable T)
{
    stdASSERT(T->parent != gblState->objectSymbolTable,
              ("should not be called when starting a function body"));
    T->numStmts = T->parent->numStmts;
}


static void resetSymbolTablePtr(ptxSymbolTableEntry s, Pointer ignored)
{
    s->symbtab = NULL;
}

// Merge into parent block when exiting a statement block.
//
// When the parser finishes parsing the current statement block, all
// the parsed information is forwarded to the parent, and the block
// itself disappears from the IR.
static void consumeSymbolTable(ptxParsingState gblState, ptxSymbolTable T)
{
    stdASSERT(T->parent != gblState->objectSymbolTable,
              ("should not be called when exiting a function body"));

    stdASSERT(mapSize(T->opaques) == 0,
              ("opaque types cannot be declared inside a statement block"));
    mapDelete(T->opaques);

    // Each symbol contains a pointer to its parent table. But once a
    // statement block is exited, this information is not
    // useable. Hence we reset the pointer, which ensures that there
    // are no dangling pointers when we delete the block from the IR.
    mapRangeTraverse(T->symbolIndexMap, (stdEltFun)resetSymbolTablePtr, NULL);

    // Once a statement block is finished, there is no situation where
    // a symbol declared in that block needs to be looked up by
    // name. So we can safely reset the mapping of symbol names to
    // symbol entries.
    mapDelete(T->symbolIndexMap);

    listXConcat(T->parent->LabelSeq, T->LabelSeq);
    listXConcat(T->parent->VariableSeq, T->VariableSeq);
    listXConcat(T->parent->FunctionSeq, T->FunctionSeq);
    listXConcat(T->parent->MarkerSeq, T->MarkerSeq);
    listXConcat(T->parent->MacroSeq, T->MacroSeq);

    listXConcat(T->parent->statements, T->statements);
    T->parent->numStmts = T->numStmts;

    stdASSERT(!T->data, ("statement blocks never use this pointer"));

    stdFREE(T);
}

static ptxSymbolTable popSymbolTable(ptxParsingState gblState)
{
    ptxSymbolTable result;

    resolveLabels(gblState, gblState->lwrSymbolTable);

    // Appending variables to be promoted from lwrSymbolTable to objectSymbolTable's VariableSeq
    listXConcat(gblState->objectSymbolTable->VariableSeq, gblState->lwrSymbolTable->VariablesToPromoteSeq);

    result         = gblState->lwrSymbolTable;
    gblState->lwrSymbolTable = gblState->lwrSymbolTable->parent;

    // reset macro parsing flags when going back to user scope
    if (ptxIsExpandedInternally(gblState->lwrInstrSrc) && gblState->parseData->lastUserSymbolTable == gblState->lwrSymbolTable) {
        gblState->parseData->lastUserSymbolTable = NULL;
        gblState->lwrInstrSrc         = UserPTX;
    }

    return result;
}


/*------------------------ Initialization, Termination -----------------------*/

static void initializeMacros(ptxParsingState gblState);
static void setIsLastSeelwectorType(ptxParsingState gblState, Bool seen);

static void initInstrParseState(ptxParsingState gblState);

static void initObject(ptxParsingState gblState)
{
    initInstrParseState(gblState);

    stdNEW(gblState->parseData->lwrSourceCodeLocation);
    gblState->parseData->nextSourceCodeLocation = NULL;
    gblState->parseData->lastInstrSourcePos     =   -1;
    gblState->parseData->firstInstrSourcePos    =   -1;
    gblState->parseData->lwrPtxDwarfSection     = NULL;
    gblState->parseData->lwrPtxDwarfLine        = NULL;
    gblState->parseData->prologueSourceLocation = NULL;

    gblState->parseData->lwrFunc              = NULL;
    gblState->parseData->lwrIsEntry           = False;
    gblState->parseData->isInlineFunc = False;
    gblState->parseData->lwrIsPrototype       = False;
    gblState->lwrSymbolTable = gblState->globalSymbolTable;
    gblState->objectSymbolTable = pushSymbolTable(gblState);
    gblState->parsingParameters = False;
    setIsLastSeelwectorType(gblState, False);
    gblState->parseData->parsingDwarfData     = False;
    gblState->parseData->noSyncWarningEmitted = False;

    initializeMacros(gblState);
}

static ptxSymbolTableEntry createMarkerEntry(ptxParsingState gblState,  ptxStorageKind s )
{
    ptxSymbolTableEntry result;

    stdNEW(result);

    result->kind           = ptxMarkerSymbol;
    result->virtualAddress = gblState->virtualSize[s];

    return result;
}


static void termObject(ptxParsingState gblState)
{
    ptxStorageKind  s;

    stdFREE(gblState->parseData->lwrSourceCodeLocation);
    gblState->parseData->firstInstrSourcePos    =   -1;
    gblState->parseData->lastInstrSourcePos     =   -1;
    gblState->parseData->lwrSourceCodeLocation  = NULL;
    gblState->parseData->nextSourceCodeLocation = NULL;
    gblState->parseData->lwrPtxDwarfSection     = NULL;
    gblState->parseData->lwrPtxDwarfLine        = NULL;
    gblState->parseData->prologueSourceLocation = NULL;

    if (gblState->enablePtxDebug) {
        stdCHECK(gblState->foundDebugInfo, (ptxMsgNoDebugInfo));
    }

    for (s=0; s<ptxMAXStorage; s++) {
        listXPutAfter(gblState->dwarfLocations[s].l, createMarkerEntry(gblState, s) );
    }
}


/*------------------------ Type Manipulation Functions -----------------------*/

static ptxType createArrayType(ptxParsingState gblState,  uInt64 N, ptxType base, msgSourcePos_t sourcePos )
{
    // OPEN64_ALIGNMENT_HACK:
    // CL#1594642 had introduced an assumption in ptxas that an extern
    // incomplete array type is always aligned at 16 bytes. That CL mentions
    // Open64 as the reason for this hack.
    //
    // But when an incomplete array is passed as a function parameter in .param
    // space, the default alignment is derived from the base type. So we pass a
    // zero instead of 16 (Open64 hack).
    uInt logAlignment = gblState->parsingParameters ? 0 : stdLOG2(16);

    stdCHECK_WITH_POS( ptxIsCompleteType(base), (ptxMsgIncompleteArrayType,sourcePos) );
    stdCHECK_WITH_POS( !isPRED(base), (ptxMsgPredTypeNotRegisterVar,sourcePos) );

    if (N == 0)  return ptxCreateIncompleteArrayType(base, logAlignment, gblState);
    else         return ptxCreateArrayType(N,base, gblState);
}


static ptxType createMultiDimArrayType(ptxParsingState gblState,  stdList_t indices, ptxType base, ptxInitializer initializer, msgSourcePos_t sourcePos )
{
    while (indices) {
        uInt64 N = (uInt64)(Address)indices->head;
        if (initializer && N == 0 && !indices->tail) {
            // only the last dimension can be implicit
            N = listSize(initializer->cases.Structured.list);
        }
        base = createArrayType(gblState,  N, base, sourcePos );
        indices = indices->tail;
    }
    return base;
}


static ptxType createVectorType(ptxParsingState gblState,  uInt N, ptxType base, msgSourcePos_t sourcePos )
{
    stdCHECK_WITH_POS( ptxIsBasicType(base), (ptxMsgBasicVectorType,sourcePos) );
    stdCHECK_WITH_POS( !isPRED(base), (ptxMsgPredTypeNotRegisterVar,sourcePos) );
    stdCHECK_WITH_POS( ((N * ptxGetTypeSizeInBytes(base)) <= 16), (ptxMsgVectorTypeTooLarge,sourcePos) );

    return ptxCreateVectorType(N,base, gblState);
}


/*------------------ Expression Validation and Construction ------------------*/

static void constCheckInt( ptxExpression a, msgSourcePos_t pos )
{
    stdCHECK_WITH_POS (a->kind == ptxIntConstantExpression, (ptxMsgIntConstantExpected,pos) );
}

static uInt cvtIntExprTouInt(ptxExpression a, msgSourcePos_t pos)
{
    constCheckInt(a, pos);

    stdCHECK_WITH_POS((a->cases.IntConstant.i <= 0xFFFFFFFF), (ptxMsgConstantOverflow,pos) );
    return (uInt)(a->cases.IntConstant.i & 0xFFFFFFFF);
}


static uInt64 cvtIntExprTouInt64(ptxExpression a, msgSourcePos_t pos)
{
    constCheckInt(a, pos);

    return (uInt64)(a->cases.IntConstant.i & 0xFFFFFFFFFFFFFFFF);
}

static ptxExpression constCast(ptxParsingState gblState,  ptxType t, ptxExpression a, msgSourcePos_t pos )
{
    ptxType s64 = ptxCreateIntType(64, True, gblState);
    ptxType u64 = ptxCreateIntType(64, False, gblState);

    constCheckInt(a, pos);
    stdCHECK_WITH_POS( (t==s64 || t==u64), (ptxMsgUnsupportedCast,pos) );

    return ptxCreateIntConstantExpr( a->cases.IntConstant.i, (t == s64), gblState);
}

static ptxExpression constUnaryExpr(ptxParsingState gblState,  ptxOperator op, ptxExpression a, msgSourcePos_t pos )
{
    switch (op) {
    case ptxADDOp :
        return a;

    case ptxSUBOp :
        if (a->kind == ptxIntConstantExpression) 
            return ptxCreateIntConstantExpr( -(a->cases.IntConstant.i), isSignedInt(a->type), gblState);
        else if (a->kind == ptxFloatConstantExpression)
            return ptxCreateF64FloatConstantExpr( -(ptxGetF64FloatConstantExpr(a)), gblState);
        else
            stdASSERT( False, ("Unexpected subexpression before unary minus") );

    case ptxNOTOp :
        constCheckInt(a, pos);
        return ptxCreateIntConstantExpr( (a->cases.IntConstant.i ? 0 : 1), True, gblState);

    case ptxILWOp :
        constCheckInt(a, pos);
        return ptxCreateIntConstantExpr( ~(a->cases.IntConstant.i), False, gblState);

    default       : stdASSERT( False, ("Unexpected binary operator") );
    }
    return NULL;
}

// The mask() operator extracts conselwtive bits described in mask from
// the operand used in initializers and inserts these bits into result
// staring from LSB.
#define RESOLVE_MASK_OPERATOR(mask, op) ((mask & op) >>  (stdFirstBit64(mask)))

static ptxExpression constMaskImmediateExpr(ptxParsingState gblState, uInt64 mask, ptxExpression imm, msgSourcePos_t pos)
{
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_72)
    // FIXME: Update feature version
    checkFeatureVersion(gblState, 7, 2, "Integer immediate in mask operator", pos);
    constCheckInt(imm, pos);
    if (imm->kind != ptxIntConstantExpression) {
        return imm;
    }
    return ptxCreateIntConstantExpr(RESOLVE_MASK_OPERATOR(mask, imm->cases.IntConstant.i),
                                    False, gblState);
#else
    stdCHECK_WITH_POS(False, (ptxMsgParsingError, pos, "(", "syntax error"));
#endif
}
#undef RESOLVE_MASK_OPERATOR

static ptxExpression constBinaryExpr(ptxParsingState gblState,  ptxOperator op, ptxExpression a, ptxExpression b, msgSourcePos_t pos )
{
    stdCHECK_WITH_POS( (a->kind == b->kind), (ptxMsgConstExprTypeMismatch,pos) );
    stdASSERT( a->kind == ptxIntConstantExpression || a->kind == ptxFloatConstantExpression, ("Unexpected subexpression of binary operator in constant expression") );

    switch (op) {
    //
    // Operators * and /
    //
    case ptxMULOp    :
        if (a->kind == ptxIntConstantExpression) {
            if (isSignedInt(a->type) && isSignedInt(b->type))
                return ptxCreateIntConstantExpr( ((Int64)a->cases.IntConstant.i * (Int64)b->cases.IntConstant.i), True, gblState );
            else
                return ptxCreateIntConstantExpr( ((uInt64)a->cases.IntConstant.i * (uInt64)b->cases.IntConstant.i), False, gblState);
        } else  return ptxCreateF64FloatConstantExpr( ptxGetF64FloatConstantExpr(a) * ptxGetF64FloatConstantExpr(b), gblState);
    case ptxDIVOp    :
        if (a->kind == ptxIntConstantExpression) {
            stdCHECK_WITH_POS( (b->cases.IntConstant.i != 0), (ptxMsgConstDivByZero,pos) );
            if (isSignedInt(a->type) && isSignedInt(b->type))
                return ptxCreateIntConstantExpr( ((Int64)a->cases.IntConstant.i / (Int64)b->cases.IntConstant.i), True, gblState );
            else
                return ptxCreateIntConstantExpr( ((uInt64)a->cases.IntConstant.i / (uInt64)b->cases.IntConstant.i), False, gblState);
        } else {
            stdCHECK_WITH_POS( (ptxGetF64FloatConstantExpr(b) != 0.0), (ptxMsgConstDivByZero,pos) );
            return ptxCreateF64FloatConstantExpr( ptxGetF64FloatConstantExpr(a) / ptxGetF64FloatConstantExpr(b), gblState);
        }

    //
    // Operator %
    //
    case ptxREMOp    :
        constCheckInt(a, pos);  constCheckInt(b, pos);
        return ptxCreateIntConstantExpr( ((uInt64)a->cases.IntConstant.i % (uInt64)b->cases.IntConstant.i), False, gblState);

    //
    // Operators + and -
    //
    case ptxADDOp    :
        if (a->kind == ptxIntConstantExpression) {
            if (isSignedInt(a->type) && isSignedInt(b->type))
                return ptxCreateIntConstantExpr( ((Int64)a->cases.IntConstant.i + (Int64)b->cases.IntConstant.i), True, gblState );
            else
                return ptxCreateIntConstantExpr( ((uInt64)a->cases.IntConstant.i + (uInt64)b->cases.IntConstant.i), False, gblState);
        } else  return ptxCreateF64FloatConstantExpr( ptxGetF64FloatConstantExpr(a) + ptxGetF64FloatConstantExpr(b), gblState);
    case ptxSUBOp    :
        if (a->kind == ptxIntConstantExpression) {
            if (isSignedInt(a->type) && isSignedInt(b->type))
                return ptxCreateIntConstantExpr( ((Int64)a->cases.IntConstant.i - (Int64)b->cases.IntConstant.i), True, gblState );
            else
                return ptxCreateIntConstantExpr( ((uInt64)a->cases.IntConstant.i - (uInt64)b->cases.IntConstant.i), False, gblState);
        } else  return ptxCreateF64FloatConstantExpr( ptxGetF64FloatConstantExpr(a) - ptxGetF64FloatConstantExpr(b), gblState);

    //
    // Operators << and >>
    //
    case ptxSHLOp    :
        constCheckInt(a, pos);  constCheckInt(b, pos);
        return ptxCreateIntConstantExpr( ((uInt64)a->cases.IntConstant.i << (uInt64)b->cases.IntConstant.i), isSignedInt(a->type), gblState);
    case ptxSHROp    :
        constCheckInt(a, pos);  constCheckInt(b, pos);
        if (isSignedInt(a->type))
            return ptxCreateIntConstantExpr( ((Int64)a->cases.IntConstant.i >> (uInt64)b->cases.IntConstant.i), isSignedInt(a->type), gblState);
        else
            return ptxCreateIntConstantExpr( ((uInt64)a->cases.IntConstant.i >> (uInt64)b->cases.IntConstant.i), isSignedInt(a->type), gblState);

    //
    // Operators <, <=, >=, >
    //
    case ptxLTOp     :
        if (a->kind == ptxIntConstantExpression) {
            if (isSignedInt(a->type) && isSignedInt(b->type))
                return ptxCreateIntConstantExpr( ((Int64)a->cases.IntConstant.i < (Int64)b->cases.IntConstant.i), True, gblState );
            else
                return ptxCreateIntConstantExpr( ((uInt64)a->cases.IntConstant.i < (uInt64)b->cases.IntConstant.i), True, gblState);
        } else  return ptxCreateIntConstantExpr( (ptxGetF64FloatConstantExpr(a) < ptxGetF64FloatConstantExpr(b)), True, gblState);
    case ptxLTEQOp   :
        if (a->kind == ptxIntConstantExpression) {
            if (isSignedInt(a->type) && isSignedInt(b->type))
                return ptxCreateIntConstantExpr( ((Int64)a->cases.IntConstant.i <= (Int64)b->cases.IntConstant.i), True, gblState );
            else
                return ptxCreateIntConstantExpr( ((uInt64)a->cases.IntConstant.i <= (uInt64)b->cases.IntConstant.i), True, gblState);
        } else  return ptxCreateIntConstantExpr( (ptxGetF64FloatConstantExpr(a) <= ptxGetF64FloatConstantExpr(b)), True, gblState);
    case ptxGTOp     :
        if (a->kind == ptxIntConstantExpression) {
            if (isSignedInt(a->type) && isSignedInt(b->type))
                return ptxCreateIntConstantExpr( ((Int64)a->cases.IntConstant.i > (Int64)b->cases.IntConstant.i), True, gblState );
            else
                return ptxCreateIntConstantExpr( ((uInt64)a->cases.IntConstant.i > (uInt64)b->cases.IntConstant.i), True, gblState);
        } else  return ptxCreateIntConstantExpr( (ptxGetF64FloatConstantExpr(a) > ptxGetF64FloatConstantExpr(b)), True, gblState);
    case ptxGTEQOp   :
        if (a->kind == ptxIntConstantExpression) {
            if (isSignedInt(a->type) && isSignedInt(b->type))
                return ptxCreateIntConstantExpr( ((Int64)a->cases.IntConstant.i >= (Int64)b->cases.IntConstant.i), True, gblState );
            else
                return ptxCreateIntConstantExpr( ((uInt64)a->cases.IntConstant.i >= (uInt64)b->cases.IntConstant.i), True, gblState);
        } else  return ptxCreateIntConstantExpr( (ptxGetF64FloatConstantExpr(a) >= ptxGetF64FloatConstantExpr(b)), True, gblState);

    //
    // Operators ==, !=
    //
    case ptxEQOp     :
        if (a->kind == ptxIntConstantExpression)  return ptxCreateIntConstantExpr( (a->cases.IntConstant.i == b->cases.IntConstant.i), True, gblState);
        else                                      return ptxCreateIntConstantExpr( (ptxGetF64FloatConstantExpr(a) == ptxGetF64FloatConstantExpr(b)), True, gblState);
    case ptxNEQOp    :
        if (a->kind == ptxIntConstantExpression)  return ptxCreateIntConstantExpr( (a->cases.IntConstant.i != b->cases.IntConstant.i), True, gblState);
        else                                      return ptxCreateIntConstantExpr( (ptxGetF64FloatConstantExpr(a) != ptxGetF64FloatConstantExpr(b)), True, gblState);

    //
    // Operators &, |, ^
    //
    case ptxOROp     :
        constCheckInt(a, pos);  constCheckInt(b, pos);
        return ptxCreateIntConstantExpr( (a->cases.IntConstant.i | b->cases.IntConstant.i), (isSignedInt(a->type) && isSignedInt(b->type)), gblState);
    case ptxANDOp    :
        constCheckInt(a, pos);  constCheckInt(b, pos);
        return ptxCreateIntConstantExpr( (a->cases.IntConstant.i & b->cases.IntConstant.i), (isSignedInt(a->type) && isSignedInt(b->type)), gblState);
    case ptxXOROp    :
        constCheckInt(a, pos);  constCheckInt(b, pos);
        return ptxCreateIntConstantExpr( (a->cases.IntConstant.i ^ b->cases.IntConstant.i), (isSignedInt(a->type) && isSignedInt(b->type)), gblState);

    //
    // Operators && and ||
    //
    case ptxOROROp   :
        constCheckInt(a, pos);  constCheckInt(b, pos);
        return ptxCreateIntConstantExpr( (a->cases.IntConstant.i || b->cases.IntConstant.i), True, gblState);
    case ptxANDANDOp :
        constCheckInt(a, pos);  constCheckInt(b, pos);
        return ptxCreateIntConstantExpr( (a->cases.IntConstant.i && b->cases.IntConstant.i), True, gblState);

    default          : stdASSERT( False, ("Unexpected binary operator") );
    }
    return NULL;
}

static ptxExpression constConditional( ptxExpression a, ptxExpression b, ptxExpression c, msgSourcePos_t sourcePos )
{
    constCheckInt(a, sourcePos);
    constCheckInt(b, sourcePos);
    constCheckInt(c, sourcePos);

    return (a->cases.IntConstant.i ? b : c);
}


/*------------------ Expression Validation and Construction ------------------*/

static ptxExpression createAddressOfExpr(ptxParsingState gblState,  ptxExpression lhs )
{
    if (lhs->isLhs) {
        if (lhs->kind == ptxArrayIndexExpression) {
            return ptxCreateAddressOfExpr(lhs, gblState);
        }

        // update ABI flags
        gblState->usesFuncPointer |= (lhs->kind == ptxSymbolExpression && lhs->cases.Symbol.symbol->kind == ptxFunctionSymbol);

        if (lhs->kind == ptxSymbolExpression &&
            lhs->cases.Symbol.symbol->kind == ptxVariableSymbol &&
            ptxIsAddressableStorage(lhs->cases.Symbol.symbol->storage)) {
          return ptxCreateAddressOfExpr(lhs, gblState);
        }
    }
    return lhs;
}


static ptxExpression createBaseOffsetExpr(ptxParsingState gblState,  ptxExpression left, ptxExpression right, msgSourcePos_t sourcePos )
{
    left = createAddressOfExpr(gblState, left);  // wrap addressible variables with AddressOfExpr
    return ptxCreateBinaryExpr(left->type, ptxADDOp, left, right);
}


static ptxExpression createNotExpr(ptxParsingState gblState,  ptxExpression arg, msgSourcePos_t sourcePos )
{
    stdCHECK_WITH_POS( isPRED(arg->type), (ptxMsgIllegalNotArgument, sourcePos) );
    return ptxCreatePredicateExpr( True, arg , gblState);
}


static ptxExpression createNegateExpr( ptxExpression arg, msgSourcePos_t sourcePos )
{
    stdCHECK_WITH_POS( isI32(arg->type) || isB32(arg->type), (ptxMsgIllegalMinusArgument, sourcePos) );
    return ptxCreateUnaryExpr( arg->type, ptxSUBOp, arg );
}


static void checkSregVersionAndTargetRequirements(ptxParsingState gblState,  ptxSymbolTableEntry entry, String name, msgSourcePos_t sourcePos )
{
    if (entry->storage.kind == ptxSregStorage) {
        // - defined in PTX ISA version 1.0: %tid, %ntid, %ctaid, %nctaid, %gridid, %clock.

        // check sregs defined in PTX ISA version 1.3
        if (strcmp(name, "%laneid") == 0 ||
            strcmp(name, "%warpid") == 0 ||
            strcmp(name, "%smid"  ) == 0 ||
            strcmp(name, "%pm0"   ) == 0 ||
            strcmp(name, "%pm1"   ) == 0 ||
            strcmp(name, "%pm2"   ) == 0 ||
            strcmp(name, "%pm3"   ) == 0
            ) {
            checkFeatureVersion(gblState, 1, 3, name, sourcePos);
        }

        // check sregs defined in PTX ISA version 2.0
        if (strcmp(name, "%nwarpid"    ) == 0 ||
            strcmp(name, "%nsmid"      ) == 0 ||
            strcmp(name, "%lanemask_eq") == 0 ||
            strcmp(name, "%lanemask_le") == 0 ||
            strcmp(name, "%lanemask_lt") == 0 ||
            strcmp(name, "%lanemask_ge") == 0 ||
            strcmp(name, "%lanemask_gt") == 0 ||
            strcmp(name, "%clock64"    ) == 0
            ) {
            checkFeatureVersion(gblState, 2, 0, name, sourcePos);
            stdCHECK_WITH_POS(checkTargetArch(gblState, 20), (ptxMsgFeatureRequiresSMVersion,sourcePos,name,"sm_20") );
        }

        // check sregs defined in PTX ISA version 3.0
        if (strcmp(name, "%pm4") == 0 ||
            strcmp(name, "%pm5") == 0 ||
            strcmp(name, "%pm6") == 0 ||
            strcmp(name, "%pm7") == 0
            ) {
            checkFeatureVersion(gblState, 3, 0, name, sourcePos);
            stdCHECK_WITH_POS(checkTargetArch(gblState, 20), (ptxMsgFeatureRequiresSMVersion,sourcePos,name,"sm_20") );
        }
        if (strcmp(name, "%globaltimer_lo") == 0 ||
            strcmp(name, "%globaltimer_hi") == 0 ||
            strcmp(name, "%globaltimer"   ) == 0
            ) {

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
            checkFeatureVersion(gblState, 3, 0, name, sourcePos);
#else
            checkFeatureVersion(gblState, 3, 1, name, sourcePos);
#endif
            stdCHECK_WITH_POS(checkTargetArch(gblState, 30), (ptxMsgFeatureRequiresSMVersion,sourcePos,name,"sm_30") );
        }

        // check sregs defined in PTX ISA version 4.0 for Maxwell
        if (strcmp(name, "%pm0_64") == 0 ||
            strcmp(name, "%pm1_64") == 0 ||
            strcmp(name, "%pm2_64") == 0 ||
            strcmp(name, "%pm3_64") == 0 ||
            strcmp(name, "%pm4_64") == 0 ||
            strcmp(name, "%pm5_64") == 0 ||
            strcmp(name, "%pm6_64") == 0 ||
            strcmp(name, "%pm7_64") == 0
            ) {
            checkFeatureVersion(gblState, 4, 0, name, sourcePos);
            stdCHECK_WITH_POS(checkTargetArch(gblState, 50), (ptxMsgFeatureRequiresSMVersion,sourcePos,name,"sm_50") );
        }

        // check sregs defined in PTX ISA version 4.1
        if (strcmp(name, "%total_smem_size") == 0) {
            checkFeatureVersion(gblState, 4, 1, name, sourcePos);
            stdCHECK_WITH_POS(checkTargetArch(gblState, 20), (ptxMsgFeatureRequiresSMVersion,sourcePos,name,"sm_20") );
        }
        if (strcmp(name, "%dynamic_smem_size") == 0) {
            checkFeatureVersion(gblState, 4, 1, name, sourcePos);
            stdCHECK_WITH_POS(checkTargetArch(gblState, 20), (ptxMsgFeatureRequiresSMVersion,sourcePos,name,"sm_20") );
        }

        // check sregs defined in PTX ISA version 5.0
        if (strcmp(name, "%clock_hi") == 0) {
            checkFeatureVersion(gblState, 5, 0, name, sourcePos);
            stdCHECK_WITH_POS(checkTargetArch(gblState, 20), (ptxMsgFeatureRequiresSMVersion,sourcePos,name,"sm_20") );
        }

        // check INTERNAL use sregs
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        // check sregs defined in PTX ISA version 3.0, ***INTERNAL-USE***
        if (strcmp(name, "%affinity"      ) == 0 ||
            strcmp(name, "%sm_ctaid"      ) == 0
            ) {
            checkFeatureVersion(gblState, 3, 0, name, sourcePos);
            stdCHECK_WITH_POS(checkTargetArch(gblState, 20), (ptxMsgFeatureRequiresSMVersion,sourcePos,name,"sm_20") );
        }
        if (strcmp(name, "%cq_entryid"      ) == 0 ||
            strcmp(name, "%cq_entryaddr"    ) == 0 ||
            strcmp(name, "%cq_incr_minus1"  ) == 0 ||
            strcmp(name, "%is_queue_cta"    ) == 0 ||
            strcmp(name, "%bar_warp"        ) == 0 ||
            strcmp(name, "%bar_warp_result" ) == 0 ||
            strcmp(name, "%bar_warp_resultp") == 0 ||
            strcmp(name, "%bar0" ) == 0 || strcmp(name, "%bar1" ) == 0 || strcmp(name, "%bar2" ) == 0 || strcmp(name, "%bar3" ) == 0 ||
            strcmp(name, "%bar4" ) == 0 || strcmp(name, "%bar5" ) == 0 || strcmp(name, "%bar6" ) == 0 || strcmp(name, "%bar7" ) == 0 ||
            strcmp(name, "%bar8" ) == 0 || strcmp(name, "%bar9" ) == 0 || strcmp(name, "%bar10") == 0 || strcmp(name, "%bar11") == 0 ||
            strcmp(name, "%bar12") == 0 || strcmp(name, "%bar13") == 0 || strcmp(name, "%bar14") == 0 || strcmp(name, "%bar15") == 0
            ) {
            checkFeatureVersion(gblState, 3, 1, name, sourcePos);
            stdCHECK_WITH_POS(checkTargetArch(gblState, 35), (ptxMsgFeatureRequiresSMVersion,sourcePos,name,"sm_35") );
        }
        if (strcmp(name, "%hwtaskid") == 0) {
            checkFeatureVersion(gblState, 5, 0, name, sourcePos);
            stdCHECK_WITH_POS(checkTargetArch(gblState, 35), (ptxMsgFeatureRequiresSMVersion,sourcePos,name,"sm_35") );
        }
        if (strcmp(name, "%nlatc") == 0) {
            checkFeatureVersion(gblState, 5, 0, name, sourcePos);
            stdCHECK_WITH_POS(checkTargetArch(gblState, 35), (ptxMsgFeatureRequiresSMVersion,sourcePos,name,"sm_35") );
        }
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
        if (strcmp(name, "%virtual_engineid") == 0) {
            checkFeatureVersion(gblState, 6, 0, name, sourcePos);
            stdCHECK_WITH_POS(checkTargetArch(gblState, 70), (ptxMsgFeatureRequiresSMVersion,sourcePos,name,"sm_70") );
        }
#endif // #if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
#if (LWCFG(GLOBAL_CHIP_T194) || LWCFG(GLOBAL_GPU_IMPL_GV11B)) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
        if (strcmp(name, "%pm0_snap_64") == 0 ||
            strcmp(name, "%pm1_snap_64") == 0 ||
            strcmp(name, "%pm2_snap_64") == 0 ||
            strcmp(name, "%pm3_snap_64") == 0 ||
            strcmp(name, "%pm4_snap_64") == 0 ||
            strcmp(name, "%pm6_snap_64") == 0 ||
            strcmp(name, "%pm7_snap_64") == 0
        ) {
            // FIXME: Update version check when exposed externally.
            checkFeatureVersion(gblState, 6, 0, "snapshot registers", sourcePos);
            stdCHECK_WITH_POS(checkTargetArch(gblState, 72), (ptxMsgFeatureRequiresSMVersion, sourcePos, "snapshot registers", "sm_72") );
        }
#endif // ((GLOBAL_CHIP_T194 || GV11B) && ISA_60)
#endif // #if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_64)
        if (strcmp(name, getSRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxStackend_STR)) == 0 ||
            strcmp(name, getSRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxStackinit_entry_STR)) == 0)
        {
            checkFeatureVersion(gblState, 6, 4, name, sourcePos);
            stdCHECK_WITH_POS(checkTargetArch(gblState, 50), (ptxMsgFeatureRequiresSMVersion,
                                                    sourcePos, name, "sm_50"));
        }
#endif
        // cluster related sregs
#if LWCFG(GLOBAL_ARCH_HOPPER)
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_FUTURE)
        if (strcmp(name, "%is_cluster_cta" ) == 0 ||
            strcmp(name, "%clusterid"      ) == 0 ||
            strcmp(name, "%nclusterid"     ) == 0 ||
            strcmp(name, "%cluster_ctaid"  ) == 0 ||
            strcmp(name, "%cluster_ctarank") == 0 ||
            strcmp(name, "%cluster_nctaid" ) == 0)
        {
            // FIXME: Update version check
            checkFeatureVersion(gblState, 7, 2, name, sourcePos);
            stdCHECK_WITH_POS(checkTargetArch(gblState, 90), (ptxMsgFeatureRequiresSMVersion,
                                                    sourcePos, name, "sm_90"));
        }
        if (strcmp(name, "%cluster_nctarank") == 0) {
            // FIXME: Update version check
            checkFeatureVersion(gblState, 7, 6, name, sourcePos);
            stdCHECK_WITH_POS(checkTargetArch(gblState, 90), (ptxMsgFeatureRequiresSMVersion,
                                                    sourcePos, name, "sm_90"));
        }
#endif // FUTURE
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        if (strcmp(name, "%clusterid_gpc") == 0) {
            // FIXME: Update version check
            checkFeatureVersion(gblState, 7, 2, name, sourcePos);
            stdCHECK_WITH_POS(checkTargetArch(gblState, 90), (ptxMsgFeatureRequiresSMVersion,
                                                    sourcePos, name, "sm_90"));
        }
#endif // INTERNAL
#endif // HOPPER

       // Reserved smem related sregs
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_76)
        if (stdEQSTRING(name, "%reserved_smem_offset_begin") ||
            stdEQSTRING(name, "%reserved_smem_offset_end")   ||
            stdEQSTRING(name, "%reserved_smem_offset_cap")   ||
            stdEQSTRING(name, "%reserved_smem_offset_0")     ||
            stdEQSTRING(name, "%reserved_smem_offset_1"))
        {
            checkFeatureVersion(gblState, 7, 6, name, sourcePos);
            stdCHECK_WITH_POS(checkTargetArch(gblState, 80), (ptxMsgFeatureRequiresSMVersion,
                                                              sourcePos, name, "sm_80"));
        }
#endif // ISA 7.6
    }
}

/*
 * A branch target may be either a label or a register.  In the case
 * of labels, the label may be a forward reference.  Since labels are scoped,
 * a label name defined in an outer scope may be masked by a label with the
 * same name not yet defined in the current scope.  For this reason, we must
 * defer binding branches to labels in outer scope until parsing is complete.
 * 
 * Example:
 *  ... 
 *  L1:  ...
 *     {
 *       bra L1;  // branch forward to L1 in same scope, not L1 in outer scope
 *       ...
 *  L1:  ...
 *     }
 *
 */
static ptxExpression createSymbolExpr(ptxParsingState gblState,  String name, msgSourcePos_t sourcePos )
{
    ptxExpression result;
    ptxSymbolTableEntry entry = ptxLookupSymbolLazyCreate( gblState->lwrSymbolTable, name, True, gblState );

    if (entry) {
        //
        // check version and target requirements for predefined special registers

        checkSregVersionAndTargetRequirements(gblState, entry, name, sourcePos);

        // if name is reference to non-label or label in current scope, return symbol
        if (entry->kind != ptxLabelSymbol || (entry->kind == ptxLabelSymbol && entry->symbtab == gblState->lwrSymbolTable)) {
            return ptxCreateSymbolExpr(entry);
        }
    }

    /*
     * fall-through to here handles undefined symbols, which can only be forward references to labels, and
     * out-of-scope labels, which must be deferred since they could be masked by subsequent same-name label
     * definitions in the current scope/block.  In both cases we create a label reference which is checked
     * at the end of parsing.
     */

    stdASSERT(!entry || (entry->kind == ptxLabelSymbol && entry->symbtab != gblState->lwrSymbolTable), ("bad label symbol") );

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
		if (ptxIsOcgBuiltinFunc(gblState->parseData, name)) {
			ptxAddFunctionSymbol( gblState->globalSymbolTable, 
				                    ptxCreateSymbol(gblState, ptxCreateLabelType(gblState), name, 0, 0, sourcePos ), 
                                    False, False, ptxStaticScope, NULL, NULL, NULL, False, False, False, -1, NULL);
            entry = ptxLookupSymbol(gblState->globalSymbolTable, name, False, gblState);
			stdASSERT(entry, ("bad function symbol"));
			return ptxCreateSymbolExpr(entry);
		}
#endif

    result = ptxCreateLabelReferenceExpr(name, gblState->lwrSymbolTable, sourcePos, gblState);
    listXPutAfter(gblState->lwrSymbolTable->LabelRefSeq, result);
    return result;
}


static ptxExpression createPredicateExpr(ptxParsingState gblState,  Bool not, String name, msgSourcePos_t sourcePos )
{
  ptxExpression p = createSymbolExpr(gblState, name, sourcePos);

  stdCHECK_WITH_POS( isPRED(p->type), (ptxMsgPredicateExpected, sourcePos) );
  return ptxCreatePredicateExpr(not, p, gblState);
}

static void checkArrayIdxExpr( ptxParseData parseData, ptxExpression arg, msgSourcePos_t sourcePos )
{
    ptxSymbolTableEntry symbol= ptxGetSymEntFromExpr(arg);
    if (!symbol) {
        return;
    }
    stdCHECK_WITH_POS( isIntegerKind(arg->type->kind) ||
                       isBitTypeKind(arg->type->kind),
                       (ptxMsgIllegalTypeForSymbolUsage,
                        sourcePos, symbol->symbol->unMangledName,
                        getTYPEAsString(parseData->deobfuscatedStringMapPtr, arg->type),
                        "array index", "integer or bit"));
}

static ptxExpression createArrayIndexExpr(ptxParsingState gblState,  ptxExpression array, ptxExpression index, msgSourcePos_t sourcePos )
{
    if (array->type->kind != ptxArrayType && array->type->kind != ptxIncompleteArrayType) {
        stdCHECK_WITH_POS( False, (ptxMsgIllegalIndex, sourcePos) );
        return ptxCreateIntConstantExpr(0,False, gblState);
    }
    checkArrayIdxExpr(gblState->parseData, index, sourcePos);
    return ptxCreateArrayIndexExpr(array,index);
}


static ptxExpression createSelectExpr(ptxParsingState gblState,  ptxExpression us, String field, msgSourcePos_t sourcePos )
{
    if (us->kind == ptxVectorExpression) {
        checkVectorExprModifier(field, us, sourcePos);
        return us;
    }
    if (us->type->kind == ptxVectorType) {
        ptxVectorSelector selectors[4];
        uInt              dimension;

        checkVectorSelector(field,selectors,&dimension,sourcePos);
        return ptxCreateVectorSelectExpr(us,dimension,selectors, gblState);
    }
    if (us->kind == ptxSymbolExpression && us->cases.Symbol.symbol->storage.kind == ptxRegStorage && ptxGetTypeSizeInBytes(us->type) == 4) {

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
        if (stdEQSTRING(field, ".b01") || stdEQSTRING(field, ".b12") || stdEQSTRING(field, ".b23"))
        {
            ptxByteSelector  selector;
            createByteSelector(field, &selector, sourcePos);
            return ptxCreateByteSelectExpr(us, 1, &selector);

        } 
#endif
        ptxVideoSelector selectors[4];
        uInt             N;

        checkVideoSelector(field,selectors,&N,sourcePos);
        return ptxCreateVideoSelectExpr(us,N,selectors);
        
    }

    stdCHECK_WITH_POS( False, (ptxMsgUnknownField, sourcePos, field) );
    return ptxCreateIntConstantExpr(0,False, gblState);
}


static ptxExpression createAddressRefExpr( ptxExpression arg, msgSourcePos_t sourcePos )
{
    return ptxCreateAddressRefExpr(arg);
}


/*---------------------------- Instruction Parsing ---------------------------*/





static void initInstrParseState(ptxParsingState gblState)
{
    int i;
    gblState->parseData->guard                = NULL;
    gblState->parseData->predicateOutput      = NULL;
    gblState->parseData->nrofInstructionTypes = 0;
    gblState->parseData->nrofArguments        = 0;
    gblState->parseData->nrofMatrixLayout     = 0;
    gblState->parseData->nrofTypeMod          = 0;
    gblState->parseData->nrofBMMAOperations   = 0;
    gblState->parseData->cmp                  = ptxNO_Comparison;
    gblState->parseData->postop               = ptxNOP;
    gblState->parseData->postopclass          = NoOperationClass;
    gblState->parseData->instrUsesTypeMod     = False;
    gblState->parseData->nrofInstrMemspace    = 0;
    for (i = 0; i < ptxMAX_INSTR_MEMSPACE; i++) {
        gblState->parseData->storage[i].kind = ptxUNSPECIFIEDStorage;
    }
    gblState->parseData->nrofEvictPriorityMod      = 0;
    gblState->parseData->evictPriorityMods[0] = ptxNOEVICTPRIORITY_MOD;
    gblState->parseData->evictPriorityMods[1] = ptxNOEVICTPRIORITY_MOD;

    gblState->parseData->nrofLevelColonMod = 0;
    gblState->parseData->levelColonMods[0] = ptxNOLEVEL_MOD;
    gblState->parseData->levelColonMods[1] = ptxNOLEVEL_MOD;

    gblState->parseData->matrixLayout[0] = ptxNOLAYOUT_MOD;
    gblState->parseData->matrixLayout[1] = ptxNOLAYOUT_MOD;
    stdMEMCLEAR(&gblState->parseData->arguments);
    //  instructionType is initialized to NULL to ensure its not garbage and
    //  any incorrect potential deference will cause segfault than silent
    //  incorrect access.
    //  Note in recognizeRealInstruction, lwrrently instructionType[0] at least
    //  is copied for all instructions
    for (i = 0; i < ptxMAX_INSTR_ARGS; i++) {
        gblState->parseData->instructionType[i] = NULL;
        gblState->parseData->typeMod[i] = ptxNOTYPE_MOD;
        gblState->parseData->BMMAOperations[i] = ptxNOMMA_MOD;
    }
}

static void setIsLastSeelwectorType(ptxParsingState gblState, Bool seen)
{
    gblState->parseData->isLastSeelwectorType = seen;
}

static void checkIsLastSeelwectorType(ptxParsingState gblState, Bool isLwrPTXType, msgSourcePos_t sourcePos)
{
    // TODO in next release: fix the Parser to accept vector type of form - "T_VECTOR T_TYPENAME"
    // and isLastSeelwectorType related functions and its usage must be removed
    stdCHECK_WITH_POS(!gblState->parseData->isLastSeelwectorType || isLwrPTXType, (ptxMsgWarning, sourcePos, "Vector Type not specified properly"));

    // reset the isLastSeelwectorType flag
    setIsLastSeelwectorType(gblState, False);
}

static void addStorage(ptxParsingState gblState,  ptxStorageClass s, msgSourcePos_t sourcePos )
{
    if (gblState->parseData->nrofInstrMemspace >= ptxMAX_INSTR_MEMSPACE) {
        stdCHECK_WITH_POS(False, (ptxMsgMultipleSpace, sourcePos));
        return; // ignore 's'.
    }

    gblState->parseData->storage[gblState->parseData->nrofInstrMemspace++] = s;
}

static void setPredicateOutput(ptxParsingState gblState, ptxExpression predicate, msgSourcePos_t sourcePos)
{
    gblState->parseData->predicateOutput= predicate;
}

static void setGuard(ptxParsingState gblState, ptxExpression predicate)
{
    gblState->parseData->guard= predicate;
}

static void pushArgument(ptxParsingState gblState, ptxExpression argument)
{
    if (gblState->parseData->nrofArguments!=ptxMAX_INSTR_ARGS) {
        gblState->parseData->arguments[ gblState->parseData->nrofArguments++ ]= argument;
    }
}

static void pushTypeMod(ptxParsingState gblState, uInt type, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    switch (type) {
    case ptxTYPE_b4_MOD:
        if (!areRestrictedUseFeaturesAllowed(gblState)) {
            stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                                      sourcePos, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, type)));
            return;
        }
    case ptxTYPE_u4_MOD:
    case ptxTYPE_s4_MOD:
    case ptxTYPE_b1_MOD:
        stdCHECK_WITH_POS(checkTargetArch(gblState, minTuringArch),
                          (ptxMsgFeatureRequiresSMVersion,
                           sourcePos,
                           getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, type),
                           minTuringArchStr));
        checkFeatureVersion(gblState, 6, 3, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, type), sourcePos);
        gblState->parseData->instrUsesTypeMod = True;
        break;
    case ptxTYPE_u2_MOD:
    case ptxTYPE_s2_MOD:
        stdCHECK_WITH_POS(checkTargetArch(gblState, minTuringArch),
                          (ptxMsgFeatureRequiresSMVersion,
                           sourcePos,
                           getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, type),
                           minTuringArchStr));
        if (areExtendedInstructionsEnabled(gblState->parseData)) {
             checkFeatureVersion(gblState, 6, 3, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, type), sourcePos);
        } else {
             checkFeatureVersion(gblState, 6, 5, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, type), sourcePos);
        }
        gblState->parseData->instrUsesTypeMod = True;
        break;
    case ptxTYPE_TF32_MOD:
    case ptxTYPE_BF16_MOD: {
        int minMinorVersion = ((type == ptxTYPE_BF16_MOD) ? 4 : 3);
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        stdCHECK_WITH_POS(checkTargetArch(gblState, minTuringArch),
                          (ptxMsgFeatureRequiresSMVersion,
                           sourcePos,
                           getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, type),
                           minTuringArchStr));
        checkFeatureVersion(gblState, 6, minMinorVersion, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, type), sourcePos);
#else
        if (areExtendedInstructionsEnabled(gblState->parseData)) {
            stdCHECK_WITH_POS(checkTargetArch(gblState, minTuringArch),
                            (ptxMsgFeatureRequiresSMVersion,
                            sourcePos,
                            getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, type),
                            minTuringArchStr));
            checkFeatureVersion(gblState, 6, minMinorVersion, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, type), sourcePos);
        } else {
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
            stdCHECK_WITH_POS(checkTargetArch(gblState, 80),
                                (ptxMsgFeatureRequiresSMVersion,
                                sourcePos,
                                getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, type),
                                "sm_80"));
            checkFeatureVersion(gblState, 7, 0, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, type), sourcePos);
#else
            stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, type)));
            return;
#endif
        }
#endif
        gblState->parseData->instrUsesTypeMod = True;
        break;
    }
    case ptxTYPE_BF16x2_MOD:
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
        stdCHECK_WITH_POS(checkTargetArch(gblState, 75),
                          (ptxMsgFeatureRequiresSMVersion,
                           sourcePos,
                           getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, type),
                           "sm_75"));
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) 
        checkFeatureVersion(gblState, 6, 4, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, type), sourcePos);
#else
        if (areExtendedInstructionsEnabled(gblState->parseData)) {
            checkFeatureVersion(gblState, 6, 5, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, type), sourcePos);
        } else {
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
            stdCHECK_WITH_POS(checkTargetArch(gblState, 80),
                                (ptxMsgFeatureRequiresSMVersion,
                                sourcePos,
                                getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, type),
                                "sm_80"));
            checkFeatureVersion(gblState, 7, 0, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, type), sourcePos);
#else
            stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                                      sourcePos, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, type)));
            return;
#endif // AMPERE & 70
        }
#endif // AMPERE & INTERNAL
#else
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                                  sourcePos, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, type)));
        return;
#endif // TURING & 65
        gblState->parseData->instrUsesTypeMod = True;
        break;
    default:
        break;
    }

    if (gblState->parseData->nrofTypeMod != ptxMAX_INSTR_ARGS) {
        gblState->parseData->typeMod[gblState->parseData->nrofTypeMod++] = type;
    }
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                              sourcePos, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, type)));
#endif
}

static void pushInstructionType(ptxParsingState gblState, ptxType type, msgSourcePos_t sourcePos)
{
    if (gblState->parseData->nrofInstructionTypes!=ptxMAX_INSTR_ARGS) {
        gblState->parseData->instructionType[ gblState->parseData->nrofInstructionTypes++ ]= type;
        // Set flag if any one of the instruction type is F64
        gblState->parseData->doubleUse |= isF64(type);
    }
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    uInt mod = ptxGetTypeModFromType(type);
    if (mod != ptxNOTYPE_MOD) {
        pushTypeMod(gblState, mod, sourcePos);
    }
#endif
}

static String getInstrTypeAsString(ptxParsingState gblState, int idx)
{
    return idx < gblState->parseData->nrofInstructionTypes ?
           getTYPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->instructionType[idx]) : "";
}

static void pushMatrixLayout(ptxParsingState gblState, uInt layout, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    if (gblState->parseData->nrofMatrixLayout == 2) {
        stdCHECK_WITH_POS(False, (ptxMsgParsingErrorNonFatal,
                                  sourcePos, getLAYOUTAsString(layout),
                                  "too many layout specifiers"));
    } else {
        gblState->parseData->matrixLayout[gblState->parseData->nrofMatrixLayout++] = layout;
    }
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                              sourcePos, getLAYOUTAsString(layout)));
#endif
}

static void setTexAddr(ptxParsingState gblState)
{
    gblState->parseData->modifiers.TADDR = ptxTADDR_MOD;
}

static void setSyncModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    gblState->parseData->modifiers.SYNC = modifier;
}

static void setThreadsModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    char anyOrAll[20] = "";
    if (ptxHasTHREADS_MOD(gblState->parseData->modifiers)) {
        snprintf(anyOrAll, 20, "%s/%s", getTHREADSAsString(ptxTANY_MOD),
                                        getTHREADSAsString(ptxTALL_MOD));
        stdCHECK_WITH_POS(False, (ptxMsgMultipleModifiers, sourcePos, anyOrAll));
    }
    gblState->parseData->modifiers.THREADS = modifier;
}

static void setBarModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    const char *name = getBARAsString(modifier);
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    stdCHECK_WITH_POS(checkTargetArch(gblState, 30), (ptxMsgFeatureRequiresSMVersion,
                                            sourcePos, name,"sm_30"));
    checkFeatureVersion(gblState, 6, 0, name, sourcePos);
    gblState->parseData->modifiers.BAR = modifier;
#else
    stdCHECK_WITH_POS(False, (ptxMsgIllegalModifier, sourcePos, name, "bar"));
#endif
}

static void setAlignModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    String modifierName = getALIGNAsString(ptxALIGNED_MOD);
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    stdCHECK_WITH_POS(!ptxHasALIGN_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, modifierName));
    checkFeatureVersion(gblState, 6, 0, modifierName, sourcePos);
    stdCHECK_WITH_POS(checkTargetArch(gblState, 20), (ptxMsgFeatureRequiresSMVersion,
                                            sourcePos, modifierName, "sm_20"));
    gblState->parseData->modifiers.ALIGN = modifier;
#else
    stdCHECK_WITH_POS(False, (ptxMsgParsingError, sourcePos,
                              modifierName, "syntax error"));
#endif
}

static void setScopeModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(!ptxHasSCOPE_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, "scope"));
    gblState->parseData->modifiers.SCOPE = modifier;
}

static void setCCModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    gblState->parseData->modifiers.CC = modifier;
}

static void setUniformModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    gblState->parseData->modifiers.UNIFORM = modifier;
}

static void setApproxModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    gblState->parseData->modifiers.APRX = modifier;
}

static void setReluModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    String modifierName = getRELUAsString(ptxRELU_MOD);
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    checkFeatureVersion(gblState, 6, 4, modifierName, sourcePos);
#else
    if (areExtendedInstructionsEnabled(gblState->parseData)) {
        checkFeatureVersion(gblState, 6, 5, modifierName, sourcePos);
    } else {
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
        checkFeatureVersion(gblState, 7, 0, modifierName, sourcePos);
#else
        msgReportWithPos(ptxMsgParsingErrorNonFatal, sourcePos, modifierName, "syntax error");
        return;
#endif
    }
#endif
    if (gblState->parseData->modifiers.SAT) {
        stdCHECK_WITH_POS(False, (ptxMsgIllegalModifierPair, sourcePos,
                                  modifierName, getSATAsString(ptxSAT_MOD)));
        return;
    }
    gblState->parseData->modifiers.RELU = modifier;
#else
    msgReportWithPos(ptxMsgParsingErrorNonFatal, sourcePos, modifierName, "syntax error");
#endif
}

static void setNaNModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    gblState->parseData->modifiers.NANMODE = modifier;
#else
    msgReportWithPos(ptxMsgParsingErrorNonFatal, sourcePos,
                     getNANMODEAsString(ptxNANMODE_MOD), "syntax error" );
#endif
}

static void setTransAModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    gblState->parseData->modifiers.TRANSA = modifier;
#else
    msgReportWithPos(ptxMsgParsingErrorNonFatal, sourcePos,
                     getTRANSAAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxTRANSA_MOD), "syntax error" );
#endif
}

static void setNegAModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    gblState->parseData->modifiers.NEGA = modifier;
#else
    msgReportWithPos(ptxMsgParsingErrorNonFatal, sourcePos,
                     getNEGAAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxNEGA_MOD), "syntax error" );
#endif
}

static void setTransBModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    gblState->parseData->modifiers.TRANSB = modifier;
#else
    msgReportWithPos(ptxMsgParsingErrorNonFatal, sourcePos,
                     getTRANSBAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxTRANSB_MOD), "syntax error" );
#endif
}

static void setNegBModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    gblState->parseData->modifiers.NEGB = modifier;
#else
    msgReportWithPos(ptxMsgParsingErrorNonFatal, sourcePos,
                     getNEGBAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxNEGB_MOD), "syntax error" );
#endif
}

static void setIgnoreCModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    gblState->parseData->modifiers.IGNOREC = modifier;
#else
    msgReportWithPos(ptxMsgParsingErrorNonFatal, sourcePos,
                     getNEGBAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxIGNOREC_MOD), "syntax error" );
#endif
}

static void setAddrTypeModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    gblState->parseData->modifiers.ADDRTYPE = modifier;
#else
    msgReportWithPos(ptxMsgParsingErrorNonFatal, sourcePos,
                     getADDRTYPEAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxADDRTYPE_FREL_MOD), "syntax error" );
#endif
}

// FIXME: The "noftz" hack allows the user to specify both qualifiers
// on the same instruction, but the hack also guarantees that there is
// no instruction where both are valid. The two functions below will
// be unified when we remove the hack.
//
// http://lwbugs/200376404
static void setFtzModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(!gblState->parseData->modifiers.FTZ,
                      (ptxMsgDuplicateModifier,
                       sourcePos, getFTZAsString(modifier)));
    gblState->parseData->modifiers.FTZ = modifier;
}

static void setNoftzModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(!gblState->parseData->modifiers.NOFTZ,
                      (ptxMsgDuplicateModifier,
                       sourcePos, getNOFTZAsString(modifier)));
    gblState->parseData->modifiers.NOFTZ = modifier;
}

static void setOobModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    stdCHECK_WITH_POS(!gblState->parseData->modifiers.OOB,
                      (ptxMsgDuplicateModifier,
                       sourcePos, getOOBAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier)));
    stdCHECK_WITH_POS(checkTargetArch(gblState, 90),
                      (ptxMsgModifierRequiresSMVersion,
                       sourcePos, getOOBAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier), "sm_90"));
    // FIXME: Update the version
    checkFeatureVersion(gblState, 7, 3, getOOBAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier), sourcePos);
    gblState->parseData->modifiers.OOB = modifier;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, getOOBAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier)));
#endif
}

static void setSatModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    String modifierName = getSATAsString(ptxSAT_MOD);
    if (gblState->parseData->modifiers.SATF) {
        stdCHECK_WITH_POS(False, (ptxMsgIllegalModifierPair, sourcePos,
                                  getSATFAsString(ptxSATFINITE_MOD), modifierName ));
        return;
    }
    if (gblState->parseData->modifiers.RELU) {
        stdCHECK_WITH_POS(False, (ptxMsgIllegalModifierPair, sourcePos,
                                  getRELUAsString(ptxRELU_MOD), modifierName));
        return;
    }
    gblState->parseData->modifiers.SAT = modifier;
}

static void setSatfModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    String modifierName = getSATFAsString(ptxSATFINITE_MOD);
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    gblState->parseData->modifiers.SATF = modifier;
    checkFeatureVersion(gblState, 6, 0, modifierName, sourcePos);
    stdCHECK_WITH_POS(checkTargetArch(gblState, 70), (ptxMsgFeatureRequiresSMVersion,
                                            sourcePos, modifierName, "sm_70"));
    if (gblState->parseData->modifiers.SAT) {
        stdCHECK_WITH_POS(False, (ptxMsgIllegalModifierPair, sourcePos,
                                  modifierName, getSATAsString(ptxSAT_MOD)));
    }
#else
    msgReportWithPos(ptxMsgParsingErrorNonFatal, sourcePos, modifierName, "syntax error");
#endif
}

static void setShamtModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    gblState->parseData->modifiers.SHAMT = modifier;
}

static void setOrderModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(!gblState->parseData->modifiers.ORDER, (ptxMsgDuplicateModifier, sourcePos,
                                         getORDERAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier)));
    switch(modifier) {
    case ptxVOLATILE_MOD:
#if LWCFG(GLOBAL_ARCH_VOLTA)
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    case ptxRELEASE_MOD:
    case ptxACQUIRE_MOD:
    case ptxRELAXED_MOD:
    case ptxACQREL_MOD:
    case ptxSC_MOD:
    case ptxWEAK_MOD:
#endif //ISA 6.0
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    case ptxMMIO_MOD:
#endif // INTERNAL
#endif // VOLTA
        gblState->parseData->modifiers.ORDER = modifier;
        break;
    default:
        gblState->parseData->modifiers.ORDER = ptxNOORDER_MOD;
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                                  sourcePos, getORDERAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier)));
    }
}

static void setWeakOrderModifier(ptxParsingState gblState, msgSourcePos_t sourcePos)
{
    String modifierName = getORDERAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxWEAK_MOD);
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    checkFeatureVersion(gblState, 6, 0, modifierName, sourcePos);
    stdCHECK_WITH_POS(checkTargetArch(gblState, 70), (ptxMsgFeatureRequiresSMVersion, sourcePos,
                                            modifierName, "sm_70"));
    setOrderModifier(gblState, ptxWEAK_MOD,sourcePos);
#else
    msgReportWithPos(ptxMsgParsingErrorNonFatal, sourcePos, modifierName, "syntax error");
#endif
}

static void setProxyKindModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    String modifierName = getPROXYKINDAsString(modifier);
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_75)
    // FIXME: For now error message says .alias as only .alias is supported
    //        Update this later once other proxy kinds are supported
    stdCHECK_WITH_POS(!ptxHasPROXYKIND_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, ".alias"));
    stdCHECK_WITH_POS(checkTargetArch(gblState, 60),
                      (ptxMsgModifierRequiresSMVersion, sourcePos,
                       modifierName, "sm_60"));
    stdCHECK_WITH_POS(checkFeatureVersion1(gblState, 7, 5),
                      (ptxMsgModifierRequiresPTXVersion, sourcePos,
                       modifierName, "7.5"));
    gblState->parseData->modifiers.PROXYKIND = modifier;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, modifierName));
#endif
}

static void setAliasProxyKindModifier(ptxParsingState gblState, msgSourcePos_t sourcePos)
{
    String modifierName = getPROXYKINDAsString(ptxPROXYKIND_ALIAS_MOD);
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_75)

    setProxyKindModifier(gblState, ptxPROXYKIND_ALIAS_MOD, sourcePos);
#else
    msgReportWithPos(ptxMsgParsingErrorNonFatal, sourcePos, modifierName, "syntax error");
#endif
}

static void setKeepRefModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    const char *name = getKEEPREFAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier);
    stdCHECK_WITH_POS(checkTargetArch(gblState, 35), (ptxMsgFeatureRequiresSMVersion,
                                            sourcePos, name,"sm_35"));
    checkFeatureVersion(gblState, 3, 1, name, sourcePos);
    gblState->parseData->modifiers.KEEPREF = modifier;
}

static void setNoatexitModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    const char *name = getNOATEXITAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier);
    stdCHECK_WITH_POS(checkTargetArch(gblState, 70), (ptxMsgFeatureRequiresSMVersion,
                                            sourcePos, name, "sm_70"));
    checkFeatureVersion(gblState, 6, 0, name, sourcePos);
    gblState->parseData->modifiers.NOATEXIT = modifier;
}

static void setNCModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS( !gblState->parseData->modifiers.NC, (ptxMsgDuplicateModifier, sourcePos, getNCAsString(ptxNC_MOD)) );
    gblState->parseData->modifiers.NC = modifier;
}

static void setVoteModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS( !ptxHasVOTE_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers, sourcePos, "vote") );
    gblState->parseData->modifiers.VOTE = modifier;
}

static void setFlowModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS( !ptxHasFLOW_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers, sourcePos, "flow") );
    gblState->parseData->modifiers.FLOW = modifier;
}

static void setBranchModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS( !ptxHasBRANCH_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers, sourcePos, "bra") );
    gblState->parseData->modifiers.BRANCH = modifier;

    if (gblState->parseData->modifiers.BRANCH == ptxUNANI_MOD) {
        String modifierName = getBRANCHAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxUNANI_MOD);
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        stdCHECK_WITH_POS(checkTargetArch(gblState, 20),
                          (ptxMsgFeatureRequiresSMVersion, sourcePos,
                           modifierName, "sm_20"));
        checkFeatureVersion(gblState, 2, 0, modifierName, sourcePos);
#else
        stdCHECK_WITH_POS(False, (ptxMsgIllegalModifier, sourcePos,
                                  get_strBRANCH(gblState->parseData), "bra"));
        gblState->parseData->modifiers.BRANCH = ptxNOBRANCH_MOD;
#endif
        return;
    }

    if (gblState->parseData->modifiers.BRANCH == ptxCOLW_MOD || gblState->parseData->modifiers.BRANCH == ptxDIV_MOD) {
#if LWCFG(GLOBAL_ARCH_VOLTA)
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        if (True) {
#else
        if (ptxIsInternalSource(gblState->lwrInstrSrc)) {
#endif
            int minPtxMajorVersion, minPtxMinorVersion;

            minPtxMajorVersion = 6;
            if (gblState->parseData->modifiers.BRANCH == ptxCOLW_MOD) {
                minPtxMinorVersion = 0;
            } else if (gblState->parseData->modifiers.BRANCH == ptxDIV_MOD) {
                // FIXME: Update version
                minPtxMinorVersion = 3;
            }
            stdCHECK_WITH_POS(checkTargetArch(gblState, 70), (ptxMsgFeatureRequiresSMVersion,
                                                    sourcePos, get_strBRANCH(gblState->parseData), "sm_70"));
            checkFeatureVersion(gblState, minPtxMajorVersion, minPtxMinorVersion, get_strBRANCH(gblState->parseData), sourcePos);
        } else {
            stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos,
                                      get_strBRANCH(gblState->parseData)));
            gblState->parseData->modifiers.BRANCH = ptxNOBRANCH_MOD;
        }
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos,
                              get_strBRANCH(gblState->parseData)));
    gblState->parseData->modifiers.BRANCH = ptxNOBRANCH_MOD;
#endif
    }
}

static void setVectorModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS( !ptxHasVECTOR_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers,sourcePos,"vector") );
    gblState->parseData->modifiers.VECTOR = modifier;
}

static void setClampModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS( !ptxHasCLAMP_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers,sourcePos,"clamp") );
    gblState->parseData->modifiers.CLAMP = modifier;
}

static void setShrModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS( !ptxHasSHR_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers,sourcePos,"shift-right") );
    gblState->parseData->modifiers.SHR = modifier;
}

static void setVmadModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS( !ptxHasVMAD_MOD(gblState->parseData->modifiers), (ptxMsgDoubleVmadModifier, sourcePos) );
    gblState->parseData->modifiers.VMAD = modifier;
}

static void setPrmtModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS( !ptxHasPRMT_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers,sourcePos,"permute") );
    gblState->parseData->modifiers.PRMT = modifier;
}

static void setShflModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS( !ptxHasSHFL_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers,sourcePos,"shuffle") );
    gblState->parseData->modifiers.SHFL = modifier;
}

static void setEnDisModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS( !ptxHasENDIS_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers,sourcePos,"enable/disable") );
    gblState->parseData->modifiers.ENDIS = modifier;
}

static void setRandModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    String modifierName = getRANDAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxRAND_MOD);
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    stdCHECK_WITH_POS( !ptxHasRAND_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers,
                                                    sourcePos, modifierName));
    gblState->parseData->modifiers.RAND = modifier;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, modifierName));
#endif
}

static void setTextureModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS( !ptxHasTEXTURE_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers,sourcePos,"texture") );
    gblState->parseData->modifiers.TEXTURE = modifier;
}

static void setDimModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS( !ptxHasDIM_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers,sourcePos,"dimension") );
    gblState->parseData->modifiers.DIM = modifier;
}

static void setFootprintModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    stdCHECK_WITH_POS( !ptxHasFOOTPRINT_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers,sourcePos,"footprint") );
    gblState->parseData->modifiers.FOOTPRINT = modifier;
#else
    String modifierName = getFOOTPRINTAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxFOOTPRINT_MOD);
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, modifierName));
#endif
}

static void setCoarseModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    stdCHECK_WITH_POS( !ptxHasGRANULARTY_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers,sourcePos,"coarse") );
    gblState->parseData->modifiers.COARSE = modifier;
#else
    String modifierName = getCOARSEAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier);
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, modifierName));
#endif
}

static void setComponentModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS( !ptxHasCOMPONENT_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers,sourcePos,"component") );
    gblState->parseData->modifiers.COMPONENT = modifier;
}

static void setQueryModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS( !ptxHasQUERY_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers,sourcePos,"query") );
    gblState->parseData->modifiers.QUERY = modifier;
}

static void setRoundModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS( !ptxHasROUND_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers, sourcePos, "rounding") );
    gblState->parseData->modifiers.ROUND = modifier;
}

static void setTestpModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS( !ptxHasTESTP_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers,sourcePos,"testp operation") );
    gblState->parseData->modifiers.TESTP = modifier;
}

static void setCacheOpModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS( !ptxHasCACHEOP_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers,sourcePos,"cache operation") );
    gblState->parseData->modifiers.CACHEOP = modifier;
}

static void setMatrixShape(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    stdCHECK_WITH_POS(!ptxHasSHAPE_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, "matrix shape"));
#endif
    switch (modifier) {
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    case ptxSHAPE_080804_MOD:
#if !LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_64)
        if (!areRestrictedUseFeaturesAllowed(gblState)) {
            stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                                      sourcePos, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier)));
            return;
        }
#endif
    case ptxSHAPE_161616_MOD:
        gblState->parseData->modifiers.SHAPE = modifier;
        return;
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_61)
    case ptxSHAPE_320816_MOD:
    case ptxSHAPE_083216_MOD:
        gblState->parseData->modifiers.SHAPE = modifier;
        return;
#endif
#endif
#if (LWCFG(GLOBAL_CHIP_T194) || LWCFG(GLOBAL_GPU_IMPL_GV11B) || LWCFG(GLOBAL_ARCH_TURING)) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    case ptxSHAPE_080816_MOD:
#if !LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
        if (!areRestrictedUseFeaturesAllowed(gblState)) {
            stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                                      sourcePos, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier)));
            return;
        }
#endif // 65
        gblState->parseData->modifiers.SHAPE = modifier;
        return;
#endif
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63) 
    case ptxSHAPE_080800_MOD:
    case ptxSHAPE_160808_MOD:
#if !LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65) 
        if (!areRestrictedUseFeaturesAllowed(gblState)) {
            stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                                      sourcePos, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier)));
            return;
        }
#endif // !ISA_65
        gblState->parseData->modifiers.SHAPE = modifier;
        return;
    case ptxSHAPE_160816_MOD:
    case ptxSHAPE_160804_MOD:
#if !LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
        if (!areRestrictedUseFeaturesAllowed(gblState)) {
            stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                                      sourcePos, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier)));
            return;
        }
#endif // !ISA_70
        gblState->parseData->modifiers.SHAPE = modifier;
        return;
    case ptxSHAPE_081600_MOD:
    case ptxSHAPE_083200_MOD:
    case ptxSHAPE_086400_MOD:
        if (!areRestrictedUseFeaturesAllowed(gblState)) {
            stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                                      sourcePos, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier)));
            return;
        }
    case ptxSHAPE_0808128_MOD:
    case ptxSHAPE_080832_MOD:
        gblState->parseData->modifiers.SHAPE = modifier;
        return;
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptxSHAPE_161608_MOD:
    case ptxSHAPE_080864_MOD:
    case ptxSHAPE_160832_MOD:
    case ptxSHAPE_160864_MOD:
    case ptxSHAPE_1608128_MOD:
    case ptxSHAPE_1608256_MOD:
        gblState->parseData->modifiers.SHAPE = modifier;
        return;
#endif // ampere, 70
#endif // turing, 63
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    case ptxSHAPE_640816_MOD:
    case ptxSHAPE_641616_MOD:
    case ptxSHAPE_642416_MOD:
    case ptxSHAPE_643216_MOD:
    case ptxSHAPE_644016_MOD:
    case ptxSHAPE_644816_MOD:
    case ptxSHAPE_645616_MOD:
    case ptxSHAPE_646416_MOD:
    case ptxSHAPE_647216_MOD:
    case ptxSHAPE_648016_MOD:
    case ptxSHAPE_648816_MOD:
    case ptxSHAPE_649616_MOD:
    case ptxSHAPE_6410416_MOD:
    case ptxSHAPE_6411216_MOD:
    case ptxSHAPE_6412016_MOD:
    case ptxSHAPE_6412816_MOD:
    case ptxSHAPE_6413616_MOD:
    case ptxSHAPE_6414416_MOD:
    case ptxSHAPE_6415216_MOD:
    case ptxSHAPE_6416016_MOD:
    case ptxSHAPE_6416816_MOD:
    case ptxSHAPE_6417616_MOD:
    case ptxSHAPE_6418416_MOD:
    case ptxSHAPE_6419216_MOD:
    case ptxSHAPE_6420016_MOD:
    case ptxSHAPE_6420816_MOD:
    case ptxSHAPE_6421616_MOD:
    case ptxSHAPE_6422416_MOD:
    case ptxSHAPE_6423216_MOD:
    case ptxSHAPE_6424016_MOD:
    case ptxSHAPE_6424816_MOD:
    case ptxSHAPE_6425616_MOD:
    case ptxSHAPE_640808_MOD:
    case ptxSHAPE_641608_MOD:
    case ptxSHAPE_642408_MOD:
    case ptxSHAPE_643208_MOD:
    case ptxSHAPE_644008_MOD:
    case ptxSHAPE_644808_MOD:
    case ptxSHAPE_645608_MOD:
    case ptxSHAPE_646408_MOD:
    case ptxSHAPE_647208_MOD:
    case ptxSHAPE_648008_MOD:
    case ptxSHAPE_648808_MOD:
    case ptxSHAPE_649608_MOD:
    case ptxSHAPE_6410408_MOD:
    case ptxSHAPE_6411208_MOD:
    case ptxSHAPE_6412008_MOD:
    case ptxSHAPE_6412808_MOD:
    case ptxSHAPE_6413608_MOD:
    case ptxSHAPE_6414408_MOD:
    case ptxSHAPE_6415208_MOD:
    case ptxSHAPE_6416008_MOD:
    case ptxSHAPE_6416808_MOD:
    case ptxSHAPE_6417608_MOD:
    case ptxSHAPE_6418408_MOD:
    case ptxSHAPE_6419208_MOD:
    case ptxSHAPE_6420008_MOD:
    case ptxSHAPE_6420808_MOD:
    case ptxSHAPE_6421608_MOD:
    case ptxSHAPE_6422408_MOD:
    case ptxSHAPE_6423208_MOD:
    case ptxSHAPE_6424008_MOD:
    case ptxSHAPE_6424808_MOD:
    case ptxSHAPE_6425608_MOD:
    case ptxSHAPE_640832_MOD:
    case ptxSHAPE_641632_MOD:
    case ptxSHAPE_642432_MOD:
    case ptxSHAPE_643232_MOD:
    case ptxSHAPE_644032_MOD:
    case ptxSHAPE_644832_MOD:
    case ptxSHAPE_645632_MOD:
    case ptxSHAPE_646432_MOD:
    case ptxSHAPE_647232_MOD:
    case ptxSHAPE_648032_MOD:
    case ptxSHAPE_648832_MOD:
    case ptxSHAPE_649632_MOD:
    case ptxSHAPE_6410432_MOD:
    case ptxSHAPE_6411232_MOD:
    case ptxSHAPE_6412032_MOD:
    case ptxSHAPE_6412832_MOD:
    case ptxSHAPE_6413632_MOD:
    case ptxSHAPE_6414432_MOD:
    case ptxSHAPE_6415232_MOD:
    case ptxSHAPE_6416032_MOD:
    case ptxSHAPE_6416832_MOD:
    case ptxSHAPE_6417632_MOD:
    case ptxSHAPE_6418432_MOD:
    case ptxSHAPE_6419232_MOD:
    case ptxSHAPE_6420032_MOD:
    case ptxSHAPE_6420832_MOD:
    case ptxSHAPE_6421632_MOD:
    case ptxSHAPE_6422432_MOD:
    case ptxSHAPE_6423232_MOD:
    case ptxSHAPE_6424032_MOD:
    case ptxSHAPE_6424832_MOD:
    case ptxSHAPE_6425632_MOD:
    case ptxSHAPE_640864_MOD:
    case ptxSHAPE_641664_MOD:
    case ptxSHAPE_642464_MOD:
    case ptxSHAPE_643264_MOD:
    case ptxSHAPE_644064_MOD:
    case ptxSHAPE_644864_MOD:
    case ptxSHAPE_645664_MOD:
    case ptxSHAPE_646464_MOD:
    case ptxSHAPE_647264_MOD:
    case ptxSHAPE_648064_MOD:
    case ptxSHAPE_648864_MOD:
    case ptxSHAPE_649664_MOD:
    case ptxSHAPE_6410464_MOD:
    case ptxSHAPE_6411264_MOD:
    case ptxSHAPE_6412064_MOD:
    case ptxSHAPE_6412864_MOD:
    case ptxSHAPE_6413664_MOD:
    case ptxSHAPE_6414464_MOD:
    case ptxSHAPE_6415264_MOD:
    case ptxSHAPE_6416064_MOD:
    case ptxSHAPE_6416864_MOD:
    case ptxSHAPE_6417664_MOD:
    case ptxSHAPE_6418464_MOD:
    case ptxSHAPE_6419264_MOD:
    case ptxSHAPE_6420064_MOD:
    case ptxSHAPE_6420864_MOD:
    case ptxSHAPE_6421664_MOD:
    case ptxSHAPE_6422464_MOD:
    case ptxSHAPE_6423264_MOD:
    case ptxSHAPE_6424064_MOD:
    case ptxSHAPE_6424864_MOD:
    case ptxSHAPE_6425664_MOD:
    case ptxSHAPE_6408256_MOD:
    case ptxSHAPE_6416256_MOD:
    case ptxSHAPE_6424256_MOD:
    case ptxSHAPE_6432256_MOD:
    case ptxSHAPE_6448256_MOD:
    case ptxSHAPE_6464256_MOD:
    case ptxSHAPE_6480256_MOD:
    case ptxSHAPE_6496256_MOD:
    case ptxSHAPE_64112256_MOD:
    case ptxSHAPE_64128256_MOD:
    case ptxSHAPE_64144256_MOD:
    case ptxSHAPE_64160256_MOD:
    case ptxSHAPE_64176256_MOD:
    case ptxSHAPE_64192256_MOD:
    case ptxSHAPE_64208256_MOD:
    case ptxSHAPE_64224256_MOD:
    case ptxSHAPE_64240256_MOD:
    case ptxSHAPE_64256256_MOD:
        gblState->parseData->modifiers.SHAPE = modifier;
        return;
#endif // HOPPER && INTERNAL
    default:
        gblState->parseData->modifiers.SHAPE = ptxNOSHAPE_MOD;
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                                  sourcePos, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier)));
        return;
    }
}

static void setSparsityModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    stdCHECK_WITH_POS(!ptxHasSPARSITY_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers,sourcePos,
                       getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSparsity_STR)));
    gblState->parseData->modifiers.SPARSITY = modifier;
#else
    String modifierName = getSPARSITYAsString(modifier);
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, modifierName));
#endif
}

static void setNoIncModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    cString modName = getNOINCAsString(modifier);
    stdCHECK_WITH_POS(!ptxHasNOINC_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, modName));
    gblState->parseData->modifiers.NOINC = modifier;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos,
                              getNOINCAsString(modifier)));
#endif
}

static void setNoCompleteModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    cString modName = getNOCOMPLETEAsString(modifier);
    stdCHECK_WITH_POS(!ptxHasNOCOMPLETE_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, modName));
    gblState->parseData->modifiers.NOCOMPLETE = modifier;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos,
                              getNOCOMPLETEAsString(modifier)));
#endif
}

#if LWCFG(GLOBAL_ARCH_AMPERE)
#if LWCFG(GLOBAL_GPU_FAMILY_GA10X) && (LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_72))
static void setXorSignModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(!ptxHasXORSIGN_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos,
                       getXORSIGNAsString(modifier)));
    gblState->parseData->modifiers.XORSIGN = modifier;
}
#endif // ga10x && (internal || version_72)
#endif // ampere

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void setNosleepModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    cString modName = getNOSLEEPAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier);
    stdCHECK_WITH_POS(!ptxHasNOSLEEP_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, modName));
    gblState->parseData->modifiers.NOSLEEP = modifier;
}
static void setSHAREDSCOPEModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    cString modName = getSHAREDSCOPEAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier);
    stdCHECK_WITH_POS(!ptxHasSHAREDSCOPE_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, modName));
    gblState->parseData->modifiers.SHAREDSCOPE = modifier;
}
static void setTensorDimModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    cString modName = getTENSORDIMAsString(modifier);
    stdCHECK_WITH_POS(!ptxHasTENSORDIM_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, modName));
    gblState->parseData->modifiers.TENSORDIM = modifier;
}
static void setIm2ColModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    cString modName = getIM2COLAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier);
    stdCHECK_WITH_POS(!ptxHasIM2COL_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, modName));
    gblState->parseData->modifiers.IM2COL = modifier;
}
static void setPackedOffModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    cString modName = getPACKEDOFFAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier);
    stdCHECK_WITH_POS(!ptxHasPACKEDOFF_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, modName));
    gblState->parseData->modifiers.PACKEDOFF = modifier;
}
static void setMulticastModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    cString modName = getMULTICASTAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier);
    stdCHECK_WITH_POS(!ptxHasMULTICAST_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, modName));
    gblState->parseData->modifiers.MULTICAST = modifier;
}
#endif // HOPPER && INTERNAL

static void setMbarrierModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    cString modName = getMBARRIERAsString(modifier);
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    stdCHECK_WITH_POS(!ptxHasMBARRIER_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, modName));
    gblState->parseData->modifiers.MBARRIER = modifier;
#else
    msgReportWithPos(ptxMsgParsingErrorNonFatal, sourcePos,
                     modName, "syntax error");
#endif // HOPPER && INTERNAL
}

static void setSparseFormatModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    stdCHECK_WITH_POS(!ptxHasSPFORMAT_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers, sourcePos,
                       getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSpformat_STR)));
    gblState->parseData->modifiers.SPFORMAT = modifier;
#else
    String modifierName = getSPFORMATAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier);
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, modifierName));    
#endif
}

static void setLevelModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(!ptxHasLEVEL_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers, sourcePos, "cache operation") );
    gblState->parseData->modifiers.LEVEL = modifier;
}

static void setEVICTPRIORITYModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    String modifierName = get_EVICTPRIORITYAsString(modifier);

#if LWCFG(GLOBAL_ARCH_VOLTA) && (LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71))
#if !LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71) && !LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
    if (!areExtendedInstructionsEnabled(gblState->parseData)) {
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, modifierName));
        return;
    }
#endif
    if (modifier == ptxEVICTFIRST_MOD || modifier == ptxEVICTNOALLOC_MOD || modifier == ptxEVICTUNCHANGED_MOD) {
        // .evict_first and .no_allocate is extended in PTX 7.2 and public in 7.4
#if !LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_72) && !LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
        if (!areExtendedInstructionsEnabled(gblState->parseData)) {
            stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, modifierName));
            return;
        }
#endif
    }
    if (gblState->parseData->nrofEvictPriorityMod >= ptxMAX_EVICTPRIORITY_MODS) {
        stdCHECK_WITH_POS(False, (ptxMsgUnexpectedNumOfModifiers, sourcePos, "cache eviction priority"));
        return;
    }
    gblState->parseData->evictPriorityMods[gblState->parseData->nrofEvictPriorityMod++] = modifier;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, modifierName));
#endif
}

static void setTTUModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    // FIXME: update version for guard
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    stdCHECK_WITH_POS( !ptxHasTTU_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers,sourcePos,"TTU") );
    gblState->parseData->modifiers.TTU = modifier;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, getTTUMODAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier)));
#endif
}

static void setTTUSlotModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    // FIXME: update version for guard
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    stdCHECK_WITH_POS( !ptxHasTTUSLOT_MOD(gblState->parseData->modifiers), (ptxMsgMultipleModifiers,sourcePos,"TTU slots") );
    gblState->parseData->modifiers.TTUSLOT = modifier;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, getTTUSLOTAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier)));
#endif
}

static void setCachePrefetchModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
#if (LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74))
    stdCHECK_WITH_POS(!ptxHasCACHEPREFETCH_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, "cache prefetching"));
    gblState->parseData->modifiers.CACHEPREFETCH = modifier;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos,
                              get_CACHEPREFETCHAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier)));
#endif // Turing && ISA_74
}

static void setPrefetchSizeModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    stdCHECK_WITH_POS(!ptxHasPREFETCHSIZE_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, "prefetch sizes"));
    gblState->parseData->modifiers.PREFETCHSIZE = modifier;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos,
                              get_PREFETCHSIZEAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier)));
#endif // Turing && Internal
}

static void setDescriptorModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    String modifierName = getDESCAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier);
#if LWCFG(GLOBAL_ARCH_AMPERE)
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    //FIXME: update version for guard
    checkFeatureVersion(gblState, 6, 4, modifierName, sourcePos);
#elif LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
    if (!areExtendedInstructionsEnabled(gblState->parseData)) {
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, modifierName));
        return;
    }
    checkFeatureVersion(gblState, 7, 1, modifierName, sourcePos);
#endif
    checkFeatureTarget(gblState, 80, modifierName, sourcePos);
    stdCHECK_WITH_POS(!ptxHasDESC_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, modifierName));
    gblState->parseData->modifiers.DESC = modifier;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, modifierName));
#endif
}

static void setNumModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    char modifierName[] = ".num";
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    stdCHECK_WITH_POS(!ptxHasNUM_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, modifierName));
#if !LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
    if (!areRestrictedUseFeaturesAllowed(gblState)) {
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                                  sourcePos, getNUMAsString(modifier)));
        return;
    }
#endif // 65
    gblState->parseData->modifiers.NUM = modifier;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                              sourcePos, getNUMAsString(modifier)));
#endif
}

static void setGroupModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    char modifierName[] = ".group";
    stdCHECK_WITH_POS(!ptxHasGROUP_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, modifierName));
    if (!areRestrictedUseFeaturesAllowed(gblState)) {
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                                  sourcePos, getGROUPAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier)));
        return;
    }
    checkFeatureTarget(gblState, 80, modifierName, sourcePos);
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    checkFeatureVersion(gblState, 6, 4, modifierName, sourcePos);
#else
    checkFeatureVersion(gblState, 7, 0, modifierName, sourcePos);
#endif
    gblState->parseData->modifiers.GROUP = modifier;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                              sourcePos, getGROUPAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier)));
#endif
}

static void setTransModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    String modifierName = getTRANSAsString(ptxTRANS_MOD);
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    stdCHECK_WITH_POS(!ptxHasTRANS_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, modifierName));
#if !LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
    if (!areRestrictedUseFeaturesAllowed(gblState)) {
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos,
                                  modifierName));
        return;
    }
#endif // 65
    gblState->parseData->modifiers.TRANS = modifier;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, modifierName));
#endif
}

static void setSeqModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    String modifierName = getSEQAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSEQ_MOD);
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    stdCHECK_WITH_POS(!ptxHasSEQ_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, modifierName));
    if (!areRestrictedUseFeaturesAllowed(gblState)) {
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos,
                                  modifierName));
        return;
    }
    checkFeatureTarget(gblState, 80, modifierName, sourcePos);
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    checkFeatureVersion(gblState, 6, 4, modifierName, sourcePos);
#else
    checkFeatureVersion(gblState, 7, 0, modifierName, sourcePos);
#endif
    gblState->parseData->modifiers.SEQ = modifier;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, modifierName));
#endif
}

static void setThreadGroupModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    char modifierName[] = "Thread group";
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    stdCHECK_WITH_POS(!ptxHasTHREADGROUP_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, modifierName));
    if (!areExtendedInstructionsEnabled(gblState->parseData) && modifier != ptxTGTHREAD_MOD) {
        // .thread modifier is also represents sparsity in sparse _mma instruction
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos,
                                  getTHREADGROUPAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier)));
        return;
    }
    if (modifier == ptxTGPAIR_MOD) {
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
        checkFeatureTarget(gblState, 80, getTHREADGROUPAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier), sourcePos);
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        checkFeatureVersion(gblState, 6, 4, getTHREADGROUPAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier), sourcePos);
#else
        checkFeatureVersion(gblState, 7, 0, getTHREADGROUPAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier), sourcePos);
#endif
#else
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos,
                                  getTHREADGROUPAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier)));
#endif // ampere, 70
    }
    gblState->parseData->modifiers.THREADGROUP = modifier;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos,
                              getTHREADGROUPAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier)));
#endif
}

static void setExpandModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    String modifierName = getEXPANDAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier);
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    stdCHECK_WITH_POS(!ptxHasEXPAND_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, modifierName));
    if (!areRestrictedUseFeaturesAllowed(gblState)) {
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, modifierName));
        return;
    }
    gblState->parseData->modifiers.EXPAND = modifier;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, modifierName));
#endif
}

static void setExclusiveModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    String modifierName = getEXCLUSIVEAsString(gblState->parseData->deobfuscatedStringMapPtr, modifier);
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    stdCHECK_WITH_POS(!ptxHasEXCLUSIVE_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, modifierName));
    gblState->parseData->modifiers.EXCLUSIVE = modifier;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, modifierName));
#endif
}

static void setAbsModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    String modifierName = getABSAsString(modifier);
#if LWCFG(GLOBAL_GPU_FAMILY_GA10X) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_72)
    stdCHECK_WITH_POS(!ptxHasABS_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, modifierName));
    checkFeatureTarget(gblState, 86, modifierName, sourcePos);
    checkFeatureVersion(gblState, 7, 2, modifierName, sourcePos);
    gblState->parseData->modifiers.ABS = modifier;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, modifierName));
#endif
}

static void setCacheHintModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    String modifierName = getCACHEHINTAsString(modifier);
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
    stdCHECK_WITH_POS(!ptxHasCACHEHINT_MOD(gblState->parseData->modifiers),
                      (ptxMsgMultipleModifiers, sourcePos, modifierName));
    gblState->parseData->modifiers.CACHEHINT = modifier;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, modifierName));
#endif
}

#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
static uInt colwertLevelEvictPriorityToEvictPriority(uInt modifier, String modifierName, msgSourcePos_t sourcePos)
{
    switch (modifier) {
    case ptxL1EVICTLAST_MOD:
    case ptxL2EVICTLAST_MOD:
        return ptxEVICTLAST_MOD;
    case ptxL1EVICTNORMAL_MOD:
    case ptxL2EVICTNORMAL_MOD:
        return ptxEVICTNORMAL_MOD;
    case ptxL1EVICTFIRST_MOD:
    case ptxL2EVICTFIRST_MOD:
        return ptxEVICTFIRST_MOD;
    case ptxL1EVICTUNCHANGED_MOD:
    case ptxL2EVICTUNCHANGED_MOD:
        return ptxEVICTUNCHANGED_MOD;
    case ptxL1EVICTNOALLOC_MOD:
    case ptxL2EVICTNOALLOC_MOD:
        return ptxEVICTNOALLOC_MOD;
    default:
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, modifierName));
        return ptxNOEVICTPRIORITY_MOD;
    }
}

static uInt getLevelColonMod(uInt modifier, String modifierName, msgSourcePos_t sourcePos)
{
    switch (modifier) {
    case ptxL1EVICTLAST_MOD:
    case ptxL1EVICTNORMAL_MOD:
    case ptxL1EVICTFIRST_MOD:
    case ptxL1EVICTUNCHANGED_MOD:
    case ptxL1EVICTNOALLOC_MOD:
        return ptxL1_MOD;

    case ptxL2EVICTNOALLOC_MOD:
    case ptxL2EVICTLAST_MOD:
    case ptxL2EVICTNORMAL_MOD:
    case ptxL2EVICTFIRST_MOD:
    case ptxL2EVICTUNCHANGED_MOD:
        return ptxL2_MOD;

    default:
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, modifierName));
        return ptxNOLEVEL_MOD;
    }
}
#endif

static void setLevelEvictPriorityModifier(ptxParsingState gblState, uInt modifier, msgSourcePos_t sourcePos)
{
    String modifierName = get_LEVELEVICTPRIORITYAsString(modifier);
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
    if (gblState->parseData->nrofLevelColonMod >= ptxMAX_LEVEL_MODS) {
        stdCHECK_WITH_POS(False, (ptxMsgUnexpectedNumOfModifiers, sourcePos, ".level::eviction_priority"));
    } else {
        gblState->parseData->levelColonMods[gblState->parseData->nrofLevelColonMod++] = getLevelColonMod(modifier, modifierName, sourcePos);
    }

    uInt evict_priority = colwertLevelEvictPriorityToEvictPriority(modifier, modifierName, sourcePos);
    setEVICTPRIORITYModifier(gblState, evict_priority, sourcePos);
#else
    stdCHECK_WITH_POS(False, (ptxMsgParsingError, sourcePos, ":", "syntax error"));
#endif
}

/*
 *  Handle any un-tokenized modifers.  Component gblState->parseData->modifiers aren't tokenized, since they alias with vector selectors.
 */
static void setModifier(ptxParsingState gblState, String dotident, msgSourcePos_t sourcePos)
{
  uInt lTypeMod = ptxNOTYPE_MOD;
  if      (strcmp(dotident, ".r") == 0)  { setComponentModifier(gblState,  ptxCOMP_R_MOD, sourcePos );  }
  else if (strcmp(dotident, ".g") == 0)  { setComponentModifier(gblState,  ptxCOMP_G_MOD, sourcePos );  }
  else if (strcmp(dotident, ".b") == 0)  { setComponentModifier(gblState,  ptxCOMP_B_MOD, sourcePos );  }
  else if (strcmp(dotident, ".a") == 0)  { setComponentModifier(gblState,  ptxCOMP_A_MOD, sourcePos );  }

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
  // This is handled here instead of ptx.l to ensure these strings don't leak out
#if LWCFG(GLOBAL_ARCH_VOLTA)
  else if (strcmp(dotident, getORDERAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxMMIO_MOD)) == 0)     { setOrderModifier(gblState,  ptxMMIO_MOD, sourcePos );  }
  else if (strcmp(dotident, getNOATEXITAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxNOATEXIT_MOD)) == 0) {
      setNoatexitModifier(gblState,  ptxNOATEXIT_MOD, sourcePos );
  }
#endif // volta
  else if (strcmp(dotident, getKEEPREFAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxKEEPREF_MOD)) == 0) {
      setKeepRefModifier(gblState,  ptxKEEPREF_MOD, sourcePos );
  }
#endif // internal

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
  else if (strcmp(dotident, getSPFORMATAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSPFORMAT_REGOFFSET_MOD)) == 0) {
    setSparseFormatModifier(gblState, ptxSPFORMAT_REGOFFSET_MOD, sourcePos);
  }
  else if (strcmp(dotident, getSPARSITYAsString(ptxSPARSITY_MOD)) == 0) {
    setSparsityModifier(gblState, ptxSPARSITY_MOD, sourcePos);
  }
#endif // ampere, 70

#if (LWCFG(GLOBAL_CHIP_T194) || LWCFG(GLOBAL_GPU_IMPL_GV11B)) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
  else if (strcmp(dotident, ".fused") == 0) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
      stdCHECK_WITH_POS(False, (ptxMsgModifierRequiresModifier, sourcePos, ".fused", ".hi"));
#else
      if (areExtendedInstructionsEnabled(gblState->parseData)) {
          stdCHECK_WITH_POS(False, (ptxMsgModifierRequiresModifier, sourcePos, ".fused", ".hi"));
      } else {
          stdCHECK_WITH_POS(False, (ptxMsgParsingError, sourcePos, dotident, "syntax error"));
      }
#endif
  }
#endif
  else if (lTypeMod = recognizeTypeMod(gblState->parseData, dotident), lTypeMod != ptxNOTYPE_MOD)
  {
      pushTypeMod(gblState, lTypeMod, sourcePos);
  }
#if LWCFG(GLOBAL_ARCH_AMPERE)
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71) || LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
  else if (strcmp(dotident, getDESCAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxDESC_MOD)) == 0) { setDescriptorModifier(gblState, ptxDESC_MOD, sourcePos); }
  else if (strcmp(dotident, get_EVICTPRIORITYAsString(ptxEVICTLAST_MOD)) == 0) {
    setEVICTPRIORITYModifier(gblState, ptxEVICTLAST_MOD, sourcePos);
  }
  else if (strcmp(dotident, get_EVICTPRIORITYAsString(ptxEVICTNORMAL_MOD)) == 0) {
    setEVICTPRIORITYModifier(gblState, ptxEVICTNORMAL_MOD, sourcePos);
  }
#endif
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_72) || LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
  else if (strcmp(dotident, get_EVICTPRIORITYAsString(ptxEVICTFIRST_MOD)) == 0) {
    setEVICTPRIORITYModifier(gblState, ptxEVICTFIRST_MOD, sourcePos);
  }
  else if (strcmp(dotident, get_EVICTPRIORITYAsString(ptxEVICTNOALLOC_MOD)) == 0) {
    setEVICTPRIORITYModifier(gblState, ptxEVICTNOALLOC_MOD, sourcePos);
  }
  else if (strcmp(dotident, get_EVICTPRIORITYAsString(ptxEVICTUNCHANGED_MOD)) == 0) {
    setEVICTPRIORITYModifier(gblState, ptxEVICTUNCHANGED_MOD, sourcePos);
  }
#endif // version_72 || internal
#if LWCFG(GLOBAL_GPU_FAMILY_GA10X) && (LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_72))
   else if (strcmp(dotident, getXORSIGNAsString(ptxXORSIGN_MOD)) == 0 ) {
    setXorSignModifier(gblState, ptxXORSIGN_MOD, sourcePos);
  }
#endif // ga10x && (internal || version_72)
#endif // ampere
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
  else if (strcmp(dotident, getNOSLEEPAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxNOSLEEP_MOD)) == 0) { setNosleepModifier(gblState, ptxNOSLEEP_MOD, sourcePos); }
  else if (strcmp(dotident, getSHAREDSCOPEAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSHAREDSCOPE_SELF_MOD)) == 0) {
     setSHAREDSCOPEModifier(gblState, ptxSHAREDSCOPE_SELF_MOD, sourcePos);
  } else if (strcmp(dotident, getSHAREDSCOPEAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSHAREDSCOPE_CLUSTER_SHARED_MOD)) == 0) {
     setSHAREDSCOPEModifier(gblState, ptxSHAREDSCOPE_CLUSTER_SHARED_MOD, sourcePos);
  }
  else if (strcmp(dotident, getIM2COLAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxIM2COL_MOD)) == 0) { setIm2ColModifier(gblState, ptxIM2COL_MOD, sourcePos); }
  else if (strcmp(dotident, getPACKEDOFFAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxPACKEDOFF_MOD)) == 0) { setPackedOffModifier(gblState, ptxPACKEDOFF_MOD, sourcePos); }
  else if (strcmp(dotident, getMULTICASTAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxMULTICAST_MOD)) == 0) { setMulticastModifier(gblState, ptxMULTICAST_MOD, sourcePos); }
  else if (strcmp(dotident, getOOBAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxOOB_MOD)) == 0) { setOobModifier(gblState, ptxOOB_MOD, sourcePos); }
#endif // HOPPER && INTERNAL
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
  else if (strcmp(dotident, getADDRTYPEAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxADDRTYPE_FREL_MOD)) == 0 ) {
     setAddrTypeModifier(gblState, ptxADDRTYPE_FREL_MOD, sourcePos);
  }
#if LWCFG(GLOBAL_ARCH_ADA)
  else if (stdEQSTRING(dotident, getVECTORAsString(ptxV8_MOD))) {
     setVectorModifier(gblState, ptxV8_MOD, sourcePos);
  }
#endif // ada
#endif // internal
  else stdCHECK_WITH_POS( False, (ptxMsgUnknownModifier,sourcePos,dotident) );
}


static void setCMP(ptxParsingState gblState, ptxComparison c, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS( gblState->parseData->cmp == ptxNO_Comparison, (ptxMsgDoubleCMP, sourcePos) );
    gblState->parseData->cmp = c;
}

static void setPtxOp(ptxParsingState gblState, ptxOperator op, ptxOperatorClass class, msgSourcePos_t sourcePos)
{
    gblState->parseData->nrofBMMAOperations++;
    if (!gblState->parseData->postopclass) {
        gblState->parseData->postop      = op;
        gblState->parseData->postopclass = class;
    }

#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    if (gblState->parseData->nrofBMMAOperations != ptxMAX_INSTR_ARGS) {
        gblState->parseData->BMMAOperations[gblState->parseData->nrofBMMAOperations-1] = colwertPostOpToMMAOperation(op);
    }
#endif
}

static void checkParameter(ptxParsingState gblState)
{
    // parameter may be from kernel or device function, or from .callprototype directive

    // check storage class
    //
    if (gblState->parseData->lwrIsEntry && !gblState->parseData->lwrIsPrototype) {
        stdCHECK_WITH_POS( gblState->parseData->lwrStorageClass.kind==ptxParamStorage, (ptxMsgEntryParamIllegalSpace, ptxsLwrPos(gblState), gblState->parseData->lwrDecl->unMangledName) );
    } else {
        stdCHECK_WITH_POS( (gblState->parseData->lwrStorageClass.kind==ptxRegStorage) || (gblState->parseData->lwrStorageClass.kind==ptxParamStorage && checkTargetArch(gblState, 20)),
                           (ptxMsgFunctionParamIllegalSpace, ptxsLwrPos(gblState), gblState->parseData->lwrDecl->unMangledName) );

        // allow sink name ('_') only in .callprototype directives
        //
        stdCHECK_WITH_POS( stdIMPLIES( strcmp(gblState->parseData->lwrDecl->unMangledName, "_")==0, gblState->parseData->lwrIsPrototype ), (ptxMsgIllegalParamName, ptxsLwrPos(gblState), gblState->parseData->lwrDecl->unMangledName) );
    }
}

  static void addParamSize(ptxVariableInfo VarI, uInt *mem)
  {
      ptxSymbol param    = VarI->symbol;
      uInt      size     = (uInt) ptxGetTypeSizeInBytes(param->type);
      uInt      logAlign = param->logAlignment;
      uInt      align    = (1<<logAlign);

      stdASSERT(FITS_IN_INT32(ptxGetTypeSizeInBits(param->type)), ("Size of data type more than expected"));
      // Don't consider opaque types for parameter size callwlation
      if (param->type->kind == ptxOpaqueType) {
          return;
      }
      // satisfy alignment, then add size of param to running total
      *mem = (*mem+align-1) & ~(align-1);
      *mem += size;
  }

static void checkKernelParamMemUsage(ptxParsingState gblState, ptxSymbolTableEntry kernel, msgSourcePos_t sourcePos)
{
    // callwlate kernel param mem usage
    uInt  mem = 0, limit = 0;
    listTraverse( kernel->aux->funcProtoAttrInfo->fparams, (stdEltFun)addParamSize, &mem );

    // Check kernel program mem usage limit and issue error
    limit = ptxVersionAtLeast(1,5, gblState) ? PTX_KERNEL_PARAM_LIMIT_ISA15
                                     : PTX_KERNEL_PARAM_LIMIT_ISA14;
    stdCHECK_WITH_POS(mem <= limit,
                      (ptxMsgKernelParamOverflow, sourcePos,
                       kernel->symbol->unMangledName, mem, limit));
}

static void termKernelFunction(ptxParsingState gblState,  ptxSymbolTableEntry entry, ptxSymbolTable body, msgSourcePos_t startPos, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS( entry->scope != ptxExternalScope, (ptxMsgIllegalExternFunction,sourcePos,entry->symbol->unMangledName) );

    entry->aux->body     = body;
    entry->aux->mbodyPos = sourcePos;
    entry->aux->startPos = startPos;
    ptxSetUniqueFuncIndex(entry, gblState);

    if (!ptxVersionAtLeast(1,4, gblState)) {  // fixup for legacy PTX
        gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->fparams = listReverse( gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->fparams );
    }

    if (ptxVersionAtLeast(2,0, gblState)) {
        stdCHECK_WITH_POS( stdIMPLIES( entry->aux->minnctapersm != 0, entry->aux->maxntid[0] != 0 || entry->aux->reqntid[0] != 0),
                            (ptxMsgWarning,sourcePos,".minnctapersm is ignored when neither .maxntid nor .reqntid is specified.") );
    } else {
        stdCHECK_WITH_POS( stdIMPLIES( entry->aux->minnctapersm != 0, entry->aux->maxntid[0] != 0 || entry->aux->reqntid[0] != 0),
                            (ptxMsgWarning,sourcePos,".maxnctapersm is ignored when neither .maxntid nor .reqntid is specified.") );
    }

    stdCHECK_WITH_POS( entry->aux->maxntid[0] == 0 || entry->aux->reqntid[0] == 0,
                       (ptxMsgConflictingDirectives,sourcePos,".maxntid and .reqntid cannot both be specified") );

    checkKernelParamMemUsage(gblState, gblState->parseData->lwrFunc, sourcePos);
    gblState->parseData->lwrFunc    = NULL;
    gblState->parseData->lwrIsEntry = False;
    setSourceLocForPrologue(gblState, startPos, sourcePos, gblState->parseData->prologueSourceLocation);
    insertPtxToSourceMapRecord(gblState); //insert record of ptxlines to sourceline from last .LOC to end of function
    // Reset source code location for next entry/device function
    gblState->parseData->lwrSourceCodeLocation->lwrLoc.fileIndex = 0;
    gblState->parseData->lwrSourceCodeLocation->lwrLoc.lineNo    = 0;
    gblState->parseData->lwrSourceCodeLocation->lwrLoc.linePos   = 0;
    gblState->parseData->lwrSourceCodeLocation->functionName     = NULL;
    gblState->parseData->lwrSourceCodeLocation->inlineAtLoc      = NULL;
    gblState->parseData->nextSourceCodeLocation = NULL;
    gblState->parseData->prologueSourceLocation = NULL;
}


  static Bool isBaseType( ptxType t )  { return (isBitTypeKind(t->kind) || isFloatKind(t->kind) || isIntegerKind(t->kind)); }

  static ptxType getArrayBaseType(ptxType arrType)
  {
      switch (arrType->kind) {
      case ptxArrayType:
          return arrType->cases.Array.base;
      case ptxIncompleteArrayType:
          return arrType->cases.IncompleteArray.base;
      default:
          stdASSERT(False, ("Expected array type here."));
          return NULL;
      }
  }

  static Bool matchParamArrayBaseTypes(ptxType formalArray, ptxType actualArray)
  {
      ptxType formal = getArrayBaseType(formalArray);
      ptxType actual = getArrayBaseType(actualArray);

      // allow bit-size type to match with bit/int/float base types
      if (isBitTypeKind(formal->kind))  { return isBaseType (actual); }
      if (isBitTypeKind(actual->kind))  { return isBaseType (formal); }

      return (isBaseType(formal) && formal==actual);
  }

static Bool matchCallParamType(ptxSymbol formal, ptxExpression actual)
{
    ptxType     type     = formal->type;
    ptxTypeKind typekind = type->kind;

    if (actual->kind == ptxLabelReferenceExpression)         { return False; }

    if (actual->kind == ptxSinkExpression)                   { return True;  }

    if (isFloatKind(typekind)) {
       if (isInteger(actual->type)                         ) { return False; }
       if (actual->type->kind == ptxTypePred               ) { return False; }
       if (actual->kind       == ptxFloatConstantExpression) { return True;  }
    } else 
    if (isInteger(type)) {
       if (isFloat(actual->type)                           ) { return False; }
       if (actual->type->kind == ptxTypePred               ) { return False; }
       if (actual->kind       == ptxIntConstantExpression  ) { return True;  }
    } else 
    if (isBitTypeKind(typekind)) {
       if (actual->type->kind == ptxTypePred               ) { return False; }
       if (actual->kind       == ptxIntConstantExpression  ) { return True;  }
       if (actual->kind       == ptxFloatConstantExpression) { return True;  }
    } else 
    if (typekind == ptxTypePred) {
       if (isFloat(actual->type)                           ) { return False; }
       if (isInteger(actual->type)                         ) { return False; }
       if (isBitType(actual->type)                         ) { return False; }
       if (actual->type->kind == ptxTypePred               ) { return True;  }
    }

    // if actual or formal is array, both must be array of same base type and size
    // - this covers the degenerative case of single-element arrays; other sizes are caught due to mismatch in type->size.
    if (typekind == ptxArrayType
        || typekind == ptxIncompleteArrayType
        || actual->type->kind == ptxArrayType)
    {
        if ((typekind != ptxArrayType && typekind != ptxIncompleteArrayType)
            || actual->type->kind != ptxArrayType)
        {
            return False;
        }

        if (!matchParamArrayBaseTypes(formal->type, actual->type)) {
            return False;
        }

        if (typekind == ptxIncompleteArrayType)
            return True;
    }

    return (ptxGetTypeSizeInBits(formal->type) == ptxGetTypeSizeInBits(actual->type));
}

static Bool matchCallParamAlignment(ptxSymbol formal, ptxExpression actual)
{
    if (actual->kind == ptxLabelReferenceExpression)
        return False;
    
    if (actual->kind != ptxSymbolExpression) {
        stdASSERT(isImmediate(actual) || actual->kind == ptxSinkExpression,
                  ("expected immediate constant"));
        return True;
    }

    return formal->logAlignment
        == actual->cases.Symbol.symbol->symbol->logAlignment;
}

static void matchCallParameter(ptxParsingState gblState, ptxVariableInfo VarI, ptxExpression actual,
                               msgSourcePos_t sourcePos)
{
    ptxSymbol       formal = VarI->symbol;
    stdCHECK_WITH_POS(matchCallParamType(formal, actual),
                      (ptxMsgCallArgTypesDiffer, sourcePos,
                       formal->unMangledName));

    stdCHECK_WITH_POS(matchCallParamAlignment(formal, actual),
                      (ptxMsgCallArgAlignmentsDiffer, sourcePos,
                       formal->unMangledName));
}

      static Bool isFormalParam(ptxParsingState gblState,  ptxExpression actual )
      {
        if (actual->kind == ptxSymbolExpression && actual->cases.Symbol.symbol->storage.kind == ptxParamStorage) {
            stdList_t l;
            for (l = gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->fparams; l; l = l->tail) {
                ptxVariableInfo VarI = l->head;
                ptxSymbol p = VarI->symbol;
                if (p==actual->cases.Symbol.symbol->symbol) return True;
            }

            for (l = gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->rparams; l; l = l->tail) {
                ptxVariableInfo VarI = l->head;
                ptxSymbol p = VarI->symbol;
                if (p==actual->cases.Symbol.symbol->symbol) return True;
            }
        }
        return False;
      }

static void checkCallParamSymbols(ptxParsingState gblState, ptxVariableInfo VarI, ptxExpression actual,
                                  Bool isRetParam, msgSourcePos_t sourcePos)
{
    ptxSymbol       formal = VarI->symbol;

    // actual parameters should be symbolExpr or constExpr; return parameter can be SinkExpression
    stdCHECK_WITH_POS((actual->kind == ptxSinkExpression && isRetParam) ||
                      (actual->kind == ptxSymbolExpression || actual->kind == ptxIntConstantExpression || actual->kind == ptxFloatConstantExpression),
                      (ptxMsgIllegalCallArg, sourcePos, formal->unMangledName));

    // actual parameters that are symbols should be in Param or Reg state space
    // Param-space arguments must be locally-scoped variables, not formal parameters to the current function
    if (actual->kind == ptxSymbolExpression) {
        ptxStorageKind  skind = actual->cases.Symbol.symbol->storage.kind;
        String          aname = actual->cases.Symbol.symbol->symbol->unMangledName;

        stdCHECK_WITH_POS( skind == ptxParamStorage || skind == ptxRegStorage, (ptxMsgCallArgIllegalSpace,sourcePos,aname) );
        stdCHECK_WITH_POS( !isFormalParam(gblState, actual), (ptxMsgFormalParamAsCallArg,sourcePos,aname) );

        // if either actual argument or formal parameter is an array, both must be .param arrays of same base type and size
        // . check state space here; type/size is checked in matchCallParamTypes
        stdCHECK_WITH_POS( stdIMPLIES( actual->type->kind == ptxArrayType, skind == ptxParamStorage && skind == VarI->storage.kind ),
                           (ptxMsgCallArgSpacesDiffer,sourcePos,aname) );
        stdCHECK_WITH_POS( stdIMPLIES( formal->type->kind == ptxArrayType, skind == ptxParamStorage && skind == VarI->storage.kind ),
                           (ptxMsgCallArgSpacesDiffer,sourcePos,aname) );
    }
}

static void checkMissingLastParam(stdList_t callee, msgSourcePos_t sourcePos)
{
    ptxVariableInfo VarI = callee->head;
    // The last argument of a call can be absent if it corresponds to an unsized
    // array parameter.
    stdCHECK_WITH_POS(!callee->tail &&
                      VarI->symbol->type->kind == ptxIncompleteArrayType,
                      (ptxMsgCallNArgsDiffer, sourcePos));
}

static void matchCallParamLists(ptxParsingState gblState, ptxSymbolTableEntryAux aux, int i, msgSourcePos_t sourcePos)
{
    stdList_t formal, actual;
    Bool      isRetParam = (i == 0);
    int formalSize, actualSize;

    stdCHECK_WITH_POS( aux != NULL, (ptxMsgCallTargetUnrecognized, sourcePos) ) {
        // get parameter list (either return params or formal params)
        formal = (isRetParam ? aux->funcProtoAttrInfo->rparams : aux->funcProtoAttrInfo->fparams);
        actual = gblState->parseData->arguments[i]->cases.ParamList.elements;
        actualSize = listSize(actual);
        formalSize = listSize(formal);
        // check number and type of arguments
        stdCHECK_WITH_POS(actualSize == formalSize
                          || actualSize == formalSize - 1,
                          (ptxMsgCallNArgsDiffer, sourcePos));

        while (formal) {
            if (!actual) {
                checkMissingLastParam(formal, sourcePos);
                break;
            }
            checkCallParamSymbols(gblState, formal->head, actual->head,
                                  isRetParam, sourcePos);
            matchCallParameter(gblState, formal->head, actual->head, sourcePos);

            formal = formal->tail;
            actual = actual->tail;
        }
    }
}

static void matchCallee(ptxParsingState gblState, ptxSymbolTableEntry fname, int i, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(fname->kind == ptxFunctionSymbol,
                      (ptxMsgFunctionNotDeclared, sourcePos,
                       fname->symbol->unMangledName));
    matchCallParamLists(gblState, fname->aux, i, sourcePos);
}

static void matchCallPrototype(ptxParsingState gblState, ptxExpression funs, int i, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(funs->kind == ptxSymbolExpression, (ptxMsgCallTargetUnrecognized, sourcePos) ) {
        matchCallParamLists(gblState, funs->cases.Symbol.symbol->aux, i, sourcePos);
    }
}

static void matchDirectCallParams(ptxParsingState gblState, int i, msgSourcePos_t sourcePos)
{
    ptxSymbolTableEntry fname;
    int                 fname_idx = (i == 0) ? 1 : i-1;   // get arg index of called function
    ptxExpression       argument  = gblState->parseData->arguments[fname_idx];

    // verify that callee is known
    if (argument->kind == ptxSymbolExpression && argument->type->kind == ptxLabelType) {
        fname  = argument->cases.Symbol.symbol;
        matchCallee(gblState, fname, i, sourcePos);
    } else {
        stdCHECK_WITH_POS(False, (ptxMsgCallTargetUnrecognized, sourcePos));
    }
}

static void matchIndirectCallParams(ptxParsingState gblState, int i, msgSourcePos_t sourcePos)
{
    ptxSymbolTableEntry fname;
    ptxExpression       funs = gblState->parseData->arguments[gblState->parseData->nrofArguments-1];

    //   case 1: arg is name of call table (array) or label of .calltargets directive.  Get aux structure from first callee in table/list's initializer list
    //   case 2: arg is label of .callprototype directive, so aux is stored directly in label's symtab entry
    stdCHECK_WITH_POS(funs->kind == ptxSymbolExpression, (ptxMsgCallTargetUnrecognized, sourcePos) ) {
        //
        // Case 1: call table or .calltargets directive.  Match call params with each function in flist initializer
        if (funs->cases.Symbol.symbol->initialValue != NULL) {
            ptxInitializer ival  = funs->cases.Symbol.symbol->initialValue;
            stdList_t      flist = ival->cases.Structured.list;

            while (flist) {
                ptxInitializer ival = flist->head;

                stdCHECK_WITH_POS( ival->kind == ptxExpressionInitializer, (ptxMsgCallTargetUnrecognized, sourcePos) ) {
                    ptxExpression sym = ival->cases.Expression.expr;

                    stdCHECK_WITH_POS( sym->kind != ptxLabelReferenceExpression,
                                       (ptxMsgFunctionNotDeclared,sym->cases.LabelReference->sourcePos,sym->cases.LabelReference->name) );

                    stdCHECK_WITH_POS( sym->kind == ptxSymbolExpression, (ptxMsgCallTargetUnrecognized, sourcePos) ) {
                        fname = sym->cases.Symbol.symbol;
                        matchCallee(gblState, fname, i, sourcePos);
                    }
                }
                flist = flist->tail;
            }
        } else {  // Case 2: .callprototype directive
            matchCallPrototype(gblState, funs, i, sourcePos);
        }
    }
}

static void checkCallParams(ptxParsingState gblState, int i, msgSourcePos_t sourcePos)
{
    if (isDirectCall(gblState->parseData->arguments, gblState->parseData->nrofArguments)) {
        matchDirectCallParams(gblState, i, sourcePos);
    } else {
        matchIndirectCallParams(gblState, i, sourcePos);
   }
}


    static void checkSink(ptxExpression e, Bool *result) { if (e->kind == ptxSinkExpression) { *result = True; } }

    static Bool checkCMPType(ptxParsingState gblState, ptxComparison cmp, ptxInstruction instr)
    {
        ptxType type;
        ptxTypeKind kind;

        type = ((instr->tmplate->nrofInstrTypes > 0) ?
                instr->type[instr->tmplate->nrofInstrTypes - 1] : NULL);

        if (type) {
            kind = type->kind;
        } else {
            // kind can't be inferred so be conservative in giving error.
            return False;
        }

        // bX                -> eq, ne
        // sX                -> eq, ne, lt, le, gt, ge
        // uX                -> eq, ne, lt, le, gt, ge, lo, hi, ls, hs
        // fX, bf16, bf16x2  -> eq, ne, lt, le, gt, ge, equ, neu, ltu, leu, gtu, geu, num, nan
        switch (kind) {
        case ptxTypeB8:
        case ptxTypeB16:
        case ptxTypeB32:
        case ptxTypeB64:
        case ptxTypeB128:
            return ( cmp==ptxEQ_Comparison  || cmp==ptxNE_Comparison );
        case ptxTypeS8:
        case ptxTypeS16:
        case ptxTypeS32:
        case ptxTypeS64:
            return ( cmp==ptxEQ_Comparison  || cmp==ptxNE_Comparison ||
                     cmp==ptxLT_Comparison  || cmp==ptxLE_Comparison ||
                     cmp==ptxGT_Comparison  || cmp==ptxGE_Comparison );
        case ptxTypeU8:
        case ptxTypeU16:
        case ptxTypeU32:
        case ptxTypeU64:
            return ( cmp==ptxEQ_Comparison  || cmp==ptxNE_Comparison ||
                     cmp==ptxLT_Comparison  || cmp==ptxLE_Comparison ||
                     cmp==ptxGT_Comparison  || cmp==ptxGE_Comparison ||
                     cmp==ptxLO_Comparison  || cmp==ptxLS_Comparison ||
                     cmp==ptxHI_Comparison  || cmp==ptxHS_Comparison );
        case ptxTypeF16:
        case ptxTypeF32:
        case ptxTypeF64:
        case ptxTypeBF16:
        case ptxTypeBF16x2:
        case ptxTypeF16x2:
            return ( cmp==ptxEQ_Comparison  || cmp==ptxNE_Comparison ||
                     cmp==ptxLT_Comparison  || cmp==ptxLE_Comparison ||
                     cmp==ptxGT_Comparison  || cmp==ptxGE_Comparison ||
                     cmp==ptxEQU_Comparison || cmp==ptxNEU_Comparison ||
                     cmp==ptxLTU_Comparison || cmp==ptxLEU_Comparison ||
                     cmp==ptxGTU_Comparison || cmp==ptxGEU_Comparison ||
                     cmp==ptxNUM_Comparison || cmp==ptxNAN_Comparison );
        default:
            return False;
        }
    }

   static Bool checkNumMemSpaces(ptxInstructionTemplate template,
                                 ptxInstructionCode code, cString name,
                                 int numMemspaces, msgSourcePos_t sourcePos )
    {
        stdASSERT(ptxHasMEMSPACE_Feature(template->features) ||
                  ptxHasMEMSPACES_Feature(template->features) 
                  , ("MEMSPACE feature expected"));
        
        Bool isCorrectNumMemspaces = False;

        switch (code) {
#if LWCFG(GLOBAL_ARCH_AMPERE) &&  LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
        case ptx_cp_async_Instr:
            isCorrectNumMemspaces = (numMemspaces == 2);
            break;
        case ptx_cp_async_mbarrier_arrive_Instr:
            isCorrectNumMemspaces = (numMemspaces == 1 || numMemspaces == 0);
            break;
#endif // ampere && version_70
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        case ptx_cp_async_bulk_Instr:
        case ptx_cp_async_bulk_tensor_Instr:
        case ptx_cp_reduce_async_bulk_tensor_Instr:
        case ptx_cp_reduce_async_bulk_Instr:
            isCorrectNumMemspaces = (numMemspaces == 2);
            break;
#endif // HOPPER && INTERNAL
        default:
            break;
        }

        stdCHECK_WITH_POS(isCorrectNumMemspaces,
                          (ptxMsgIncorrectMemspaces, sourcePos, name));
        return isCorrectNumMemspaces;
    }

    static Bool checkMemSpaceUsage( ptxParsingState gblState, ptxInstructionCode code, ptxStorageKind kind, int memspaceIndex)
    {
        switch (code) {
        case ptx_ld_Instr:
            return ( kind == ptxConstStorage || kind == ptxGenericStorage || kind == ptxGlobalStorage || kind == ptxLocalStorage ||
                     kind == ptxParamStorage || kind == ptxSharedStorage);
        case ptx_ldu_Instr:
            return ( kind == ptxGenericStorage || kind == ptxGlobalStorage );

        case ptx__ldldu_Instr:
            return ( kind == ptxGenericStorage );

        case ptx_prefetch_Instr:
            return ( kind == ptxGenericStorage || kind == ptxGlobalStorage || kind == ptxLocalStorage );

        case ptx_prefetchu_Instr:
            return ( kind == ptxGenericStorage );

        case ptx_isspacep_Instr:
        case ptx_cvta_Instr:
        case ptx_cvta_to_Instr:
            return ( (kind == ptxConstStorage && ptxVersionAtLeast(3,1, gblState)) || kind == ptxGlobalStorage || kind == ptxLocalStorage || 
                      kind == ptxSharedStorage );

        case ptx_cctl_Instr:
          return ( kind == ptxConstStorage || kind == ptxGenericStorage || kind == ptxGlobalStorage || kind == ptxLocalStorage || kind == ptxTexStorage );
        case ptx_cctlu_Instr:
            return ( kind == ptxGenericStorage || kind == ptxGlobalStorage );
        case ptx_atom_Instr:
        case ptx_red_Instr:
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
        case ptx_wmma_load_a_Instr:
        case ptx_wmma_load_b_Instr:
        case ptx_wmma_load_c_Instr:
        case ptx_wmma_store_d_Instr:
#endif
            return ( kind == ptxGenericStorage || kind == ptxGlobalStorage || kind == ptxSharedStorage );

        case ptx_st_Instr:
            return ( kind == ptxGenericStorage || kind == ptxGlobalStorage || kind == ptxLocalStorage ||
                     (kind == ptxParamStorage && checkTargetArch(gblState, 20)) || kind == ptxSharedStorage );

#if LWCFG(GLOBAL_ARCH_AMPERE)
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
        case ptx_cp_async_Instr:
            switch (memspaceIndex) {
            case 0: return (kind == ptxSharedStorage);
            case 1: return (kind == ptxGlobalStorage);
            default:
                stdASSERT(False, ("unexpected memspace index"));
                return False;
            }
            return False;
        case ptx_cp_async_mbarrier_arrive_Instr:
            return kind == ptxSharedStorage || kind == ptxGenericStorage;
#endif // ISA_70

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        case ptx_destroy_Instr:
#endif // internal
        case ptx_cachepolicy_Instr:
            return (kind == ptxGenericStorage || kind == ptxGlobalStorage);
#endif // internal || version_71
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
        case ptx_discard_Instr:
        case ptx_applypriority_Instr:
        case ptx_createpolicy_range_Instr:
            return (kind == ptxGenericStorage || kind == ptxGlobalStorage);
#endif // ISA_74
#endif // Ampere

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
        case ptx_mbarrier_init_Instr:
        case ptx_mbarrier_ilwal_Instr:
        case ptx_mbarrier_arrive_Instr:
        case ptx_mbarrier_arrive_drop_Instr:
        case ptx_mbarrier_test_wait_Instr:
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
        case ptx_mbarrier_test_wait_parity_Instr:
#endif
            return (kind == ptxSharedStorage || kind == ptxGenericStorage);
#endif // Ampere && 7.0
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        case ptx_mbarrier_try_wait_Instr:
        case ptx_mbarrier_try_wait_parity_Instr:
        case ptx_mbarrier_expect_copy_Instr:
        case ptx_mbarrier_arrive_expect_copy_Instr:
        case ptx_mbarrier_arrive_drop_expect_copy_Instr:
        case ptx_mbarrier_expect_tx_Instr:
        case ptx_mbarrier_arrive_expect_tx_Instr:
        case ptx_mbarrier_arrive_drop_expect_tx_Instr:
        case ptx_setctarank_Instr:
            return (kind == ptxSharedStorage || kind == ptxGenericStorage);
        case ptx_cp_async_bulk_Instr:
        case ptx_cp_async_bulk_tensor_Instr:
        case ptx_cp_reduce_async_bulk_tensor_Instr:
        case ptx_cp_reduce_async_bulk_Instr:
            switch (memspaceIndex) {
            case 0:
            case 1:
                // memespace related checks of instruction cp{.reduce}.async.bulk.tensor and cp{.reduce}.async.bulk
                // are performed separetely in functions "checkStateSpaceForTensorCopyInstruction"
                // "checkStateSpaceForBulkCopyInstruction" respectively
                return True;
            default:
                stdASSERT(False, ("unexpected memspace index"));
                return False;
            }
            return False;
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
        case ptx_ldmatrix_Instr:
            return (kind == ptxSharedStorage || kind == ptxGenericStorage);
#endif
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_FUTURE)
        case ptx_stmatrix_Instr:
            return (kind == ptxSharedStorage || kind == ptxGenericStorage);
#endif
        default:
            return False;
        }
    }
    static void checkStateSpaceConsistency( ptxInstructionTemplate template, ptxExpression arg, ptxStorageKind kind, msgSourcePos_t sourcePos)
    {
        //make instruction specific checks
        //check that ld/ldu & st doesnot load/store from invalid address location
        if ( template->code == ptx_ld_Instr || template->code == ptx_ldu_Instr || template->code == ptx_st_Instr) {
            if (arg->kind == ptxSymbolExpression)
            {
                switch (arg->type->kind) {
                case ptxLabelType:
                case ptxMacroType:
                case ptxTypePred:
                case ptxConditionCodeType:
                case ptxOpaqueType:
                    stdCHECK_WITH_POS( 0, (ptxMsgIllegalOperandType,sourcePos,template->name) );
                    break;
                default:
                    break;
                }
            }
        }
        // assume correct if instruction has no state space modifier
        if (kind == ptxUNSPECIFIEDStorage) return;

        switch (arg->kind) {
        case ptxLabelReferenceExpression:
            stdCHECK_WITH_POS( 0 , (ptxMsgIllegalOperandType,sourcePos,template->name) );
            break;

        case ptxSymbolExpression:
            // opaque args are checked against instruction opcode separately
            if (arg->type->kind == ptxOpaqueType) break;

            // return False if symbol is not a variable
            if (arg->cases.Symbol.symbol->kind != ptxVariableSymbol) {
                stdCHECK_WITH_POS( 0 , (ptxMsgIllegalOperandType,sourcePos,template->name) );
                break;
            }

            // if address is a simple variable, make sure state space matches instruction state space
            if (ptxIsAddressableStorage(arg->cases.Symbol.symbol->storage)) {
                if (kind == ptxGenericStorage) {
                    stdCHECK_WITH_POS( (arg->cases.Symbol.symbol->storage.kind == ptxGlobalStorage ||
                             arg->cases.Symbol.symbol->storage.kind == ptxLocalStorage  ||
                             arg->cases.Symbol.symbol->storage.kind == ptxSharedStorage ), 
                             (ptxMsgSpaceMismatch,sourcePos,template->name) );
                } else {
                    stdCHECK_WITH_POS( (arg->cases.Symbol.symbol->storage.kind == kind ), 
                                        (ptxMsgSpaceMismatch,sourcePos,template->name) );
                }
            }
            break;

        case ptxAddressOfExpression:
            checkStateSpaceConsistency(template, arg->cases.AddressOf.lhs, kind, sourcePos);
            break;

        case ptxAddressRefExpression:
            checkStateSpaceConsistency(template, arg->cases.AddressRef.arg, kind, sourcePos);
            break;

        case ptxArrayIndexExpression:
            checkStateSpaceConsistency(template, arg->cases.ArrayIndex->arg,
                                       kind, sourcePos);
            break;

        case ptxBinaryExpression:
            // if address is base+offset expression, check base consistency
            checkStateSpaceConsistency(template, arg->cases.Binary->left, kind, sourcePos);
            break;

        default:
            break;
        }

        return;  // assume correct if we can't prove otherwise
    }

    static Bool isLwrFuncInputParam (ptxParsingState gblState, ptxExpression arg)
    {
        ptxSymbolTableEntry sym;

        if (arg->kind != ptxSymbolExpression) {
            stdASSERT( False, ("symbol expected") );
            return False;
        }
        sym = arg->cases.Symbol.symbol;

        if (sym->kind == ptxVariableSymbol && sym->storage.kind == ptxParamStorage) {
            stdList_t l;
            for (l = gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->fparams; l; l = l->tail) {
                ptxVariableInfo VarI = l->head;
                ptxSymbol p = VarI->symbol;
                if (strcmp(p->unMangledName, sym->symbol->unMangledName)==0) return True;
            }
        }
        return False;
    }
    static Bool isLwrFuncReturnParam (ptxParsingState gblState, ptxExpression arg)
    {
        ptxSymbolTableEntry sym;

        if (arg->kind != ptxSymbolExpression) {
            stdASSERT( False, ("symbol expected") );
            return False;
        }
        sym = arg->cases.Symbol.symbol;

        if (sym->kind == ptxVariableSymbol && sym->storage.kind == ptxParamStorage) {

            stdList_t l;
            for (l = gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->rparams; l; l = l->tail) {
                ptxVariableInfo VarI = l->head;
                ptxSymbol p = VarI->symbol;
                if (strcmp(p->unMangledName, sym->symbol->unMangledName)==0) return True;
            }
        }
        return False;
    }

    static void checkAddressRefType(ptxParseData parseData, ptxExpression arg, msgSourcePos_t sourcePos)
    {
        ptxSymbolTableEntry symbol = ptxGetSymEntFromExpr(arg);
        if (!symbol) {
            return;
        }
        stdCHECK_WITH_POS( isIntegerKind(arg->type->kind) ||
                           isBitTypeKind(arg->type->kind),
                           (ptxMsgIllegalTypeForSymbolUsage, sourcePos,
                            symbol->symbol->unMangledName,
                            getTYPEAsString(parseData->deobfuscatedStringMapPtr, arg->type),
                            "address operand", "integer or bit"));
    }

    static void checkAddressExpr( ptxParsingState gblState, ptxExpression arg, ptxStorageKind kind, ptxInstructionCode code, msgSourcePos_t sourcePos )
    {
        // assume correct if instruction has no state space modifier
        if (kind == ptxUNSPECIFIEDStorage) return;

        switch (arg->kind) {
        case ptxAddressRefExpression:
            checkAddressRefType(gblState->parseData, arg, sourcePos);
            checkAddressExpr(gblState, arg->cases.AddressRef.arg, kind, code, sourcePos );
            break;
        case ptxAddressOfExpression:
            checkAddressExpr(gblState, arg->cases.AddressOf.lhs, kind, code, sourcePos );
            break;

        case ptxBinaryExpression:
            // if address is base+offset expression, check base consistency
            checkAddressExpr(gblState, arg->cases.Binary->left, kind, code, sourcePos );
            break;

        case ptxIntConstantExpression:
            // immediate offset addressing valid only for local state space
            stdCHECK_WITH_POS( kind == ptxLocalStorage, (ptxMsgIllegalImmediateAddress,sourcePos));
            break;

        case ptxSymbolExpression:
            if (code == ptx_ld_Instr && kind == ptxParamStorage) {
                stdCHECK_WITH_POS( !isLwrFuncReturnParam(gblState, arg), (ptxMsgIllegalReadOfReturnParam,sourcePos,arg->cases.Symbol.symbol->symbol->unMangledName) );
            }
            if (code == ptx_st_Instr && kind == ptxParamStorage) {
                stdCHECK_WITH_POS( !isLwrFuncInputParam(gblState, arg), (ptxMsgIllegalWriteToInputParam,sourcePos,arg->cases.Symbol.symbol->symbol->unMangledName) );
            }
            // otherwise okay
            break;

        default:
            break;
        }
    }

static Bool isMemDescAvailableForPublicInstr(ptxParsingState gblState)
{
#if LWCFG(GLOBAL_ARCH_AMPERE)
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    return checkFeatureVersion1(gblState, 6, 4);
#elif LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
    return areExtendedInstructionsEnabled(gblState->parseData) && checkFeatureVersion1(gblState, 7,1);
#endif
#endif
    return False;
}

static Bool isGenericDefaultStateSpace(uInt code)
{
    switch (code) {
    case ptx_ld_Instr:
    case ptx_st_Instr:
    case ptx_atom_Instr:
    case ptx_red_Instr:
    case ptx_ldu_Instr:
    case ptx_prefetch_Instr:
#if LWCFG(GLOBAL_ARCH_AMPERE)
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
    case ptx_cachepolicy_Instr:
#endif  // internal || ISA_71
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    case ptx_destroy_Instr:
#endif // internal
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
    case ptx_discard_Instr:
    case ptx_applypriority_Instr:
    case ptx_createpolicy_range_Instr:
#endif // ISA_74
#endif // ampere
    case ptx_prefetchu_Instr:
    case ptx_cctl_Instr:
    case ptx_cctlu_Instr:
    case ptx__ldldu_Instr:
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    case ptx_wmma_load_a_Instr:
    case ptx_wmma_load_b_Instr:
    case ptx_wmma_load_c_Instr:
    case ptx_wmma_store_d_Instr:
#endif
        return True;

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptx_cp_async_Instr:
        return False;
    case ptx_cp_async_mbarrier_arrive_Instr:
        return True;
#endif
#if LWCFG(GLOBAL_ARCH_AMPERE) &&  LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptx_mbarrier_init_Instr:
    case ptx_mbarrier_ilwal_Instr:
    case ptx_mbarrier_arrive_Instr:
    case ptx_mbarrier_arrive_drop_Instr:
    case ptx_mbarrier_test_wait_Instr:
    case ptx_mbarrier_pending_count_Instr:
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
    case ptx_mbarrier_test_wait_parity_Instr:
#endif
        return True;
#endif // Ampere && 7.0
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    case ptx_mbarrier_try_wait_Instr:
    case ptx_mbarrier_try_wait_parity_Instr:
    case ptx_mbarrier_expect_copy_Instr:
    case ptx_mbarrier_arrive_expect_copy_Instr:
    case ptx_mbarrier_arrive_drop_expect_copy_Instr:
    case ptx_mbarrier_expect_tx_Instr:
    case ptx_mbarrier_arrive_expect_tx_Instr:
    case ptx_mbarrier_arrive_drop_expect_tx_Instr:
    case ptx_setctarank_Instr:
        return True;
    case ptx_cp_async_bulk_Instr:
    case ptx_cp_async_bulk_tensor_Instr:
    case ptx_cp_reduce_async_bulk_tensor_Instr:
    case ptx_cp_reduce_async_bulk_Instr:
        return False;
#endif // HOPPER && INTERNAL
    case ptx_isspacep_Instr:
    case ptx_cvta_Instr:
    case ptx_cvta_to_Instr:
        return False;
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
    case ptx_ldmatrix_Instr:
        return True;
#endif
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_FUTURE)
    case ptx_stmatrix_Instr:
        return True;
#endif

    default:
        stdASSERT( False, ("Case label out of bounds") );
    }
    return False;
}

static Bool checkCacheOp( ptxInstructionCode code, uInt cop )
{
    switch (code) {
    case ptx_ld_Instr:
      return (cop == ptxCA_MOD || cop == ptxCG_MOD || cop == ptxCS_MOD || cop == ptxLU_MOD || cop == ptxCV_MOD);

    case ptx_suld_b_Instr:
      return (cop == ptxCA_MOD || cop == ptxCG_MOD || cop == ptxCS_MOD || cop == ptxCV_MOD);

    case ptx_st_Instr:
    case ptx_sust_b_Instr:
    case ptx_sust_p_Instr:
      return (cop == ptxWB_MOD || cop == ptxCG_MOD || cop == ptxCS_MOD || cop == ptxWT_MOD);

    case ptx_cctl_Instr:
      return (cop == ptxWB_MOD || ptxILW_MOD || cop == ptxILWALL_MOD);

    case ptx_cctlu_Instr:
      return (ptxILW_MOD || cop == ptxILWALL_MOD);

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    case ptx_membar_Instr:
#if LWCFG(GLOBAL_ARCH_TURING)
    case ptx_ttucctl_Instr:
#endif
      return (cop == ptxILWALL_MOD);
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptx_cp_async_Instr:
      return (cop == ptxCA_MOD || cop == ptxCG_MOD);
#endif

    default:
      return False;
    }
}

static Bool checkCacheLevel( ptxInstructionCode code, uInt lvl )
{
    switch (code) {
    case ptx_prefetch_Instr:
      return (lvl == ptxL1_MOD || lvl == ptxL2_MOD);

#if LWCFG(GLOBAL_ARCH_AMPERE) && (LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71))
    case ptx_cachepolicy_Instr:
      return (lvl == ptxL2_MOD);
#endif // ampere, (internal || ISA_71)

    case ptx_prefetchu_Instr:
      return (lvl == ptxL1_MOD);

    case ptx_ld_Instr:
      return (lvl == ptxL2_MOD);

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
    case ptx_discard_Instr:
    case ptx_applypriority_Instr:
    case ptx_createpolicy_fractional_Instr:
    case ptx_createpolicy_range_Instr:
    case ptx_createpolicy_cvt_Instr:
      return (lvl == ptxL2_MOD);
#endif
    default:
      return False;
    }
}

static Bool checkValidClamp(ptxParsingState gblState, ptxInstructionCode code, uInt clamp, msgSourcePos_t sourcePos)
{
    // surface instructions
    if (ptxIsSurfaceInstr(code)) {
        if (clamp==ptxTRAP_MOD) checkFeatureVersion(gblState, 1, 5, ".trap modifier", sourcePos);
        if (clamp==ptxCLAMP_MOD) checkFeatureVersion(gblState, 2, 0, ".clamp modifier", sourcePos);
        if (clamp==ptxZERO_MOD) checkFeatureVersion(gblState, 2, 0, ".zero modifier", sourcePos);

        return (clamp == ptxCLAMP_MOD || clamp == ptxTRAP_MOD || clamp == ptxZERO_MOD);
    }

    // video instruction
    if (ptxIsVideoInstruction(code)) {
        return (clamp == ptxCLAMP_MOD || clamp == ptxWRAP_MOD);
    }

    // shf instruction
    if (code == ptx_shf_l_Instr || code == ptx_shf_r_Instr) {
        return (clamp == ptxCLAMP_MOD || clamp == ptxWRAP_MOD);
    }

#if LWCFG(GLOBAL_ARCH_VOLTA)
    switch (code) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_76)
    // bmsk instruction
    case ptx_bmsk_Instr:
        // OPTIX_HAND_EDIT: Move return in each case to avoid "error: statement will never be exelwted" in SANDBAG build
        return (clamp == ptxCLAMP_MOD || clamp == ptxWRAP_MOD);
#endif
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    // sgxt instruction
    case ptx_sgxt_Instr:
        // OPTIX_HAND_EDIT: Move return in each case to avoid "error: statement will never be exelwted" in SANDBAG build
        return (clamp == ptxCLAMP_MOD || clamp == ptxWRAP_MOD);
#endif
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_76)
    // szext instruction
    case ptx_szext_Instr:
        // OPTIX_HAND_EDIT: Move return in each case to avoid "error: statement will never be exelwted" in SANDBAG build
        return (clamp == ptxCLAMP_MOD || clamp == ptxWRAP_MOD);
#endif

    default:
        return False;
    }
#endif

    return False;
}

static void checkFermiInstructions(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    switch (tcode) {
    case ptx_brev_Instr:
    case ptx_bfe_Instr:
    case ptx_bfi_Instr:
    case ptx_bfind_Instr:
    case ptx_prmt_Instr:
    case ptx_popc_Instr:
    case ptx_clz_Instr:
    case ptx_ldu_Instr:
    case ptx__ldldu_Instr:
    case ptx_testp_Instr:
    case ptx_copysign_Instr:
    case ptx_prefetch_Instr:
    case ptx_prefetchu_Instr:
    case ptx_isspacep_Instr:
    case ptx_cvta_Instr:
    case ptx_cvta_to_Instr:
    case ptx_cctl_Instr:
    case ptx_cctlu_Instr:
        stdCHECK_WITH_POS( checkTargetArch(gblState, 20), (ptxMsgSMVersionRequired,sourcePos,name,"sm_20") );
        checkFeatureVersion(gblState, 2, 0, name, sourcePos);
        break;

    case ptx_tld4_Instr:
        stdCHECK_WITH_POS( checkTargetArch(gblState, 20), (ptxMsgSMVersionRequired,sourcePos,name,"sm_20") );
        checkFeatureVersion(gblState, 2, 2, name, sourcePos);
        break;

    case ptx_txq_Instr:
    case ptx_suq_Instr:
        // supported on all target architectures
        checkFeatureVersion(gblState, 1, 5, name, sourcePos);
        break;
    case ptx_txq_level_Instr:
        stdCHECK_WITH_POS( checkTargetArch(gblState, 30), (ptxMsgSMVersionRequired,sourcePos,name,"sm_30") );
        checkFeatureVersion(gblState, 4, 3, name, sourcePos);
        break;

    case ptx_tex_base_Instr:
    case ptx_tex_level_Instr:
    case ptx_tex_grad_Instr:
        stdCHECK_WITH_POS( checkTargetArch(gblState, 20), (ptxMsgSMVersionRequired,sourcePos,name,"sm_20") );
        checkFeatureVersion(gblState, 3, 1, name, sourcePos);
        break;

    default:
        break;
    }

    stdCHECK_WITH_POS(stdIMPLIES(ptxIsVideoInstruction(tcode), checkTargetArch(gblState, 20)), 
                      (ptxMsgSMVersionRequired,sourcePos,name,"sm_20"));
    if (ptxIsVideoInstruction(tcode)) {
        checkFeatureVersion(gblState, 2, 0, "2.0", sourcePos);
    }

    if (ptxIsSurfaceInstr(tcode)) {
        if (isPTX15SurfaceInstr(tcode)) {
            // supported on all target architectures
            checkFeatureVersion(gblState, 1, 5, name, sourcePos);
        } else {
            stdCHECK_WITH_POS(checkTargetArch(gblState, 20),
                              (ptxMsgSMVersionRequired, sourcePos, name, "sm_20"));
            checkFeatureVersion(gblState, 2, 0, name, sourcePos);
        }

        // Surface instructions with relocations are not supported on ampere
        // merlwry path
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_COMPUTE_COMPILER_INTERNAL)
        ptxSetNonMercFeatureUsed(gblState, ptxSurfInstruction);
#endif
    }
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_COMPUTE_COMPILER_INTERNAL)
    if (tcode == ptx_suq_Instr) {
        // Surface instructions with relocations are not supported on ampere
        // merlwry path
        ptxSetNonMercFeatureUsed(gblState, ptxSurfInstruction);
    }
#endif
}

static void checkKeplerInstructions(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    switch (tcode) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    case ptx_brx_idx_Instr:
        stdCHECK_WITH_POS(checkTargetArch(gblState, 30), (ptxMsgSMVersionRequired,sourcePos,name,"sm_30") );
        checkFeatureVersion(gblState, 6, 0, name, sourcePos);
        break;
#endif
    case ptx__checkfp_divide_Instr:
        stdCHECK_WITH_POS(checkTargetArch(gblState, 32), (ptxMsgSMVersionRequired,sourcePos,name,"sm_32") );
        checkFeatureVersion(gblState, 3, 1, name, sourcePos);
        break;

    case ptx_shf_l_Instr:
    case ptx_shf_r_Instr:
        stdCHECK_WITH_POS(checkTargetArch(gblState, 32), (ptxMsgSMVersionRequired,sourcePos,name,"sm_32") );
        checkFeatureVersion(gblState, 3, 1, name, sourcePos);
        break;

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    case ptx_intr_Instr:
    case ptx_getlmembase_Instr:
    case ptx_setlmembase_Instr:
        stdCHECK_WITH_POS(checkTargetArch(gblState, 35), (ptxMsgSMVersionRequired,sourcePos,name,"sm_35") );
        checkFeatureVersion(gblState, 3, 1, name, sourcePos);
        break;
#endif

    case ptx_istypep_Instr:
        stdCHECK_WITH_POS(checkTargetArch(gblState, 30), (ptxMsgSMVersionRequired,sourcePos,name,"sm_30") );
        checkFeatureVersion(gblState, 4, 0, name, sourcePos);
        break;

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    case ptx_fns_Instr:
        stdCHECK_WITH_POS(checkTargetArch(gblState, 30), (ptxMsgSMVersionRequired,sourcePos,name,"sm_30") );
        checkFeatureVersion(gblState, 6, 0, name, sourcePos);
        break;
#endif

    default:
        break;
    }

    stdCHECK_WITH_POS(stdIMPLIES(ptxIsVideoSIMD2Instr(tcode) || ptxIsVideoSIMD4Instr(tcode),
                      checkTargetArch(gblState, 30)), (ptxMsgSMVersionRequired,sourcePos,name,"sm_30"));

    if (ptxIsVideoSIMD2Instr(tcode) || ptxIsVideoSIMD4Instr(tcode))  {
        checkFeatureVersion(gblState, 3, 0, "3.0", sourcePos);
    }
}

static void checkMaxwellInstructions(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    if (tcode == ptx_lop3_Instr) {
        stdCHECK_WITH_POS(checkTargetArch(gblState, 50),
                          (ptxMsgSMVersionRequired,sourcePos,name,"sm_50"));
        checkFeatureVersion(gblState, 4, 3, name, sourcePos);
    }
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    if (tcode == ptx_tex_clamp_Instr || tcode == ptx_tex_grad_clamp_Instr) {
        stdCHECK_WITH_POS( checkTargetArch(gblState, 52), (ptxMsgSMVersionRequired, sourcePos, name, "sm_52") );
        // FIXME: Fix version check based on final POR from where this feature will be supported
        checkFeatureVersion(gblState, 6, 5, name, sourcePos);
    }
#endif
}

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_75)
static void checkMembarProxyInstruction(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    checkFeatureVersion(gblState, 7, 5, name, sourcePos);
    checkFeatureTarget(gblState, 60, name, sourcePos);

    // FIXME: For now error message says .alias as only .alias is supported
    //        Update this later once other proxy kinds are supported
    stdCHECK_WITH_POS(gblState->parseData->modifiers.PROXYKIND, (ptxMsgModifierRequired, sourcePos,
                                                                 ".alias", name));
}
#endif // ISA_75

static void checkPascalInstructions(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    switch (tcode) {
    case ptx_dp4a_Instr:
    case ptx_dp2a_hi_Instr:
    case ptx_dp2a_lo_Instr:
    case ptx_dp2a_Instr:
        stdCHECK_WITH_POS(checkTargetArch(gblState, 61),
                          (ptxMsgSMVersionRequired,sourcePos,name,"sm_61"));
        checkFeatureVersion(gblState, 5, 0, name, sourcePos);
        stdCHECK_WITH_POS(tcode != ptx_dp2a_Instr,
                          (ptxMsgModifierRequired, sourcePos,
                           "'.hi/.lo'", name));
        break;
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_75)
    case ptx_membar_proxy_Instr:
        checkMembarProxyInstruction(gblState, tcode, name, sourcePos);
        break;
#endif
    }
}

#if (LWCFG(GLOBAL_CHIP_T194) || LWCFG(GLOBAL_GPU_IMPL_GV11B) || LWCFG(GLOBAL_ARCH_TURING)) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
#if LWCFG(GLOBAL_ARCH_TURING)

static Bool isSubByteCvtPack(ptxParsingState gblState, uInt nrofTypeMod, uInt typeMod[ptxMAX_INSTR_ARGS])
{
    return  nrofTypeMod == 3 &&  (isI4Mod(gblState->parseData->typeMod[0]) || isI2Mod(gblState->parseData->typeMod[0])) &&
            isS32Mod(gblState->parseData->typeMod[1]) && isB32Mod(gblState->parseData->typeMod[2]);
}
#endif // Turing

static void checkCvtPackInstruction(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    Bool isCorrectType = False;

    checkFeatureTarget(gblState, 72, name, sourcePos);
    checkFeatureVersion(gblState, 6, 5, name, sourcePos);

#if LWCFG(GLOBAL_ARCH_TURING)
    if (isSubByteCvtPack(gblState, gblState->parseData->nrofTypeMod, gblState->parseData->typeMod)) {
        Char feature[] = "cvt.pack with sub-byte type";
        checkFeatureVersion(gblState, 6, 5, feature, sourcePos);
        checkFeatureTarget(gblState, minTuringArch, feature, sourcePos);
        gblState->parseData->modifiers.ATYPE= gblState->parseData->typeMod[0];
        return;
    }
#endif // Turing

    if (gblState->parseData->nrofTypeMod == 2) {
        isCorrectType = isI16Mod(gblState->parseData->typeMod[0]) && isS32Mod(gblState->parseData->typeMod[1]);
    } else {
        isCorrectType = isI8Mod(gblState->parseData->typeMod[0]) && isS32Mod(gblState->parseData->typeMod[1]) && isB32Mod(gblState->parseData->typeMod[2]);
    }
    stdCHECK_WITH_POS(isCorrectType, (ptxMsgNonMatchingInstrTypes, sourcePos, name));

}
#endif

#if LWCFG(GLOBAL_ARCH_VOLTA)

static void checkWarpsyncInstr(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos) {

    checkFeatureVersion(gblState, 6, 0, name, sourcePos);
    checkFeatureTarget(gblState, 70,   name, sourcePos);
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    if (gblState->parseData->modifiers.EXCLUSIVE) {
        Char feature[] = "_warpsync.exclusive";
        checkFeatureTarget(gblState, 80, feature, sourcePos);
        // FIXME: Update version check
        checkFeatureVersion(gblState, 6, 4, feature, sourcePos);
        if (gblState->parseData->nrofArguments != 2) {
            stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrArgs, sourcePos, feature));
            return;
        }
        ptxExpression arg = gblState->parseData->arguments[1];
        stdCHECK_WITH_POS(arg->kind==ptxLabelReferenceExpression ||
                          (arg->kind==ptxSymbolExpression
                           && arg->cases.Symbol.symbol->kind == ptxLabelSymbol),
                          (ptxMsgLabelExpected,sourcePos, 1 ,name));
        return;

    }
#endif
    stdCHECK_WITH_POS((gblState->parseData->nrofArguments == 1), (ptxMsgNonMatchingInstrArgs, sourcePos, name));
    // To support unaligned *sync instructions in EWP mode, macro functions of corresponding
    // instructions with _warpsync should be marked as unique
    if (IsMacroFunc(gblState->parseData->lwrFunc->symbol->name, gblState)) {
        stdASSERT(IsUniqueMacroFunc(gblState->parseData->lwrFunc, gblState),
                  ("Macro functions with _warpsync should be marked as .unique"));
    }
}

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_75)
static void checkFenceProxyInstruction(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    checkFeatureVersion(gblState, 7, 5, name, sourcePos);
    checkFeatureTarget(gblState, 70,    name, sourcePos);

    // FIXME: For now error message says .alias as only .alias is supported
    //        Update this later once other proxy kinds are supported
    stdCHECK_WITH_POS(gblState->parseData->modifiers.PROXYKIND, (ptxMsgModifierRequired, sourcePos,
                                            ".alias", name));
}
#endif // ISA_75

static void checkVoltaInstructions(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    switch (tcode) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    case ptx_errbar_Instr:
    case ptx_nanotrap_Instr:
    case ptx_setctaid_x_Instr:
    case ptx_setctaid_y_Instr:
    case ptx_setctaid_z_Instr:
    case ptx_setctaid_Instr:
    case ptx_yield_Instr:
        checkFeatureVersion(gblState, 6, 0, name, sourcePos);
        checkFeatureTarget(gblState, 70,   name, sourcePos);
        break;
    case ptx__warpsync_Instr:
        checkWarpsyncInstr(gblState, tcode, name, sourcePos);
        break;
    case ptx_sgxt_Instr:
        stdCHECK_WITH_POS( checkTargetArch(gblState, 70), (ptxMsgSMVersionRequired,sourcePos,name,"sm_70") );
        checkFeatureVersion(gblState, 6, 1, name, sourcePos);
        break;
#endif
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_76)
    case ptx_szext_Instr:
        stdCHECK_WITH_POS( checkTargetArch(gblState, 70), (ptxMsgSMVersionRequired,sourcePos,name,"sm_70") );
        checkFeatureVersion(gblState, 7, 6, name, sourcePos);
        break;
#endif
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_76)
    case ptx_bmsk_Instr:
        stdCHECK_WITH_POS( checkTargetArch(gblState, 70), (ptxMsgSMVersionRequired,sourcePos,name,"sm_70") );
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        checkFeatureVersion(gblState, 6, 1, name, sourcePos);
#elif LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_76)
        checkFeatureVersion(gblState, 7, 6, name, sourcePos);
#endif
        break;
#endif
#if ((LWCFG(GLOBAL_CHIP_T194) || LWCFG(GLOBAL_GPU_IMPL_GV11B) || LWCFG(GLOBAL_ARCH_TURING)) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65))
    case ptx_cvt_pack_Instr:
        checkCvtPackInstruction(gblState, tcode, name, sourcePos);
        break;
#endif
#if (LWCFG(GLOBAL_CHIP_T194) || LWCFG(GLOBAL_GPU_IMPL_GV11B))
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
    case ptx_mad_fused_hi_Instr:
    case ptx_madc_fused_hi_Instr:
        stdCHECK_WITH_POS( checkTargetArch(gblState, 72), (ptxMsgSMVersionRequired,sourcePos,name,"sm_72") );
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        checkFeatureVersion(gblState, 6, 0, name, sourcePos);
#else
        if (areExtendedInstructionsEnabled(gblState->parseData)) {
            checkFeatureVersion(gblState, 6, 5, name, sourcePos);
        } else {
            stdCHECK_WITH_POS( False, (ptxMsgUnknownInstructionName,sourcePos,name) );
        }
#endif //Internal
        break;
#endif // 65
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    case ptx_mad_fused_lo_Instr:
    case ptx_madc_fused_lo_Instr:
        stdCHECK_WITH_POS( checkTargetArch(gblState, 72), (ptxMsgSMVersionRequired,sourcePos,name,"sm_72") );
        checkFeatureVersion(gblState, 6, 0, name, sourcePos); // FIXME: Update version check when exposed externally
        break;
#endif //Internal
#endif
#if (LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_62) || LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL))
    case ptx_nanosleep_Instr:
        stdCHECK_WITH_POS( checkTargetArch(gblState, 70), (ptxMsgSMVersionRequired,sourcePos,name,"sm_70"));
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        checkFeatureVersion(gblState, 6, 0, name, sourcePos);
#else
        checkFeatureVersion(gblState, 6, 2, name, sourcePos);
#endif
        break;
#endif // GLOBAL_FEATURE_PTX_ISA_VERSION_62 || GLOBAL_FEATURE_PTX_ISA_INTERNAL
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_75)
    case ptx_fence_proxy_Instr:
        checkFenceProxyInstruction(gblState, tcode, name, sourcePos);
        break;
#endif // ISA_75
    }
}
#endif // GLOBAL_ARCH_VOLTA

#if LWCFG(GLOBAL_ARCH_TURING)

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
static void checkScatterInstruction(ptxParsingState gblState, uInt tcode, cString name,
                                    msgSourcePos_t sourcePos);
#endif

#if (LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65) || (LWCFG(GLOBAL_ARCH_HOPPER) && (LWCFG(GLOBAL_FEATURE_PTX_ISA_FUTURE) || LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL))))
static void checkInstructionArgsForBF16(ptxParsingState gblState, ptxInstructionTemplate template, cString name,
                                        uInt startArg, uInt nrofArguments,
                                        ptxExpression arguments[ptxMAX_INSTR_ARGS],
                                        msgSourcePos_t sourcePos)
{
    /*
     * TODO: This function performs checks for instr args being compatible with
     *       BF16 for cases where template is defined based on BF16 types and
     *       NOT as TYPEMOD (or ATYPE/BTYPE). Once all of the templates are
     *       updated to use BF16 as types, this function is supposed to replace
     *       checkInstructionForBF16.
     */

    uInt i, typeSize = 16;

    for (i = 0; i < template->nrofInstrTypes; i++) {
        if(isBF16x2(gblState->parseData->instructionType[i])) {
            typeSize = 32;
        }
    }

    /*
     * For argument from {startArg, nrofArguments-1}, that has a specified
     * type, only bit type with appropriate type size is allowed.
     */
    for (i = startArg; i < nrofArguments; i++) {
        if (template->argType[i] != ptxFollowAType) {
            stdCHECK_WITH_POS(isBitTypeKind(arguments[i]->type->kind) && ptxGetTypeSizeInBits(arguments[i]->type) == typeSize,
                             (ptxMsgNonMatchingInstrArgs, sourcePos, name));
        }
    }

    /*
     * Explicitly set ATYPE/BTYPE to NoTYPEMODs -- just for transition phase.
     * Once all instructions using BF16/BF16x2 types stop using TYPEMOD we
     * don't need to reset.
     */
    gblState->parseData->modifiers.ATYPE = ptxNOTYPE_MOD;
    gblState->parseData->modifiers.BTYPE = ptxNOTYPE_MOD;
}
#endif // ISA_65 || (HOPPER && (INTERNAL || FUTURE))

#if (LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65) || (LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)))
static void checkInstructionForBF16(ptxParsingState gblState, ptxInstructionTemplate template, cString name,
                                    uInt startArg, uInt nrofArguments,
                                    ptxExpression arguments[ptxMAX_INSTR_ARGS],
                                    msgSourcePos_t sourcePos)
{
    uInt i, typeSize = 16;
    if (gblState->parseData->typeMod[0] == ptxTYPE_BF16x2_MOD || gblState->parseData->typeMod[1] == ptxTYPE_BF16x2_MOD)
        typeSize = 32;
    /*
     * For argument from {startArg, nrofArguments-1}, that has a specified
     * type, only bit type with appropriate type size is allowed.
     */
    for (i = startArg; i < nrofArguments; i++) {
        if (template->argType[i] != ptxFollowAType) {
            stdCHECK_WITH_POS(isBitTypeKind(arguments[i]->type->kind) && ptxGetTypeSizeInBits(arguments[i]->type) == typeSize, 
                             (ptxMsgNonMatchingInstrArgs, sourcePos, name));
        }
    }
    gblState->parseData->modifiers.ATYPE = gblState->parseData->typeMod[0];
    gblState->parseData->modifiers.BTYPE = gblState->parseData->typeMod[1];
}
#endif // ISA_65 || HOPPER && INTERNAL

static void checkTuringInstructions(ptxParsingState gblState, ptxInstructionTemplate template, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    int ptxISAMajorVersionToCheck = 6, ptxISAMinorVersionToCheck = 5, minArchToCheck = 75, featureIsUnsupported = False;
    switch (tcode) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    // FIXME: update version for guard
    case ptx_ttucctl_Instr:
    case ptx__ttust_Instr:
    case ptx__ttuld_Instr:
    case ptx__ttuopen_Instr:
    case ptx__ttugo_Instr:
        stdCHECK_WITH_POS( checkTargetArch(gblState, 75),
                           (ptxMsgFeatureRequiresSMVersion,sourcePos, name, "sm_75") );
        checkFeatureVersion(gblState, 6, 0, name, sourcePos); // FIXME: Update version check
        break;
#endif

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    case ptx__ldsm_Instr:
    case ptx__movm_Instr:
        stdCHECK_WITH_POS(checkTargetArch(gblState, minTuringArch),
                          (ptxMsgFeatureRequiresSMVersion, sourcePos,
                           name, minTuringArchStr));
        checkFeatureVersion(gblState, 6, 3, name, sourcePos);
        break;
    case ptx_scatter_Instr:
        checkScatterInstruction(gblState, tcode, name, sourcePos);
        break;
#endif

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
    case ptx_ldmatrix_Instr:
        stdCHECK_WITH_POS(checkTargetArch(gblState, 75),
                          (ptxMsgFeatureRequiresSMVersion, sourcePos, name, "sm_75"));
        checkFeatureVersion(gblState, 6, 5, name, sourcePos);
        break;
    case ptx_cvt_Instr:
        if (!areExtendedInstructionsEnabled(gblState->parseData)) {
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
            ptxISAMajorVersionToCheck = 7;
            ptxISAMinorVersionToCheck = 0;
            minArchToCheck = 80;
#else
            featureIsUnsupported = True;
#endif // AMPERE && ISA_70
        }
        if (gblState->parseData->nrofTypeMod > 2) {
            // We need to explicitly check total number of type modifiers as instruction template matching
            // will not detect that.
            stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrTypes, sourcePos, name));
            return;
        }
        if (gblState->parseData->nrofTypeMod > 0 && (gblState->parseData->typeMod[0] == ptxTYPE_BF16_MOD || gblState->parseData->typeMod[0] == ptxTYPE_BF16x2_MOD)) {
            if (featureIsUnsupported) {
                stdCHECK_WITH_POS( False, (ptxMsgParsingErrorNonFatal,sourcePos,name,"syntax error") );
                return;
            }
            if (!checkTargetArch(gblState, minArchToCheck) || !checkFeatureVersion1(gblState, ptxISAMajorVersionToCheck, ptxISAMinorVersionToCheck)) {
                char featureName[500];
                sprintf(featureName, "cvt with %s", getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->typeMod[0]));
                checkFeatureTarget(gblState, minArchToCheck, featureName, sourcePos);
                checkFeatureVersion(gblState, ptxISAMajorVersionToCheck, ptxISAMinorVersionToCheck, featureName, sourcePos);
            }
            if (gblState->parseData->typeMod[0] == ptxTYPE_BF16x2_MOD) {
                stdCHECK_WITH_POS(gblState->parseData->nrofArguments == 3, (ptxMsgNonMatchingInstrArgs, sourcePos, name));
            }
            checkInstructionForBF16(gblState, template, name, 0, gblState->parseData->nrofArguments, gblState->parseData->arguments, sourcePos);
        }
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
        else if (gblState->parseData->nrofTypeMod == 2 && gblState->parseData->typeMod[0] == ptxTYPE_f32_MOD && gblState->parseData->typeMod[1] == ptxTYPE_BF16_MOD) {
            if (featureIsUnsupported) {
                stdCHECK_WITH_POS( False, (ptxMsgParsingErrorNonFatal,sourcePos,name,"syntax error") );
                return;
            }
            // Requires ISA 7.1, sm_80+
            if (!checkTargetArch(gblState, 80) || !checkFeatureVersion1(gblState, 7, 1)) {
                char featureName[500];
                sprintf(featureName, "cvt with %s%s", getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->typeMod[0]),
                                                      getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->typeMod[1]));
                checkFeatureTarget(gblState, 80, featureName, sourcePos);
                checkFeatureVersion(gblState, 7, 1, featureName, sourcePos);
            }
            checkInstructionForBF16(gblState, template, name, 0, gblState->parseData->nrofArguments, gblState->parseData->arguments, sourcePos);
        }
#endif // AMPERE && ISA_71
        else if (gblState->parseData->nrofInstructionTypes == 2   &&
                 isF16x2(gblState->parseData->instructionType[0]) &&
                 !isF8x2(gblState->parseData->instructionType[1]))
            {
            if (featureIsUnsupported) {
                stdCHECK_WITH_POS( False, (ptxMsgParsingErrorNonFatal,sourcePos,name,"syntax error") );
                return;
            }
            if (!checkTargetArch(gblState, minArchToCheck) || !checkFeatureVersion1(gblState, ptxISAMajorVersionToCheck, ptxISAMinorVersionToCheck)) {
                char featureName[500];
                sprintf(featureName, "cvt with %s", getTYPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->instructionType[0]));
                checkFeatureTarget(gblState, minArchToCheck, featureName, sourcePos);
                checkFeatureVersion(gblState, ptxISAMajorVersionToCheck, ptxISAMinorVersionToCheck, featureName, sourcePos);
            }
            stdCHECK_WITH_POS(gblState->parseData->nrofArguments == 3, (ptxMsgNonMatchingInstrArgs, sourcePos, name));
        }
        break;
#endif // ISA_65
    }
}

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)

static Bool isAllowedInstrInTTUBlock(uInt tcode)
{
    return tcode == ptx_mov_Instr;
}

void checkValidTTUBlock(uInt tcode, ptxParsingState ptxIR, String name,
                           msgSourcePos_t sourcePos)
{
    if (tcode == ptx__ttuopen_Instr) {
        stdCHECK_WITH_POS(ptxIR->parsingTTUBlock == False,
                          (ptxMsgMultipleTTUOpenInstr, sourcePos, name, "TTU"));
       ptxIR->parsingTTUBlock = True;
       return;
    }

    if (ptxIR->parsingTTUBlock) {
        stdCHECK_WITH_POS(ptxIsTTUInstr(tcode) || isAllowedInstrInTTUBlock(tcode),
                          (ptxMsgIlwalidInstrInTTUBlock, sourcePos, name, "TTU"));

        if (tcode == ptx__ttuld_Instr && ptxHasTTU_MOD(ptxIR->parseData->modifiers)/*.close*/) {
            ptxIR->parsingTTUBlock = False;
        }

        return;
    }

    stdCHECK_WITH_POS( !ptxIsTTUInstrExceptTTUCCL(tcode),
                       (ptxMsgMisplacedTTUInstr, sourcePos, name, "TTU"));
}
#endif

#endif // GLOBAL_ARCH_TURING

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkDestroyInstruction(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    Int64 size;
    stdASSERT(tcode == ptx_destroy_Instr,
             ("Any instruction other than destroy should not reach here"));
    checkFeatureTarget(gblState, 80,   name, sourcePos);
    // FIXME: Update version check
    checkFeatureVersion(gblState, 6, 3, name, sourcePos);
    stdASSERT(gblState->parseData->arguments[1]->kind == ptxIntConstantExpression,
             ("Incorrect template is matched for destroy"));

    size = gblState->parseData->arguments[1]->cases.IntConstant.i;
    stdCHECK_WITH_POS(size == 128, (ptxMsgArgValueUnexpected,
                                    sourcePos, 2, name, size, "128"));
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
static void checkDiscardInstruction(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    Int64 size;
    stdASSERT(tcode == ptx_discard_Instr,
             ("Any instruction other than discard should not reach here"));
    checkFeatureTarget(gblState, 80,   name, sourcePos);
    checkFeatureVersion(gblState, 7, 4, name, sourcePos);

    // .L2 required
    stdCHECK_WITH_POS(gblState->parseData->modifiers.LEVEL, (ptxMsgModifierRequired, sourcePos,
                                        getLEVELAsString(ptxL2_MOD), name));

    size = ptxGetImmediateIntVal(gblState->parseData->arguments[1]);

#if LWCFG(GLOBAL_ARCH_ADA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    // ADA introduced per-sector ilwalidation, with sector granularity in CCTL.RML2 instr
    // 1, 2, 3, 4 being valid sector counts which correspond to 32, 64, 96, 128 bytes
    switch(size) {
    case 32:
    case 64:
    case 96:
        checkFeatureTarget(gblState, 89, "discard size 32/64/96", sourcePos);
        // FIXME: update version check
        checkFeatureVersion(gblState, 7, 6, "discard size 32/64/96", sourcePos);
        break;
    case 128:
        break;
    default:
        stdCHECK_WITH_POS(False, (ptxMsgArgValueUnexpected, sourcePos, 2, name, size,
                                  // only sm_89+ has 32/64/96/128 as valid values
                                  checkTargetArch(gblState, 89) ? "32/64/96/128" : "128"));
        break;
    }
#else
    stdCHECK_WITH_POS(size == 128, (ptxMsgArgValueUnexpected, sourcePos, 2, name, size, "128"));
#endif
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && (LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71))
static void checkCachepolicyInstruction(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    stdASSERT(tcode == ptx_cachepolicy_Instr,
             ("Any instruction other than cachepolicy should not reach here"));
    checkFeatureTarget(gblState, 80,   name, sourcePos);
    // 7.1 for release, 6.3 for internal.
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    checkFeatureVersion(gblState, 6, 3, name, sourcePos);
#else
    checkFeatureVersion(gblState, 7, 1, name, sourcePos);
#endif
    stdCHECK_WITH_POS(gblState->parseData->nrofEvictPriorityMod > 0,(ptxMsgModifierRequired, sourcePos,
                                                "cache eviction priority" , name));
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
static void checkApplypriorityInstruction(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    Int64 size;

    stdASSERT(tcode == ptx_applypriority_Instr,
             ("Any instruction other than applypriority should not reach here"));

    checkFeatureTarget(gblState, 80,   name, sourcePos);
    checkFeatureVersion(gblState, 7, 4, name, sourcePos);

    stdCHECK_WITH_POS(gblState->parseData->nrofEvictPriorityMod != 0,
                      (ptxMsgModifierRequired, sourcePos, "cache eviction priority", name));
    stdCHECK_WITH_POS((gblState->parseData->modifiers.LEVEL || gblState->parseData->nrofLevelColonMod != 0),
                      (ptxMsgModifierRequired, sourcePos, getLEVELAsString(ptxL2_MOD), name));

    size = ptxGetImmediateIntVal(gblState->parseData->arguments[1]);

    stdCHECK_WITH_POS(size == 128, (ptxMsgArgValueUnexpected,
                                    sourcePos, 2, name, size, "128"));
}

static void checkArgsForCreatepolicyInstruction(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    if (tcode == ptx_createpolicy_cvt_Instr) {
        return;
    }

    if (tcode == ptx_createpolicy_fractional_Instr &&
        gblState->parseData->nrofArguments == 2 && gblState->parseData->arguments[1]->kind == ptxFloatConstantExpression)
    {
        Float fraction = ptxGetF32FloatConstantExpr(gblState->parseData->arguments[1]);
        stdCHECK_WITH_POS((0.0 < fraction && fraction <= 1.0),
                          (ptxMsgFloatArgValOutOfRangeExclMin, sourcePos, 2, name, fraction, 0.0, 1.0));
    }

    if (tcode == ptx_createpolicy_range_Instr &&
        gblState->parseData->arguments[2]->kind == ptxIntConstantExpression && gblState->parseData->arguments[3]->kind == ptxIntConstantExpression)
    {
        uInt primary_size = ptxGetImmediateIntVal(gblState->parseData->arguments[2]);
        uInt total_size = ptxGetImmediateIntVal(gblState->parseData->arguments[3]);

        stdCHECK_WITH_POS(primary_size <= total_size,
                          (ptxMsgIlwalidRelativeValue, sourcePos, 3, name, primary_size,
                           "less than or equal to", total_size, 4));
    }
}

static void checkModifiersForCreatepolicyInstruction(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    if (tcode == ptx_createpolicy_fractional_Instr ||
        tcode == ptx_createpolicy_range_Instr)
    {
        stdCHECK_WITH_POS((gblState->parseData->nrofEvictPriorityMod != 0),
                          (ptxMsgModifierRequired, sourcePos, "cache eviction priority", name));
    }
    stdCHECK_WITH_POS((gblState->parseData->modifiers.LEVEL || gblState->parseData->nrofLevelColonMod != 0),
                      (ptxMsgModifierRequired, sourcePos, getLEVELAsString(ptxL2_MOD), name));
}

static void checkCreatepolicyInstruction(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    stdASSERT((tcode == ptx_createpolicy_fractional_Instr ||
               tcode == ptx_createpolicy_range_Instr ||
               tcode == ptx_createpolicy_cvt_Instr),
              ("Unexpected createpolicy variant"));
    checkFeatureTarget(gblState, 80,   name, sourcePos);
    checkFeatureVersion(gblState, 7, 4, name, sourcePos);

    checkModifiersForCreatepolicyInstruction(gblState, tcode, name, sourcePos);
    checkArgsForCreatepolicyInstruction(gblState, tcode, name, sourcePos);
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkClmadInstruction(ptxParsingState gblState, uInt tcode, cString name, uInt nrofInstructionTypes,
                                  ptxType instructionType[ptxMAX_INSTR_ARGS], ptxOperator postop,
                                  ptxExpression arguments[ptxMAX_INSTR_ARGS], 
                                  msgSourcePos_t sourcePos)
{
    // FIXME: Update version check
    checkFeatureVersion(gblState, 6, 4, name, sourcePos);
    checkFeatureTarget(gblState, 80,   name, sourcePos);
}
#endif  // AMPERE && INTERNAL

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkSourceSizeArgForCopyInstr(ptxParsingState gblState, cString name, msgSourcePos_t sourcePos)
{
    Bool usesCorrectType = False;
    Int64 cpSize, srcSize;
    // Parser was linient till now (useLenientCheckForDesc) for arg3.
    // So check types here more precisely :
    usesCorrectType = gblState->parseData->arguments[3]->kind == ptxIntConstantExpression ||
        isB32(gblState->parseData->arguments[3]->type) || isI32(gblState->parseData->arguments[3]->type);

    if (!usesCorrectType) {
        stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrArgs, sourcePos, name));
        return;
    }
    if (!ptxIsImmediateExpr(gblState->parseData->arguments[3])){
        return;
    }
    cpSize = gblState->parseData->arguments[2]->cases.IntConstant.i;
    srcSize = ptxGetImmediateIntVal(gblState->parseData->arguments[3]);
    stdCHECK_WITH_POS(0 <= srcSize && srcSize <= cpSize,
                      (ptxMsgArgValueOutOfRange, sourcePos, 3, name,
                       srcSize, 0, cpSize));
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
// checks second argument of Internal And Public variants of
// cp.async.ca/cg.shared.global.{desc}

static Bool checkArg2ForCopyInstr(ptxParsingState gblState, cString name, msgSourcePos_t sourcePos)
{
    Int64 cpSize;
    Bool isCorrectCpSize = False;
    String correctCpSizeExpected = NULL;

    if (gblState->parseData->nrofArguments < 3) {
        stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrArgs, sourcePos, name));
        return False;
    }
    if (!ptxIsImmediateExpr(gblState->parseData->arguments[2])) {
        stdCHECK_WITH_POS(False, (ptxMsgConstantArgRequired, sourcePos, 2, name));
        return False;
    }
    if (!(gblState->parseData->modifiers.CACHEOP == ptxCA_MOD || gblState->parseData->modifiers.CACHEOP == ptxCG_MOD)) {
        // Cannot produce accurate error message if wrong cache op is specified.
        // So skipping ArgValueUnexpected error.
        // Note: wrong cache op is caught in checkModifiersForCopyInstr()
        return False;
    }

    cpSize = gblState->parseData->arguments[2]->cases.IntConstant.i;

    if (gblState->parseData->modifiers.CACHEOP == ptxCA_MOD) {
        isCorrectCpSize = (cpSize == 4 || cpSize == 8 || cpSize == 16);
        correctCpSizeExpected = "4 or 8 or 16";
    } else {
        stdASSERT(gblState->parseData->modifiers.CACHEOP == ptxCG_MOD, ("unexpected cacheop"));
        isCorrectCpSize = (cpSize == 16);
        correctCpSizeExpected = "16";
    }
    stdCHECK_WITH_POS(isCorrectCpSize, (ptxMsgArgValueUnexpected, sourcePos, 2,
                                        name, cpSize, correctCpSizeExpected));
    return True;
}
#endif

static void printErrorForDESCOrCACHEHINTRequired(ptxInstructionTemplate template, uInt nargs,
                                                 cString name, msgSourcePos_t sourcePos)
{
    if (!(ptxHasCACHEHINT_Feature(template->features) || ptxHasDESC_Feature(template->features))) {
        return;
    }
#if LWCFG(GLOBAL_ARCH_AMPERE)
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
    stdCHECK_WITH_POS(False, (ptxMsgModifierRequiredWithArgs, sourcePos, getCACHEHINTAsString(ptxCACHEHINT_MOD), name, nargs));
#elif LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    stdCHECK_WITH_POS(False, (ptxMsgModifierRequiredWithArgs, sourcePos, getDESCAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxDESC_MOD), name, nargs));
#endif
#endif
}

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_75)
static void checkIgnoreSrcArgForCopyInstr(ptxParsingState gblState, cString name, uInt tcode, Bool hasDescOrCachehintMod, msgSourcePos_t sourcePos)
{
    Bool hasIgnoreSrc = isIgnoreSrcPresentForCopyInstruction(tcode, gblState->parseData->arguments, gblState->parseData->nrofArguments);

    if (!hasIgnoreSrc) {
        return;
    }
    checkFeatureVersion(gblState, 7, 5, "igonre-src on cp.async", sourcePos);
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkArgsForCopyInstr(ptxParsingState gblState, ptxInstructionTemplate template,
                                        uInt tcode, cString name,
                                        msgSourcePos_t sourcePos)
{
    Bool hasSrcSizeArg = False, needsFurtherChecking = False, hasCachehintMod;
    int  maxCopyArg;
    if (tcode != ptx_cp_async_Instr) {
        return;
    }
    hasCachehintMod = ptxHasCACHEHINT_MOD(gblState->parseData->modifiers);
    Bool hasDescOrCachehintMod = ptxHasDESC_MOD(gblState->parseData->modifiers) || hasCachehintMod;
    maxCopyArg = (isMemDescAvailableForPublicInstr(gblState) || hasCachehintMod)? 5: 4;
    if (gblState->parseData->nrofArguments > maxCopyArg)
    {
        printErrorForDESCOrCACHEHINTRequired(template, gblState->parseData->nrofArguments, name, sourcePos);
        stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrArgs, sourcePos, name));
        return;
    }
    needsFurtherChecking = checkArg2ForCopyInstr(gblState, name, sourcePos);
    if (!needsFurtherChecking)
        return;

    if (gblState->parseData->nrofArguments == 3) {
        // nothing else to check
        return;
    }
    // only instructions with nrOfArguments > 3 are expected
    // to reach here.
    if (gblState->parseData->nrofArguments == 5 && !hasDescOrCachehintMod) {
        printErrorForDESCOrCACHEHINTRequired(template, gblState->parseData->nrofArguments, name, sourcePos);
        stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrArgs, sourcePos, name));
        return;
    }

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_75)
    checkIgnoreSrcArgForCopyInstr(gblState, name, tcode, hasDescOrCachehintMod, sourcePos);
#endif

    hasSrcSizeArg = isSrcSizePresentForCopyInstruction(tcode, gblState->parseData->arguments, gblState->parseData->nrofArguments,
                                                       hasDescOrCachehintMod);
    if (hasSrcSizeArg) {
        checkSourceSizeArgForCopyInstr(gblState, name, sourcePos);
    }
    //memdesc arg check is handled by template arg check
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkCopyInstruction(ptxParsingState gblState, ptxInstructionTemplate template,
                                 uInt tcode, cString name,
                                 msgSourcePos_t sourcePos)
{
    checkFeatureVersion(gblState, 7, 0, name, sourcePos);
    checkFeatureTarget(gblState, 80,   name, sourcePos);
    checkArgsForCopyInstr(gblState, template, tcode, name, sourcePos);
}
#endif // ampere && 70

static Bool isNativeMultiArriveSupportedForMbarrierInstr(ptxParsingState gblState) {
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    return checkTargetArch(gblState, 90) && checkFeatureVersion1(gblState, 7, 2);
#else
    return False;
#endif
}

#if (LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)) || (LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL))
static void checkArg2ForMbarrierInstr(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    Int64 arg2;
    if (gblState->parseData->nrofArguments < 3) {
        return;
    }
    if (!isImmediate(gblState->parseData->arguments[2])) {
        return;
    }
    switch (tcode) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71) || (LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL))
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
    case ptx_mbarrier_test_wait_parity_Instr:
#endif // ISA 71
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    case ptx_mbarrier_try_wait_parity_Instr:
#endif // Hopper && Internal
        // test_wait/try_wait.parity
        // immediate arg[2] must be 0 or 1
        arg2 = ptxGetImmediateIntVal(gblState->parseData->arguments[2]);
        stdCHECK_WITH_POS(0 == arg2 || arg2 == 1, (ptxMsgArgValueUnexpected, sourcePos,
                                                   2, name, arg2, "0 or 1"));
        return;
#endif // ISA 71 || (Hopper && Internal)
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptx_mbarrier_arrive_Instr:
    case ptx_mbarrier_arrive_drop_Instr:
        // multi-arrive / multi-arrive_drop
        arg2 = ptxGetImmediateIntVal(gblState->parseData->arguments[2]);
        stdCHECK_WITH_POS(arg2 > 0, (ptxMsgArgValBeMoreThanOne, sourcePos,
                                     2, name, arg2));
        return;
#endif // ISA 70
    default:
        stdASSERT(False, ("unexpected mbarrier variant"));
        return;
    }
}
#endif // (Ampere && ISA 70) || (Hopper && Internal)

#if (LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)) || (LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL))
static void checkArgsForMbarrierInstr(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    String featureName;
    if (tcode == ptx_mbarrier_try_wait_Instr ||
        tcode == ptx_mbarrier_try_wait_parity_Instr)
    {
        stdCHECK_WITH_POS(stdIMPLIES(ptxHasNOSLEEP_MOD(gblState->parseData->modifiers), gblState->parseData->nrofArguments == 3),
                          (ptxMsgNonMatchingInstrArgs, sourcePos, name));
    }
    if ((tcode == ptx_mbarrier_arrive_Instr ||
         tcode == ptx_mbarrier_arrive_drop_Instr) &&
        !ptxHasNOCOMPLETE_MOD(gblState->parseData->modifiers) &&
        gblState->parseData->nrofArguments == 3)
    {
        featureName  = stdCONCATSTRING(name, " with count argument and without '.noComplete' modifier");
        checkFeatureVersion(gblState, 7, 2, featureName, sourcePos);
        checkFeatureTarget(gblState, 90, featureName, sourcePos);
    }
#endif
    if (tcode != ptx_mbarrier_arrive_Instr &&
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
        tcode != ptx_mbarrier_test_wait_parity_Instr &&
#endif
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        tcode != ptx_mbarrier_try_wait_parity_Instr &&
#endif
        tcode != ptx_mbarrier_arrive_drop_Instr)
    {
        return;
    }
    checkArg2ForMbarrierInstr(gblState, tcode, name, sourcePos);
}
#endif

#if (LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)) || (LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL))
static void checkMbarrierInstructions(ptxParsingState gblState, uInt tcode, String name,
                                      msgSourcePos_t sourcePos)
{
    int maxVersion = 7, milwersion = 0, target = 80;
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
    if (tcode == ptx_mbarrier_test_wait_parity_Instr)
        milwersion = 1;
#endif
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    if (tcode == ptx_mbarrier_try_wait_Instr     ||
        tcode == ptx_mbarrier_try_wait_parity_Instr)
    {
        milwersion = 1;
        target     = 90;
    } else if (tcode == ptx_mbarrier_expect_tx_Instr             ||
               tcode == ptx_mbarrier_arrive_expect_tx_Instr      ||
               tcode == ptx_mbarrier_arrive_drop_expect_tx_Instr ||
               tcode == ptx_mbarrier_expect_copy_Instr           ||
               tcode == ptx_mbarrier_arrive_expect_copy_Instr    ||
               tcode == ptx_mbarrier_arrive_drop_expect_copy_Instr)
    {
        milwersion = 2;
        target = 90;
    }
    stdCHECK_WITH_POS((tcode != ptx_mbarrier_expect_copy_Instr           &&
                       tcode != ptx_mbarrier_arrive_expect_copy_Instr    &&
                       tcode != ptx_mbarrier_arrive_drop_expect_copy_Instr),
                      (ptxMsgModDeprecateSoonWithHint, sourcePos,
                       ".expect_copy", "mbarrier", ".expect_tx"));
#endif
    checkFeatureVersion(gblState, maxVersion, milwersion, name, sourcePos);
    checkFeatureTarget(gblState, target,   name, sourcePos);

    checkArgsForMbarrierInstr(gblState, tcode, name, sourcePos);
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_COMPUTE_COMPILER_INTERNAL)
    // error on sm8x for mbarrier on merlwry
    if (checkCompilationArch(gblState, 80) && !checkCompilationArch(gblState, 90)) {
        ptxSetNonMercFeatureUsed(gblState, ptxMbarrierInstruction);
    }
#endif
}
#endif

#define isB0B3(sel) (sel == ptxBYTE_B0 || sel == ptxBYTE_B1 ||\
                     sel == ptxBYTE_B2 || sel == ptxBYTE_B3)
#define isB01B12B23(sel) (sel == ptxBYTE_B01 || sel == ptxBYTE_B12 || sel == ptxBYTE_B23)
#define isH0H1(sel) (sel == ptxBYTE_H0 || sel == ptxBYTE_H1)

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
/*
_________________________________________
           |          |                  |
   elesize | idx Size | selector allowed |
___________|__________|__________________|
           |          |                  |
    .b8    |   .b4    |    .h0, .h1      |
___________|__________|__________________|
           |          |                  |
    .b8    |   .b8    |       NA         |
___________|__________|__________________|
           |          |                  |
    .b16   |   .b4    |.b0,.b1,.b2,.b3   |
___________|__________|__________________|
           |          |                  |
    .b16   |   .b8    |    .h0, .h1      |
___________|__________|__________________|
*/
static void checkSelectorForSpmetadata(ptxParsingState gblState, cString name,
                                       uInt nrofInstructionTypes,
                                       ptxType instructionType[ptxMAX_INSTR_ARGS],
                                       uInt nrofTypeMod,
                                       uInt typeMod[ptxMAX_INSTR_ARGS],
                                       ptxModifier modifiers,
                                       ptxExpression arguments[ptxMAX_INSTR_ARGS],
                                       msgSourcePos_t sourcePos)
{
    uInt selector;
    String elSize  = getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxElSize_STR);
    String idxSize = getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxIdxSize_STR);

    if (nrofInstructionTypes  < 1 || nrofTypeMod != 2) {
        // Do not proceed if elSize/idxsize is incorrect
        return;
    }
    if (nrofInstructionTypes == 2 && isB8(gblState->parseData->instructionType[0]) && isB8(gblState->parseData->instructionType[1])) {
         stdCHECK_WITH_POS(arguments[1]->kind != ptxByteSelectExpression,
                          (ptxMsgByteSelectorNotAllowedForMods, sourcePos,
                          stdCONCATSTRING(elSize, ".b8"),
                          stdCONCATSTRING(idxSize, ".b8")));
        return;
    }

    if (arguments[1]->kind != ptxByteSelectExpression) {
        stdCHECK_WITH_POS(False, (ptxMsgByteWordSelectorRequired, sourcePos, 1, name));
        return;
    }
    selector = arguments[1]->cases.ByteSelect->selector[0];
    stdCHECK_WITH_POS(typeMod[0] == ptxTYPE_b16_MOD && typeMod[1] == ptxTYPE_b4_MOD ?
                      isB0B3(selector) : isH0H1(selector),
                      (ptxMsgMismatchByteSelectorForMods, sourcePos,
                      stdCONCATSTRING(elSize, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, typeMod[0])),
                      stdCONCATSTRING(idxSize, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, typeMod[1]))));
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
// TODO: Similar vecidx range callwlation is required for scatter.sp
//       use same function to perform check common to both instructions
static int callwlateVecIdxMaxVal(uInt nrofTypes, ptxType lwrType, ptxModifier mods)
{
    uInt nrOfThread = 1, eleSize, idxSize;

    if (!lwrType) {
        // Do early exit if instruction type is invalid
        return 1;
    }
    eleSize = isB16(lwrType) ? 16 : 8;

    // idxSize '.b8' is represented as second instruction type and '.b4' as type modifier
    idxSize = nrofTypes == 2 ? 8  : 4;
    switch (mods.THREADGROUP) {
    case ptxTGTHREAD_MOD : nrOfThread = 1;  break;
    case ptxTGPAIR_MOD   : nrOfThread = 2;  break;
    case ptxTGQUAD_MOD   : nrOfThread = 4;  break;
    default              : return 1;
    }
    // check vecidx
    return (((1 << idxSize) / ((32*nrOfThread) / eleSize)) / 2) - 1;
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkSpmetadataArgRange(ptxExpression arg, int argIndex, int milwal, int maxVal,
                                    cString name, msgSourcePos_t sourcePos)
{
    uInt64 val;
    if (!arg) {
        // Do early exit if instruction arg is invalid
        return;
    }
    if (arg->kind != ptxIntConstantExpression) {
        stdCHECK_WITH_POS(False, (ptxMsgConstantArgRequired, sourcePos,
                                  argIndex, name));
        return;
    }
    val = arg->cases.IntConstant.i;
    stdCHECK_WITH_POS((milwal <= val && val <= maxVal),
                      (ptxMsgArgValueOutOfRange, sourcePos, argIndex,
                       name, val, milwal, maxVal));
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
/*
______________________________________
           |            |            |
   elesize | Mask Range | slot range |
___________|____________|____________|
           |            |            |
    .b8    |   [0-15]   |   [0-3]    |
___________|____________|____________|
           |            |            |
    .b16   |   [0-3]    |   [0-7]    |
___________|____________|____________|
*/
static void checkMaskAndSlotForSpmetadata(ptxParsingState gblState, cString name,
                                          uInt nrofInstructionTypes,
                                          ptxType instructionType[ptxMAX_INSTR_ARGS],
                                          ptxExpression arguments[ptxMAX_INSTR_ARGS],
                                          msgSourcePos_t sourcePos)
{
    Int64 val;
    ptxExpression arg;
    String elSize  = getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxElSize_STR);
    Int milwal = 0, setBitsInMask = 0, i, maxVal;
    for(i = 3; i < 5; ++i)
    {
        arg = arguments[i];
        if (!arg || nrofInstructionTypes < 1) {
            // Do not proceed if instruction arg/type is invalid
            continue;
        }
        if (arg->kind != ptxIntConstantExpression) {
            stdCHECK_WITH_POS(False, (ptxMsgConstantArgRequired, sourcePos,
                                      i, name));
            return;
        }

        val = arg->cases.IntConstant.i;
        if (i == 3) {
            // mask argument
            maxVal = isB16(gblState->parseData->instructionType[0]) ? 3 : 15;
            setBitsInMask = stdNrofBits32(val);
            stdCHECK_WITH_POS(setBitsInMask <= 2, (ptxMsgConstArgMaxNoBitsSet, sourcePos,
                                                   3, name, 2));
        }  else {
            // slot argument
            maxVal = isB16(gblState->parseData->instructionType[0]) ? 7 : 3;
        }
        stdCHECK_WITH_POS((milwal <= val && val <= maxVal),
                          (ptxMsgArgValueOutOfRangeMod, sourcePos, i,
                           name, val, milwal, maxVal,
                           stdCONCATSTRING(elSize, getTYPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->instructionType[0]))));
    }
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkArgsForSpmetadata(ptxParsingState gblState, cString name,
                                   uInt nrofInstructionTypes,
                                   ptxType instructionType[ptxMAX_INSTR_ARGS],
                                   uInt nrofTypeMod,
                                   ptxModifier modifiers,
                                   ptxExpression arguments[ptxMAX_INSTR_ARGS],
                                   msgSourcePos_t sourcePos)
{
    int maxVal;

    if (nrofInstructionTypes  < 1 || nrofTypeMod != 2) {
        // Do not proceed if elSize/idxsize is incorrect
        return;
    }
    
    maxVal = callwlateVecIdxMaxVal(nrofInstructionTypes, gblState->parseData->instructionType[0], gblState->parseData->modifiers);
    if (maxVal < 0) {
        String threadGroupStr = stdCONCATSTRING("in mode ", get_strTHREADGROUP(gblState->parseData));
        stdCHECK_WITH_POS(False,
                          (ptxMsgIlwalidCombinationForInstr, sourcePos, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->typeMod[0]),
                           getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->typeMod[1]), name, threadGroupStr));
        stdFREE(threadGroupStr);
        return;
    }
    checkSpmetadataArgRange(arguments[2], 2, 0, maxVal, name, sourcePos);
    checkMaskAndSlotForSpmetadata(gblState, name, nrofInstructionTypes, instructionType,
                                  arguments, sourcePos);
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkInstrTypeForSpmetadata(ptxParsingState gblState, cString name,
                                        uInt nrofInstructionTypes,
                                        ptxType instructionType[ptxMAX_INSTR_ARGS],
                                        uInt nrofTypeMod,
                                        uInt typeMod[ptxMAX_INSTR_ARGS],
                                        msgSourcePos_t sourcePos)
{
    if (nrofInstructionTypes < 1) {
        stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrTypes, sourcePos, name));
        return;
    }
    if (nrofTypeMod != 2) {
        // Error out if incorrect type gblState->parseData->modifiers are passed
        stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrTypes, sourcePos, name));
        return;
    }
    if (isB16(instructionType[0])) {
        stdCHECK_WITH_POS(typeMod[0] == ptxTYPE_b16_MOD &&
                          (typeMod[1] == ptxTYPE_b8_MOD || typeMod[1] == ptxTYPE_b4_MOD),
                          (ptxMsgNonMatchingInstrTypes, sourcePos, name));
    } else if (isB8(instructionType[0])) {
        stdCHECK_WITH_POS(typeMod[0] == ptxTYPE_b8_MOD &&
                          (typeMod[1] == ptxTYPE_b8_MOD || typeMod[1] == ptxTYPE_b4_MOD),
                          (ptxMsgNonMatchingInstrTypes, sourcePos, name));
    } else {
        stdASSERT(False, ("Incorrect template is matched for spmetadata"));
    }
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkInstrModifiersForSpmetadata(cString name, ptxModifier modifiers,
                                             msgSourcePos_t sourcePos)
{
    char modifierName[] = "mode";
    stdCHECK_WITH_POS(modifiers.THREADGROUP, (ptxMsgModifierRequired, sourcePos,
                                              modifierName, name));
}

static void checkSpmetadataInstruction(ptxParsingState gblState, uInt tcode, cString name,
                                       uInt nrofInstructionTypes,
                                       ptxType instructionType[ptxMAX_INSTR_ARGS],
                                       uInt nrofTypeMod,
                                       uInt typeMod[ptxMAX_INSTR_ARGS],
                                       ptxModifier modifiers,
                                       ptxExpression arguments[ptxMAX_INSTR_ARGS],
                                       msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    checkFeatureVersion(gblState, 6, 4, name, sourcePos);
#else
    checkFeatureVersion(gblState, 7, 0, name, sourcePos);
#endif
    checkFeatureTarget(gblState, 80,   name, sourcePos);

    checkInstrTypeForSpmetadata(gblState, name, nrofInstructionTypes, instructionType,
                                nrofTypeMod, typeMod, sourcePos);

    checkInstrModifiersForSpmetadata(name, modifiers, sourcePos);

    checkSelectorForSpmetadata(gblState, name, nrofInstructionTypes, instructionType,
                               nrofTypeMod, typeMod, modifiers,
                               arguments, sourcePos);

    checkArgsForSpmetadata(gblState, name, nrofInstructionTypes, instructionType, nrofTypeMod, modifiers,
                           arguments, sourcePos);
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static uInt callwlateInputDataWidthForGatherGenMetadata(uInt elSizeMod, uInt groupMod)
{
    return ptxGetTypeModSize(elSizeMod) * 4 * ptxGetNumOfGroups(groupMod);
}

static void checkArgsForGather(ptxParsingState gblState, cString name,
                               uInt nrofInstructionTypes,
                               ptxType instructionType[ptxMAX_INSTR_ARGS],
                               uInt nrofArguments,
                               ptxExpression arguments[ptxMAX_INSTR_ARGS],
                               msgSourcePos_t sourcePos)
{
    uInt dataWidth;
    Int64 val;
    String elSize  = getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxElSize_STR);
    String idxSize = getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxIdxSize_STR);
    ptxByteSelector selector;

    if (nrofArguments != 5 || gblState->parseData->modifiers.GROUP == ptxNOGROUP_MOD) {
        // Do early exit if instruction arguments/modifiers are invalid
        return;
    }

    dataWidth = callwlateInputDataWidthForGatherGenMetadata(gblState->parseData->typeMod[0],
                                                            gblState->parseData->modifiers.GROUP);

    if (arguments[0]->kind == ptxByteSelectExpression) {
       selector = arguments[0]->cases.ByteSelect->selector[0];
       stdCHECK_WITH_POS(((isH0H1(selector) && dataWidth == 32) || (isB0B3(selector) && dataWidth == 16)),
                         (ptxMsgArgIllegalByteSelectMods, sourcePos, 0, name,
                          stdCONCATSTRING(elSize, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->typeMod[0])),
                          getGROUPAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.GROUP)));

    } else if (dataWidth == 32 || dataWidth == 16) {
        // Generate default selector if no selector is specified
        selector = (dataWidth == 32) ? ptxBYTE_H0 : ptxBYTE_B0;
        arguments[0] =  ptxCreateByteSelectExpr(arguments[0], 1, &selector);
    }

    // We do not create default selector for source argument as it can be immediate
    // instead we will directly default value to subop
    if (arguments[1]->kind == ptxByteSelectExpression) {
        selector = arguments[1]->cases.ByteSelect->selector[0];
        stdCHECK_WITH_POS((isH0H1(selector) && dataWidth == 16),
                          (ptxMsgArgIllegalByteSelectMods, sourcePos,  1, name,
                           stdCONCATSTRING(elSize, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->typeMod[0])),
                           getGROUPAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.GROUP)));
    }


    if (arguments[4]->kind != ptxIntConstantExpression) {
        stdCHECK_WITH_POS(False, (ptxMsgConstantArgRequired, sourcePos,
                                  4, name));
        return;
    }
    val = arguments[4]->cases.IntConstant.i;

    if (0 > val || val > 15) {
        stdCHECK_WITH_POS(False, (ptxMsgArgValueOutOfRange, sourcePos, 4, name,
                          val, 0, 15));
    }
    if (val) {
        uInt idx = ptxGetTypeModSize(gblState->parseData->typeMod[1]);
        uInt metadataSize = (val*idx) + (idx*2*ptxGetNumOfGroups(gblState->parseData->modifiers.GROUP));
        stdCHECK_WITH_POS((metadataSize <= 32),
                          (ptxMsgArgValueIllegalMods, sourcePos, 4, name, val,
                           stdCONCATSTRING(idxSize, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->typeMod[1])),
                           getGROUPAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.GROUP)));
        stdCHECK_WITH_POS((val % 2 == 0), (ptxMsgArgValueReqMultiple, sourcePos, 4, name,
                                           val, 2));

    }
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkCommonModsForGatherGenmetadata(ptxParsingState gblState, cString name,
                                                uInt nrofTypeMod,
                                                uInt typeMod[ptxMAX_INSTR_ARGS],
                                                msgSourcePos_t sourcePos,
                                                cString elStr, cString idxStr)
{
    if (gblState->parseData->modifiers.GROUP == ptxNOGROUP_MOD) {
        stdCHECK_WITH_POS(False, (ptxMsgModifierRequired, sourcePos, ".group", name));
        return;
    }

    uInt dataWidth = callwlateInputDataWidthForGatherGenMetadata(typeMod[0],
                                                                gblState->parseData->modifiers.GROUP);

    stdCHECK_WITH_POS(dataWidth <= 64,
                      (ptxMsgIllegalModifierWithMod, sourcePos,
                       getGROUPAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.GROUP), name,
                       stdCONCATSTRING(elStr, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, typeMod[0]))));

    stdCHECK_WITH_POS(!(typeMod[1] == ptxTYPE_b8_MOD && gblState->parseData->modifiers.GROUP == ptxGROUP_g4_MOD),
                      (ptxMsgIllegalModifierWithMod, sourcePos,
                       getGROUPAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.GROUP), name,
                       stdCONCATSTRING(idxStr, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, typeMod[1]))));
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkInstrModifiersForGather(ptxParsingState gblState, cString name,
                                         uInt nrofTypeMod,
                                         uInt typeMod[ptxMAX_INSTR_ARGS],
                                         msgSourcePos_t sourcePos)
{
    checkCommonModsForGatherGenmetadata(gblState, name, nrofTypeMod, typeMod, sourcePos,
                                        getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxElSize_STR),
                                        getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxIdxSize_STR));
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkInstrTypeForGather(ptxParsingState gblState, cString name,
                                    uInt nrofInstructionTypes,
                                    ptxType instructionType[ptxMAX_INSTR_ARGS],
                                    uInt nrofTypeMod,
                                    uInt typeMod[ptxMAX_INSTR_ARGS],
                                    msgSourcePos_t sourcePos)
{
    if (nrofTypeMod != 2) {
        // Error out if incorrect type gblState->parseData->modifiers are passed
        stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrTypes, sourcePos, name));
        return;
    }

    if (!((typeMod[0] == ptxTYPE_b16_MOD || typeMod[0] == ptxTYPE_b8_MOD ||
           typeMod[0] == ptxTYPE_b4_MOD) &&
          (typeMod[1] == ptxTYPE_b8_MOD  ||  typeMod[1] == ptxTYPE_b4_MOD ||
           typeMod[1] == ptxTYPE_b2_MOD)))
    {
        stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrTypes, sourcePos, name));
        return;
    }

    gblState->parseData->modifiers.ATYPE = typeMod[0];
    gblState->parseData->modifiers.BTYPE = typeMod[1];
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkGatherInstruction(ptxParsingState gblState, uInt tcode, cString name,
                                   uInt nrofInstructionTypes,
                                   ptxType instructionType[ptxMAX_INSTR_ARGS],
                                   uInt nrofTypeMod,
                                   uInt typeMod[ptxMAX_INSTR_ARGS],
                                   uInt nrofArguments,
                                   ptxExpression arguments[ptxMAX_INSTR_ARGS],
                                   msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    checkFeatureVersion(gblState, 6, 4, name, sourcePos);
#else
    checkFeatureVersion(gblState, 7, 0, name, sourcePos);
#endif
    checkFeatureTarget(gblState, 80,   name, sourcePos);

    checkInstrTypeForGather(gblState, name, nrofInstructionTypes, instructionType,
                            nrofTypeMod, typeMod, sourcePos);

    checkInstrModifiersForGather(gblState, name, nrofTypeMod, typeMod, sourcePos);

    checkArgsForGather(gblState, name, nrofInstructionTypes, instructionType,
                       nrofArguments, arguments, sourcePos);
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkArgsForGenmetadata(ptxParsingState gblState, cString name,
                                    uInt nrofInstructionTypes,
                                    ptxType instructionType[ptxMAX_INSTR_ARGS],
                                    uInt nrofArguments,
                                    ptxExpression arguments[ptxMAX_INSTR_ARGS],
                                    msgSourcePos_t sourcePos)
{
    uInt maxVal[] = {0, 0, 0, 255, 15}, i;
    Int64 val;
    uInt    idx;
    uInt ngroup = 0;
    String idxSize = getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxIdxSize_STR);

    if (nrofArguments != 6 || gblState->parseData->modifiers.GROUP == ptxNOGROUP_MOD) {
        // Do early exit if instruction arguments/modifiers are invalid
        return;
    }
    idx = ptxGetTypeModSize(gblState->parseData->typeMod[1]);
    ngroup = ptxGetNumOfGroups(gblState->parseData->modifiers.GROUP);

    for (i = 3; i <= 4; i++) {
        if (arguments[i]->kind != ptxIntConstantExpression) {
            stdCHECK_WITH_POS(False, (ptxMsgConstantArgRequired, sourcePos,
                                      i, name));
            continue;
        }
        val = arguments[i]->cases.IntConstant.i;

        if (0 > val || val > maxVal[i]) {
            stdCHECK_WITH_POS(False, (ptxMsgArgValueOutOfRange, sourcePos, i, name,
                              val, 0, maxVal[i]));
            continue;
        }

        if (i == 3) {
            uInt maxVecIdx;
            maxVecIdx =  ((1 << (idx - 2)) - 1) >> ((ngroup*gblState->parseData->modifiers.SEQ) >> 1);
            stdCHECK_WITH_POS((val <= maxVecIdx),
                              (ptxMsgArgValueIllegalMods, sourcePos, i, name, val,
                               stdCONCATSTRING(idxSize, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->typeMod[1])),
                               getGROUPAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.GROUP)));

        }
        else if (i == 4) {
            uInt metadataWidth = (val * idx) + (ngroup * idx * 2) ;
            stdCHECK_WITH_POS(metadataWidth <= 32,
                              (ptxMsgArgValueIllegalMods, sourcePos, i, name, val,
                               stdCONCATSTRING(idxSize, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->typeMod[1])),
                               getGROUPAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.GROUP)));
            stdCHECK_WITH_POS((val % 2 == 0), (ptxMsgArgValueReqMultiple, sourcePos, 4, name,
                                               val, 2));
        }
    }
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkInstrModifiersForGenmetadata(ptxParsingState gblState, cString name,
                                              uInt nrofTypeMod,
                                              uInt typeMod[ptxMAX_INSTR_ARGS],
                                              uInt postop,
                                              msgSourcePos_t sourcePos)
{
    char modifierName[] = "slct";
    String seqAndIdx = getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSeqAndIdxSize_STR);

    checkCommonModsForGatherGenmetadata(gblState, name, nrofTypeMod, typeMod, sourcePos,
                                        getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxEleFormat_STR),
                                        getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxIdxSize_STR));
    if (!gblState->parseData->modifiers.GROUP) {
        return;
    }

    switch(postop) {
    case    ptxMAXOp:
    case ptxMAXABSOp:
        break;
    case ptxNOP:
        stdCHECK_WITH_POS(postop, (ptxMsgModifierRequired, sourcePos,
                                   modifierName, name));
        break;
    default:
        stdCHECK_WITH_POS(False, (ptxMsgIllegalModifier, sourcePos, get_strPOSTOP(gblState->parseData), name));
        break;
    }

    if (gblState->parseData->modifiers.SEQ && typeMod[1] == ptxTYPE_b2_MOD) {
        stdCHECK_WITH_POS( gblState->parseData->modifiers.GROUP == ptxGROUP_g1_MOD,
                          (ptxMsgIllegalModifierWithMod, sourcePos,
                           getGROUPAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.GROUP), name,
                           stdCONCATSTRING(seqAndIdx, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, typeMod[1]))));
    }
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkInstrTypeForGenmetadata(ptxParsingState gblState, cString name,
                                         uInt nrofInstructionTypes,
                                         ptxType instructionType[ptxMAX_INSTR_ARGS],
                                         uInt nrofTypeMod,
                                         uInt typeMod[ptxMAX_INSTR_ARGS],
                                         msgSourcePos_t sourcePos)
{
    if (nrofTypeMod != 2) {
        // Error out if incorrect type gblState->parseData->modifiers are passed
        stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrTypes, sourcePos, name));
        return;
    }

    if (!((typeMod[0] == ptxTYPE_f16_MOD || typeMod[0] == ptxTYPE_BF16_MOD ||
           typeMod[0] == ptxTYPE_u8_MOD || typeMod[0] == ptxTYPE_s8_MOD ||
           typeMod[0] == ptxTYPE_u4_MOD || typeMod[0] == ptxTYPE_s4_MOD ) &&
          (typeMod[1] == ptxTYPE_b8_MOD || typeMod[1] == ptxTYPE_b4_MOD ||
           typeMod[1] == ptxTYPE_b2_MOD)))

    {
        stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrTypes, sourcePos, name));
    }
    gblState->parseData->modifiers.ATYPE = typeMod[0];
    gblState->parseData->modifiers.BTYPE = typeMod[1];
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkGenmetadataInstruction(ptxParsingState gblState, uInt tcode, cString name,
                                        uInt nrofInstructionTypes,
                                        ptxType instructionType[ptxMAX_INSTR_ARGS],
                                        uInt nrofTypeMod,
                                        uInt typeMod[ptxMAX_INSTR_ARGS],
                                        uInt nrofArguments,
                                        ptxExpression arguments[ptxMAX_INSTR_ARGS],
                                        ptxOperator  postop,
                                        msgSourcePos_t sourcePos)
{
    // FIXME: Update version check
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    checkFeatureVersion(gblState, 6, 4, name, sourcePos);
#else
    checkFeatureVersion(gblState, 7, 0, name, sourcePos);
#endif
    checkFeatureTarget(gblState, 80,   name, sourcePos);

    checkInstrTypeForGenmetadata(gblState, name, nrofInstructionTypes, instructionType,
                                 nrofTypeMod, typeMod, sourcePos);

    checkInstrModifiersForGenmetadata(gblState, name, nrofTypeMod, typeMod, postop, sourcePos);

    checkArgsForGenmetadata(gblState, name, nrofInstructionTypes, instructionType,
                            nrofArguments, arguments, sourcePos);
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkPostOpForRedux(ptxParsingState gblState, cString name, uInt nrofInstructionTypes,
                                ptxType instructionType[ptxMAX_INSTR_ARGS],
                                ptxOperator postop,
                                msgSourcePos_t sourcePos)
{
    if (nrofInstructionTypes != 1) {
        stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrTypes, sourcePos, name));
        return;
    }

    switch(postop) {
    case ptxNOP:
        stdCHECK_WITH_POS(False, (ptxMsgOutputAOPExpected, sourcePos, name));
        break;

    case  ptxOROp:
    case ptxANDOp:
    case ptxXOROp:
        stdCHECK_WITH_POS(isB32(gblState->parseData->instructionType[0]),
                          (ptxMsgOpIncorrectType, sourcePos,
                           getTYPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->instructionType[0]),
                           get_strPOSTOP(gblState->parseData), name));
        break;
    case ptxADDOp:
    case ptxMAXOp:
    case ptxMINOp:
        stdCHECK_WITH_POS(isI32(gblState->parseData->instructionType[0]),
                          (ptxMsgOpIncorrectType, sourcePos,
                           getTYPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->instructionType[0]),
                           get_strPOSTOP(gblState->parseData), name));
        break;
    default:
        stdCHECK_WITH_POS(False, (ptxMsgOutputAOPNotAllowed, sourcePos, name,"", ""));
        break;

    }

}

static void checkReduxInstruction(ptxParsingState gblState, uInt tcode, cString name,
                                  uInt nrofInstructionTypes,
                                  ptxType instructionType[ptxMAX_INSTR_ARGS],
                                  ptxOperator postop,
                                  ptxExpression arguments[ptxMAX_INSTR_ARGS],
                                  msgSourcePos_t sourcePos)
{

    // In internal builds was supported in 6.4, publicly exposed in 7.0
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    checkFeatureVersion(gblState, 6, 4, name, sourcePos);
#else
    checkFeatureVersion(gblState, 7, 0, name, sourcePos);
#endif
    checkFeatureTarget(gblState, 80,   name, sourcePos);
    checkPostOpForRedux(gblState, name, nrofInstructionTypes, instructionType, postop, sourcePos);

}
#endif  // AMPERE && 70

#if LWCFG(GLOBAL_ARCH_AMPERE)
static void checkBraColwDivInstruction(ptxParsingState gblState, uInt tocde, String name, msgSourcePos_t sourcePos)
{
    char feature [] = "mask operand on bra instruction";

    // branch with only label operand
    if (gblState->parseData->nrofArguments == 1) {
        return;
    }

    // FIXME: update version check
    checkFeatureVersion(gblState, 6, 3, feature, sourcePos);
    checkFeatureTarget(gblState, 80,   feature, sourcePos);

    // mask on bra instruction requires .colw or .div gblState->parseData->modifiers
    stdCHECK_WITH_POS((gblState->parseData->modifiers.BRANCH == ptxCOLW_MOD || gblState->parseData->modifiers.BRANCH == ptxDIV_MOD),
                        (ptxMsgNonMatchingInstrArgs, sourcePos, name));
}
#endif // AMPERE

#if LWCFG(GLOBAL_ARCH_AMPERE)
static void checkAmpereInstructions(ptxParsingState gblState, ptxInstructionTemplate template, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    switch (tcode) {
    case ptx_bra_Instr:
        checkBraColwDivInstruction(gblState, tcode, name, sourcePos);
        break;

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptx_cp_async_Instr:
    case ptx_cp_async_wait_all_Instr:
    case ptx_cp_async_wait_group_Instr:
    case ptx_cp_async_commit_group_Instr:
    case ptx_cp_async_mbarrier_arrive_Instr:
        checkCopyInstruction(gblState, template, tcode, name, sourcePos);
        break;
#endif
        
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
    case ptx_cachepolicy_Instr:
        checkCachepolicyInstruction(gblState, tcode, name, sourcePos);
        break;
#endif // Internal || ISA_71

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
    case ptx_applypriority_Instr:
        checkApplypriorityInstruction(gblState, tcode, name, sourcePos);
        break;
    case ptx_createpolicy_fractional_Instr:
    case ptx_createpolicy_range_Instr:
    case ptx_createpolicy_cvt_Instr:
        checkCreatepolicyInstruction(gblState, tcode, name, sourcePos);
        break;
#endif

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    case ptx_destroy_Instr:
        checkDestroyInstruction(gblState, tcode, name, sourcePos);
        break;
#endif // Internal
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
    case ptx_discard_Instr:
        checkDiscardInstruction(gblState, tcode, name, sourcePos);
        break;
#endif // ISA_74

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    case ptx_clmad_hi_Instr:
    case ptx_clmad_lo_Instr:
        checkClmadInstruction(gblState, tcode, name, gblState->parseData->nrofInstructionTypes,
                              gblState->parseData->instructionType, gblState->parseData->postop,
                              gblState->parseData->arguments, sourcePos);
        break;
#endif // Internal
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptx_spmetadata_Instr:
        checkSpmetadataInstruction(gblState, tcode, name, gblState->parseData->nrofInstructionTypes,
                                   gblState->parseData->instructionType, gblState->parseData->nrofTypeMod, gblState->parseData->typeMod,
                                   gblState->parseData->modifiers, gblState->parseData->arguments, sourcePos);
        break;
    case ptx_gather_Instr:
        checkGatherInstruction(gblState, tcode, name, gblState->parseData->nrofInstructionTypes,
                               gblState->parseData->instructionType, gblState->parseData->nrofTypeMod, gblState->parseData->typeMod,
                               gblState->parseData->nrofArguments, gblState->parseData->arguments, sourcePos);
        break;
    case ptx_genmetadata_Instr:
        checkGenmetadataInstruction(gblState, tcode, name, gblState->parseData->nrofInstructionTypes,
                                    gblState->parseData->instructionType, gblState->parseData->nrofTypeMod, gblState->parseData->typeMod,
                                    gblState->parseData->nrofArguments, gblState->parseData->arguments,
                                    gblState->parseData->postop, sourcePos);
        break;
#endif
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptx_mbarrier_init_Instr:
    case ptx_mbarrier_ilwal_Instr:
    case ptx_mbarrier_arrive_Instr:
    case ptx_mbarrier_arrive_drop_Instr:
    case ptx_mbarrier_test_wait_Instr:
    case ptx_mbarrier_pending_count_Instr:
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
    case ptx_mbarrier_test_wait_parity_Instr:
#endif        
        checkMbarrierInstructions(gblState, tcode, name, sourcePos);
        break;
    case ptx_max_Instr:
    case ptx_min_Instr:
    case ptx_fma_Instr:
    case ptx_abs_Instr:
    case ptx_neg_Instr:
        if (gblState->parseData->nrofTypeMod > 0 && (gblState->parseData->typeMod[0] == ptxTYPE_BF16_MOD || gblState->parseData->typeMod[0] == ptxTYPE_BF16x2_MOD)) {
            checkFeatureTarget(gblState, 80,   getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->typeMod[0]), sourcePos);
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) 
            checkFeatureVersion(gblState, 6, 4, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->typeMod[0]), sourcePos);
#else
            if (areExtendedInstructionsEnabled(gblState->parseData)) {
                checkFeatureVersion(gblState, 6, 5, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->typeMod[0]), sourcePos);
            } else {
                checkFeatureVersion(gblState, 7, 0, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->typeMod[0]), sourcePos);
            }
#endif
            if (gblState->parseData->instructionType[0] != NULL) {
                stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrTypes, sourcePos, name));
            }
            checkInstructionForBF16(gblState, template, name, 0, gblState->parseData->nrofArguments, gblState->parseData->arguments, sourcePos);
        }
        break;
    case ptx_cvt_Instr:
        if (gblState->parseData->nrofTypeMod > 0 && gblState->parseData->typeMod[0] == ptxTYPE_TF32_MOD) {
            int i;
            checkFeatureTarget(gblState, 80,   getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->typeMod[0]), sourcePos);
            checkFeatureVersion(gblState, 7, 0, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->typeMod[0]), sourcePos);
            stdCHECK_WITH_POS(gblState->parseData->nrofArguments == 2, (ptxMsgNonMatchingInstrArgs, sourcePos, name));
            // For an argument that has a specified type, only bit type of size 32 is allowed
            for (i = 0; i < gblState->parseData->nrofArguments; i++) {
                if (template->argType[i] != ptxFollowAType) {
                    stdCHECK_WITH_POS(isBitTypeKind(gblState->parseData->arguments[i]->type->kind) && ptxGetTypeSizeInBits(gblState->parseData->arguments[i]->type) == 32, 
                                     (ptxMsgNonMatchingInstrArgs, sourcePos, name));
                }
            }
            gblState->parseData->modifiers.ATYPE = gblState->parseData->typeMod[0];
        }
        break;
    case ptx_redux_Instr:
        checkReduxInstruction(gblState, tcode, name, gblState->parseData->nrofInstructionTypes,
                              gblState->parseData->instructionType, gblState->parseData->postop,
                              gblState->parseData->arguments, sourcePos);
        break;
#endif // 70
    }
}
#endif // Ampere


#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkTypeForSetMaxRegInstr(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    stdASSERT(gblState->parseData->nrofInstructionTypes == 1, (""));
    stdCHECK_WITH_POS (isU32(gblState->parseData->instructionType[0]), (ptxMsgNonMatchingInstrTypes, sourcePos, name));
}
#endif // Hopper && Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkArgsForSetMaxRegInstr(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    uInt maxRegSizeIndex = tcode == ptx_setmaxreg_try_alloc_Instr ? 1 : 0;
    ptxCheckImmediateArgForMultipleOf(gblState->parseData->arguments, maxRegSizeIndex, 8, name, sourcePos);
    uInt64 argVal = ptxGetImmediateIntVal(gblState->parseData->arguments[maxRegSizeIndex]);
    stdCHECK_WITH_POS (argVal > 0, (ptxMsgPositiveValueExpected, sourcePos, name));
}
#endif // Hopper && Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkSetMaxRegInstruction(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    // FIXME: update version check
    checkFeatureVersion(gblState, 7, 0, name, sourcePos);
    checkFeatureTarget(gblState, 90,    name, sourcePos);
    checkTypeForSetMaxRegInstr(gblState, tcode, name, sourcePos);
    checkArgsForSetMaxRegInstr(gblState, tcode, name, sourcePos);
}
#endif // Hopper && Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkArgsForSetSMEMSizeInstr(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    if (tcode == ptx_setsmemsize_flush_Instr)
        return;

    ptxCheckImmediateArgForMultipleOf(gblState->parseData->arguments, 0, 128, name, sourcePos);
}
#endif // Hopper && Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkSetctarankInstruction(ptxParsingState gblState, String name, uInt tcode, msgSourcePos_t sourcePos)
{
    checkFeatureTarget(gblState, 90, name, sourcePos);
    checkFeatureVersion(gblState, 7, 2, name, sourcePos);
    // TODO: Remove this explicit check and report error in pre-process instruction
    //       when code disabled against bug 200437885 is enabled
    if (gblState->parseData->nrofInstrMemspace > 1) {
        stdCHECK_WITH_POS(False, (ptxMsgIncorrectMemspaces, sourcePos, name));
    }
}
#endif // Hopper && Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkSetSMEMSizeInstruction(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    // FIXME: update version check
    checkFeatureVersion(gblState, 7, 0, name, sourcePos);
    checkFeatureTarget(gblState, 90,    name, sourcePos);
    // HACK: since setsmem is similar to setmaxreg, simply re-using check here
    checkTypeForSetMaxRegInstr(gblState, tcode, name, sourcePos);
    checkArgsForSetSMEMSizeInstr(gblState, tcode, name, sourcePos);
}
#endif // Hopper && Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_FUTURE)
static void checkElectOneInstruction(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    // FIXME: update version check
    checkFeatureVersion(gblState, 7, 2, name, sourcePos);
    checkFeatureTarget(gblState, 90,    name, sourcePos);
}
#endif // Hopper && Future

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkReduceOperationForTensorCopy(cString name,
                                              ptxOperator postop,
                                              ptxStorageClass storage[ptxMAX_INSTR_MEMSPACE],
                                              msgSourcePos_t sourcePos)
{
    if (postop == ptxNOP) {
        stdCHECK_WITH_POS(False, (ptxMsgOutputAOPExpected, sourcePos, name));
        return;
    }

    switch(postop) {
    case  ptxOROp:
    case ptxANDOp:
    case ptxXOROp:
    case ptxADDOp:
    case ptxMAXOp:
    case ptxMINOp:
    case ptxINCOp:
    case ptxDECOp:
        return;
    default:
        stdCHECK_WITH_POS(False, (ptxMsgOutputAOPNotAllowed, sourcePos, name,"", ""));
        return;
    }

}
#endif // Hopper && Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static Bool isMbarrierRequiredForBulkCopy(ptxStorageClass dstStorage, ptxStorageClass srcStorage)
{
    return dstStorage.kind == ptxSharedStorage;
}
#endif // Hopper && Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static Bool checkStateSpaceForTensorCopyInstruction(uInt tcode, cString name,
                                                    uInt nrofInstrMemspace,
                                                    ptxStorageClass storage[ptxMAX_INSTR_MEMSPACE],
                                                    msgSourcePos_t sourcePos)
{
    if (tcode != ptx_cp_async_bulk_tensor_Instr &&
        tcode != ptx_cp_reduce_async_bulk_tensor_Instr)
    {
        stdASSERT(False, ("cp{.reduce}.async.bulk.tensor instruction is expected"));
        return False;
    }

    if (nrofInstrMemspace != 2 ) {
        return False;
    }

    switch (tcode) {
    case ptx_cp_reduce_async_bulk_tensor_Instr:
        return (storage[0].kind  == ptxGlobalStorage && storage[1].kind ==  ptxSharedStorage);
    default:
        return ((storage[0].kind  == ptxSharedStorage && storage[1].kind ==  ptxGlobalStorage) ||
                (storage[0].kind  == ptxGlobalStorage && storage[1].kind ==  ptxSharedStorage));
    }
}
#endif

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkModifiersForTensorCopyInstruction(ptxParsingState gblState, uInt tcode, String name,
                                                   ptxStorageClass storage[ptxMAX_INSTR_MEMSPACE],
                                                   msgSourcePos_t sourcePos)
{
    Bool isMbarrierRequired = isMbarrierRequiredForBulkCopy(storage[0], storage[1]);

    stdCHECK_WITH_POS(stdIMPLIES(isMbarrierRequired, ptxHasMBARRIER_MOD(gblState->parseData->modifiers)),
                      (ptxMsgModifierRequired, sourcePos, ".mbarrier", name));
    stdCHECK_WITH_POS(ptxHasTENSORDIM_MOD(gblState->parseData->modifiers),
                      (ptxMsgModifierRequired, sourcePos, ".dim", name));
    stdCHECK_WITH_POS(stdIMPLIES(ptxHasIM2COL_MOD(gblState->parseData->modifiers),
                                 gblState->parseData->modifiers.TENSORDIM >= ptxDIM3D_MOD),
                      (ptxMsgIllegalModifierPair, sourcePos,
                       get_strTENSORDIM(gblState->parseData), get_strIM2COL(gblState->parseData)));

    if (!isMbarrierRequired) {
        // Instruction checks related to UTMASTG are completed
        return;
    }

    if (ptxHasPACKEDOFF_MOD(gblState->parseData->modifiers)) {
        stdCHECK_WITH_POS(ptxHasIM2COL_MOD(gblState->parseData->modifiers),
                          (ptxMsgModifierRequiresModifier, sourcePos,
                           getPACKEDOFFAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxPACKEDOFF_MOD),
                           getIM2COLAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxIM2COL_MOD)));
    }
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkArgsForTensorCopyInstruction(ptxParsingState gblState, uInt tcode, String name,
                                              ptxStorageClass storage[ptxMAX_INSTR_MEMSPACE],
                                              msgSourcePos_t sourcePos)
{
    Bool isMbarrierRequired = isMbarrierRequiredForBulkCopy(storage[0], storage[1]);
    uInt argVecSize, expectedSize, argNum = isMbarrierRequired ? 2 : 1;


    // tensor co-ordinate Argument
    if (gblState->parseData->arguments[argNum]->type->kind != ptxVectorType) {
        stdCHECK_WITH_POS(False, (ptxMsgVectorArgumentExpected, sourcePos, argNum));
        return;
    }

    /* Note: I64 co-ords aren't allowed. But when vector contains all of immediate
     *       integers, then we treat it of type I64. Therefore, below check allows 
     *       I64 type. However, When explictly I64 vector is provided, then we
     *       error out in template matching itself.
     */
    stdCHECK_WITH_POS((isI32(gblState->parseData->arguments[argNum]->type->cases.Vector.base) ||
                       isB32(gblState->parseData->arguments[argNum]->type->cases.Vector.base) ||
                       isI64(gblState->parseData->arguments[argNum]->type->cases.Vector.base)),
                      (ptxMsgNonMatchingInstrArgs, sourcePos, name));
    argVecSize = gblState->parseData->arguments[argNum]->type->cases.Vector.N;
    expectedSize = gblState->parseData->modifiers.TENSORDIM;
    stdCHECK_WITH_POS(argVecSize == expectedSize,
                      (ptxMsgArgumentVectorMismatchArgNum,
                       sourcePos, (argNum + 1), name));

    if (!isMbarrierRequired) {
        // Instruction checks related to UTMASTG are completed
        return;
    }

    // Checks for instruction UTMALDG

    // Nothing to check for barrier argument
    argNum += 2;

    if (gblState->parseData->modifiers.IM2COL) {
        if (gblState->parseData->modifiers.PACKEDOFF) {
            // IM2COL packed offset argument must be scalar U16
            stdCHECK_WITH_POS((gblState->parseData->arguments[argNum]->type->kind != ptxVectorType),
                              (ptxMsgVectorArgumentNotExpected, sourcePos,
                               argNum, name));
        } else {
            // IM2COL packed offset argument must be vector U16
            uInt argVecSize, expectedVecSize = 3; // Ht, wd, dpt
            stdCHECK_WITH_POS((gblState->parseData->arguments[argNum]->type->kind == ptxVectorType),
                              (ptxMsgVectorArgumentExpected, sourcePos,
                               argNum, name));
            argVecSize = gblState->parseData->arguments[argNum]->type->cases.Vector.N;
            expectedVecSize -= (ptxDIM5D_MOD - gblState->parseData->modifiers.TENSORDIM);
            stdASSERT((expectedVecSize > 0), ("Unable to infer expected vector size"));
            stdCHECK_WITH_POS(argVecSize == expectedVecSize,
                              (ptxMsgArgumentVectorMismatchArgNum,
                               sourcePos, (argNum + 1), name));
        }
        argNum++;
    }

    if (gblState->parseData->modifiers.MULTICAST) {
        // ctaMask argument must be u16 scalar
        stdCHECK_WITH_POS((gblState->parseData->arguments[argNum]->type->kind != ptxVectorType),
                          (ptxMsgVectorArgumentNotExpected, sourcePos,
                           argNum, name));
    }
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkTensorCopyInstruction(ptxParsingState gblState, uInt tcode, String name,
                                       uInt nrofInstrMemspace,
                                       ptxStorageClass storage[ptxMAX_INSTR_MEMSPACE],
                                       ptxOperator postop, ptxModifier modifiers,
                                       msgSourcePos_t sourcePos)
{
    // FIXME: update version check
    checkFeatureTarget(gblState, 90,    name, sourcePos);
    checkFeatureVersion(gblState, 7, 2, name, sourcePos);

    if  (!checkStateSpaceForTensorCopyInstruction(tcode, name, nrofInstrMemspace,
                                                  storage, sourcePos))
    {
        stdCHECK_WITH_POS(False, (ptxMsgSpaceIncorrect, sourcePos, name));
        return;
    }

    if (tcode == ptx_cp_reduce_async_bulk_tensor_Instr) {
        checkReduceOperationForTensorCopy(name, postop, storage, sourcePos);
    }

    checkModifiersForTensorCopyInstruction(gblState, tcode, name, storage, sourcePos);
    checkArgsForTensorCopyInstruction(gblState, tcode, name, storage, sourcePos);
}
#endif // Hopper && Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static Bool isMulticastSupportedForBulkCopy(ptxStorageClass storage[ptxMAX_INSTR_MEMSPACE])
{
    return storage[1].kind == ptxGlobalStorage;
}

static Bool isDescAllowedForBulkCopy(ptxStorageClass storage[ptxMAX_INSTR_MEMSPACE])
{
    return (storage[0].kind == ptxGlobalStorage || storage[1].kind == ptxGlobalStorage);
}

static Bool checkStateSpaceForBulkCopyInstruction(uInt tcode, cString name,
                                                  uInt nrofInstrMemspace,
                                                  ptxStorageClass storage[ptxMAX_INSTR_MEMSPACE],
                                                  msgSourcePos_t sourcePos)
{
    if (tcode != ptx_cp_async_bulk_Instr &&
        tcode != ptx_cp_reduce_async_bulk_Instr)
    {
        stdASSERT(False, ("cp{.reduce}.async.bulk instruction is expected"));
        return False;
    }

    if (nrofInstrMemspace != 2 ) {
        return False;
    }

    switch (tcode) {
    case ptx_cp_reduce_async_bulk_Instr:
        return ((storage[0].kind  == ptxGlobalStorage && storage[1].kind ==  ptxSharedStorage) ||
                (storage[0].kind  == ptxSharedStorage && storage[1].kind ==  ptxSharedStorage));

    case ptx_cp_async_bulk_Instr:
        return ((storage[0].kind  == ptxSharedStorage && storage[1].kind ==  ptxGlobalStorage) ||
                (storage[0].kind  == ptxGlobalStorage && storage[1].kind ==  ptxSharedStorage) ||
                (storage[0].kind  == ptxSharedStorage && storage[1].kind ==  ptxSharedStorage));

    default:
        stdASSERT(False, ("Unexpected instruction"));
        return False;
    }
}

static void checkReductionOpAndTypeForBulkCopyCommon(ptxParsingState gblState, String name,
                                                     ptxType instructionType[ptxMAX_INSTR_ARGS],
                                                     ptxOperator postop,
                                                     msgSourcePos_t sourcePos)
{
    if (postop == ptxNOP) {
        stdCHECK_WITH_POS(False, (ptxMsgOutputAOPExpected, sourcePos, name));
        return;
    }

    Bool isCorrectInstrType = False;
    ptxType type = instructionType[0];

    if (!type && !isBF16Mod(gblState->parseData->typeMod[0]))
        return;

    String typeStr = (type != NULL) ? getTYPEAsString(gblState->parseData->deobfuscatedStringMapPtr, type) : getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->typeMod[0]);

    switch(postop) {
    case  ptxOROp:
    case ptxANDOp:
    case ptxXOROp:
        isCorrectInstrType = isB32(type) || isB64(type);
        break;

    case ptxADDOp:
        isCorrectInstrType = isU32(type) || isS32(type) || isU64(type) ||
                             isF16(type) || isF32(type) || isF64(type) ||
                             isBF16Mod(gblState->parseData->typeMod[0]);
        break;

    case ptxMAXOp:
    case ptxMINOp:
        isCorrectInstrType = isU32(type) || isS32(type) || isU64(type) ||
                             isS64(type) || isF16(type) ||
                             isBF16Mod(gblState->parseData->typeMod[0]);
        break;

    case ptxINCOp:
    case ptxDECOp:
        isCorrectInstrType = isU32(type);
        break;

    default:
        stdCHECK_WITH_POS(False, (ptxMsgOutputAOPNotAllowed, sourcePos, name, "", ""));
        return;
    }
    stdCHECK_WITH_POS(isCorrectInstrType,
                      (ptxMsgOpIncorrectType, sourcePos,
                       typeStr, get_strPOSTOP(gblState->parseData), name));
}

static void checkReductionOpAndTypeForBulkCopyS2S(ptxParsingState gblState, String name,
                                                  ptxType instructionType[ptxMAX_INSTR_ARGS],
                                                  ptxOperator postop,
                                                  msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(!isS64(gblState->parseData->instructionType[0]),
                      (ptxMsgIllegalType, sourcePos, stdCONCATSTRING(name, " with .shared destination state space")));
    stdCHECK_WITH_POS(stdIMPLIES((isU64(gblState->parseData->instructionType[0]) || isB64(gblState->parseData->instructionType[0])), postop == ptxADDOp),
                      (ptxMsgOutputAOPNotAllowed, sourcePos, name, ".shared.shared", getTYPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->instructionType[0])));
}

static void checkModifiersForBulkCopyReduceInstruction(ptxParsingState gblState, uInt tcode, String name,
                                                       ptxType instructionType[ptxMAX_INSTR_ARGS],
                                                       ptxOperator postop,
                                                       msgSourcePos_t sourcePos)
{
    if (isBF16Mod(gblState->parseData->typeMod[0]) || isF16(gblState->parseData->instructionType[0])) {
        String typeStr = (isF16(gblState->parseData->instructionType[0])) ? getTYPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->instructionType[0]) : getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->typeMod[0]);
        if (postop == ptxADDOp) {
            stdCHECK_WITH_POS(gblState->parseData->modifiers.NOFTZ,
                              (ptxMsgModifierRequiredWithTypeAndOp, sourcePos,
                               getNOFTZAsString(ptxEXPLICIT_NOFTZ_MOD), name,
                               typeStr, get_strPOSTOP(gblState->parseData)));
        } else {
            stdCHECK_WITH_POS(!gblState->parseData->modifiers.NOFTZ,
                              (ptxMsgIllegalModifierWithMod, sourcePos,
                               getNOFTZAsString(ptxEXPLICIT_NOFTZ_MOD), name, get_strPOSTOP(gblState->parseData)));
        }
    }
}

static void checkModifiersForBulkCopyInstruction(ptxParsingState gblState, uInt tcode, String name,
                                                 ptxStorageClass storage[ptxMAX_INSTR_MEMSPACE],
                                                 ptxType instructionType[ptxMAX_INSTR_ARGS],
                                                 ptxOperator postop,
                                                 msgSourcePos_t sourcePos)
{
    Bool isMbarrierRequired = isMbarrierRequiredForBulkCopy(storage[0], storage[1]);
    Bool isMulticastSupported = isMulticastSupportedForBulkCopy(storage);
    Bool isDescAllowed = isDescAllowedForBulkCopy(storage);

    if (tcode == ptx_cp_reduce_async_bulk_Instr) {
        checkModifiersForBulkCopyReduceInstruction(gblState, tcode, name, instructionType,
                                                   postop, sourcePos);
    }

    stdCHECK_WITH_POS(stdIMPLIES(gblState->parseData->modifiers.DESC, isDescAllowed),
                      (ptxMsgIllegalModifierWithMod, sourcePos,
                       getDESCAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxDESC_MOD), name, ".shared.shared state space"));
    stdCHECK_WITH_POS(stdIMPLIES(isMbarrierRequired, ptxHasMBARRIER_MOD(gblState->parseData->modifiers)),
                      (ptxMsgModifierRequired, sourcePos, ".mbarrier", name));
    stdCHECK_WITH_POS(stdIMPLIES(ptxHasMBARRIER_MOD(gblState->parseData->modifiers), isMbarrierRequired),
                      (ptxMsgIllegalModifier, sourcePos, ".mbarrier", name));
    stdCHECK_WITH_POS(stdIMPLIES(ptxHasMULTICAST_MOD(gblState->parseData->modifiers), isMulticastSupported),
                      (ptxMsgIllegalModifier, sourcePos, get_strMULTICAST(gblState->parseData), name));
}

static void checkArgsForBulkCopyInstruction(ptxParsingState gblState, uInt tcode, String name,
                                            msgSourcePos_t sourcePos)
{
    int val, milwal = 0, maxVal = 1048560;

    // Arguments should be less than 6 in case of multicast not supported or not present
    // This check takes care of cases where multicast is not present but 6 arguments are provided
    // as template matching allows such cases by returning template for 6 arguments
    stdCHECK_WITH_POS(stdIMPLIES(!gblState->parseData->modifiers.MULTICAST, gblState->parseData->nrofArguments <= 5),
                      (ptxMsgNonMatchingInstrArgs, sourcePos, name));

    if (gblState->parseData->arguments[2]->kind == ptxIntConstantExpression) {
        val = gblState->parseData->arguments[2]->cases.IntConstant.i;
        stdCHECK_WITH_POS(stdMULTIPLEOF(val, 16), (ptxMsgArgValueReqMultiple, sourcePos, 2, name,
                                                   val, 16));
        stdCHECK_WITH_POS((milwal <= val && val <= maxVal),
                          (ptxMsgArgValueOutOfRange, sourcePos, 2,
                           name, val, milwal, maxVal));
    }
}

static void checkTypeForBulkCopyReduceInstr(ptxParsingState gblState, String name,
                                            ptxStorageClass storage[ptxMAX_INSTR_MEMSPACE],
                                            ptxType instructionType[ptxMAX_INSTR_ARGS],
                                            ptxOperator postop,
                                            msgSourcePos_t sourcePos)
{
    Bool isDstShared = (storage[0].kind == ptxSharedStorage);

    gblState->parseData->modifiers.ATYPE = gblState->parseData->typeMod[0];
    if (gblState->parseData->nrofTypeMod != 1 &&
        (instructionType[0] == NULL && !isBF16Mod(gblState->parseData->modifiers.ATYPE)))
    {
        stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrTypes, sourcePos, name));
    }

    checkReductionOpAndTypeForBulkCopyCommon(gblState, name, instructionType, postop, sourcePos);

    // Checks for .S.S state spaces
    if (isDstShared) {
        checkReductionOpAndTypeForBulkCopyS2S(gblState, name, instructionType, postop, sourcePos);
    }
}

static void checkBulkCopyInstruction(ptxParsingState gblState, uInt tcode, String name,
                                     uInt nrofInstrMemspace,
                                     ptxStorageClass storage[ptxMAX_INSTR_MEMSPACE],
                                     ptxType instructionType[ptxMAX_INSTR_ARGS],
                                     ptxOperator postop, msgSourcePos_t sourcePos)
{
    // FIXME: update version check
    checkFeatureTarget(gblState, 90,    name, sourcePos);
    if (tcode == ptx_cp_reduce_async_bulk_Instr) {
        checkFeatureVersion(gblState, 7, 3, name, sourcePos);
    } else {
        checkFeatureVersion(gblState, 7, 2, name, sourcePos);
    }

    if  (!checkStateSpaceForBulkCopyInstruction(tcode, name, nrofInstrMemspace,
                                                storage, sourcePos))
    {
        stdCHECK_WITH_POS(False, (ptxMsgSpaceIncorrect, sourcePos, name));
        return;
    }

    if (tcode == ptx_cp_reduce_async_bulk_Instr) {
        checkTypeForBulkCopyReduceInstr(gblState, name, storage, gblState->parseData->instructionType, postop, sourcePos);
    }

    checkModifiersForBulkCopyInstruction(gblState, tcode, name, storage, gblState->parseData->instructionType, postop, sourcePos);
    checkArgsForBulkCopyInstruction(gblState, tcode, name, sourcePos);
}
#endif // Hopper && Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkModifiersForBarrierClusterInstruction(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    if (tcode == ptx_barrier_cluster_arrive_Instr && gblState->parseData->modifiers.ORDER) {
        // FIXME: update version check
        stdCHECK_WITH_POS(ptxVersionAtLeast(7, 6, gblState),
                          (ptxMsgInstModRequiresPTXVersion, sourcePos,
                           get_strORDER(gblState->parseData), name, "7.6"));
    }
}

static void checkBarrierClusterInstructions(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    // FIXME: update version check
    checkFeatureVersion(gblState, 7, 2, name, sourcePos);
    checkFeatureTarget(gblState, 90,    name, sourcePos);

    checkModifiersForBarrierClusterInstruction(gblState, tcode, name, sourcePos);
}
#endif // Hopper && Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_FUTURE)
static void checkCompareInstrWithBF16(ptxParsingState gblState, ptxInstructionTemplate template,
                                      String name, msgSourcePos_t sourcePos)
{
    uInt typeIndex = 0, lastArgNum, tcode = template->code;
    String instrWithType;
    Bool isSetpInstr = False;

    isSetpInstr = (tcode == ptx_setp_Instr) ? True : False;

    stdASSERT(stdIMPLIES(!isSetpInstr, (tcode == ptx_set_Instr)),
              ("Unexpected instruction code"));

    if (isSetpInstr &&
        !isBF16(gblState->parseData->instructionType[0]) &&
        !isBF16x2(gblState->parseData->instructionType[0])) {
        return;
    }

    if (!isSetpInstr &&
        !isBF16(gblState->parseData->instructionType[0]) &&
        !isBF16x2(gblState->parseData->instructionType[0]) &&
        !isBF16(gblState->parseData->instructionType[1]) &&
        !isBF16x2(gblState->parseData->instructionType[1])) {
        return;
    }

    if (!isSetpInstr &&
        (isBF16(gblState->parseData->instructionType[1]) ||
         isBF16x2(gblState->parseData->instructionType[1]))) {
        // set.{dType}.{BF16/BF16x2}
        typeIndex = 1;
    }

    instrWithType = stdCONCATSTRING(name,
                                    getTYPEAsString(gblState->parseData->deobfuscatedStringMapPtr,
                                    gblState->parseData->instructionType[typeIndex]));

    // FIXME: update version check
    checkFeatureTarget(gblState, 90, instrWithType, sourcePos);
    checkFeatureVersion(gblState, 7, 4, instrWithType, sourcePos);

    // Last argument may be of type predicate and NOT of type BF16/BF16x2.
    lastArgNum = (isPRED(gblState->parseData->arguments[gblState->parseData->nrofArguments - 1]->type)
                  ? (gblState->parseData->nrofArguments - 1) : gblState->parseData->nrofArguments);

    checkInstructionArgsForBF16(gblState, template, name, 1, lastArgNum,
                                gblState->parseData->arguments, sourcePos);
}
#endif // Hopper && Future

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_FUTURE)
static void checkArithmeticInstrWithBF16(ptxParsingState gblState, ptxInstructionTemplate template,
                                         String name, msgSourcePos_t sourcePos)
{
    String instrWithType;

    if (!isBF16(gblState->parseData->instructionType[0]) &&
        !isBF16x2(gblState->parseData->instructionType[0])) {
        return;
    }

    stdCHECK_WITH_POS(gblState->parseData->nrofInstructionTypes == 1,
                      (ptxMsgNonMatchingInstrTypes, sourcePos, name));

    instrWithType = stdCONCATSTRING(name,
                                    getTYPEAsString(gblState->parseData->deobfuscatedStringMapPtr,
                                                    gblState->parseData->instructionType[0]));

    // FIXME: update version check
    checkFeatureTarget(gblState, 90, instrWithType, sourcePos);
    checkFeatureVersion(gblState, 7, 4, instrWithType, sourcePos);

    checkInstructionArgsForBF16(gblState, template, name, 0,
                                gblState->parseData->nrofArguments,
                                gblState->parseData->arguments, sourcePos);

    // BF16/BF16x2 arithmetic supports only rn rounding modifier.
    stdCHECK_WITH_POS(stdIMPLIES(ptxHasRoundFModifier(gblState->parseData->modifiers),
                                 gblState->parseData->modifiers.ROUND == ptxRN_MOD),
                      (ptxMsgIllegalRoundingModifier,sourcePos,name));
}
#endif // Hopper && Future

#if LWCFG(GLOBAL_ARCH_HOPPER)
static void checkHopperInstructions(ptxParsingState gblState, ptxInstructionTemplate template, uInt tcode, String name,
                                    ptxOperator postop, ptxModifier modifiers, msgSourcePos_t sourcePos)
{
    switch (tcode) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    case ptx_setmaxreg_release_Instr:
        stdCHECK_WITH_POS(False, (ptxMsgIllegalModifierArch, sourcePos, ".release", "setmaxreg", gblState->target_arch));
        break;
    case ptx_setmaxreg_try_alloc_Instr:
    case ptx_setmaxreg_alloc_Instr:
    case ptx_setmaxreg_dealloc_Instr:
        checkSetMaxRegInstruction(gblState, tcode, name, sourcePos);
        break;
    case ptx_setsmemsize_Instr:
    case ptx_setsmemsize_flush_Instr:
        checkSetSMEMSizeInstruction(gblState, tcode, name, sourcePos);
        break;
    case ptx_mbarrier_try_wait_Instr:
    case ptx_mbarrier_try_wait_parity_Instr:
    case ptx_mbarrier_expect_copy_Instr:
    case ptx_mbarrier_arrive_expect_copy_Instr:
    case ptx_mbarrier_arrive_drop_expect_copy_Instr:
    case ptx_mbarrier_expect_tx_Instr:
    case ptx_mbarrier_arrive_expect_tx_Instr:
    case ptx_mbarrier_arrive_drop_expect_tx_Instr:
        checkMbarrierInstructions(gblState, tcode, name, sourcePos);
        break;
    case ptx_setctarank_Instr:
        checkSetctarankInstruction(gblState, name, tcode, sourcePos);
        break;
    case ptx_cp_async_bulk_tensor_Instr:
    case ptx_cp_reduce_async_bulk_tensor_Instr:
        checkTensorCopyInstruction(gblState, tcode, name, gblState->parseData->nrofInstrMemspace, gblState->parseData->storage,
                                   postop, modifiers, sourcePos);
        break;
    case ptx_cp_async_bulk_Instr:
    case ptx_cp_reduce_async_bulk_Instr:
        checkBulkCopyInstruction(gblState, tcode, name, gblState->parseData->nrofInstrMemspace, gblState->parseData->storage,
                                 gblState->parseData->instructionType, postop, sourcePos);
        break;
    case ptx_barrier_cluster_Instr:
    case ptx_barrier_cluster_arrive_Instr:
    case ptx_barrier_cluster_wait_Instr:
        checkBarrierClusterInstructions(gblState, tcode, name, sourcePos);
        break;
    case ptx_cvt_Instr:
        if (isF8x2(gblState->parseData->instructionType[0]) ||
            isF8x2(gblState->parseData->instructionType[1]))
        {
            char feature[128];
            sprintf (feature, "%s with %s/%s", name,
                     getTypeEnumAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxTypeE4M3x2),
                     getTypeEnumAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxTypeE5M2x2));
            checkFeatureTarget(gblState, 90, feature, sourcePos);
            checkFeatureVersion(gblState, 7, 5, feature, sourcePos);
        }
        break;
#endif // Internal
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_FUTURE)
    case ptx_elect_one_Instr:
        checkElectOneInstruction(gblState, tcode, name, sourcePos);
        break;
    case ptx_add_Instr:
    case ptx_sub_Instr:
    case ptx_mul_Instr:
        checkArithmeticInstrWithBF16(gblState, template, name, sourcePos);
        break;
    case ptx_set_Instr:
    case ptx_setp_Instr:
        checkCompareInstrWithBF16(gblState, template, name, sourcePos);
        break;
    case ptx_stmatrix_Instr:
        checkFeatureTarget(gblState, 90,   name, sourcePos);
        // FIXME: Update version check
        checkFeatureVersion(gblState, 7, 1, name, sourcePos);
#endif //Future
    }
}
#endif // Hopper

#if LWCFG(GLOBAL_ARCH_ADA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkWideLoadStoreInstr(ptxParsingState gblState, uInt tcode, uInt nrofInstrMemspac,
                                    ptxStorageClass storage[ptxMAX_INSTR_MEMSPACE],
                                    msgSourcePos_t sourcePos)
{
    String feature = "256 bit wide load/store";
    // FIXME: Update version check
    checkFeatureVersion(gblState, 7, 4, feature, sourcePos);
    checkFeatureTarget(gblState, 89, feature, sourcePos);

    stdCHECK_WITH_POS((nrofInstrMemspac == 0 || storage[0].kind == ptxGlobalStorage),
                      (ptxMsgSpaceExpectedForFeature,
                       sourcePos, "global", feature));
}
#endif // ada, internal

#if LWCFG(GLOBAL_ARCH_ADA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkAdaInstructions(ptxParsingState gblState, ptxInstructionTemplate template, uInt tcode,
                                 int nrofInstructionTypes,
                                 ptxType instructionType[ptxMAX_INSTR_ARGS],
                                 uInt nrofInstrMemspac,
                                 ptxStorageClass storage[ptxMAX_INSTR_MEMSPACE],
                                 ptxModifier modifiers, msgSourcePos_t sourcePos)
{
    if (isWideLoadStoreInstr(tcode, instructionType[0], modifiers)) {
        checkWideLoadStoreInstr(gblState, tcode, gblState->parseData->nrofInstrMemspace, storage, sourcePos);
    }
    switch(tcode) {
        case ptx_prefetch_Instr:
        if (ptxHasRESULT_Feature(template->features)) {
            if (checkTargetArch(gblState, 90)) {
                stdCHECK_WITH_POS(False, (ptxMsgIlwalidInstTargetArch, sourcePos, 
                                          "Prefetch with query fault result predicate", gblState->target_arch));
            } else if (checkCompilationArch(gblState, 90)) {
                stdCHECK_WITH_POS(False, (ptxMsgIlwalidInstCompilationArch, sourcePos,
                                          "Prefetch with query fault result predicate", gblState->gpuInfo->internalName));
            } else {
                stdCHECK_WITH_POS(checkTargetArch(gblState, 89), 
                                  (ptxMsgIlwalidInstTargetArch, sourcePos,
                                   "Prefetch with query fault result predicate", gblState->target_arch));
            }
            // FIXME: update version check
            checkFeatureVersion(gblState, 7, 6, "Prefetch with query fault result predicate", sourcePos);

            if (gblState->parseData->nrofEvictPriorityMod != 0) {
                // Disallow evict priority
                stdCHECK_WITH_POS(False,
                                  (ptxMsgIllegalModifier, sourcePos, ".level::eviction_priority",
                                   "Prefetch with query fault result predicate"));
            } else {
                // Disallow L1 cache level
                stdCHECK_WITH_POS(gblState->parseData->modifiers.LEVEL == ptxL2_MOD, 
                                  (ptxMsgUnsupportedModifier, sourcePos,
                                   getLEVELAsString(gblState->parseData->modifiers.LEVEL),
                                   "Prefetch with query fault result predicate"));
            }
        }
        break;
    }

}
#endif // ada, internal

    static Bool isUnaddressableParam (ptxParsingState gblState, ptxSymbolTableEntry sym, ptxSymbolTableEntry func, msgSourcePos_t sourcePos)
    {
        if (sym->kind == ptxVariableSymbol && sym->storage.kind == ptxParamStorage) {
            stdList_t l;
            // function .param variables are either input/return parameters, or local.
            // So return True if not an input parameter OR a return parameter.
            for (l = func->aux->funcProtoAttrInfo->fparams; l; l = l->tail) {
                ptxVariableInfo VarI = l->head;
                ptxSymbol p = VarI->symbol;
                if (strcmp(p->unMangledName, sym->symbol->unMangledName)==0) return False;
            }
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
            for (l = func->aux->funcProtoAttrInfo->rparams; l; l = l->tail) {
                ptxVariableInfo VarI = l->head;
                ptxSymbol p = VarI->symbol;
                if (strcmp(p->unMangledName, sym->symbol->unMangledName)==0) {
                    stdCHECK_WITH_POS(checkTargetArch(gblState, 30),
                                      (ptxMsgFeatureRequiresSMVersion, sourcePos,
                                       "address of return parameter", "sm_30"));
                    checkFeatureVersion(gblState, 6, 0, "address of return parameter", sourcePos);
                    return False;
                }
            }
#endif
            return True;
        }
        return False;  // assume correct if we can't prove otherwise
    }
    
    static void checkAddressableParam (ptxParsingState gblState, ptxExpression arg, ptxSymbolTableEntry func, msgSourcePos_t sourcePos)
    {
        if (arg->kind == ptxSymbolExpression) {
            ptxSymbolTableEntry sym = arg->cases.Symbol.symbol;

            stdCHECK_WITH_POS( !isUnaddressableParam(gblState, sym,func,sourcePos), (ptxMsgUnaddressableParam,sourcePos,sym->symbol->unMangledName) );
        }
    }            

    static void checkAddressableFunc (ptxParsingState gblState, ptxExpression arg, msgSourcePos_t sourcePos)
    {
        if (arg->kind == ptxSymbolExpression) {
            ptxSymbolTableEntry sym = arg->cases.Symbol.symbol;

            if (sym->kind == ptxFunctionSymbol) {
                if (sym->aux->isEntry) {
                    checkFeatureVersion(gblState, 3,1,"kernel function addresses",sourcePos);
                    stdCHECK_WITH_POS( checkTargetArch(gblState, 35), (ptxMsgSMVersionRequired,sourcePos,"kernel function address","sm_35") );
                } else {
                    checkFeatureVersion(gblState, 2,1,"device function addresses",sourcePos);
                }
            }
        }
    }
    
    static void checkValidInstrTypeForFuncAddr (ptxParsingState gblState, ptxExpression arg, String name, msgSourcePos_t sourcePos)
    {
        if (arg->kind == ptxSymbolExpression) {
            ptxSymbolTableEntry sym = arg->cases.Symbol.symbol;

            if (sym->kind == ptxFunctionSymbol) {
                if (!(isB32(gblState->parseData->instructionType[0]) || isB64(gblState->parseData->instructionType[0]) || 
                      isU32(gblState->parseData->instructionType[0]) || isU64(gblState->parseData->instructionType[0])))
                {
                    String msgStr = stdCONCATSTRING(name, " instruction with function address operand");
                    stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrTypesWarn, sourcePos, msgStr));
                    stdFREE(msgStr);
                }
            }
        }
    }

    static void checkMovTexOrSurf (ptxParsingState gblState, ptxExpression arg, ptxType type, String name, msgSourcePos_t sourcePos)
    {
        if ( argIsOpaqueType(arg, &isTEXREF) ) {
            checkFeatureVersion(gblState, 3,1,"indirect texture access",sourcePos);
            stdCHECK_WITH_POS( isU64(type), (ptxMsgIndirectTexRequiresU64,sourcePos) );
            stdCHECK_WITH_POS( stdIMPLIES( !ptxVersionAtLeast(4,0, gblState), checkTargetOpts(gblState, "texmode_unified") ), (ptxMsgIndirectTexRequiresUnified,sourcePos) );
            stdCHECK_WITH_POS( checkTargetArch(gblState, 20), (ptxMsgSMVersionRequired,sourcePos,"indirect texture access","sm_20") );
        }
        if (argIsOpaqueType(arg, &isSAMPLERREF)) {
            checkFeatureVersion(gblState, 4,3,"indirect sampler access",sourcePos);
            stdCHECK_WITH_POS( isU64(type), (ptxMsgIndirectSamplerRequiresU64,sourcePos) );
            stdCHECK_WITH_POS( checkTargetArch(gblState, 30), (ptxMsgSMVersionRequired,sourcePos,"indirect sampler access","sm_30") );
        }

        if ( argIsOpaqueType(arg, &isSURFREF) ) {
            checkFeatureVersion(gblState, 3,1,"indirect surface access",sourcePos);
            stdCHECK_WITH_POS( isU64(type), (ptxMsgIndirectSurfRequiresU64,sourcePos) );
            stdCHECK_WITH_POS( checkTargetArch(gblState, 20), (ptxMsgSMVersionRequired,sourcePos,"indirect surface access","sm_20") );
        }
    }

    static uInt getCallTargetIdx(ptxParsingState gblState)
    {
        uInt i;
        for (i=0; i<gblState->parseData->nrofArguments; i++) {
            ptxExpression arg = gblState->parseData->arguments[i];
            if (arg->kind != ptxParamListExpression) {
                return i;
            }
        }
        stdASSERT( False, ("Call target not found.\n") );
        return 0; // suppress compiler warning
    }

    static int getCallReturnArgIdx(ptxParsingState gblState)
    {
        return (gblState->parseData->arguments[0]->kind == ptxParamListExpression) ? 0 : -1;
    }

    static int getCallInputArgIdx(ptxParsingState gblState)
    {
        uInt inputArgPos = getCallTargetIdx(gblState) + 1;
        if (inputArgPos < 0 || inputArgPos >= gblState->parseData->nrofArguments) {
            return -1;
        }
        return (gblState->parseData->arguments[inputArgPos]->kind == ptxParamListExpression) ? inputArgPos : -1;
    }

    // handles simple symbol expressions, returns False otherwise
    static Bool isWritableSreg(ptxExpression arg)
    {
        Bool isWritable = False;
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        if (arg->kind == ptxSymbolExpression && arg->cases.Symbol.symbol->storage.kind == ptxSregStorage) {
            String name = arg->cases.Symbol.symbol->symbol->unMangledName;
            isWritable = (strcmp(name, "%bar_warp") == 0 ||
                          strcmp(name, "%bar0" ) == 0 || strcmp(name, "%bar1" ) == 0 ||
                          strcmp(name, "%bar2" ) == 0 || strcmp(name, "%bar3" ) == 0 ||
                          strcmp(name, "%bar4" ) == 0 || strcmp(name, "%bar5" ) == 0 ||
                          strcmp(name, "%bar6" ) == 0 || strcmp(name, "%bar7" ) == 0 ||
                          strcmp(name, "%bar8" ) == 0 || strcmp(name, "%bar9" ) == 0 ||
                          strcmp(name, "%bar10") == 0 || strcmp(name, "%bar11") == 0 ||
                          strcmp(name, "%bar12") == 0 || strcmp(name, "%bar13") == 0 ||
                          strcmp(name, "%bar14") == 0 || strcmp(name, "%bar15") == 0);
        }
#endif
        return isWritable;
    }

static void checkSetInstruction(ptxParsingState gblState, uInt tcode, cString name,
                                int nrofInstructionTypes,
                                ptxType instructionType[ptxMAX_INSTR_ARGS],
                                msgSourcePos_t sourcePos)
{

    if (nrofInstructionTypes > 2) {
        stdASSERT(False, ("Incorrect template is matched for set instruction"));
        return;
    }
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
    if (((isI16(instructionType[0]) || isI32(instructionType[0])) && isF16(instructionType[1]))
        || (isI32(instructionType[0]) && isF16x2(instructionType[1])))
    {
        Char feature[] = "half precision floating point set instruction with integer result";
        checkFeatureVersion(gblState, 6, 5, feature, sourcePos);
        checkFeatureTarget(gblState, 53,   feature, sourcePos);
    }
#endif
}

#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
static void setMatrixElementSubByteType(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    if (gblState->parseData->nrofTypeMod == 2) {
        gblState->parseData->modifiers.EXPANDED_FORMAT   = gblState->parseData->typeMod[0];
        gblState->parseData->modifiers.COMPRESSED_FORMAT = gblState->parseData->typeMod[1];
    } else {
        stdCHECK_WITH_POS(False, (ptxMsgIncorrectNumberInstrTypes,
                                  sourcePos, name,
                                  getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
    }
}

#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
Bool isSubByteWMMA(ptxParsingState gblState, uInt tcode, int nrofInstructionTypes,
                   ptxType instructionType[ptxMAX_INSTR_ARGS]);
Bool isBitTypeWMMA(ptxParsingState gblState, uInt tcode, int nrofInstructionTypes,
                   ptxType instructionType[ptxMAX_INSTR_ARGS]);
#endif
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
Bool isNonStandardFPWMMA(ptxParsingState gblState, uInt tcode, int nrofInstructionTypes,
                         ptxType instructionType[ptxMAX_INSTR_ARGS]);
#endif
static Bool isTypeModAllowed(ptxParsingState gblState, uInt tcode)
{
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    if (isSubByteWMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)
        || isBitTypeWMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
        || isNonStandardFPWMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)
#endif
       )
    {
        return True;
    }
#endif
    switch(tcode) {
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
    case ptx_cvt_pack_Instr:
        return True;
#endif
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    case ptx__ldsm_Instr:
    case ptx__movm_Instr:
    case ptx__mma_Instr:
    case ptx_scatter_Instr:
        return True;
#endif
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_64)
    case ptx_mma_Instr:
        return True;
#endif

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    case ptx_add_Instr:
    case ptx_sub_Instr:
    case ptx_mul_Instr:
    case ptx_set_Instr:
    case ptx_setp_Instr:
    case ptx_ex2_Instr:
    case ptx_tanh_Instr:
    case ptx_rcp_Instr:
    case ptx_sqrt_Instr:
    case ptx_rsqrt_Instr:
    case ptx_sin_Instr:
    case ptx_cos_Instr:
    case ptx_lg2_Instr:
    case ptx__mma_warpgroup_Instr:
    case ptx_atom_Instr:
    case ptx_red_Instr:
    case ptx_cp_reduce_async_bulk_Instr:
        return True;
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptx_genmetadata_Instr:
    case ptx_spmetadata_Instr:
    case ptx_gather_Instr:
    case ptx_min_Instr:
    case ptx_max_Instr:
    case ptx_fma_Instr:
    case ptx_abs_Instr:
    case ptx_neg_Instr:
        return True;
#endif // 70
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
    case ptx_cvt_Instr:
        return True;
#endif
    default:
        return False;
    }
}

#if LWCFG(GLOBAL_ARCH_TURING)

static void checkNumModifier(ptxParsingState gblState, uInt tcode, String name, uInt vecArgIndx, msgSourcePos_t sourcePos)
{
    char num[] = ".num";
    Bool validArg;
    switch (gblState->parseData->modifiers.NUM) {
    case ptxNONUM_MOD:
        stdCHECK_WITH_POS(False, (ptxMsgModifierRequired,
                                  sourcePos, num, name));
        break;
    case ptxNUM_x1_MOD:
        validArg = (gblState->parseData->arguments[vecArgIndx]->type->kind == ptxVectorType &&
                    gblState->parseData->arguments[vecArgIndx]->type->cases.Vector.N == 1);
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_FUTURE)
        if (tcode == ptx_stmatrix_Instr) {
            validArg |= (gblState->parseData->arguments[vecArgIndx]->type->kind != ptxVectorType);
            stdCHECK_WITH_POS(validArg,
                              (ptxMsgNonMatchingInstrArgs, sourcePos, name));
        } else
#endif
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
        if (tcode == ptx_ldmatrix_Instr) {
            stdCHECK_WITH_POS(validArg,
                              (ptxMsgVectorArgumentSizeExpected,
                               sourcePos, 1, 0, name));
        } else
#endif
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
        if (tcode == ptx__ldsm_Instr) {
            validArg |= (gblState->parseData->arguments[vecArgIndx]->type->kind != ptxVectorType);
            stdCHECK_WITH_POS(validArg,
                              (ptxMsgNonMatchingInstrArgs, sourcePos, name));
        }
#endif
        break;
    case ptxNUM_x2_MOD:
        stdCHECK_WITH_POS((gblState->parseData->arguments[vecArgIndx]->type->kind == ptxVectorType
                          && gblState->parseData->arguments[vecArgIndx]->type->cases.Vector.N == 2),
                           (ptxMsgVectorArgumentSizeExpected,
                            sourcePos, 2, vecArgIndx, name));
        gblState->parseData->modifiers.VECTOR = ptxV2_MOD;
        break;
    case ptxNUM_x4_MOD:
        stdCHECK_WITH_POS((gblState->parseData->arguments[vecArgIndx]->type->kind == ptxVectorType
                          && gblState->parseData->arguments[vecArgIndx]->type->cases.Vector.N == 4),
                           (ptxMsgVectorArgumentSizeExpected,
                            sourcePos, 4, vecArgIndx, name));
        gblState->parseData->modifiers.VECTOR = ptxV4_MOD;
        break;
    default:
        break;
    }
}

static void checkMovmInstr(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    cString modifierName = getTRANSAsString(ptxTRANS_MOD);
    stdCHECK_WITH_POS(!(gblState->parseData->arguments[0]->type->kind == ptxVectorType
                      || gblState->parseData->arguments[1]->type->kind == ptxVectorType),
                       (ptxMsgVectorOperandNotAllowed, sourcePos, name));
    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_080800_MOD:
        checkFeatureVersion(gblState, 6, 3, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, minTuringArch),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), minTuringArchStr));
        if (!gblState->parseData->modifiers.TRANS) {
            stdCHECK_WITH_POS(False, (ptxMsgShapeRequiresModifier,
                                      sourcePos, modifierName, name,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        }
        if (gblState->parseData->modifiers.EXPAND) {
            stdCHECK_WITH_POS(False, (ptxMsgNotAllowedModForInstShape,
                                      sourcePos, getEXPANDAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.EXPAND),
                                      name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        }
        stdCHECK_WITH_POS(isB16(gblState->parseData->instructionType[0]), (ptxMsgNonMatchingShapeTypes,
                                                      sourcePos, name,
                                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        break;
    case ptxSHAPE_083200_MOD:
        checkFeatureVersion(gblState, 6, 3, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, minTuringArch),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), minTuringArchStr));
        if (gblState->parseData->modifiers.TRANS) {
            stdCHECK_WITH_POS(False, (ptxMsgNotAllowedModForInstShape,
                                      sourcePos, modifierName, name,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        }
        if (!gblState->parseData->modifiers.EXPAND) {
            stdCHECK_WITH_POS(False, (ptxMsgShapeRequiresModifier,
                                      sourcePos, getEXPANDAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxEXPAND_MOD),
                                      name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        }
        setMatrixElementSubByteType(gblState, name, sourcePos);
        stdCHECK_WITH_POS(gblState->parseData->nrofInstructionTypes == 1 &&
                          (isU8U4(gblState->parseData->modifiers.EXPANDED_FORMAT, gblState->parseData->modifiers.COMPRESSED_FORMAT) ||
                           isS8S4(gblState->parseData->modifiers.EXPANDED_FORMAT, gblState->parseData->modifiers.COMPRESSED_FORMAT)),
                           (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        break;
    case ptxSHAPE_086400_MOD:
        checkFeatureVersion(gblState, 6, 3, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, minTuringArch),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), minTuringArchStr));
        if (gblState->parseData->modifiers.TRANS) {
            stdCHECK_WITH_POS(False, (ptxMsgNotAllowedModForInstShape,
                                      sourcePos, modifierName, name,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        }
        if (!gblState->parseData->modifiers.EXPAND) {
            stdCHECK_WITH_POS(False, (ptxMsgShapeRequiresModifier,
                                      sourcePos, getEXPANDAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxEXPAND_MOD),
                                      name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        }
        setMatrixElementSubByteType(gblState, name, sourcePos);
        stdCHECK_WITH_POS(!gblState->parseData->nrofInstructionTypes &&
                          (isU4U2(gblState->parseData->modifiers.EXPANDED_FORMAT, gblState->parseData->modifiers.COMPRESSED_FORMAT) ||
                           isS4S2(gblState->parseData->modifiers.EXPANDED_FORMAT, gblState->parseData->modifiers.COMPRESSED_FORMAT)),
                           (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        break;
    default:
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), name));
        }
        break; 
    }
}

static void checkLdsmInstr(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos) 
{
    cString trans = getTRANSAsString(ptxTRANS_MOD);

    checkNumModifier(gblState, tcode, name, 0, sourcePos);

    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_080800_MOD: 
        checkFeatureVersion(gblState, 6, 3, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, minTuringArch),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), minTuringArchStr));
        stdCHECK_WITH_POS(isB16(gblState->parseData->instructionType[0]), (ptxMsgNonMatchingShapeTypes,
                                                      sourcePos, name,
                                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        break;
    case ptxSHAPE_081600_MOD:
        checkFeatureVersion(gblState, 6, 3, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, minTuringArch),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), minTuringArchStr));
        setMatrixElementSubByteType(gblState, name, sourcePos);
        stdCHECK_WITH_POS(isU8U4(gblState->parseData->modifiers.EXPANDED_FORMAT, gblState->parseData->modifiers.COMPRESSED_FORMAT) ||
                          isS8S4(gblState->parseData->modifiers.EXPANDED_FORMAT, gblState->parseData->modifiers.COMPRESSED_FORMAT),
                          (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        break;
    case ptxSHAPE_083200_MOD:
        checkFeatureVersion(gblState, 6, 3, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, minTuringArch),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), minTuringArchStr));
        setMatrixElementSubByteType(gblState, name, sourcePos);
        stdCHECK_WITH_POS(!gblState->parseData->nrofInstructionTypes &&
                          (isU4U2(gblState->parseData->modifiers.EXPANDED_FORMAT, gblState->parseData->modifiers.COMPRESSED_FORMAT) ||
                           isS4S2(gblState->parseData->modifiers.EXPANDED_FORMAT, gblState->parseData->modifiers.COMPRESSED_FORMAT)),
                           (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        break;
    default:
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), name));
        }
        break; 
    }

    if (gblState->parseData->modifiers.TRANS) {
        switch (gblState->parseData->modifiers.SHAPE) {
        case ptxSHAPE_080800_MOD:
             break;
        default:
            stdCHECK_WITH_POS(False, (ptxMsgNotAllowedModForShape, sourcePos,
                                      trans, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
            gblState->parseData->modifiers.TRANS = ptxNOTRANS_MOD;
            break;
        }
    }

    stdCHECK_WITH_POS(gblState->parseData->nrofInstrMemspace == 0,
                      (ptxMsgNoMemSpaceExpected,sourcePos,name));

    // Instruction _ldsm has implicit shared storage
    addStorage(gblState, ptxCreateStorageClass(ptxSharedStorage, -1), sourcePos);
}

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
static void checkLdmatrixInstr(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    checkNumModifier(gblState, tcode, name, 0, sourcePos);
    stdCHECK_WITH_POS(gblState->parseData->modifiers.ALIGN,
                      (ptxMsgModifierRequired, sourcePos, getALIGNAsString(ptxALIGNED_MOD), name));
    stdCHECK_WITH_POS(gblState->parseData->modifiers.SYNC,
                      (ptxMsgModifierRequired, sourcePos, getSYNCAsString(ptxSYNC_MOD), name));

    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_080800_MOD:
        checkFeatureVersion(gblState, 6, 5, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, 75),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), "sm_75"));
        stdCHECK_WITH_POS(isB16(gblState->parseData->instructionType[0]), (ptxMsgNonMatchingShapeTypes,
                                                      sourcePos, name,
                                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        break;
    default:
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), name));
        }
        break;
    }

    if (gblState->parseData->nrofInstrMemspace > 1) {
        stdCHECK_WITH_POS(False, (ptxMsgIncorrectMemspaces, sourcePos, name));
    }
}
#endif // 65
#endif // GLOBAL_ARCH_TURING
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_FUTURE)
static void checkStmatrixInstr(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    checkNumModifier(gblState, tcode, name, 1, sourcePos);

    stdCHECK_WITH_POS(gblState->parseData->modifiers.ALIGN,
                      (ptxMsgModifierRequired, sourcePos, getALIGNAsString(ptxALIGNED_MOD), name));
    stdCHECK_WITH_POS(gblState->parseData->modifiers.SYNC,
                      (ptxMsgModifierRequired, sourcePos, getSYNCAsString(ptxSYNC_MOD), name));

    stdCHECK_WITH_POS((gblState->parseData->modifiers.SHAPE == ptxSHAPE_080800_MOD ||
                       gblState->parseData->modifiers.SHAPE == ptxNOSHAPE_MOD),
                      (ptxMsgIllegalMatrixShape, sourcePos,
                       getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), name));
 
    stdCHECK_WITH_POS(gblState->parseData->nrofInstrMemspace <= 1 ,
                      (ptxMsgIncorrectMemspaces, sourcePos, name));
}
#endif


#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
Bool isSubByteWMMA(ptxParsingState gblState, uInt tcode, int nrofInstructionTypes,
                   ptxType instructionType[ptxMAX_INSTR_ARGS])
{
    return ptxIsWMMAInstr(tcode) && gblState->parseData->modifiers.SHAPE == ptxSHAPE_080832_MOD;
}

Bool isBitTypeWMMA(ptxParsingState gblState, uInt tcode, int nrofInstructionTypes,
                   ptxType instructionType[ptxMAX_INSTR_ARGS])
{
    return ptxIsWMMAInstr(tcode) && gblState->parseData->modifiers.SHAPE == ptxSHAPE_0808128_MOD;
}

Bool isMultiplePostOpAllowed(ptxParsingState gblState, uInt tcode)
{
    return (tcode == ptx__mma_Instr
            || isBitTypeWMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
            || tcode == ptx_mma_Instr
#endif
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
            || (tcode == ptx__mma_warpgroup_Instr && isBGMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType, gblState->parseData->modifiers, True))
#endif
           );
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
Bool checkShapeForNonStandardFpWMMA(uInt tcode, uInt shape,
                                    uInt nrofTypeMod,
                                    uInt typeMod[ptxMAX_INSTR_ARGS])
{
    uInt abTypePos;

    stdASSERT(((nrofTypeMod == 1) || (nrofTypeMod == 4)),
              ("Unexpected instruction types for non standard FP WMMA"));


    if (tcode == ptx_wmma_load_c_Instr || tcode == ptx_wmma_store_d_Instr) {
        stdASSERT(False, ("Incorrect instruction detected as non standard non standard FP-WMMA"));
        return False;
    }
    abTypePos = ptxIsWMMALoadStore(tcode) ? 0 : 1;

    switch (shape) {
    case ptxSHAPE_161608_MOD:
        return (typeMod[abTypePos] == ptxTYPE_TF32_MOD);
    case ptxSHAPE_161616_MOD:
    case ptxSHAPE_320816_MOD:
    case ptxSHAPE_083216_MOD:
        return (typeMod[abTypePos] == ptxTYPE_BF16_MOD);
    default:
        return False;
    }
}
#endif

Bool checkShapeForIntFloatWMMA(ptxParsingState gblState, uInt tcode, uInt shape,
                               int nrofInstructionTypes,
                               ptxType instructionType[ptxMAX_INSTR_ARGS],
                               uInt nrofTypeMod,
                               uInt typeMod[ptxMAX_INSTR_ARGS])
{

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    if (isNonStandardFPWMMA(gblState, tcode, nrofInstructionTypes, instructionType)) {
        return checkShapeForNonStandardFpWMMA(tcode, shape, nrofTypeMod, typeMod);
    }
#endif

    if (tcode == ptx_wmma_load_a_Instr || tcode == ptx_wmma_load_b_Instr) {
        switch (shape) {
        case ptxSHAPE_161616_MOD:
        case ptxSHAPE_320816_MOD:
        case ptxSHAPE_083216_MOD:
            return True;
        default:
            return False;
        }
    } else if (tcode == ptx_wmma_load_c_Instr || tcode == ptx_wmma_store_d_Instr) {
        switch (shape) {
        case ptxSHAPE_161616_MOD:
        case ptxSHAPE_320816_MOD:
        case ptxSHAPE_083216_MOD:
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
// For sub-byte and bit WMMA C/D Matrices are of type u32/s32 hence they are checked
// Using Integer WMMA routines
        case ptxSHAPE_080832_MOD:
        case ptxSHAPE_0808128_MOD:
#endif
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
        case ptxSHAPE_161608_MOD:
#endif
            return True;
        default:
            return False;
        }
    }
    return False;
}

Bool isIntegerWMMA(uInt tcode, int nrofInstructionTypes,
                   ptxType instructionType[ptxMAX_INSTR_ARGS])
{
#if (LWCFG(GLOBAL_CHIP_T194) || LWCFG(GLOBAL_GPU_IMPL_GV11B) || LWCFG(GLOBAL_ARCH_TURING)) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    if (!ptxIsWMMAInstr(tcode)) {
        return False;
    }

    if (nrofInstructionTypes != 1 && nrofInstructionTypes != 4) {
        return False;
    }

    if ((isS32(instructionType[0]) || isU8(instructionType[0])
        || isS8(instructionType[0])))
    {
        return True;
    }
#endif

    return False;
}

#if  LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
Bool isDoubleFPWMMA(ptxParsingState gblState, uInt tcode, int nrofInstructionTypes,
                    ptxType instructionType[ptxMAX_INSTR_ARGS])
{
    if (!ptxIsWMMAInstr(tcode)) {
        return False;
    }

    if (nrofInstructionTypes != 1 && nrofInstructionTypes != 4) {
        return False;
    }

    return isF64(instructionType[0]);
}

Bool isNonStandardFPWMMA(ptxParsingState gblState, uInt tcode, int nrofInstructionTypes,
                         ptxType instructionType[ptxMAX_INSTR_ARGS])
{
    if (!ptxIsWMMAInstr(tcode)) {
        return False;
    }

    if (nrofInstructionTypes != 0 && nrofInstructionTypes != 2) {
        return False;
    }

    // Following recognizes wmma.load/store.bf16/tf32 as FPWMMA.
    if (nrofInstructionTypes == 0 && gblState->parseData->nrofTypeMod == 1 &&
        (gblState->parseData->typeMod[0] == ptxTYPE_BF16_MOD || gblState->parseData->typeMod[0] == ptxTYPE_TF32_MOD))
    {
        return True;
    }

    // Following recognizes wmma.mma.f32.bf16/tf32.bf16/tf32.f32 as FPWMMA.
    if (nrofInstructionTypes == 2 && gblState->parseData->nrofTypeMod == 4 &&
        isF32(instructionType[0]) && isF32(instructionType[1]) &&
        (gblState->parseData->typeMod[1] == ptxTYPE_BF16_MOD || gblState->parseData->typeMod[1] == ptxTYPE_TF32_MOD) &&
        (gblState->parseData->typeMod[1] == gblState->parseData->typeMod[2]))
    {
        return True;
    }

    return False;
}

#endif // Ampere && ISA_70

Bool isFloatingPointWMMA(ptxParsingState gblState, uInt tcode, int nrofInstructionTypes,
                         ptxType instructionType[ptxMAX_INSTR_ARGS])
{
    if (!ptxIsWMMAInstr(tcode)) {
        return False;
    }

#if  LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    if (isNonStandardFPWMMA(gblState, tcode, nrofInstructionTypes, instructionType)) {
        return True;
    }
#endif

    if (nrofInstructionTypes <= 0) {
        return False;
    }

    if (isF16(instructionType[0]) || isF32(instructionType[0])) {
        return True;
    }

    return False;
}

Bool isHMMA(uInt tcode, uInt nrofInstructionTypes,
            ptxType instructionType[ptxMAX_INSTR_ARGS])
{
    if (tcode != ptx__mma_Instr) {
        return False;
    }

    return (nrofInstructionTypes > 0 &&
            (isF32(instructionType[0]) || isF16(instructionType[0])));
}

#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
extern Bool isBMMA(ptxParsingState gblState, uInt tcode, uInt nrofInstructionTypes,
            ptxType instructionType[ptxMAX_INSTR_ARGS],
            ptxModifier modifiers, Bool useTypeMod)
{
    if (tcode != ptx__mma_Instr) {
        return False;
    }
    
    if (useTypeMod && gblState->parseData->nrofTypeMod < 2)  return False;

    if (nrofInstructionTypes != 2) return False;
    
    if (useTypeMod) {
        if (!(gblState->parseData->typeMod[1] == ptxTYPE_b1_MOD && gblState->parseData->typeMod[2] == ptxTYPE_b1_MOD))
            return False;
    } else {
        if (!(modifiers.ATYPE == ptxTYPE_b1_MOD && modifiers.BTYPE == ptxTYPE_b1_MOD))
            return False;
    }

    return isS32(instructionType[0]) && isS32(instructionType[1]);
}
#endif

#if (LWCFG(GLOBAL_CHIP_T194) || LWCFG(GLOBAL_GPU_IMPL_GV11B) || LWCFG(GLOBAL_ARCH_TURING)) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
Bool isDenseIMMA(ptxParsingState gblState, uInt tcode, uInt nrofInstructionTypes,
                 ptxType instructionType[ptxMAX_INSTR_ARGS],
                 ptxModifier modifiers, Bool useTypeMod)
{
    if (tcode != ptx__mma_Instr) return False;

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    // if sparsity is present, it can't be dense IMMA.
    if (modifiers.SPARSITY) return False;
#endif

    if (useTypeMod && gblState->parseData->nrofTypeMod < 2) return False;

    if (!(nrofInstructionTypes == 0 || nrofInstructionTypes == 2 || nrofInstructionTypes == 4))
        return False;

    switch(nrofInstructionTypes) {
    case 0:
        // Dense IMMA: .u4.u4/.s4.s4
        if (useTypeMod) {
            if (gblState->parseData->nrofTypeMod != 2) return False;
            return (isI4Mod(gblState->parseData->typeMod[0]) && isI4Mod(gblState->parseData->typeMod[1]));
        }
        // Don't use typeMods
        return isI4Mod(modifiers.ATYPE) && isI4Mod(modifiers.BTYPE); 
        break;
    case 2:
        // Dense IMMA: .u8.u8/.s8.s8 or .s32.u4.u4.s32/.s32.s4.s4.s32
        if (useTypeMod) {
            switch (gblState->parseData->nrofTypeMod) {
            case 2:
                // .u8.u8/.s8.s8
                return (isI8Mod(gblState->parseData->typeMod[0]) && isI8Mod(gblState->parseData->typeMod[1]));
                break;
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
            case 4:
                //.s32.u4.u4.s32/.s32.s4.s4.s32
                return (isS32Mod(gblState->parseData->typeMod[0]) && isS32Mod(gblState->parseData->typeMod[3]) &&
                        isI4Mod(gblState->parseData->typeMod[1]) && isI4Mod(gblState->parseData->typeMod[2]));
                break;
#endif
            default:
                return False;
            }
        }
        // Don't use typeMod for detecting u8u8/s8s8 or s32u4u4s32/s32s4s4s32
        return ((isI8(instructionType[0]) && isI8(instructionType[1]))
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
                || (isS32(instructionType[0]) && isS32(instructionType[1]) &&
                    isI4Mod(modifiers.ATYPE) && isI4Mod(modifiers.BTYPE))
#endif
               );
        break;
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case 4:
        // Dense IMMA: .s32.u8.u8.s32/.s32.s8.s8.s32
        return (isS32(instructionType[0]) && isI8(instructionType[1]) &&
                isI8(instructionType[2])  && isS32(instructionType[3]));
        break;
#endif
    default:
        return False;
        break;
    }
    return False;
}

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
// This function returns True if instruction 
// is a true sparse IMMA instruction. if useTypeMod 
// is True then function does checks based on typeMod else
// uses already set ATYPE and BTYPE
Bool isSparseIMMA(ptxParsingState gblState, uInt tcode, uInt nrofInstructionTypes,  
                  ptxType instructionType[ptxMAX_INSTR_ARGS],
                  ptxModifier modifiers, Bool useTypeMod)
{
    if (tcode != ptx__mma_Instr) return False;

    if (!modifiers.SPARSITY) return False;

    if (useTypeMod && gblState->parseData->nrofTypeMod < 4) return False;
    
    if (!(nrofInstructionTypes == 2 || nrofInstructionTypes == 4)) 
        return False;    

    if (!(isS32(instructionType[0]) && isS32(instructionType[nrofInstructionTypes - 1])))
        return False;

    switch(nrofInstructionTypes) {
    case 2:
        // Sparse IMMA: s32u4u4s32/s32s4s4s32
        if (useTypeMod) {
            if ((gblState->parseData->typeMod[1] == ptxTYPE_u4_MOD || gblState->parseData->typeMod[1] == ptxTYPE_s4_MOD) &&
                (gblState->parseData->typeMod[2] == ptxTYPE_u4_MOD || gblState->parseData->typeMod[2] == ptxTYPE_s4_MOD))
            {
                return True;
            }
        } else {
            return isI4Mod(modifiers.ATYPE) && isI4Mod(modifiers.BTYPE);
        }
        break;
    case 4:
        // Sparse IMMA: s32s8s8s32/s32u8u8s32
        return isI8(instructionType[1]) && isI8(instructionType[2]);
        break;
    default:
        return False;
        break;
    }
    return False;
}
#endif // ampere, 70

Bool isIMMA(ptxParsingState gblState, uInt tcode, uInt nrofInstructionTypes,
            ptxType instructionType[ptxMAX_INSTR_ARGS], 
            ptxModifier modifiers, Bool useTypeMod)
{
   Bool isIMMA;
   isIMMA = isDenseIMMA(gblState, tcode, nrofInstructionTypes, 
                        instructionType, modifiers, useTypeMod);

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
   isIMMA = isIMMA || isSparseIMMA(gblState, tcode, nrofInstructionTypes,
                                   instructionType, modifiers, useTypeMod);
#endif

   return isIMMA;
}
#endif

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
Bool isHGMMA(uInt tcode, uInt nrofInstructionTypes,
             ptxType instructionType[ptxMAX_INSTR_ARGS])
{
    if (tcode != ptx__mma_warpgroup_Instr) {
        return False;
    }
    
    return (nrofInstructionTypes > 0 &&
            (isF32(instructionType[0])  || isF16(instructionType[0])) &&
            (!(isF8(instructionType[1]))));
}

Bool isQGMMA(uInt tcode, uInt nrofInstructionTypes,
             ptxType instructionType[ptxMAX_INSTR_ARGS])
{
    if (tcode != ptx__mma_warpgroup_Instr) {
        return False;
    }
    
    return (nrofInstructionTypes > 0 &&
            isF8(instructionType[1]));
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
Bool isIGMMA(ptxParsingState gblState, uInt tcode, uInt nrofInstructionTypes,
             ptxType instructionType[ptxMAX_INSTR_ARGS],
             ptxModifier modifiers, Bool useTypeMod)
{
    if (tcode != ptx__mma_warpgroup_Instr) {
        return False;
    }

    if (useTypeMod && gblState->parseData->nrofTypeMod < 2) return False;

    if (!(nrofInstructionTypes == 0 || nrofInstructionTypes == 2 || nrofInstructionTypes == 4))
        return False;

    switch(nrofInstructionTypes) {
    case 2:
        // IGMMA: .s32.u4.u4.s32/.s32.s4.s4.s32
        if (useTypeMod) {
            if (gblState->parseData->nrofTypeMod == 4) {
                //.s32.u4.u4.s32/.s32.s4.s4.s32
                return (isS32Mod(gblState->parseData->typeMod[0]) && isS32Mod(gblState->parseData->typeMod[3]) &&
                        isI4Mod(gblState->parseData->typeMod[1]) && isI4Mod(gblState->parseData->typeMod[2]));
            } else {
                return False;
            }
        }
        // Don't use typeMod for detecting s32u4u4s32/s32s4s4s32
        return ((isS32(instructionType[0]) && isS32(instructionType[1]) &&
                    isI4Mod(modifiers.ATYPE) && isI4Mod(modifiers.BTYPE))
               );
        break;
    case 4:
        // Dense IGMMA: .s32.u8.u8.s32/.s32.s8.s8.s32
        return (isS32(instructionType[0]) && isI8(instructionType[1]) &&
                isI8(instructionType[2])  && isS32(instructionType[3]));
        break;
    default:
        return False;
        break;
    }
    return False;
}

Bool isBGMMA(ptxParsingState gblState, uInt tcode, uInt nrofInstructionTypes,
             ptxType instructionType[ptxMAX_INSTR_ARGS],
             ptxModifier modifiers, Bool useTypeMod)
{
    if (tcode != ptx__mma_warpgroup_Instr) {
        return False;
    }
    if (useTypeMod && gblState->parseData->nrofTypeMod < 2)  return False;

    if (nrofInstructionTypes != 2) return False;
    
    if (useTypeMod) {
        if (!(gblState->parseData->typeMod[1] == ptxTYPE_b1_MOD && gblState->parseData->typeMod[2] == ptxTYPE_b1_MOD))
            return False;
    } else {
        if (!(modifiers.ATYPE == ptxTYPE_b1_MOD && modifiers.BTYPE == ptxTYPE_b1_MOD))
            return False;
    }

    return isS32(instructionType[0]) && isS32(instructionType[1]);
}
#endif // Hopper && Internal

static void checkLayoutOrder(ptxParsingState gblState, String name, msgSourcePos_t sourcePos, int alayout,
                             int blayout)
{
    if (gblState->parseData->nrofMatrixLayout < 2) {
        stdCHECK_WITH_POS(gblState->parseData->matrixLayout[0] != ptxNOLAYOUT_MOD, (ptxMsgModifierRequired, sourcePos,
                                              "alayout", name));
        stdCHECK_WITH_POS(gblState->parseData->matrixLayout[1] != ptxNOLAYOUT_MOD, (ptxMsgModifierRequired, sourcePos,
                                              "blayout", name));
        return;
    }
    stdCHECK_WITH_POS(gblState->parseData->matrixLayout[0] == alayout,
                      (ptxMsgIllegalLayout, sourcePos, 'a',
                       getLAYOUTAsString(gblState->parseData->matrixLayout[0]), name));
    stdCHECK_WITH_POS(gblState->parseData->matrixLayout[1] == blayout,
                      (ptxMsgIllegalLayout, sourcePos, 'b',
                       getLAYOUTAsString(gblState->parseData->matrixLayout[1]), name));
}

static Bool setLayoutsForMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(gblState->parseData->nrofMatrixLayout != 0,
                      (ptxMsgModifierRequired, sourcePos,
                       "'.alayout.blayout'", name));
    stdCHECK_WITH_POS(gblState->parseData->nrofMatrixLayout != 1,
                      (ptxMsgModifierRequired, sourcePos,
                       "'.blayout'", name));

    if (gblState->parseData->nrofMatrixLayout == 2) {
        gblState->parseData->modifiers.ALAYOUT = gblState->parseData->matrixLayout[0];
        gblState->parseData->modifiers.BLAYOUT = gblState->parseData->matrixLayout[1];
        return True;
    }

    return False;
}

static uInt getMatrixTypeSizeForMMA(ptxParsingState gblState, ptxMMASubType typeOfMMA, int argNum)
{
    switch(typeOfMMA) {
    case ptxMMASubTypeFpLoad:
    case ptxMMASubTypeFpStore:
    case ptxMMASubTypeNonFpLoad:
    case ptxMMASubTypeNonFpStore:
    case ptxMMASubTypeNonStdFpLoad:
        return ptxGetTypeModSize(gblState->parseData->typeMod[0]);
    case ptxMMASubTypeDoubleFpLoad:
    case ptxMMASubTypeDoubleFpStore:
    case ptxMMASubTypeWMMADoubleFp:
    case ptxMMASubTypeDMMA:
        // We treat .f64.f64.f64.f64 as instruction type and not gblState->parseData->modifiers.
        return 64;
    case ptxMMASubTypeBMMA:
    case ptxMMASubTypeIMMA:
    case ptxMMASubTypeHMMA:
    case ptxMMASubTypeNonStdFp:
    case ptxMMASubTypeWMMANonFp:
    case ptxMMASubTypeWMMAFp:
    case ptxMMASubTypeWMMANonStdFp:
    case ptxMMASubTypeQGMMA:
    case ptxMMASubTypeHGMMA:
    case ptxMMASubTypeIGMMA:
    case ptxMMASubTypeBGMMA:
        return ptxGetTypeModSize(gblState->parseData->typeMod[argNum]);
    default:
        stdASSERT(False, ("Unknown MMA type"));
        return 0;
    }
}

static uInt getNrOfThreadsForMMA(ptxMMASubType typeOfMMA, int shape, int argNum)
{
    switch(typeOfMMA) {
    case ptxMMASubTypeBMMA:
    case ptxMMASubTypeIMMA:
    case ptxMMASubTypeDMMA:
    case ptxMMASubTypeNonStdFp:
    case ptxMMASubTypeWMMANonFp:
    case ptxMMASubTypeWMMAFp:
    case ptxMMASubTypeFpLoad:
    case ptxMMASubTypeFpStore:
    case ptxMMASubTypeNonFpLoad:
    case ptxMMASubTypeNonFpStore:
    case ptxMMASubTypeNonStdFpLoad:
    case ptxMMASubTypeDoubleFpLoad:
    case ptxMMASubTypeDoubleFpStore:
    case ptxMMASubTypeWMMADoubleFp:
    case ptxMMASubTypeWMMANonStdFp:
        return WARP_SIZE;
    case ptxMMASubTypeHMMA:
        if (shape == ptxSHAPE_080804_MOD) {
            return 8; // Exelwted by quad-pair
        }
        return WARP_SIZE;
    case ptxMMASubTypeQGMMA:
    case ptxMMASubTypeHGMMA:
    case ptxMMASubTypeIGMMA:
    case ptxMMASubTypeBGMMA:
        if (argNum == 2) {
            return WARP_SIZE; // Matrix B requires 1 warp 
        }
        return WARP_SIZE * 4; // Matrixes A, C, D are distributed across 4 warps
    default:
        stdASSERT(False, ("Unknown MMA type"));
        return 0;
    }
}

static uInt getRegisterTypeSizeForMMA(ptxMMASubType typeOfMMA)
{
    switch(typeOfMMA) {
    case ptxMMASubTypeHMMA:
    case ptxMMASubTypeNonStdFp:
    case ptxMMASubTypeWMMANonFp:
    case ptxMMASubTypeWMMAFp:
    case ptxMMASubTypeWMMANonStdFp:
    case ptxMMASubTypeFpLoad:
    case ptxMMASubTypeFpStore:
    case ptxMMASubTypeNonStdFpLoad:
    case ptxMMASubTypeNonFpLoad:
    case ptxMMASubTypeNonFpStore:
    case ptxMMASubTypeQGMMA:
    case ptxMMASubTypeHGMMA:
        // either of .b32 or .16x2 or .f32
    case ptxMMASubTypeBMMA:
    case ptxMMASubTypeIMMA:
    case ptxMMASubTypeIGMMA:
    case ptxMMASubTypeBGMMA:
        // either of .s32 or .b32
        return 32;
    case ptxMMASubTypeDoubleFpLoad:
    case ptxMMASubTypeDoubleFpStore:
    case ptxMMASubTypeWMMADoubleFp:
    case ptxMMASubTypeDMMA:
        // .f64
        return 64;
    default:
        stdASSERT(False, ("Unknown MMA type"));
        return 0;
    }
}

static uInt getNumElemsPerFragmentForMMA(ptxParsingState gblState, ptxMMASubType typeOfMMA, int shape,
                                         Bool isSparse, int argNum)
{
    uInt perThreadElements, matrixElementTypeSize, matrixSize, regTypeSize, nrOfThreads;
    uInt m = 0, n = 0, k = 0;

    if (shape < 0 || shape >= ptxSHAPE_MAX_MOD) {
        stdASSERT(False, ("Unexpected shape"));
    }
    if (argNum < 0 || argNum > 3) {
        stdASSERT(False, ("MMA should have only 4 arguments"));
    }
    /*
     * The formula does NOT hold for following cases:
     * (1) Argument A and B of Fp-WMMA.
     * (2) Argument A and B of WMMA Fp Load.
     * Hence, handled using specialization.
     */
    if ((typeOfMMA == ptxMMASubTypeWMMAFp || typeOfMMA == ptxMMASubTypeFpLoad) && (argNum == 1 || argNum == 2)) {
        return 8;
    }

    String shapeStr = getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, shape);
    sscanf(shapeStr, ".m%dn%dk%d", &m, &n, &k);
    regTypeSize = getRegisterTypeSizeForMMA(typeOfMMA);
    nrOfThreads = getNrOfThreadsForMMA(typeOfMMA, shape, argNum);
    matrixElementTypeSize = getMatrixTypeSizeForMMA(gblState, typeOfMMA, argNum);

    if (!nrOfThreads || !regTypeSize) {
        stdASSERT(False, ("Expecting a non-zero value for nrOfThreads and regTypeSize"));
    }

    switch(argNum) {
    case 0:
    case 3:
        matrixSize = (m * n);
        break;
    case 1:
        matrixSize = (m * k);
        // This matrix may or may not be sparse
        if(isSparse) {
            matrixSize /= 2;
        }
        break;
    case 2:
        matrixSize = (n * k);
        break;
    default:
        stdASSERT(False, ("Invalid argument number"));
        matrixSize = 0;
    }

    perThreadElements = (((matrixSize * matrixElementTypeSize) / nrOfThreads) / regTypeSize);
    return perThreadElements;
}

// FIXME: This needs to be handled in templates.
// http://lwbugs/200290538
static void checkF16x2Compatibility(ptxType argType,
                                    String name, msgSourcePos_t sourcePos)
{
    if (isB32(argType)) return;
    stdCHECK_WITH_POS(isF16x2(argType), (ptxMsgNonMatchingInstrTypes,
                                         sourcePos, name));
}

static void checkFPCompatibilityForFpMMA(ptxType instrType, ptxType argType,
                                        String name, msgSourcePos_t sourcePos)
{
    if (isF32(instrType)) {
        if (isB32(argType)) return;
        stdCHECK_WITH_POS(isF32(argType), (ptxMsgNonMatchingInstrTypes,
                                            sourcePos, name));
        return;
    }

    stdASSERT(isF16(instrType), ("only f16 or f32 in the syntax!"));
    checkF16x2Compatibility(argType, name, sourcePos);
}

static void checkArgTypeForFpMMA(ptxParsingState gblState, ptxMMASubType typeOfMMA, ptxType instrType, ptxType baseType,
                                 int argVecSize, int argIndex, String name,
                                 msgSourcePos_t sourcePos)
{
    int numElements;
    checkFPCompatibilityForFpMMA(instrType, baseType, name, sourcePos);

    stdASSERT(isF16(instrType) || isF32(instrType), ("only f16 or f32 in the syntax!"));

    numElements = getNumElemsPerFragmentForMMA(gblState, typeOfMMA, gblState->parseData->modifiers.SHAPE,
                                               gblState->parseData->modifiers.SPARSITY, argIndex);
    stdCHECK_WITH_POS(argVecSize == numElements,
                      (ptxMsgArgumentVectorMismatch, sourcePos, name));
}

static void checkABArgTypeForFpMMA(ptxParsingState gblState, ptxMMASubType typeOfMMA, ptxType baseType, int argVecSize,
                                   int argIndex, String name, msgSourcePos_t sourcePos)
{
    int numElements = getNumElemsPerFragmentForMMA(gblState, typeOfMMA, gblState->parseData->modifiers.SHAPE,
                                                   gblState->parseData->modifiers.SPARSITY, argIndex);
    stdCHECK_WITH_POS(argVecSize == numElements,
                      (ptxMsgArgumentVectorMismatch, sourcePos, name));

#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_64)
    if (gblState->parseData->instrUsesTypeMod) {
        if (gblState->parseData->modifiers.ATYPE == ptxTYPE_TF32_MOD || gblState->parseData->modifiers.ATYPE == ptxTYPE_BF16_MOD) {
            stdCHECK_WITH_POS(isBitTypeKind(baseType->kind),
                              (ptxMsgNonMatchingInstrArgs, sourcePos, name));
        }
        return;
    }
#endif
    checkF16x2Compatibility(baseType, name, sourcePos);
}

// HMMA checks and utility functions
static void checkLayoutsForHMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    if (gblState->parseData->modifiers.SHAPE == ptxSHAPE_160808_MOD ||
        gblState->parseData->modifiers.SHAPE == ptxSHAPE_160816_MOD)
    {
        checkLayoutOrder(gblState, name, sourcePos, ptxLAYOUT_ROW_MOD, ptxLAYOUT_COL_MOD);
    }
}

static void checkArgsForHMMA(ptxParsingState gblState, uInt tcode, String name, ptxMMASubType typeOfMMA,
                             msgSourcePos_t sourcePos)
{
    int i;
    uInt dtypePos = 0, ctypePos = 1;
    Bool abcdValidTypes = False;
    // A Dense HMMA instruction with more than 4
    // arguments can come here as it can get matched with
    // a sparse _mma template. Issue a proper error.
    // e.g. _mma.m8n8k4.row.col.f32.f32 d, a, b, c, e, f;
    stdCHECK_WITH_POS(gblState->parseData->nrofArguments == 4, 
                      (ptxMsgNonMatchingInstrArgs, sourcePos, name));

    // TypeMod must contain 4 valid types before we check arguments.
    abcdValidTypes = (gblState->parseData->typeMod[0] != ptxNOTYPE_MOD && gblState->parseData->typeMod[1] != ptxNOTYPE_MOD &&
                      gblState->parseData->typeMod[2] != ptxNOTYPE_MOD && gblState->parseData->typeMod[3] != ptxNOTYPE_MOD);
    if (!abcdValidTypes) {
        stdCHECK_WITH_POS(False, (ptxMsgIncorrectNumberInstrTypes, sourcePos,
                                  name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        return;
    }

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_64)
    // For public mma atype and btype are explicit (mma.dtype.atype.btype.ctype)
    if (tcode == ptx_mma_Instr) {
        // For NonStd MMA, atype and btype are recognized as typeMod.
        ctypePos = (typeOfMMA == ptxMMASubTypeNonStdFp) ? 1 : 3;
    } else {
        ctypePos = 1;
    }
#endif

    for (i = 0; i != 4; ++i) {
        int argVecSize;
        ptxType baseType;
        if (gblState->parseData->arguments[i]->type->kind != ptxVectorType) {
            stdCHECK_WITH_POS(False, (ptxMsgVectorArgumentExpected,
                                      sourcePos, i));
            continue;
        }

        baseType = gblState->parseData->arguments[i]->type->cases.Vector.base;
        argVecSize = gblState->parseData->arguments[i]->type->cases.Vector.N;

        switch (i) {
        case 0:
            checkArgTypeForFpMMA(gblState, ptxMMASubTypeHMMA, gblState->parseData->instructionType[dtypePos], baseType,
                                 argVecSize, i, name, sourcePos);
            break;
        case 1:
        case 2:
            checkABArgTypeForFpMMA(gblState, ptxMMASubTypeHMMA, baseType, argVecSize, i, name, sourcePos);
            break;
        case 3:
           checkArgTypeForFpMMA(gblState, ptxMMASubTypeHMMA, gblState->parseData->instructionType[ctypePos], baseType,
                                argVecSize, i, name, sourcePos);
            break;
        }
    }
}

static Bool isDenseHMMAWithImplicitTypes(ptxModifier modifiers)
{
    if (modifiers.SPARSITY) {
        // Sparse HMMA
        return False;
    }
    switch(modifiers.SHAPE) {
    case ptxSHAPE_080804_MOD:
    case ptxSHAPE_160808_MOD:
    case ptxSHAPE_160816_MOD:
        return True;
    default:
        return False;
    }
}

static void checkShapeForHMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{

    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_080804_MOD:
        checkFeatureVersion(gblState, 6, 0, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, 70),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), "sm_70"));
#if LWCFG(GLOBAL_ARCH_AMPERE)
        if (!ptxIsExpandedInternally(gblState->lwrInstrSrc)) {
            if (checkTargetArch(gblState, 80)) {
                stdCHECK_WITH_POS(False,
                                  (ptxMsgIlwalidInstTargetArch, sourcePos,
                                   getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxMMA884_STR), gblState->target_arch));
            } else {
                stdCHECK_WITH_POS(!checkCompilationArch(gblState, 80),
                                  (ptxMsgIlwalidInstCompilationArch, sourcePos,
                                   getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxMMA884_STR),
                                   gblState->gpuInfo->internalName));
            }
        }
#endif
        return;
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    case ptxSHAPE_160816_MOD:
    case ptxSHAPE_160808_MOD:
    case ptxSHAPE_160804_MOD:
        //  checkFeatureVersion is explicitly used here to ensure that no errors
        //  are reported when these shapes are encountered out of macro expansions.
        checkFeatureVersion(gblState, 6, 3, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, minTuringArch),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), minTuringArchStr));
#endif
        return;
    default:
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), name));
        }
        return;
    }

}

static void checkVersionTargetForHMMA(ptxParsingState gblState, msgSourcePos_t sourcePos)
{
    char feature[] = "MMA with floating point types";
    checkFeatureVersion(gblState, 6, 0, feature, sourcePos);
    checkFeatureTarget(gblState, 70,   feature, sourcePos);
}

static void checkABCDTypesForHMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    if (gblState->parseData->nrofTypeMod != 4) {
        stdASSERT(False, ("Incorrect number of Type gblState->parseData->modifiers"));
        return;
    }

    Bool abcdTypeCheck = False;
    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_080804_MOD:
        abcdTypeCheck = gblState->parseData->typeMod[1] == ptxTYPE_f16_MOD
                        && gblState->parseData->typeMod[2] == ptxTYPE_f16_MOD
                        && stdIMPLIES(isF32Mod(gblState->parseData->typeMod[3]), isF32Mod(gblState->parseData->typeMod[0]));
        break;
    case ptxSHAPE_160804_MOD:
        abcdTypeCheck = gblState->parseData->typeMod[0] == ptxTYPE_f32_MOD
                        && gblState->parseData->typeMod[1] == ptxTYPE_TF32_MOD
                        && gblState->parseData->typeMod[2] == ptxTYPE_TF32_MOD
                        && gblState->parseData->typeMod[3] == ptxTYPE_f32_MOD;
        break;
    case ptxSHAPE_160808_MOD:
        abcdTypeCheck = gblState->parseData->typeMod[0] == ptxTYPE_f32_MOD
                        && gblState->parseData->typeMod[1] == ptxTYPE_TF32_MOD
                        && gblState->parseData->typeMod[2] == ptxTYPE_TF32_MOD
                        && gblState->parseData->typeMod[3] == ptxTYPE_f32_MOD;
        // if altfmt is not tf32 then check for bf16
        if (!abcdTypeCheck) {
            abcdTypeCheck = gblState->parseData->typeMod[0] == ptxTYPE_f32_MOD
                            && gblState->parseData->typeMod[1] == ptxTYPE_BF16_MOD
                            && gblState->parseData->typeMod[2] == ptxTYPE_BF16_MOD
                            && gblState->parseData->typeMod[3] == ptxTYPE_f32_MOD;
        }
        // if altfmt is not bf16/tf16 then check for .f16 (expanded gblState->parseData->typeMod)
        if (!abcdTypeCheck) {
            abcdTypeCheck = gblState->parseData->typeMod[0] == gblState->parseData->typeMod[3] //.dtype == .ctype
                            && gblState->parseData->typeMod[1] == ptxTYPE_f16_MOD
                            && gblState->parseData->typeMod[2] == ptxTYPE_f16_MOD; 
        }
        break;
    case ptxSHAPE_160816_MOD:
        abcdTypeCheck = gblState->parseData->typeMod[0] == ptxTYPE_f32_MOD
                        && gblState->parseData->typeMod[1] == ptxTYPE_BF16_MOD
                        && gblState->parseData->typeMod[2] == ptxTYPE_BF16_MOD
                        && gblState->parseData->typeMod[3] == ptxTYPE_f32_MOD;
        // if altfmt is not bf16/tf16 then check for .f16 (expanded gblState->parseData->typeMod)
        if (!abcdTypeCheck) {
            abcdTypeCheck = gblState->parseData->typeMod[0] == gblState->parseData->typeMod[3] // .dtype == .ctype
                            && gblState->parseData->typeMod[1] == ptxTYPE_f16_MOD
                            && gblState->parseData->typeMod[2] == ptxTYPE_f16_MOD;
        }
        break;
    default:
        stdCHECK_WITH_POS(False, (ptxMsgIncorrectNumberInstrTypes,
                                  sourcePos, name,
                                  getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
    }
    stdCHECK_WITH_POS(abcdTypeCheck,
                      (ptxMsgIllegalShapeType, sourcePos,
                       name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
    gblState->parseData->modifiers.ATYPE = gblState->parseData->typeMod[1];
    gblState->parseData->modifiers.BTYPE = gblState->parseData->typeMod[2];
}

static void checkInstrTypesForHMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    // TODO: Allow AB instruction types to be specified for standard types too.
    if (isF32(gblState->parseData->instructionType[1])) {
        stdCHECK_WITH_POS(isF32(gblState->parseData->instructionType[0]),
                          (ptxMsgCDTypeMismatchForShape, sourcePos,
                           getInstrTypeAsString(gblState, 1), getInstrTypeAsString(gblState, 1),
                           name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
    } else {
        stdASSERT(isF16(gblState->parseData->instructionType[1]),
                  ("expected only floating point instructions here"));

        switch (gblState->parseData->modifiers.SHAPE) {
        case ptxSHAPE_160808_MOD:
        case ptxSHAPE_160816_MOD:
            stdCHECK_WITH_POS(isF16(gblState->parseData->instructionType[0]),
                              (ptxMsgCDTypeMismatchForShape, sourcePos,
                               getInstrTypeAsString(gblState, 1), getInstrTypeAsString(gblState, 1),
                               name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
            break;
        default:
            break;
        }
    }

    stdCHECK_WITH_POS((gblState->parseData->typeMod[0] != ptxNOTYPE_MOD && gblState->parseData->typeMod[1] != ptxNOTYPE_MOD &&
                       gblState->parseData->typeMod[2] != ptxNOTYPE_MOD && gblState->parseData->typeMod[3] != ptxNOTYPE_MOD),
                      (ptxMsgIncorrectNumberInstrTypes, sourcePos, name,
                       getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
    if (gblState->parseData->nrofTypeMod == 4) {
        checkABCDTypesForHMMA(gblState, name, sourcePos);
    } else {
        stdCHECK_WITH_POS(False, (ptxMsgIncorrectNumberInstrTypes, sourcePos,
                                  name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
    }
}

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkVersionTargetForSparseHMMA(ptxParsingState gblState, msgSourcePos_t sourcePos)
{
    String feature = getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSparseMMA_STR);
    checkFeatureVersion(gblState, 6, 3, feature, sourcePos);
    checkFeatureTarget(gblState, 80, feature, sourcePos);
}

static Bool isSparseHMMAWithMixedPrecision(ptxType instructionType[ptxMAX_INSTR_ARGS],
                                             uInt nrofInstructionTypes)
{
    if (nrofInstructionTypes == 4) {
        return ((isF32(instructionType[0]) && isF32(instructionType[3])) &&
                (isF16(instructionType[1]) && isF16(instructionType[2])));
    }
    return False;
}

static Bool isSparseHMMAWithTF32Type(ptxParsingState gblState, ptxType instructionType[ptxMAX_INSTR_ARGS],
                                       uInt nrofInstructionTypes)
{
    Bool abcdTypeCheck = False;
    
    if (gblState->parseData->nrofTypeMod >= 4) {
        abcdTypeCheck = gblState->parseData->typeMod[0] == ptxTYPE_f32_MOD  && 
                        gblState->parseData->typeMod[1] == ptxTYPE_TF32_MOD &&
                        gblState->parseData->typeMod[2] == ptxTYPE_TF32_MOD &&
                        gblState->parseData->typeMod[3] == ptxTYPE_f32_MOD;
    }
    return abcdTypeCheck;
}

static Bool isSparseHMMAWithBF16Type(ptxParsingState gblState, ptxType instructionType[ptxMAX_INSTR_ARGS],
                                       uInt nrofInstructionTypes)
{
    Bool abcdTypeCheck = False;

    if (gblState->parseData->nrofTypeMod >= 4) {
        abcdTypeCheck = gblState->parseData->typeMod[0] == ptxTYPE_f32_MOD  &&
                        gblState->parseData->typeMod[1] == ptxTYPE_BF16_MOD &&
                        gblState->parseData->typeMod[2] == ptxTYPE_BF16_MOD &&
                        gblState->parseData->typeMod[3] == ptxTYPE_f32_MOD;
    }
    return abcdTypeCheck;
}

static void setModifiersForSparseHMMA(ptxParsingState gblState, ptxType instructionType[ptxMAX_INSTR_ARGS],
                                      uInt nrofInstructionTypes)
{
    if (isSparseHMMAWithTF32Type(gblState, instructionType, nrofInstructionTypes) ||
        isSparseHMMAWithBF16Type(gblState, instructionType, nrofInstructionTypes))
    {
        gblState->parseData->modifiers.ATYPE = gblState->parseData->typeMod[1];
        gblState->parseData->modifiers.BTYPE = gblState->parseData->typeMod[2];
    }
}

static void checkShapeForSparseHMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    switch(gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_160816_MOD:
    case ptxSHAPE_160808_MOD:
    case ptxSHAPE_160832_MOD:
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        checkFeatureVersion(gblState, 6, 3, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
#else
        checkFeatureVersion(gblState, 7, 0, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
#endif
        stdCHECK_WITH_POS(checkTargetArch(gblState, 80),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), "sm_80"));
        break;
    default:
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), name));
        }
        break;
    }
}

static void checkInstrTypesForSparseHMMA(ptxParsingState gblState, ptxType instructionType[ptxMAX_INSTR_ARGS], 
                                         String name, msgSourcePos_t sourcePos)
{
    Bool abcdTypeCheck, allF16, mixF16F32, hasTF32Mod, hasBF16Mod;
    
    allF16       = areAllFourMatrixTypesF16(instructionType, gblState->parseData->nrofInstructionTypes);
    mixF16F32    = isSparseHMMAWithMixedPrecision(instructionType, gblState->parseData->nrofInstructionTypes);
    hasTF32Mod   = isSparseHMMAWithTF32Type(gblState, instructionType, gblState->parseData->nrofInstructionTypes);
    hasBF16Mod   = isSparseHMMAWithBF16Type(gblState, instructionType, gblState->parseData->nrofInstructionTypes);

    switch(gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_160816_MOD:
        abcdTypeCheck = (gblState->parseData->nrofInstructionTypes == 2 && (hasTF32Mod || hasBF16Mod)) ||
                        (gblState->parseData->nrofInstructionTypes == 4 && (allF16 || mixF16F32));
        break;
    case ptxSHAPE_160808_MOD:
        abcdTypeCheck = (gblState->parseData->nrofInstructionTypes == 2) && hasTF32Mod;
        break;
    case ptxSHAPE_160832_MOD:
        abcdTypeCheck = (gblState->parseData->nrofInstructionTypes == 4 && (allF16 || mixF16F32)) ||
                        (gblState->parseData->nrofInstructionTypes == 2 &&  hasBF16Mod);
        break;
    default:
        abcdTypeCheck = False;
        break;
    }
    
    stdCHECK_WITH_POS(abcdTypeCheck,
                      (ptxMsgIllegalShapeType, sourcePos,
                       name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
}

static void checkLayoutsForSparseHMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    if (gblState->parseData->modifiers.SHAPE == ptxSHAPE_160808_MOD ||
        gblState->parseData->modifiers.SHAPE == ptxSHAPE_160816_MOD ||
        gblState->parseData->modifiers.SHAPE == ptxSHAPE_160832_MOD)
    {
        checkLayoutOrder(gblState, name, sourcePos, ptxLAYOUT_ROW_MOD, ptxLAYOUT_COL_MOD);
    }
}

static void checkArgTypesForSparseHMMA(ptxParsingState gblState, ptxModifier modifiers, 
                                       ptxType instructionType[ptxMAX_INSTR_ARGS],
                                       String name, msgSourcePos_t sourcePos)
{
    uInt i, argVecSize, minImmValue = 0, maxImmValue, numElements;
    Bool allF16, hasTF32Mod, hasBF16Mod;
    uInt64 immValue;

    stdASSERT(gblState->parseData->nrofArguments == 6, ("incorrect number of args"));

    for (i = 0; i != 4; ++i) {
        if (gblState->parseData->arguments[i]->type->kind != ptxVectorType) {
            stdCHECK_WITH_POS(False, (ptxMsgVectorArgumentExpected,
                                      sourcePos, i));
            continue;
        }
        argVecSize = gblState->parseData->arguments[i]->type->cases.Vector.N;
        numElements = getNumElemsPerFragmentForMMA(gblState, ptxMMASubTypeHMMA, modifiers.SHAPE,
                                                   modifiers.SPARSITY, i);
        stdCHECK_WITH_POS(argVecSize == numElements,
                          (ptxMsgArgumentVectorMismatch, sourcePos, name));
    }

    stdASSERT(gblState->parseData->arguments[5]->kind == ptxIntConstantExpression, ("Immediate expected"));
    immValue = gblState->parseData->arguments[5]->cases.IntConstant.i;

    allF16       = areAllFourMatrixTypesF16(gblState->parseData->instructionType, gblState->parseData->nrofInstructionTypes);
    hasTF32Mod   = isSparseHMMAWithTF32Type(gblState, gblState->parseData->instructionType, gblState->parseData->nrofInstructionTypes);
    hasBF16Mod   = isSparseHMMAWithBF16Type(gblState, gblState->parseData->instructionType, gblState->parseData->nrofInstructionTypes);

    if ((modifiers.SHAPE == ptxSHAPE_160832_MOD && (allF16 || hasBF16Mod)) ||
        (modifiers.SHAPE == ptxSHAPE_160816_MOD && hasTF32Mod)) 
    {
        // This indicates only a thread-pair or a byte-pair, 
        // so maxImmValue should be 1.
        maxImmValue = 1;
    } else {
        // This indicates a thread in a quad or a byte in 32bits,
        // so maxImmValue should be 3.
        maxImmValue = 3;
    }

    stdCHECK_WITH_POS((minImmValue <= immValue && immValue <= maxImmValue),
                      (ptxMsgArgValueOutOfRange, sourcePos, 6,
                       name, immValue, minImmValue, maxImmValue));
}

static void checkSparseHMMA(ptxParsingState gblState, ptxType instructionType[ptxMAX_INSTR_ARGS], 
                            String name, msgSourcePos_t sourcePos)
{
    checkVersionTargetForSparseHMMA(gblState, sourcePos);
    if (setLayoutsForMMA(gblState, name, sourcePos)) {
        checkLayoutsForSparseHMMA(gblState, name, sourcePos);
    } 
    setModifiersForSparseHMMA(gblState, instructionType, gblState->parseData->nrofInstructionTypes);
    checkShapeForSparseHMMA(gblState, name, sourcePos);
    checkInstrTypesForSparseHMMA(gblState, instructionType, name, sourcePos);
    checkArgTypesForSparseHMMA(gblState, gblState->parseData->modifiers, instructionType, name, sourcePos);
}
#endif // ampere, future

#if LWCFG(GLOBAL_ARCH_AMPERE)
static void checkSatfiniteForHMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    if (!(gblState->parseData->modifiers.SATF)) return;

    if (ptxIsExpandedInternally(gblState->lwrInstrSrc)) return;

    // Issue Error on satfinite with .target sm_80+
    stdCHECK_WITH_POS(!checkTargetArch(gblState, 80),
                      (ptxMsgModUnsupportedArchError, sourcePos, get_strSATF(gblState->parseData),
                       name, "with floating point type", "sm_80"));
}
#endif

static void checkHMMA(ptxParsingState gblState, ptxInstructionTemplate template, String name, msgSourcePos_t sourcePos)
{
    uInt tcode = template->code;

    checkVersionTargetForHMMA(gblState, sourcePos);

    // Check for sparse and dense HMMA
#if LWCFG(GLOBAL_ARCH_AMPERE)
    checkSatfiniteForHMMA(gblState, name, sourcePos);
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    // if sparsity feature is present, .sp mod must be present
    stdCHECK_WITH_POS(stdIMPLIES(ptxHasSPARSITY_Feature(template->features),
                                 ptxHasSPARSITY_MOD(gblState->parseData->modifiers)),
                                 (ptxMsgModifierRequired, sourcePos,
                                  getSPARSITYAsString(ptxSPARSITY_MOD), name));

    if (gblState->parseData->modifiers.SPARSITY) {
        String s = stdCONCATSTRING(getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSparse_STR), name);
        checkSparseHMMA(gblState, gblState->parseData->instructionType, s, sourcePos);
        stdFREE(s);
        return;
    }
#endif 

    if (setLayoutsForMMA(gblState, name, sourcePos)) {
        checkLayoutsForHMMA(gblState, name, sourcePos);
    }

    stdASSERT(gblState->parseData->nrofInstructionTypes == 2, ("expected two instruction types"));

    checkInstrTypesForHMMA(gblState, name, sourcePos);
    checkShapeForHMMA(gblState, tcode, name, sourcePos);
    checkArgsForHMMA(gblState, tcode, name, ptxMMASubTypeHMMA, sourcePos);
}

// IMMA checks and utility functions
#if (LWCFG(GLOBAL_CHIP_T194) || LWCFG(GLOBAL_GPU_IMPL_GV11B) || LWCFG(GLOBAL_ARCH_TURING)) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
static void setABTypesForIMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    if (gblState->parseData->nrofTypeMod == 4) {
        // .s32.s4.s4.s32 or .s32.u4.u4.s32
        gblState->parseData->modifiers.ATYPE = gblState->parseData->typeMod[1];
        gblState->parseData->modifiers.BTYPE = gblState->parseData->typeMod[2];
    } else {
        stdCHECK_WITH_POS(False, (ptxMsgIncorrectNumberInstrTypes,
                                  sourcePos, name,
                                  getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
    }
}

static void checkCDArgTypeForIMMA(ptxParsingState gblState, uInt tcode, ptxExpression argument,
                                  int argNum, String name,
                                  msgSourcePos_t sourcePos)
{
    uInt numElements;

    stdCHECK_WITH_POS(argument->type->kind == ptxVectorType,
                      (ptxMsgVectorArgumentExpected, sourcePos, argNum));

    numElements = getNumElemsPerFragmentForMMA(gblState, ptxMMASubTypeIMMA, gblState->parseData->modifiers.SHAPE,
                                               gblState->parseData->modifiers.SPARSITY, argNum);

    if (argument->type->kind == ptxVectorType) {
        stdCHECK_WITH_POS(argument->type->cases.Vector.N == numElements,
                          (ptxMsgArgumentVectorMismatch, sourcePos, name));
    }
}

static void checkABArgTypeForIMMA(ptxParsingState gblState, uInt tcode, ptxExpression argument,
                                  int argNum, String name,
                                  msgSourcePos_t sourcePos)
{
    uInt numElements;
 
    numElements = getNumElemsPerFragmentForMMA(gblState, ptxMMASubTypeIMMA, gblState->parseData->modifiers.SHAPE,
                                               gblState->parseData->modifiers.SPARSITY, argNum);

    if (argument->type->kind == ptxVectorType) {
        stdCHECK_WITH_POS(argument->type->cases.Vector.N == numElements,
                          (ptxMsgArgumentVectorMismatch, sourcePos, name));
    }
}

static void checkArgsForIMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    stdASSERT(gblState->parseData->nrofArguments == 4, ("expected four arguments"));

    checkCDArgTypeForIMMA(gblState, tcode, gblState->parseData->arguments[0], 0, name, sourcePos);
    checkABArgTypeForIMMA(gblState, tcode, gblState->parseData->arguments[1], 1, name, sourcePos);
    checkABArgTypeForIMMA(gblState, tcode, gblState->parseData->arguments[2], 2, name, sourcePos);
    checkCDArgTypeForIMMA(gblState, tcode, gblState->parseData->arguments[3], 3, name, sourcePos);
}

static void checkInstrTypesForIMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    char feature[] = "MMA with integer types";
    if (!gblState->parseData->modifiers.SHAPE) {
        return;
    }

    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_080816_MOD:
        stdCHECK_WITH_POS(((gblState->parseData->nrofInstructionTypes == 2) &&
                          (isI8(gblState->parseData->instructionType[0]) && isI8(gblState->parseData->instructionType[1]))),
                          (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        return;
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    case ptxSHAPE_080832_MOD:
        stdCHECK_WITH_POS(!gblState->parseData->nrofInstructionTypes &&
                          (isI4Mod(gblState->parseData->modifiers.ATYPE) && isI4Mod(gblState->parseData->modifiers.BTYPE)),
                          (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        return;
#endif
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptxSHAPE_160816_MOD:
        stdCHECK_WITH_POS(((gblState->parseData->nrofInstructionTypes == 4) &&
                          (isI8(gblState->parseData->instructionType[1]) && isI8(gblState->parseData->instructionType[2]))),
                          (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        return;
    case ptxSHAPE_160832_MOD:
        if (gblState->parseData->nrofInstructionTypes == 4) {
            stdCHECK_WITH_POS((isI8(gblState->parseData->instructionType[1]) && isI8(gblState->parseData->instructionType[2])),
                              (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                               getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        }
        else if (gblState->parseData->nrofInstructionTypes == 2) {
            stdCHECK_WITH_POS((isI4Mod(gblState->parseData->modifiers.ATYPE) && isI4Mod(gblState->parseData->modifiers.BTYPE)),
                              (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                               getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        }
        else {
             stdCHECK_WITH_POS(False, (ptxMsgNonMatchingShapeTypes, sourcePos,
                                       name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        }
        return;
    case ptxSHAPE_160864_MOD:
        stdCHECK_WITH_POS(((gblState->parseData->nrofInstructionTypes == 2) &&
                          (isI4Mod(gblState->parseData->modifiers.ATYPE) && isI4Mod(gblState->parseData->modifiers.BTYPE))),
                          (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        return;
#endif

    default:
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE),
                                      feature));
        }
        return;
    }
}
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
static void checkInstrTypeSubByteIMMA(ptxParsingState gblState, uInt tcode, cString name, msgSourcePos_t sourcePos)
{
    if (tcode != ptx_wmma_load_a_Instr && tcode != ptx_wmma_load_b_Instr) {
        return;
    }

    if (gblState->parseData->nrofTypeMod != 1 || gblState->parseData->nrofInstructionTypes != 0) {
        stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrTypes, sourcePos, name));
        return;
    }

    stdCHECK_WITH_POS(isI4Mod(gblState->parseData->typeMod[0]),
                      (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                       getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
    if (tcode == ptx_wmma_load_a_Instr) {
        gblState->parseData->modifiers.ATYPE = gblState->parseData->typeMod[0];
    } else {
        gblState->parseData->modifiers.BTYPE = gblState->parseData->typeMod[0];
    }
    // wmma.load.c and wmma.store.d are checked using integer wmma check routines
}

static void checkInstrTypeBitWMMA(ptxParsingState gblState, uInt tcode, cString name, msgSourcePos_t sourcePos)
{
    if (tcode != ptx_wmma_load_a_Instr && tcode != ptx_wmma_load_b_Instr) {
        return;
    }

    if (gblState->parseData->nrofTypeMod != 1 || gblState->parseData->nrofInstructionTypes != 0) {
        stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrTypes, sourcePos, name));
        return;
    }

    stdCHECK_WITH_POS(gblState->parseData->typeMod[0] == ptxTYPE_b1_MOD,
                      (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                       getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
    if (tcode == ptx_wmma_load_a_Instr) {
        gblState->parseData->modifiers.ATYPE = gblState->parseData->typeMod[0];
    } else {
        gblState->parseData->modifiers.BTYPE = gblState->parseData->typeMod[0];
    }

    // wmma.load.c and wmma.store.d are checked using integer wmma check routines
}

static void checkInstrLayoutSubByteBitWMMA(ptxParsingState gblState, uInt tcode, cString name, msgSourcePos_t sourcePos)
{
    int alayout;
    if (tcode != ptx_wmma_load_a_Instr && tcode != ptx_wmma_load_b_Instr) {
        return;
    }

    if (tcode == ptx_wmma_load_a_Instr) {
        alayout = ptxLAYOUT_ROW_MOD;
    } else {
        alayout = ptxLAYOUT_COL_MOD;
    }
    stdCHECK_WITH_POS(gblState->parseData->matrixLayout[0] == alayout,
                      (ptxMsgIllegalLayout, sourcePos, 'a',
                       getLAYOUTAsString(gblState->parseData->matrixLayout[0]), name));

}

static void checkInstrLayoutSubByteWMMA(ptxParsingState gblState, uInt tcode, cString name, msgSourcePos_t sourcePos)
{
    checkInstrLayoutSubByteBitWMMA(gblState, tcode, name, sourcePos);
}

static void checkInstrLayoutBitWMMA(ptxParsingState gblState, uInt tcode, cString name, msgSourcePos_t sourcePos)
{
    checkInstrLayoutSubByteBitWMMA(gblState, tcode, name, sourcePos);
}
#endif

static Bool isDenseIMMAWithImplicitTypes(ptxModifier modifiers)
{
    if (modifiers.SPARSITY) {
        // sparse IMMA
        return False;
    }
    switch(modifiers.SHAPE) {
    case ptxSHAPE_080816_MOD:
    case ptxSHAPE_080832_MOD:
        return True;
    default:
        return False;
    }
}

static void checkShapeForIMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    String featureWithShape = stdCONCATSTRING("Integer MMA with shape ",
                                              getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE));
#endif
    char feature[] = "MMA with integer types";

    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_080816_MOD:
        checkFeatureVersion(gblState, 6, 3, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, 72),
                          (ptxMsgFeatureRequiresSMVersion, sourcePos,
                           feature, "sm_72"));

        return;
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    case ptxSHAPE_080832_MOD:
        checkFeatureVersion(gblState, 6, 3, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, minTuringArch),
                          (ptxMsgFeatureRequiresSMVersion, sourcePos,
                           featureWithShape, minTuringArchStr));
        return;
#endif
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptxSHAPE_160816_MOD:
    case ptxSHAPE_160832_MOD:
    case ptxSHAPE_160864_MOD:
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        checkFeatureVersion(gblState, 6, 4, featureWithShape, sourcePos);
#else
        checkFeatureVersion(gblState, 7, 0, featureWithShape, sourcePos);
#endif
        stdCHECK_WITH_POS(checkTargetArch(gblState, 80),
                          (ptxMsgFeatureRequiresSMVersion, sourcePos,
                           featureWithShape, "sm_80"));
        return;
#endif
    default:
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE),
                                      feature));
        }
        return;
    }
}

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkVersionTargetForSparseIMMA(ptxParsingState gblState, msgSourcePos_t sourcePos)
{

    String feature = getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSparseMMAINT_STR);
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    checkFeatureVersion(gblState, 6, 3, feature, sourcePos);
#else
    checkFeatureVersion(gblState, 7, 0, feature, sourcePos);
#endif
    stdCHECK_WITH_POS(checkTargetArch(gblState, 80),
                      (ptxMsgFeatureRequiresSMVersion, sourcePos,
                       feature, "sm_80"));
}

static void setABTypesForSparseIMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    // Sparse IMMA can have either u4u4u32 or u8u8u32.
    if (gblState->parseData->nrofTypeMod == 4 &&
        (gblState->parseData->nrofInstructionTypes == 2 || gblState->parseData->nrofInstructionTypes == 4)) 
    {
        gblState->parseData->modifiers.ATYPE = gblState->parseData->typeMod[1];
        gblState->parseData->modifiers.BTYPE = gblState->parseData->typeMod[2];
    } else {
        stdCHECK_WITH_POS(False, (ptxMsgIncorrectNumberInstrTypes,
                                  sourcePos, name,
                                  getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
    }
}

static void checkShapeForSparseIMMA(ptxParsingState gblState, msgSourcePos_t sourcePos)
{

    String feature = getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSparseMMAINT_STR);
    String featureWithShape = stdCONCATSTRING(getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSparseMMAINTSHAPE_STR),
                                              getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE));

    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_080832_MOD:
    case ptxSHAPE_080864_MOD:
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        checkFeatureVersion(gblState, 6, 3, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
#else
        checkFeatureVersion(gblState, 7, 0, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
#endif
        stdCHECK_WITH_POS(checkTargetArch(gblState, 80),
                          (ptxMsgFeatureRequiresSMVersion, sourcePos,
                           feature, "sm_80"));
        return;
     case ptxSHAPE_160832_MOD:
     case ptxSHAPE_160864_MOD:
     case ptxSHAPE_1608128_MOD:
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        checkFeatureVersion(gblState, 6, 4, featureWithShape, sourcePos);
#else
        checkFeatureVersion(gblState, 7, 0, featureWithShape, sourcePos);
#endif
        stdCHECK_WITH_POS(checkTargetArch(gblState, 80),
                          (ptxMsgFeatureRequiresSMVersion, sourcePos,
                           featureWithShape, "sm_80"));
        return;
    default:
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE),
                                      feature));
        }
        return;
    }
}

static void checkLayoutsForSparseIMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_080832_MOD:
    case ptxSHAPE_080864_MOD:
    case ptxSHAPE_160832_MOD:
    case ptxSHAPE_160864_MOD:
    case ptxSHAPE_1608128_MOD:
        checkLayoutOrder(gblState, name, sourcePos, ptxLAYOUT_ROW_MOD, ptxLAYOUT_COL_MOD);
    }
}

static void checkInstrTypesForSparseIMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{

    String feature = getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSparseMMAINT_STR);
    if (!gblState->parseData->modifiers.SHAPE) {
        return;
    }

    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_080832_MOD:
    case ptxSHAPE_160832_MOD:
        stdCHECK_WITH_POS(((gblState->parseData->nrofInstructionTypes == 4) &&
                          (isI8(gblState->parseData->instructionType[1]) && isI8(gblState->parseData->instructionType[2]))),
                          (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        return;
    case ptxSHAPE_080864_MOD:
    case ptxSHAPE_1608128_MOD:
        stdCHECK_WITH_POS((gblState->parseData->nrofInstructionTypes == 2) &&
                          (isI4Mod(gblState->parseData->modifiers.ATYPE) && isI4Mod(gblState->parseData->modifiers.BTYPE)),
                          (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        return;
    case ptxSHAPE_160864_MOD:
        if (gblState->parseData->nrofInstructionTypes == 4) {
            stdCHECK_WITH_POS((isI8(gblState->parseData->instructionType[1]) && isI8(gblState->parseData->instructionType[2])),
                              (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                               getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        } else if (gblState->parseData->nrofInstructionTypes == 2) {
            stdCHECK_WITH_POS((isI4Mod(gblState->parseData->modifiers.ATYPE) && isI4Mod(gblState->parseData->modifiers.BTYPE)),
                              (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                               getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        } else {
             stdCHECK_WITH_POS(False, (ptxMsgNonMatchingShapeTypes, sourcePos,
                                       name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        }
        return;
    default:
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE),
                                      feature));
        }
        return;
    }
}

static void checkABArgTypeForSparseIMMA(ptxParsingState gblState, ptxExpression arguments[ptxMAX_INSTR_ARGS],
                                        String name, msgSourcePos_t sourcePos)
{
    uInt numAElements, numBElements;
    ptxExpression matrixA = arguments[1], matrixB = arguments[2];

    numAElements = getNumElemsPerFragmentForMMA(gblState, ptxMMASubTypeIMMA, gblState->parseData->modifiers.SHAPE,
                                                gblState->parseData->modifiers.SPARSITY, 1);
    numBElements = getNumElemsPerFragmentForMMA(gblState, ptxMMASubTypeIMMA, gblState->parseData->modifiers.SHAPE,
                                                gblState->parseData->modifiers.SPARSITY, 2);

    // Check A
    if (matrixA->type->kind == ptxVectorType) {
        stdCHECK_WITH_POS(matrixA->type->cases.Vector.N == numAElements,
                          (ptxMsgArgumentVectorMismatch, sourcePos, name));
    }

    // Check B
    stdCHECK_WITH_POS(matrixB->type->kind == ptxVectorType,
                      (ptxMsgVectorArgumentExpected, sourcePos, 2));

    if (matrixB->type->kind == ptxVectorType) {
        stdCHECK_WITH_POS(matrixB->type->cases.Vector.N == numBElements,
                          (ptxMsgArgumentVectorMismatch, sourcePos, name));
    }
}

static void checkCDArgTypeForSparseIMMA(ptxParsingState gblState, uInt tcode, ptxExpression arguments[ptxMAX_INSTR_ARGS],
                                        String name, msgSourcePos_t sourcePos)
{
    uInt numCElements, numDElements;
    ptxExpression matrixC = arguments[3];
    ptxExpression matrixD = arguments[0];

    if (matrixC->type->kind != ptxVectorType) {
        stdCHECK_WITH_POS(False, (ptxMsgVectorArgumentExpected, sourcePos, 3));
        return;
    }

    if (matrixD->type->kind != ptxVectorType)  {
        stdCHECK_WITH_POS(False, (ptxMsgVectorArgumentExpected, sourcePos, 0));
        return;
    }

    numCElements = getNumElemsPerFragmentForMMA(gblState, ptxMMASubTypeIMMA, gblState->parseData->modifiers.SHAPE,
                                                gblState->parseData->modifiers.SPARSITY, 3);
    numDElements = getNumElemsPerFragmentForMMA(gblState, ptxMMASubTypeIMMA, gblState->parseData->modifiers.SHAPE,
                                                gblState->parseData->modifiers.SPARSITY, 0);

    stdCHECK_WITH_POS(matrixC->type->cases.Vector.N == numCElements,
                      (ptxMsgArgumentVectorMismatch, sourcePos, name));

    stdCHECK_WITH_POS(matrixD->type->cases.Vector.N == numDElements,
                      (ptxMsgArgumentVectorMismatch, sourcePos, name));
}

static uInt getMaxSparsitySelectorForSparseIMMA(uInt shape, Bool isI4TypeMod) {
    // TODO: It should be possible to colwert this into formula.
    switch (shape) {
    case ptxSHAPE_080832_MOD:
    case ptxSHAPE_080864_MOD:
        // Thread id within a quad or byte-id within 32 bits.
        return 3;
    case ptxSHAPE_160832_MOD:
        // Thread-pair within a quad or a byte-pair within 32 bits.
        return 1;
    case ptxSHAPE_1608128_MOD:
        // Entire quad or entire 32 bits.
        return 0;
    case ptxSHAPE_160864_MOD:
        // Thread/Byte pair or entire quad/Byte depending upon .{u/s}4 or .{u/s}8
        return (isI4TypeMod) ? 1 : 0;
    default:
        // To avoid warning.
        return 0;
    }
}

static void checkArgTypesForSparseIMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    uInt64 sparsitySel;
    uInt sparsitySelMax;
    Bool isI4TypeMod;

    checkABArgTypeForSparseIMMA(gblState, gblState->parseData->arguments, name, sourcePos);
    checkCDArgTypeForSparseIMMA(gblState, tcode, gblState->parseData->arguments, name, sourcePos);

    isI4TypeMod = isI4Mod(gblState->parseData->typeMod[1]) && isI4Mod(gblState->parseData->typeMod[2]);
    sparsitySelMax = getMaxSparsitySelectorForSparseIMMA(gblState->parseData->modifiers.SHAPE, isI4TypeMod); 

    stdASSERT(gblState->parseData->arguments[5]->kind == ptxIntConstantExpression, ("Immediate expected"));
    sparsitySel = gblState->parseData->arguments[5]->cases.IntConstant.i;
    stdCHECK_WITH_POS((0 <= sparsitySel && sparsitySel <= sparsitySelMax),
                      (ptxMsgArgValueOutOfRange, sourcePos, 6,
                       name, sparsitySel, 0, sparsitySelMax));
}

static void checkSparseIMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    checkVersionTargetForSparseIMMA(gblState, sourcePos);
    checkShapeForSparseIMMA(gblState, sourcePos);
    if (setLayoutsForMMA(gblState, name, sourcePos)) {
        checkLayoutsForSparseIMMA(gblState, name, sourcePos);
    }
    setABTypesForSparseIMMA(gblState, name, sourcePos);
    checkInstrTypesForSparseIMMA(gblState, name, sourcePos);
    checkArgTypesForSparseIMMA(gblState, tcode, name, sourcePos);
}
#endif // ampere, future

static void checkIMMA(ptxParsingState gblState, ptxInstructionTemplate template, String name, msgSourcePos_t sourcePos)
{
    uInt tcode = template->code;
    char feature[] = "MMA with integer types";
    Bool abcdValidTypes;

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    // if sparsity feature is present, .sp mod must be present
    stdCHECK_WITH_POS(stdIMPLIES(ptxHasSPARSITY_Feature(template->features),
                                 ptxHasSPARSITY_MOD(gblState->parseData->modifiers)),
                                 (ptxMsgModifierRequired, sourcePos,
                                  getSPARSITYAsString(ptxSPARSITY_MOD), name));

    if (gblState->parseData->modifiers.SPARSITY) {
        String s = stdCONCATSTRING(getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSparse_STR), name);
        checkSparseIMMA(gblState, tcode, s, sourcePos);
        stdFREE(s);
        return;
    }
#endif 
    checkFeatureVersion(gblState, 6, 3, feature, sourcePos);
    checkShapeForIMMA(gblState, name, sourcePos);
    if (setLayoutsForMMA(gblState, name, sourcePos)) {
        checkLayoutOrder(gblState, name, sourcePos, ptxLAYOUT_ROW_MOD, ptxLAYOUT_COL_MOD);
    }

#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    if (gblState->parseData->nrofInstructionTypes == 0 || gblState->parseData->nrofInstructionTypes == 2) {
        // Sub byte IMMA (.s32.u4.u4.s32)
        setABTypesForIMMA(gblState, name, sourcePos);
    }
#endif

    checkInstrTypesForIMMA(gblState, name, sourcePos);

    // TypeMod must containt 4 valid types.
    abcdValidTypes = (gblState->parseData->typeMod[0] != ptxNOTYPE_MOD && gblState->parseData->typeMod[1] != ptxNOTYPE_MOD &&
                      gblState->parseData->typeMod[2] != ptxNOTYPE_MOD && gblState->parseData->typeMod[3] != ptxNOTYPE_MOD);
    if (!abcdValidTypes) {
        stdCHECK_WITH_POS(False, (ptxMsgIncorrectNumberInstrTypes, sourcePos,
                                  name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        return;
    }
    checkArgsForIMMA(gblState, tcode, name, sourcePos);
}
#endif

// BMMA checks and utility functions
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
static void checkShapeForBMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    char feature[] = "MMA with boolean types";
    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_0808128_MOD:
        checkFeatureVersion(gblState, 6, 3, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, minTuringArch),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), minTuringArchStr));
        return;
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptxSHAPE_1608128_MOD:
    case ptxSHAPE_1608256_MOD: {
        String featureWithShape = stdCONCATSTRING("Boolean MMA with shape ",
                                                  getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE));
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        checkFeatureVersion(gblState, 6, 4, featureWithShape, sourcePos);
#else
        checkFeatureVersion(gblState, 7, 0, featureWithShape, sourcePos);
#endif
        stdCHECK_WITH_POS(checkTargetArch(gblState, 80),
                          (ptxMsgFeatureRequiresSMVersion, sourcePos,
                           featureWithShape, "sm_80"));
        stdFREE(featureWithShape);
        return;
    }
#endif
    default:
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), feature));
        }
    }
}

static void checkInstructionTypesForBMMA(ptxParsingState gblState, uInt tcode, String name,
                                         msgSourcePos_t sourcePos)
{
    Bool abcdTypeCheck;

    if (isU32(gblState->parseData->instructionType[0]) || isU32(gblState->parseData->instructionType[1])) {
        stdCHECK_WITH_POS(False, (ptxMsgNonMatchingShapeTypes, sourcePos,
                                  name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        return;
    }

    if (gblState->parseData->nrofTypeMod == 4) {
        abcdTypeCheck = gblState->parseData->typeMod[0] == ptxTYPE_s32_MOD
                        && gblState->parseData->typeMod[1] == ptxTYPE_b1_MOD
                        && gblState->parseData->typeMod[2] == ptxTYPE_b1_MOD
                        && gblState->parseData->typeMod[3] == ptxTYPE_s32_MOD;

        stdCHECK_WITH_POS(abcdTypeCheck,
                          (ptxMsgIllegalShapeType, sourcePos,
                           name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));

        gblState->parseData->modifiers.ATYPE = gblState->parseData->typeMod[1];
        gblState->parseData->modifiers.BTYPE = gblState->parseData->typeMod[2];
    } else {
        stdCHECK_WITH_POS(False, (ptxMsgIncorrectNumberInstrTypes, sourcePos,
                                  name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
    }
}

static void checkOperationsForBMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    if (gblState->parseData->nrofBMMAOperations == 2) {
        switch (gblState->parseData->BMMAOperations[0]) {
        case ptxMMA_XOR_MOD : break;
#if LWCFG(GLOBAL_ARCH_AMPERE)
        case ptxMMA_AND_MOD :
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
            stdCHECK_WITH_POS(ptxVersionAtLeast(6, 4, gblState),
                              (ptxMsgInstModRequiresPTXVersion, sourcePos,
                               getMMA_OPAsString(ptxMMA_AND_MOD), name, "6.4"));
#else
            stdCHECK_WITH_POS(ptxVersionAtLeast(7, 1, gblState),
                              (ptxMsgInstModRequiresPTXVersion, sourcePos,
                               getMMA_OPAsString(ptxMMA_AND_MOD), name, "7.1"));
#endif // INTERNAL
            stdCHECK_WITH_POS(checkTargetArch(gblState, 80), (ptxMsgInstModRequiresSMVersion,
                                                    sourcePos, getMMA_OPAsString(ptxMMA_AND_MOD),
                                                    name, "sm_80"));
            break;
#endif // Ampere
        default:
            stdCHECK_WITH_POS(False, (ptxMsgNonMatchingOperations, sourcePos,
                                      name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        }
        stdCHECK_WITH_POS(gblState->parseData->BMMAOperations[1] == ptxMMA_POPC_MOD,
                          (ptxMsgNonMatchingOperations, sourcePos,
                           name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));

        gblState->parseData->modifiers.MMA_OP1 = gblState->parseData->BMMAOperations[0];
        gblState->parseData->modifiers.MMA_OP2 = gblState->parseData->BMMAOperations[1];
    } else {
        stdCHECK_WITH_POS(False, (ptxMsgIncorrectNumberOperations,
                                  sourcePos, name,
                                  getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
    }
    // Ensure absence of SATF
    stdCHECK_WITH_POS(!gblState->parseData->modifiers.SATF,
                      (ptxMsgIllegalModifier, sourcePos, get_strSATF(gblState->parseData), name));
}

static void checkCDArgTypeForBMMA(ptxParsingState gblState, uInt tcode, ptxExpression argument,
                                  int argNum, String name,
                                  msgSourcePos_t sourcePos)
{
    uInt argVecSize, numElements;

    if (argument->type->kind != ptxVectorType) {
        stdCHECK_WITH_POS(False,
                          (ptxMsgVectorArgumentExpected, sourcePos, argNum));
        return;
    }

    argVecSize = argument->type->cases.Vector.N;

    // Pass 0 as .sp is not possible.
    numElements = getNumElemsPerFragmentForMMA(gblState, ptxMMASubTypeBMMA, gblState->parseData->modifiers.SHAPE, 0, argNum);

    stdCHECK_WITH_POS(argVecSize == numElements,
                      (ptxMsgArgumentVectorMismatch, sourcePos, name));
}

static void checkABArgTypeForBMMA(ptxParsingState gblState, uInt tcode, ptxExpression argument, int argNum,
                                  String name, msgSourcePos_t sourcePos)
{
    uInt argVecSize, numElements;

    // Pass 0 as .sp is not possible.
    numElements = getNumElemsPerFragmentForMMA(gblState, ptxMMASubTypeBMMA, gblState->parseData->modifiers.SHAPE, 0, argNum);

    if (numElements == 1) {
        // Expecting scalar or vector with single element.
        Bool validArg = stdIMPLIES(argument->type->kind == ptxVectorType,
                                   argument->type->cases.Vector.N == 1);
        stdCHECK_WITH_POS(validArg,
                          (ptxMsgNonMatchingInstrArgs, sourcePos, name));
        return;
    }

    if (argument->type->kind != ptxVectorType) {
        stdCHECK_WITH_POS(False, (ptxMsgVectorArgumentExpected, sourcePos, argNum));
        return;
    }

    argVecSize = argument->type->cases.Vector.N;
    stdCHECK_WITH_POS(argVecSize == numElements,
                      (ptxMsgArgumentVectorMismatch, sourcePos, name));
}

static void checkArgsForBMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    stdASSERT(gblState->parseData->nrofArguments == 4, ("expected four arguments"));

    checkCDArgTypeForBMMA(gblState, tcode, gblState->parseData->arguments[0], 0, name, sourcePos);
    checkABArgTypeForBMMA(gblState, tcode, gblState->parseData->arguments[1], 1, name, sourcePos);
    checkABArgTypeForBMMA(gblState, tcode, gblState->parseData->arguments[2], 2, name, sourcePos);
    checkCDArgTypeForBMMA(gblState, tcode, gblState->parseData->arguments[3], 3, name, sourcePos);
}

static void checkBMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    char feature[] = "MMA with boolean types";

    checkFeatureVersion(gblState, 6, 3, feature, sourcePos);
    stdCHECK_WITH_POS(checkTargetArch(gblState, minTuringArch),
                      (ptxMsgFeatureRequiresSMVersion, sourcePos,
                       feature, minTuringArchStr));
    checkShapeForBMMA(gblState, tcode, name, sourcePos);

    if (setLayoutsForMMA(gblState, name, sourcePos)) {
        checkLayoutOrder(gblState, name, sourcePos, ptxLAYOUT_ROW_MOD, ptxLAYOUT_COL_MOD);
    }

    checkInstructionTypesForBMMA(gblState, tcode, name, sourcePos);
    checkOperationsForBMMA(gblState, tcode, name, sourcePos);
    checkArgsForBMMA(gblState, tcode, name, sourcePos);
}
#endif

// DMMA checks and utility functions

#if LWCFG(GLOBAL_ARCH_AMPERE) && (LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70))
static void checkRoundingModifierForDMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos) 
{
    if (!ptxHasROUND_MOD(gblState->parseData->modifiers)) {
        // Enforce .rn
        gblState->parseData->modifiers.ROUND = ptxRN_MOD;
        return;
    }

    switch(gblState->parseData->modifiers.ROUND) {
    case ptxRN_MOD:
    case ptxRM_MOD:
    case ptxRP_MOD:
    case ptxRZ_MOD:
        break;
    default:
        stdCHECK_WITH_POS(False, (ptxMsgIllegalRoundingModifier, sourcePos,name));
    }
}
#endif // Ampere && (INTERNAL || ISA_70)

#if LWCFG(GLOBAL_ARCH_AMPERE) && (LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70))
static void checkCDArgTypeForDMMA(ptxParsingState gblState, ptxExpression argument, int argNum,
                                  String name, msgSourcePos_t sourcePos)
{
    int argVecSize, numElements;

    if (argument->type->kind != ptxVectorType) {
        stdCHECK_WITH_POS(False,
                          (ptxMsgVectorArgumentExpected, sourcePos, argNum));
        return;
    }

    argVecSize = argument->type->cases.Vector.N;

    numElements = getNumElemsPerFragmentForMMA(gblState, ptxMMASubTypeDMMA, gblState->parseData->modifiers.SHAPE,
                                               gblState->parseData->modifiers.SPARSITY, argNum);
    stdCHECK_WITH_POS(argVecSize == numElements,
                      (ptxMsgArgumentVectorMismatch, sourcePos, name));
}
#endif // Ampere && (INTERNAL || ISA_70)

#if LWCFG(GLOBAL_ARCH_AMPERE) && (LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70))
static void checkABArgTypeForDMMA(ptxParsingState gblState, ptxExpression argument, int argNum,
                                  String name, msgSourcePos_t sourcePos)
{
    int numElements = getNumElemsPerFragmentForMMA(gblState, ptxMMASubTypeDMMA, gblState->parseData->modifiers.SHAPE,
                                                   gblState->parseData->modifiers.SPARSITY, argNum);
    if (argument->type->kind == ptxVectorType) {
        stdCHECK_WITH_POS(argument->type->cases.Vector.N == numElements,
                          (ptxMsgNonMatchingInstrArgs, sourcePos, name));
    }
}
#endif // Ampere && (INTERNAL || ISA_70)

#if LWCFG(GLOBAL_ARCH_AMPERE) && (LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70))
static void checkArgsForDMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    stdASSERT(gblState->parseData->nrofArguments == 4, ("expected four arguments"));

    int ii;
    for (ii = 0; ii != 4; ++ii) {
        switch (ii) {
        case 0:
        case 3:
            checkCDArgTypeForDMMA(gblState, gblState->parseData->arguments[ii], ii, name, sourcePos);
            break;
        case 1:
        case 2:
            checkABArgTypeForDMMA(gblState, gblState->parseData->arguments[ii], ii, name, sourcePos);
            break;
        default:
            break;
        }
    }
}
#endif // Ampere && (INTERNAL || ISA_70)

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static Bool isDMMA(uInt tcode, uInt nrofInstructionTypes, ptxType instructionType[ptxMAX_INSTR_ARGS])
{
    if (tcode != ptx__mma_Instr) {
        return False;
    }

    if (nrofInstructionTypes <= 0) {
        return False;
    }

    if (isF64(instructionType[0]) && isF64(instructionType[1]) && 
        isF64(instructionType[2]) && isF64(instructionType[3])) 
    {
        return True;
    }

    return False;
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkVersionTargetForDMMA(ptxParsingState gblState, String feature, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    checkFeatureVersion(gblState, 6, 3, feature, sourcePos);
#else
    checkFeatureVersion(gblState, 7, 0, feature, sourcePos);
#endif
    stdCHECK_WITH_POS(checkTargetArch(gblState, 80),
                      (ptxMsgFeatureRequiresSMVersion, sourcePos,
                       feature, "sm_80"));
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkShapeForDMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_080804_MOD:
        break;
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_FUTURE)
    case ptxSHAPE_160804_MOD:
    case ptxSHAPE_160808_MOD:
    case ptxSHAPE_160816_MOD:
        // FIXME: Update version check
        checkFeatureVersion(gblState, 7, 0, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, 90),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), "sm_90"));

#endif
        break;
    default:
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), name));
        }
        break;
    }
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkDMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    checkVersionTargetForDMMA(gblState, "MMA with double types", sourcePos);
    checkShapeForDMMA(gblState, name, sourcePos);
    checkLayoutOrder(gblState, name, sourcePos, ptxLAYOUT_ROW_MOD, ptxLAYOUT_COL_MOD);
    checkArgsForDMMA(gblState, name, sourcePos);

    // If no rounding modifier given, enforce .rn
    checkRoundingModifierForDMMA(gblState, name, sourcePos);
}
#endif

static void makeImplicitTypeExplicitForMMA(ptxParsingState gblState, uInt implicitTypes, uInt implicitTypeMod)
{
    /*
     * implicitTypes == 0 -> Unknown number of types are implicit.
     * implicitTypes == 1 -> AB types are implicit.
     * implicitTypes == 2 -> CD types are implicit.
     */
    stdASSERT(implicitTypes < 3,("implicitTypes must be less than 3."));

    switch (gblState->parseData->nrofTypeMod) {
    case 4:
        break;
    case 3:
        // Handles erroneous case of incorrect number of types
        gblState->parseData->typeMod[3] = implicitTypeMod;
        break;
    case 2:
        if (implicitTypes == 1) {
            // AB types are implicit
            // D A B C: typeMod[0].impliciTypeMod.implicitTypeMod.typeMod[1]
            gblState->parseData->typeMod[3] = gblState->parseData->typeMod[1];
            gblState->parseData->typeMod[1] = implicitTypeMod;
            gblState->parseData->typeMod[2] = implicitTypeMod;
        } else if (implicitTypes == 2) {
            // CD types are implicit
            // D A B C: implicitTypeMod.typeMod[0].typeMod[1].impliciTypeMod
            gblState->parseData->typeMod[2] = gblState->parseData->typeMod[1];
            gblState->parseData->typeMod[1] = gblState->parseData->typeMod[0];
            gblState->parseData->typeMod[0] = implicitTypeMod;
            gblState->parseData->typeMod[3] = implicitTypeMod;
        } else if (implicitTypes == 0) {
           // None of AB and CD are implicit.
           // But, typeMod[0] and typeMod[1] must hold valid types.
            gblState->parseData->typeMod[2] = implicitTypeMod;
            gblState->parseData->typeMod[3] = implicitTypeMod;
        }
        break;
    case 1:
        // Handles erroneous case of incorrect number of types
        gblState->parseData->typeMod[1] = implicitTypeMod;
        gblState->parseData->typeMod[2] = implicitTypeMod;
        gblState->parseData->typeMod[3] = implicitTypeMod;
        break;
    default:
        // Handles erroneous case of incorrect number of types
        return;
    }
    gblState->parseData->nrofTypeMod = 4;
}

// Umbrella function which differentiates between *MMAs except for WMMA
// and calls the respective check function.
static void checkMMA(ptxParsingState gblState, ptxInstructionTemplate template, String name, msgSourcePos_t sourcePos)
{
    uInt tcode = template->code;
    if (isHMMA(tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
        uInt implicitTypes = 0, implicitTypeMod = ptxNOTYPE_MOD;
        if (isDenseHMMAWithImplicitTypes(gblState->parseData->modifiers)) {
            // .f16 is the implicit type for AB.
            implicitTypeMod = ptxTYPE_f16_MOD; // .f16
            implicitTypes = 1; // AB implicit
        }
        makeImplicitTypeExplicitForMMA(gblState, implicitTypes, implicitTypeMod);
        checkHMMA(gblState, template, name, sourcePos);
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    } else if (isBMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, 
                      gblState->parseData->instructionType, gblState->parseData->modifiers, True)) 
    {
        // Allow both s32 and u32 to pass, error out u32 later.
        checkBMMA(gblState, tcode, name, sourcePos);
#endif // bmma
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    } else if (isDMMA(tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
        checkDMMA(gblState, tcode, name, sourcePos);
#endif
#if (LWCFG(GLOBAL_CHIP_T194) || LWCFG(GLOBAL_GPU_IMPL_GV11B) || LWCFG(GLOBAL_ARCH_TURING)) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    // Check for nrofTypeMod to detect if sub-byte IMMA.
    } else if (isIMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType, gblState->parseData->modifiers, True)) {
        uInt implicitTypes = 0, implicitTypeMod = ptxNOTYPE_MOD;
        if (isDenseIMMAWithImplicitTypes(gblState->parseData->modifiers)) {
            // .s32 is the implicit type for CD.
            implicitTypeMod = ptxTYPE_s32_MOD; // .s32
            implicitTypes = 2; // CD implicit
        }
        makeImplicitTypeExplicitForMMA(gblState, implicitTypes, implicitTypeMod);
        checkIMMA(gblState, template, name, sourcePos);
    } else {
        // Error out if no match found. 
        // This is needed because an instruction can
        // match during templates but is an illegal _mma instruction.  
        // e.g. _mma.sp.thread.m8n8k32.row.col.u32  
        stdCHECK_WITH_POS(False, 
                          (ptxMsgNonMatchingInstrTypes, sourcePos, name));
#else
    } else {
        stdASSERT(False,
                  ("Unexpected instruction."));
#endif // imma
    }
}

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_64)
static void checkVersionTargetForPublicMMA(ptxParsingState gblState, String feature, msgSourcePos_t sourcePos)
{
    checkFeatureVersion(gblState, 6, 4, feature, sourcePos);
    checkFeatureTarget(gblState, 70, feature, sourcePos);
}

static void checkLayoutsForPublicMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    switch (gblState->parseData->modifiers.SHAPE) {
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptxSHAPE_0808128_MOD:
#endif // Turing && ISA_70
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptxSHAPE_160804_MOD:
    case ptxSHAPE_160816_MOD:
    case ptxSHAPE_160832_MOD:
    case ptxSHAPE_160864_MOD:
    case ptxSHAPE_1608128_MOD:
    case ptxSHAPE_1608256_MOD:
#endif // Ampere && ISA_70
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
    case ptxSHAPE_160808_MOD:
    case ptxSHAPE_080816_MOD:
    case ptxSHAPE_080832_MOD:
        checkLayoutOrder(gblState, name, sourcePos, ptxLAYOUT_ROW_MOD, ptxLAYOUT_COL_MOD);
        break;
#endif // Turing && 65
    case ptxSHAPE_080804_MOD:
        break;
    default:
        // Report error message for invalid shape in checkShapeForPublicMMA.
        return;
    }
}

static void checkTypeForPublicMMA(ptxParsingState gblState, ptxMMASubType typeOfMMA, uInt tcode,
                                  String name, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
    if (typeOfMMA == ptxMMASubTypeUnknown) {
        stdCHECK_WITH_POS(False, (ptxMsgIllegalShapeType, sourcePos,
                                  name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        return;
    }
    if (typeOfMMA == ptxMMASubTypeIMMA) {
        stdCHECK_WITH_POS(((gblState->parseData->nrofInstructionTypes == 4) &&
                          (isS32(gblState->parseData->instructionType[0]) && isS32(gblState->parseData->instructionType[3])) &&
                          (isI8(gblState->parseData->instructionType[1]) && isI8(gblState->parseData->instructionType[2]))),
                          (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        return;
    }
    if (typeOfMMA == ptxMMASubTypeSubByteIMMA) {
        stdCHECK_WITH_POS(((gblState->parseData->nrofInstructionTypes == 2) &&
                          (isS32(gblState->parseData->instructionType[0]) && isS32(gblState->parseData->instructionType[1])) &&
                          (isI4Mod(gblState->parseData->typeMod[1]) && isI4Mod(gblState->parseData->typeMod[2]))),
                          (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        return;
    }
#endif // Turing && 65
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    if (typeOfMMA == ptxMMASubTypeDMMA || typeOfMMA == ptxMMASubTypeNonStdFp) {
        // Nothing to check here.
        return;
    }
#endif // AMPERE && ISA_70
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    if (typeOfMMA == ptxMMASubTypeBMMA) {
        checkInstructionTypesForBMMA(gblState, tcode, name, sourcePos);
        return;
    }
#endif // TURING && ISA_70
    stdASSERT(typeOfMMA == ptxMMASubTypeHMMA,
              ("Only floating point MMA's are expected to reach here"));

    if (gblState->parseData->nrofInstructionTypes != 4) {
        // Erroneous syntax.
        stdASSERT(False, ("Unexpected number of instruction types for floating point mma"));
        return;
    }

    if (isF32(gblState->parseData->instructionType[3])) {
        stdCHECK_WITH_POS(isF32(gblState->parseData->instructionType[0]),
                          (ptxMsgCDTypeMismatchForShape, sourcePos,
                           getInstrTypeAsString(gblState, 3), getInstrTypeAsString(gblState, 3),
                           name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        return;
    }
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
    stdASSERT(isF16(gblState->parseData->instructionType[3]),
              ("expected only floating point instructions here"));
    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_160808_MOD:
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptxSHAPE_160816_MOD:
#endif // Ampere && ISA_70
        stdCHECK_WITH_POS(isF16(gblState->parseData->instructionType[0]),
                          (ptxMsgCDTypeMismatchForShape, sourcePos,
                           getInstrTypeAsString(gblState, 3), getInstrTypeAsString(gblState, 3),
                           name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
         break;
    }
#endif // Turing && ISA_65
}

static Bool checkShapeForPublicHMMA(ptxParsingState gblState, ptxMMASubType typeOfMMA, String name,
                                    msgSourcePos_t sourcePos)
{
    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_080804_MOD:
        checkFeatureVersion(gblState, 6, 4, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        checkFeatureTarget(gblState, 70, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        return True;
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
    case ptxSHAPE_160808_MOD:
        if (typeOfMMA == ptxMMASubTypeNonStdFp) {
            checkFeatureVersion(gblState, 7, 0, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
            checkFeatureTarget(gblState, 80, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
            return True;
        }
        if (typeOfMMA == ptxMMASubTypeHMMA) {
            checkFeatureVersion(gblState, 6, 5, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
            checkFeatureTarget(gblState, 75, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
            return True;
        }
#endif
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptxSHAPE_160816_MOD:
    case ptxSHAPE_160804_MOD:
        checkFeatureVersion(gblState, 7, 0, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        checkFeatureTarget(gblState, 80, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        return True;
#endif
    default:
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), name));
        }
        return False;
    }
}

#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
static Bool checkShapeForPublicIMMA(ptxParsingState gblState, ptxMMASubType typeOfMMA, String name,
                                    msgSourcePos_t sourcePos)
{
    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_080816_MOD:
        // Expected only .s32.{s8/u8}.{s8/u8}.s32
        stdCHECK_WITH_POS(typeOfMMA == ptxMMASubTypeIMMA,
                          (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        checkFeatureVersion(gblState, 6, 5, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        checkFeatureTarget(gblState, 75, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        return True;
    case ptxSHAPE_080832_MOD:
        // Expected only .s32.{s4/u4}.{s4/u4}.s32
        stdCHECK_WITH_POS(typeOfMMA == ptxMMASubTypeSubByteIMMA,
                          (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        checkFeatureVersion(gblState, 6, 5, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        checkFeatureTarget(gblState, 75, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        return True;
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptxSHAPE_160816_MOD:
        // Expected only .s32.{s8/u8}.{s8/u8}.s32
        stdCHECK_WITH_POS(typeOfMMA == ptxMMASubTypeIMMA,
                          (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        checkFeatureVersion(gblState, 7, 0, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        checkFeatureTarget(gblState, 80, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        return True;
    case ptxSHAPE_160832_MOD:
        // Expected .s32.{s4/u4/s8/u8}.{s4/u4/s8/u8}.s32
        stdCHECK_WITH_POS((typeOfMMA == ptxMMASubTypeSubByteIMMA ||
                           typeOfMMA == ptxMMASubTypeIMMA),
                          (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        checkFeatureVersion(gblState, 7, 0, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        checkFeatureTarget(gblState, 80, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        return True;
    case ptxSHAPE_160864_MOD:
        // Expected only .s32.{s4/u4}.{s4/u4}.s32
        stdCHECK_WITH_POS(typeOfMMA == ptxMMASubTypeSubByteIMMA,
                          (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        checkFeatureVersion(gblState, 7, 0, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        checkFeatureTarget(gblState, 80, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        return True;
#endif // AMPERE && ISA_70
    default:
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), name));
        }
        return False;
    }
}
#endif // Turing && ISA_65

#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static Bool checkShapeForPublicBMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_0808128_MOD:
        checkFeatureVersion(gblState, 7, 0, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        checkFeatureTarget(gblState, 75, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        return True;
#if LWCFG(GLOBAL_ARCH_AMPERE)
    case ptxSHAPE_1608128_MOD:
    case ptxSHAPE_1608256_MOD:
        checkFeatureVersion(gblState, 7, 0, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        checkFeatureTarget(gblState, 80, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        return True;
#endif // Ampere
    default:
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), name));
        }
        return False;
    }
}
#endif // TURING && ISA_70

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static Bool checkShapeForPublicDMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    String FeatureWithType = stdCONCATSTRING(getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE),
                                             " with double types");
    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_080804_MOD:
        checkFeatureVersion(gblState, 7, 0, FeatureWithType , sourcePos);
        checkFeatureTarget(gblState, 80, FeatureWithType, sourcePos);
        return True;
    default:
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), name));
        }
        return False;
    }
}
#endif // AMPERE && ISA_70

static void checkModifierForPublicMMA(ptxParsingState gblState, ptxMMASubType typeOfMMA, uInt tcode,
                                      String name, msgSourcePos_t sourcePos)
{
    Bool satModAllowed;
    // Check .align
    stdCHECK_WITH_POS(gblState->parseData->modifiers.ALIGN,
                      (ptxMsgModifierRequired, sourcePos, getALIGNAsString(ptxALIGNED_MOD), name));

#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
    satModAllowed =   (typeOfMMA == ptxMMASubTypeIMMA
                    || typeOfMMA == ptxMMASubTypeSubByteIMMA
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
                    || typeOfMMA == ptxMMASubTypeSparseIMMA
                    || typeOfMMA == ptxMMASubTypeSubByteSparseIMMA
#endif
                      );
    // Check .satfinite
    stdCHECK_WITH_POS(stdIMPLIES(gblState->parseData->modifiers.SATF, satModAllowed),
                      (ptxMsgIllegalModifier, sourcePos, get_strSATF(gblState->parseData), name));
#endif // Turing && 65

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    if (typeOfMMA == ptxMMASubTypeDMMA) {
        String nameWithType = stdCONCATSTRING(name, " with double types");
        /*  Note that m8n8k4 HMMA variant puts no restriction on Layout order, but
         *  DMMA variant does enforce. Therefore, we defer Layout order checks
         *  for m8n8k4 until it is confirmed to be DMMA variant.
         */
        checkLayoutOrder(gblState, nameWithType, sourcePos, ptxLAYOUT_ROW_MOD, ptxLAYOUT_COL_MOD);
        // If no rounding modifier given, enforce .rn
        checkRoundingModifierForDMMA(gblState, nameWithType, sourcePos);
    }
#endif // AMPERE && ISA_70
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    if (typeOfMMA == ptxMMASubTypeBMMA) {
        // Check .xor/.and + .popc
        checkOperationsForBMMA(gblState, tcode, name, sourcePos);
    }
#endif // TURING && ISA_70
}

static Bool checkShapeForPublicMMA(ptxParsingState gblState, ptxMMASubType typeOfMMA, String name, msgSourcePos_t sourcePos)
{
    switch (typeOfMMA) {
    case ptxMMASubTypeHMMA:
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptxMMASubTypeNonStdFp:
#endif // AMPERE && ISA_70
        return checkShapeForPublicHMMA(gblState, typeOfMMA, name, sourcePos);
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
    case ptxMMASubTypeIMMA:
    case ptxMMASubTypeSubByteIMMA:
        return checkShapeForPublicIMMA(gblState, typeOfMMA, name, sourcePos);
#endif // Turing && ISA_65
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptxMMASubTypeDMMA:
        return checkShapeForPublicDMMA(gblState, name, sourcePos);
#endif // Ampere && ISA_70
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptxMMASubTypeBMMA:
        return checkShapeForPublicBMMA(gblState, name, sourcePos);
#endif // Turing && ISA_70
    case ptxMMASubTypeUnknown:
        stdCHECK_WITH_POS(False, (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                                  getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
    default:
        return False;
    }
}

static void checkArgsForPublicMMA(ptxParsingState gblState, ptxMMASubType typeOfMMA, uInt tcode,
                                  String name, msgSourcePos_t sourcePos)
{
    int i;
    if (gblState->parseData->nrofArguments != 4) {
        stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrArgs, sourcePos, name));
        return;
    }

    for (i = 0; i != 4; ++i) {
        stdCHECK_WITH_POS((gblState->parseData->arguments[i]->type->kind == ptxVectorType),
                          (ptxMsgVectorArgumentExpected, sourcePos, i));
    }

    switch(typeOfMMA) {
    case ptxMMASubTypeHMMA:
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptxMMASubTypeNonStdFp:
#endif // AMPERE && ISA_70
        checkArgsForHMMA(gblState, tcode, name, typeOfMMA, sourcePos);
        break;
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
    case ptxMMASubTypeIMMA:
    case ptxMMASubTypeSubByteIMMA:
        checkArgsForIMMA(gblState, tcode, name, sourcePos);
        break;
#endif // Turing && 65
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptxMMASubTypeDMMA:
        checkArgsForDMMA(gblState, name, sourcePos);
        break;
#endif // Ampere && ISA_70
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptxMMASubTypeBMMA:
        checkArgsForBMMA(gblState, tcode, name, sourcePos);
        break;
#endif // Turing && ISA_70
    default:
        return;
    }
}

static ptxMMASubType getMMASubTypeForPublicMMA(ptxParsingState gblState)
{
    if (gblState->parseData->nrofInstructionTypes == 4) {
        if (isF16(gblState->parseData->instructionType[1]) && isF16(gblState->parseData->instructionType[2])) {
            // *.f16.f16.*
            return gblState->parseData->modifiers.SPARSITY ?  ptxMMASubTypeSparseHMMA : ptxMMASubTypeHMMA;
        }
        if (isS32(gblState->parseData->instructionType[0]) && isS32(gblState->parseData->instructionType[3])) {
            // s32.*.*.s32
            // As number of instructionTypes are 4, this can't be bit/ sub byte MMA
            return gblState->parseData->modifiers.SPARSITY ?  ptxMMASubTypeSparseIMMA : ptxMMASubTypeIMMA;
        }
        if (isF64(gblState->parseData->instructionType[0]) && isF64(gblState->parseData->instructionType[1]) &&
            isF64(gblState->parseData->instructionType[2]) && isF64(gblState->parseData->instructionType[3]))
        {
            // f64.f64.f64.f64
            return ptxMMASubTypeDMMA;
        }
    }
    if (gblState->parseData->nrofInstructionTypes == 2) {
        if (isS32(gblState->parseData->instructionType[0]) && isS32(gblState->parseData->instructionType[1])) {
            // s32.*.*.s32
            // As number of instructionTypes are 2, this can be bit or sub byte MMA
            if (isB1Mod(gblState->parseData->typeMod[1]) && isB1Mod(gblState->parseData->typeMod[2])) {
                return ptxMMASubTypeBMMA;
            }
            if (isI4Mod(gblState->parseData->typeMod[1]) && isI4Mod(gblState->parseData->typeMod[2])) {
                return gblState->parseData->modifiers.SPARSITY ? ptxMMASubTypeSubByteSparseIMMA : ptxMMASubTypeSubByteIMMA;
            }
        }
        if (isF32(gblState->parseData->instructionType[0]) && isF32(gblState->parseData->instructionType[1]) &&
            (gblState->parseData->nrofTypeMod == 4) && (gblState->parseData->typeMod[1] == gblState->parseData->typeMod[2]) &&
            (gblState->parseData->typeMod[1] == ptxTYPE_BF16_MOD || gblState->parseData->typeMod[1] == ptxTYPE_TF32_MOD))
        {
            // f32.bf16/tf32.bf16/tf32.f32
            return gblState->parseData->modifiers.SPARSITY ? ptxMMASubTypeSparseNonStdFp : ptxMMASubTypeNonStdFp;
        }
    }
    return ptxMMASubTypeUnknown;
}

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
static void checkShapeForPublicSparseIMMA(ptxParsingState gblState, msgSourcePos_t sourcePos)
{
    String feature = getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSparseMMAINT_STR);
    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_080832_MOD:
    case ptxSHAPE_080864_MOD:
        stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                  getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE),
                                  feature));
        return;
    default:
        checkShapeForSparseIMMA(gblState, sourcePos);
        return;
    }
}
#endif // ampere && ISA_71

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
static Bool isSparsePublicMMA(ptxMMASubType typeOfMMA)
{
    switch(typeOfMMA) {
    case ptxMMASubTypeSparseHMMA:
    case ptxMMASubTypeSparseIMMA:
    case ptxMMASubTypeSubByteSparseIMMA:
    case ptxMMASubTypeSparseNonStdFp:
        return True;
    default:
        return False;
    }
}

static void checkPublicSparseMMA(ptxParsingState gblState, ptxMMASubType typeOfMMA, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    stdASSERT(gblState->parseData->modifiers.SPARSITY, ("Incorrect instruction is identified as sparse mma"));
    String feature = getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSparseMMA_STR);
    checkFeatureVersion(gblState, 7, 1, feature, sourcePos);
    checkFeatureTarget(gblState, 80, feature, sourcePos);
    String fullName = stdCONCATSTRING(getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSparse_STR), name);
    setLayoutsForMMA(gblState, fullName, sourcePos);

    switch(typeOfMMA) {
    case ptxMMASubTypeSparseHMMA:
    case ptxMMASubTypeSparseNonStdFp:
        checkLayoutsForSparseHMMA(gblState, fullName, sourcePos);
        setModifiersForSparseHMMA(gblState, gblState->parseData->instructionType, gblState->parseData->nrofInstructionTypes);
        checkShapeForSparseHMMA(gblState, fullName, sourcePos);
        checkInstrTypesForSparseHMMA(gblState, gblState->parseData->instructionType, fullName, sourcePos);
        checkArgTypesForSparseHMMA(gblState, gblState->parseData->modifiers, gblState->parseData->instructionType, fullName, sourcePos);
        break;
    case ptxMMASubTypeSparseIMMA:
    case ptxMMASubTypeSubByteSparseIMMA:
        checkShapeForPublicSparseIMMA(gblState, sourcePos);
        checkLayoutsForSparseIMMA(gblState, fullName, sourcePos);
        setABTypesForSparseIMMA(gblState, fullName, sourcePos);
        checkInstrTypesForSparseIMMA(gblState, fullName, sourcePos);
        checkArgTypesForSparseIMMA(gblState, tcode, fullName, sourcePos);
        break;
    default:
        stdASSERT(False, ("Incorrect sparse public mma"));
        break;
    }
    stdFREE(fullName);

}
#endif // ampere, ISA_71

static void checkPublicMMA(ptxParsingState gblState, ptxInstructionTemplate template, String name, msgSourcePos_t sourcePos)
{
    ptxMMASubType typeOfMMA;
    uInt tcode = template->code;
    checkVersionTargetForPublicMMA(gblState, name, sourcePos);
    setLayoutsForMMA(gblState, name, sourcePos);
    checkLayoutsForPublicMMA(gblState, name, sourcePos);
    typeOfMMA = getMMASubTypeForPublicMMA(gblState);
    checkModifierForPublicMMA(gblState, typeOfMMA, tcode, name, sourcePos);
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
    if (isSparsePublicMMA(typeOfMMA)) {
        checkPublicSparseMMA(gblState, typeOfMMA, template->code, name, sourcePos);
        return;
    }
#endif // ampere, ISA_71
    if (checkShapeForPublicMMA(gblState, typeOfMMA, name, sourcePos)) {
        gblState->parseData->modifiers.ATYPE = gblState->parseData->typeMod[1];
        gblState->parseData->modifiers.BTYPE = gblState->parseData->typeMod[2];
        checkTypeForPublicMMA(gblState, typeOfMMA, tcode, name, sourcePos);
        checkArgsForPublicMMA(gblState, typeOfMMA, tcode, name, sourcePos);
    }
}
#endif

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkVersionTargetForBGMMA(ptxParsingState gblState, msgSourcePos_t sourcePos)
{
    String feature = getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxBGMMA_STR);
    // FIXME: Update version/target check
    checkFeatureVersion(gblState, 7, 1, feature, sourcePos);
    checkFeatureTarget(gblState, 90,   feature, sourcePos);
}
#endif // Hopper & Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkShapeForBGMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_6408256_MOD:
    case ptxSHAPE_6416256_MOD:
    case ptxSHAPE_6424256_MOD:
    case ptxSHAPE_6432256_MOD:
    case ptxSHAPE_6448256_MOD:
    case ptxSHAPE_6464256_MOD:
    case ptxSHAPE_6480256_MOD:
    case ptxSHAPE_6496256_MOD:
    case ptxSHAPE_64112256_MOD:
    case ptxSHAPE_64128256_MOD:
    case ptxSHAPE_64144256_MOD:
    case ptxSHAPE_64160256_MOD:
    case ptxSHAPE_64176256_MOD:
    case ptxSHAPE_64192256_MOD:
    case ptxSHAPE_64208256_MOD:
    case ptxSHAPE_64224256_MOD:
    case ptxSHAPE_64240256_MOD:
    case ptxSHAPE_64256256_MOD:
        return;

    default: 
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), name));
        }
        return;
    }
}
#endif // Hopper & Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkInstructionTypesForBGMMA(ptxParsingState gblState, uInt tcode, String name,
                                         msgSourcePos_t sourcePos)
{
    Bool abcdTypeCheck;

    if (isU32(gblState->parseData->instructionType[0]) || isU32(gblState->parseData->instructionType[1])) {
        stdCHECK_WITH_POS(False, (ptxMsgNonMatchingShapeTypes, sourcePos,
                                  name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        return;
    }

    if (gblState->parseData->nrofTypeMod == 4) {
        abcdTypeCheck = gblState->parseData->typeMod[0] == ptxTYPE_s32_MOD
                        && gblState->parseData->typeMod[1] == ptxTYPE_b1_MOD
                        && gblState->parseData->typeMod[2] == ptxTYPE_b1_MOD
                        && gblState->parseData->typeMod[3] == ptxTYPE_s32_MOD;

        stdCHECK_WITH_POS(abcdTypeCheck,
                          (ptxMsgIllegalShapeType, sourcePos,
                           name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));

        gblState->parseData->modifiers.ATYPE = gblState->parseData->typeMod[1];
        gblState->parseData->modifiers.BTYPE = gblState->parseData->typeMod[2];
    } else {
        stdCHECK_WITH_POS(False, (ptxMsgIncorrectNumberInstrTypes, sourcePos,
                                  name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
    }
}
#endif // Hopper & Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkOperationsForBGMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    if (gblState->parseData->nrofBMMAOperations == 2) {
        stdCHECK_WITH_POS(gblState->parseData->BMMAOperations[0] == ptxMMA_XOR_MOD ||
                          gblState->parseData->BMMAOperations[0] == ptxMMA_AND_MOD, 
                          (ptxMsgNonMatchingOperations, sourcePos,
                           name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        stdCHECK_WITH_POS(gblState->parseData->BMMAOperations[1] == ptxMMA_POPC_MOD,
                          (ptxMsgNonMatchingOperations, sourcePos,
                           name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));

        gblState->parseData->modifiers.MMA_OP1 = gblState->parseData->BMMAOperations[0];
        gblState->parseData->modifiers.MMA_OP2 = gblState->parseData->BMMAOperations[1];
    } else {
        stdCHECK_WITH_POS(False, (ptxMsgIncorrectNumberOperations,
                                  sourcePos, name,
                                  getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
    }
    // Ensure absence of SATF
    stdCHECK_WITH_POS(!gblState->parseData->modifiers.SATF,
                      (ptxMsgIllegalModifier, sourcePos, get_strSATF(gblState->parseData), name));
}
#endif // Hopper & Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkCDArgTypeForBGMMA(ptxParsingState gblState, ptxMMASubType typeOfMMA, ptxType instrType, ptxType baseType,
                                 int argVecSize, int argIndex, String name,
                                 msgSourcePos_t sourcePos)
{
    // Pass 0 as .sp is not possible.
    int numElements = getNumElemsPerFragmentForMMA(gblState, typeOfMMA, gblState->parseData->modifiers.SHAPE, 0, argIndex);
    stdCHECK_WITH_POS(argVecSize == numElements,
                      (ptxMsgArgumentVectorMismatch, sourcePos, name));
}
#endif // Hopper & Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkABArgTypeForBGMMA(ptxParsingState gblState, ptxMMASubType typeOfMMA, ptxType baseType, int argVecSize,
                                   int argIndex, String name, msgSourcePos_t sourcePos)
{
    // Pass 0 as .sp is not possible.
    int numElements = getNumElemsPerFragmentForMMA(gblState, typeOfMMA, gblState->parseData->modifiers.SHAPE, 0, argIndex);
    stdCHECK_WITH_POS(argVecSize == numElements,
                      (ptxMsgArgumentVectorMismatch, sourcePos, name));
}
#endif // Hopper & Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkArgsForBGMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    int i;

    stdCHECK_WITH_POS((gblState->parseData->arguments[0]->type->kind == ptxVectorType),
                          (ptxMsgVectorArgumentExpected, sourcePos, 0));
    stdCHECK_WITH_POS((gblState->parseData->arguments[3]->type->kind == ptxVectorType),
                          (ptxMsgVectorArgumentExpected, sourcePos, 3));

    for (i = 0; i != 4; ++i) {
        int argVecSize;
        ptxType baseType;
        if (gblState->parseData->arguments[i]->type->kind != ptxVectorType) {
            // Skip arguments that are memory descriptors
            continue;
        }

        baseType = gblState->parseData->arguments[i]->type->cases.Vector.base;
        argVecSize = gblState->parseData->arguments[i]->type->cases.Vector.N;

        switch (i) {
        case 0:
            checkCDArgTypeForBGMMA(gblState, ptxMMASubTypeBGMMA, gblState->parseData->instructionType[i], baseType,
                                 argVecSize, i, name, sourcePos);
            break;
        case 1:
        case 2:
            checkABArgTypeForBGMMA(gblState, ptxMMASubTypeBGMMA, baseType, argVecSize, i, name, sourcePos);
            break;
        case 3:
           checkCDArgTypeForBGMMA(gblState, ptxMMASubTypeBGMMA, gblState->parseData->instructionType[i], baseType,
                                argVecSize, i, name, sourcePos);
            break;
        }
    }
    if (gblState->parseData->nrofArguments > 4) {
        // check group scoreboard argument
        if (gblState->parseData->arguments[4]->kind == ptxIntConstantExpression) {
            stdCHECK_WITH_POS((gblState->parseData->arguments[4]->cases.IntConstant.i == 0),
                              (ptxMsgArgValueUnexpected, sourcePos, 4, name, gblState->parseData->arguments[4]->cases.IntConstant.i, "0"));
        } else {
            stdCHECK_WITH_POS(False, (ptxMsgIntConstantExpected, sourcePos, 0));
        }
    }
}
#endif // Hopper & Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkBGMMA(ptxParsingState gblState, ptxInstructionTemplate template, String name, msgSourcePos_t sourcePos)
{
    uInt tcode = template->code;

    checkVersionTargetForBGMMA(gblState, sourcePos);
    checkShapeForBGMMA(gblState, tcode, name, sourcePos);
    checkInstructionTypesForBGMMA(gblState, tcode, name, sourcePos);
    checkOperationsForBGMMA(gblState, tcode, name, sourcePos);
    checkArgsForBGMMA(gblState, tcode, name, sourcePos);
}
#endif // Hopper & Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkVersionTargetForIGMMA(ptxParsingState gblState, String feature, msgSourcePos_t sourcePos)
{
    int milwersion = gblState->parseData->modifiers.SPARSITY ? 3 : 1;
    // FIXME: Update version/target check
    checkFeatureVersion(gblState, 7, milwersion, feature, sourcePos);
    checkFeatureTarget(gblState, 90,   feature, sourcePos);
}
#endif // Hopper & Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkCDArgTypeForIGMMA(ptxParsingState gblState, ptxMMASubType typeOfMMA, ptxType instrType, ptxType baseType,
                                 int argVecSize, int argIndex, String name,
                                 msgSourcePos_t sourcePos)
{
    int numElements = getNumElemsPerFragmentForMMA(gblState, typeOfMMA, gblState->parseData->modifiers.SHAPE,
                                               gblState->parseData->modifiers.SPARSITY, argIndex);
    stdCHECK_WITH_POS(argVecSize == numElements,
                      (ptxMsgArgumentVectorMismatch, sourcePos, name));
}
#endif // Hopper & Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkABArgTypeForIGMMA(ptxParsingState gblState, ptxMMASubType typeOfMMA, ptxType baseType, int argVecSize,
                                   int argIndex, String name, msgSourcePos_t sourcePos)
{
    int numElements = getNumElemsPerFragmentForMMA(gblState, typeOfMMA, gblState->parseData->modifiers.SHAPE,
                                                   gblState->parseData->modifiers.SPARSITY, argIndex);
    stdCHECK_WITH_POS(argVecSize == numElements,
                      (ptxMsgArgumentVectorMismatch, sourcePos, name));
}
#endif // Hopper & Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkArgsForIGMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    int i, maxNumOfArg;
    
    maxNumOfArg = gblState->parseData->modifiers.SPARSITY ? 6 : 5;
    stdCHECK_WITH_POS((gblState->parseData->nrofArguments == maxNumOfArg ||
                       gblState->parseData->nrofArguments == maxNumOfArg - 1),
                      (ptxMsgNonMatchingInstrArgs, sourcePos, name));

    stdCHECK_WITH_POS((gblState->parseData->arguments[0]->type->kind == ptxVectorType),
                          (ptxMsgVectorArgumentExpected, sourcePos, 0));
    stdCHECK_WITH_POS((gblState->parseData->arguments[3]->type->kind == ptxVectorType),
                          (ptxMsgVectorArgumentExpected, sourcePos, 3));

    for (i = 0; i != 4; ++i) {
        int argVecSize;
        ptxType baseType;
        if (gblState->parseData->arguments[i]->type->kind != ptxVectorType) {
            // Skip arguments that are memory descriptors
            continue;
        }

        baseType = gblState->parseData->arguments[i]->type->cases.Vector.base;
        argVecSize = gblState->parseData->arguments[i]->type->cases.Vector.N;

        switch (i) {
        case 0:
            checkCDArgTypeForIGMMA(gblState, ptxMMASubTypeIGMMA, gblState->parseData->instructionType[i], baseType,
                                 argVecSize, i, name, sourcePos);
            break;
        case 1:
        case 2:
            checkABArgTypeForIGMMA(gblState, ptxMMASubTypeIGMMA, baseType, argVecSize, i, name, sourcePos);
            break;
        case 3:
           checkCDArgTypeForIGMMA(gblState, ptxMMASubTypeIGMMA, gblState->parseData->instructionType[i], baseType,
                                argVecSize, i, name, sourcePos);
            break;
        }
    }
    if (gblState->parseData->nrofArguments == maxNumOfArg) {
        // check group scoreboard argument
        if (gblState->parseData->arguments[gblState->parseData->nrofArguments - 1]->kind == ptxIntConstantExpression) {
            stdCHECK_WITH_POS((gblState->parseData->arguments[gblState->parseData->nrofArguments - 1]->cases.IntConstant.i == 0),
                              (ptxMsgArgValueUnexpected, sourcePos, gblState->parseData->nrofArguments - 1,
                               name, gblState->parseData->arguments[gblState->parseData->nrofArguments - 1]->cases.IntConstant.i, "0"));
        } else {
            stdCHECK_WITH_POS(False, (ptxMsgIntConstantExpected, sourcePos, 0));
        }
    }
}
#endif // Hopper & Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkShapeForIGMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_640864_MOD:
    case ptxSHAPE_641664_MOD:
    case ptxSHAPE_642464_MOD:
    case ptxSHAPE_643264_MOD:
    case ptxSHAPE_644864_MOD:
    case ptxSHAPE_646464_MOD:
    case ptxSHAPE_648064_MOD:
    case ptxSHAPE_649664_MOD:
    case ptxSHAPE_6411264_MOD:
    case ptxSHAPE_6412864_MOD:
    case ptxSHAPE_6414464_MOD:
    case ptxSHAPE_6416064_MOD:
    case ptxSHAPE_6417664_MOD:
    case ptxSHAPE_6419264_MOD:
    case ptxSHAPE_6420864_MOD:
    case ptxSHAPE_6422464_MOD:
    case ptxSHAPE_6424064_MOD:
    case ptxSHAPE_6425664_MOD:
        return;
    case ptxSHAPE_640832_MOD:
    case ptxSHAPE_641632_MOD:
    case ptxSHAPE_642432_MOD:
    case ptxSHAPE_643232_MOD:
    case ptxSHAPE_644832_MOD:
    case ptxSHAPE_646432_MOD:
    case ptxSHAPE_648032_MOD:
    case ptxSHAPE_649632_MOD:
    case ptxSHAPE_6411232_MOD:
    case ptxSHAPE_6412832_MOD:
    case ptxSHAPE_6414432_MOD:
    case ptxSHAPE_6416032_MOD:
    case ptxSHAPE_6417632_MOD:
    case ptxSHAPE_6419232_MOD:
    case ptxSHAPE_6420832_MOD:
    case ptxSHAPE_6422432_MOD:
    case ptxSHAPE_6424032_MOD:
    case ptxSHAPE_6425632_MOD:
        if (!gblState->parseData->modifiers.SPARSITY){
            return;
        }
    default: 
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), name));
        }
        return;
    }
}
#endif // Hopper & Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkInstrTypesForIGMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{

    String feature = getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxIGMMA_STR);
    if (!gblState->parseData->modifiers.SHAPE) {
        return;
    }

    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_640832_MOD:
    case ptxSHAPE_641632_MOD:
    case ptxSHAPE_642432_MOD:
    case ptxSHAPE_643232_MOD:
    case ptxSHAPE_644832_MOD:
    case ptxSHAPE_646432_MOD:
    case ptxSHAPE_648032_MOD:
    case ptxSHAPE_649632_MOD:
    case ptxSHAPE_6411232_MOD:
    case ptxSHAPE_6412832_MOD:
    case ptxSHAPE_6414432_MOD:
    case ptxSHAPE_6416032_MOD:
    case ptxSHAPE_6417632_MOD:
    case ptxSHAPE_6419232_MOD:
    case ptxSHAPE_6420832_MOD:
    case ptxSHAPE_6422432_MOD:
    case ptxSHAPE_6424032_MOD:
    case ptxSHAPE_6425632_MOD:
        stdCHECK_WITH_POS(((gblState->parseData->nrofInstructionTypes == 4) &&
                          (isI8(gblState->parseData->instructionType[1]) && isI8(gblState->parseData->instructionType[2]))),
                          (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        return;
    case ptxSHAPE_640864_MOD:
    case ptxSHAPE_641664_MOD:
    case ptxSHAPE_642464_MOD:
    case ptxSHAPE_643264_MOD:
    case ptxSHAPE_644864_MOD:
    case ptxSHAPE_646464_MOD:
    case ptxSHAPE_648064_MOD:
    case ptxSHAPE_649664_MOD:
    case ptxSHAPE_6411264_MOD:
    case ptxSHAPE_6412864_MOD:
    case ptxSHAPE_6414464_MOD:
    case ptxSHAPE_6416064_MOD:
    case ptxSHAPE_6417664_MOD:
    case ptxSHAPE_6419264_MOD:
    case ptxSHAPE_6420864_MOD:
    case ptxSHAPE_6422464_MOD:
    case ptxSHAPE_6424064_MOD:
    case ptxSHAPE_6425664_MOD:
        stdCHECK_WITH_POS(((gblState->parseData->nrofInstructionTypes == 2 && 
                            isI4Mod(gblState->parseData->modifiers.ATYPE) && isI4Mod(gblState->parseData->modifiers.BTYPE)) ||
                           (gblState->parseData->modifiers.SPARSITY && gblState->parseData->nrofInstructionTypes == 4 &&
                            isI8(gblState->parseData->instructionType[1]) && isI8(gblState->parseData->instructionType[2]))),
                          (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        return;
    default:
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE),
                                      feature));
        }
        return;
    }
}
#endif // Hopper & Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkIGMMA(ptxParsingState gblState, ptxInstructionTemplate template, String name, msgSourcePos_t sourcePos)
{
    uInt tcode = template->code;
    Bool abcdValidTypes;
    String strFeature, strName, feature;

    stdASSERT(gblState->parseData->nrofInstructionTypes == 4 || gblState->parseData->nrofInstructionTypes == 2,
              ("unexpected number of instruction types"));
    feature = getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxIGMMA_STR);
    if (gblState->parseData->modifiers.SPARSITY) {
        strFeature = stdCONCATSTRING(getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSparse_STR), feature);
        strName    = stdCONCATSTRING(getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSparse_STR), name);
    } else {
        strFeature = feature;
        strName    = name;
    }
    checkVersionTargetForIGMMA(gblState, strFeature, sourcePos);
    checkShapeForIGMMA(gblState, tcode, strName, sourcePos);
    if (gblState->parseData->nrofInstructionTypes == 2) {
        // Sub byte IGMMA (.s32.u4.u4.s32 or .s32.s4.s4.s32)
        setABTypesForIMMA(gblState, name, sourcePos);
    }
    checkInstrTypesForIGMMA(gblState, strName, sourcePos);
    // TypeMod must containt 4 valid types.
    abcdValidTypes = (gblState->parseData->typeMod[0] != ptxNOTYPE_MOD && gblState->parseData->typeMod[1] != ptxNOTYPE_MOD &&
                      gblState->parseData->typeMod[2] != ptxNOTYPE_MOD && gblState->parseData->typeMod[3] != ptxNOTYPE_MOD);
    if (!abcdValidTypes) {
        stdCHECK_WITH_POS(False, (ptxMsgIncorrectNumberInstrTypes, sourcePos,
                                  name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        return;
    }
    checkArgsForIGMMA(gblState, tcode, strName, sourcePos);
}
#endif // Hopper & Internal

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static Bool isHGMMAWithMixedPrecision(ptxParsingState gblState, uInt tcode)
{
    stdASSERT(tcode == ptx__mma_warpgroup_Instr,
              ("unexpected instruction"));
    
    if (gblState->parseData->nrofInstructionTypes == 4) {
        return ((isF32(gblState->parseData->instructionType[0]) && isF32(gblState->parseData->instructionType[3])) &&
                (isF16(gblState->parseData->instructionType[1]) && isF16(gblState->parseData->instructionType[2])));
    }
    return False;
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static Bool isHGMMAWithTF32Type(ptxParsingState gblState, uInt tcode)
{
    Bool abcdTypeCheck = False;
    stdASSERT(tcode == ptx__mma_warpgroup_Instr,
              ("unexpected instruction"));
    
    if (gblState->parseData->nrofTypeMod == 4) {
        abcdTypeCheck = gblState->parseData->typeMod[0] == ptxTYPE_f32_MOD  &&
                        gblState->parseData->typeMod[1] == ptxTYPE_TF32_MOD &&
                        gblState->parseData->typeMod[2] == ptxTYPE_TF32_MOD &&
                        gblState->parseData->typeMod[3] == ptxTYPE_f32_MOD;
    }
    return abcdTypeCheck;
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static Bool isHGMMAWithBF16Type(ptxParsingState gblState, uInt tcode)
{
    Bool abcdTypeCheck = False;
    stdASSERT(tcode == ptx__mma_warpgroup_Instr,
              ("unexpected instruction"));
    
    if (gblState->parseData->nrofTypeMod == 4) {
        abcdTypeCheck = gblState->parseData->typeMod[0] == ptxTYPE_f32_MOD  &&
                        gblState->parseData->typeMod[1] == ptxTYPE_BF16_MOD &&
                        gblState->parseData->typeMod[2] == ptxTYPE_BF16_MOD &&
                        gblState->parseData->typeMod[3] == ptxTYPE_f32_MOD;
    }
    return abcdTypeCheck;
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static Bool isNonStdFPHGMMA(ptxParsingState gblState, uInt tcode)
{
    return isHGMMAWithBF16Type(gblState, tcode) || isHGMMAWithTF32Type(gblState, tcode);
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkVersionTargetForSparseHGMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    // FIXME: Update version/target check
    checkFeatureVersion(gblState, 7, 3, name, sourcePos);
    checkFeatureTarget(gblState, 90,   name, sourcePos);
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkInstrTypesForSparseHGMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    Bool abcdTypeCheck, allF16, mixF16F32, hasTF32Mod, hasBF16Mod;
    if (gblState->parseData->nrofTypeMod != 4) {
        stdCHECK_WITH_POS(False, (ptxMsgIncorrectNumberInstrTypes, sourcePos,
                                  name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
    }

    allF16     = areAllFourMatrixTypesF16(gblState->parseData->instructionType, gblState->parseData->nrofInstructionTypes);
    mixF16F32  = isHGMMAWithMixedPrecision(gblState, tcode);
    hasTF32Mod = isHGMMAWithTF32Type(gblState, tcode);
    hasBF16Mod = isHGMMAWithBF16Type(gblState, tcode);

    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_640816_MOD:
    case ptxSHAPE_641616_MOD:
    case ptxSHAPE_642416_MOD:
    case ptxSHAPE_643216_MOD:
    case ptxSHAPE_644016_MOD:
    case ptxSHAPE_644816_MOD:
    case ptxSHAPE_645616_MOD:
    case ptxSHAPE_646416_MOD:
    case ptxSHAPE_647216_MOD:
    case ptxSHAPE_648016_MOD:
    case ptxSHAPE_648816_MOD:
    case ptxSHAPE_649616_MOD:
    case ptxSHAPE_6410416_MOD:
    case ptxSHAPE_6411216_MOD:
    case ptxSHAPE_6412016_MOD:
    case ptxSHAPE_6412816_MOD:
    case ptxSHAPE_6413616_MOD:
    case ptxSHAPE_6414416_MOD:
    case ptxSHAPE_6415216_MOD:
    case ptxSHAPE_6416016_MOD:
    case ptxSHAPE_6416816_MOD:
    case ptxSHAPE_6417616_MOD:
    case ptxSHAPE_6418416_MOD:
    case ptxSHAPE_6419216_MOD:
    case ptxSHAPE_6420016_MOD:
    case ptxSHAPE_6420816_MOD:
    case ptxSHAPE_6421616_MOD:
    case ptxSHAPE_6422416_MOD:
    case ptxSHAPE_6423216_MOD:
    case ptxSHAPE_6424016_MOD:
    case ptxSHAPE_6424816_MOD:
    case ptxSHAPE_6425616_MOD:
        abcdTypeCheck = (gblState->parseData->nrofInstructionTypes == 2 && hasTF32Mod);
        break;
    case ptxSHAPE_640832_MOD:
    case ptxSHAPE_641632_MOD:
    case ptxSHAPE_642432_MOD:
    case ptxSHAPE_643232_MOD:
    case ptxSHAPE_644032_MOD:
    case ptxSHAPE_644832_MOD:
    case ptxSHAPE_645632_MOD:
    case ptxSHAPE_646432_MOD:
    case ptxSHAPE_647232_MOD:
    case ptxSHAPE_648032_MOD:
    case ptxSHAPE_648832_MOD:
    case ptxSHAPE_649632_MOD:
    case ptxSHAPE_6410432_MOD:
    case ptxSHAPE_6411232_MOD:
    case ptxSHAPE_6412032_MOD:
    case ptxSHAPE_6412832_MOD:
    case ptxSHAPE_6413632_MOD:
    case ptxSHAPE_6414432_MOD:
    case ptxSHAPE_6415232_MOD:
    case ptxSHAPE_6416032_MOD:
    case ptxSHAPE_6416832_MOD:
    case ptxSHAPE_6417632_MOD:
    case ptxSHAPE_6418432_MOD:
    case ptxSHAPE_6419232_MOD:
    case ptxSHAPE_6420032_MOD:
    case ptxSHAPE_6420832_MOD:
    case ptxSHAPE_6421632_MOD:
    case ptxSHAPE_6422432_MOD:
    case ptxSHAPE_6423232_MOD:
    case ptxSHAPE_6424032_MOD:
    case ptxSHAPE_6424832_MOD:
    case ptxSHAPE_6425632_MOD:
        abcdTypeCheck = (gblState->parseData->nrofInstructionTypes == 4 && (allF16 || mixF16F32)) ||
            (gblState->parseData->nrofInstructionTypes == 2 && hasBF16Mod);
        break;
    default:
        return;
    }
    stdCHECK_WITH_POS(abcdTypeCheck,
                      (ptxMsgIllegalShapeType, sourcePos,
                       name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
    gblState->parseData->modifiers.ATYPE = gblState->parseData->typeMod[1];
    gblState->parseData->modifiers.BTYPE = gblState->parseData->typeMod[2];
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkShapeForSparseHGMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_640816_MOD:
    case ptxSHAPE_641616_MOD:
    case ptxSHAPE_642416_MOD:
    case ptxSHAPE_643216_MOD:
    case ptxSHAPE_644016_MOD:
    case ptxSHAPE_644816_MOD:
    case ptxSHAPE_645616_MOD:
    case ptxSHAPE_646416_MOD:
    case ptxSHAPE_647216_MOD:
    case ptxSHAPE_648016_MOD:
    case ptxSHAPE_648816_MOD:
    case ptxSHAPE_649616_MOD:
    case ptxSHAPE_6410416_MOD:
    case ptxSHAPE_6411216_MOD:
    case ptxSHAPE_6412016_MOD:
    case ptxSHAPE_6412816_MOD:
    case ptxSHAPE_6413616_MOD:
    case ptxSHAPE_6414416_MOD:
    case ptxSHAPE_6415216_MOD:
    case ptxSHAPE_6416016_MOD:
    case ptxSHAPE_6416816_MOD:
    case ptxSHAPE_6417616_MOD:
    case ptxSHAPE_6418416_MOD:
    case ptxSHAPE_6419216_MOD:
    case ptxSHAPE_6420016_MOD:
    case ptxSHAPE_6420816_MOD:
    case ptxSHAPE_6421616_MOD:
    case ptxSHAPE_6422416_MOD:
    case ptxSHAPE_6423216_MOD:
    case ptxSHAPE_6424016_MOD:
    case ptxSHAPE_6424816_MOD:
    case ptxSHAPE_6425616_MOD:
        return;
    case ptxSHAPE_640832_MOD:
    case ptxSHAPE_641632_MOD:
    case ptxSHAPE_642432_MOD:
    case ptxSHAPE_643232_MOD:
    case ptxSHAPE_644032_MOD:
    case ptxSHAPE_644832_MOD:
    case ptxSHAPE_645632_MOD:
    case ptxSHAPE_646432_MOD:
    case ptxSHAPE_647232_MOD:
    case ptxSHAPE_648032_MOD:
    case ptxSHAPE_648832_MOD:
    case ptxSHAPE_649632_MOD:
    case ptxSHAPE_6410432_MOD:
    case ptxSHAPE_6411232_MOD:
    case ptxSHAPE_6412032_MOD:
    case ptxSHAPE_6412832_MOD:
    case ptxSHAPE_6413632_MOD:
    case ptxSHAPE_6414432_MOD:
    case ptxSHAPE_6415232_MOD:
    case ptxSHAPE_6416032_MOD:
    case ptxSHAPE_6416832_MOD:
    case ptxSHAPE_6417632_MOD:
    case ptxSHAPE_6418432_MOD:
    case ptxSHAPE_6419232_MOD:
    case ptxSHAPE_6420032_MOD:
    case ptxSHAPE_6420832_MOD:
    case ptxSHAPE_6421632_MOD:
    case ptxSHAPE_6422432_MOD:
    case ptxSHAPE_6423232_MOD:
    case ptxSHAPE_6424032_MOD:
    case ptxSHAPE_6424832_MOD:
    case ptxSHAPE_6425632_MOD:
        return;
    default:
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), name));
        }
        return;
    }
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkVersionTargetForHGMMA(ptxParsingState gblState, String feature, msgSourcePos_t sourcePos)
{
    // FIXME: Update version/target check
    checkFeatureVersion(gblState, 7, 0, feature, sourcePos);
    checkFeatureTarget(gblState, 90,   feature, sourcePos);
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkInstrTypesForHGMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    Bool abcdTypeCheck, allF16, mixF16F32;
    Bool hasTF32Mod, hasBF16Mod;
    String feature;
    if (gblState->parseData->nrofTypeMod != 4) {
        stdCHECK_WITH_POS(False, (ptxMsgIncorrectNumberInstrTypes, sourcePos,
                                  name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
    }
    
    allF16       = areAllFourMatrixTypesF16(gblState->parseData->instructionType, gblState->parseData->nrofInstructionTypes);
    mixF16F32    = isHGMMAWithMixedPrecision(gblState, tcode);
    hasTF32Mod   = isHGMMAWithTF32Type(gblState, tcode);
    hasBF16Mod   = isHGMMAWithBF16Type(gblState, tcode);

    feature      = stdCONCATSTRING("BF16/TF32 as input matrix type for ", name);
    if (hasTF32Mod || hasBF16Mod) {
        checkFeatureVersion(gblState, 7, 3, feature, sourcePos);
        checkFeatureTarget(gblState, 90,   feature, sourcePos);
    }
    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_640816_MOD:
    case ptxSHAPE_641616_MOD:
    case ptxSHAPE_642416_MOD:
    case ptxSHAPE_643216_MOD:
    case ptxSHAPE_644016_MOD:
    case ptxSHAPE_644816_MOD:
    case ptxSHAPE_645616_MOD:
    case ptxSHAPE_646416_MOD:
    case ptxSHAPE_647216_MOD:
    case ptxSHAPE_648016_MOD:
    case ptxSHAPE_648816_MOD:
    case ptxSHAPE_649616_MOD:
    case ptxSHAPE_6410416_MOD:
    case ptxSHAPE_6411216_MOD:
    case ptxSHAPE_6412016_MOD:
    case ptxSHAPE_6412816_MOD:
    case ptxSHAPE_6413616_MOD:
    case ptxSHAPE_6414416_MOD:
    case ptxSHAPE_6415216_MOD:
    case ptxSHAPE_6416016_MOD:
    case ptxSHAPE_6416816_MOD:
    case ptxSHAPE_6417616_MOD:
    case ptxSHAPE_6418416_MOD:
    case ptxSHAPE_6419216_MOD:
    case ptxSHAPE_6420016_MOD:
    case ptxSHAPE_6420816_MOD:
    case ptxSHAPE_6421616_MOD:
    case ptxSHAPE_6422416_MOD:
    case ptxSHAPE_6423216_MOD:
    case ptxSHAPE_6424016_MOD:
    case ptxSHAPE_6424816_MOD:
    case ptxSHAPE_6425616_MOD:
        abcdTypeCheck = (gblState->parseData->nrofInstructionTypes == 4 && (allF16 || mixF16F32));
        abcdTypeCheck |= (gblState->parseData->nrofInstructionTypes == 2 && hasBF16Mod);
        break;
    case ptxSHAPE_640808_MOD:
    case ptxSHAPE_641608_MOD:
    case ptxSHAPE_642408_MOD:
    case ptxSHAPE_643208_MOD:
    case ptxSHAPE_644008_MOD:
    case ptxSHAPE_644808_MOD:
    case ptxSHAPE_645608_MOD:
    case ptxSHAPE_646408_MOD:
    case ptxSHAPE_647208_MOD:
    case ptxSHAPE_648008_MOD:
    case ptxSHAPE_648808_MOD:
    case ptxSHAPE_649608_MOD:
    case ptxSHAPE_6410408_MOD:
    case ptxSHAPE_6411208_MOD:
    case ptxSHAPE_6412008_MOD:
    case ptxSHAPE_6412808_MOD:
    case ptxSHAPE_6413608_MOD:
    case ptxSHAPE_6414408_MOD:
    case ptxSHAPE_6415208_MOD:
    case ptxSHAPE_6416008_MOD:
    case ptxSHAPE_6416808_MOD:
    case ptxSHAPE_6417608_MOD:
    case ptxSHAPE_6418408_MOD:
    case ptxSHAPE_6419208_MOD:
    case ptxSHAPE_6420008_MOD:
    case ptxSHAPE_6420808_MOD:
    case ptxSHAPE_6421608_MOD:
    case ptxSHAPE_6422408_MOD:
    case ptxSHAPE_6423208_MOD:
    case ptxSHAPE_6424008_MOD:
    case ptxSHAPE_6424808_MOD:
    case ptxSHAPE_6425608_MOD:
        abcdTypeCheck = (gblState->parseData->nrofInstructionTypes == 2 && hasTF32Mod);
        break;
    default:
        return;
    }
    stdCHECK_WITH_POS(abcdTypeCheck,
                      (ptxMsgIllegalShapeType, sourcePos,
                       name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
    gblState->parseData->modifiers.ATYPE = gblState->parseData->typeMod[1];
    gblState->parseData->modifiers.BTYPE = gblState->parseData->typeMod[2];
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkArgsForFPGMMA(ptxParsingState gblState, uInt tcode,
                               String name, msgSourcePos_t sourcePos,
                               int cTypeIndex, ptxMMASubType typeOfGMMA)
{
    int i, maxNumOfArg;
    maxNumOfArg = gblState->parseData->modifiers.SPARSITY ? 7 : 5;

    stdCHECK_WITH_POS((gblState->parseData->nrofArguments == maxNumOfArg ||
                       gblState->parseData->nrofArguments == maxNumOfArg - 1),
                      (ptxMsgNonMatchingInstrArgs, sourcePos, name));
    stdCHECK_WITH_POS((gblState->parseData->arguments[0]->type->kind == ptxVectorType),
                          (ptxMsgVectorArgumentExpected, sourcePos, 0));
    stdCHECK_WITH_POS((gblState->parseData->arguments[3]->type->kind == ptxVectorType),
                          (ptxMsgVectorArgumentExpected, sourcePos, 3));
    
    for (i = 0; i != 4; ++i) {
        int argVecSize;
        ptxType baseType;
        if (gblState->parseData->arguments[i]->type->kind != ptxVectorType) {
            // Skip arguments that are memory descriptors
            continue;
        }

        baseType = gblState->parseData->arguments[i]->type->cases.Vector.base;
        argVecSize = gblState->parseData->arguments[i]->type->cases.Vector.N;

        switch (i) {
        case 0:
            checkArgTypeForFpMMA(gblState, typeOfGMMA, gblState->parseData->instructionType[i], baseType,
                                 argVecSize, i, name, sourcePos);
            break;
        case 1:
        case 2:
            checkABArgTypeForFpMMA(gblState, typeOfGMMA, baseType, argVecSize, i, name, sourcePos);
            break;
        case 3:
            checkArgTypeForFpMMA(gblState, typeOfGMMA, gblState->parseData->instructionType[cTypeIndex], baseType,
                                argVecSize, i, name, sourcePos);
            break;
        }
    }
    
    if (gblState->parseData->nrofArguments == maxNumOfArg) {
        // check group scoreboard argument
        if (gblState->parseData->arguments[gblState->parseData->nrofArguments - 1]->kind == ptxIntConstantExpression) {
            stdCHECK_WITH_POS((gblState->parseData->arguments[gblState->parseData->nrofArguments - 1]->cases.IntConstant.i == 0),
                              (ptxMsgArgValueUnexpected, sourcePos, gblState->parseData->nrofArguments - 1,
                               name, gblState->parseData->arguments[gblState->parseData->nrofArguments - 1]->cases.IntConstant.i, "0"));
        } else {
            stdCHECK_WITH_POS(False, (ptxMsgIntConstantExpected, sourcePos, 0));
        }
    }
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkArgs6ForSparseFPGMMA(ptxParsingState gblState, uInt tcode,
                               String name, msgSourcePos_t sourcePos)
{
    int immValue;
    if (gblState->parseData->nrofArguments < 6) {
        return;
    }
    stdASSERT(gblState->parseData->arguments[5]->kind == ptxIntConstantExpression, ("Immediate expected"));
    immValue = gblState->parseData->arguments[5]->cases.IntConstant.i;
    stdCHECK_WITH_POS((immValue == 0 || immValue == 1),
                      (ptxMsgArgValueUnexpected, sourcePos, 5,
                       name, immValue, "0 or 1"));
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkArgsForHGMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    int cTypeIndex;
    
    cTypeIndex  = isNonStdFPHGMMA(gblState, tcode) ? 1 : gblState->parseData->nrofInstructionTypes - 1;
    checkArgsForFPGMMA(gblState, tcode, name, sourcePos, cTypeIndex, ptxMMASubTypeHGMMA);
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkShapeForHGMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_640816_MOD:
    case ptxSHAPE_641616_MOD:
    case ptxSHAPE_642416_MOD:
    case ptxSHAPE_643216_MOD:
    case ptxSHAPE_644016_MOD:
    case ptxSHAPE_644816_MOD:
    case ptxSHAPE_645616_MOD:
    case ptxSHAPE_646416_MOD:
    case ptxSHAPE_647216_MOD:
    case ptxSHAPE_648016_MOD:
    case ptxSHAPE_648816_MOD:
    case ptxSHAPE_649616_MOD:
    case ptxSHAPE_6410416_MOD:
    case ptxSHAPE_6411216_MOD:
    case ptxSHAPE_6412016_MOD:
    case ptxSHAPE_6412816_MOD:
    case ptxSHAPE_6413616_MOD:
    case ptxSHAPE_6414416_MOD:
    case ptxSHAPE_6415216_MOD:
    case ptxSHAPE_6416016_MOD:
    case ptxSHAPE_6416816_MOD:
    case ptxSHAPE_6417616_MOD:
    case ptxSHAPE_6418416_MOD:
    case ptxSHAPE_6419216_MOD:
    case ptxSHAPE_6420016_MOD:
    case ptxSHAPE_6420816_MOD:
    case ptxSHAPE_6421616_MOD:
    case ptxSHAPE_6422416_MOD:
    case ptxSHAPE_6423216_MOD:
    case ptxSHAPE_6424016_MOD:
    case ptxSHAPE_6424816_MOD:
    case ptxSHAPE_6425616_MOD:
        return;
    case ptxSHAPE_640808_MOD:
    case ptxSHAPE_641608_MOD:
    case ptxSHAPE_642408_MOD:
    case ptxSHAPE_643208_MOD:
    case ptxSHAPE_644008_MOD:
    case ptxSHAPE_644808_MOD:
    case ptxSHAPE_645608_MOD:
    case ptxSHAPE_646408_MOD:
    case ptxSHAPE_647208_MOD:
    case ptxSHAPE_648008_MOD:
    case ptxSHAPE_648808_MOD:
    case ptxSHAPE_649608_MOD:
    case ptxSHAPE_6410408_MOD:
    case ptxSHAPE_6411208_MOD:
    case ptxSHAPE_6412008_MOD:
    case ptxSHAPE_6412808_MOD:
    case ptxSHAPE_6413608_MOD:
    case ptxSHAPE_6414408_MOD:
    case ptxSHAPE_6415208_MOD:
    case ptxSHAPE_6416008_MOD:
    case ptxSHAPE_6416808_MOD:
    case ptxSHAPE_6417608_MOD:
    case ptxSHAPE_6418408_MOD:
    case ptxSHAPE_6419208_MOD:
    case ptxSHAPE_6420008_MOD:
    case ptxSHAPE_6420808_MOD:
    case ptxSHAPE_6421608_MOD:
    case ptxSHAPE_6422408_MOD:
    case ptxSHAPE_6423208_MOD:
    case ptxSHAPE_6424008_MOD:
    case ptxSHAPE_6424808_MOD:
    case ptxSHAPE_6425608_MOD:
        checkFeatureVersion(gblState, 7, 3, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        checkFeatureTarget(gblState, 90,   getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        return;
    default: 
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), name));
        }
        return;
    }
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkArgsForSparseHGMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    checkArgsForHGMMA(gblState, tcode, name, sourcePos);
    checkArgs6ForSparseFPGMMA(gblState, tcode, name, sourcePos);
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkSparseHGMMA(ptxParsingState gblState, uInt tcode, String name, String feature, msgSourcePos_t sourcePos)
{
    checkVersionTargetForSparseHGMMA(gblState, feature, sourcePos);
    checkShapeForSparseHGMMA(gblState, name, sourcePos);
    checkInstrTypesForSparseHGMMA(gblState, tcode, name, sourcePos);
    checkArgsForSparseHGMMA(gblState, tcode, name, sourcePos);
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkHGMMA(ptxParsingState gblState, ptxInstructionTemplate template, String name, msgSourcePos_t sourcePos)
{
    uInt tcode = template->code;
    String feature = getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxFPGMMA_STR);
    
    checkVersionTargetForHGMMA(gblState, feature, sourcePos);
    stdASSERT(gblState->parseData->nrofInstructionTypes == 4 || gblState->parseData->nrofInstructionTypes == 2,
              ("unexpected number of instruction types"));
    if (gblState->parseData->modifiers.SPARSITY) {
        String sparseFeature = stdCONCATSTRING(getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSparse_STR), feature);
        String sparseName = stdCONCATSTRING(getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSparse_STR), name);
        checkSparseHGMMA(gblState, tcode, sparseName, sparseFeature, sourcePos);
        stdFREE(sparseFeature);
        stdFREE(sparseName);
        return;
    }
    checkShapeForHGMMA(gblState, tcode, name, sourcePos);
    checkInstrTypesForHGMMA(gblState, tcode, name, sourcePos);
    checkArgsForHGMMA(gblState, tcode, name, sourcePos);
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static Bool isQGMMAWithF16CDType(ptxParsingState gblState, uInt tcode)
{
    stdASSERT(tcode == ptx__mma_warpgroup_Instr,
              ("unexpected instruction"));

    if (gblState->parseData->nrofInstructionTypes == 4) {
        return ((isF16(gblState->parseData->instructionType[0]) && isF16(gblState->parseData->instructionType[3])) &&
                (isF8(gblState->parseData->instructionType[1]) && isF8(gblState->parseData->instructionType[2])));
    }
    return False;
}

static Bool isQGMMAWithF32CDType(ptxParsingState gblState, uInt tcode)
{
    stdASSERT(tcode == ptx__mma_warpgroup_Instr,
              ("unexpected instruction"));

    if (gblState->parseData->nrofInstructionTypes == 4) {
        return ((isF32(gblState->parseData->instructionType[0]) && isF32(gblState->parseData->instructionType[3])) &&
                (isF8(gblState->parseData->instructionType[1]) && isF8(gblState->parseData->instructionType[2])));
    }
    return False;
}

static void checkVersionTargetForQGMMA(ptxParsingState gblState, String feature, msgSourcePos_t sourcePos)
{
    // FIXME: Update version/target check
    checkFeatureVersion(gblState, 7, 5, feature, sourcePos);
    checkFeatureTarget(gblState, 90,   feature, sourcePos);
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkInstrTypesForQGMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    Bool abcdTypeCheck, cdTypeF16, cdTypeF32;
    if (gblState->parseData->nrofTypeMod != 4) {
        stdCHECK_WITH_POS(False, (ptxMsgIncorrectNumberInstrTypes, sourcePos,
                                  name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
    }

    cdTypeF16 = isQGMMAWithF16CDType(gblState, tcode);
    cdTypeF32 = isQGMMAWithF32CDType(gblState, tcode);

    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_640832_MOD:
    case ptxSHAPE_641632_MOD:
    case ptxSHAPE_642432_MOD:
    case ptxSHAPE_643232_MOD:
    case ptxSHAPE_644032_MOD:
    case ptxSHAPE_644832_MOD:
    case ptxSHAPE_645632_MOD:
    case ptxSHAPE_646432_MOD:
    case ptxSHAPE_647232_MOD:
    case ptxSHAPE_648032_MOD:
    case ptxSHAPE_648832_MOD:
    case ptxSHAPE_649632_MOD:
    case ptxSHAPE_6410432_MOD:
    case ptxSHAPE_6411232_MOD:
    case ptxSHAPE_6412032_MOD:
    case ptxSHAPE_6412832_MOD:
    case ptxSHAPE_6413632_MOD:
    case ptxSHAPE_6414432_MOD:
    case ptxSHAPE_6415232_MOD:
    case ptxSHAPE_6416032_MOD:
    case ptxSHAPE_6416832_MOD:
    case ptxSHAPE_6417632_MOD:
    case ptxSHAPE_6418432_MOD:
    case ptxSHAPE_6419232_MOD:
    case ptxSHAPE_6420032_MOD:
    case ptxSHAPE_6420832_MOD:
    case ptxSHAPE_6421632_MOD:
    case ptxSHAPE_6422432_MOD:
    case ptxSHAPE_6423232_MOD:
    case ptxSHAPE_6424032_MOD:
    case ptxSHAPE_6424832_MOD:
    case ptxSHAPE_6425632_MOD:
        abcdTypeCheck = (gblState->parseData->nrofInstructionTypes == 4 && (cdTypeF16 || cdTypeF32));
        break;
    default:
        return;
    }
    stdCHECK_WITH_POS(abcdTypeCheck,
                      (ptxMsgIllegalShapeType, sourcePos,
                       name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkShapeForQGMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_640832_MOD:
    case ptxSHAPE_641632_MOD:
    case ptxSHAPE_642432_MOD:
    case ptxSHAPE_643232_MOD:
    case ptxSHAPE_644032_MOD:
    case ptxSHAPE_644832_MOD:
    case ptxSHAPE_645632_MOD:
    case ptxSHAPE_646432_MOD:
    case ptxSHAPE_647232_MOD:
    case ptxSHAPE_648032_MOD:
    case ptxSHAPE_648832_MOD:
    case ptxSHAPE_649632_MOD:
    case ptxSHAPE_6410432_MOD:
    case ptxSHAPE_6411232_MOD:
    case ptxSHAPE_6412032_MOD:
    case ptxSHAPE_6412832_MOD:
    case ptxSHAPE_6413632_MOD:
    case ptxSHAPE_6414432_MOD:
    case ptxSHAPE_6415232_MOD:
    case ptxSHAPE_6416032_MOD:
    case ptxSHAPE_6416832_MOD:
    case ptxSHAPE_6417632_MOD:
    case ptxSHAPE_6418432_MOD:
    case ptxSHAPE_6419232_MOD:
    case ptxSHAPE_6420032_MOD:
    case ptxSHAPE_6420832_MOD:
    case ptxSHAPE_6421632_MOD:
    case ptxSHAPE_6422432_MOD:
    case ptxSHAPE_6423232_MOD:
    case ptxSHAPE_6424032_MOD:
    case ptxSHAPE_6424832_MOD:
    case ptxSHAPE_6425632_MOD:
        return;
    default:
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), name));
        }
        return;
    }
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkInstrTypesForSparseQGMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    Bool abcdTypeCheck, cdTypeF16, cdTypeF32;
    if (gblState->parseData->nrofTypeMod != 4) {
        stdCHECK_WITH_POS(False, (ptxMsgIncorrectNumberInstrTypes, sourcePos,
                                  name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
    }

    cdTypeF16 = isQGMMAWithF16CDType(gblState, tcode);
    cdTypeF32 = isQGMMAWithF32CDType(gblState, tcode);

    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_640864_MOD:
    case ptxSHAPE_641664_MOD:
    case ptxSHAPE_642464_MOD:
    case ptxSHAPE_643264_MOD:
    case ptxSHAPE_644064_MOD:
    case ptxSHAPE_644864_MOD:
    case ptxSHAPE_645664_MOD:
    case ptxSHAPE_646464_MOD:
    case ptxSHAPE_647264_MOD:
    case ptxSHAPE_648064_MOD:
    case ptxSHAPE_648864_MOD:
    case ptxSHAPE_649664_MOD:
    case ptxSHAPE_6410464_MOD:
    case ptxSHAPE_6411264_MOD:
    case ptxSHAPE_6412064_MOD:
    case ptxSHAPE_6412864_MOD:
    case ptxSHAPE_6413664_MOD:
    case ptxSHAPE_6414464_MOD:
    case ptxSHAPE_6415264_MOD:
    case ptxSHAPE_6416064_MOD:
    case ptxSHAPE_6416864_MOD:
    case ptxSHAPE_6417664_MOD:
    case ptxSHAPE_6418464_MOD:
    case ptxSHAPE_6419264_MOD:
    case ptxSHAPE_6420064_MOD:
    case ptxSHAPE_6420864_MOD:
    case ptxSHAPE_6421664_MOD:
    case ptxSHAPE_6422464_MOD:
    case ptxSHAPE_6423264_MOD:
    case ptxSHAPE_6424064_MOD:
    case ptxSHAPE_6424864_MOD:
    case ptxSHAPE_6425664_MOD:
        abcdTypeCheck = (gblState->parseData->nrofInstructionTypes == 4 && (cdTypeF16 || cdTypeF32));
        break;
    default:
        return;
    }
    stdCHECK_WITH_POS(abcdTypeCheck,
                      (ptxMsgIllegalShapeType, sourcePos,
                       name, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkShapeForSparseQGMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    switch (gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_640864_MOD:
    case ptxSHAPE_641664_MOD:
    case ptxSHAPE_642464_MOD:
    case ptxSHAPE_643264_MOD:
    case ptxSHAPE_644064_MOD:
    case ptxSHAPE_644864_MOD:
    case ptxSHAPE_645664_MOD:
    case ptxSHAPE_646464_MOD:
    case ptxSHAPE_647264_MOD:
    case ptxSHAPE_648064_MOD:
    case ptxSHAPE_648864_MOD:
    case ptxSHAPE_649664_MOD:
    case ptxSHAPE_6410464_MOD:
    case ptxSHAPE_6411264_MOD:
    case ptxSHAPE_6412064_MOD:
    case ptxSHAPE_6412864_MOD:
    case ptxSHAPE_6413664_MOD:
    case ptxSHAPE_6414464_MOD:
    case ptxSHAPE_6415264_MOD:
    case ptxSHAPE_6416064_MOD:
    case ptxSHAPE_6416864_MOD:
    case ptxSHAPE_6417664_MOD:
    case ptxSHAPE_6418464_MOD:
    case ptxSHAPE_6419264_MOD:
    case ptxSHAPE_6420064_MOD:
    case ptxSHAPE_6420864_MOD:
    case ptxSHAPE_6421664_MOD:
    case ptxSHAPE_6422464_MOD:
    case ptxSHAPE_6423264_MOD:
    case ptxSHAPE_6424064_MOD:
    case ptxSHAPE_6424864_MOD:
    case ptxSHAPE_6425664_MOD:
        return;
    default:
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), name));
        }
        return;
    }
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkArgsForSparseQGMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    uInt64 immValue;
    checkArgsForFPGMMA(gblState, tcode, name, sourcePos, 3, ptxMMASubTypeQGMMA);
    checkArgs6ForSparseFPGMMA(gblState, tcode, name, sourcePos);
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkSparseQGMMA(ptxParsingState gblState, uInt tcode, String name, String feature, msgSourcePos_t sourcePos)
{
    checkVersionTargetForQGMMA(gblState, feature, sourcePos);
    checkShapeForSparseQGMMA(gblState, name, sourcePos);
    checkInstrTypesForSparseQGMMA(gblState, tcode, name, sourcePos);
    checkArgsForSparseQGMMA(gblState, tcode, name, sourcePos);
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkQGMMA(ptxParsingState gblState, ptxInstructionTemplate template, String name, msgSourcePos_t sourcePos)
{
    uInt tcode = template->code;
    String feature = getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxQGMMA_STR);

    stdASSERT(gblState->parseData->nrofInstructionTypes == 4,
              ("unexpected number of instruction types"));
    if (gblState->parseData->modifiers.SPARSITY) {
        String sparseFeature = stdCONCATSTRING(getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSparse_STR), feature);
        String sparseName = stdCONCATSTRING(getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSparse_STR), name);
        checkSparseQGMMA(gblState, tcode, sparseName, sparseFeature, sourcePos);
        stdFREE(sparseFeature);
        stdFREE(sparseName);
        return;
    }
    checkVersionTargetForQGMMA(gblState, feature, sourcePos);
    checkShapeForQGMMA(gblState, tcode, name, sourcePos);
    checkInstrTypesForQGMMA(gblState, tcode, name, sourcePos);
    checkArgsForFPGMMA(gblState, tcode, name, sourcePos, 3, ptxMMASubTypeQGMMA);
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
// Umbrella function which differentiates between gmma variants and calls the respective check function.
static void checkGMMA(ptxParsingState gblState, ptxInstructionTemplate template, String name, msgSourcePos_t sourcePos)
{
    uInt tcode = template->code;
    if (isHGMMA(tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
        checkHGMMA(gblState, template, name, sourcePos);
    }
    if (isQGMMA(tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
        checkQGMMA(gblState, template, name, sourcePos);
    }
    if (isIGMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType, gblState->parseData->modifiers, True)) {
        checkIGMMA(gblState, template, name, sourcePos);
    }
    if (isBGMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType, gblState->parseData->modifiers, True)) {
        checkBGMMA(gblState, template, name, sourcePos);
    }
}
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkWarpgroup(ptxParsingState gblState, ptxInstructionTemplate template, String name, msgSourcePos_t sourcePos)
{
    uInt tcode      = template->code;
    uInt milwersion = (tcode == ptx__warpgroup_commit_batch_Instr) ? 3 : 0;
    String feature  = getERRORMSGSTRAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxWARPGROUP_STR);
    // FIXME: Update version/target check
    checkFeatureVersion(gblState, 7, milwersion, feature, sourcePos);
    checkFeatureTarget(gblState, 90,   feature, sourcePos);

    if (tcode == ptx__warpgroup_wait_Instr && gblState->parseData->nrofArguments > 0) {
        // check the argument for pending count of previous warpgroup operations
        if (gblState->parseData->arguments[0]->kind == ptxIntConstantExpression) {
            int pendingCnt = gblState->parseData->arguments[0]->cases.IntConstant.i;
            stdCHECK_WITH_POS(pendingCnt >= 0 && pendingCnt <= 7,
                              (ptxMsgArgValueOutOfRange, sourcePos, 0, name, pendingCnt, 0, 7));
        } else {
            stdCHECK_WITH_POS(False, (ptxMsgIntConstantExpected, sourcePos, 0));
        }
    }

}
#endif // HOPPER && INTERNAL

// WMMA checks and utility functions
static void reportWMMALimitations(ptxParsingState gblState, uInt tcode, String name,
                                  msgSourcePos_t sourcePos)
{
    // FIXME: Remove this when .SAT is no longer available on MMA instructions
    if (tcode == ptx_wmma_mma_Instr) {
        stdCHECK_WITH_POS(!gblState->parseData->modifiers.SAT,
                          (ptxMsgIllegalModifier, sourcePos,
                           get_strSAT(gblState->parseData), name));
    }
}

static void checkFPWMMASatfinite(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    if (ptxIsExpandedInternally(gblState->lwrInstrSrc)) return;

    if (!(gblState->parseData->modifiers.SATF)) return;

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65) 
    if (ptxVersionAtLeast(6, 5, gblState)) {
            stdCHECK_WITH_POS(False, (ptxMsgModifierUnsupportedError, sourcePos,
                                      "'wmma.mma' with floating point type", get_strSATF(gblState->parseData), "6.5" ));
            return;
    }
#endif
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_64)
    // Issue deprecation warning for satfinite starting PTX 6.4.
    if (ptxVersionAtLeast(6, 4, gblState)) {
        stdCHECK_WITH_POS(False, (ptxMsgModDeprecated, sourcePos, get_strSATF(gblState->parseData),
                                  "'wmma.mma' with floating point type", "6.4"));
    }    
#endif

    // Issue warning about unexpected results of satfinite.
    stdCHECK_WITH_POS(False, (ptxMsgModResultUnexp, sourcePos, get_strSATF(gblState->parseData),
                              "'wmma.mma' with floating point type", "sm_70"));

    // Ignore satfinite for Ampere+
#if LWCFG(GLOBAL_ARCH_AMPERE)
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    /*
     * SATF not supported on wmma.mma.bf16/tf32. But for consistent template
     * matching, we allow SATF to be passed from template and here we print the
     * error message instead.
     */
    if (isNonStandardFPWMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
        stdCHECK_WITH_POS(!gblState->parseData->modifiers.SATF, (ptxMsgIllegalModifier, sourcePos,
                                            get_strSATF(gblState->parseData), name));
    }
#endif // ISA_70
    if (checkTargetArch(gblState, 80)) {
        gblState->parseData->modifiers.SATF = ptxNOSATF_MOD;
    }
#endif // Ampere

}

static void checkAlignedforWMMA(ptxParsingState gblState, uInt tcode, String name,
                                msgSourcePos_t sourcePos)
{
   if (gblState->parseData->modifiers.ALIGN == ptxALIGNED_MOD) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
        checkFeatureVersion(gblState, 6, 3, ".aligned modifier for wmma", sourcePos);
#else
        stdCHECK_WITH_POS(False, (ptxMsgIllegalModifier, sourcePos,
                                  get_strALIGN(gblState->parseData), name));
#endif
   } else {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
       stdCHECK_WITH_POS(!ptxVersionAtLeast(6, 3, gblState),
                         (ptxMsgModifierRequired, sourcePos, getALIGNAsString(ptxALIGNED_MOD), name));
#endif
   }
}

static void checkVersionTargetForWMMA(ptxParsingState gblState, uInt tcode, String name,
                                      msgSourcePos_t sourcePos)
{
    if (isFloatingPointWMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
        char feature[] = "WMMA with floating point types";
        checkFeatureVersion(gblState, 6, 0, feature, sourcePos);
        checkFeatureTarget(gblState, 70,   feature, sourcePos);
#if  LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
        if (isNonStandardFPWMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
            char feature[] = "WMMA with .bf16/.tf32 FP types";
            checkFeatureVersion(gblState, 7, 0, feature, sourcePos);
            checkFeatureTarget(gblState, 80,   feature, sourcePos);
        }
#endif
#if (LWCFG(GLOBAL_CHIP_T194) || LWCFG(GLOBAL_GPU_IMPL_GV11B) || LWCFG(GLOBAL_ARCH_TURING)) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    } else if (isIntegerWMMA(tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
        char feature[] = "WMMA with integer types";
        checkFeatureVersion(gblState, 6, 3, feature, sourcePos);
        checkFeatureTarget(gblState, 72,   feature, sourcePos);
#endif
#if  LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    } else if (isSubByteWMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
        char feature[] = "WMMA with sub-byte integer types";
        checkFeatureVersion(gblState, 6, 3, feature, sourcePos);
        checkFeatureTarget(gblState, minTuringArch,   feature, sourcePos);
    } else if (isBitTypeWMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
        char feature[] = "WMMA with bit types";
        checkFeatureVersion(gblState, 6, 3, feature, sourcePos);
        checkFeatureTarget(gblState, minTuringArch,   feature, sourcePos);
#endif
#if  LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    } else if (isDoubleFPWMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
        char feature[] = "WMMA with fp64 types";
        checkFeatureVersion(gblState, 7, 0, feature, sourcePos);
        checkFeatureTarget(gblState, 80,   feature, sourcePos);
#endif
    }
    else {
        stdASSERT(False, ("Unexpected instruction type for instruction WMMA"));
    }
}

static void checkArgTypeForIntegerWMMA(int N, ptxType instrType,
                                       ptxType baseType, int argVecSize,
                                       String name, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(N == argVecSize, (ptxMsgArgumentVectorMismatch,
                                        sourcePos, name));
}

static void checkDescArgForWMMALoadStore(ptxParsingState gblState, uInt tcode, String name,
                                         msgSourcePos_t sourcePos)
{
    Bool hasDescMod = ptxHasDESC_MOD(gblState->parseData->modifiers);
    uInt descArgIdx = 0, ldmArgIdx = 0;

    if (gblState->parseData->nrofArguments != 3 && gblState->parseData->nrofArguments != 4)
        return;

    if (gblState->parseData->nrofArguments == 4) {
        if (!hasDescMod) {
            stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrArgs, sourcePos, name));
            return;
        }
        ldmArgIdx  = 2;
        descArgIdx = 3;
    } else if (hasDescMod) {
        descArgIdx = 2;
    } else {
        ldmArgIdx = 2;
    }

    if (descArgIdx) {
        Bool usesCorrectType = isB64(gblState->parseData->arguments[descArgIdx]->type) ||
                               isI64(gblState->parseData->arguments[descArgIdx]->type) ||
                               gblState->parseData->arguments[descArgIdx]->kind == ptxIntConstantExpression;
        stdCHECK_WITH_POS(usesCorrectType, (ptxMsgNonMatchingInstrArgs, sourcePos, name));
    }

    // check ldm argument to be strict
    if (ldmArgIdx) {
        Bool usesCorrectType = isB32(gblState->parseData->arguments[ldmArgIdx]->type) ||
                               isI32(gblState->parseData->arguments[ldmArgIdx]->type) ||
                               gblState->parseData->arguments[ldmArgIdx]->kind == ptxIntConstantExpression;
        stdCHECK_WITH_POS(usesCorrectType, (ptxMsgNonMatchingInstrArgs, sourcePos, name));
    }
}

static void checkArgsForWMMALoadStore(ptxParsingState gblState, uInt tcode, String name,
                                      msgSourcePos_t sourcePos)
{
    int argNumber = (tcode == ptx_wmma_store_d_Instr ? 1 : 0);
    ptxExpression arg = gblState->parseData->arguments[argNumber];
    int argIndex = 0;
    int argVecSize = arg->type->cases.Vector.N;
    ptxType baseType = arg->type->cases.Vector.base;
    ptxMMASubType typeOfMMA;
    Bool isNonStandardFPLoadStore = False;
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    isNonStandardFPLoadStore = isNonStandardFPWMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes,
                                                   gblState->parseData->instructionType);
#endif

    if (arg->type->kind != ptxVectorType) {
        stdCHECK_WITH_POS(arg->type->kind == ptxVectorType,
                          (ptxMsgVectorArgumentExpected, sourcePos, argNumber));
        return;
    }

    checkDescArgForWMMALoadStore(gblState, tcode, name, sourcePos);

    switch (tcode) {
    case ptx_wmma_load_a_Instr:
        argIndex = 1;
        break;
    case ptx_wmma_load_b_Instr:
        argIndex = 2;
        break;
    case ptx_wmma_load_c_Instr:
        argIndex = 3;
        break;
    case ptx_wmma_store_d_Instr:
        argIndex = 0;
        break;
    default:
        stdASSERT(False, ("Unknown instruction"));
    }

    if (isFloatingPointWMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
        if ((tcode == ptx_wmma_load_a_Instr || tcode == ptx_wmma_load_b_Instr)
            && !isNonStandardFPLoadStore)
        {
            stdCHECK_WITH_POS(isF16(gblState->parseData->instructionType[0]),
                              (ptxMsgIllegalType, sourcePos, name));
        }
        if (isNonStandardFPLoadStore) {
            /*  We don't have valid instructionType[0] for NonStdFPWMMA, therefore
             *  do argument checks using checkABArgTypeForFpMMA function which
             *  uses gblState->parseData->modifiers.ATYPE.
             */
            gblState->parseData->modifiers.ATYPE = gblState->parseData->typeMod[0];
            typeOfMMA = (argIndex == 0) ? ptxMMASubTypeFpStore : ptxMMASubTypeNonStdFpLoad;
            checkABArgTypeForFpMMA(gblState, typeOfMMA, baseType, argVecSize, argIndex, name, sourcePos);
        } else {
            typeOfMMA = (argIndex == 0) ? ptxMMASubTypeFpStore : ptxMMASubTypeFpLoad;
            checkArgTypeForFpMMA(gblState, typeOfMMA, gblState->parseData->instructionType[0], baseType, argVecSize,
                                 argIndex, name, sourcePos);
        }
        stdCHECK_WITH_POS(checkShapeForIntFloatWMMA(gblState, tcode, gblState->parseData->modifiers.SHAPE,
                                                    gblState->parseData->nrofInstructionTypes,
                                                    gblState->parseData->instructionType,
                                                    gblState->parseData->nrofTypeMod,
                                                    gblState->parseData->typeMod),
                          (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        return;
    }

#if (LWCFG(GLOBAL_CHIP_T194) || LWCFG(GLOBAL_GPU_IMPL_GV11B) || LWCFG(GLOBAL_ARCH_TURING)) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    if (isIntegerWMMA(tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
        int numElements;
        typeOfMMA = (argIndex == 0) ? ptxMMASubTypeNonFpStore : ptxMMASubTypeNonFpLoad;
        numElements = getNumElemsPerFragmentForMMA(gblState, typeOfMMA, gblState->parseData->modifiers.SHAPE,
                                                   gblState->parseData->modifiers.SPARSITY, argIndex);
        checkArgTypeForIntegerWMMA(numElements, gblState->parseData->instructionType[0], baseType,
                                   argVecSize, name, sourcePos);
        stdCHECK_WITH_POS(checkShapeForIntFloatWMMA(gblState, tcode, gblState->parseData->modifiers.SHAPE,
                                                    gblState->parseData->nrofInstructionTypes,
                                                    gblState->parseData->instructionType,
                                                    gblState->parseData->nrofTypeMod,
                                                    gblState->parseData->typeMod),
                          (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        return;
    }
#endif
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    if (isSubByteWMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
        int numElements;
        checkInstrTypeSubByteIMMA(gblState, tcode, name, sourcePos);
        checkInstrLayoutSubByteWMMA(gblState, tcode, name, sourcePos);
        typeOfMMA = (argIndex == 0) ? ptxMMASubTypeNonFpStore : ptxMMASubTypeNonFpLoad;
        numElements = getNumElemsPerFragmentForMMA(gblState, typeOfMMA, gblState->parseData->modifiers.SHAPE,
                                                   gblState->parseData->modifiers.SPARSITY, argIndex);
        stdCHECK_WITH_POS(argVecSize == numElements,
                          (ptxMsgArgumentVectorMismatch, sourcePos, name));
        return;
    }
    if (isBitTypeWMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
        int numElements;
        checkInstrTypeBitWMMA(gblState, tcode, name, sourcePos);
        checkInstrLayoutBitWMMA(gblState, tcode, name, sourcePos);
        typeOfMMA = (argIndex == 0) ? ptxMMASubTypeNonFpStore : ptxMMASubTypeNonFpLoad;
        numElements = getNumElemsPerFragmentForMMA(gblState, typeOfMMA, gblState->parseData->modifiers.SHAPE,
                                                   gblState->parseData->modifiers.SPARSITY, argIndex);
        stdCHECK_WITH_POS(argVecSize == numElements,
                          (ptxMsgArgumentVectorMismatch, sourcePos, name));
        return;
    }
#endif
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    if (isDoubleFPWMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
        int numElements;
        stdCHECK_WITH_POS((gblState->parseData->nrofInstructionTypes == 1 && isF64(gblState->parseData->instructionType[0])),
                          (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        typeOfMMA = (argIndex == 0) ? ptxMMASubTypeDoubleFpStore : ptxMMASubTypeDoubleFpLoad;
        numElements = getNumElemsPerFragmentForMMA(gblState, typeOfMMA, gblState->parseData->modifiers.SHAPE,
                                                   gblState->parseData->modifiers.SPARSITY, argIndex);
        stdCHECK_WITH_POS(argVecSize == numElements,
                          (ptxMsgArgumentVectorMismatch, sourcePos, name));
        return;
    }

#endif
    stdASSERT(False, ("Unexpected instruction type for instruction WMMA"));
}

static void checkShapeForWMMA(ptxParsingState gblState, uInt tcode, String name,
                              msgSourcePos_t sourcePos)
{
    switch(gblState->parseData->modifiers.SHAPE) {
    case ptxSHAPE_161616_MOD:
        checkFeatureVersion(gblState, 6, 0, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, 70),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), "sm_70"));
        return;
    case ptxSHAPE_320816_MOD:
    case ptxSHAPE_083216_MOD:
        checkFeatureVersion(gblState, 6, 1, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, 70),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), "sm_70"));
        return;
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    case ptxSHAPE_080832_MOD:
    case ptxSHAPE_0808128_MOD:
        checkFeatureVersion(gblState, 6, 3, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, minTuringArch),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), minTuringArchStr));
        return;

#endif // Turing && ISA_63
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptxSHAPE_161608_MOD:
    case ptxSHAPE_080804_MOD:
        checkFeatureVersion(gblState, 7, 0, getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, 80),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), "sm_80"));
        return;
#endif // Ampere && ISA_70
    default:
        if (gblState->parseData->modifiers.SHAPE != ptxNOSHAPE_MOD) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalMatrixShape, sourcePos,
                                      getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE), name));
        }
        return;
    }
}

static void checkWMMALoadStore(ptxParsingState gblState, uInt tcode, String name,
                               msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(gblState->parseData->nrofMatrixLayout == 1,
                      (ptxMsgModifierRequired, sourcePos, "layout", name));
    // Reusing the ALAYOUT modifier. Note that wmma.load/wmma.store has a single layout.
    gblState->parseData->modifiers.ALAYOUT = gblState->parseData->matrixLayout[0];
    checkArgsForWMMALoadStore(gblState, tcode, name, sourcePos);
}

static Bool isFPWMMAWithImplicitTypes(uInt shape)
{
    switch(shape) {
    case ptxSHAPE_161616_MOD:
    case ptxSHAPE_083216_MOD:
    case ptxSHAPE_320816_MOD:
        return True;
    default:
        return False;
    }
}

static void checkArgsForFPWMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{

    int i;
    int argVecSize;
    ptxType baseType;
    ptxMMASubType typeOfMMA = ptxMMASubTypeWMMAFp;

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    if (isNonStandardFPWMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
        typeOfMMA = ptxMMASubTypeWMMANonStdFp;
        gblState->parseData->modifiers.ATYPE = gblState->parseData->typeMod[1];
        gblState->parseData->modifiers.BTYPE = gblState->parseData->typeMod[2];
    }
#endif

    stdASSERT(gblState->parseData->nrofArguments == 4, ("expected four arguments"));

    for (i = 0; i != 4; ++i) {
        if (gblState->parseData->arguments[i]->type->kind != ptxVectorType) {
            stdCHECK_WITH_POS(False, (ptxMsgVectorArgumentExpected,
                                      sourcePos, i));
            continue;
        }

        baseType = gblState->parseData->arguments[i]->type->cases.Vector.base;
        argVecSize = gblState->parseData->arguments[i]->type->cases.Vector.N;

        switch (i) {
        case 0:
            checkArgTypeForFpMMA(gblState, typeOfMMA, gblState->parseData->instructionType[0], baseType, argVecSize,
                                 i, name, sourcePos);
            break;
        case 1:
        case 2:
            checkABArgTypeForFpMMA(gblState, typeOfMMA, baseType, argVecSize, i, name, sourcePos);
            break;
        case 3:
            checkArgTypeForFpMMA(gblState, typeOfMMA, gblState->parseData->instructionType[1], baseType, argVecSize,
                                 i, name, sourcePos);
            break;
        }
    }
}

#if (LWCFG(GLOBAL_CHIP_T194) || LWCFG(GLOBAL_GPU_IMPL_GV11B) || LWCFG(GLOBAL_ARCH_TURING)) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
static void checkArgsForIntegerWMMA(ptxParsingState gblState, uInt tcode, String name,
                                    msgSourcePos_t sourcePos)
{

    int i;
    int argVecSize, numElements;
    ptxType baseType;

    stdASSERT(gblState->parseData->nrofArguments == 4, ("expected four arguments"));

    for (i = 0; i != 4; ++i) {
        if (gblState->parseData->arguments[i]->type->kind != ptxVectorType) {
            stdCHECK_WITH_POS(False, (ptxMsgVectorArgumentExpected,
                                      sourcePos, i));
            continue;
        }

        baseType = gblState->parseData->arguments[i]->type->cases.Vector.base;
        argVecSize = gblState->parseData->arguments[i]->type->cases.Vector.N;
        numElements = getNumElemsPerFragmentForMMA(gblState, ptxMMASubTypeWMMANonFp, gblState->parseData->modifiers.SHAPE,
                                                   gblState->parseData->modifiers.SPARSITY, i);
        checkArgTypeForIntegerWMMA(numElements, gblState->parseData->instructionType[i], baseType,
                                   argVecSize, name, sourcePos);
    }
}

static void checkInstructionTypeForIntegerWMMA(ptxParsingState gblState, uInt tcode, String name,
                                               msgSourcePos_t sourcePos)
{
    Bool ABTypeCheck, CDTypeCheck;

    ABTypeCheck = (isU8(gblState->parseData->instructionType[1]) && isU8(gblState->parseData->instructionType[2]))
                   || (isS8(gblState->parseData->instructionType[1]) && isS8(gblState->parseData->instructionType[2]));

    CDTypeCheck = isS32(gblState->parseData->instructionType[0]) && isS32(gblState->parseData->instructionType[3]);

    stdCHECK_WITH_POS(ABTypeCheck, (ptxMsgNonMatchingInstrTypes, sourcePos,
                                    name));

    stdCHECK_WITH_POS(CDTypeCheck, (ptxMsgNonMatchingInstrTypes, sourcePos,
                                    name));
}
#endif

#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
static void checkInstructionTypeForSubByteWMMA(ptxParsingState gblState, uInt tcode, String name,
                                               msgSourcePos_t sourcePos)
{
    Bool ABTypeCheck = False , CDTypeCheck = False;

    if (gblState->parseData->nrofTypeMod == 4) {
        gblState->parseData->modifiers.ATYPE = gblState->parseData->typeMod[1];
        gblState->parseData->modifiers.BTYPE = gblState->parseData->typeMod[2];
        ABTypeCheck = ((gblState->parseData->modifiers.ATYPE == gblState->parseData->modifiers.BTYPE) &&
                        isI4Mod(gblState->parseData->modifiers.BTYPE));
    }

    if (gblState->parseData->nrofInstructionTypes == 2) {
        CDTypeCheck = isS32(gblState->parseData->instructionType[0]) && isS32(gblState->parseData->instructionType[1]);
    }

    stdCHECK_WITH_POS(ABTypeCheck && CDTypeCheck, (ptxMsgNonMatchingInstrTypes,
                                                   sourcePos, name));
}

static void checkArgsForBitAndSubByteWMMACommon(ptxParsingState gblState, uInt tcode, String name,
                                                msgSourcePos_t sourcePos)
{

    int i;
    int argVecSize, numElements;

    stdASSERT(gblState->parseData->nrofArguments == 4, ("expected four arguments"));

    for (i = 0; i != 4; ++i) {
        if (gblState->parseData->arguments[i]->type->kind != ptxVectorType) {
            stdCHECK_WITH_POS(False, (ptxMsgVectorArgumentExpected,
                                      sourcePos, i));
            continue;
        }

        argVecSize = gblState->parseData->arguments[i]->type->cases.Vector.N;
        numElements = getNumElemsPerFragmentForMMA(gblState, ptxMMASubTypeWMMANonFp, gblState->parseData->modifiers.SHAPE,
                                                   gblState->parseData->modifiers.SPARSITY, i);

        stdCHECK_WITH_POS(argVecSize == numElements, (ptxMsgArgumentVectorMismatch,
                                                      sourcePos, name));
    }
}

static void checkArgsForBitWMMA(ptxParsingState gblState, uInt tcode, String name,
                                msgSourcePos_t sourcePos)
{
    checkArgsForBitAndSubByteWMMACommon(gblState, tcode, name, sourcePos);

}

static void checkArgsForSubByteWMMA(ptxParsingState gblState, uInt tcode, String name,
                                    msgSourcePos_t sourcePos)
{

    checkArgsForBitAndSubByteWMMACommon(gblState, tcode, name, sourcePos);

}

static void checkInstructionTypeForBitTypeWMMA(ptxParsingState gblState, uInt tcode, String name,
                                               msgSourcePos_t sourcePos)
{
    Bool ABTypeCheck = False , CDTypeCheck = False;

    if (gblState->parseData->nrofTypeMod == 4) {
        gblState->parseData->modifiers.ATYPE = gblState->parseData->typeMod[1];
        gblState->parseData->modifiers.BTYPE = gblState->parseData->typeMod[2];
        ABTypeCheck = (gblState->parseData->modifiers.ATYPE == gblState->parseData->modifiers.BTYPE &&
                       gblState->parseData->modifiers.BTYPE == ptxTYPE_b1_MOD) ;
    }

    if (gblState->parseData->nrofInstructionTypes == 2) {
        CDTypeCheck = isS32(gblState->parseData->instructionType[0]) && isS32(gblState->parseData->instructionType[1]);
    }

    stdCHECK_WITH_POS(ABTypeCheck && CDTypeCheck, (ptxMsgNonMatchingInstrTypes,
                                                   sourcePos, name));
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkArgsForDoubleFPWMMA(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    int i;
    stdASSERT(gblState->parseData->nrofArguments == 4, ("expected four arguments"));
    for (i = 0; i != 4; ++i) {
        if (gblState->parseData->arguments[i]->type->kind != ptxVectorType) {
            stdCHECK_WITH_POS(False, (ptxMsgVectorArgumentExpected,
                                      sourcePos, i));
            continue;
        }
    }
    checkArgsForDMMA(gblState, name, sourcePos);
}
#endif // AMPERE && ISA_70

static void checkMMAForWMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    setLayoutsForMMA(gblState, name, sourcePos);

    if (isFloatingPointWMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
        uInt implicitTypes = 0, implicitTypeMod = ptxNOTYPE_MOD;
        if (isFPWMMAWithImplicitTypes(gblState->parseData->modifiers.SHAPE)) {
            // .f16 is the implicit type for AB.
            implicitTypeMod = ptxTYPE_f16_MOD; // .f16
            implicitTypes = 1; // AB implicit
        }
        makeImplicitTypeExplicitForMMA(gblState, implicitTypes, implicitTypeMod);
        checkFPWMMASatfinite(gblState, tcode, name, sourcePos);
        checkArgsForFPWMMA(gblState, tcode, name, sourcePos);
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
        if (isNonStandardFPWMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
            stdCHECK_WITH_POS(checkShapeForNonStandardFpWMMA(tcode, gblState->parseData->modifiers.SHAPE, gblState->parseData->nrofTypeMod, gblState->parseData->typeMod),
                              (ptxMsgNonMatchingShapeTypes, sourcePos, name,
                               getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        }
#endif
        return;
    }

#if (LWCFG(GLOBAL_CHIP_T194) || LWCFG(GLOBAL_GPU_IMPL_GV11B) || LWCFG(GLOBAL_ARCH_TURING)) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    if (isIntegerWMMA(tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
        checkInstructionTypeForIntegerWMMA(gblState, tcode, name, sourcePos);
        checkArgsForIntegerWMMA(gblState, tcode, name, sourcePos);
        return;
    }
#endif
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    if (isSubByteWMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
        checkLayoutOrder(gblState, name, sourcePos, ptxLAYOUT_ROW_MOD, ptxLAYOUT_COL_MOD);
        checkInstructionTypeForSubByteWMMA(gblState, tcode, name, sourcePos);
        checkArgsForSubByteWMMA(gblState, tcode, name, sourcePos);
        stdCHECK_WITH_POS(gblState->parseData->postopclass == NoOperationClass,
                          (ptxMsgNotAllowedModForInstShape, sourcePos,
                           get_strPOSTOP(gblState->parseData), name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
        return;
    }
    if (isBitTypeWMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
        checkOperationsForBMMA(gblState, tcode, name, sourcePos);
        checkLayoutOrder(gblState, name, sourcePos, ptxLAYOUT_ROW_MOD, ptxLAYOUT_COL_MOD);
        checkInstructionTypeForBitTypeWMMA(gblState, tcode, name, sourcePos);
        checkArgsForBitWMMA(gblState, tcode, name, sourcePos);
        stdCHECK_WITH_POS(!gblState->parseData->modifiers.SATF,
                          (ptxMsgNotAllowedModForInstShape, sourcePos,
                           get_strSATF(gblState->parseData), name,
                           getSHAPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.SHAPE)));
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
        stdCHECK_WITH_POS(stdIMPLIES(gblState->parseData->BMMAOperations[0] == ptxMMA_AND_MOD,
                                     ptxVersionAtLeast(7, 1, gblState)),
                          (ptxMsgInstModRequiresPTXVersion, sourcePos,
                           getMMA_OPAsString(ptxMMA_AND_MOD), name, "7.1"));
#endif
        return;
    }
#endif // Turing && ISA_63
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    if (isDoubleFPWMMA(gblState, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType)) {
        // If no rounding modifier given, enforce .rn
        checkRoundingModifierForDMMA(gblState, name, sourcePos);
        checkArgsForDoubleFPWMMA(gblState, name, sourcePos);
        return;
    }

#endif // Ampere && ISA_70
    stdASSERT(False, ("Unexpected instruction type for instruction WMMA"));

}

static void checkWMMA(ptxParsingState gblState, uInt tcode, String name, msgSourcePos_t sourcePos)
{
    // Common checks
    checkVersionTargetForWMMA(gblState, tcode, name, sourcePos);
    checkAlignedforWMMA(gblState, tcode, name, sourcePos);
    checkShapeForWMMA(gblState, tcode, name, sourcePos);
    gblState->parseData->lwrFunc->aux->usesWMMAInstrs = True;

    if (ptxIsWMMALoadStore(tcode)) {
        // WMMA load store checks
        checkWMMALoadStore(gblState, tcode, name, sourcePos);
    } else if (tcode == ptx_wmma_mma_Instr) {
       // WMMA MMA checks
        checkMMAForWMMA(gblState, tcode, name, sourcePos);
    }
    reportWMMALimitations(gblState, tcode, name, sourcePos);
}
#endif

#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)

static void checkInstrTypeForScatter(ptxParsingState gblState, cString name, msgSourcePos_t sourcePos)
{
    if (gblState->parseData->nrofTypeMod != 2) {
        stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrTypes, sourcePos, name));
        return;
    }

    switch(gblState->parseData->typeMod[0]) {
        case ptxTYPE_b8_MOD  :  break;
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
        case ptxTYPE_b16_MOD :  stdCHECK_WITH_POS(checkTargetArch(gblState, 80),
                                                 (ptxMsgModifierRequiresSMVersion,
                                                  sourcePos,
                                                  getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxTYPE_b16_MOD),
                                                  "sm_80"));
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
                                checkFeatureVersion(gblState, 6, 4, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxTYPE_b16_MOD), sourcePos);
#else
                                checkFeatureVersion(gblState, 7, 0, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxTYPE_b16_MOD), sourcePos);
#endif
                                break;
#endif // Ampere, internal
        default              :  stdCHECK_WITH_POS(False,
                                                  (ptxMsgNonMatchingInstrTypes,
                                                  sourcePos, name));
    }

    stdCHECK_WITH_POS(gblState->parseData->typeMod[1] == ptxTYPE_b4_MOD ||
                      gblState->parseData->typeMod[1] == ptxTYPE_b8_MOD,
                      (ptxMsgNonMatchingInstrTypes, sourcePos, name));
}

static void checkModifierForScatter(ptxParsingState gblState, cString name, ptxModifier mod,
                                    msgSourcePos_t sourcePos)
{
    char modifierName[] = "Mode";
    stdCHECK_WITH_POS(ptxHasTHREADGROUP_MOD(mod), (ptxMsgModifierRequired, sourcePos,
                                                   modifierName, name));
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
   if (mod.THREADGROUP == ptxTGPAIR_MOD) {
        stdCHECK_WITH_POS(checkTargetArch(gblState, 80), (ptxMsgModifierRequiresSMVersion, sourcePos,
                                                getTHREADGROUPAsString(gblState->parseData->deobfuscatedStringMapPtr, mod.THREADGROUP), "sm_80"));
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        checkFeatureVersion(gblState, 6, 4, getTHREADGROUPAsString(gblState->parseData->deobfuscatedStringMapPtr, mod.THREADGROUP), sourcePos);
#else
        checkFeatureVersion(gblState, 7, 0, getTHREADGROUPAsString(gblState->parseData->deobfuscatedStringMapPtr, mod.THREADGROUP), sourcePos);
#endif
    }
    if (mod.SPARSITY) {
        stdCHECK_WITH_POS(checkTargetArch(gblState, 80), (ptxMsgModifierRequiresSMVersion,
                                                sourcePos, getSPARSITYAsString(mod.SPARSITY),
                                                "sm_80"));
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        checkFeatureVersion(gblState, 6, 4, getSPARSITYAsString(mod.SPARSITY), sourcePos);
#else
        checkFeatureVersion(gblState, 7, 0, getSPARSITYAsString(mod.SPARSITY), sourcePos);
#endif
    }
#endif // Ampere, internal
}

static void checkScatterArgRange(ptxExpression arg, int argIndex, int milwal, int maxVal,
                                 cString name, msgSourcePos_t sourcePos)
{
    uInt64 val;
    if (arg->kind != ptxIntConstantExpression) {
        stdCHECK_WITH_POS(False, (ptxMsgConstantArgRequired, sourcePos,
                                  argIndex, name));
        return;
    }

    val = arg->cases.IntConstant.i;
    stdCHECK_WITH_POS((milwal <= val && val <= maxVal),
                      (ptxMsgArgValueOutOfRange, sourcePos, argIndex,
                       name, val, milwal, maxVal));
}

static void checkIdxArgForScatter(ptxParsingState gblState, ptxExpression idxArg, int index, uInt tcode,
                                  cString name, msgSourcePos_t sourcePos)
{
    uInt nIdx       = 32 / (ptxGetTypeSizeInBits(gblState->parseData->instructionType[0]));
    uInt idxSize, idxArgSize;

    if (gblState->parseData->nrofTypeMod != 2)
        return;
    idxSize    = ptxGetTypeModSize(gblState->parseData->typeMod[1]);
    idxArgSize = nIdx * idxSize;
    stdCHECK_WITH_POS( idxArgSize == ptxGetTypeSizeInBits(idxArg->type),
                       (ptxMsgDifferentArgSizeExpected, sourcePos,
                        index, name, idxArgSize));
}

static void checkVecIdxArgForScatter(ptxParsingState gblState, ptxExpression vecIdx, int index, uInt tcode,
                                     cString name, msgSourcePos_t sourcePos)
{
    uInt  vecIdxMax, nBitsElements, nBitsTarget;
    int nBitsSubVectors;
    switch (ptxGetTypeSizeInBits(gblState->parseData->instructionType[0])) {
        case  8:  nBitsElements = 2; break; // .b8  (4 elements)
        case 16:  nBitsElements = 1; break; // .b16 (2 elements)
        default: stdASSERT(False, ("unexpected type"));
                 return;
    }
    if (gblState->parseData->nrofTypeMod != 2)
        return;
    nBitsTarget     = ptxGetTypeModSize(gblState->parseData->typeMod[1]);
    nBitsSubVectors = nBitsTarget - nBitsElements;

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    if (gblState->parseData->modifiers.SPARSITY) {
        nBitsSubVectors--;
    }
#endif

    if (gblState->parseData->modifiers.THREADGROUP == ptxTGQUAD_MOD) {
        nBitsSubVectors -= 2; // 2 Bits are used for LIQ
    } else if (gblState->parseData->modifiers.THREADGROUP == ptxTGPAIR_MOD) {
        nBitsSubVectors -= 1; // 1 Bit is used for LIP
    }

    if (nBitsSubVectors < 0) {
        String threadGroupStr = stdCONCATSTRING("in mode ", get_strTHREADGROUP(gblState->parseData));
        stdCHECK_WITH_POS(False,
                          (ptxMsgIlwalidCombinationForInstr, sourcePos, getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->typeMod[0]),
                           getTYPEMODAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->typeMod[1]), name, threadGroupStr));
        stdFREE(threadGroupStr);
        return;
    }

    vecIdxMax = (1 << nBitsSubVectors) - 1;
    checkScatterArgRange(vecIdx, index, 0, vecIdxMax, name, sourcePos);
}

static void checkMaskArgForScatter(ptxParsingState gblState, ptxExpression mask, int index, uInt tcode,
                                   cString name, uInt sparseMod,
                                   msgSourcePos_t sourcePos)
{
    uInt maskMax;

    if (isB8(gblState->parseData->instructionType[0])) {
        maskMax = 0xF;
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    } else if (isB16(gblState->parseData->instructionType[0])) {
        maskMax = 0x3;
#endif
    } else {
        stdASSERT(False, ("unexpected type"));
        maskMax = 0x0;
    }
    checkScatterArgRange(mask, index, 0, maskMax, name, sourcePos);

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    if (sparseMod) {
        uInt maskVal, setBitsInMask = 0;
        maskVal = (uInt) mask->cases.IntConstant.i;
        setBitsInMask = stdNrofBits32(maskVal);
        stdCHECK_WITH_POS(setBitsInMask <= 2, (ptxMsgConstArgMaxNoBitsSet, sourcePos,
                                               index, name, 2));
    }
#endif
}

static void checkScatterArgs(ptxParsingState gblState, uInt tcode, cString name, uInt sparseMod, msgSourcePos_t sourcePos)
{
    checkIdxArgForScatter   (gblState, gblState->parseData->arguments[2], 2, tcode, name, sourcePos);
    checkVecIdxArgForScatter(gblState, gblState->parseData->arguments[3], 3, tcode, name, sourcePos);
    checkMaskArgForScatter  (gblState, gblState->parseData->arguments[4], 4, tcode, name, sparseMod, sourcePos);
}

static void checkScatterInstruction(ptxParsingState gblState, uInt tcode, cString name,
                                    msgSourcePos_t sourcePos)
{
    checkFeatureVersion(gblState, 6, 3, name, sourcePos);
    checkFeatureTarget(gblState, minTuringArch,   name, sourcePos);

    checkInstrTypeForScatter(gblState, name, sourcePos);
    checkModifierForScatter(gblState, name, gblState->parseData->modifiers, sourcePos);
    checkScatterArgs(gblState, tcode, name, gblState->parseData->modifiers.SPARSITY, sourcePos);
}

#endif

// Add all CACHEPREFETCH modifier related checks here
static void checkCachePrefetchModifier(ptxParsingState gblState, ptxInstructionTemplate template, String name,
                                       msgSourcePos_t sourcePos)
{
    uInt tcode = template->code;

    stdCHECK_WITH_POS(ptxHasCACHEPREFETCH_Feature(template->features),
                      (ptxMsgIllegalModifier, sourcePos, get_strCACHEPREFETCH(gblState->parseData),
                       name));

    if (tcode == ptx_ld_Instr || tcode == ptx_cp_async_Instr) {
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
        stdCHECK_WITH_POS(checkTargetArch(gblState, minTuringArch),
                          (ptxMsgFeatureRequiresSMVersion, sourcePos,
                          "cache prefetching", minTuringArchStr));
        checkFeatureVersion(gblState, 7, 4, "cache prefetching", sourcePos);
#endif // Turing && ISA_74

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
        if (gblState->parseData->modifiers.CACHEPREFETCH == ptxCACHEPREFETCH_L2_256B_MOD) {
            stdCHECK_WITH_POS(checkTargetArch(gblState, 80),
                              (ptxMsgModifierRequiresSMVersion, sourcePos,
                               get_strCACHEPREFETCH(gblState->parseData), "sm_80"));
            checkFeatureVersion(gblState, 7, 4, "256B cache prefetching", sourcePos);
        }
#endif // Ampere && ISA_74

        stdCHECK_WITH_POS(stdIMPLIES(tcode == ptx_ld_Instr,
                                     (gblState->parseData->storage[0].kind == ptxGlobalStorage ||
                                      gblState->parseData->storage[0].kind == ptxGenericStorage)),
                          (ptxMsgSpaceIncorrectForFeature,
                           sourcePos, "cache prefetching"));

    } else {
        stdCHECK_WITH_POS(False, (ptxMsgIllegalModifier, sourcePos,
                                  get_strCACHEPREFETCH(gblState->parseData), name));
    }
}

// Add all LEVEL modifier related checks here
static void checkLevelModifier(ptxParsingState gblState, ptxInstructionTemplate template, String name,
                               msgSourcePos_t sourcePos)
{
    uInt tcode = template->code;

    stdCHECK_WITH_POS(ptxHasLEVEL_Feature(template->features),
                      (ptxMsgIllegalModifier, sourcePos, get_strLEVEL(gblState->parseData), name));

    stdCHECK_WITH_POS(checkTargetArch(gblState, 20),
                      (ptxMsgSMVersionRequired, sourcePos, name, "sm_20"));

    stdCHECK_WITH_POS(checkCacheLevel(tcode, gblState->parseData->modifiers.LEVEL),
                      (ptxMsgIllegalModifier, sourcePos, get_strLEVEL(gblState->parseData), name));

    if (tcode == ptx_ld_Instr) {
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        stdCHECK_WITH_POS(checkTargetArch(gblState, minTuringArch),
                          (ptxMsgFeatureRequiresSMVersion,
                           sourcePos, "cache level", minTuringArchStr));

        checkFeatureVersion(gblState, 6, 0, "cache level", sourcePos);

        stdCHECK_WITH_POS(gblState->parseData->modifiers.PREFETCHSIZE, (ptxMsgModifierRequiresFeature,
                                                   sourcePos, get_strLEVEL(gblState->parseData),
                                                   "prefetch size", name));

        stdCHECK_WITH_POS(!gblState->parseData->modifiers.CACHEOP, (ptxMsgIllegalModifierPair, sourcePos,
                                               get_strLEVEL(gblState->parseData), get_strCACHEOP(gblState->parseData)));
#else
        stdCHECK_WITH_POS(False, (ptxMsgIllegalModifier, sourcePos, get_strLEVEL(gblState->parseData),
                                  name));
#endif // Turing && Internal
    }
}

// Add all PREFETCHSIZE modifier related checks here
static void checkPrefetchSizeModifier(ptxParsingState gblState, ptxInstructionTemplate template, String name,
                                      msgSourcePos_t sourcePos)
{
    uInt tcode = template->code;

    stdCHECK_WITH_POS(ptxHasPREFETCHSIZE_Feature(template->features),
                      (ptxMsgIllegalModifier, sourcePos, get_strPREFETCHSIZE(gblState->parseData),
                       name));

    if (tcode == ptx_ld_Instr) {
        stdCHECK_WITH_POS(gblState->parseData->modifiers.LEVEL, (ptxMsgModifierRequiresFeature,
                                            sourcePos, get_strPREFETCHSIZE(gblState->parseData),
                                            "cache level", name));

        stdCHECK_WITH_POS(!gblState->parseData->modifiers.CACHEOP, (ptxMsgIllegalModifierPair, sourcePos,
                                               get_strPREFETCHSIZE(gblState->parseData),
                                               get_strCACHEOP(gblState->parseData)));

#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        stdCHECK_WITH_POS(checkTargetArch(gblState, minTuringArch),
                          (ptxMsgFeatureRequiresSMVersion, sourcePos,
                          "prefetch size", minTuringArchStr));
        checkFeatureVersion(gblState, 6, 0, "prefetch size", sourcePos);
#endif // Turing && Internal

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        if (gblState->parseData->modifiers.PREFETCHSIZE == ptxPREFETCHSIZE_256B_MOD) {
            stdCHECK_WITH_POS(checkTargetArch(gblState, 80), (ptxMsgModifierRequiresSMVersion,
                              sourcePos, get_strPREFETCHSIZE(gblState->parseData), "sm_80"));
            // FIXME: update version check
            checkFeatureVersion(gblState, 6, 3, "256B prefetch size", sourcePos);
        }
#endif // Ampere && Internal
    }
}

#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
static void restrictLevelColonEvictPriorityModifier(ptxInstructionTemplate template, String name,
                                                    msgSourcePos_t sourcePos)
{
    uInt tcode = template->code;

    if (tcode == ptx_ld_Instr || tcode == ptx_st_Instr) {
        return;
    }

#if LWCFG(GLOBAL_ARCH_AMPERE)
    if (tcode == ptx_prefetch_Instr || tcode == ptx_applypriority_Instr ||
        tcode == ptx_createpolicy_range_Instr || tcode == ptx_createpolicy_fractional_Instr)
    {
        return;
    }
#endif

    stdCHECK_WITH_POS(False, (ptxMsgIllegalModifier, sourcePos,
                              ".level::eviction_priority", name));
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
static void checkEVICTPRIORITYModOnApplypriority(ptxParsingState gblState, ptxInstructionTemplate template, String name,
                                                 msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(ptxVersionAtLeast(7, 4, gblState),
                      (ptxMsgInstModRequiresPTXVersion, sourcePos,
                       get_strEVICTPRIORITY(gblState->parseData), name, "7.4"));
    stdCHECK_WITH_POS(checkTargetArch(gblState, 80), (ptxMsgInstModRequiresSMVersion,
                                            sourcePos, get_strEVICTPRIORITY(gblState->parseData),
                                            name, "sm_80"));
    stdCHECK_WITH_POS(gblState->parseData->modifiers.EVICTPRIORITY == ptxEVICTNORMAL_MOD,
                      (ptxMsgUnsupportedModifier, sourcePos, get_strEVICTPRIORITY(gblState->parseData),
                       name));
    stdCHECK_WITH_POS((gblState->parseData->modifiers.LEVEL == ptxL2_MOD || gblState->parseData->levelColonMods[0] == ptxL2_MOD),
                      (ptxMsgModifierRequiresFeature,
                       sourcePos, get_strEVICTPRIORITY(gblState->parseData),
                       "cache level L2", name));
    stdCHECK_WITH_POS(gblState->parseData->nrofEvictPriorityMod == gblState->parseData->nrofLevelColonMod,
                      (ptxMsgSyntaxExpected, sourcePos, ".level::eviction_priority", name));
    stdCHECK_WITH_POS(!(gblState->parseData->modifiers.LEVEL && gblState->parseData->nrofLevelColonMod > 0),
                      (ptxMsgIllegalModifierWithMod, sourcePos,
                       get_strLEVEL(gblState->parseData), name, ".level::eviction_priority"));
    stdCHECK_WITH_POS((gblState->parseData->storage[0].kind == ptxGlobalStorage ||
                       gblState->parseData->storage[0].kind == ptxGenericStorage),
                      (ptxMsgSpaceIncorrectForFeature,
                       sourcePos, "cache eviction priority"));
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
static void checkEVICTPRIORITYModOnCreatepolicy(ptxParsingState gblState, ptxInstructionTemplate template, String name,
                                                 msgSourcePos_t sourcePos)
{
    if (gblState->parseData->modifiers.HITPRIORITY) {
        stdCHECK_WITH_POS(ptxVersionAtLeast(7, 4, gblState),
                          (ptxMsgInstModRequiresPTXVersion, sourcePos,
                           get_strHITPRIORITY(gblState->parseData), name, "7.4"));
        stdCHECK_WITH_POS(checkTargetArch(gblState, 80), (ptxMsgInstModRequiresSMVersion,
                                                sourcePos, get_strHITPRIORITY(gblState->parseData),
                                                name, "sm_80"));
    }
    if (gblState->parseData->modifiers.MISSPRIORITY) {
        stdCHECK_WITH_POS(ptxVersionAtLeast(7, 4, gblState),
                          (ptxMsgInstModRequiresPTXVersion, sourcePos,
                           get_strMISSPRIORITY(gblState->parseData), name, "7.4"));
        stdCHECK_WITH_POS(checkTargetArch(gblState, 80), (ptxMsgInstModRequiresSMVersion,
                                                sourcePos, get_strMISSPRIORITY(gblState->parseData),
                                                name, "sm_80"));
    }
    stdCHECK_WITH_POS(gblState->parseData->nrofEvictPriorityMod == gblState->parseData->nrofLevelColonMod,
                      (ptxMsgSyntaxExpected, sourcePos, ".level::eviction_priority", name));
    stdCHECK_WITH_POS(!(gblState->parseData->modifiers.LEVEL && gblState->parseData->nrofLevelColonMod > 0),
                      (ptxMsgIllegalModifierWithMod, sourcePos,
                       get_strLEVEL(gblState->parseData), name, ".level::eviction_priority"));
    // Other modifier related checks are handled while setting HIT/MISS PRIORITY
}
#endif

#if LWCFG(GLOBAL_ARCH_ADA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkL2EVICTPRIORITYModOnLoadStore(ptxParsingState gblState, ptxInstructionTemplate template, String name,
                                             msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(isWideLoadStoreInstr(template->code, gblState->parseData->instructionType[0], gblState->parseData->modifiers),
                      (ptxMsgInstRequiresTypeModifier,
                       sourcePos, name, ".v8.b32",
                       get_L2EVICTPRIORITYAsString(gblState->parseData->modifiers.L2EVICTPRIORITY)));

    stdCHECK_WITH_POS((gblState->parseData->modifiers.L2EVICTPRIORITY  == ptxL2EVICTFIRST_MOD ||
                       gblState->parseData->modifiers.L2EVICTPRIORITY  == ptxL2EVICTLAST_MOD  ||
                       gblState->parseData->modifiers.L2EVICTPRIORITY  == ptxL2EVICTNORMAL_MOD ),
                       (ptxMsgIllegalModifier, sourcePos,
                        get_L2EVICTPRIORITYAsString(gblState->parseData->modifiers.L2EVICTPRIORITY), name));
}
#endif // ada, internal

#if LWCFG(GLOBAL_ARCH_ADA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static Bool disallowNonColonEvictPrioritySyntaxOnLoadStore(int nrofEvictPriorityMod)
{
    switch (nrofEvictPriorityMod) {
    case 1: return False;
    case 2: return True;
    default:
        stdASSERT(False, ("Unexpected number of eviction priorities specified"));
    }
    return False;
}
#endif // ada, internal

#if LWCFG(GLOBAL_ARCH_VOLTA) && (LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71))
static void checkEVICTPRIORITYModOnLoadStore(ptxParsingState gblState, ptxInstructionTemplate template, String name,
                                             msgSourcePos_t sourcePos)
{
    // PTX 7.4 supports eviction policy publicly
    // PTX 7.2 has that as internal and extended (extended was added in update release under same version) feature
    uInt minPtxMajorVersion = 7;
    uInt minPtxMinorVersion = 4;
    cString minPtxVersionStr = "7.4";

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    minPtxMajorVersion = 7;
    minPtxMinorVersion = 2;
    minPtxVersionStr = "7.2";
#else
    if (areExtendedInstructionsEnabled(gblState->parseData)) {
        minPtxMajorVersion = 7;
        minPtxMinorVersion = 2;
        minPtxVersionStr = "7.2";
    }
#endif
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
    if (True) {
#else
    if (areExtendedInstructionsEnabled(gblState->parseData)) {
#endif
        if (gblState->parseData->nrofLevelColonMod  > 1 && gblState->parseData->levelColonMods[0] == gblState->parseData->levelColonMods[1]) {
            char cacheMod[30];
            snprintf(cacheMod, 30, "%s::eviction_priority",
                     getLEVELAsString(gblState->parseData->levelColonMods[0]));
 
            stdCHECK_WITH_POS(False,(ptxMsgDuplicateModifierInstr,
                                     sourcePos, cacheMod, name));
        }

        if (gblState->parseData->modifiers.EVICTPRIORITY) {
            stdCHECK_WITH_POS(ptxVersionAtLeast(minPtxMajorVersion, minPtxMinorVersion, gblState),
                              (ptxMsgInstModRequiresPTXVersion, sourcePos,
                               get_strEVICTPRIORITY(gblState->parseData), name, minPtxVersionStr));
            stdCHECK_WITH_POS(checkTargetArch(gblState, 70), (ptxMsgInstModRequiresSMVersion,
                                                    sourcePos, get_strEVICTPRIORITY(gblState->parseData),
                                                    name, "sm_70"));
            stdCHECK_WITH_POS((gblState->parseData->storage[0].kind == ptxGlobalStorage ||
                               gblState->parseData->storage[0].kind == ptxGenericStorage),
                              (ptxMsgModIlwalidWithStateSpace,
                               sourcePos, get_strEVICTPRIORITY(gblState->parseData), get_strSTORAGE(gblState->parseData), name ));
            stdCHECK_WITH_POS(gblState->parseData->modifiers.CACHEOP == ptxNOCACHEOP_MOD,
                              (ptxMsgIllegalModifierPair, sourcePos,
                               get_strEVICTPRIORITY(gblState->parseData), get_strCACHEOP(gblState->parseData)));
            stdCHECK_WITH_POS(gblState->parseData->modifiers.ORDER != ptxVOLATILE_MOD,
                              (ptxMsgIllegalModifierPair, sourcePos,
                               get_strEVICTPRIORITY(gblState->parseData), get_strORDER(gblState->parseData)));
        }
#if !LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
        if (!areExtendedInstructionsEnabled(gblState->parseData)) {
            stdCHECK_WITH_POS(gblState->parseData->nrofEvictPriorityMod == gblState->parseData->nrofLevelColonMod,
                              (ptxMsgSyntaxExpected, sourcePos, ".L1::eviction_priority", name));

            // In public only one modifier is allowed so check for 0th position levelColonMod
            stdCHECK_WITH_POS(gblState->parseData->nrofLevelColonMod == 1 && gblState->parseData->levelColonMods[0] == ptxL1_MOD,
                              (ptxMsgSyntaxExpected, sourcePos, ".L1::eviction_priority", name));
        }
#endif

#if LWCFG(GLOBAL_ARCH_ADA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        if (disallowNonColonEvictPrioritySyntaxOnLoadStore(gblState->parseData->nrofEvictPriorityMod)) {
            stdCHECK_WITH_POS(gblState->parseData->nrofEvictPriorityMod == gblState->parseData->nrofLevelColonMod,
                              (ptxMsgSyntaxExpected, sourcePos, ".level::eviction_priority", name));
        }
        if (gblState->parseData->modifiers.L2EVICTPRIORITY) {
           checkL2EVICTPRIORITYModOnLoadStore(gblState, template, name, sourcePos);
        }
#endif //ada, internal
    } else {
        stdCHECK_WITH_POS(False, (ptxMsgIllegalModifier, sourcePos, get_strEVICTPRIORITY(gblState->parseData), name));
    }
}
#endif

#if LWCFG(GLOBAL_ARCH_VOLTA) && (LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71))
static void checkEVICTPRIORITYModOnPrefetchCachepolicy(ptxParsingState gblState, ptxInstructionTemplate template, String name,
                                                       msgSourcePos_t sourcePos)
{
    uInt tcode = template->code;
    uInt minPtxMajorVersion, minPtxMinorVersion;
    cString minPtxVersionStr;

    Char feature[] = "cache eviction priority";
    // 7.1 for extended, 6.3 for internal.
    // 7.4 for public release on prefetch

    if (tcode == ptx_prefetch_Instr) {
        minPtxMajorVersion = 7;
        minPtxMinorVersion = 4;
        minPtxVersionStr = "7.4";
    }
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    minPtxMajorVersion = 6;
    minPtxMinorVersion = 3;
    minPtxVersionStr = "6.3";
#else
    if (areExtendedInstructionsEnabled(gblState->parseData)) {
        minPtxMajorVersion = 7;
        minPtxMinorVersion = 1;
        minPtxVersionStr = "7.1";
    }
#endif
    stdCHECK_WITH_POS(ptxVersionAtLeast(minPtxMajorVersion, minPtxMinorVersion, gblState),
                      (ptxMsgInstModRequiresPTXVersion, sourcePos,
                       feature, name, minPtxVersionStr));
    stdCHECK_WITH_POS(checkTargetArch(gblState, 80), (ptxMsgInstModRequiresSMVersion,
                                            sourcePos, feature,
                                            name, "sm_80"));
    if (tcode == ptx_prefetch_Instr) {
        stdCHECK_WITH_POS(gblState->parseData->modifiers.EVICTPRIORITY == ptxEVICTNORMAL_MOD ||
                          gblState->parseData->modifiers.EVICTPRIORITY == ptxEVICTLAST_MOD,
                          (ptxMsgIllegalModifier, sourcePos, get_strEVICTPRIORITY(gblState->parseData),
                           name));

#if !LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
        if (!areExtendedInstructionsEnabled(gblState->parseData)) {
            stdCHECK_WITH_POS(gblState->parseData->nrofEvictPriorityMod == gblState->parseData->nrofLevelColonMod,
                              (ptxMsgSyntaxExpected, sourcePos, ".level::eviction_priority", name));
        }
#endif

        stdCHECK_WITH_POS(!(gblState->parseData->modifiers.LEVEL && gblState->parseData->nrofLevelColonMod > 0),
                          (ptxMsgIllegalModifierWithMod, sourcePos,
                           get_strLEVEL(gblState->parseData), name, ".level::eviction_priority"));

    } else {
        stdCHECK_WITH_POS(gblState->parseData->modifiers.EVICTPRIORITY == ptxEVICTNORMAL_MOD,
                          (ptxMsgIllegalModifier, sourcePos, get_strEVICTPRIORITY(gblState->parseData),
                           name));
    }

    stdCHECK_WITH_POS((gblState->parseData->modifiers.LEVEL == ptxL2_MOD || gblState->parseData->levelColonMods[0] == ptxL2_MOD),
                      (ptxMsgModifierRequiresFeature,
                       sourcePos, get_strEVICTPRIORITY(gblState->parseData),
                       "cache level L2", name));
    stdCHECK_WITH_POS((gblState->parseData->storage[0].kind == ptxGlobalStorage ||
                       gblState->parseData->storage[0].kind == ptxGenericStorage),
                      (ptxMsgSpaceIncorrectForFeature,
                       sourcePos, feature ));
}
#endif

static Bool checkIfMultipleEvictPriorityAllowed(ptxParsingState gblState, uInt tcode, String name,
                                                msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
    if (tcode == ptx_createpolicy_range_Instr ||
        tcode == ptx_createpolicy_fractional_Instr)
    {
        return True;
    }
#endif

#if LWCFG(GLOBAL_ARCH_ADA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    if (tcode == ptx_ld_Instr || tcode == ptx_st_Instr) {
        return True;
    }
#endif

    if (gblState->parseData->nrofEvictPriorityMod > 1) {
        stdCHECK_WITH_POS(False, (ptxMsgMultipleModifiers, sourcePos, "cache eviction priority"));
    }
    return False;

}

#if LWCFG(GLOBAL_ARCH_VOLTA) && (LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71))
static void checkEVICTPRIORITYModifier(ptxParsingState gblState, ptxInstructionTemplate template, String name,
                                       msgSourcePos_t sourcePos)
{
    uInt tcode = template->code;

    stdCHECK_WITH_POS(ptxHasEVICTPRIORITY_Feature(template->features),
                      (ptxMsgIllegalModifier, sourcePos, get_EVICTPRIORITYAsString(gblState->parseData->evictPriorityMods[0]),
                       name));
    if (gblState->parseData->nrofEvictPriorityMod > 1) {
        stdCHECK_WITH_POS(ptxHasEVICTPRIORITY_Feature(template->features),
                          (ptxMsgIllegalModifier, sourcePos, get_EVICTPRIORITYAsString(gblState->parseData->evictPriorityMods[1]),
                           name));
    }

    if (!checkIfMultipleEvictPriorityAllowed(gblState, tcode, name, sourcePos)) {
        if (gblState->parseData->nrofEvictPriorityMod > 1) {
            return;
        }
        gblState->parseData->modifiers.EVICTPRIORITY = gblState->parseData->evictPriorityMods[0];
    }

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
    if (tcode == ptx_createpolicy_range_Instr ||
        tcode == ptx_createpolicy_fractional_Instr)
    {
        stdCHECK_WITH_POS(gblState->parseData->evictPriorityMods[0] == ptxEVICTFIRST_MOD ||
                          gblState->parseData->evictPriorityMods[0] == ptxEVICTUNCHANGED_MOD ||
                          gblState->parseData->evictPriorityMods[0] == ptxEVICTLAST_MOD ||
                          gblState->parseData->evictPriorityMods[0] == ptxEVICTNORMAL_MOD,
                          (ptxMsgUnsupportedModWithInfo, sourcePos,
                           get_EVICTPRIORITYAsString(gblState->parseData->evictPriorityMods[0]),
                           "as primary_priority", name));
        if (gblState->parseData->nrofEvictPriorityMod > 1) {
            stdCHECK_WITH_POS(gblState->parseData->evictPriorityMods[1] == ptxEVICTFIRST_MOD ||
                              gblState->parseData->evictPriorityMods[1] == ptxEVICTUNCHANGED_MOD,
                              (ptxMsgUnsupportedModWithInfo, sourcePos,
                               get_EVICTPRIORITYAsString(gblState->parseData->evictPriorityMods[1]),
                               "as secondary_priority", name));
            stdCHECK_WITH_POS((gblState->parseData->modifiers.LEVEL == ptxL2_MOD || gblState->parseData->levelColonMods[1] == ptxL2_MOD),
                              (ptxMsgModifierRequiresFeature,
                               sourcePos, "cache eviction priority",
                               "cache level L2", name));
        }
        gblState->parseData->modifiers.HITPRIORITY = gblState->parseData->evictPriorityMods[0];
        gblState->parseData->modifiers.MISSPRIORITY = gblState->parseData->evictPriorityMods[1];
        stdCHECK_WITH_POS((gblState->parseData->modifiers.LEVEL == ptxL2_MOD || gblState->parseData->levelColonMods[0] == ptxL2_MOD),
                          (ptxMsgModifierRequiresFeature,
                           sourcePos, "cache eviction priority",
                           "cache level L2", name));
    }
#endif

    if (tcode == ptx_prefetch_Instr || tcode == ptx_cachepolicy_Instr) {
        checkEVICTPRIORITYModOnPrefetchCachepolicy(gblState, template, name, sourcePos);
    }

    if (tcode == ptx_ld_Instr || tcode == ptx_st_Instr) {

        if (!gblState->parseData->nrofLevelColonMod && gblState->parseData->nrofEvictPriorityMod) {
            // .evict_priority modifier specified without Level:: is for L1
            gblState->parseData->modifiers.EVICTPRIORITY = gblState->parseData->evictPriorityMods[0];
        }

        for (uInt i = 0; i < gblState->parseData->nrofLevelColonMod; i++) {
            switch (gblState->parseData->levelColonMods[i]) {
            case ptxL1_MOD:
                gblState->parseData->modifiers.EVICTPRIORITY = gblState->parseData->evictPriorityMods[i];
                break;
            case ptxL2_MOD:
                gblState->parseData->modifiers.L2EVICTPRIORITY = gblState->parseData->evictPriorityMods[i];
                break;
            default:
                stdASSERT(False, ("Unexpected Level mod"));
            }
        }
        checkEVICTPRIORITYModOnLoadStore(gblState, template, name, sourcePos);
    }

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
    if (tcode == ptx_applypriority_Instr) {
        if (gblState->parseData->modifiers.EVICTPRIORITY) {
            checkEVICTPRIORITYModOnApplypriority(gblState, template, name, sourcePos);
        }
    } else if (tcode == ptx_createpolicy_range_Instr || tcode == ptx_createpolicy_fractional_Instr) {
        checkEVICTPRIORITYModOnCreatepolicy(gblState, template, name, sourcePos);
    }
#endif
}
#endif // volta, (internal || ISA_71)

static String getSymbolName(ptxExpression arg)
{
    ptxSymbolTableEntry entry;

    if (arg->kind != ptxSymbolExpression) return NULL;
    entry = arg->cases.Symbol.symbol;
    if (entry->kind != ptxVariableSymbol) return NULL;
    return entry->symbol->unMangledName;
}

static void checkXorSignModifier(ptxParsingState gblState, String name, ptxInstructionTemplate template,
                            msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_GPU_FAMILY_GA10X) && (LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_72))
    stdCHECK_WITH_POS(ptxHasXORSIGN_Feature(template->features),
                      (ptxMsgIllegalModifier, sourcePos, get_strXORSIGN(gblState->parseData), name));
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    checkFeatureVersion(gblState, 7, 0, get_strXORSIGN(gblState->parseData), sourcePos);
#else
    checkFeatureVersion(gblState, 7, 2, get_strXORSIGN(gblState->parseData), sourcePos);
    stdCHECK_WITH_POS(ptxHasABS_MOD (gblState->parseData->modifiers),
                      (ptxMsgModifierRequiresModifier, sourcePos,
                       getXORSIGNAsString(ptxXORSIGN_MOD),
                       getABSAsString(ptxABS_MOD))
    );
#endif
    stdCHECK_WITH_POS(checkTargetArch(gblState, 86),
                      (ptxMsgModifierRequiresSMVersion, sourcePos,
                       get_strXORSIGN(gblState->parseData), "sm_86"));
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                              sourcePos, get_strXORSIGN(gblState->parseData)));
#endif
}

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_62)
static void checkDuplicateAndSinkElementsIlwec(String name, ptxExpression vec,
                                               uInt argIndex,
                                               msgSourcePos_t sourcePos)
{
    stdSet_t elementSet = setNEW(String, 8);
    stdList_t element = vec->cases.Vector.elements;
    String symName;
    ptxExpression lwrElement;

    while (element) {
        lwrElement = element->head;
        if (lwrElement->kind == ptxSinkExpression) {
            stdCHECK_WITH_POS(False, (ptxMsgSinkNotAllowedAsDest,
                                      sourcePos, name));
            break;
        }
        symName = getSymbolName(lwrElement);
        if (setContains(elementSet, symName)) {
            stdCHECK_WITH_POS(False, (ptxMsgDuplicateNotAllowed,
                                      sourcePos, argIndex, name));
            break;
        }
        setInsert(elementSet, symName);
        element = element->tail;
    }
    setDelete(elementSet);
}

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_73)
static void checkAllocaSaveRestoreInstr(ptxParsingState gblState, String name, uInt tcode,
                                        msgSourcePos_t sourcePos)
{
    uInt alignment;
    // FIXME : Update version check
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    stdCHECK_WITH_POS(checkTargetArch(gblState, 50),
                      (ptxMsgSMVersionRequired, sourcePos, name, "sm_50"));
    checkFeatureVersion(gblState, 6, 4, name, sourcePos);
#else
    checkFeatureTarget(gblState, 52,   name, sourcePos);
    checkFeatureVersion(gblState, 7, 3, name, sourcePos);
#endif
    switch(tcode) {
    case ptx_alloca_Instr:
        // implicit alignment for numberofargs == 2
        if (gblState->parseData->nrofArguments == 3) {
            stdASSERT(gblState->parseData->arguments[2]->kind == ptxIntConstantExpression,
                      ("Alignment must be integer constant"));
            alignment = gblState->parseData->arguments[2]->cases.IntConstant.i;
            stdCHECK_WITH_POS((alignment > 0 && stdISPOW2((Int)alignment)),
                              (ptxMsgWrongAlignmentValue, sourcePos));
            // Max allowed alignment is 8MB (2^23)
            stdCHECK_WITH_POS(alignment <= 8388608, (ptxMsgAlignmentValueTooLarge, sourcePos));
        }
        // for internal either no instr types
        // or 1 instr type. 
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        stdASSERT(gblState->parseData->nrofInstructionTypes <= 1,
                  ("Incorrect template is matched for alloca instruction"));
        break;
#endif
        // fall through
        // for ISA_73 one instruction type. 
    case ptx_stacksave_Instr:
    case ptx_stackrestore_Instr:
        stdASSERT(gblState->parseData->nrofInstructionTypes == 1,
                  ("Incorrect template is matched for alloca, stacksave or stackrestore instruction"));
        stdCHECK_WITH_POS(isU32(gblState->parseData->instructionType[0]) || isU64(gblState->parseData->instructionType[0]),
                          (ptxMsgNonMatchingInstrTypes, sourcePos, name));
        break;
    default:
        stdASSERT(False, ("Only alloca, stacksave or stackrestore instruction is expected"));
        break;
    }
}
#endif

static void checkP2RandR2PInstr(ptxParsingState gblState, String name, uInt tcode,
                                msgSourcePos_t sourcePos)
{
    uInt mask = gblState->parseData->arguments[2]->cases.IntConstant.i;
    uInt vecIndex  = tcode == ptx_r2p_Instr ? 0 : 1;
    uInt byteIndex = tcode == ptx_r2p_Instr ? 1 : 0;

    // checks common to p2r-r2p
    if (gblState->parseData->arguments[vecIndex]->type->kind != ptxVectorType) {
        stdCHECK_WITH_POS(False, (ptxMsgVectorArgumentExpected,
                                  sourcePos, vecIndex));
        return;
    }

    stdCHECK_WITH_POS(gblState->parseData->arguments[byteIndex]->kind == ptxByteSelectExpression,
                      (ptxMsgByteSelectorRequired, sourcePos, byteIndex, name));

    stdCHECK_WITH_POS((mask && mask < 128), (ptxMsgMaskSizeIncorrect,
                                             sourcePos, 2, name));
    stdCHECK_WITH_POS(stdNrofBits32(mask) == gblState->parseData->arguments[vecIndex]->type->cases.Vector.N,
                      (ptxMsgVectorSizeNotEqualToMask,
                       sourcePos, vecIndex, name));

    // Instruction specific checks
    switch (tcode) {
    case ptx_p2r_Instr:
    // we are already reporting error if sink '_' is used as a source argument
        break;
    case ptx_r2p_Instr:
        checkDuplicateAndSinkElementsIlwec(name, gblState->parseData->arguments[0], 0,  sourcePos);
        break;
    default:
        stdASSERT(False, ("p2r or r2p instruction is expected"));
        break;
    }

}
#endif

static void checkEx2Instr(ptxParsingState gblState, ptxInstructionTemplate template, String name,
                          msgSourcePos_t sourcePos)
{
    if (isBF16(gblState->parseData->instructionType[0]) ||
        isBF16x2(gblState->parseData->instructionType[0])) {
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_FUTURE)
        String instrWithType;
        stdCHECK_WITH_POS(gblState->parseData->nrofInstructionTypes == 1,
                          (ptxMsgNonMatchingInstrTypes, sourcePos, name));

        instrWithType = stdCONCATSTRING(name,
                                        getTYPEAsString(gblState->parseData->deobfuscatedStringMapPtr,
                                                        gblState->parseData->instructionType[0]));
        // FIXME: update version check
        checkFeatureTarget(gblState, 90, instrWithType, sourcePos);
        checkFeatureVersion(gblState, 7, 4, instrWithType, sourcePos);

        stdCHECK_WITH_POS(gblState->parseData->modifiers.APRX,
                          (ptxMsgModifierRequired, sourcePos,
                           getAPRXAsString(ptxAPRX_MOD), name));
        checkInstructionArgsForBF16(gblState, template, name, 0,
                                    gblState->parseData->nrofArguments,
                                    gblState->parseData->arguments, sourcePos);
#else
        stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrTypes, sourcePos, name));
#endif // HOPPER && FUTURE
    } else if (isF16(gblState->parseData->instructionType[0]) ||
               isF16x2(gblState->parseData->instructionType[0])) {
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
        stdCHECK_WITH_POS(checkTargetArch(gblState, minTuringArch),
                (ptxMsgFeatureRequiresSMVersion, sourcePos,
                 "ex2.f16/f16x2", minTuringArchStr));
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        // FIXME : Update version check
        checkFeatureVersion(gblState, 6, 0, "ex2.f16/f16x2", sourcePos);
#else
        if (areExtendedInstructionsEnabled(gblState->parseData)) {
            checkFeatureVersion(gblState, 6, 5, "ex2.f16/f16x2", sourcePos);
        } else {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
            checkFeatureVersion(gblState, 7, 0, "ex2.f16/f16x2", sourcePos);
#else
            stdCHECK_WITH_POS(False, (ptxMsgIllegalType, sourcePos,name));
            return;
#endif
        }
#endif //Internal

        // For f16 variants, extended version supports approx while INTERNAL
        // version requires .rz.
        // Internal builds will support both but builds with extended only should
        // support only extended version

        // TODO: Once internal version is removed, no longer required to have these checks
        // explicit checks as templates should error out correctly
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        // Support both .rz variant and .approx variant
        if (gblState->parseData->modifiers.ROUND) {
            stdCHECK_WITH_POS(gblState->parseData->modifiers.ROUND == ptxRZ_MOD,
                              (ptxMsgIllegalRoundingModifier, sourcePos, name));
            stdCHECK_WITH_POS(!gblState->parseData->modifiers.APRX, (ptxMsgIllegalModifier, sourcePos,
                                                getAPRXAsString(ptxAPRX_MOD), name));
        } else
#endif // LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
        if (True) {
#else
        if (areExtendedInstructionsEnabled(gblState->parseData)) {
#endif
            // extended only version, requiring .approx
            stdCHECK_WITH_POS(gblState->parseData->modifiers.APRX, (ptxMsgModifierRequired, sourcePos,
                                                getAPRXAsString(ptxAPRX_MOD), name));
            stdCHECK_WITH_POS(!gblState->parseData->modifiers.FTZ, (ptxMsgIllegalModifier, sourcePos,
                                                getFTZAsString(ptxFTZ_MOD), name));
            stdCHECK_WITH_POS(!gblState->parseData->modifiers.ROUND, (ptxMsgIllegalModifier, sourcePos, "rounding", name));
        } else {
            stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrTypes, sourcePos,
                                        "ex2"));
        }
#endif // LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
    } else if (isF32(gblState->parseData->instructionType[0])) {
        stdCHECK_WITH_POS(gblState->parseData->modifiers.APRX, (ptxMsgModifierRequired, sourcePos,
                                           getAPRXAsString(ptxAPRX_MOD), name));
    } else if (gblState->parseData->nrofInstructionTypes != 1) {
        // Exactly one type is expected for ex2
        stdCHECK_WITH_POS(False,
                          (ptxMsgNonMatchingInstrTypes, sourcePos, name));
    }
}

static Bool isVariableSizeVecAllowed(uInt tcode, uInt N) {

    // Instructions are identified using string comparison instead of tcode to
    // prevent instruction template generation with incorrect argument vector size

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_62)
    if (tcode == ptx_p2r_Instr || tcode == ptx_r2p_Instr) {
    // Allow vector of any size less than 8 for instructions P2R & R2P
        return N < 8;
    }
#endif

#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    if (tcode == ptx__mma_Instr || ptxIsWMMAInstr(tcode)
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_64)
        || tcode == ptx_mma_Instr
#endif
       )
    {
    // Allow vector of size 8 for _mma/wmma* instructions only
        return N == 8;
    }
#endif

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    if (tcode == ptx__mma_warpgroup_Instr)
        return True;
    if (tcode == ptx_cp_async_bulk_tensor_Instr ||
        tcode == ptx_cp_reduce_async_bulk_tensor_Instr)
    {
        return (1 <= N && N <= 5);
    }
#endif // HOPPER && INTERNAL

#if LWCFG(GLOBAL_ARCH_ADA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    if (tcode == ptx_ld_Instr || tcode == ptx_st_Instr)
        return N == 8;
#endif // ada, internal
    return False;
}

static Bool isSinkAllowedForSrc(uInt tcode, ptxModifier modifiers)
{
#if LWCFG(GLOBAL_ARCH_ADA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    return tcode == ptx_st_Instr && modifiers.VECTOR == ptxV8_MOD;
#else
    return False;
#endif // ada,internal
}

static void checkForSinkAtSrc(uInt tcode, cString name, ptxExpression argument,
                              ptxModifier modifiers, msgSourcePos_t sourcePos)
{
    Bool hasSinkAtSrc = False;
    stdASSERT(argument, (""));

    if (argument->kind == ptxVectorExpression) {
        listTraverse(argument->cases.Vector.elements, (stdEltFun)checkSink, &hasSinkAtSrc);
    } else {
        checkSink(argument, &hasSinkAtSrc);
    }
    stdCHECK_WITH_POS(stdIMPLIES(hasSinkAtSrc, isSinkAllowedForSrc(tcode, modifiers)),
                      (ptxMsgSinkNotAllowedAsSource,sourcePos));
}

static void checkForSinkAtDest(ptxParsingState gblState, uInt tcode, cString name, ptxExpression argument,
                               ptxModifier modifiers,msgSourcePos_t sourcePos)
{
    Bool hasSinkAtDest = False;
    switch(tcode) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    case ptx_bar_scan_Instr:
#endif
    case ptx_atom_Instr:
    case ptx_red_Instr:
    case ptx_setp_Instr:
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_FUTURE)
    case ptx_elect_one_Instr:
#endif
        return;
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    case ptx_mbarrier_arrive_drop_Instr:
        return;
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
        // error on 7.0 only as before that the instruction is not supported,
        // and from 7.1 sink symbol is supported
    case ptx_mbarrier_arrive_Instr:
        if (ptxVersionAtLeast(7, 1, gblState)) {
            return;
        }
        // error if sink at dest
        break;
#endif
#endif
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    case ptx_mbarrier_arrive_expect_copy_Instr:
    case ptx_mbarrier_arrive_drop_expect_copy_Instr:
    case ptx_mbarrier_arrive_expect_tx_Instr:
    case ptx_mbarrier_arrive_drop_expect_tx_Instr:
        return;
#endif
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    case ptx_match_Instr:
    case ptx__match_Instr:
        if (modifiers.VOTE == ptxVALL_MOD) {
            return;
        }
        // error if sink at dest
        break;
#endif
#if LWCFG(GLOBAL_ARCH_ADA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    case ptx_ld_Instr:
        if (modifiers.VECTOR == ptxV8_MOD) {
            break;
        }
#endif // ada, internal
    default:
        break;
    }
    checkSink(argument, &hasSinkAtDest);
    stdCHECK_WITH_POS(!hasSinkAtDest, (ptxMsgSinkButNoResult,sourcePos,name));
}


static void setDefaultFtzForSm1x(ptxParsingState gblState, uInt tcode, ptxInstructionTemplate template,
                                 msgSourcePos_t sourcePos)
{
    if (checkTargetArch(gblState, 20)) return;

    if (!ptxHasFTZ_Feature(template->features)) return;

    if (gblState->parseData->modifiers.FTZ) return;

    // FIXME: The two "if" expressions that follow are diffilwlt to
    // read through. This should be refactored for readability.

    // cvt requires special handling
    // rcp.approx.ftz.f64 is not supported for sm_1x and requires explicit .ftz for sm_2x.
    // rsqrt.approx.ftz.f64 is not supported for sm_1x and requires explicit .ftz for sm_2x.
    if ( ! ( (tcode==ptx_cvt_Instr) ||
             (tcode==ptx_rcp_Instr && isF64(gblState->parseData->instructionType[0])) ||
             (tcode==ptx_rsqrt_Instr && isF64(gblState->parseData->instructionType[0]) && gblState->parseData->modifiers.APRX))) {
        setFtzModifier(gblState, ptxFTZ_MOD, sourcePos);
    }
    if ( tcode==ptx_cvt_Instr && (isF32(gblState->parseData->instructionType[0]) || isF32(gblState->parseData->instructionType[1])) ) {
        // set .ftz if PTX version 1.5 or later, or if version 1.0-1.4 AND neither src/dst type is 64-bit
        if (ptxVersionAtLeast(1,5, gblState) || (ptxGetTypeSizeInBytes(gblState->parseData->instructionType[0]) != 8 && ptxGetTypeSizeInBytes(gblState->parseData->instructionType[1]) != 8) ) {
            setFtzModifier(gblState, ptxFTZ_MOD, sourcePos);
        }
    }
}

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_75)
static void checkProxyKindModifier(ptxParsingState gblState, uInt tcode, cString name,
                                   ptxInstructionTemplate template,
                                   msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(ptxHasPROXYKIND_Feature(template->features),
                      (ptxMsgIllegalModifier, sourcePos, get_strPROXYKIND(gblState->parseData), name));
}
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
static void checkCacheHintModifier(ptxParsingState gblState, uInt tcode, cString name,
                                   ptxInstructionTemplate template,
                                   msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(ptxHasCACHEHINT_Feature(template->features),
                      (ptxMsgIllegalModifier, sourcePos, get_strCACHEHINT(gblState->parseData), name));
    stdCHECK_WITH_POS(checkTargetArch(gblState, 80),
                      (ptxMsgModifierRequiresSMVersion, sourcePos,
                       get_strCACHEHINT(gblState->parseData), "sm_80"));
    stdCHECK_WITH_POS(checkFeatureVersion1(gblState, 7, 4),
                      (ptxMsgModifierRequiresPTXVersion, sourcePos,
                       get_strCACHEHINT(gblState->parseData), "7.4"));
    stdCHECK_WITH_POS((gblState->parseData->modifiers.ORDER != ptxVOLATILE_MOD),
                      (ptxMsgIllegalModifierPair, sourcePos, get_strCACHEHINT(gblState->parseData), get_strORDER(gblState->parseData)));
}

static void checkStateSpaceForCacheHint(ptxParsingState gblState, uInt tcode, cString name,
                                        uInt nrofInstrMemspace,
                                        ptxStorageClass storage[ptxMAX_INSTR_MEMSPACE],
                                        msgSourcePos_t sourcePos)
{
    Bool isValidStateSpace = False;
    ptxStorageKind kind1 = storage[0].kind;
    ptxStorageKind kind2 = storage[1].kind;

    switch (tcode) {
    case ptx_ld_Instr:
    case ptx_st_Instr:
    case ptx_atom_Instr:
    case ptx_red_Instr:
        isValidStateSpace = (kind1 == ptxGlobalStorage ||
                             kind1 == ptxGenericStorage);
        break;
    case ptx_cp_async_Instr:
        isValidStateSpace = (kind1 == ptxSharedStorage &&
                             kind2 == ptxGlobalStorage);
        break;
    default:
        break;
    }

    stdCHECK_WITH_POS(isValidStateSpace,
                      (ptxMsgModIlwalidWithStateSpace, sourcePos, get_strCACHEHINT(gblState->parseData),
                       get_strSTORAGE(gblState->parseData), name));
}
#endif

static void checkStateSpaceForMemDesc(ptxParsingState gblState, uInt tcode, cString name,
                                      uInt nrofInstrMemspace,
                                      ptxStorageClass storage[ptxMAX_INSTR_MEMSPACE],
                                      msgSourcePos_t sourcePos)
{
    Bool isValidStateSpace = False;
    ptxStorageKind kind1 = storage[0].kind;
    ptxStorageKind kind2 = storage[1].kind;

    switch (tcode) {
    case ptx_ld_Instr:
    case ptx_st_Instr:
    case ptx_atom_Instr:
    case ptx_red_Instr:
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    case ptx_wmma_load_a_Instr:
    case ptx_wmma_load_b_Instr:
    case ptx_wmma_load_c_Instr:
    case ptx_wmma_store_d_Instr:
#endif
        isValidStateSpace = (kind1 == ptxGlobalStorage ||
                             kind1 == ptxGenericStorage);
        break;
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
    case ptx_cp_async_Instr:
        isValidStateSpace = (kind1 == ptxSharedStorage &&
                             kind2 == ptxGlobalStorage);
        break;
#endif
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    case ptx_cp_async_bulk_Instr:
    case ptx_cp_async_bulk_tensor_Instr:
    case ptx_cp_reduce_async_bulk_tensor_Instr:
    case ptx_cp_reduce_async_bulk_Instr:
        // Checking state space of instruction cp{.reduce}.async.bulk.tensor and cp{.reduce}.async.bulk
        // will be done separately in functions checkStateSpaceForTensorCopyInstruction
        // and checkStateSpaceForBulkCopyInstruction respectively
        isValidStateSpace = True;
        break;
#endif // HOPPER && INTERNAL
    default:
        break;
    }

    stdCHECK_WITH_POS(isValidStateSpace,
                      (ptxMsgModIlwalidWithStateSpace, sourcePos, get_strDESC(gblState->parseData),
                       get_strSTORAGE(gblState->parseData), name));
}

static Bool useLenientCheckForDesc(ptxParsingState gblState, uInt tcode)
{
    // For ld/st/atom/red/cp.async instructions templates for .desc
    // and .L2::cachehint are same which can't be distinguised in
    // template matching. Hence do lenient check for those
    // Also cp.async has the following 2 templates:
    // 1. DEFINE( , cp, MMLw, ...      , ..)
    // 2. DEFINE( , cp, MMLW, ...|DESC , ..)
    // which template matching will not be able to distinguish.
    // So be lenient while checking desc-feature <==> desc-modifier
    // for the above case.
    // Similarly for wmma.load/store with ldm argument.
    // A strict check is handled in:
    //  * checkArgsForCopyInstr(gblState) for cp
    //  * checkArgsForLdStInstr(gblState) for ld/st
    //  * checkArgsForAtomRedInstr(gblState) for atom/red
    //  * checkDescArgForWMMALoadStore(gblState) for wmma.load/store

#if LWCFG(GLOBAL_ARCH_AMPERE) && (LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71))
    if ((tcode == ptx_cp_async_Instr && (gblState->parseData->nrofArguments == 4 || gblState->parseData->nrofArguments == 5)) ||
        (tcode == ptx_ld_Instr && gblState->parseData->nrofArguments == 3) ||
        (tcode == ptx_st_Instr && gblState->parseData->nrofArguments == 3) ||
        (tcode == ptx_atom_Instr && gblState->parseData->nrofArguments == 4) ||
        (tcode == ptx_red_Instr && gblState->parseData->nrofArguments == 3))
     {
        return True;
     }
#endif

#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    if (tcode == ptx_wmma_load_a_Instr ||
        tcode == ptx_wmma_load_b_Instr ||
        tcode == ptx_wmma_load_c_Instr ||
        tcode == ptx_wmma_store_d_Instr)
    {
        return gblState->parseData->nrofArguments == 3;
    }
#endif

    return False;
}

static void checkForNonSyncDeprecation(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    // FIXME: For macro expanded instructions, skip these checks. For macro
    //        expanded instructions, checkTargetArch always return True irrespective
    //        of .target. 
    //        This should be okay as instructions used in macros are internally
    //        controlled so should be fine.

    if (ptxIsExpandedInternally(gblState->lwrInstrSrc)) return;

    if (ptxHasSYNC_MOD(gblState->parseData->modifiers)) return;

    // Complete silence for vote.ballot on .version 6.0 and 6.1 as these were
    // used for __activemask() in LWCA
    if (ptxVersionAtLeast(6, 0, gblState)
        && !ptxVersionAtLeast(6, 2, gblState)
        && gblState->parseData->modifiers.VOTE == ptxBALLOT_MOD)
    {
        return;
    }

    // TODO: Add a check for some future PTX version (co-ordinated
    // with LWCA) where a non-sync instruction is always a syntax
    // error, even with legacy .target.

#if LWCFG(GLOBAL_ARCH_VOLTA)
    // Issue error when encounted non-sync instructions 6.4+ and .target sm_70+
    if (checkTargetArch(gblState, 70)) {
        if (!gblState->allowNonSyncInstrs && ptxVersionAtLeast(6, 4, gblState)) {
            stdCHECK_WITH_POS(False, (ptxMsgNonSynlwnsupportedError, sourcePos, name));
            return;
        }
    }

    // For any compilations for Volta+, issue warning about unpredictable
    // outcome for non-sync instructions
    if (checkCompilationArch(gblState, 70)) {
        /* Short term WAR : in JIT path, the non-sync warning is emitted only once.
           The bug 2843594 tracks an app which runs into OOM as there are around ~30k
           instance of non-sync shfl instruction warnings.
           Bug 200597719 tracks the clean fix for high memory usage for emitting a
           warning in JIT path.
           Note: this is not needed in offline path, as the warnings/errors are simply
           redirected to stdout/stderr without keeping track of all the warnings/errors
           seen so far unlike the JIT path.
         */
        if (stdIMPLIES(emitNoSyncWarningOnce, !gblState->parseData->noSyncWarningEmitted)) {
            stdCHECK_WITH_POS(False, (ptxMsgWarnNonSyncOutcome, sourcePos, name, "sm_70"));
        }
        gblState->parseData->noSyncWarningEmitted = True;
    }
#endif

    // Issue deprecation warning for non-sync instructions in PTX 6.0+
    if (ptxVersionAtLeast(6, 0, gblState)) {
        stdCHECK_WITH_POS(False, (ptxMsgNonSyncDeprecated, sourcePos, name));
    }
}

static int getBarrierNumberArgIdx(uInt tcode)
{
    switch(tcode) {
    case ptx_barrier_Instr:
    case ptx_bar_Instr:
    case ptx_barrier_arrive_Instr:
    case ptx_bar_arrive_Instr:
        return 0;
    case ptx_barrier_red_Instr:
    case ptx_bar_red_Instr:
        return 1;
    default:
        stdASSERT(False, ("Barrier instruction expected"));
    }
    return -1;
}

static void checkBarrierNumber(ptxParsingState gblState, uInt tcode, msgSourcePos_t sourcePos)
{
    int argIdx = getBarrierNumberArgIdx(tcode);
    ptxExpression arg = gblState->parseData->arguments[argIdx];

    if (!ptxIsImmediateExpr(arg)) {
        return;
    }
    int val = arg->cases.IntConstant.i;
    stdCHECK_WITH_POS((0 <= val && val <= 15),
                      (ptxMsgBarrierNumOutOfRange, sourcePos, val));
}

static int getBarrierThreadCountArgIdx(ptxParsingState gblState, uInt tcode)
{
    switch(tcode) {
    case ptx_barrier_Instr:
    case ptx_bar_Instr:
    case ptx_barrier_arrive_Instr:
    case ptx_bar_arrive_Instr:
        if (gblState->parseData->nrofArguments == 2) {
            return 1;
        }
        return -1;
    case ptx_barrier_red_Instr:
    case ptx_bar_red_Instr:
        if (gblState->parseData->nrofArguments == 4) {
            return 2;
        }
        return -1;
    default:
        stdASSERT(False, ("Barrier instruction expected"));
    }
    return -1;
}

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkSHAREDSCOPEModifier(ptxParsingState gblState, String name, uInt tcode, uInt mod,
                                     ptxInstructionTemplate template,
                                     msgSourcePos_t sourcePos)
{
    checkFeatureTarget(gblState, 90, get_strSHAREDSCOPE(gblState->parseData), sourcePos);
    checkFeatureVersion(gblState, 7, 2, get_strSHAREDSCOPE(gblState->parseData), sourcePos);

    if (!stdIMPLIES(ptxHasSHAREDSCOPE_MOD(gblState->parseData->modifiers),
                    ptxHasSHAREDSCOPE_Feature(template->features)))
    {
        stdCHECK_WITH_POS(False, (ptxMsgIllegalModifier, sourcePos,
                                  get_strSHAREDSCOPE(gblState->parseData), name));
        return;
    }

    stdCHECK_WITH_POS(gblState->parseData->storage[0].kind == ptxSharedStorage,
                      (ptxMsgModRequiresStateSpace, sourcePos, get_strSHAREDSCOPE(gblState->parseData),
                       ".shared", name));
}
#endif

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkMULTICASTModifier(ptxParsingState gblState, String name, uInt tcode,
                                   ptxInstructionTemplate template,
                                   msgSourcePos_t sourcePos)
{
    checkFeatureTarget(gblState, 90, get_strMULTICAST(gblState->parseData), sourcePos);
    checkFeatureVersion(gblState, 7, 2, get_strMULTICAST(gblState->parseData), sourcePos);

    if (!stdIMPLIES(ptxHasMULTICAST_MOD(gblState->parseData->modifiers),
                    ptxHasMULTICAST_Feature(template->features)))
    {
        stdCHECK_WITH_POS(False, (ptxMsgIllegalModifier, sourcePos,
                                  get_strMULTICAST(gblState->parseData), name));
        return;
    }
}
#endif

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkMBARRIERModifier(ptxParsingState gblState, String name, uInt tcode,
                                  ptxInstructionTemplate template,
                                  msgSourcePos_t sourcePos)
{
    /* Note that .mbarrier is allowed on instructions even when arch <= sm_90
     * (eg: cp.async.mbarrier.arrive). But for such cases, detect it as part of
     * instruction name itself. Only for cp.async.tensor, we detect as modifier.
     */

    checkFeatureTarget(gblState, 90, get_strMBARRIER(gblState->parseData), sourcePos);
    checkFeatureVersion(gblState, 7, 2, get_strMBARRIER(gblState->parseData), sourcePos);

    if (!stdIMPLIES(ptxHasMBARRIER_MOD(gblState->parseData->modifiers),
                    ptxHasMBARRIER_Feature(template->features)))
    {
        stdCHECK_WITH_POS(False, (ptxMsgIllegalModifier, sourcePos,
                                  get_strMBARRIER(gblState->parseData), name));
        return;
    }
}
#endif

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkIM2COLModifier(ptxParsingState gblState, String name, uInt tcode,
                                ptxInstructionTemplate template,
                                msgSourcePos_t sourcePos)
{
    checkFeatureTarget(gblState, 90, get_strIM2COL(gblState->parseData), sourcePos);
    checkFeatureVersion(gblState, 7, 2, get_strIM2COL(gblState->parseData), sourcePos);

    if (!stdIMPLIES(ptxHasIM2COL_MOD(gblState->parseData->modifiers),
                    ptxHasIM2COL_Feature(template->features)))
    {
        stdCHECK_WITH_POS(False, (ptxMsgIllegalModifier, sourcePos,
                                  get_strIM2COL(gblState->parseData), name));
        return;
    }
}
#endif

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
static void checkPACKEDOFFModifier(ptxParsingState gblState, String name, uInt tcode,
                                   ptxInstructionTemplate template,
                                   msgSourcePos_t sourcePos)
{
    checkFeatureTarget(gblState, 90, get_strPACKEDOFF(gblState->parseData), sourcePos);
    checkFeatureVersion(gblState, 7, 2, get_strPACKEDOFF(gblState->parseData), sourcePos);

    if (!stdIMPLIES(ptxHasPACKEDOFF_MOD(gblState->parseData->modifiers),
                    ptxHasPACKEDOFF_Feature(template->features)))
    {
        stdCHECK_WITH_POS(False, (ptxMsgIllegalModifier, sourcePos,
                                  get_strPACKEDOFF(gblState->parseData), name));
        return;
    }
}
#endif

static void restrictU16VectorArgToSpecificInstr(uInt tcode, cString name,
                                                ptxInstructionTemplate template,
                                                uInt argNum, ptxExpression argument,
                                                msgSourcePos_t sourcePos)
{
    if (!argument->type || argument->type->kind != ptxVectorType
        || argument->kind == ptxSinkExpression) {
        return;
    }

    if (!isU16(argument->type->cases.Vector.base)) {
        return;
    }

    if (template->argType[argNum] == ptxFollowAType) {
        return;
    }

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    // U16 vector requires tcode == cp_async_bulk_tensor
    stdCHECK_WITH_POS((tcode == ptx_cp_async_bulk_tensor_Instr ||
                       tcode == ptx_cp_reduce_async_bulk_tensor_Instr),
                      (ptxMsgVectorArgumentNotExpected, sourcePos, argNum, name));
#endif // HOPPER && INTERNAL
}

static void checkBarrierThreadCount(ptxParsingState gblState, uInt tcode, msgSourcePos_t sourcePos)
{
    int argIdx = getBarrierThreadCountArgIdx(gblState, tcode);
    if (argIdx == -1) {
        return;
    }

    ptxExpression arg = gblState->parseData->arguments[argIdx];
    if (!ptxIsImmediateExpr(arg)) {
        return;
    }
    int val = arg->cases.IntConstant.i;
    stdCHECK_WITH_POS(!(val % WARP_SIZE), (ptxMsgBarrierThreadCntNotAllowed, sourcePos));
}

static void specializeDimModForInstr(ptxParsingState gblState, String name,
                                     ptxInstructionTemplate template,
                                     msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(ptxHasTEXMOD_Feature(template->features) ||
                      ptxHasTENSORDIM_Feature(template->features),
                      (ptxMsgIllegalModifier, sourcePos, "dimension", name));

    stdASSERT(ptxHasTEXMOD_Feature(template->features) ^
              ptxHasTENSORDIM_Feature(template->features),
              ("Clashing combination of instruction features."));

    if (ptxHasTEXMOD_Feature(template->features)) {
        stdASSERT(gblState->parseData->modifiers.DIM <= ptx3D_MOD, ("Unexpected number of dimensions"));
        setTextureModifier(gblState, gblState->parseData->modifiers.DIM, sourcePos);
    }

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    if (ptxHasTENSORDIM_Feature(template->features)) {
        setTensorDimModifier(gblState, gblState->parseData->modifiers.DIM, sourcePos);
    }
#endif // HOPPER && INTERNAL
}

/*
 * pre-process arguments:
 * - promote source predicate operands to PredicateExpressions
 * - colwert optional operand negations into negAB or negC modifier
 * - check for illegal combinations
 */
static void preprocessArguments(ptxParsingState gblState, String name, msgSourcePos_t sourcePos)
{
    int i;
    Bool negAB = False, negC = False;

    uInt tcode = ptxGetInstructionOpcode(gblState->parseData, name);

    for (i=0; i<gblState->parseData->nrofArguments; i++) {
        ptxExpression arg = gblState->parseData->arguments[i];

        if (i>0 && isPRED(arg->type) && arg->kind == ptxSymbolExpression) {
            gblState->parseData->arguments[i] = ptxCreatePredicateExpr(False, arg, gblState);
        }
        if (arg->kind == ptxUnaryExpression && arg->cases.Unary->op == ptxSUBOp) {
            switch (i) {
            case 1: negAB = True;          break;
            case 2: negAB = negAB ^ True;  break;
            case 3: negC  = True;          break;
            default:
                stdCHECK_WITH_POS( False, (ptxMsgIllegalMinusCombination,sourcePos) );  // illegal position
                break;
            }
            gblState->parseData->arguments[i] = arg->cases.Unary->arg;
        }
        if (arg->kind == ptxVectorExpression) {
            Int N = arg->type->cases.Vector.N;
            Bool allowVarSizeVec = False;

            allowVarSizeVec = isVariableSizeVecAllowed(tcode, N);

            if (!(N == 1 || N == 2 || N == 4 || allowVarSizeVec)) {
                stdCHECK_WITH_POS(False, (ptxMsgIllegalVectorSize, sourcePos, N));
            }

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_64)
            if (arg->cases.Vector.reverseMod) {
                Bool allowReverseModifier;
                stdCHECK_WITH_POS(checkFeatureVersion1(gblState, 6, 4),
                                  (ptxMsgModifierRequiresPTXVersion, sourcePos,
                                   ".reverse", "6.4"));
                stdCHECK_WITH_POS(checkTargetArch(gblState, 50),
                                  (ptxMsgModifierRequiresSMVersion, sourcePos,
                                   ".reverse", "sm_50"));

                allowReverseModifier = (tcode == ptx_p2r_Instr ||
                                        tcode == ptx_r2p_Instr);

                stdCHECK_WITH_POS(allowReverseModifier,
                                  (ptxMsgIllegalModifier, sourcePos, ".reverse", name));

                if (allowReverseModifier) {
                    arg->cases.Vector.elements = listReverse(arg->cases.Vector.elements);
                }
            }
#endif
        }

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_62)
        // TODO: recognize all selectors as byteSelectors and only for video
        //       instruction colwert them into video selectors
        if (arg->kind == ptxVideoSelectExpression) {
            if ((tcode == ptx_p2r_Instr && i == 0) ||
                (tcode == ptx_r2p_Instr && i == 1)) {
                arg->kind = ptxByteSelectExpression;
                arg->cases.ByteSelect->arg = arg->cases.VideoSelect->arg;
                arg->cases.ByteSelect->N   = arg->cases.VideoSelect->N;
                colwertVideoToByteSelectorForP2RandR2P(arg, i, name, sourcePos);
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
            } else if ((tcode == ptx_spmetadata_Instr && i == 1) ||
                       (tcode == ptx_gather_Instr     && i <= 1)) {
                uInt N = arg->cases.VideoSelect->N;
                ptxExpression varg = arg->cases.VideoSelect->arg;
                uInt selector = colwertVideoToByteSelectorForAmpereInstr(arg);
                if (N == 1 && selector != ptxBYTE_NONE) {
                    arg->kind = ptxByteSelectExpression;
                    arg->cases.ByteSelect->arg = varg;
                    arg->cases.ByteSelect->N   = N;
                    arg->cases.ByteSelect->selector[0] = selector;
                }
#endif
            }
        }
#endif

    }
    stdCHECK_WITH_POS( !(negAB && negC), (ptxMsgIllegalMinusCombination,sourcePos) ) {
        if (negAB) { setVmadModifier(gblState, ptxVMAD_NEG_AB_MOD, sourcePos); }
        if (negC)  { setVmadModifier(gblState, ptxVMAD_NEG_C_MOD,  sourcePos); }
    }

    // handle case of moving address of symbol into register.  The other case of "mov,sym+int;" is handled in handleAddition
    if (tcode == ptx_mov_Instr && gblState->parseData->nrofArguments > 1) {
        ptxExpression arg = gblState->parseData->arguments[1];

        checkAddressableParam(gblState, arg,gblState->parseData->lwrFunc,sourcePos);
        checkAddressableFunc(gblState, arg,sourcePos);
        checkValidInstrTypeForFuncAddr(gblState, arg,name,sourcePos);
        checkMovTexOrSurf(gblState, arg,gblState->parseData->instructionType[0],name,sourcePos);

        gblState->parseData->arguments[1] = createAddressOfExpr(gblState, arg);
    } else if (tcode == ptx_cvta_Instr && gblState->parseData->nrofArguments > 1) {
        // handle case of colwerting address of symbol into a generic address.
        checkAddressableParam(gblState, gblState->parseData->arguments[1],gblState->parseData->lwrFunc,sourcePos);
        gblState->parseData->arguments[1] = createAddressOfExpr(gblState, gblState->parseData->arguments[1]);
    } else if ((tcode == ptx_ld_Instr || tcode == ptx_ldu_Instr) && gblState->parseData->nrofArguments > 1) {
        // handle case of array index expression used in LD instruction.
        // Colwert this to AddressRefExpr with arrayIndex as AddressOfExpr
        if (gblState->parseData->arguments[1]->kind == ptxArrayIndexExpression) {
            gblState->parseData->arguments[1] = createAddressRefExpr(createAddressOfExpr(gblState, gblState->parseData->arguments[1]),sourcePos);
        }
    } else if (tcode == ptx_st_Instr && gblState->parseData->nrofArguments > 0) {
        // handle case of array index expression used in ST instruction.
        // Colwert this to AddressRefExpr with arrayIndex as AddressOfExpr
        if (gblState->parseData->arguments[0]->kind == ptxArrayIndexExpression) {
            gblState->parseData->arguments[0] = createAddressRefExpr(createAddressOfExpr(gblState, gblState->parseData->arguments[0]),sourcePos);
        }
    } else if (tcode == ptx_call_Instr && !isDirectCall(gblState->parseData->arguments, gblState->parseData->nrofArguments)) {
        // handle case of call with unresolved labelref as last argument by trying to resolve arg to a label symbol expr.
        // - last arg may be the label of a .calltargets, or .callprototype directive.
        // - such labels must precede the call, but may be in an outer scope and therefore need ptxLookupSymbol to search parent symtabs.
        // - forward references are illegal, but these will remain as label refs and fail to match the instruction template's arg type.
        ptxExpression arg = gblState->parseData->arguments[gblState->parseData->nrofArguments-1];
        if ( arg->kind == ptxLabelReferenceExpression ) {
            String name = arg->cases.LabelReference->name;
            ptxSymbolTableEntry entry = ptxLookupSymbol(gblState->lwrSymbolTable, name, True, gblState );
            stdCHECK_WITH_POS(entry, (ptxMsgUnknownSymbol, sourcePos, name)) {
                gblState->parseData->arguments[gblState->parseData->nrofArguments-1] = ptxCreateSymbolExpr(entry);
            }
        }
    }
}

static void checkArguments(ptxParsingState gblState, uInt tcode, String name, ptxInstructionTemplate template,
                            msgSourcePos_t sourcePos)
{
    uInt i;
    ptxExpression arg;

    if (gblState->parseData->nrofArguments == 0) return;

    for (i = 0; i < gblState->parseData->nrofArguments; i++) {
        arg = gblState->parseData->arguments[i];
        if (template->argType[i] == ptxImageAType || template->argType[i] == ptxMemoryAType) {
            int storageIndex = ptxGetStorageIndex(tcode, i, gblState->parseData->nrofInstrMemspace);
            ptxStorageKind kind = gblState->parseData->storage[storageIndex].kind;
            checkAddressExpr(gblState, arg, kind, tcode, sourcePos);
            checkStateSpaceConsistency(template, arg, kind, sourcePos);
        }

        if (i == 0) {
            checkForSinkAtDest(gblState, tcode, name, arg, gblState->parseData->modifiers, sourcePos);
        } else {
            checkForSinkAtSrc(tcode, name, arg, gblState->parseData->modifiers, sourcePos);
        }
        // check SREG usage
        if (ptxGetStorageKind(arg) == ptxSregStorage) {
            stdCHECK_WITH_POS(ptxHasSREGARG_Feature(template->features), (ptxMsgSRegArgNotAllowed,sourcePos,name) ) {
                stdCHECK_WITH_POS( stdIMPLIES( i==0, isWritableSreg(arg) ), (ptxMsgSRegReadOnly,sourcePos) );
            }
        }

        restrictU16VectorArgToSpecificInstr(tcode, name, template, i, arg, sourcePos);
    }
}

// TODO: Update templates and implementation of all existing instructions to not use 'type - modifiers'
//       Remove this functions when all instructions started using only instructionTypes.
static Bool isTypeModToTypeColwersionRequired(ptxParsingState gblState, String name)
{
    uInt tcode = ptxGetInstructionOpcode(gblState->parseData, name);
    switch (tcode) {
    case ptx_gather_Instr:
    case ptx_add_Instr:
    case ptx_sub_Instr:
    case ptx_mul_Instr:
    case ptx_set_Instr:
    case ptx_setp_Instr:
    case ptx_tanh_Instr:
    case ptx_ex2_Instr:
    case ptx_sin_Instr:
    case ptx_cos_Instr:
    case ptx_lg2_Instr:
    case ptx_sqrt_Instr:
    case ptx_rsqrt_Instr:
    case ptx_rcp_Instr:
    case ptx_atom_Instr:
    case ptx_red_Instr:
        return True;
    default:
        return False;
    }
}

// TODO: Remove this functions when all instructions started using only instructionTypes and create corresponding
//         instructionTypes directly from parser rules.
static void colwertTypeModIntoInstrTypes(int nrofTypeMod, uInt typeMod[ptxMAX_INSTR_ARGS],
                                         uInt *nrofInstructionTypes,
                                         ptxType instructionType[ptxMAX_INSTR_ARGS],
                                         ptxParsingState gblState)
{
    int i = 0;
    for (i = 0; i < nrofTypeMod; i++) {
        if (i > *nrofInstructionTypes ||
            (ptxGetTypeModFromType(instructionType[i]) !=  typeMod[i]))
        {
            instructionType[i] = ptxGetTypeFromTypeMod(typeMod[i], gblState);
        }
    }
    *nrofInstructionTypes = nrofTypeMod;
}

static ptxInstructionTemplate preprocessInstruction(ptxParsingState gblState, String name, Bool macroAllowed, msgSourcePos_t sourcePos )
{
    ptxInstructionTemplate template;
    uInt tcode;

    if (isTypeModToTypeColwersionRequired(gblState, name)) {
        // When type-modifiees are colwerted into instructions types all checks releted to instructionTypes will be performed in 'ptxMatchInstruction'
        // and no explicit checks will be required.
        colwertTypeModIntoInstrTypes(gblState->parseData->nrofTypeMod, gblState->parseData->typeMod, &gblState->parseData->nrofInstructionTypes,
                                     gblState->parseData->instructionType, gblState);
    }

    preprocessArguments(gblState, name, sourcePos);

    template= ptxMatchInstruction( gblState->parseData, name, gblState->parseData->storage, gblState->parseData->nrofInstrMemspace, gblState->parseData->arguments,
                                   gblState->parseData->instructionType, gblState->parseData->nrofArguments, gblState->parseData->nrofInstructionTypes,
                                   /* Allow internal instructions during macro expansion
                                      and in utlity functions used for macro expansions */
                                   ptxIsInternalSource(gblState->lwrInstrSrc),
                                   sourcePos );

    if (!template)  {
        gblState->parseData->instruction_tcode = -1;
        return NULL;
    } else {
        tcode = template->code;
        gblState->parseData->instruction_tcode = tcode;
    }

    if (gblState->parseData->modifiers.DIM) {
        specializeDimModForInstr(gblState, name, template, sourcePos);
    }

    // Fermi Instructions
    checkFermiInstructions(gblState, tcode, name, sourcePos);

    // Kepler Instructions
    checkKeplerInstructions(gblState, tcode, name, sourcePos);

    // Maxwell Instructions
    checkMaxwellInstructions(gblState, tcode, name, sourcePos);

    // Pascal Instructions
    checkPascalInstructions(gblState, tcode, name, sourcePos);

    // Volta Instructions
#if LWCFG(GLOBAL_ARCH_VOLTA)
    checkVoltaInstructions(gblState, tcode, name, sourcePos);
#endif

    // Turing Instructions
#if LWCFG(GLOBAL_ARCH_TURING)
    checkTuringInstructions(gblState, template, tcode, name, sourcePos);
#endif

    // Ampere Instructions
#if LWCFG(GLOBAL_ARCH_AMPERE)
    checkAmpereInstructions(gblState, template, tcode, name, sourcePos);
#endif

    // Hopper Instructions
#if LWCFG(GLOBAL_ARCH_HOPPER)
    checkHopperInstructions(gblState, template, tcode, name, gblState->parseData->postop, gblState->parseData->modifiers, sourcePos);
#endif

#if LWCFG(GLOBAL_ARCH_ADA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    checkAdaInstructions(gblState, template, tcode, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType,
                         gblState->parseData->nrofInstrMemspace, gblState->parseData->storage, gblState->parseData->modifiers, sourcePos);
#endif // ada, internal

#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    stdCHECK_WITH_POS((gblState->parseData->nrofBMMAOperations < 2 || isMultiplePostOpAllowed(gblState, tcode)),
                      (ptxMsgDoublePtxOp, sourcePos));
#else
    stdCHECK_WITH_POS(gblState->parseData->nrofBMMAOperations < 2, (ptxMsgDoublePtxOp, sourcePos));
#endif

    // Check LEVEL and PREFETCH before checking MEMSPACE, since the
    // latter checks use these gblState->parseData->modifiers.
    if (gblState->parseData->modifiers.LEVEL) {
        checkLevelModifier(gblState, template, name, sourcePos);
    }
    if (gblState->parseData->modifiers.PREFETCHSIZE) {
        checkPrefetchSizeModifier(gblState, template, name, sourcePos);
    }

#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
    // if .level::evict_priority is used then norfLevelColonMod is incremented
    // which is used here for checking if level::evict_priority is allowed
    if (gblState->parseData->nrofLevelColonMod > 0) {
        restrictLevelColonEvictPriorityModifier(template, name, sourcePos);
    }
#endif

    // MEMSPACE
    if (ptxHasMEMSPACES_Feature(template->features)) {
        stdASSERT(gblState->parseData->nrofInstrMemspace <= ptxMAX_INSTR_MEMSPACE, ("unexpected number of memspaces"));

        if (checkNumMemSpaces(template, tcode, name, gblState->parseData->nrofInstrMemspace, sourcePos)) {
            int i;
            for (i = 0; i < gblState->parseData->nrofInstrMemspace; i++) {
                stdCHECK_WITH_POS(checkMemSpaceUsage(gblState, tcode, gblState->parseData->storage[i].kind, i),
                                  (ptxMsgSpaceIncorrect, sourcePos, name));
            }
        }
    } else if (ptxHasMEMSPACE_Feature(template->features)) {
        // TODO: Enable the following check once MODS bug 200437885 is fixed
        /* stdCHECK_WITH_POS(gblState->parseData->nrofInstrMemspace <= 1, */
        /*                   (ptxMsgIncorrectMemspaces, sourcePos, name)); */

        // for sm_20, instructions ld, ldu, st, atom, red, prefetch,
        // prefetchu, and cctl{u} default to generic addressing
        if (gblState->parseData->storage[0].kind == ptxUNSPECIFIEDStorage
            && isGenericDefaultStateSpace(tcode))
        {
            stdCHECK_WITH_POS(checkTargetArch(gblState, 20),
                              (ptxMsgFeatureRequiresSMVersion,
                               sourcePos, "generic addressing", "sm_20"));
            addStorage(gblState, ptxCreateStorageClass(ptxGenericStorage, -1), sourcePos);
            checkFeatureVersion(gblState, 2, 0, "generic addressing", sourcePos);
        }

        stdCHECK_WITH_POS(gblState->parseData->storage[0].kind != ptxUNSPECIFIEDStorage,
                          (ptxMsgModifierRequired, sourcePos,
                           "State space", name));

        stdCHECK_WITH_POS(checkMemSpaceUsage(gblState, tcode, gblState->parseData->storage[0].kind, 0),
                          (ptxMsgSpaceIncorrect, sourcePos, name));
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        if (gblState->parseData->modifiers.LEVEL && gblState->parseData->modifiers.PREFETCHSIZE) {
            stdCHECK_WITH_POS((gblState->parseData->storage[0].kind == ptxGlobalStorage ||
                               gblState->parseData->storage[0].kind == ptxGenericStorage),
                              (ptxMsgSpaceIncorrectForFeature,
                               sourcePos, "prefetch size" ));
        }
#endif
    }

    if (!stdIMPLIES(gblState->parseData->nrofInstrMemspace > 0,
                   (ptxHasMEMSPACE_Feature(template->features)  ||
                    ptxHasMEMSPACES_Feature(template->features) ||
                    ptxInstrHasImplicitMemSpace(tcode))))
    {
        stdCHECK_WITH_POS(False, (ptxMsgNoMemSpaceExpected, sourcePos, name));
    }

    if (gblState->parseData->modifiers.KEEPREF) {
        stdCHECK_WITH_POS(ptxHasKEEPREF_Feature(template->features),
                          (ptxMsgIllegalModifier, sourcePos,
                           get_strKEEPREF(gblState->parseData), name));
    }

    if (gblState->parseData->modifiers.NOATEXIT) {
        stdCHECK_WITH_POS(ptxHasNOATEXIT_Feature(template->features),
                          (ptxMsgIllegalModifier, sourcePos,
                           get_strNOATEXIT(gblState->parseData), name));
    }

    if (gblState->parseData->modifiers.CACHEPREFETCH) {
        checkCachePrefetchModifier(gblState, template, name, sourcePos);
    }

#if LWCFG(GLOBAL_ARCH_VOLTA) && (LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71))
    if (gblState->parseData->nrofEvictPriorityMod > 0) {
        checkEVICTPRIORITYModifier(gblState, template, name, sourcePos);
    }
#endif // ampere, internal

    // colwert UNIFORM_MOD to instruction specific modifier based on instruction features
    if (gblState->parseData->modifiers.UNIFORM) {
        stdCHECK_WITH_POS(ptxHasFLOW_Feature(template->features) || ptxHasVOTE_Feature(template->features),
                          (ptxMsgIllegalModifier, sourcePos, getUNIFORMAsString(ptxUNIFORM_MOD), name));

        if (ptxHasFLOW_Feature(template->features)) { setFlowModifier(gblState, ptxUNI_MOD, sourcePos); }
        if (ptxHasVOTE_Feature(template->features)) { setVoteModifier(gblState, ptxVUNI_MOD,sourcePos); }
    }

    if (gblState->parseData->modifiers.THREADGROUP) {
        stdCHECK_WITH_POS( ptxHasSPFORMAT_Feature(template->features) || ptxHasTHREADGROUP_Feature(template->features),
                           (ptxMsgIllegalModifier, sourcePos, get_strTHREADGROUP(gblState->parseData), name));
        if (ptxHasSPFORMAT_Feature(template->features)) { setSparseFormatModifier(gblState, ptxSPFORMAT_THREAD_MOD, sourcePos); }
    } 

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    {
        // check sparse gblState->parseData->modifiers.
        cString sp = getSPARSITYAsString(ptxSPARSITY_MOD);

        stdCHECK_WITH_POS(stdIMPLIES(ptxHasSPFORMAT_MOD(gblState->parseData->modifiers), 
                    ptxHasSPFORMAT_Feature(template->features)),
                (ptxMsgIllegalModifier, sourcePos, get_strSPFORMAT(gblState->parseData), name));

        stdCHECK_WITH_POS(stdIMPLIES(ptxHasSPARSITY_MOD(gblState->parseData->modifiers), 
                    ptxHasSPARSITY_Feature(template->features)),
                (ptxMsgIllegalModifier, sourcePos, get_strSPARSITY(gblState->parseData), name));

        // make .thread or .regoffset compulsory
        if (ptxHasSPFORMAT_Feature(template->features)) {
            char spformat[50];
            snprintf(spformat, 50, "%s or %s",
                     getSPFORMATAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSPFORMAT_THREAD_MOD),
                     getSPFORMATAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxSPFORMAT_REGOFFSET_MOD));

            stdCHECK_WITH_POS(ptxHasSPFORMAT_MOD(gblState->parseData->modifiers),
                              (ptxMsgModifierRequired, sourcePos, spformat, name));
        }
        // if .spformat is present then .sp must be present
        stdCHECK_WITH_POS(stdIMPLIES(ptxHasSPFORMAT_MOD(gblState->parseData->modifiers),
                    ptxHasSPARSITY_MOD(gblState->parseData->modifiers)), 
                (ptxMsgModRequiredWithMod, sourcePos, sp, name, get_strSPFORMAT(gblState->parseData)));
    }
#endif // ampere, future

    // colwert THREADS_MOD to instruction specific modifier based on instruction features
    if (gblState->parseData->modifiers.THREADS) {
        stdCHECK_WITH_POS( ptxHasVOTE_Feature(template->features)
                           || ptxHasBAR_Feature(template->features),
                           (ptxMsgIllegalModifier,sourcePos,get_strTHREADS(gblState->parseData),name) );
        if (ptxHasVOTE_Feature(template->features)) {
            ptxVOTEmod mod = ((gblState->parseData->modifiers.THREADS == ptxTALL_MOD) ? ptxVALL_MOD : ptxVANY_MOD);
            setVoteModifier(gblState, mod, sourcePos);
        }
        if (ptxHasBAR_Feature(template->features)) {
            ptxBARmod mod = ((gblState->parseData->modifiers.THREADS == ptxTALL_MOD) ? ptxBALL_MOD : ptxBANY_MOD);
            setBarModifier(gblState, mod, sourcePos);
        }
    }

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    // NOSLEEP
    stdCHECK_WITH_POS(stdIMPLIES(ptxHasNOSLEEP_MOD(gblState->parseData->modifiers),
                                 ptxHasNOSLEEP_Feature(template->features)),
                      (ptxMsgIllegalModifier, sourcePos, get_strNOSLEEP(gblState->parseData), name));

    // SHAREDSCOPE
    if (gblState->parseData->modifiers.SHAREDSCOPE) {
        checkSHAREDSCOPEModifier(gblState, name, tcode, gblState->parseData->modifiers.SHAREDSCOPE, template, sourcePos);
    }
    if (gblState->parseData->modifiers.MULTICAST) {
        checkMULTICASTModifier(gblState, name, tcode, template, sourcePos);
    }
    if (gblState->parseData->modifiers.IM2COL) {
        checkIM2COLModifier(gblState, name, tcode, template, sourcePos);
    }
    if (gblState->parseData->modifiers.PACKEDOFF) {
        checkPACKEDOFFModifier(gblState, name, tcode, template, sourcePos);
    }
    if (gblState->parseData->modifiers.MBARRIER) {
        checkMBARRIERModifier(gblState, name, tcode, template, sourcePos);
    }

    // OOB modifier
    if (gblState->parseData->modifiers.OOB) {
        stdCHECK_WITH_POS(ptxHasOOB_Feature(template->features),
                          (ptxMsgIllegalModifier, sourcePos, getOOBAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxOOB_MOD), name));
        stdCHECK_WITH_POS(!gblState->parseData->modifiers.FTZ, 
                          (ptxMsgIllegalModifierPair, sourcePos, getFTZAsString(ptxOOB_MOD),
                          getOOBAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxOOB_MOD)));
    }
#endif

    // THREADGROUP
    stdCHECK_WITH_POS( stdIMPLIES(ptxHasTHREADGROUP_MOD(gblState->parseData->modifiers),
                                  ptxHasTHREADGROUP_Feature(template->features)),
                       (ptxMsgIllegalModifier, sourcePos, get_strTHREADGROUP(gblState->parseData), name));

    stdCHECK_WITH_POS( stdIMPLIES(ptxHasALIGN_MOD(gblState->parseData->modifiers),
                       ptxHasALIGN_Feature(template->features)),
                       (ptxMsgIllegalModifier, sourcePos,
                        getALIGNAsString(ptxALIGNED_MOD), name));

    // Check Alloca and friends
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_73)
    switch (tcode) {
    case ptx_stacksave_Instr:
    case ptx_stackrestore_Instr:
    case ptx_alloca_Instr:
        checkAllocaSaveRestoreInstr(gblState, name, tcode, sourcePos);
    }
#endif

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_62)
    if (tcode == ptx_p2r_Instr || tcode == ptx_r2p_Instr) {
        stdCHECK_WITH_POS(checkTargetArch(gblState, 50),
                         (ptxMsgSMVersionRequired, sourcePos, name, "sm_50"));
        checkFeatureVersion(gblState, 6, 0, name, sourcePos);
        checkP2RandR2PInstr(gblState, name, tcode, sourcePos);
    }
#endif

    if (tcode == ptx_set_Instr) {
        checkSetInstruction(gblState, tcode, name, gblState->parseData->nrofInstructionTypes, gblState->parseData->instructionType, sourcePos);
    }

    // NOINC (optional)
    stdCHECK_WITH_POS( stdIMPLIES(ptxHasNOINC_MOD(gblState->parseData->modifiers),
                                  ptxHasNOINC_Feature(template->features)),
                       (ptxMsgIllegalModifier, sourcePos,
                        getNOINCAsString(ptxNOINC_MOD), name) );

    // NOCOMPLETE (mandatory)
    if ( ptxHasNOCOMPLETE_MOD(gblState->parseData->modifiers) &&
        !ptxHasNOCOMPLETE_Feature(template->features))
    {
        Bool isMbarrierArriveInstr = False;
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
         isMbarrierArriveInstr |= (tcode == ptx_mbarrier_arrive_Instr ||
                                   tcode == ptx_mbarrier_arrive_drop_Instr);
#endif
        String instrVariant =  isMbarrierArriveInstr ?
                                 stdCONCATSTRING(name, " without count argument") :
                                 name;
        msgReportWithPos(ptxMsgIllegalModifier, sourcePos,
                           getNOCOMPLETEAsString(gblState->parseData->modifiers.NOCOMPLETE), instrVariant);
    }

    if ( ptxHasNOCOMPLETE_Feature(template->features) &&
        !ptxHasNOCOMPLETE_MOD(gblState->parseData->modifiers))
    {
        Bool isMbarrierArriveInstr = False;
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
         isMbarrierArriveInstr |= (tcode == ptx_mbarrier_arrive_Instr ||
                                   tcode == ptx_mbarrier_arrive_drop_Instr);
#endif
        String instrVariant =  isMbarrierArriveInstr ?
                                 stdCONCATSTRING(name, " with count argument") :
                                 name;
        stdCHECK_WITH_POS(isMbarrierArriveInstr &&
                          isNativeMultiArriveSupportedForMbarrierInstr(gblState),
                          (ptxMsgModifierRequired, sourcePos,
                           getNOCOMPLETEAsString(ptxNOCOMPLETE_MOD),
                           instrVariant));
    }

// exclusive modifier
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    stdCHECK_WITH_POS(stdIMPLIES(ptxHasEXCLUSIVE_MOD(gblState->parseData->modifiers),
                                  ptxHasEXCLUSIVE_Feature(template->features)),
                      (ptxMsgIllegalModifier, sourcePos,
                       getEXCLUSIVEAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxEXCLUSIVE_MOD), name));
#endif

    // SYNC
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    stdCHECK_WITH_POS( stdIMPLIES(ptxHasSYNC_Feature(template->features), ptxHasSYNC_MOD(gblState->parseData->modifiers)),
                       (ptxMsgModifierRequired, sourcePos,
                        (tcode == ptx_bar_Instr || tcode == ptx_barrier_Instr)?
                        "Barrier" : getSYNCAsString(ptxSYNC_MOD), name));
    if (tcode == ptx_barrier_Instr) {
        stdCHECK_WITH_POS( checkTargetArch(gblState, 30),
                          (ptxMsgSMVersionRequired,sourcePos,name,"sm_30") );
        checkFeatureVersion(gblState, 6, 0, name, sourcePos);
        checkBarrierNumber(gblState, tcode, sourcePos);
        checkBarrierThreadCount(gblState, tcode, sourcePos);
    }
#else
    stdCHECK_WITH_POS( stdIMPLIES(ptxHasSYNC_Feature(template->features), ptxHasSYNC_MOD(gblState->parseData->modifiers)),
                       (ptxMsgModifierRequired, sourcePos,
                        tcode == ptx_bar_Instr ? "Barrier" : getSYNCAsString(ptxSYNC_MOD),
                        name));
#endif
    if (tcode == ptx_bar_Instr && ptxHasSYNC_MOD(gblState->parseData->modifiers)) {
        checkBarrierNumber(gblState, tcode, sourcePos);
        checkBarrierThreadCount(gblState, tcode, sourcePos);
    }

    // bar.arrive
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    if (tcode == ptx_bar_arrive_Instr || tcode == ptx_barrier_arrive_Instr) {
#else
    if (tcode == ptx_bar_arrive_Instr) {
#endif

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
        if (tcode == ptx_barrier_arrive_Instr) {
            stdCHECK_WITH_POS(checkTargetArch(gblState, 30),
                              (ptxMsgSMVersionRequired, sourcePos, name,
                               "sm_30"));
            checkFeatureVersion(gblState, 6, 0, name, sourcePos);
        } else
#endif
        if (tcode == ptx_bar_arrive_Instr) {
            stdCHECK_WITH_POS(checkTargetArch(gblState, 20),
                              (ptxMsgSMVersionRequired, sourcePos, name,
                               "sm_20"));
            checkFeatureVersion(gblState, 2, 0, name, sourcePos);
        }
        stdCHECK_WITH_POS(gblState->parseData->nrofArguments == 2,
                          (ptxMsgBarArriveRequiresThdCnt, sourcePos, name));
        stdCHECK_WITH_POS(stdIMPLIES(gblState->parseData->nrofArguments == 2 &&
                                     gblState->parseData->arguments[1]->kind == ptxIntConstantExpression,
                                     gblState->parseData->arguments[1]->cases.IntConstant.i != 0),
                          (ptxMsgBarArriveRequiresThdCnt,sourcePos,name));
        // only .any modifier allowed
        stdCHECK_WITH_POS(stdIMPLIES(gblState->parseData->modifiers.BAR,
                                     gblState->parseData->modifiers.BAR == ptxBANY_MOD),
                          (ptxMsgIllegalModifier, sourcePos, get_strBAR(gblState->parseData),
                           name));
        checkBarrierNumber(gblState, tcode, sourcePos);
        checkBarrierThreadCount(gblState, tcode, sourcePos);
    }

    // {bar,barrier}.red.{popc,and,or}
    //
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    if (tcode == ptx_bar_red_Instr || tcode == ptx_barrier_red_Instr) {
#else
    if (tcode == ptx_bar_red_Instr) {
#endif
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
        if (tcode == ptx_barrier_red_Instr) {
            stdCHECK_WITH_POS(checkTargetArch(gblState, 30),
                              (ptxMsgSMVersionRequired, sourcePos, name,
                               "sm_30"));
            checkFeatureVersion(gblState, 6, 0, name, sourcePos);
        } else
#endif
        if (tcode == ptx_bar_red_Instr) {
            stdCHECK_WITH_POS(checkTargetArch(gblState, 20),
                              (ptxMsgSMVersionRequired, sourcePos,
                               name, "sm_20"));
            checkFeatureVersion(gblState, 2, 0, name, sourcePos);
        }
        // {bar,barrier}.red.popc requires .u32,
        // {bar,barrier}.red.{and,or} requires .pred
        stdCHECK_WITH_POS(stdIMPLIES(gblState->parseData->postop == ptxPOPCOp,
                                     isU32(gblState->parseData->instructionType[0])),
                          (ptxMsgOpRequiresU32, sourcePos));
        stdCHECK_WITH_POS(stdIMPLIES((gblState->parseData->postop == ptxANDOp || gblState->parseData->postop == ptxOROp),
                                     isPRED(gblState->parseData->instructionType[0])),
                          (ptxMsgOpRequiresPred, sourcePos));

        stdCHECK_WITH_POS((gblState->parseData->postop == ptxPOPCOp || gblState->parseData->postop == ptxANDOp
                           || gblState->parseData->postop == ptxOROp),
                          (ptxMsgOutputAOPNotAllowed, sourcePos, name,
                           getInstrTypeAsString(gblState, 0), getInstrTypeAsString(gblState, 1)));

        // only .any modifier allowed
        stdCHECK_WITH_POS(stdIMPLIES(gblState->parseData->modifiers.BAR, gblState->parseData->modifiers.BAR == ptxBANY_MOD),
                          (ptxMsgIllegalModifier, sourcePos, get_strBAR(gblState->parseData), name));
        checkBarrierNumber(gblState, tcode, sourcePos);
        checkBarrierThreadCount(gblState, tcode, sourcePos);
    }

    // POPC is present only when tcode is bar_red_Instr or barrier_red_Instr
    // or __mma_Instr
    if (gblState->parseData->postop == ptxPOPCOp) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    stdCHECK_WITH_POS(stdIMPLIES(gblState->parseData->postop==ptxPOPCOp, tcode==ptx_bar_red_Instr
                                 || tcode==ptx_barrier_red_Instr),
                      (ptxMsgOutputAOPNotAllowed, sourcePos, name,
                       getInstrTypeAsString(gblState, 0), getInstrTypeAsString(gblState, 1)));
#elif LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    stdCHECK_WITH_POS(stdIMPLIES(gblState->parseData->postop==ptxPOPCOp, tcode==ptx_bar_red_Instr
                                 || tcode==ptx_barrier_red_Instr
                                 || tcode == ptx__mma_Instr),
                      (ptxMsgOutputAOPNotAllowed, sourcePos, name,
                       getInstrTypeAsString(gblState, 0), getInstrTypeAsString(gblState, 1)));
#else
    stdCHECK_WITH_POS(stdIMPLIES( gblState->parseData->postop==ptxPOPCOp, tcode==ptx_bar_red_Instr),
                      (ptxMsgOutputAOPNotAllowed, sourcePos, name,
                       getInstrTypeAsString(gblState, 0), getInstrTypeAsString(gblState, 1)));
#endif
    }

    if (gblState->parseData->postop == ptxMAXABSOp) {
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
        if (!areRestrictedUseFeaturesAllowed(gblState)) {
            stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos,
                                      get_strPOSTOP(gblState->parseData)));
        } else {
            checkFeatureTarget(gblState, 80, get_strPOSTOP(gblState->parseData), sourcePos);
            checkFeatureVersion(gblState, 6, 4, get_strPOSTOP(gblState->parseData) , sourcePos);
        }
#else
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier, sourcePos, get_strPOSTOP(gblState->parseData)));
#endif
    }

    // RAND -- optional
    stdCHECK_WITH_POS(
            stdIMPLIES(gblState->parseData->modifiers.RAND, ptxHasRAND_Feature(template->features)),
            (ptxMsgIllegalModifier, sourcePos, getRANDAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxRAND_MOD), name)
    );

    // SHFL -- required
    stdCHECK_WITH_POS(
            stdIMPLIES(gblState->parseData->modifiers.SHFL, ptxHasSHFL_Feature(template->features)),
            (ptxMsgIllegalModifier, sourcePos, get_strSHFL(gblState->parseData), name)
    );
    stdCHECK_WITH_POS(
            stdIMPLIES(ptxHasSHFL_Feature(template->features), gblState->parseData->modifiers.SHFL),
            (ptxMsgModifierRequired, sourcePos, "Shuffle", name)
    );

    // VOTE
    stdCHECK_WITH_POS(stdIMPLIES(ptxHasVOTE_MOD(gblState->parseData->modifiers),
                                 ptxHasVOTE_Feature(template->features)),
                      (ptxMsgIllegalModifier, sourcePos, get_strVOTE(gblState->parseData), name));
    // SAT
    stdCHECK_WITH_POS(stdIMPLIES(gblState->parseData->modifiers.SAT,
                      (ptxHasSAT_Feature(template->features) || ptxHasVSAT_Feature(template->features))),
                      (ptxMsgIllegalModifier, sourcePos, getSATAsString(ptxSAT_MOD), name));

    // DESC
    stdCHECK_WITH_POS( stdIMPLIES( ptxHasDESC_Feature(template->features),
                                   ptxHasDESC_MOD(gblState->parseData->modifiers)
                                   || useLenientCheckForDesc(gblState, tcode)),
                       (ptxMsgModifierRequired, sourcePos,
                        getDESCAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxDESC_MOD), name));

    if (ptxHasDESC_MOD(gblState->parseData->modifiers)) {
        stdCHECK_WITH_POS(ptxHasDESC_Feature(template->features) ||
                          useLenientCheckForDesc(gblState, tcode),
                          (ptxMsgIllegalModifier, sourcePos,
                           getDESCAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxDESC_MOD), name) );
        checkStateSpaceForMemDesc(gblState, tcode, name, gblState->parseData->nrofInstrMemspace, gblState->parseData->storage,
                                  sourcePos);
    }

    // MUFU instructions
    switch (tcode) {
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
    case ptx_tanh_Instr:
        stdCHECK_WITH_POS(checkTargetArch(gblState, minTuringArch),
                          (ptxMsgFeatureRequiresSMVersion,sourcePos, name, minTuringArchStr));
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        // FIXME: update version for guard
        checkFeatureVersion(gblState, 6, 0, name, sourcePos);
#else
        // TANH supported as extended in 6.5 and public ISA in 7.0
        if (areExtendedInstructionsEnabled(gblState->parseData)) {
            checkFeatureVersion(gblState, 6, 5, name, sourcePos);
        } else {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
            checkFeatureVersion(gblState, 7, 0, name, sourcePos);
#else
            stdCHECK_WITH_POS( False, (ptxMsgUnknownInstructionName,sourcePos,name) );
#endif // ISA_70
        }
#endif //Internal
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_FUTURE)
        if (isBF16(gblState->parseData->instructionType[0]) ||
            isBF16x2(gblState->parseData->instructionType[0])) {
            String instrWithType;
            stdCHECK_WITH_POS(gblState->parseData->nrofInstructionTypes == 1,
                              (ptxMsgNonMatchingInstrTypes, sourcePos, name));
            instrWithType = stdCONCATSTRING(name,
                                            getTYPEAsString(gblState->parseData->deobfuscatedStringMapPtr,
                                                            gblState->parseData->instructionType[0]));
            // FIXME: update version check
            checkFeatureVersion(gblState, 7, 4, instrWithType, sourcePos);
            checkFeatureTarget(gblState, 90, instrWithType, sourcePos);
            checkInstructionArgsForBF16(gblState, template, name, 0,
                                        gblState->parseData->nrofArguments,
                                        gblState->parseData->arguments, sourcePos);
        }
#endif // HOPPER && FUTURE
        break;
#endif // TURING && ISA_65
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    case ptx_sin_Instr:
    case ptx_cos_Instr:
    case ptx_lg2_Instr:
    case ptx_rcp_Instr:
    case ptx_sqrt_Instr:
    case ptx_rsqrt_Instr:
        if (isF16(gblState->parseData->instructionType[0]) ||
            isF16x2(gblState->parseData->instructionType[0])) {
            String type, feature;
            stdString_t sType = stringNEW();
            ptxPrintType(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->instructionType[0], sType);
            type = stringStripToBuf(sType);
            feature = stdCONCATSTRING(name, type);

            // FIXME: update version for guard
            checkFeatureVersion(gblState, 6, 1, feature, sourcePos);
            checkFeatureTarget(gblState, minTuringArch,   feature, sourcePos);
            stdFREE2(feature, type);
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        } else if (isBF16(gblState->parseData->instructionType[0]) ||
                   isBF16x2(gblState->parseData->instructionType[0])) {
            String instrWithType;
            stdCHECK_WITH_POS(gblState->parseData->nrofInstructionTypes == 1,
                              (ptxMsgNonMatchingInstrTypes, sourcePos, name));
            instrWithType = stdCONCATSTRING(name,
                                            getTYPEAsString(gblState->parseData->deobfuscatedStringMapPtr,
                                                            gblState->parseData->instructionType[0]));
            // FIXME: update version check
            checkFeatureVersion(gblState, 7, 4, instrWithType, sourcePos);
            checkFeatureTarget(gblState, 90, instrWithType, sourcePos);

            stdCHECK_WITH_POS(gblState->parseData->modifiers.APRX,
                              (ptxMsgModifierRequired, sourcePos,
                               getAPRXAsString(ptxAPRX_MOD), name));

            checkInstructionArgsForBF16(gblState, template, name, 0,
                                        gblState->parseData->nrofArguments,
                                        gblState->parseData->arguments, sourcePos);
#endif // HOPPER && INTERNAL
        } else if (gblState->parseData->nrofInstructionTypes != 1) {
            // Exactly one type is expected for sin/cos/lg2/rcp/sqrt/rsqrt
            stdCHECK_WITH_POS(False,
                              (ptxMsgNonMatchingInstrTypes, sourcePos, name));
        }
        break;
#endif // TURING && INTERNAL
    }

    // preprocessing is done twice for instructions that pass through macro expansion but are not expanded, e.g. CVT
    // - since gblState->parseData->modifiers are set to default values in first pass, don't perform ISA-specific modifier checks for 'escaped' instructions (macroAllowed==False)

    //APRX
    if (macroAllowed && gblState->parseData->modifiers.APRX)
        checkFeatureVersion(gblState, 1, 4, getAPRXAsString(ptxAPRX_MOD), sourcePos);
    stdCHECK_WITH_POS( stdIMPLIES( gblState->parseData->modifiers.APRX, ptxHasAPRX_Feature(template->features)),
                      (ptxMsgIllegalModifier, sourcePos,
                       getAPRXAsString(ptxAPRX_MOD), name));

    if (ptxHasAPRX_Feature(template->features) && !ptxVersionAtLeast(1,4, gblState)) {
        setApproxModifier(gblState, ptxAPRX_MOD, sourcePos);
    }
    // Instructions with both APRX and ROUNDF features require .approx or .rnd to be set; e.g. {div,rcp,sqrt}.f32 and rcp.f64
    // Instructions with only APRX feature require .approx to be set
    if (ptxHasROUNDF_Feature(template->features)) {
        stdCHECK_WITH_POS(
                stdIMPLIES( ptxHasAPRX_Feature(template->features),
                            ( (gblState->parseData->modifiers.APRX && !ptxHasRoundFModifier(gblState->parseData->modifiers)) || (!gblState->parseData->modifiers.APRX && ptxHasRoundFModifier(gblState->parseData->modifiers)) ) ),
                (ptxMsgModifierRequired, sourcePos,
                 "Rounding modifier or '.approx'", name)
        );
    } else {
        stdCHECK_WITH_POS(
                stdIMPLIES( ptxHasAPRX_Feature(template->features), gblState->parseData->modifiers.APRX ),
                (ptxMsgModifierRequired, sourcePos, getAPRXAsString(ptxAPRX_MOD), name)
        );
    }

    //FTZ
    if (macroAllowed &&  gblState->parseData->modifiers.FTZ)
        checkFeatureVersion(gblState, 1, 4, getFTZAsString(gblState->parseData->modifiers.FTZ), sourcePos);

    stdCHECK_WITH_POS(stdIMPLIES(gblState->parseData->modifiers.FTZ, ptxHasFTZ_Feature(template->features)),
                      (ptxMsgIllegalModifier, sourcePos,
                       getFTZAsString(gblState->parseData->modifiers.FTZ), name));

    // FIXME: We don't check version/target here since NOFTZ is
    // lwrrently used only on atom.add.f16x2, which does its own
    // checks anyway. The check here will be eliminated once we remove
    // the "noftz" hack.
    //
    // http://lwbugs/200376404
    stdCHECK_WITH_POS(stdIMPLIES(gblState->parseData->modifiers.NOFTZ, ptxHasNOFTZ_Feature(template->features)),
                      (ptxMsgIllegalModifier, sourcePos,
                       getNOFTZAsString(gblState->parseData->modifiers.NOFTZ), name));

    // rcp.approx.f64 requires .ftz, .version 2.1, sm_20
    if ( tcode == ptx_rcp_Instr && gblState->parseData->modifiers.APRX && isF64(gblState->parseData->instructionType[0]) ) {
        stdCHECK_WITH_POS(gblState->parseData->modifiers.FTZ, (ptxMsgModifierRequired,sourcePos,
                                          "'.ftz'", "rcp.approx.f64"));
        checkFeatureVersion(gblState, 2, 1, "rcp.approx.f64", sourcePos);
        stdCHECK_WITH_POS( checkTargetArch(gblState, 20), (ptxMsgSMVersionRequired,sourcePos,"rcp.approx.f64","sm_20") );
    }

    // rsqrt.approx.ftz.f64 requires .version 4.0, sm_20
    if ( tcode == ptx_rsqrt_Instr && gblState->parseData->modifiers.APRX && isF64(gblState->parseData->instructionType[0]) && gblState->parseData->modifiers.FTZ ) {
        checkFeatureVersion(gblState, 4, 0, "rsqrt.approx.ftz.f64", sourcePos);
        stdCHECK_WITH_POS( checkTargetArch(gblState, 20), (ptxMsgSMVersionRequired,sourcePos,"rsqrt.approx.ftz.f64","sm_20") );
    }

#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    if (tcode == ptx_match_Instr || tcode == ptx__match_Instr) {
        stdCHECK_WITH_POS(!(gblState->parseData->modifiers.VOTE == ptxBALLOT_MOD),
                          (ptxMsgIllegalModifier, sourcePos, getVOTEAsString(ptxBALLOT_MOD), name));

        stdCHECK_WITH_POS(gblState->parseData->modifiers.VOTE && (gblState->parseData->modifiers.VOTE == ptxVALL_MOD || gblState->parseData->modifiers.VOTE == ptxVANY_MOD),
                          (ptxMsgModifierRequired, sourcePos, "'.any' or '.all'", name));

        // only match.all supports predicate output
        if (gblState->parseData->predicateOutput) {
            stdCHECK_WITH_POS(gblState->parseData->modifiers.VOTE == ptxVALL_MOD, (ptxMsgResultPredNotAllowed, sourcePos, "match.any"));
        }
    }
#endif

    // non-sync shfl and vote instructions are now deprecated
    if (tcode == ptx_vote_Instr || tcode == ptx_shfl_Instr)
        checkForNonSyncDeprecation(gblState, name, sourcePos);

   //Checks for vote instruction other than feature and version checks 
   if (tcode == ptx_vote_Instr) {
        if (gblState->parseData->modifiers.VOTE == ptxBALLOT_MOD) {
            stdCHECK_WITH_POS(isB32(gblState->parseData->instructionType[0]),
                              (ptxMsgInstRequiresTypeModifier,
                               sourcePos, ".vote", ".b32", get_strVOTE(gblState->parseData)));
        } else {
              stdCHECK_WITH_POS(isPRED(gblState->parseData->instructionType[0]),
                                (ptxMsgInstRequiresTypeModifier,
                                 sourcePos, ".vote", ".pred", get_strVOTE(gblState->parseData)));
        }
    }

   // check for aligned modifier on vote/match/shfl
   if (tcode == ptx_vote_Instr     ||
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
       tcode == ptx_bar_warp_Instr ||
#if LWCFG(GLOBAL_ARCH_VOLTA)
       tcode == ptx_match_Instr    ||
#endif
#endif
       tcode == ptx_shfl_Instr)
   {
       if (gblState->parseData->modifiers.ALIGN == ptxALIGNED_MOD) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
           Char *msg = stdCONCATSTRING(".aligned modifier for ", name);
           // TODO: Update version guard
           checkFeatureVersion(gblState, 6, 4, msg, sourcePos);
           stdFREE(msg);
#else
           // Allow .aligned modifier if on *sync instruction if it is used in macro
           stdCHECK_WITH_POS(ptxIsInternalSource(gblState->lwrInstrSrc),
                             (ptxMsgIllegalModifier, sourcePos, get_strALIGN(gblState->parseData), name));
#endif
       }
   }

    // cvt.ftz requires .f32 as src or dst
    stdCHECK_WITH_POS(
            stdIMPLIES( (gblState->parseData->modifiers.FTZ && tcode==ptx_cvt_Instr),
                        (isF32(gblState->parseData->instructionType[0]) || isF32(gblState->parseData->instructionType[1])) ),
            (ptxMsgCvtFTZNotAllowed,sourcePos,name)
    );
    // version 1.0-1.4 does not allow cvt.ftz if either src/dst type is 64-bit
    stdCHECK_WITH_POS( !macroAllowed ||
            stdIMPLIES( (gblState->parseData->modifiers.FTZ && tcode==ptx_cvt_Instr && !ptxVersionAtLeast(1,5, gblState)),
                        (ptxGetTypeSizeInBits(gblState->parseData->instructionType[0]) != 64 && ptxGetTypeSizeInBits(gblState->parseData->instructionType[1]) != 8) ),
            (ptxMsgCvtFTZNotAllowed,sourcePos,name)
    );

    setDefaultFtzForSm1x(gblState, tcode, template, sourcePos);

    // check reduction op and argument types for sured.{add,min,max,and,or}
    stdCHECK_WITH_POS( stdIMPLIES( (tcode==ptx_sured_b_Instr || tcode==ptx_sured_p_Instr),
                                   (gblState->parseData->postop==ptxADDOp || gblState->parseData->postop==ptxMINOp || gblState->parseData->postop==ptxMAXOp || gblState->parseData->postop==ptxANDOp || gblState->parseData->postop==ptxOROp) ),
                       (ptxMsgIllegalOp,sourcePos, gblState->parseData->postop, name)
    );
    if (tcode == ptx_sured_b_Instr) {
        if (gblState->parseData->postop==ptxADDOp) {
            stdCHECK_WITH_POS( isI32(gblState->parseData->instructionType[0]) || isU64(gblState->parseData->instructionType[0]),
                               (ptxMsgOpIncorrectType, sourcePos,
                                getTYPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->instructionType[0]),
                                get_strPOSTOP(gblState->parseData), name));
        } else if (gblState->parseData->postop==ptxMINOp || gblState->parseData->postop==ptxMAXOp) {
            stdCHECK_WITH_POS( isI32(gblState->parseData->instructionType[0]),
                               (ptxMsgOpIncorrectType, sourcePos,
                                getTYPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->instructionType[0]),
                                get_strPOSTOP(gblState->parseData), name));
        } else if (gblState->parseData->postop==ptxANDOp || gblState->parseData->postop==ptxOROp) {
            stdCHECK_WITH_POS( isB32(gblState->parseData->instructionType[0]),
                               (ptxMsgOpIncorrectType, sourcePos,
                                getTYPEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->instructionType[0]),
                                get_strPOSTOP(gblState->parseData), name));
        }
    }

#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    if (ptxHasSHAPE_MOD(gblState->parseData->modifiers)) {
        stdCHECK_WITH_POS(ptxHasSHAPE_Feature(template->features),
                          (ptxMsgIllegalModifier,
                           sourcePos, get_strSHAPE(gblState->parseData), name));
    }

    if (ptxHasSHAPE_Feature(template->features)) {
        stdCHECK_WITH_POS(ptxHasSHAPE_MOD(gblState->parseData->modifiers),
                          (ptxMsgModifierRequired, sourcePos, "Shape", name));
    }

    if (gblState->parseData->nrofMatrixLayout != 0) {
        // notice how we use SHAPE to recognize matrix operations
        stdCHECK_WITH_POS(ptxHasSHAPE_Feature(template->features),
                          (ptxMsgIllegalModifier, sourcePos,
                           ".alayout or .blayout", name));
    }

    if (ptxIsWMMAInstr(tcode)) {
        checkWMMA(gblState, tcode, name, sourcePos);
    } else if (tcode == ptx__mma_Instr) {
        checkMMA(gblState, template, name, sourcePos);
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_64)
    } else if (tcode == ptx_mma_Instr) {
        checkPublicMMA(gblState, template, name, sourcePos);
#endif
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    } else if (tcode == ptx__mma_warpgroup_Instr) {
        checkGMMA(gblState, template, name, sourcePos);
    } else if (tcode == ptx__warpgroup_wait_Instr   ||
               tcode == ptx__warpgroup_arrive_Instr ||
               tcode == ptx__warpgroup_commit_batch_Instr)
    {
        checkWarpgroup(gblState, template, name, sourcePos);
#endif
    }
#endif // Volta

    //VECTORMODE
    stdCHECK_WITH_POS(
            stdIMPLIES( ptxHasVECTOR_MOD(gblState->parseData->modifiers),
                        ptxHasVECTORIZABLE_Feature(template->features) ),
            (ptxMsgOutputVectorModeNotAllowed,sourcePos,name)
    );

#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    if (tcode == ptx__ldsm_Instr) {
        checkLdsmInstr(gblState, tcode, name, sourcePos);
    }

    if (tcode == ptx__movm_Instr) {
        checkMovmInstr(gblState, tcode, name, sourcePos);
    }

#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
    if (tcode == ptx_ldmatrix_Instr) {
        checkLdmatrixInstr(gblState, tcode, name, sourcePos);
    }
#endif

    if (gblState->parseData->instrUsesTypeMod) {
        stdCHECK_WITH_POS(isTypeModAllowed(gblState, tcode),
                          (ptxMsgNonMatchingInstrTypes, sourcePos, name));
    }
#endif
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_FUTURE)
    if (tcode == ptx_stmatrix_Instr) {
        checkStmatrixInstr(gblState, tcode, name, sourcePos);
    }
#endif

    if (tcode == ptx_ex2_Instr) {
        checkEx2Instr(gblState, template, name, sourcePos);
    }

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_62)
    if (tcode == ptx_activemask_Instr) {
        checkFeatureVersion(gblState, 6, 2, name, sourcePos);
        checkFeatureTarget(gblState, 30,   name, sourcePos);
    }
#endif

    // Checks for macro instructions.
    if (macroAllowed) {
        if (tcode == ptx_vote_Instr) {
            // VOTE instruction requires SM_12 or higher
            checkFeatureVersion(gblState, 1, 2, "1.2", sourcePos);
            stdCHECK_WITH_POS(checkTargetArch(gblState, 12), (ptxMsgSMVersionRequired,
                                                    sourcePos,name,"sm_12") );
            if (gblState->parseData->modifiers.VOTE == ptxBALLOT_MOD) {
                checkFeatureVersion(gblState, 2, 0, "vote.ballot", sourcePos);
                stdCHECK_WITH_POS(checkTargetArch(gblState, 20), (ptxMsgSMVersionRequired,
                                                        sourcePos, "vote.ballot",
                                                        "sm_20") );
            }
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
            if (ptxHasSYNC_MOD(gblState->parseData->modifiers)) {
                checkFeatureVersion(gblState, 6, 0, "vote.sync", sourcePos);
                stdCHECK_WITH_POS(checkTargetArch(gblState, 30), (ptxMsgSMVersionRequired,
                                                        sourcePos,"vote.sync",
                                                        "sm_30") );
            }
        } else if (tcode == ptx_bar_warp_Instr) {
            checkFeatureVersion(gblState, 6, 0, "bar.warp", sourcePos);
            stdCHECK_WITH_POS(checkTargetArch(gblState, 30), (ptxMsgSMVersionRequired,sourcePos,"bar.warp","sm_30") );
#endif
        } else if (tcode == ptx_shfl_Instr ) {
            stdCHECK_WITH_POS( checkTargetArch(gblState, 30), (ptxMsgSMVersionRequired,sourcePos,name,"sm_30") );
            checkFeatureVersion(gblState, 3, 0, name, sourcePos);
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
            if (ptxHasSYNC_MOD(gblState->parseData->modifiers)) {
                //Target architecture for shfl.sync is same as shfl i.e. sm_30
                checkFeatureVersion(gblState, 6, 0, "shfl.sync", sourcePos);
            }
#endif
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
        } else if (tcode == ptx_match_Instr) {
            checkFeatureVersion(gblState, 6, 0, name, sourcePos);
            stdCHECK_WITH_POS( checkTargetArch(gblState, 70), (ptxMsgSMVersionRequired,
                                                     sourcePos, name, "sm_70") );
#endif
        // check range of immediate operands 'pos' and 'len' for BFE, BFI
        // - disable check for 'escaped' instructions, since they were checked before macro expansion
        } else if (tcode == ptx_bfe_Instr || tcode == ptx_bfi_Instr) {
            uInt64 val;
            uInt   i = (tcode==ptx_bfe_Instr) ? 2 : 3;

            if (gblState->parseData->arguments[i]->kind == ptxIntConstantExpression) {
                val = gblState->parseData->arguments[i]->cases.IntConstant.i;
                stdCHECK_WITH_POS( (0 <= val && val <= 255),
                                   (ptxMsgArgValueOutOfRange, sourcePos, i, name, val, 0, 255) );
            }

            if (gblState->parseData->arguments[i+1]->kind == ptxIntConstantExpression) {
                val = gblState->parseData->arguments[i+1]->cases.IntConstant.i;
                stdCHECK_WITH_POS( (0 <= val && val <= 255),
                                   (ptxMsgArgValueOutOfRange, sourcePos, i+1, name, val, 0, 255) );
            }
        }
    }

#if LWCFG(GLOBAL_ARCH_VOLTA) && (LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_62) || LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL))
    if (tcode == ptx_nanosleep_Instr) {
        stdCHECK_WITH_POS(isU32(gblState->parseData->instructionType[0]), 
                          (ptxMsgInstRequiresType, sourcePos, "nanosleep",
                           ".u32"));
    }
#endif // LWCFG(GLOBAL_ARCH_VOLTA) && (GLOBAL_FEATURE_PTX_ISA_VERSION_62 || GLOBAL_FEATURE_PTX_ISA_INTERNAL)

    if (tcode == ptx_bra_Instr) {
        if (gblState->parseData->modifiers.BRANCH == ptxCOLW_MOD || gblState->parseData->modifiers.BRANCH == ptxDIV_MOD) {
            stdCHECK_WITH_POS(gblState->parseData->guard == NULL, (ptxMsgIllegalPredicationInstr, sourcePos, 
                                              name, getBRANCHAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.BRANCH)));
        }
    }
    checkArguments(gblState, tcode, name, template, sourcePos);

    return template;
}

static Bool compareTypes(ptxTypeKind kind1, ptxTypeKind kind2)
{
    return ( isBitTypeKind(kind1) || isBitTypeKind(kind2)|| kind1 == kind2 ||
            (  isFloatKind(kind1) && isFloatKind(kind2)) ||
            (isIntegerKind(kind1) && isIntegerKind(kind2)));
}

static Bool isMMEStorageInstruction(ptxInstructionCode tcode)
{
    switch(tcode) {

      case ptx_ld_Instr:
      case ptx_st_Instr:
      case ptx_atom_Instr:
      case ptx_red_Instr:
            return True;
      case ptx_membar_Instr:
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
      case ptx_fence_Instr:
#endif
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
      case ptx_barrier_cluster_arrive_Instr:
#endif // HOPPER && INTERNAL
            return False;
      default:
            stdASSERT(False,("Unknown Instruction"));
            return False;
    }
}

static Bool checkOrderForInst(ptxParsingState gblState, ptxInstructionCode tcode,
                              String name, msgSourcePos_t sourcePos)
{
    if (gblState->parseData->modifiers.ORDER == ptxVOLATILE_MOD)
        checkFeatureVersion(gblState, 1, 1, getORDERAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxVOLATILE_MOD), sourcePos);
    else {
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
        checkFeatureVersion(gblState, 6, 0, get_strORDER(gblState->parseData), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, 70),
                          (ptxMsgFeatureRequiresSMVersion, sourcePos,
                           get_strORDER(gblState->parseData), "sm_70"));
#else
        stdASSERT(False, ("unexpected order modifier"));
#endif
    }

    stdASSERT(gblState->parseData->modifiers.ORDER != ptxNOORDER_MOD, ("expected non-weak order"));

    if (isMMEStorageInstruction(tcode)) {
        switch (gblState->parseData->storage[0].kind) {
        case ptxGenericStorage:
        case ptxGlobalStorage:
            break;
        case ptxSharedStorage:
            stdCHECK_WITH_POS(gblState->parseData->modifiers.ORDER != ptxMMIO_MOD,
                              (ptxMsgNoOrderOnSpace, sourcePos,
                               get_strORDER(gblState->parseData), get_strSTORAGE(gblState->parseData)));
            break;
        default:
            stdCHECK_WITH_POS(gblState->parseData->modifiers.ORDER == ptxWEAK_MOD, (ptxMsgNoOrderOnSpace, sourcePos,
                                      get_strORDER(gblState->parseData), get_strSTORAGE(gblState->parseData)));
            break;
        }

    }

    switch (gblState->parseData->modifiers.ORDER) {
    case ptxVOLATILE_MOD:
    case ptxWEAK_MOD:
    case ptxMMIO_MOD:
        return tcode == ptx_ld_Instr
            || tcode == ptx_st_Instr;
    case ptxACQUIRE_MOD:
        return tcode == ptx_atom_Instr
            || tcode == ptx_ld_Instr;
    case ptxRELEASE_MOD:
        return tcode == ptx_atom_Instr
            || tcode == ptx_red_Instr
            || tcode == ptx_st_Instr;
    case ptxACQREL_MOD:
        return tcode == ptx_atom_Instr
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
            || tcode == ptx_fence_Instr
#endif
            || False;

    case ptxSC_MOD:
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
        return tcode == ptx_fence_Instr;
#else
        return False;
#endif
    case ptxRELAXED_MOD:
        return tcode == ptx_atom_Instr
            || tcode == ptx_red_Instr
            || tcode == ptx_ld_Instr
            || tcode == ptx_st_Instr
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
            || tcode == ptx_barrier_cluster_arrive_Instr
#endif // HOPPER && INTERNAL
            ;
    }

    stdASSERT(False, ("unexpected memory order"));
    return False;
}

static void checkOrder(ptxParsingState gblState, ptxInstructionTemplate template,
                       String name, msgSourcePos_t sourcePos)
{
    int tcode = template->code;

    if (!ptxHasORDER_Feature(template->features)) {
        stdCHECK_WITH_POS(!gblState->parseData->modifiers.ORDER,
                          (ptxMsgIllegalModifier, sourcePos,
                           get_strORDER(gblState->parseData), name));
        return;
    }

    if (tcode == ptx_membar_Instr) {
        // FIXME: The following error check is ineffective. Any explicit order
        // is lost because membar is a macro. The current macro implementation
        // is such that unhandled gblState->parseData->modifiers are not passed through.
        if (gblState->parseData->modifiers.ORDER) {
            stdCHECK_WITH_POS(False, (ptxMsgIllegalModifier, sourcePos,
                                      get_strORDER(gblState->parseData), name));
            // Avoid assert when forcing ptxSC_MOD
            gblState->parseData->modifiers.ORDER = ptxNOORDER_MOD;
        }
        setOrderModifier(gblState, ptxSC_MOD, sourcePos);
        return;
    }

    if (!gblState->parseData->modifiers.ORDER) {
        // If no order was specified then set applicable defaults.
        if (tcode == ptx_atom_Instr || tcode == ptx_red_Instr) {
            setOrderModifier(gblState, ptxRELAXED_MOD, sourcePos);
            return;
        }

#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
        if (tcode == ptx_fence_Instr) {
            setOrderModifier(gblState, ptxACQREL_MOD, sourcePos);
        }
#endif
        return;
    }

    stdCHECK_WITH_POS(!gblState->parseData->modifiers.CACHEOP || gblState->parseData->modifiers.ORDER == ptxWEAK_MOD, (ptxMsgIllegalModifierPair, sourcePos,
                                           get_strORDER(gblState->parseData), get_strCACHEOP(gblState->parseData)));
    stdCHECK_WITH_POS(!gblState->parseData->modifiers.NC, (ptxMsgIllegalModifierPair, sourcePos,
                                      get_strORDER(gblState->parseData), get_strNC(gblState->parseData)));

    stdCHECK_WITH_POS(checkOrderForInst(gblState, tcode, name, sourcePos),
                      (ptxMsgIllegalModifier, sourcePos, get_strORDER(gblState->parseData), name));
}

static Bool checkScopeForInst(ptxParsingState gblState, ptxInstructionCode tcode,
                              String name, msgSourcePos_t sourcePos)
{
    if (tcode == ptx_membar_Instr) {
        if (gblState->parseData->modifiers.SCOPE == ptxSYS_MOD) {
            checkFeatureVersion(gblState, 2, 0, "membar.sys", sourcePos);
            stdCHECK_WITH_POS(checkTargetArch(gblState, 20), (ptxMsgSMVersionRequired,
                                                    sourcePos, "membar.sys",
                                                    "sm_20"));
        }
        return gblState->parseData->modifiers.SCOPE != ptxGPU_MOD;
    }

    if (gblState->parseData->modifiers.SCOPE == ptxGL_MOD) return False;

    if (tcode == ptx_atom_Instr || tcode == ptx_red_Instr) {
        stdCHECK_WITH_POS(checkTargetArch(gblState, 60),
                          (ptxMsgFeatureRequiresSMVersion, sourcePos,
                           "scopes on atomic operations", "sm_60"));
        checkFeatureVersion(gblState, 5, 0, "scopes on atomic operations", sourcePos);
        return True;
    }

#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    if (tcode == ptx_ld_Instr || tcode == ptx_st_Instr) {
        // We don't have to check versions here, since it is handled
        // in checkOrder.
        stdCHECK_WITH_POS(gblState->parseData->modifiers.ORDER,
                          (ptxMsgModifierRequiresFeature, sourcePos,
                           get_strSCOPE(gblState->parseData), "memory order", name));
        stdCHECK_WITH_POS(gblState->parseData->modifiers.ORDER != ptxVOLATILE_MOD,
                          (ptxMsgNoOrderOnSpace,sourcePos,
                           get_strORDER(gblState->parseData), get_strSCOPE(gblState->parseData)));
        return True;
    }

    stdASSERT(tcode == ptx_fence_Instr, (""));
    return True;
#endif // VOLTA

    // In release builds, atom and ld/st instructions will reach this point, but
    // we need to pretend that scopes are not supported for these instructions.
    return False;
}

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_COMPUTE_COMPILER_INTERNAL)
static void checkTextureInstrForMerlwry(ptxParsingState gblState, ptxInstruction instr)
{
    stdASSERT(ptxIsTextureInstr(instr->tmplate->code) || ptxIsTxqInstr(instr->tmplate->code),
              ("texture instruction expected"));

    // Texture instructions with relocations are not supported on ampere
    // merlwry path
    ptxSetNonMercFeatureUsed(gblState, ptxTexInstruction);

    if (ptxIsTexGradInstr(instr->tmplate->code)) {
        // tex.grad.3d/.lwbe/.alwbe not supported on merlwry
        if (gblState->parseData->modifiers.TEXTURE == ptx3D_MOD ||
            gblState->parseData->modifiers.TEXTURE == ptxLWBE_MOD ||
            gblState->parseData->modifiers.TEXTURE == ptxALWBE_MOD)
        {
            ptxSetNonMercFeatureUsed(gblState, ptxTexGrad3DLwbeAlwbe);
        }
        // tex.grad with depth compare not supported on merlwry
        if (ptxTexHasDepthCompareArg(gblState, instr)) {
            ptxSetNonMercFeatureUsed(gblState, ptxTexGradDepthCompare);
        }
    }
}
#endif

static void checkIfNoScope(ptxParsingState gblState, ptxInstructionTemplate template,
                           String name, msgSourcePos_t sourcePos)
{
    int tcode = template->code;

    if (tcode == ptx_membar_Instr) {
        stdCHECK_WITH_POS(False, (ptxMsgLevelModRequired, sourcePos, name));
        return;
    }

    if (gblState->parseData->modifiers.ORDER == ptxMMIO_MOD) {
        stdCHECK_WITH_POS(False,
                          (ptxMsgModifierRequiresFeature, sourcePos,
                           get_strORDER(gblState->parseData), "scope", name));
        return;
    }

#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    if (tcode == ptx_fence_Instr) {
        stdCHECK_WITH_POS(False,(ptxMsgModifierRequired, sourcePos,
                                 "Scope", name));

    }
#endif

    if (tcode == ptx_atom_Instr || tcode == ptx_red_Instr)
    {
         if (gblState->parseData->modifiers.ORDER != ptxMMIO_MOD) {
              gblState->parseData->modifiers.SCOPE = ptxGPU_MOD;
              return;
         }
    }

    if (gblState->parseData->modifiers.ORDER && gblState->parseData->modifiers.ORDER != ptxVOLATILE_MOD
        && gblState->parseData->modifiers.ORDER != ptxWEAK_MOD)
    {
        stdCHECK_WITH_POS(False,
                          (ptxMsgModifierRequiresFeature, sourcePos,
                           get_strORDER(gblState->parseData), "scope", name));
        return;
    }

    return;
}

static void checkScope(ptxParsingState gblState, ptxInstructionTemplate template,
                       String name, msgSourcePos_t sourcePos)
{
    int tcode = template->code;

    if (!ptxHasSCOPE_Feature(template->features)) {
        stdCHECK_WITH_POS(!gblState->parseData->modifiers.SCOPE, (ptxMsgIllegalModifier, sourcePos,
                                             get_strSCOPE(gblState->parseData), name));
        return;
    }

    if (gblState->parseData->modifiers.ORDER == ptxVOLATILE_MOD || gblState->parseData->modifiers.ORDER == ptxWEAK_MOD) {
        stdCHECK_WITH_POS(!gblState->parseData->modifiers.SCOPE,
                          (ptxMsgIllegalModifierPair,sourcePos, get_strORDER(gblState->parseData),
                           get_strSCOPE(gblState->parseData)));
        return;
    }
    // Enforce defaults
    if (!gblState->parseData->modifiers.SCOPE) {
         checkIfNoScope(gblState, template, name, sourcePos);
         return;
    }

    stdCHECK_WITH_POS(checkScopeForInst(gblState, tcode, name, sourcePos),
                      (ptxMsgIllegalModifier, sourcePos, get_strSCOPE(gblState->parseData), name));
}

static Bool isVectorAType(ptxArgumentType type)
{
    switch (type) {
    case ptxU16AType:
    case ptxS32AType:
    case ptxF32AType:
    case ptxB32AType:
    case ptxB64AType:
    case ptxPredicateVectorAType:
        return True;
    default:
        return False;
    }
}

static void checkArgsForLdStInstr(ptxParsingState gblState, ptxInstructionTemplate template, uInt tcode, cString name, msgSourcePos_t sourcePos)
{
    Bool hasDescOrCachehintMod = ptxHasDESC_MOD(gblState->parseData->modifiers) || ptxHasCACHEHINT_MOD(gblState->parseData->modifiers);
    uInt correctArgs = hasDescOrCachehintMod ? 3 : 2;
    if (gblState->parseData->nrofArguments > correctArgs) {
        printErrorForDESCOrCACHEHINTRequired(template, gblState->parseData->nrofArguments, name, sourcePos);
    }
    stdCHECK_WITH_POS(gblState->parseData->nrofArguments == correctArgs,
                      (ptxMsgNonMatchingInstrArgs, sourcePos, name));
}

static void checkArgsForAtomRedInstr(ptxParsingState gblState, ptxInstruction instr, msgSourcePos_t sourcePos)
{
    uInt correctNumArgs;
    Bool isRedInstr = (instr->tmplate->code == ptx_red_Instr);
    Bool hasDescOrCachehintMod = ptxHasDESC_MOD(gblState->parseData->modifiers) || ptxHasCACHEHINT_MOD(gblState->parseData->modifiers);
    Bool hasRequiredModError = False;

    if (isRedInstr) {
        correctNumArgs = hasDescOrCachehintMod ? 3 : 2;
        hasRequiredModError = (gblState->parseData->nrofArguments > correctNumArgs);
    } else if (ptxHasCAS_Feature(instr->tmplate->features)) {
        correctNumArgs = 4;
    } else {
        correctNumArgs = hasDescOrCachehintMod ? 4 : 3;
        hasRequiredModError = (gblState->parseData->nrofArguments > correctNumArgs);
    }

    if (hasRequiredModError) {
        printErrorForDESCOrCACHEHINTRequired(instr->tmplate, gblState->parseData->nrofArguments, instr->tmplate->name, sourcePos);
    }
    stdCHECK_WITH_POS(instr->tmplate->nrofArguments == correctNumArgs,
                      (ptxMsgNonMatchingInstrArgs, sourcePos, instr->tmplate->name));
}

static void checkAtomRedInstruction(ptxParsingState gblState, ptxInstruction instr, msgSourcePos_t sourcePos)
{
    // check ATOM/RED constraints
    // sm_{10,11} supports 32-bit instruction types
    // global is sm_11+, .shared is sm_12+
    // sm_12+ adds support for 64-bit types (e.g. add.u64, {cas,exch}.b64)
    // 64-bit implies .global for sm_1x.
    // sm_20 supports 64-bit atomic ops on generic, global, and shared state spaces.
    // and/or/xor  are .b32 only; sm_32+ allows .b64
    // cas/exch    are .b32 only through sm_11
    //             sm_12+ allows .b64
    //             sm_70+ allows .b16
    //             are .global only for sm_1x, sm_20 allows generic and shared
    //             are not supported by RED
    // add         allows .u32, .s32 through sm_11, sm_12+ allows u64, sm_20+ allows .f32,
    //             sm_90+ allows .bf16 and .bf16x2
    // inc/dec     are .u32 only
    // min/max     allow .u32, .s32; sm_32+ allows .u64, .s64
    // safeadd     allow .u64 only, not supported by RED
    // noftz       allowed from sm_70 && PTX ISA 6.3 with .f16
    //             allowed with f16x2 on PTX ISA 6.2
    //             allowed from sm_90 && PTX ISA 7.2 (Internal) with .bf16 and .bf16x2

    uInt tcode = instr->tmplate->code;
    String name = instr->tmplate->name;
    String storeMessage = gblState->parseData->storage[0].kind == ptxGenericStorage ? " with generic state space" : get_strSTORAGE(gblState->parseData);
    String typeMessage = "";
    uInt minSM = 11, minorPTXVersion = 1, majorPTXVersion = 0;
    Bool isCorrectInstructionType = False;
    Bool isUsesBF16Type = False;
    Bool isUsesBF16x2Type = False;
    String typeAsString = "";

    if (tcode == ptx_red_Instr) {
        // RED instruction introduced in PTX .version 1.2
        checkFeatureVersion(gblState, 1, 2, name, sourcePos);
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        stdCHECK_WITH_POS(!(gblState->parseData->postop == ptxCASOp || gblState->parseData->postop == ptxEXCHOp
                            || gblState->parseData->postop == ptxSAFEADDOp),
                          (ptxMsgIllegalOp, sourcePos, get_strPOSTOP(gblState->parseData), name));
#else
        stdCHECK_WITH_POS(!(gblState->parseData->postop == ptxCASOp || gblState->parseData->postop == ptxEXCHOp),
                          (ptxMsgIllegalOp, sourcePos, get_strPOSTOP(gblState->parseData), name));
#endif
    } else {
        // ATOM instruction requires sm_11+
        stdCHECK_WITH_POS(checkTargetArch(gblState, 11),
                          (ptxMsgSMVersionRequired, sourcePos, name, "sm_11"));
    }

    // Exiting early if state space is wrong to avoid printing unrealted errors
    // which can potentially print out state space
    if (!checkMemSpaceUsage(gblState, tcode, gblState->parseData->storage[0].kind, 0)) {
        return;
    }

    // check shared shared requires sm_12+
    stdCHECK_WITH_POS((gblState->parseData->storage[0].kind != ptxSharedStorage || checkTargetArch(gblState, 12)),
                      (ptxMsgFeatureRequiresSMVersion, sourcePos,
                       "shared storage", "sm_12"));

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_62)
    if (isF16x2(instr->type[0])) {
        stdCHECK_WITH_POS(gblState->parseData->modifiers.NOFTZ,
                          (ptxMsgModifierRequiredWithType, sourcePos,
                           getNOFTZAsString(ptxEXPLICIT_NOFTZ_MOD), name,
                           getTypeEnumAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxTypeF16x2)));
    }
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    else if (isF16(instr->type[0])) {
        stdCHECK_WITH_POS(gblState->parseData->modifiers.NOFTZ,
                          (ptxMsgModifierRequiredWithType, sourcePos,
                           getNOFTZAsString(ptxEXPLICIT_NOFTZ_MOD), name,
                           getTypeEnumAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxTypeF16)));
    }
#endif
#endif

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_FUTURE)
    isUsesBF16Type   = isBF16(instr->type[0]);
    isUsesBF16x2Type = isBF16x2(instr->type[0]);
    if (isUsesBF16Type || isUsesBF16x2Type) {
        stdCHECK_WITH_POS(gblState->parseData->modifiers.NOFTZ,
                          (ptxMsgModifierRequiredWithType, sourcePos,
                           getNOFTZAsString(ptxEXPLICIT_NOFTZ_MOD), name,
                           getTYPEAsString(gblState->parseData->deobfuscatedStringMapPtr,
                                           gblState->parseData->instructionType[0])));
    }
#endif // HOPPER, FUTURE

    switch (gblState->parseData->postop) {
    case ptxANDOp:
    case ptxOROp:
    case ptxXOROp:
        // atom/red.{and,or,xor}.b64 requires :
        // sm_32 target with isa version 4.0 or sm_35 target with isa version 3.1
        // so we check for minimum target of sm_32 and min isa version of 3.1
        if (isB64(instr->type[0])) {
            minSM = 32;
            majorPTXVersion = 3;
            minorPTXVersion = 1;
        }
        // check type for atom/red.{and,or,xor}
        isCorrectInstructionType = isB32(instr->type[0]) || isB64(instr->type[0]);
        typeMessage = ".b32 or .b64";
       break;
    case ptxCASOp:
        if (tcode == ptx_atom_Instr) {
            // check type and space for atom.cas
            if (isB64(instr->type[0])) {
                if (gblState->parseData->storage[0].kind == ptxSharedStorage) {
                    // 64-bit atom.shared.{cas,exch} requires PTX 2.0, sm_20
                    minSM = 20;
                    majorPTXVersion = 2;
                    minorPTXVersion = 0;
                } else if (gblState->parseData->storage[0].kind == ptxGlobalStorage) {
                    // 64-bit atom.global.{add,cas,exch} requires PTX 1.2, sm_12
                    minSM = 12;
                    majorPTXVersion = 1;
                    minorPTXVersion = 2;
                }
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
            } else if (isB16(instr->type[0])) {
                // atom.cas.b16 requires PTX 6.3, sm_70
                minSM = 70;
                majorPTXVersion = 6;
                minorPTXVersion = 3;
#endif
            }
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
            isCorrectInstructionType = isB16(instr->type[0]) || isB32(instr->type[0])
                                       || isB64(instr->type[0]);
            typeMessage = ".b16 or .b32 or .b64";
#else
            isCorrectInstructionType = isB32(instr->type[0]) || isB64(instr->type[0]);
            typeMessage = ".b32 or .b64";
#endif
        }
        break;
    case ptxEXCHOp:
        if (tcode == ptx_atom_Instr) {
            // check type and space for 64-bit atom.exch
            if (isB64(instr->type[0])) {
                if (gblState->parseData->storage[0].kind == ptxSharedStorage) {
                    // 64-bit atom.shared.{cas,exch} requires PTX 2.0, sm_20
                    minSM = 20;
                    majorPTXVersion = 2;
                    minorPTXVersion = 0;
                } else if (gblState->parseData->storage[0].kind == ptxGlobalStorage) {
                    // 64-bit atom.global.{add,cas,exch} requires PTX 1.2, sm_12
                    minSM = 12;
                    majorPTXVersion = 1;
                    minorPTXVersion = 2;
                }
            }

            isCorrectInstructionType = isB32(instr->type[0]) || isB64(instr->type[0]);
            typeMessage = ".b32 or .b64";
        }
        break;
    case ptxADDOp:
        // check type for atom/red.add
        if (isF32(instr->type[0])) {
            minSM = 20;
            majorPTXVersion = 2;
            minorPTXVersion = 0;
        } else if (isF64(instr->type[0])) {
            // {atom,red}.add.f64 requires PTX 5.0, sm_60
            minSM = 60;
            majorPTXVersion = 5;
            minorPTXVersion = 0;
        } else if (isU64(instr->type[0])) {
            if (gblState->parseData->storage[0].kind == ptxSharedStorage) {
                // 64-bit {atom,red}.shared.add requires PTX 2.0, sm_20
                minSM = 20;
                majorPTXVersion = 2;
                minorPTXVersion = 0;
            } else if (gblState->parseData->storage[0].kind == ptxGlobalStorage) {
                // 64-bit atom.global.{add,cas,exch} requires PTX 1.2, sm_12
                minSM = 12;
                majorPTXVersion = 1;
                minorPTXVersion = 2;
            }
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
        } else if (isF16(instr->type[0])) {
            // {atom,red}.add.f16.noftz requires PTX 6.3, sm_70
            minSM = 70;
            majorPTXVersion = 6;
            minorPTXVersion = 3;
#endif
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_62)
        } else if (isF16x2(instr->type[0])) {
            // {atom,red}.add.f16x2.noftz requires PTX 6.2, sm_60
            minSM = 60;
            majorPTXVersion = 6;
            minorPTXVersion = 2;
#endif
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_FUTURE)
        } else if (isUsesBF16Type || isUsesBF16x2Type) {
            // FIXME: Update target/version check
            // {atom,red}.add.{bf16/bf16x2}.noftz requires PTX 7.4 (FUTURE), sm_90
            minSM = 90;
            majorPTXVersion = 7;
            minorPTXVersion = 4;
#endif // HOPPER && FUTURE
        }
#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
            typeMessage = ".u32 or .s32 or .u64 or .f64 or f16 or f16x2 or .f32";
            isCorrectInstructionType = isI32(instr->type[0]) || isU64(instr->type[0])
                                       || isF64(instr->type[0]) || isF16(instr->type[0])
                                       || isF16x2(instr->type[0]) || isF32(instr->type[0]);
#elif LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_62)
            typeMessage = ".u32 or .s32 or .u64 or .f64 or f16x2 or .f32";
            isCorrectInstructionType = isI32(instr->type[0]) || isU64(instr->type[0])
                                       || isF64(instr->type[0]) || isF16x2(instr->type[0])
                                       || isF32(instr->type[0]);
#else
            typeMessage = ".u32 or.s32 or .u64 or .f64 or .f32";
            isCorrectInstructionType = isI32(instr->type[0])
                                       || isU64(instr->type[0])
                                       || isF64(instr->type[0])
                                       || isF32(instr->type[0]);
#endif
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_FUTURE)
        isCorrectInstructionType = (isCorrectInstructionType ||
                                    isUsesBF16Type           ||
                                    isUsesBF16x2Type);
        typeMessage = stdCONCATSTRING(typeMessage, " or .bf16 or .bf16x2");
#endif // HOPPER && FUTURE
        break;
    case ptxINCOp:
    case ptxDECOp:
        typeMessage = ".u32";
        isCorrectInstructionType = isU32(instr->type[0]);
        break;
    case ptxMINOp:
    case ptxMAXOp:
        // PTX 3.1: {atom,red}.{min,max}.u64 requires sm_32 target, isa version 3.1
        if (isI64(instr->type[0])) {
            minSM = 32;
            majorPTXVersion = 3;
            minorPTXVersion = 1;
        }
        typeMessage = ".u32 or .s32 or .u64 or .s64";
        isCorrectInstructionType = isI64(instr->type[0]) || isI32(instr->type[0]);
        break;
    case ptxSAFEADDOp:
        if (tcode == ptx_atom_Instr) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
            if (isU64(instr->type[0])) {
                // atom.safeadd requires sm_35 target, isa version 3.1
                minSM = 35;
                majorPTXVersion = 3;
                minorPTXVersion = 1;
            }
            typeMessage = ".u64";
            isCorrectInstructionType = isU64(instr->type[0]);
#else
           stdCHECK_WITH_POS(False,
                             (ptxMsgUnknownModifier, sourcePos,
                              get_strPOSTOP(gblState->parseData)));
#endif
        }
        break;
    case ptxNOP:
    case ptxLTOp:
    case ptxLTEQOp:
    case ptxGTOp:
    case ptxGTEQOp:
    case ptxEQOp:
    case ptxNEQOp:
    case ptxOROROp:
    case ptxANDANDOp:
    case ptxSUBOp:
    case ptxSHLOp:
    case ptxSHROp:
    case ptxMULOp:
    case ptxDIVOp:
    case ptxREMOp:
    case ptxNOTOp:
    case ptxILWOp:
    case ptxPOPCOp:
    default:
        stdCHECK_WITH_POS(False,
                          (ptxMsgIllegalOp, sourcePos, get_strPOSTOP(gblState->parseData), name));
    }

    if (gblState->parseData->nrofInstructionTypes > 0 && instr->type[0]) {
        typeAsString = getTYPEAsString(gblState->parseData->deobfuscatedStringMapPtr, instr->type[0]);
    } else if (gblState->parseData->nrofInstructionTypes == 0) {
        // At least one type is expected for atom/red.
        stdCHECK_WITH_POS(False,
                          (ptxMsgNonMatchingInstrTypes, sourcePos, name));
        typeAsString = "";
    } else {
        stdASSERT(False, ("Unexpected type"));
    }

    stdCHECK_WITH_POS(checkTargetArch(gblState, minSM),
                      (ptxMsgSMVersionRequired2, sourcePos, name,
                       get_strPOSTOP(gblState->parseData), typeAsString, storeMessage, minSM));
    stdCHECK_WITH_POS(checkFeatureVersion1(gblState, majorPTXVersion, minorPTXVersion),
                      (ptxMsgInstRequiresPTXVersion, sourcePos, name,
                       get_strPOSTOP(gblState->parseData),typeAsString, storeMessage,
                       majorPTXVersion, minorPTXVersion));
    stdCHECK_WITH_POS(isCorrectInstructionType,
                      (ptxMsgOpRequiresType, sourcePos, get_strPOSTOP(gblState->parseData),
                       typeMessage, name));

    checkArgsForAtomRedInstr(gblState, instr, sourcePos);

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_FUTURE)
    if (isUsesBF16Type || isUsesBF16x2Type) {
        if (tcode == ptx_red_Instr) {
            // Arguments of form: M[x/d]{U}
            checkInstructionArgsForBF16(gblState, instr->tmplate, name, 1, 2,
                                        gblState->parseData->arguments, sourcePos);
        } else {
            // Arguments of form: [x/d]M[x/d]{U}
            checkInstructionArgsForBF16(gblState, instr->tmplate, name, 0, 1,
                                        gblState->parseData->arguments, sourcePos);
            checkInstructionArgsForBF16(gblState, instr->tmplate, name, 2, 3,
                                        gblState->parseData->arguments, sourcePos);
        }
    }
#endif // HOPPER && FUTURE
}

static void recognizeRealInstruction(ptxParsingState gblState, String name, ptxInstructionTemplate template,
                                     Bool errorCheckOnly, msgSourcePos_t sourcePos )
{
    uInt i, tcode;
    uInt vectorMode  = gblState->parseData->modifiers.VECTOR;
    uInt textureGeom = gblState->parseData->modifiers.TEXTURE;
    uInt vectorSize = ptxGetVectorSize(gblState->parseData->modifiers);

    ptxInstruction instr;

    if (!template)  {
        return;
    } else {
        tcode = template->code;
    }

    stdNEW(instr);

   /*
    * reserve 1 symbolic byte for each instruction
    * This is a psuedo address that this parser maintains
    * and will later be translated using an instruction 
    * space translation table retrieved from OCG
    */
    instr->virtualAddress  = gblState->virtualSize[ ptxCodeStorage ]++;
    instr->stmtId          = gblState->lwrSymbolTable->numStmts;

    instr->tmplate         = template;
    instr->cmp             = gblState->parseData->cmp;
    instr->postop          = gblState->parseData->postop;
    instr->nrofStorage     = gblState->parseData->nrofInstrMemspace;
    instr->storage         = stdCOPY_N( gblState->parseData->storage,         stdMAX(1,gblState->parseData->nrofInstrMemspace)  );
    instr->guard           = gblState->parseData->guard;
    instr->predicateOutput = gblState->parseData->predicateOutput;
    instr->arguments       = stdCOPY_N( gblState->parseData->arguments,       template->nrofArguments  );

    // instr->modifiers is overwritten again in the end as gblState->parseData->modifiers may be modified.
    // However initialize it explicitly here so functions can still refer to
    // instr->modifiers when required e.g. ptxTexHasOffsetArg() use
    // instr->modifiers internally
    instr->modifiers       = gblState->parseData->modifiers;

    // FIXME: Ensure at least one type is initialized for every instruction.
    //        This is needed as code in DAG generation(for instructions like _ldsm, cctl)
    //        has hacks where instr->type[0] is overwritten to work with rest of
    //        DAG common routines like ptxOptExprDag, ptxOptIndirectStore.
    //        This is meant to be short term WAR till we can refactor DAG
    //        code to not rely on this.
    instr->type            = stdCOPY_N( gblState->parseData->instructionType, stdMAX(1, template->nrofInstrTypes));
    instr->loc             = NULL;
    if (isPtxUserInput(msgGetFileName(sourcePos))) {
        ptxCodeLocation ptxLoc;

        stdNEW(ptxLoc);
        ptxLoc->lwrLoc.fileIndex = 0;
        ptxLoc->lwrLoc.lineNo    = sourcePos->lineNo;
        ptxLoc->lwrLoc.linePos   = 0;
        ptxLoc->functionName     = NULL;
        ptxLoc->inlineAtLoc      = NULL;
        instr->loc        = ptxLoc;

        if (gblState->parseData->lwrSourceCodeLocation->lwrLoc.lineNo != 0) {
            if (gblState->parseData->firstInstrSourcePos == -1) {
                gblState->parseData->firstInstrSourcePos = sourcePos->lineNo;
            }
            gblState->parseData->lastInstrSourcePos = sourcePos->lineNo;
        }
        if (gblState->parseData->nextSourceCodeLocation) {
            // assign label's source code location with location of its associated instruction
            gblState->parseData->nextSourceCodeLocation->lwrLoc.fileIndex = gblState->parseData->lwrSourceCodeLocation->lwrLoc.fileIndex;
            gblState->parseData->nextSourceCodeLocation->lwrLoc.lineNo    = gblState->parseData->lwrSourceCodeLocation->lwrLoc.lineNo;
            gblState->parseData->nextSourceCodeLocation->lwrLoc.linePos   = gblState->parseData->lwrSourceCodeLocation->lwrLoc.linePos;
            gblState->parseData->nextSourceCodeLocation->functionName     = gblState->parseData->lwrSourceCodeLocation->functionName;
            gblState->parseData->nextSourceCodeLocation->inlineAtLoc      = gblState->parseData->lwrSourceCodeLocation->inlineAtLoc;

            // reset label's source code location for next label
            gblState->parseData->nextSourceCodeLocation = NULL;
        }
    }
    if (!errorCheckOnly) {
        // When errorCheckOnly flag is set we do not add instruction into IR
        // instead we do only error checks.This is WAR added for macro instructions
        // to ensure that all error checks are happening for source instruction.
        ptxAddStatement( gblState->lwrSymbolTable, ptxCreateInstructionStatement(instr) );
    }


   /*
    * Handle postoperationclass overlap:
    */
    if (ptxHasATOMIC_Feature(template->features) && (gblState->parseData->postopclass&AtomicOperations)) { gblState->parseData->postopclass = AtomicOperationClass; }


    /*
     * Perform .target-specific instruction checks:
     */

    // .f64 requires sm_13+ or .target map_f64_to_f32
    if (!gblState->parseData->isF64Allowed) {
        for (i=0; i<template->nrofInstrTypes; i++) {
            if (isF64(instr->type[i])) {
                stdCHECK_WITH_POS(False, (ptxMsgFPRequired,sourcePos,name));
                if (gblState->warn_on_double_demotion) {
                    stdCHECK_WITH_POS(False, (ptxMsgDoubleToFloat,sourcePos));
                    gblState->warn_on_double_demotion = False;
                }
            }
        }
    }

    // Warn if double data type used and clear the flag
    stdCHECK_WITH_POS(stdIMPLIES(gblState->warn_on_double_use, !gblState->parseData->doubleUse), (ptxMsgDoubleUse, sourcePos));

    // Reset "doubleUse" so that it can be used for next instruction.
    gblState->parseData->doubleUse = False;

    if (tcode == ptx_bra_Instr) {
        ptxExpression arg;

        arg = gblState->parseData->arguments[0];
        stdCHECK_WITH_POS(arg->kind==ptxLabelReferenceExpression ||
                          (arg->kind==ptxSymbolExpression
                           && arg->cases.Symbol.symbol->kind == ptxLabelSymbol),
                          (ptxMsgLabelExpected,sourcePos,0,name));
    }

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    if (tcode == ptx_brx_idx_Instr) {
        ptxExpression arg = gblState->parseData->arguments[1];
        stdCHECK_WITH_POS(arg->kind==ptxSymbolExpression
                          && arg->cases.Symbol.symbol->kind == ptxBranchTargetSymbol,
                          (ptxMsgBranchTargetExpected,sourcePos,1,name));
    }
#endif

    if (tcode == ptx_call_Instr) {
        uInt                   idx = getCallTargetIdx(gblState);
        ptxExpression          arg = gblState->parseData->arguments[idx];
        ptxSymbolTableEntry    symbol;
        ptxSymbolTableEntryAux aux;
        String                 funcName;

        // ptxLabelReferenceExpression implies a undeclared function
        if (arg->kind == ptxLabelReferenceExpression) {
            stdCHECK_WITH_POS( False, (ptxMsgCallPrototypeRequired,sourcePos,arg->cases.LabelReference->name) );
            return;
        }
        stdASSERT(arg->kind == ptxSymbolExpression, (""));
        symbol = ptxGetSymEntFromExpr(arg);
        funcName = symbol->symbol->name;

        if (isDirectCall(gblState->parseData->arguments, gblState->parseData->nrofArguments)) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
            if (!ptxIsBuiltinFunc(gblState->parseData, funcName)) {
#endif
                stdCHECK_WITH_POS( arg->kind==ptxSymbolExpression && arg->type->kind==ptxLabelType, (ptxMsgLabelExpected,sourcePos,0,name) ) {
                    aux = arg->cases.Symbol.symbol->aux;

                    stdCHECK_WITH_POS( (arg->kind == ptxSymbolExpression && arg->cases.Symbol.symbol->kind == ptxFunctionSymbol && !aux->isEntry),
                                       (ptxMsgIllegalCalltarget,sourcePos) );

                    // update ABI flags
                    gblState->callsExternFunc |= (arg->cases.Symbol.symbol->scope == ptxExternalScope);

                    // if call is missing either the return or argument parameter list, verify that callee has corresponding null list
                    stdCHECK_WITH_POS( stdIMPLIES( idx==0, listSize(aux->funcProtoAttrInfo->rparams)==0 ), (ptxMsgCallNArgsDiffer,sourcePos) ) {
                        stdCHECK_WITH_POS( stdIMPLIES( idx==gblState->parseData->nrofArguments-1, listSize(aux->funcProtoAttrInfo->fparams)==0 ), (ptxMsgCallNArgsDiffer,sourcePos) );
                    }
                    if (ptxIsInternalSource(gblState->lwrInstrSrc)) {
                       scheduleMacroUtilFuncForParsing(arg->cases.Symbol.symbol->symbol->unMangledName, gblState);
                    }
                    if (!aux->funcProtoAttrInfo->hasAllocatedParams) {
                        gblState->usesFuncWithMultipleRets |= listSize(aux->funcProtoAttrInfo->rparams) > 1;
                    }
                }
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
            }
#endif
        } else {
            Bool isRegArgExpected = True;
            Bool isExpectedArrType;
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
            cString expectedArrTypeStr = ".u32/.u64/.u8";
#else
            cString expectedArrTypeStr = ".u32/.u64";
#endif
            checkFeatureVersion(gblState, 2, 1, "indirect call", sourcePos);
            stdCHECK_WITH_POS( checkTargetArch(gblState, 20), (ptxMsgSMVersionRequired,sourcePos,"indirect call","sm_20") );
            stdASSERT( !ptxIsInternalSource(gblState->lwrInstrSrc), ("indirect call unsupported in macro body") );

            isRegArgExpected = arg->kind==ptxSymbolExpression &&
                               (arg->cases.Symbol.symbol->storage.kind==ptxRegStorage
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
                                || ptxIsBuiltinFunc(gblState->parseData, funcName)
#endif
                               );
            stdCHECK_WITH_POS(isRegArgExpected, (ptxMsgRegisterExpected,sourcePos,idx,name) );

            arg = gblState->parseData->arguments[gblState->parseData->nrofArguments-1];

            isExpectedArrType = False;
            if (arg->kind==ptxSymbolExpression && arg->type->kind==ptxArrayType) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
                isExpectedArrType = (isU32(arg->type->cases.Array.base) || isU64(arg->type->cases.Array.base)
                                     || isU8(arg->type->cases.Array.base));
#else
                isExpectedArrType = (isU32(arg->type->cases.Array.base) || isU64(arg->type->cases.Array.base));
#endif
            }
            // Fatal error.
            stdCHECK_WITH_POS( (arg->kind==ptxSymbolExpression && arg->type->kind==ptxLabelType) ||
                               (arg->kind==ptxSymbolExpression && arg->type->kind==ptxArrayType && isExpectedArrType),
                               (ptxMsgLabelOrArrayExpected,sourcePos,expectedArrTypeStr,gblState->parseData->nrofArguments-1,name) );
            // Fatal error.
            stdCHECK_WITH_POS( stdIMPLIES(arg->kind==ptxSymbolExpression && arg->type->kind==ptxArrayType,
                                          arg->cases.Symbol.symbol->storage.kind==ptxConstStorage || arg->cases.Symbol.symbol->storage.kind==ptxGlobalStorage),
                               (ptxMsgConstOrGlobalArrayExpected,sourcePos,gblState->parseData->nrofArguments-1,name) );

            // update ABI flags
            gblState->usesFuncPointer = True;

            // if call is missing either the return or argument parameter list, verify that callee has corresponding null list
            // . first get aux structure, so that we can access the rparams and fparams lists
            //   case 1: arg is name of call table (array) or label of .calltargets directive.  Get aux structure from first callee in table/list's initializer list
            //   case 2: arg is label of .callprototype directive, so aux is stored directly in label's symtab entry
            aux = NULL;

            // Fatal error.
            stdCHECK_WITH_POS(arg->kind == ptxSymbolExpression,
                              (ptxMsgCallTargetUnrecognized, sourcePos));
            symbol = arg->cases.Symbol.symbol;
            if (symbol->kind == ptxCallTargetSymbol
                || symbol->kind == ptxVariableSymbol)
            { // case 1: call table or .calltargets directive
                ptxInitializer ival  = symbol->initialValue;
                stdList_t flist;

                stdCHECK_WITH_POS(ival, (ptxMsgInitValExpected, sourcePos,
                                         symbol->symbol->name));
                flist = ival->cases.Structured.list;

                if (flist) {
                    ptxExpression sym;
                    ival = flist->head;

                    // Fatal error.
                    stdCHECK_WITH_POS(ival->kind == ptxExpressionInitializer,
                                      (ptxMsgCallTargetUnrecognized, sourcePos));
                    sym = ival->cases.Expression.expr;

                    // Fatal error.
                    stdCHECK_WITH_POS(sym->kind == ptxSymbolExpression,
                                      (ptxMsgCallTargetUnrecognized, sourcePos));
                    aux = sym->cases.Symbol.symbol->aux;
                }
            } else { // case 2: .callprototype directive
                stdCHECK_WITH_POS(symbol->kind == ptxCallPrototypeSymbol,
                                  (ptxMsgCallTargetUnrecognized, sourcePos));
                aux = symbol->aux;
            }

            // Fatal error.
            stdCHECK_WITH_POS(aux, (ptxMsgCallTargetUnrecognized, sourcePos));

            stdCHECK_WITH_POS( stdIMPLIES( idx==0, listSize(aux->funcProtoAttrInfo->rparams)==0 ), (ptxMsgCallNArgsDiffer,sourcePos) );
            stdCHECK_WITH_POS( stdIMPLIES( idx==gblState->parseData->nrofArguments-2, listSize(aux->funcProtoAttrInfo->fparams)==0 ), (ptxMsgCallNArgsDiffer,sourcePos) );
            if (!aux->funcProtoAttrInfo->hasAllocatedParams) {
                gblState->usesFuncWithMultipleRets |= listSize(aux->funcProtoAttrInfo->rparams) > 1;
            }
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_COMPUTE_COMPILER_INTERNAL)
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
            if (ptxIsOcgBuiltinGenomicsFunc(gblState->parseData, funcName)) {
                ptxSetNonMercFeatureUsed(gblState, ptxGenomics);
            }
#endif
#endif
        }
    }
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_COMPUTE_COMPILER_INTERNAL)
    // Check Texture support for merlwry
    if (ptxIsTextureInstr(tcode) || ptxIsTxqInstr(tcode)) {
        checkTextureInstrForMerlwry(gblState, instr);
    }
#endif
    /*
     *   Vector type consistency check
     */
    for (i = 0; i < gblState->parseData->nrofArguments; i++) {
        if (gblState->parseData->arguments[i]->kind == ptxVectorExpression) {
            stdList_t vecElements = gblState->parseData->arguments[i]->cases.Vector.elements;
            ptxExpression lwrElement;
            ptxType prevType = NULL;

            if (ptxIsTextureInstr(instr->tmplate->code) && (i == ptxTexComponentArgNumber(gblState, instr, TEX_COMPONENT_TYPE_COORDS)) && 
                (ptxIsTexSurfInstrUsesArrayModifier(gblState->parseData->modifiers)))
            {
                if (textureGeom == ptxA2DMS_MOD) {
                    vecElements = vecElements->tail;
                }
                lwrElement = vecElements->head;
                // Array index must be .u32
                stdCHECK_WITH_POS(isI32(lwrElement->type) || isB32(lwrElement->type) || lwrElement->kind == ptxIntConstantExpression,
                                  (ptxMsgArrayIndexTypeMismatch, sourcePos, name));
                vecElements = vecElements->tail;
            }

            for ( ; vecElements != NULL; vecElements = vecElements->tail) {
                lwrElement = vecElements->head;

                if (lwrElement->kind == ptxSinkExpression) {
                    continue;
                }
                if (prevType == NULL) {                 // In case of sink expression seen previously
                    prevType = lwrElement->type;
                }
                stdCHECK_WITH_POS(compareTypes(lwrElement->type->kind, prevType->kind), (ptxMsgVaryingVectorType, sourcePos, name));
                prevType = lwrElement->type;
            }
        }
    }

    /*
     * Instruction-specific checks:
     */

    stdCHECK_WITH_POS(
            stdIMPLIES(gblState->parseData->modifiers.SCOPE, ptxHasSCOPE_Feature(template->features)),
            (ptxMsgIllegalModifier, sourcePos, get_strSCOPE(gblState->parseData), name)
    );

    if (tcode == ptx_atom_Instr || tcode == ptx_red_Instr) {
        checkAtomRedInstruction(gblState, instr, sourcePos);
    }

    if (tcode == ptx_membar_Instr) {
        // membar.{cta,gl,sys}
        checkFeatureVersion(gblState, 1, 4, name, sourcePos);

        // membar.{cta,gl,sys}.ilwall
        //
        if (gblState->parseData->modifiers.CACHEOP == ptxILWALL_MOD) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
            stdCHECK_WITH_POS( checkTargetArch(gblState, 50), (ptxMsgSMVersionRequired,sourcePos,"membar.ilwall","sm_50") );
            checkFeatureVersion(gblState, 4, 0, "membar.ilwall", sourcePos);
#else
            stdCHECK_WITH_POS(False, (ptxMsgIllegalModifier, sourcePos,
                                       get_strCACHEOP(gblState->parseData), name));
#endif
        }
    }

    // tex.grad instruction requires dpdx/dpdy argument to be of vector type.
    if (ptxIsTexGradInstr(tcode)) {
        // Use dsdx (or dsdy) as it corresponds to first component in dpdx(or dpdy) vector.
        int dpdxArgNum = ptxTexComponentArgNumber(gblState, instr, TEX_COMPONENT_TYPE_DSDX);
        int dpdyArgNum = ptxTexComponentArgNumber(gblState, instr, TEX_COMPONENT_TYPE_DSDY);
        stdASSERT(gblState->parseData->nrofArguments >= dpdyArgNum,
                  ("Insufficient arguments."));
        stdCHECK_WITH_POS((gblState->parseData->arguments[dpdxArgNum]->type->kind == ptxVectorType),
                          (ptxMsgVectorArgumentExpected, sourcePos, dpdxArgNum));
        stdCHECK_WITH_POS((gblState->parseData->arguments[dpdyArgNum]->type->kind == ptxVectorType),
                          (ptxMsgVectorArgumentExpected, sourcePos, dpdyArgNum));
    }

    // BRKPT instruction requires SM_11 or higher
    stdCHECK_WITH_POS( tcode != ptx_brkpt_Instr || checkTargetArch(gblState, 11), (ptxMsgSMVersionRequired,sourcePos,name,"sm_11") );

    stdCHECK_WITH_POS( stdIMPLIES( (tcode==ptx_cvta_Instr || tcode==ptx_cvta_to_Instr), (isU32(instr->type[0]) || isU64(instr->type[0])) ),
                       (ptxMsgInstRequiresU32orU64,sourcePos,name) );

    // CVTA: if cvta has symbol for source, check state space against instruction state space
    if (tcode==ptx_cvta_Instr) {
        ptxSymbolTableEntry symEnt = ptxGetSymEntFromExpr(gblState->parseData->arguments[1]);
        if (symEnt && symEnt->storage.kind != ptxRegStorage) {
            stdCHECK_WITH_POS(symEnt->storage.kind == gblState->parseData->storage[0].kind,
                            (ptxMsgSpaceMismatch,sourcePos,name) );
        }
    }

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    // GETLMEMBASE, SETLMEMBASE require .u64 instruction type
    stdCHECK_WITH_POS( stdIMPLIES( (tcode==ptx_getlmembase_Instr || tcode==ptx_setlmembase_Instr), isU64(instr->type[0]) ),
                       (ptxMsgInstRequiresType,sourcePos,name,".u64") );
#endif

    if (ptxIsVideoScalarInstr(tcode)) {
        // check for legal secondary op
        stdCHECK_WITH_POS( (gblState->parseData->postop==ptxNOP || gblState->parseData->postop==ptxADDOp || gblState->parseData->postop==ptxMINOp || gblState->parseData->postop==ptxMAXOp), (ptxMsgVideoIllegalSecOp,sourcePos,name) );

        // check third instruction type for vshl, vshr
        stdCHECK_WITH_POS( stdIMPLIES( (tcode == ptx_vshl_Instr || tcode == ptx_vshr_Instr), isU32(instr->type[2]) ), (ptxMsgOpRequiresU32,sourcePos) );
    }

    if (ptxIsVideoSIMD2Instr(tcode) || ptxIsVideoSIMD4Instr(tcode)) {
        // check for legal secondary op
        stdCHECK_WITH_POS( (gblState->parseData->postop==ptxNOP || gblState->parseData->postop==ptxADDOp), (ptxMsgVideoIllegalSecOp,sourcePos,name) );

        // check for sat/accumulate conflict
        stdCHECK_WITH_POS( stdIMPLIES( gblState->parseData->modifiers.SAT, gblState->parseData->postop==ptxNOP ), (ptxMsgVideoIllegalSatAddCombo,sourcePos) );
    }

    /*
     * Perform specific checks based on instruction features:
     */

    // vector modifier applies to first instruction type
    // Do vector type check only on instructions with at least one type
    if (gblState->parseData->nrofInstructionTypes) {
        Bool wideLoadStoreVec = False;
#if LWCFG(GLOBAL_ARCH_ADA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        wideLoadStoreVec = isWideLoadStoreInstr(tcode, instr->type[0], gblState->parseData->modifiers);
#endif // ada, internal
        stdCHECK_WITH_POS(
                stdIMPLIES( ptxHasVECTOR_MOD(gblState->parseData->modifiers),
                           (ptxGetTypeSizeInBits(instr->type[0])*vectorSize <= 128
                            || wideLoadStoreVec)),
                (ptxMsgVectorTypeTooLarge,sourcePos)
        );
    }


    //RESULTP
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_FUTURE)
    stdCHECK_WITH_POS(stdIMPLIES(tcode == ptx_elect_one_Instr, gblState->parseData->predicateOutput),
                      (ptxMsgResultPredExpected, sourcePos, name));
#endif
    if (gblState->parseData->predicateOutput) {
        stdCHECK_WITH_POS( gblState->parseData->predicateOutput->isLhs, (ptxMsgResultPredExpected, sourcePos, name) );

        stdCHECK_WITH_POS(
                ptxHasRESULTP_Feature(template->features),
                (ptxMsgResultPredNotAllowed, sourcePos, name)
        );

        stdCHECK_WITH_POS( isPRED(gblState->parseData->predicateOutput->type), (ptxMsgResultPredExpected, sourcePos, name) );
        if (ptxIsTextureInstr(tcode)) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
            char feature[] = "Texture instruction with optional predicate result";
            stdCHECK_WITH_POS( checkTargetArch(gblState, 52), (ptxMsgFeatureRequiresSMVersion, sourcePos, feature, "sm_52") );
            checkFeatureVersion(gblState, 6, 5, feature, sourcePos);
#elif LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
            char feature[] = "Texture instruction with optional predicate result";
            stdCHECK_WITH_POS( checkTargetArch(gblState, 60), (ptxMsgFeatureRequiresSMVersion, sourcePos, feature, "sm_60") );
            checkFeatureVersion(gblState, 7, 1, feature, sourcePos);
#else
            stdCHECK_WITH_POS( False, (ptxMsgResultPredNotAllowed, sourcePos, name));
#endif
        }
    }


    //CMP
    stdCHECK_WITH_POS(
            stdIMPLIES( gblState->parseData->cmp != ptxNO_Comparison, ptxHasCMP_Feature(template->features) ),
            (ptxMsgOutputCMPNotAllowed,sourcePos,name)
    );
    stdCHECK_WITH_POS(
            stdIMPLIES( ptxHasCMP_Feature(template->features), gblState->parseData->cmp != ptxNO_Comparison ),
            (ptxMsgModifierRequired, sourcePos, "Comparison", name)
    );

    // check CMP operator against instruction type
    if (gblState->parseData->cmp != ptxNO_Comparison) {
        stdCHECK_WITH_POS(checkCMPType(gblState, gblState->parseData->cmp, instr),
                          (ptxMsgCMPTypeMismatch,sourcePos));
    }


#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    if (isMultiplePostOpAllowed(gblState, tcode)) {
#else
    if (True) {
#endif
        //BOP
        stdCHECK_WITH_POS(stdIMPLIES(ptxHasBOP_Feature(template->features),
                                     gblState->parseData->postopclass&BoolOperationClass ),
                          (ptxMsgOutputBOPExpected,sourcePos,name)
        );
    }
    //--------------------------------------------------------------------------------------
    // normalize IR for ATOM ops
    //--------------------------------------------------------------------------------------

    //ATOM ops
    stdCHECK_WITH_POS(
            stdIMPLIES( gblState->parseData->postopclass&AtomicOperationClass, ptxHasATOMIC_Feature(template->features) ),
            (ptxMsgOutputAOPNotAllowed,sourcePos,name,sType(gblState->parseData, instr,0),sType(gblState->parseData, instr,1))
    );
    stdCHECK_WITH_POS(
            stdIMPLIES( ptxHasATOMIC_Feature(template->features), gblState->parseData->postopclass&AtomicOperationClass ),
            (ptxMsgOutputAOPExpected,sourcePos,name)
    );

    //RESULT; note that the existence of arguments[0] is required, but may be ptxSinkExpr in case of SINK output
    stdCHECK_WITH_POS(
            stdIMPLIES( ptxHasRESULT_Feature(template->features),
                        gblState->parseData->nrofArguments > 0 && (gblState->parseData->arguments[0]->isLhs || gblState->parseData->arguments[0]->kind == ptxSinkExpression) ),
            (ptxMsgResultExpected,sourcePos,name)
    );
    stdCHECK_WITH_POS(
            stdIMPLIES( gblState->parseData->nrofArguments > 0 && !gblState->parseData->arguments[0], ptxHasRESULT_Feature(template->features) ),
            (ptxMsgSinkButNoResult,sourcePos,name)
    );

    if (vectorMode && ptxHasRESULT_Feature(template->features) && (template->argType[0] == ptxFollowAType) && gblState->parseData->arguments[0]) {
        stdCHECK_WITH_POS( gblState->parseData->arguments[0]->type->kind == ptxVectorType,
                           (ptxMsgVectorResultExpected, sourcePos) );

        stdCHECK_WITH_POS( gblState->parseData->arguments[0]->type->cases.Vector.N == vectorSize,
                           (ptxMsgArgumentVectorMismatch, sourcePos, name) );
    }

    // bar.scan
    //
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    stdCHECK_WITH_POS( stdIMPLIES( tcode==ptx_bar_scan_Instr, checkTargetArch(gblState, 32)), (ptxMsgSMVersionRequired,sourcePos,"bar.scan","sm_32") );
    if (tcode==ptx_bar_scan_Instr) checkFeatureVersion(gblState, 3, 1, "bar.scan", sourcePos);

    // bar.scan requires .u32
    stdCHECK_WITH_POS( stdIMPLIES( tcode==ptx_bar_scan_Instr, isU32(instr->type[0])), (ptxMsgOpRequiresU32,sourcePos) );
#endif

#if LWCFG(GLOBAL_ARCH_VOLTA) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    if (tcode == ptx_fence_Instr) {
        checkFeatureVersion(gblState, 6, 0, "fence instruction", sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, 70),
                          (ptxMsgFeatureRequiresSMVersion, sourcePos,
                           "fence instruction", "sm_70"));
    }
#endif

    checkOrder(gblState, template, name, sourcePos);
    checkScope(gblState, template, name, sourcePos);

    if (gblState->parseData->modifiers.ORDER == ptxWEAK_MOD) {
        // Set weak order to no order after all the error checks are done.
        // This ensures that WEAK order is processed same as NOORDER in other phases.
        gblState->parseData->modifiers.ORDER = ptxNOORDER_MOD;
    }

    //NC
    if (gblState->parseData->modifiers.NC) {
        stdCHECK_WITH_POS( tcode == ptx_ld_Instr, (ptxMsgIllegalModifier, sourcePos,
                                                   getNCAsString(ptxNC_MOD), name) ) {
            uInt cop = gblState->parseData->modifiers.CACHEOP;

            stdCHECK_WITH_POS( gblState->parseData->storage[0].kind == ptxGlobalStorage, (ptxMsgNCWrongSpace,sourcePos) );
            stdCHECK_WITH_POS( !cop || cop==ptxCA_MOD || cop==ptxCG_MOD || cop==ptxCS_MOD, (ptxMsgNCIllegalCacheOp,sourcePos) );

            stdCHECK_WITH_POS( checkTargetArch(gblState, 32), (ptxMsgSMVersionRequired,sourcePos,"ld.nc","sm_32") );
#ifdef ENABLE_OPTIX_HACK
            // FIXME : Hack for optix to not error out for using ld.global.nc with ISA 3.0 
            checkFeatureVersion(gblState, 3, 0, getNCAsString(ptxNC_MOD), sourcePos);
#else
            checkFeatureVersion(gblState, 3, 1, getNCAsString(ptxNC_MOD), sourcePos);
#endif
        }
    }

    // If operand is of type vector then the instruction must be in vector mode.
    // and vice versa; if the instruction is in vectorMode then the desired operand must of type vector.
        
    if (tcode == ptx_ld_Instr || tcode == ptx_ldu_Instr || tcode == ptx_st_Instr) {
        if (vectorMode) {
            stdCHECK_WITH_POS(ptxIsArgVecType(instr), (ptxMsgArgumentVectorMismatch, sourcePos, name));
        } else if (ptxIsArgVecType(instr) && gblState->parseData->arguments[ptxGetVecArgNumber(instr)]->type->cases.Vector.N != 1) {
            stdCHECK_WITH_POS(False, (ptxMsgArgumentVectorMismatch, sourcePos, name));
        }

        if (tcode == ptx_ld_Instr || tcode == ptx_st_Instr) {
            checkArgsForLdStInstr(gblState, template, tcode, name, sourcePos);
        }
    }

    // Ld.param and st.param cannot be predicated if parameter is used for
    // passing argument/collecting return value in caller.
    if ((tcode==ptx_st_Instr || tcode==ptx_ld_Instr) && gblState->parseData->storage[0].kind == ptxParamStorage && gblState->parseData->guard) {
        int argIndex;
        ptxSymbolTableEntry sym;
        
        argIndex = tcode == ptx_ld_Instr ? 1 : 0;
        sym = ptxGetSymEntFromExpr(instr->arguments[argIndex]);

        if (sym->storage.kind != ptxRegStorage) {
            Bool IsAccessFromParamList = False;
            stdList_t paramList, l;

            paramList = tcode == ptx_ld_Instr ? gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->fparams : gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->rparams;

            for (l = paramList; l; l = l->tail) {
                ptxVariableInfo VarI = l->head;
                ptxSymbol p = VarI->symbol;
                if (p->index == sym->symbol->index) {
                    IsAccessFromParamList = True;
                    break;
                }
            }
            // predicated st.param to non-return operand or predicated ld.param to non-argument operand
            stdCHECK_WITH_POS(IsAccessFromParamList, (ptxMsgIllegalPredication,sourcePos,(tcode==ptx_ld_Instr ? "ld.param" : "st.param"),sym->symbol->unMangledName));
        }
    }

    // DIV.FULL instruction introduced in PTX .version 1.4
    if (tcode==ptx_div_full_Instr) checkFeatureVersion(gblState, 1, 4, name, sourcePos);

    // FMA.F64 requires .version 1.4 (check for sm_13+ covered by .f64 check), FMA.F32 requires .version 2.0
    if (tcode==ptx_fma_Instr) {
        if (isF64(instr->type[0])) checkFeatureVersion(gblState, 1, 4, "fma.f64", sourcePos);
        if (isF32(instr->type[0])) checkFeatureVersion(gblState, 2, 0, "fma.f32", sourcePos);
    }

    //SAT
    // float-to-int always saturates; set SAT by default
    if (tcode == ptx_cvt_Instr && isInteger(instr->type[0]) && isFloat(instr->type[1])) {
        gblState->parseData->modifiers.SAT = ptxSAT_MOD;
    }
    // int-to-int cvt.sat allowed only if source type value range is larger than dest type value range.
    // The cases where SAT may apply are:
    // . signed->unsigned colwersions
    // . unsigned->signed colwersions, where source type size is >= dest type size
    // . signed->signed or unsigned->unsigned colwersions, where source type size > dest type size

    if (gblState->parseData->modifiers.SAT && tcode == ptx_cvt_Instr && isInteger(instr->type[0]) && isInteger(instr->type[1])) {
        stdCHECK_WITH_POS( (isSignedInt(instr->type[1]) && !isSignedInt(instr->type[0])) ||
                           (!isSignedInt(instr->type[1]) && isSignedInt(instr->type[0]) && (ptxGetTypeSizeInBits(instr->type[1]) >= ptxGetTypeSizeInBits(instr->type[0]))) ||
                           (ptxGetTypeSizeInBits(instr->type[1]) > ptxGetTypeSizeInBits(instr->type[0])),
                           (ptxMsgIllegalModifier,sourcePos, getSATAsString(ptxSAT_MOD), name)
        );
    }
    if (gblState->parseData->modifiers.SAT && ptxHasSAT_Feature(template->features)) {
        switch (tcode) {
#if (LWCFG(GLOBAL_CHIP_T194) || LWCFG(GLOBAL_GPU_IMPL_GV11B))
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
        case ptx_cvt_pack_Instr: // fallthrough
#endif
#if  LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
        case ptx__mma_Instr: // fallthrough
#endif
#endif
        case ptx_cvt_Instr:
            break;
        default:
            {
                stdString_t typeName = stringNEW();
                String s;
                ptxPrintType(gblState->parseData->deobfuscatedStringMapPtr, instr->type[0], typeName);
                s = stringStripToBuf(typeName);
                if (!((isInteger(instr->type[0]) && isSignedInt(instr->type[0]) && ptxGetTypeSizeInBits(instr->type[0]) == 32)
                     || (isFloat(instr->type[0]) && (ptxGetTypeSizeInBits(instr->type[0]) == 32 || ptxGetTypeSizeInBits(instr->type[0]) == 16))
                     || (isF16x2(instr->type[0]) && ptxGetTypeSizeInBits(instr->type[0]) == 32)))
                {
                    stdCHECK_WITH_POS( 0, (ptxMsgSATNotAllowed,sourcePos,s));
                }
            }
        }
    }
#if (LWCFG(GLOBAL_CHIP_T194) || LWCFG(GLOBAL_GPU_IMPL_GV11B)) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
    if (tcode == ptx_cvt_pack_Instr) {
        stdCHECK_WITH_POS( stdIMPLIES( ptxHasSAT_Feature(template->features),
                                       gblState->parseData->modifiers.SAT),
                           (ptxMsgModifierRequired, sourcePos, getSATAsString(ptxSAT_MOD), name));
    }
#endif

    //SATF
    if (gblState->parseData->modifiers.SATF) {
        stdCHECK_WITH_POS(ptxHasSATF_Feature(template->features),
                          (ptxMsgIllegalModifier, sourcePos,
                           get_strSATF(gblState->parseData), name));
    }
    //SHAMT
    if (gblState->parseData->modifiers.SHAMT) {
        stdCHECK_WITH_POS(ptxHasSHAMT_Feature(template->features),
                          (ptxMsgIllegalModifier, sourcePos,
                           get_strSHAMT(gblState->parseData), name));
    }

    // CC
    stdCHECK_WITH_POS(
            stdIMPLIES( gblState->parseData->modifiers.CC, ptxHasCC_Feature(template->features)),
            (ptxMsgIllegalModifier, sourcePos, getCCAsString(ptxCC_MOD), name)
    );
    if (gblState->parseData->modifiers.CC) {
        stdCHECK_WITH_POS( isInteger(instr->type[0]) && (ptxGetTypeSizeInBits(instr->type[0]) == 32 || ptxGetTypeSizeInBits(instr->type[0]) == 64),
                           (ptxMsgCCRequiresIntType,sourcePos,name, "32bit or 64bit") );
        stdCHECK_WITH_POS( stdIMPLIES( ptxGetTypeSizeInBits(instr->type[0]) == 64, checkTargetArch(gblState, 20)),
                           (ptxMsgSMVersionRequired,sourcePos,".cc with 64bit type","sm_20") );
        if (ptxGetTypeSizeInBits(instr->type[0]) == 64) checkFeatureVersion(gblState, 4, 3, ".cc with 64bit type", sourcePos);
    }
    stdCHECK_WITH_POS(
            stdIMPLIES( gblState->parseData->modifiers.CC, !gblState->parseData->modifiers.SAT),
            (ptxMsgIllegalModifierPair, sourcePos, get_strCC(gblState->parseData), get_strSAT(gblState->parseData))
    );
    if (gblState->parseData->modifiers.CC) checkFeatureVersion(gblState, 1, 2, getCCAsString(ptxCC_MOD), sourcePos);
    if (tcode==ptx_addc_Instr) checkFeatureVersion(gblState, 1, 2, "1.2", sourcePos);
    if (tcode==ptx_sub_Instr && gblState->parseData->modifiers.CC) checkFeatureVersion(gblState, 1, 3, "sub.cc", sourcePos);
    if (tcode==ptx_subc_Instr) checkFeatureVersion(gblState, 1, 3, "1.3", sourcePos);
    stdCHECK_WITH_POS( stdIMPLIES( (tcode==ptx_mad_lo_Instr || tcode==ptx_mad_hi_Instr) && gblState->parseData->modifiers.CC, checkTargetArch(gblState, 20)),
                       (ptxMsgSMVersionRequired,sourcePos,"mad.cc","sm_20") );
    if ((tcode==ptx_mad_lo_Instr || tcode==ptx_mad_hi_Instr) && gblState->parseData->modifiers.CC) checkFeatureVersion(gblState, 3, 0, "mad.cc", sourcePos);
    stdCHECK_WITH_POS( stdIMPLIES( tcode==ptx_madc_lo_Instr || tcode==ptx_madc_hi_Instr, checkTargetArch(gblState, 20)),
                       (ptxMsgSMVersionRequired,sourcePos,"madc","sm_20") );
    if (tcode==ptx_madc_lo_Instr || tcode==ptx_madc_hi_Instr) checkFeatureVersion(gblState, 3, 0, "madc", sourcePos);


    //ROUND
    if (gblState->parseData->modifiers.ROUND) {
        stdCHECK_WITH_POS(
                stdIMPLIES( ptxHasRoundFModifier(gblState->parseData->modifiers), ptxHasROUNDF_Feature(template->features)),
                (ptxMsgIllegalRoundingModifier,sourcePos,name)
        );
        stdCHECK_WITH_POS(
                stdIMPLIES( ptxHasRoundIModifier(gblState->parseData->modifiers), ptxHasROUNDI_Feature(template->features)),
                (ptxMsgIllegalRoundingModifier,sourcePos,name)
        );
        
        // .rm or .rp implies CVT or sm_20 or sm_13&f64
        stdCHECK_WITH_POS(
                 stdIMPLIES( gblState->parseData->modifiers.ROUND == ptxRM_MOD || gblState->parseData->modifiers.ROUND == ptxRP_MOD,
                             (tcode == ptx_cvt_Instr
                              || checkTargetArch(gblState, 20)
                              || (checkTargetArch(gblState, 13) && isF64(instr->type[0]))) ),
                 (ptxMsgIllegalRoundingModifier,sourcePos,name)
        );

        // Rounding mode checks for CVT
        if (tcode == ptx_cvt_Instr &&
            template->nrofInstrTypes == 2 &&
            isFloat(instr->type[0]) && isFloat(instr->type[1])) {
            stdCHECK_WITH_POS(
                     stdIMPLIES( ptxHasRoundFModifier(gblState->parseData->modifiers), ptxGetTypeSizeInBits(instr->type[0]) < ptxGetTypeSizeInBits(instr->type[1])),
                     (ptxMsgIllegalRoundingModifier,sourcePos,name)
            );
            stdCHECK_WITH_POS(
                     stdIMPLIES( ptxHasRoundIModifier(gblState->parseData->modifiers), ptxGetTypeSizeInBits(instr->type[0]) == ptxGetTypeSizeInBits(instr->type[1])),
                     (ptxMsgIllegalRoundingModifier,sourcePos,name)
            );
        }
        if (tcode == ptx_cvt_Instr &&
            (gblState->parseData->modifiers.RELU || (template->nrofInstrTypes == 2 && isF16x2(instr->type[0])) ||
            gblState->parseData->modifiers.ATYPE == ptxTYPE_BF16_MOD || gblState->parseData->modifiers.ATYPE == ptxTYPE_BF16x2_MOD))
        {
            stdCHECK_WITH_POS(gblState->parseData->modifiers.ROUND == ptxRN_MOD || gblState->parseData->modifiers.ROUND == ptxRZ_MOD,
                     (ptxMsgIllegalRoundingModifier,sourcePos,name)
            );
        }
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        if (tcode == ptx_cvt_Instr && template->nrofInstrTypes == 2 &&
            (isF8x2(instr->type[0]) || isF8x2(instr->type[1])))
        {
            stdCHECK_WITH_POS(gblState->parseData->modifiers.ROUND == ptxRN_MOD,
                              (ptxMsgIllegalRoundingModifier, sourcePos, name));
        }
#endif

        // Rounding modifier rna is allowed only with cvt.tf32
        stdCHECK_WITH_POS( stdEQUIV(gblState->parseData->modifiers.ROUND == ptxRNA_MOD,
                                    tcode == ptx_cvt_Instr && gblState->parseData->modifiers.ATYPE == ptxTYPE_TF32_MOD),
                           (ptxMsgIllegalRoundingModifier,sourcePos,name));

        // {mad,div,rcp,sqrt}.rnd.f32, fma.f32 require sm_20
        if (isF32(instr->type[0])) {
            // FIXME: error message should be superceded by the one below, but this leads to failure of //sw/gpgpu/lwca/apps/ptxtest.
            stdCHECK_WITH_POS( stdIMPLIES( tcode==ptx_mad_Instr, checkTargetArch(gblState, 20) ), (ptxMsgIllegalRoundingModifier,sourcePos,name) );
            stdCHECK_WITH_POS( stdIMPLIES( tcode==ptx_mad_Instr, checkTargetArch(gblState, 20) ), (ptxMsgSMVersionRequired,sourcePos,"mad.rnd.f32","sm_20") );
            stdCHECK_WITH_POS( stdIMPLIES( tcode==ptx_div_Instr, checkTargetArch(gblState, 20) ), (ptxMsgSMVersionRequired,sourcePos,"div.rnd.f32","sm_20") );
            stdCHECK_WITH_POS( stdIMPLIES( tcode==ptx_rcp_Instr, checkTargetArch(gblState, 20) ), (ptxMsgSMVersionRequired,sourcePos,"rcp.rnd.f32","sm_20") );
            stdCHECK_WITH_POS( stdIMPLIES( tcode==ptx_sqrt_Instr, checkTargetArch(gblState, 20) ), (ptxMsgSMVersionRequired,sourcePos,"sqrt.rnd.f32","sm_20") );

            stdCHECK_WITH_POS( stdIMPLIES( tcode==ptx_fma_Instr, checkTargetArch(gblState, 20) ), (ptxMsgSMVersionRequired,sourcePos,"fma.f32","sm_20") );
        }
        // {div,rcp,sqrt}.rn.f64 requires sm_13+ or map_f64_to_f32.  No check needed since .f64 requires sm_13+ or map_f64_to_f32 (already checked)
        // {div,rcp,sqrt}.{rz,rp,rn}.f64 requires sm_20+
        if (isF64(instr->type[0]) && gblState->parseData->modifiers.ROUND != ptxRN_MOD) {
            stdCHECK_WITH_POS( stdIMPLIES( tcode==ptx_div_Instr, checkTargetArch(gblState, 20) ), (ptxMsgSMVersionRequired,sourcePos,"div.rn.f64","sm_20") );
            stdCHECK_WITH_POS( stdIMPLIES( tcode==ptx_rcp_Instr, checkTargetArch(gblState, 20) ), (ptxMsgSMVersionRequired,sourcePos,"rcp.rn.f64","sm_20") );
            stdCHECK_WITH_POS( stdIMPLIES( tcode==ptx_sqrt_Instr, checkTargetArch(gblState, 20) ), (ptxMsgSMVersionRequired,sourcePos,"sqrt.rn.f64","sm_20") );
        }

        // FIXME: need ISA Version checks for rnd
        // rounding that requires sm_20+ doesn't need additional check for version 2.0+
        // . cvt supports all rounding mods since PTX ISA version 1.0
        // . {add,sub,mul,mad}.{rm,rp}.f64 requires PTX ISA version 1.2+
        // . {div,rcp,sqrt}.rn.f64 requires PTX ISA version 1.4+

    } else if (ptxHasROUNDF_Feature(template->features) || ptxHasROUNDI_Feature(template->features)) { // no rounding modifier specified
        // CVT requires explicit round gblState->parseData->modifiers
        stdCHECK_WITH_POS( tcode != ptx_cvt_Instr ||
                           (template->nrofInstrTypes == 2 &&
                            isFloat(instr->type[0]) && isFloat(instr->type[1]) &&
                            ptxGetTypeSizeInBits(instr->type[0]) >= ptxGetTypeSizeInBits(instr->type[1])),
                           (ptxMsgModifierRequired, sourcePos,
                            "Rounding", name));

        // mad.f32 (no rounding) allowed only for sm_1x in PTX ISA Version 2.0 and higher
        // errata: due to missing parser test, we'll WARN in PTX ISA Version 3.1 and ERROR in version 3.2 and later
        stdCHECK_WITH_POS( stdIMPLIES(tcode == ptx_mad_Instr && isF32(instr->type[0]), !ptxVersionIs(gblState, 3,1) || !checkTargetArch(gblState, 20)),
                           (ptxMsgWarning,sourcePos,"Rounding modifier required for mad.f32 if .target is sm_20 or later.") );
        stdCHECK_WITH_POS( stdIMPLIES(tcode == ptx_mad_Instr && isF32(instr->type[0]), !ptxVersionAtLeast(3,2, gblState) || !checkTargetArch(gblState, 20)),
                           (ptxMsgModifierRequired, sourcePos,
                            "Rounding", name));

        // FMA requires explicit round gblState->parseData->modifiers
        stdCHECK_WITH_POS(tcode != ptx_fma_Instr,
                          (ptxMsgModifierRequired, sourcePos,
                           "Rounding", name));

        // ROUNDF defaults to .rn for {mad,div,rcp,sqrt}.f64 for ptx isa versions < 1.4, requires rounding modifier for versions >= 1.4
        // except for rcp.approx.f64, which has no ROUNDF
        if ( (tcode == ptx_mad_Instr || tcode == ptx_div_Instr || tcode == ptx_rcp_Instr || tcode == ptx_sqrt_Instr) &&
             ptxHasROUNDF_Feature(template->features) && isF64(instr->type[0]) && !gblState->parseData->modifiers.APRX)
        {
            if (!ptxVersionAtLeast(1,4, gblState)) {
                gblState->parseData->modifiers.ROUND |= ptxRN_MOD;
            } else {
                stdCHECK_WITH_POS(False, (ptxMsgModifierRequired, sourcePos,
                                          "Rounding", name));
            }
        }
    }

    if (gblState->parseData->modifiers.RELU) {
        stdCHECK_WITH_POS(ptxHasRELU_Feature(template->features),
                          (ptxMsgIllegalModifier, sourcePos, get_strRELU(gblState->parseData), name));
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        checkFeatureVersion(gblState, 6, 4, get_strRELU(gblState->parseData), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, 75),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                            get_strRELU(gblState->parseData), "sm_75"));
        if (!checkTargetArch(gblState, 80)) {
            stdCHECK_WITH_POS(tcode==ptx_cvt_Instr, (ptxMsgIllegalModifier, sourcePos, get_strRELU(gblState->parseData), name));
        }
#else
        if (areExtendedInstructionsEnabled(gblState->parseData)) {
            checkFeatureVersion(gblState, 6, 4, get_strRELU(gblState->parseData), sourcePos);
            stdCHECK_WITH_POS(checkTargetArch(gblState, 75),
                              (ptxMsgModifierRequiresSMVersion, sourcePos,
                               get_strRELU(gblState->parseData), "sm_75"));
            if (!checkTargetArch(gblState, 80)) {
                stdCHECK_WITH_POS(tcode==ptx_cvt_Instr, (ptxMsgIllegalModifier, sourcePos, get_strRELU(gblState->parseData), name));
            }
        } else {
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
        checkFeatureVersion(gblState, 7, 0, get_strRELU(gblState->parseData), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, 80),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                            get_strRELU(gblState->parseData), "sm_80"));

#endif
        }
#endif
    }

    if (gblState->parseData->modifiers.NANMODE) {
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
        stdCHECK_WITH_POS(ptxHasNANMODE_Feature(template->features),
                          (ptxMsgIllegalModifier, sourcePos, get_strNANMODE(gblState->parseData), name));
        checkFeatureVersion(gblState, 7, 0, get_strNANMODE(gblState->parseData), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, 80),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                           get_strNANMODE(gblState->parseData), "sm_80"));
#else
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                                  sourcePos, get_strNANMODE(gblState->parseData)));
#endif
    }

    if (gblState->parseData->modifiers.XORSIGN) {
        checkXorSignModifier(gblState, name, template, sourcePos);
    }

    if (gblState->parseData->modifiers.TRANSA) {
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        stdCHECK_WITH_POS(ptxHasTRANSA_Feature(template->features),
                          (ptxMsgIllegalModifier, sourcePos, get_strTRANSA(gblState->parseData), name));
        stdCHECK_WITH_POS((!isHGMMAWithTF32Type(gblState, tcode)),
                          (ptxMsgIllegalModifierWithType, sourcePos,            
                           getTRANSAAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.TRANSA), name, "TF32"));
        // FIXME: Update version/target check
        checkFeatureVersion(gblState, 7, 0, get_strTRANSA(gblState->parseData), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, 90),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                           get_strTRANSA(gblState->parseData), "sm_90"));
#else
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                                  sourcePos, get_strTRANSA(gblState->parseData)));
#endif
    }

    if (gblState->parseData->modifiers.NEGA) {
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        stdCHECK_WITH_POS(ptxHasNEGA_Feature(template->features),
                          (ptxMsgIllegalModifier, sourcePos, get_strNEGA(gblState->parseData), name));
        // FIXME: Update version/target check
        checkFeatureVersion(gblState, 7, 0, get_strNEGA(gblState->parseData), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, 90),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                           get_strNEGA(gblState->parseData), "sm_90"));
#else
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                                  sourcePos, get_strNEGA(gblState->parseData)));
#endif
    }

    if (gblState->parseData->modifiers.TRANSB) {
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        stdCHECK_WITH_POS(ptxHasTRANSB_Feature(template->features),
                          (ptxMsgIllegalModifier, sourcePos, get_strTRANSB(gblState->parseData), name));
        stdCHECK_WITH_POS((!isHGMMAWithTF32Type(gblState, tcode)),
                          (ptxMsgIllegalModifierWithType, sourcePos,
                           getTRANSAAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.TRANSA), name, "TF32"));
        // FIXME: Update version/target check
        checkFeatureVersion(gblState, 7, 0, get_strTRANSB(gblState->parseData), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, 90),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                           get_strTRANSB(gblState->parseData), "sm_90"));
#else
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                                  sourcePos, get_strTRANSB(gblState->parseData)));
#endif
    }

    if (gblState->parseData->modifiers.NEGB) {
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        stdCHECK_WITH_POS(ptxHasNEGB_Feature(template->features),
                          (ptxMsgIllegalModifier, sourcePos, get_strNEGB(gblState->parseData), name));
        // FIXME: Update version/target check
        checkFeatureVersion(gblState, 7, 0, get_strNEGB(gblState->parseData), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, 90),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                           get_strNEGB(gblState->parseData), "sm_90"));
#else
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                                  sourcePos, get_strNEGB(gblState->parseData)));
#endif
    }

    if (gblState->parseData->modifiers.IGNOREC) {
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        stdCHECK_WITH_POS(ptxHasIGNOREC_Feature(template->features),
                          (ptxMsgIllegalModifier, sourcePos, get_strIGNOREC(gblState->parseData), name));
        // FIXME: Update version/target check
        checkFeatureVersion(gblState, 7, 0, get_strIGNOREC(gblState->parseData), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, 90),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                           get_strIGNOREC(gblState->parseData), "sm_90"));
#else
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                                  sourcePos, get_strIGNOREC(gblState->parseData)));
#endif
    }

    // ADDRTYPE (mandatory)
    stdCHECK_WITH_POS( stdIMPLIES(ptxHasADDRTYPE_MOD(gblState->parseData->modifiers),
                                  ptxHasADDRTYPE_Feature(template->features)),
                       (ptxMsgIllegalModifier, sourcePos,
                        getADDRTYPEAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxADDRTYPE_FREL_MOD), name) );

    stdCHECK_WITH_POS( stdIMPLIES(ptxHasADDRTYPE_Feature(template->features),
                                  ptxHasADDRTYPE_MOD(gblState->parseData->modifiers)),
                       (ptxMsgModifierRequired, sourcePos,
                        getADDRTYPEAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxADDRTYPE_FREL_MOD), name));

    //CACHEOP
    if (gblState->parseData->modifiers.CACHEOP) {
        stdCHECK_WITH_POS(ptxHasCACHEOP_Feature(template->features),
                          (ptxMsgIllegalModifier, sourcePos,
                           get_strCACHEOP(gblState->parseData), name));
        stdCHECK_WITH_POS(checkTargetArch(gblState, 20),
                          (ptxMsgSMVersionRequired, sourcePos, name,"sm_20"));
        checkFeatureVersion(gblState, 2, 0, "cache operation", sourcePos);
        stdCHECK_WITH_POS(checkCacheOp(tcode, gblState->parseData->modifiers.CACHEOP),
                          (ptxMsgIllegalModifier, sourcePos,
                           get_strCACHEOP(gblState->parseData), name));
    }

    if (ptxHasCACHEOP_Feature(template->features)) {
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        // mandatory CACHEOP check
        if (tcode == ptx_ttucctl_Instr) {
            stdCHECK_WITH_POS( ptxHasCACHEOP_MOD(gblState->parseData->modifiers),
                               (ptxMsgModifierRequired, sourcePos,
                                "'.ilwall'", name) );
        }
#endif
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
        if (tcode == ptx_cp_async_Instr) {
            stdCHECK_WITH_POS(ptxHasCACHEOP_MOD(gblState->parseData->modifiers),
                              (ptxMsgModifierRequired, sourcePos,
                               "'.ca or .cg'", name));
        }
#endif
    }

    if ((tcode == ptx_cctl_Instr || tcode == ptx_cctlu_Instr)) {
        // cctl is allowed unconditionally in internal builds, and
        // only via macro expansion in external builds.
#if !LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        if (!ptxIsInternalSource(gblState->lwrInstrSrc)) {
            stdCHECK_WITH_POS( False, (ptxMsgParsingError,sourcePos,name,"unrecognized instruction") );
        }
#endif
        // .ilwall iff no addr operand
        stdCHECK_WITH_POS(stdEQUIV(gblState->parseData->modifiers.CACHEOP==ptxILWALL_MOD,
                                   gblState->parseData->nrofArguments==0),
                          (ptxMsgIllegalModifier, sourcePos,
                           get_strCACHEOP(gblState->parseData), name));

        // .const implies !.wb
        stdCHECK_WITH_POS(stdIMPLIES(gblState->parseData->storage[0].kind == ptxConstStorage,
                                     gblState->parseData->modifiers.CACHEOP != ptxWB_MOD),
                          (ptxMsgIllegalModifier, sourcePos,
                           get_strCACHEOP(gblState->parseData), name));

        // .tex implies .ilwall, requires sm_35 and PTX ISA 3.1
        if (gblState->parseData->storage[0].kind == ptxTexStorage) {
            stdCHECK_WITH_POS(gblState->parseData->modifiers.CACHEOP == ptxILWALL_MOD,
                              (ptxMsgIllegalModifier, sourcePos,
                               get_strCACHEOP(gblState->parseData), name));
            stdCHECK_WITH_POS( checkTargetArch(gblState, 35), (ptxMsgSMVersionRequired,sourcePos,"cctl.tex.ilwall","sm_35") );
            checkFeatureVersion(gblState, 3, 1, "cctl.tex.ilwall", sourcePos);
        }
    }

    // prefetch/prefetchu require cache level
    if (tcode == ptx_prefetch_Instr || tcode == ptx_prefetchu_Instr
#if LWCFG(GLOBAL_ARCH_AMPERE) && (LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) || LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71))
        || tcode == ptx_cachepolicy_Instr
#endif // ampere, (Internal || ISA_71)
        )
    {
        stdCHECK_WITH_POS((gblState->parseData->modifiers.LEVEL || gblState->parseData->nrofLevelColonMod > 0), 
                          (ptxMsgModifierRequired, sourcePos, "Cache level", name));
    }

    // FLOW
    if (gblState->parseData->modifiers.FLOW) {
        stdCHECK_WITH_POS(ptxHasFLOW_Feature(template->features),
                          (ptxMsgIllegalModifier, sourcePos,
                           get_strFLOW(gblState->parseData), name));

        // {tex,tld4}.uni requires PTX 3.2.
        // Target check is covered by address operand check, i.e., okay to use .uni with direct texref operand, even if target < sm_20
        if (ptxIsTexInstr(tcode)) checkFeatureVersion(gblState, 3, 2, "tex.uni", sourcePos);
        if (tcode==ptx_tld4_Instr) checkFeatureVersion(gblState, 3, 2, "tld4.uni", sourcePos);
    }

    //BRANCH
    if (gblState->parseData->modifiers.BRANCH) {
        stdCHECK_WITH_POS(ptxHasBRANCH_Feature(template->features),
                          (ptxMsgIllegalModifier, sourcePos,
                           get_strBRANCH(gblState->parseData), name));
   }

    //SIGNED
    if (ptxHasSIGNED_Feature(template->features)) {
      // get index of SIGNED operand
      uInt i = (tcode == ptx_slct_Instr) ? 1 : 0;

      stdCHECK_WITH_POS(  isFloat(instr->type[i]) ||
                          isSignedInt(instr->type[i]),
                         (ptxMsgSignedRequired,sourcePos,name)
                         );
    }

#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    // add/sub/mul with empty instruction type is allowed only for bf16 format.
    if ((tcode == ptx_add_Instr || tcode == ptx_sub_Instr || tcode == ptx_mul_Instr) &&
        instr->type[0] == NULL && gblState->parseData->modifiers.ATYPE != ptxTYPE_BF16_MOD && gblState->parseData->modifiers.ATYPE != ptxTYPE_BF16x2_MOD)
    {
        stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrTypes, sourcePos, name));
    }
#endif // HOPPER && INTERNAL

    // min/max/fma/abs/neg with empty instruction type is allowed only for bf16 format.
    if ((tcode == ptx_min_Instr || tcode == ptx_max_Instr || tcode == ptx_fma_Instr || 
         tcode == ptx_abs_Instr || tcode == ptx_neg_Instr) &&
        instr->type[0] == NULL && gblState->parseData->modifiers.ATYPE != ptxTYPE_BF16_MOD && gblState->parseData->modifiers.ATYPE != ptxTYPE_BF16x2_MOD)
    {
        stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrTypes, sourcePos, name));
    }

    // cvt with 1 inst type is allowed only with bf16/bf16x2/tf32 and vice versa
    if (tcode == ptx_cvt_Instr) {
        stdCHECK_WITH_POS(!((template->nrofInstrTypes == 1) ^ (gblState->parseData->modifiers.ATYPE == ptxTYPE_BF16_MOD || gblState->parseData->modifiers.ATYPE == ptxTYPE_BF16x2_MOD ||
                             gblState->parseData->modifiers.ATYPE == ptxTYPE_TF32_MOD ||
                             gblState->parseData->modifiers.BTYPE == ptxTYPE_BF16_MOD )), (ptxMsgNonMatchingInstrTypes, sourcePos, name));
    }

    // f16 arithmetic, compare, texture
    if (ptxIsF16ArithmeticInstr(tcode) || ptxIsF16CompareInstr(tcode) || ptxIsTextureInstr(tcode)) {
        if (isF16(instr->type[0]) || isF16x2(instr->type[0])) {
            if (tcode == ptx_min_Instr) {
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
                stdCHECK_WITH_POS( checkTargetArch(gblState, 80), (ptxMsgFeatureRequiresSMVersion,sourcePos,"min.f16 or min.f16x2","sm_80") );
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
                checkFeatureVersion(gblState, 6, 4, "min.f16 or min.f16x2", sourcePos);
#else
                checkFeatureVersion(gblState, 7, 0, "min.f16 or min.f16x2", sourcePos);
#endif
#else
                stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrTypes, sourcePos,name));
#endif
            } else if (tcode == ptx_max_Instr) {
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
                stdCHECK_WITH_POS( checkTargetArch(gblState, 80), (ptxMsgFeatureRequiresSMVersion,sourcePos,"max.f16 or max.f16x2","sm_80") );
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
                checkFeatureVersion(gblState, 6, 4, "max.f16 or max.f16x2", sourcePos);
#else
                checkFeatureVersion(gblState, 7, 0, "max.f16 or max.f16x2", sourcePos);
#endif
#else
                stdCHECK_WITH_POS(False, (ptxMsgNonMatchingInstrTypes, sourcePos,name));
#endif
            } else {
                stdCHECK_WITH_POS( checkTargetArch(gblState, 53), (ptxMsgFeatureRequiresSMVersion,sourcePos,"f16 arithemetic and compare instructions","sm_53") );
                checkFeatureVersion(gblState, 4, 2, "f16 arithemetic and compare instructions", sourcePos);
                // f16 arithmetic supports only rn rounding modifier
                stdCHECK_WITH_POS( stdIMPLIES( ptxHasRoundFModifier(gblState->parseData->modifiers), gblState->parseData->modifiers.ROUND == ptxRN_MOD), 
                               (ptxMsgIllegalRoundingModifier,sourcePos,name) );
            }
            if (tcode == ptx_neg_Instr) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
                checkFeatureVersion(gblState, 6, 0, "neg.f16 or neg.f16x2", sourcePos);
#else
                stdCHECK_WITH_POS(0, (ptxMsgNonMatchingInstrTypes, sourcePos,name));
#endif
            }
            if (tcode == ptx_abs_Instr) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
                checkFeatureVersion(gblState, 6, 5, "abs.f16 or abs.f16x2", sourcePos);
#else
                stdCHECK_WITH_POS(0, (ptxMsgNonMatchingInstrTypes, sourcePos,name));
#endif
            }
        }
    }

    //TEXADDR
    stdCHECK_WITH_POS( stdIMPLIES( gblState->parseData->modifiers.TADDR, ptxHasTEXADDR_Feature(template->features)), (ptxMsgIllegalAddressingMode,sourcePos,name) );
    stdCHECK_WITH_POS( stdIMPLIES( ptxVersionAtLeast(1,2, gblState) && ptxHasTEXADDR_Feature(template->features), gblState->parseData->modifiers.TADDR ),
                       (ptxMsgIllegalAddressingMode,sourcePos,name) );


    //TEX, TLD4 coordinates, vector size
    if (ptxIsTextureInstr(tcode)) {
        uInt reqVecSize = isF16x2(instr->type[0]) ? 2 : 4;
        stdCHECK_WITH_POS(stdIMPLIES((ptxTexHasOffsetArg(gblState, instr) || ptxTexHasDepthCompareArg(gblState, instr)), checkTargetArch(gblState, 30)), (ptxMsgFeatureRequiresSMVersion,sourcePos,"offset operand","sm_30"));
        if ((ptxTexHasOffsetArg(gblState, instr) || ptxTexHasDepthCompareArg(gblState, instr))) checkFeatureVersion(gblState, 4, 3, name, sourcePos);
        stdCHECK_WITH_POS(stdIMPLIES(ptxTexHasDepthCompareArg(gblState, instr), textureGeom != ptx3D_MOD), (ptxMsgIllegalModifier, sourcePos, get_strTEXTURE(gblState->parseData), name)); 
        stdCHECK_WITH_POS( stdIMPLIES( isInteger(instr->type[1]), isSignedInt(instr->type[1])),
                           (ptxMsgSignedIntCoordRequired,sourcePos)
        );
        stdCHECK_WITH_POS( stdIMPLIES( textureGeom == ptxLWBE_MOD || textureGeom == ptxALWBE_MOD, isFloat(instr->type[1])),
                           (ptxMsgFloatCoordRequired,sourcePos)
        );
        stdCHECK_WITH_POS( stdIMPLIES( textureGeom == ptx2DMS_MOD || textureGeom == ptxA2DMS_MOD, 
                           isInteger(instr->type[1]) && isSignedInt(instr->type[1])),
                           (ptxMsgSignedIntCoordRequired,sourcePos)
        );

        if (vectorSize != reqVecSize) {
            String instrNameType = stdCONCATSTRING(name, getInstrTypeAsString(gblState, 0));
            stdCHECK_WITH_POS(False, (ptxMsgRequiresVectorType, sourcePos, instrNameType, reqVecSize));
            stdFREE(instrNameType);
        }

        stdCHECK_WITH_POS( stdIMPLIES( checkTargetOpts(gblState, "texmode_unified"),     !ptxTexHasSampler(gblState) ), (ptxMsgTexModeViolation,sourcePos,"unified") );
        stdCHECK_WITH_POS( stdIMPLIES( checkTargetOpts(gblState, "texmode_independent"),  ptxTexHasSampler(gblState) ), (ptxMsgTexModeViolation,sourcePos,"independent") );
    }

    //TEXMOD
    stdCHECK_WITH_POS(
            stdIMPLIES( ptxHasTEXTURE_MOD(gblState->parseData->modifiers), ptxHasTEXMOD_Feature(template->features)),
            (ptxMsgIllegalModifier,sourcePos,"Geometry",name)
    );
    stdCHECK_WITH_POS(
            stdIMPLIES( ptxHasTEXMOD_Feature(template->features), ptxHasTEXTURE_MOD(gblState->parseData->modifiers)),
            (ptxMsgModifierRequired,sourcePos,"Geometry",name)
    );
    if (ptxIsSurfaceInstr(tcode) && textureGeom == ptx3D_MOD) {

        stdCHECK_WITH_POS( checkTargetArch(gblState, 20), (ptxMsgFeatureRequiresSMVersion,sourcePos,"surface instruction with .3d geometry","sm_20") );
        checkFeatureVersion(gblState, 3, 0, "surface instruction with .3d geometry", sourcePos);
    }

    // FOOTPRINT
    if (gblState->parseData->modifiers.FOOTPRINT) {
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        // FIXME: Fix version check based on final POR from where this feature will be supported
        checkFeatureVersion(gblState, 6, 5, get_strFOOTPRINT(gblState->parseData), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, 75),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                            get_strFOOTPRINT(gblState->parseData), "sm_75"));
        stdCHECK_WITH_POS(ptxHasFOOTPRINT_Feature(template->features),
                          (ptxMsgIllegalModifier, sourcePos, get_strFOOTPRINT(gblState->parseData), name));
        if (ptxIsTexGradInstr(tcode)) {
            stdCHECK_WITH_POS(textureGeom == ptx1D_MOD || textureGeom == ptx2D_MOD,
                              (ptxMsgWrongTexGeom, sourcePos, get_strTEXTURE(gblState->parseData), "tex.grad with .footprint"));
        } else {
            stdCHECK_WITH_POS(textureGeom == ptx1D_MOD || textureGeom == ptx2D_MOD || textureGeom == ptx3D_MOD,
                              (ptxMsgWrongTexGeom, sourcePos, get_strTEXTURE(gblState->parseData), "tex with .footprint"));
        }
#else
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                                  sourcePos, get_strFOOTPRINT(gblState->parseData)));
#endif
    }

    // COARSE
    if (gblState->parseData->modifiers.COARSE) {
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        // FIXME: Fix version check based on final POR from where this feature will be supported
        checkFeatureVersion(gblState, 6, 5, get_strCOARSE(gblState->parseData), sourcePos);
        stdCHECK_WITH_POS(checkTargetArch(gblState, 75),
                          (ptxMsgModifierRequiresSMVersion, sourcePos,
                            get_strCOARSE(gblState->parseData), "sm_75"));
        stdCHECK_WITH_POS(ptxHasCOARSE_Feature(template->features),
                          (ptxMsgIllegalModifier, sourcePos, getCOARSEAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxCOARSE_MOD), name));

        stdCHECK_WITH_POS(ptxHasFOOTPRINT_MOD(gblState->parseData->modifiers),
                          (ptxMsgModifierRequiresModifier, sourcePos,
                           getCOARSEAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxCOARSE_MOD),
                           getFOOTPRINTAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxFOOTPRINT_MOD), name));
#else
        stdCHECK_WITH_POS(False, (ptxMsgUnknownModifier,
                                  sourcePos, getCOARSEAsString(gblState->parseData->deobfuscatedStringMapPtr, gblState->parseData->modifiers.COARSE)));
#endif
    }

    // tld4 instruction checks.
    if (tcode == ptx_tld4_Instr) {
        stdString_t s = stringNEW();
        String str;
        stringAddFormat(s, "%s %s", "tld4 instruction with", get_strTEXTURE(gblState->parseData));
        str = stringStripToBuf(s);  

        stdCHECK_WITH_POS(!(textureGeom == ptx3D_MOD || textureGeom == ptx1D_MOD || textureGeom == ptxA1D_MOD), (ptxMsgIllegalModifier, sourcePos, get_strTEXTURE(gblState->parseData), name));
        if ( textureGeom == ptxA2D_MOD || textureGeom == ptxLWBE_MOD || textureGeom == ptxALWBE_MOD ) {
            stdCHECK_WITH_POS(checkTargetArch(gblState, 30), (ptxMsgFeatureRequiresSMVersion,sourcePos, str, "sm_30"));
            checkFeatureVersion(gblState, 4, 3, str, sourcePos);
        }
        stdFREE(str);
    }
    
    if (textureGeom == ptx1D_BUFFER_MOD) {
        stdCHECK_WITH_POS(checkTargetArch(gblState, 30), (ptxMsgFeatureRequiresSMVersion,sourcePos, ".1d_buffer", "sm_30"));
        checkFeatureVersion(gblState, 4, 3, ".1d_buffer", sourcePos);

        stdCHECK_WITH_POS( tcode == ptx_sust_p_Instr  || tcode == ptx_sust_b_Instr  ||                
                           tcode == ptx_sured_p_Instr || tcode == ptx_sured_b_Instr ||
                           tcode == ptx_suld_b_Instr, (ptxMsgIllegalModifier,sourcePos,".1d_buffer",name) );
    }

    if (textureGeom == ptxA1D_MOD || textureGeom == ptxA2D_MOD) {
        stdCHECK_WITH_POS( ptxIsTextureInstr(tcode) || tcode==ptx_suld_b_Instr || tcode==ptx_sust_b_Instr
                           || tcode==ptx_sust_p_Instr , (ptxMsgIllegalModifier,sourcePos, get_strTEXTURE(gblState->parseData), name) );
        if ( tcode==ptx_suld_b_Instr || tcode==ptx_sust_b_Instr ) {
            stdCHECK_WITH_POS( checkTargetArch(gblState, 20), (ptxMsgFeatureRequiresSMVersion,sourcePos,"surface instruction with array geometry","sm_20") );
            checkFeatureVersion(gblState, 3, 0, "surface instruction with array geometry", sourcePos);
        }
        if ( tcode==ptx_sust_p_Instr ) {
            stdCHECK_WITH_POS( checkTargetArch(gblState, 30), (ptxMsgFeatureRequiresSMVersion,sourcePos,"sust.p with array geometry","sm_30") );
            checkFeatureVersion(gblState, 4, 1, "sust.p with array geometry", sourcePos);
        }
        checkFeatureVersion(gblState, 2, 3, "array geometry", sourcePos);
    }
    if (textureGeom == ptxLWBE_MOD || textureGeom == ptxALWBE_MOD) {
        stdCHECK_WITH_POS(!ptxTexHasOffsetArg(gblState, instr), (ptxMsgIllegalModifier, sourcePos, get_strTEXTURE(gblState->parseData), name));
        if (tcode == ptx_tex_grad_Instr) {
            checkFeatureVersion(gblState, 4, 3, "tex.grad with lwbe geometry", sourcePos);
            stdCHECK_WITH_POS( checkTargetArch(gblState, 20), (ptxMsgFeatureRequiresSMVersion,sourcePos,"tex.grad.{lwbe, alwbe}","sm_20"));
        }
        stdCHECK_WITH_POS( ptxIsTextureInstr(tcode), (ptxMsgIllegalModifier,sourcePos, get_strTEXTURE(gblState->parseData), name) );
        stdCHECK_WITH_POS( stdIMPLIES(textureGeom == ptxALWBE_MOD, checkTargetArch(gblState, 20)),
                           (ptxMsgFeatureRequiresSMVersion,sourcePos,"lwbemap array","sm_20") );
        checkFeatureVersion(gblState, 3, 0, "lwbemap textures", sourcePos);
    }
    if (textureGeom == ptx2DMS_MOD || textureGeom == ptxA2DMS_MOD) {
        stdCHECK_WITH_POS(checkTargetArch(gblState, 30), (ptxMsgFeatureRequiresSMVersion,sourcePos,"multi-sample textures","sm_30") );
        checkFeatureVersion(gblState, 3, 2, "multi-sample textures", sourcePos);
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        stdCHECK_WITH_POS( ptxIsTexInstr(tcode) &&
                           !(tcode==ptx_tex_grad_Instr
                             || tcode==ptx_tex_level_Instr
                             || tcode==ptx_tex_clamp_Instr
                             || tcode==ptx_tex_grad_clamp_Instr),
                             (ptxMsgIllegalModifier,sourcePos,"Multi-sample geometry",name) );
#else
        stdCHECK_WITH_POS( ptxIsTexInstr(tcode) &&
                           !(tcode==ptx_tex_grad_Instr
                             || tcode==ptx_tex_level_Instr),
                             (ptxMsgIllegalModifier,sourcePos,"Multi-sample geometry",name) );
#endif
    }
    //COMPMOD
    stdCHECK_WITH_POS(
            stdIMPLIES( ptxHasCOMPONENT_MOD(gblState->parseData->modifiers), ptxHasCOMPMOD_Feature(template->features)),
            (ptxMsgIllegalModifier,sourcePos,"Component",name)
    );
    stdCHECK_WITH_POS(
            stdIMPLIES( ptxHasCOMPMOD_Feature(template->features), ptxHasCOMPONENT_MOD(gblState->parseData->modifiers)),
            (ptxMsgModifierRequired,sourcePos,"Component",name)
    );


    //TEXQ,SMPLQ,SURFQ
    // - TexQuery that isn't a SurfQuery requires TEXQ feature
    // - SamplerQuery always requires SMPLQ feature
    // - SurfQuery is legal for txq or suq, so requires either SURFQ or TEXQ feature
    stdCHECK_WITH_POS(
            stdIMPLIES( ptxHasTexQueryModifier(gblState->parseData->modifiers) && !ptxHasSurfQueryModifier(gblState->parseData->modifiers), ptxHasTEXQ_Feature(template->features)),
            (ptxMsgQueryIllegal,sourcePos,name)
    );
    stdCHECK_WITH_POS(
            stdIMPLIES( ptxHasSamplerQueryModifier(gblState->parseData->modifiers), ptxHasSMPLQ_Feature(template->features)),
            (ptxMsgQueryIllegal,sourcePos,name)
    );
    stdCHECK_WITH_POS(
            stdIMPLIES( ptxHasSurfQueryModifier(gblState->parseData->modifiers), ptxHasSURFQ_Feature(template->features) || ptxHasTEXQ_Feature(template->features)),
            (ptxMsgQueryIllegal,sourcePos,name)
    );

    stdCHECK_WITH_POS(
            stdIMPLIES( ptxHasQUERY_MOD(gblState->parseData->modifiers),
                        ptxHasSURFQ_Feature(template->features)|ptxHasSMPLQ_Feature(template->features)|ptxHasTEXQ_Feature(template->features)),
            (ptxMsgQueryIllegal,sourcePos,name)
    );
    stdCHECK_WITH_POS(
            stdIMPLIES( ptxHasSURFQ_Feature(template->features)|ptxHasSMPLQ_Feature(template->features)|ptxHasTEXQ_Feature(template->features),
                        ptxHasQUERY_MOD(gblState->parseData->modifiers)),
            (ptxMsgModifierRequired,sourcePos,"Query", name)
    );
    if (gblState->parseData->modifiers.QUERY==ptxQUERY_CHTYPE_MOD) checkFeatureVersion(gblState, 2, 1, "channel_data_type attribute", sourcePos);
    if (gblState->parseData->modifiers.QUERY==ptxQUERY_CHORDER_MOD) checkFeatureVersion(gblState, 2, 1, "channel_order attribute", sourcePos);
    if (gblState->parseData->modifiers.QUERY==ptxQUERY_UNNORM_MOD) checkFeatureVersion(gblState, 2, 2, "force_unnormalized_coords attribute", sourcePos);

    if (gblState->parseData->modifiers.QUERY == ptxQUERY_ARRSIZE_MOD) {
        checkFeatureVersion(gblState, 4, 1, "array_size attribute", sourcePos);
    }

    if (gblState->parseData->modifiers.QUERY == ptxQUERY_MIPLEVEL_MOD) {
        checkFeatureVersion(gblState, 4, 1, "num_mipmap_levels attribute", sourcePos);
        stdCHECK_WITH_POS( checkTargetArch(gblState, 20), (ptxMsgFeatureRequiresSMVersion,sourcePos,"num_mipmap_levels attribute","sm_20") );
    }

    if (gblState->parseData->modifiers.QUERY == ptxQUERY_SAMPLES_MOD) {
        checkFeatureVersion(gblState, 4, 1, "num_samples attribute", sourcePos);
        stdCHECK_WITH_POS( checkTargetArch(gblState, 30), (ptxMsgFeatureRequiresSMVersion,sourcePos,"num_samples attribute","sm_30") );
    }

    if (gblState->parseData->modifiers.QUERY == ptxQUERY_LAYOUT_MOD) {
        checkFeatureVersion(gblState, 4, 2, "memory_layout attribute", sourcePos);
    }

    //CLAMP -- must be specified
    stdCHECK_WITH_POS( stdIMPLIES(gblState->parseData->modifiers.CLAMP, ptxHasCLAMP_Feature(template->features)), (ptxMsgIllegalModifier,sourcePos,"Clamp",name) );
    stdCHECK_WITH_POS( stdIMPLIES(ptxHasCLAMP_Feature(template->features), gblState->parseData->modifiers.CLAMP), (ptxMsgModifierRequired,sourcePos,"Clamp",name) );
    stdCHECK_WITH_POS( stdIMPLIES(gblState->parseData->modifiers.CLAMP, checkValidClamp(gblState, tcode, gblState->parseData->modifiers.CLAMP, sourcePos)), (ptxMsgIllegalModifier,sourcePos,"Clamp",name) );
        
    // SHR -- optional
    stdCHECK_WITH_POS(
            stdIMPLIES(gblState->parseData->modifiers.SHR, ptxHasSHR_Feature(template->features)),
            (ptxMsgIllegalModifier,sourcePos,"Shift-right",name)
    );
    
    // VMAD -- optional
    stdCHECK_WITH_POS(
            stdIMPLIES(gblState->parseData->modifiers.VMAD==ptxVMAD_PO_MOD, ptxHasVMAD_Feature(template->features)),
            (ptxMsgIllegalModifier, sourcePos, getVMADAsString(ptxVMAD_PO_MOD), name)
    );
    stdCHECK_WITH_POS(
            stdIMPLIES(gblState->parseData->modifiers.VMAD==ptxVMAD_NEG_AB_MOD || gblState->parseData->modifiers.VMAD==ptxVMAD_NEG_C_MOD, ptxHasVMAD_Feature(template->features)),
            (ptxMsgVmadNegNotAllowed,sourcePos,name)
    );
    
    // PRMT -- optional
    stdCHECK_WITH_POS(
            stdIMPLIES(gblState->parseData->modifiers.PRMT, ptxHasPRMT_Feature(template->features)),
            (ptxMsgIllegalModifier,sourcePos,"Permute",name)
    );
    
    // ENDIS -- required
    stdCHECK_WITH_POS(
            stdIMPLIES( gblState->parseData->modifiers.ENDIS, ptxHasENDIS_Feature(template->features) ),
            (ptxMsgIllegalModifier,sourcePos,"Enable/disable",name)
    );
    stdCHECK_WITH_POS(
            stdIMPLIES( ptxHasENDIS_Feature(template->features), gblState->parseData->modifiers.ENDIS ),
            (ptxMsgModifierRequired,sourcePos,"Enable/disable",name)
    );
    

    // TTUSLOT -- optional
    stdCHECK_WITH_POS(
            stdIMPLIES(ptxHasTTUSLOT_MOD(gblState->parseData->modifiers), ptxHasTTUSLOT_Feature(template->features)),
            (ptxMsgIllegalModifier, sourcePos, getTTUSLOTAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxTTUSLOT_DUAL_MOD), name)
    );

    // TTU -- optional
    stdCHECK_WITH_POS(
            stdIMPLIES(ptxHasTTU_MOD(gblState->parseData->modifiers), ptxHasTTU_Feature(template->features)),
            (ptxMsgIllegalModifier, sourcePos, getTTUMODAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxTTU_CLOSE_MOD), name)
    );

#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    // NUM
    stdCHECK_WITH_POS(
            stdIMPLIES(ptxHasNUM_MOD(gblState->parseData->modifiers),
                       ptxHasNUM_Feature(template->features)),
                       (ptxMsgIllegalModifier, sourcePos, get_strNUM(gblState->parseData), name)
    );

    // TRANS
    stdCHECK_WITH_POS(
            stdIMPLIES(ptxHasTRANS_MOD(gblState->parseData->modifiers),
                       ptxHasTRANS_Feature(template->features)),
                       (ptxMsgIllegalModifier, sourcePos, get_strTRANS(gblState->parseData), name)
    );

    // EXPAND
    stdCHECK_WITH_POS(
            stdIMPLIES(ptxHasEXPAND_MOD(gblState->parseData->modifiers),
                       ptxHasEXPAND_Feature(template->features)),
                       (ptxMsgIllegalModifier, sourcePos, get_strEXPAND(gblState->parseData), name)
    );
#endif

    // FIXME: update version for guard
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    if (ptxIsTTUInstr(tcode)) {
        uInt targetArch;
        stdCHECK_WITH_POS( stdIMPLIES(ptxHasVECTORIZABLE_Feature(template->features),
                                      vectorSize == 2),
                          (ptxMsgRequiresVectorType,sourcePos,name,2));
#if LWCFG(GLOBAL_ARCH_AMPERE)
        /*
         *  Cannot use checkTargetArch(gblState), since it's usage always returns 'true' 
         *  for internally expanded code. TTU instructions coming out of TTU 
         *  builtin functions should also be checked for valid target arch. 
         */
        sscanf(gblState->target_arch, "%*[^0-9]%d", &targetArch);
#if LWCFG(GLOBAL_GPU_FAMILY_GA10X)
        if (targetArch >= 80  && targetArch < 86)
#else
        if (targetArch >= 80)
#endif
        {
            stdCHECK_WITH_POS(False, (ptxMsgIlwalidInstTargetArch, sourcePos,
                                      name, gblState->target_arch));
        }
#if LWCFG(GLOBAL_GPU_FAMILY_GA10X)
        else if (checkCompilationArch(gblState, 80) && !checkCompilationArch(gblState, 86))
#else
        else if (checkCompilationArch(gblState, 80))
#endif
        {
            stdCHECK_WITH_POS(False, (ptxMsgIlwalidInstCompilationArch, sourcePos,
                                      name, gblState->gpuInfo->internalName));
        }
#endif // Ampere
    }
#endif // #if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)

#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    // As this below check also tests for non-TTU instruction present
    // inside of TTU block, do not make it instruction specific
    checkValidTTUBlock(tcode, gblState, name, sourcePos);
#endif

#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    stdCHECK_WITH_POS(
            stdIMPLIES(ptxHasGROUP_MOD(gblState->parseData->modifiers),
                       ptxHasGROUP_Feature(template->features)),
                       (ptxMsgIllegalModifier, sourcePos, get_strGROUP(gblState->parseData), name)
    );

    stdCHECK_WITH_POS(
            stdIMPLIES(ptxHasSEQ_MOD(gblState->parseData->modifiers),
                       ptxHasSEQ_Feature(template->features)),
                       (ptxMsgIllegalModifier, sourcePos, get_strSEQ(gblState->parseData), name)
    );
#endif

#if LWCFG(GLOBAL_GPU_FAMILY_GA10X) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_72)
    stdCHECK_WITH_POS(
            stdIMPLIES(ptxHasABS_MOD(gblState->parseData->modifiers),
                       ptxHasABS_Feature(template->features)),
                       (ptxMsgIllegalModifier, sourcePos, get_strABS(gblState->parseData), name)
    );
    stdCHECK_WITH_POS(stdIMPLIES(ptxHasABS_MOD(gblState->parseData->modifiers),
                                 ptxHasXORSIGN_MOD (gblState->parseData->modifiers)),
                      (ptxMsgModifierRequiresModifier, sourcePos,
                       getABSAsString(ptxABS_MOD),
                       getXORSIGNAsString(ptxXORSIGN_MOD))
    );
#endif

    // CACHEHINT
#if LWCFG(GLOBAL_ARCH_AMPERE) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_74)
    if (gblState->parseData->modifiers.CACHEHINT) {
        checkCacheHintModifier(gblState, tcode, name, template, sourcePos);
        checkStateSpaceForCacheHint(gblState, tcode, name, gblState->parseData->nrofInstrMemspace, gblState->parseData->storage,
                                    sourcePos);
    }
#endif

    // PROXYKIND
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_75)
    if (gblState->parseData->modifiers.PROXYKIND) {
        checkProxyKindModifier(gblState, tcode, name, template, sourcePos);
    }
#endif

#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
    if (tcode == ptx_tanh_Instr) {
        // Checks for FP32 tanh are done via templates
        if (gblState->parseData->nrofInstructionTypes > 0 &&
            (isF16(instr->type[0]) || isF16x2(instr->type[0]))) {
            // For f16 variants, extended version supports approx while INTERNAL
            // version requires .rz.
            // Internal builds will support both but builds with extended only should
            // support only extended version

            // TODO: Once internal version is removed, no longer required to have these checks
            // explicit checks as templates should error out correctly
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
            // Support both .rz variant and .approx variant
            if (gblState->parseData->modifiers.ROUND) {
                stdCHECK_WITH_POS(gblState->parseData->modifiers.ROUND == ptxRZ_MOD,
                                  (ptxMsgIllegalRoundingModifier, sourcePos, name));
                stdCHECK_WITH_POS(!gblState->parseData->modifiers.APRX, (ptxMsgIllegalModifier, sourcePos,
                                  getAPRXAsString(ptxAPRX_MOD), name));
            } else
#endif
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
            if (True) {
#else
            if (areExtendedInstructionsEnabled(gblState->parseData)) {
#endif
                // extended, public only version, requiring .approx
                stdCHECK_WITH_POS(gblState->parseData->modifiers.APRX, (ptxMsgModifierRequired, sourcePos,
                                                   getAPRXAsString(ptxAPRX_MOD), name));
                stdCHECK_WITH_POS(!gblState->parseData->modifiers.ROUND, (ptxMsgIllegalModifier, sourcePos, "rounding", name));
            }
        } else if (isF32(instr->type[0])) {
            stdCHECK_WITH_POS(gblState->parseData->modifiers.APRX, (ptxMsgModifierRequired, sourcePos,
                                                getAPRXAsString(ptxAPRX_MOD), name));
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_PTX_ISA_FUTURE)
        } else if (gblState->parseData->nrofInstructionTypes == 1 &&
                   (isBF16(gblState->parseData->instructionType[0]) ||
                    isBF16x2(gblState->parseData->instructionType[0]))) {
            stdCHECK_WITH_POS(gblState->parseData->modifiers.APRX,
                              (ptxMsgModifierRequired, sourcePos,
                               getAPRXAsString(ptxAPRX_MOD), name));
#endif // HOPPER && FUTURE
        } else if (gblState->parseData->nrofInstructionTypes != 1) {
            // Exactly one type is expected for tanh
            stdCHECK_WITH_POS(False,
                              (ptxMsgNonMatchingInstrTypes, sourcePos, name));
        }

    }
#endif

    // BRKPT arguments
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL) 
    if (tcode == ptx_brkpt_Instr && gblState->parseData->nrofArguments==1) {
        checkFeatureVersion(gblState, 3, 1, "brkpt arg", sourcePos);
        stdCHECK_WITH_POS( checkTargetArch(gblState, 35), (ptxMsgFeatureRequiresSMVersion,sourcePos,"brkpt arg","sm_35") );

        stdCHECK_WITH_POS( gblState->parseData->arguments[0]->kind == ptxIntConstantExpression, (ptxMsgIntConstantExpected,sourcePos) ) {
            uInt64 val = gblState->parseData->arguments[0]->cases.IntConstant.i;
            if (checkTargetArch(gblState, 50)) {
                stdCHECK_WITH_POS( (1<=val && val<=7),
                                   (ptxMsgArgValueOutOfRange, sourcePos, 0, name, val, 1, 7) );
            } else {
                stdCHECK_WITH_POS( (1<=val && val<=3),
                                   (ptxMsgArgValueOutOfRange, sourcePos, 0, name, val, 1, 3) );
            }
        }
    }
#endif

    // BRKPT.INTR
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    if (tcode == ptx_intr_cpu_Instr) {
        checkFeatureVersion(gblState, 4, 0, "intr.cpu", sourcePos);
        stdCHECK_WITH_POS( checkTargetArch(gblState, 35), (ptxMsgFeatureRequiresSMVersion,sourcePos,"instr.cpu","sm_35") );
    }
#endif

    // PMEVENT argument range
    if (tcode == ptx_pmevent_Instr) {
        checkFeatureVersion(gblState, 1, 4, name, sourcePos);
        stdCHECK_WITH_POS( gblState->parseData->arguments[0]->kind == ptxIntConstantExpression, (ptxMsgIntConstantExpected,sourcePos) ) {
            uInt64 val = gblState->parseData->arguments[0]->cases.IntConstant.i;
            stdCHECK_WITH_POS( (0<=val && val<=15),
                               (ptxMsgArgValueOutOfRange, sourcePos, 0, name, val, 0, 15) );
        }
    }

    if (tcode == ptx_pmevent_mask_Instr) {
        checkFeatureVersion(gblState, 3, 0, name, sourcePos);
        stdCHECK_WITH_POS( checkTargetArch(gblState, 20), (ptxMsgFeatureRequiresSMVersion,sourcePos,"pmevent.mask","sm_20") );
        stdCHECK_WITH_POS( gblState->parseData->arguments[0]->kind == ptxIntConstantExpression, (ptxMsgIntConstantExpected,sourcePos) ) {
            uInt64 val = gblState->parseData->arguments[0]->cases.IntConstant.i;
            stdCHECK_WITH_POS( (0<=val && val<=0xffff), (ptxMsgArgValueOutOfRange,sourcePos,val,0,0xffff) );
        }
    }
    /*
     * Generic argument format checks
     */
    for (i=0; i<gblState->parseData->nrofArguments; i++) {
        ptxExpression argument = gblState->parseData->arguments[i];

        if (argument->kind == ptxSinkExpression) {
            // checks for sink already done in preprocessInstruction(gblState)
            continue;
        }

        // check vector argument length against vector instruction type or tex/surf geometry
        if (argument->type->kind == ptxVectorType) {
            uInt argVecSize = argument->type->cases.Vector.N;
            stdCHECK_WITH_POS( ptxHasVECTORIZABLE_Feature(template->features) ||
                               isVectorAType(template->argType[i]),
                               (ptxMsgVectorOperandNotAllowed,sourcePos,name)
            );

            if (tcode == ptx_mov_Instr && !ptxHasVECTOR_MOD(gblState->parseData->modifiers)) {
                // Force usage of vector modifier in case of non-vector MOV instruction.
                if (!isBitTypeKind(instr->type[0]->kind)) {
                    stdCHECK_WITH_POS(0, (ptxMsgArgumentVectorMismatch ,sourcePos, name));
                }

                // mov w/o vector mod but with vector operand must be vector-scalar or scalar-vector
                if (i==0) {
                    ptxExpression otherarg = gblState->parseData->arguments[1];
                    stdCHECK_WITH_POS(otherarg->type->kind != ptxVectorType, (ptxMsgIllegalVecVecMov,sourcePos));
                }
            }

            if (ptxIsTextureInstr(tcode)    ||
                tcode == ptx_suld_b_Instr   ||  
                tcode == ptx__sulea_b_Instr ||
                tcode == ptx__sulea_p_Instr )
            {
               // check for unmatched texture geometry and vector dimensions.
                if (i == ptxTexComponentArgNumber(gblState, instr, TEX_COMPONENT_TYPE_COORDS)) {
                    stdCHECK_WITH_POS( argVecSize >= ptxGetTexSurfNumPosComponents(gblState->parseData->modifiers), (ptxMsgTexGeomMismatch,sourcePos,name) );
                }
                if (ptxIsTextureInstr(tcode) && i == ptxTexComponentArgNumber(gblState, instr, TEX_COMPONENT_TYPE_AOFFSET)) {
                    stdCHECK_WITH_POS( argVecSize >= ptxGetTextureDim(gblState->parseData->modifiers), (ptxMsgTexGeomMismatch,sourcePos,name) );
                }
                if (i == 2) { 
                    if (tcode == ptx_tex_Instr && !ptxVersionAtLeast(1,2, gblState) && vectorMode) { // for ptx isa < 1.2, tex coordinate vector same size as dest vector
                        stdCHECK_WITH_POS( argVecSize == vectorSize, (ptxMsgArgumentVectorMismatch, sourcePos, name) );
                    } else {
                        // vector must be large enough to accomodate all dimensions
                        stdCHECK_WITH_POS( argVecSize >= ptxGetTexSurfNumPosComponents(gblState->parseData->modifiers), (ptxMsgTexGeomMismatch,sourcePos,name) );
                    }
                }
                if (ptxIsTexGradInstr(tcode)) {
                    uInt firstPartialIdx = (ptxTexHasSampler(gblState) ? 4 : 3);

                    if (i==firstPartialIdx || i==firstPartialIdx+1) {
                        stdCHECK_WITH_POS( stdIMPLIES( (textureGeom == ptx1D_MOD || textureGeom == ptxA1D_MOD), (argVecSize==1) ), (ptxMsgTexGeomMismatch,sourcePos,name) );
                        stdCHECK_WITH_POS( stdIMPLIES( (textureGeom == ptx2D_MOD || textureGeom == ptxA2D_MOD), (argVecSize==2) ), (ptxMsgTexGeomMismatch,sourcePos,name) );
                        stdCHECK_WITH_POS( stdIMPLIES( (textureGeom == ptx3D_MOD                             ), (argVecSize==4) ), (ptxMsgTexGeomMismatch,sourcePos,name) );
                    }
                }
            } else if (tcode == ptx_sust_b_Instr || tcode == ptx_sust_p_Instr || tcode == ptx_sured_b_Instr || tcode == ptx_sured_p_Instr) {
                if (i==2 && vectorMode) { 
                    stdCHECK_WITH_POS( argVecSize == vectorSize, (ptxMsgArgumentVectorMismatch, sourcePos, name) );
                } else if (i==1) {
                    // vector must be large enough to accomodate all dimensions
                    stdCHECK_WITH_POS( argVecSize >= ptxGetTexSurfNumPosComponents(gblState->parseData->modifiers), (ptxMsgTexGeomMismatch,sourcePos,name) );
                }
            } else if (vectorMode) {
                stdCHECK_WITH_POS( argVecSize == vectorSize, (ptxMsgArgumentVectorMismatch, sourcePos, name) );
            }
        }

        // check video selectors
        stdCHECK_WITH_POS( stdIMPLIES( ptxIsVideoScalarInstr(tcode), isVideoScalarSelector(argument, i) ), (ptxMsgIncorrectVideoSelector,sourcePos,i) );
        //passing the argument member of the instr so that default value may be populated if required
        stdCHECK_WITH_POS( stdIMPLIES( ptxIsVideoSIMD2Instr (tcode), isVideoSIMD2Selector (instr->arguments + i, i) ), (ptxMsgIncorrectVideoSelector,sourcePos,i) );
        stdCHECK_WITH_POS( stdIMPLIES( ptxIsVideoSIMD4Instr (tcode), isVideoSIMD4Selector (instr->arguments + i, i) ), (ptxMsgIncorrectVideoSelector,sourcePos,i) );
        argument = gblState->parseData->arguments[i] = instr->arguments[i];
        
        stdCHECK_WITH_POS(
                stdIMPLIES( i == 0 && argument->kind == ptxVideoSelectExpression,
                            ptxIsVideoSIMD2Instr(tcode) || ptxIsVideoSIMD4Instr(tcode) ||
                            (ptxIsVideoScalarInstr(tcode) && tcode != ptx_vmad_Instr && gblState->parseData->nrofArguments == 4) ),
                (ptxMsgVideoDestSlctNotAllowed,sourcePos,name)
        );
        stdCHECK_WITH_POS(
                stdIMPLIES( i == 0 && argument->kind == ptxVideoSelectExpression && ptxIsVideoScalarInstr(tcode) && gblState->parseData->nrofArguments == 4,
                            gblState->parseData->postop == ptxNOP ),
                (ptxMsgVideoNoDestSlctWithSecOp,sourcePos,name)
        );
        stdCHECK_WITH_POS(
                stdIMPLIES( i > 0 && argument->kind == ptxVideoSelectExpression, ptxIsVideoInstruction(tcode) ),
                (ptxMsgVideoSrcSlctNotAllowed,sourcePos,name)
        );
        stdCHECK_WITH_POS(
                stdIMPLIES( argument->kind == ptxVideoSelectExpression && ptxIsVideoInstruction(tcode), i != 3 ),
                (ptxMsgVideoSrcCSlctNotAllowed,sourcePos)
        );

       /*
        * Allowed forms:
        * - LHS: register
        * - RHS: register, constant, optionally-negated predicate register, and mem-addr
        */
        if (template->argType[i] != ptxImageAType && template->argType[i] != ptxMemoryAType && 
            template->argType[i] != ptxVoidAType  && template->argType[i] != ptxSymbolAType)
        {
            if ( gblState->parseData->arguments[i]->isLhs ) {
                ptxStorageClass argStorage = ptxGetStorage(argument);
                stdCHECK_WITH_POS( ptxIsRegisterStorage(argStorage), (ptxMsgRegisterExpected,sourcePos,i,name) );
            } else if (gblState->parseData->arguments[i]->kind == ptxPredicateExpression) {
                stdCHECK_WITH_POS (ptxIsRegisterStorage( ptxGetStorage(argument->cases.Predicate.arg) ),
                                   (ptxMsgRegisterExpected,sourcePos,i,name) );
            } else {
                stdCHECK_WITH_POS( gblState->parseData->arguments[i]->isConstant, (ptxMsgConstOrRegArgRequired,sourcePos,i,name) );
            }
        }

        switch (template->argType[i]) {
        case ptxFollowAType        :
        case ptxF16x2AType         :
        case ptxScalarF32AType     :
        case ptxU16AType           :
        case ptxU32AType           :
        case ptxU64AType           :
        case ptxS32AType           :
        case ptxF32AType           :
        case ptxB32AType           :
        case ptxB64AType           :
        case ptxConstantIntAType   :
        case ptxConstantFloatAType :
        case ptxSymbolAType        :
        case ptxPredicateVectorAType:
        case ptxLabelAType         :
        case ptxPredicateAType     : break;  // already checked in ptxMatchInstruction

        case ptxImageAType     :
        case ptxMemoryAType    :
        {
                                     // check for AddressRef operand
                                     // square-brackets not required for ptx versions < 1.2
                                     stdCHECK_WITH_POS ( stdIMPLIES(ptxVersionAtLeast(1,2, gblState), gblState->parseData->modifiers.TADDR || argument->kind == ptxAddressRefExpression),
                                                         (ptxMsgAddressExpected,sourcePos,i,name) );
                                     
                                     // FIXME: update version for guard
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
                                     // TTU instruction check for immediate memory addressing
                                     if (ptxIsTTUInstr(tcode)) {
                                         stdCHECK_WITH_POS( stdIMPLIES(argument->kind == ptxAddressRefExpression,
                                                                       argument->cases.AddressRef.arg->kind == ptxIntConstantExpression),
                                                           (ptxMsgConstantArgRequired,sourcePos,i,name));
                                     }
#endif

                                     // texture instruction address checks

                                     // Error if indirect texture/surface access is made prior to sm_30 and PTX version 4.3.
                                     if (ptxIsTextureInstr(tcode) && i == 1 ) {
                                         if (checkTargetOpts(gblState, "texmode_independent")) {
                                                stdCHECK_WITH_POS( argIsOpaqueType(argument, &isTEXREF) || argIsI64Reg(argument), (ptxMsgTexRefOrU64Expected,sourcePos,i,name) );
                                                stdCHECK_WITH_POS( argIsOpaqueType(gblState->parseData->arguments[i+1], &isSAMPLERREF) || argIsI64Reg(gblState->parseData->arguments[i+1]), 
                                                                   (ptxMsgSamplerRefOrU64Expected,sourcePos,i+1,name) );
                                                if (argIsI64Reg(argument) || argIsI64Reg(gblState->parseData->arguments[i+1])) {
                                                    checkFeatureVersion(gblState, 4,3,"indirect texture access with texmode_independent",sourcePos);
                                                    stdCHECK_WITH_POS( checkTargetArch(gblState, 30), (ptxMsgSMVersionRequired,sourcePos,"indirect texture access with texmode_independent","sm_30") );
                                                }
                                         } else { // texmode_unified
                                             stdCHECK_WITH_POS( argIsOpaqueType(argument, &isTEXREF) || argIsI64Reg(argument), (ptxMsgTexRefOrU64Expected,sourcePos,i,name) );
                                             if (argIsI64Reg(argument)) {
                                                 #ifdef ENABLE_OPTIX_HACK
                                                    // FIXME : Hack for optix to not error out for using indirect texture access with ISA 3.0 
                                                    checkFeatureVersion(gblState, 3,0,"indirect texture access",sourcePos);
                                                 #else
                                                    checkFeatureVersion(gblState, 3,1,"indirect texture access",sourcePos);
                                                 #endif
                                                 stdCHECK_WITH_POS( checkTargetArch(gblState, 20), (ptxMsgSMVersionRequired,sourcePos,"indirect texture access","sm_20") );
                                             }
                                         }
                                     }
                                     if (ptxIsTxqInstr(tcode)) {
                                         if (checkTargetOpts(gblState, "texmode_independent")) {
                                                stdCHECK_WITH_POS( stdIMPLIES( ptxHasTexQueryModifier(gblState->parseData->modifiers), (argIsOpaqueType(gblState->parseData->arguments[1], &isTEXREF) || argIsI64Reg(argument)) ),
                                                                    (ptxMsgTexRefOrU64Expected,sourcePos,1,name) );
                                                stdCHECK_WITH_POS( stdIMPLIES( ptxHasSamplerQueryModifier(gblState->parseData->modifiers), (argIsOpaqueType(gblState->parseData->arguments[1], &isSAMPLERREF) || argIsI64Reg(argument)) ),
                                                                    (ptxMsgSamplerRefOrU64Expected,sourcePos,1,name) );
                                         } else { // texmode_unified
                                             stdCHECK_WITH_POS( argIsOpaqueType(argument, &isTEXREF) || argIsI64Reg(argument), (ptxMsgTexRefOrU64Expected,sourcePos,i,name) );
                                             if (argIsI64Reg(argument)) {
                                                 checkFeatureVersion(gblState, 3,1,"indirect texture access",sourcePos);
                                                 stdCHECK_WITH_POS( checkTargetArch(gblState, 20), (ptxMsgSMVersionRequired,sourcePos,"indirect texture access","sm_20") );
                                             }
                                         }
                                        // txq.force_unnormalized_coords requires samplerref argument or u64 register(when indirect access)
                                        stdCHECK_WITH_POS( stdIMPLIES( gblState->parseData->modifiers.QUERY==ptxQUERY_UNNORM_MOD, (argIsOpaqueType(gblState->parseData->arguments[1], &isSAMPLERREF) || argIsI64Reg(argument)) ),
                                                            (ptxMsgSamplerRefExpected,sourcePos,1,name) );
                                        stdCHECK_WITH_POS( stdIMPLIES( tcode == ptx_txq_level_Instr, 
                                                                        (gblState->parseData->modifiers.QUERY==ptxQUERY_WIDTH_MOD
                                                                        || gblState->parseData->modifiers.QUERY==ptxQUERY_HEIGHT_MOD
                                                                        || gblState->parseData->modifiers.QUERY==ptxQUERY_DEPTH_MOD) ),
                                                            (ptxMsgQueryIllegal,sourcePos,name) );
                                         gblState->usesQueryInstruction = True;
                                     }

                                     // surface instruction address check
                                     if (ptxIsSurfaceInstr(tcode) || tcode==ptx_suq_Instr) {
                                         stdCHECK_WITH_POS( argIsOpaqueType(argument, &isSURFREF) || argIsI64Reg(argument), (ptxMsgSurfRefOrU64Expected,sourcePos,i,name) );
                                         if (argIsI64Reg(argument)) {
                                             checkFeatureVersion(gblState, 3,1,"indirect surface access",sourcePos);
                                             stdCHECK_WITH_POS( checkTargetArch(gblState, 20), (ptxMsgSMVersionRequired,sourcePos,"indirect surface access","sm_20") );
                                         }
                                         if (tcode==ptx_suq_Instr) {
                                            // surface queries not yet supported with noCloning.
                                            gblState->usesQueryInstruction = True;
                                        }
                                     }

                                     // @@ do memory operand check
                                     break;
        }

        case ptxTargetAType        : // @@ Must check for label, but see how function calls will work
                                     // check for reference to undeclared function (observed as ptxLabelReferenceExpression) 
                                     // must've been done earlier in this function

                                     if (argument->kind == ptxSymbolExpression && argument->type->kind != ptxLabelType) {
                                         ptxType t = argument->type;
                                         stdCHECK_WITH_POS( (isB32(t) || isB64(t) || isI32(t) || isI64(t)), (ptxMsgIllegalTarget,sourcePos,name) );
                                     }
                                     break;

        case ptxParamListAType     : checkCallParams(gblState, i, sourcePos);
                                     break;

        case ptxVoidAType          : break;  // wildcard argument; any type checking is instruction-specific

        }
    }

    // This is random generation of prefetch size for Sector Promotion stress
    // testing. Random addition is done at the end of processing to avoid
    // version and error checks.
    if (gblState->generatePrefetchSizeSeed && tcode == ptx_ld_Instr
        && !gblState->parseData->modifiers.PREFETCHSIZE && !gblState->parseData->modifiers.CACHEPREFETCH
        && (gblState->parseData->storage[0].kind == ptxGlobalStorage || gblState->parseData->storage[0].kind == ptxGenericStorage))
    {
        if (checkTargetArch(gblState, 80) || checkCompilationArch(gblState, 80)) {
            gblState->parseData->modifiers.PREFETCHSIZE = rand() / ((RAND_MAX / 4) + 1 );
        } else {
            gblState->parseData->modifiers.PREFETCHSIZE = rand() / ((RAND_MAX / 3) + 1 );
        }

        if (gblState->parseData->modifiers.PREFETCHSIZE != 0) {
            gblState->parseData->modifiers.LEVEL = ptxL2_MOD;
            CT_DEBUG_MSG("randomPrefetchSize", 1, "Prefetch size modifier %s added to load instruction on line %d\n",
                         get_strPREFETCHSIZE(gblState->parseData), sourcePos->lineNo );
        }

    }
    if (!errorCheckOnly) {
        instr->modifiers = gblState->parseData->modifiers;
    } else {
        stdFREE(instr->arguments);
        stdFREE(instr->storage);
        stdFREE(instr->type);
        stdFREE(instr->loc);
        stdFREE(instr);
    }
}

static void impliesReserved(ptxParsingState gblState, String a, String b) 
{
    stdSet_t  aliases= mapApply(gblState->parseData->reservedMacroAliases,a);
    
    if (!aliases) { aliases= setNEW(String,1); }
    
    setInsert(aliases,b);
    
    mapDefine(gblState->parseData->reservedMacroAliases,a,aliases);
}

static void isReservedAlias(ptxParsingState gblState, String a, String b) 
{
    impliesReserved(gblState, a,b);
    impliesReserved(gblState, b,a);
}

static void initializeMacros(ptxParsingState gblState)
{
    gblState->parseData->reservedMacroFormals = setNEW(String,8);  
    gblState->parseData->reservedMacroAliases = mapNEW(String,8);  
    
    setInsert( gblState->parseData->reservedMacroFormals, "GUARD"   );
    setInsert( gblState->parseData->reservedMacroFormals, "PRED"    );
    setInsert( gblState->parseData->reservedMacroFormals, "TYPES"   );
    setInsert( gblState->parseData->reservedMacroFormals, "POSTOP"  );
    setInsert( gblState->parseData->reservedMacroFormals, "COMPARE" );
    setInsert( gblState->parseData->reservedMacroFormals, "APRX"    );
    setInsert( gblState->parseData->reservedMacroFormals, "FTZ"     );
    setInsert( gblState->parseData->reservedMacroFormals, "SAT"     );
    setInsert( gblState->parseData->reservedMacroFormals, "CC"      );              
    setInsert( gblState->parseData->reservedMacroFormals, "SHAMT"   );
//  setInsert( gblState->parseData->reservedMacroFormals, "TADDR"   );           
    setInsert( gblState->parseData->reservedMacroFormals, "ORDER"   );
    setInsert( gblState->parseData->reservedMacroFormals, "NC"      );             
    setInsert( gblState->parseData->reservedMacroFormals, "ROUND"   );           
    setInsert( gblState->parseData->reservedMacroFormals, "TESTP"   );           
    setInsert( gblState->parseData->reservedMacroFormals, "FLOW"    );            
    setInsert( gblState->parseData->reservedMacroFormals, "TEXTURE" );         
    setInsert( gblState->parseData->reservedMacroFormals, "QUERY"   );         
    setInsert( gblState->parseData->reservedMacroFormals, "CLAMP"   );           
    setInsert( gblState->parseData->reservedMacroFormals, "SHR"     );             
    setInsert( gblState->parseData->reservedMacroFormals, "VMAD"    );            
    setInsert( gblState->parseData->reservedMacroFormals, "PRMT"    );            
    setInsert( gblState->parseData->reservedMacroFormals, "SHFL"    );            
    setInsert( gblState->parseData->reservedMacroFormals, "ENDIS"   );            
    setInsert( gblState->parseData->reservedMacroFormals, "UNIFORM" );   
    setInsert( gblState->parseData->reservedMacroFormals, "VECTOR"  );          
    setInsert( gblState->parseData->reservedMacroFormals, "VOTE"    );   
    
    isReservedAlias(gblState, "GUARD","PRED");      
}

typedef String (*macroFun_t) (ptxParsingState parseState, char *);

static void recognizeInlineFunction(ptxParsingState gblState,  ptxSymbolTableEntry func, msgSourcePos_t sourcePos, void *scanner)
{
    String         funcName         = func->symbol->name;
    msgSourcePos_t bodyPos          = func->symbol->sourcePos;
    uInt           nrofInputArgs    = listSize(func->aux->funcProtoAttrInfo->fparams);
    uInt           nrofOutputArgs   = listSize(func->aux->funcProtoAttrInfo->rparams);
    int            inputArgPos      = getCallInputArgIdx(gblState);
    int            outputArgPos     = getCallReturnArgIdx(gblState);
    ptxExpression  inputArgsExp     = NULL;
    ptxExpression  outputArgsExp    = NULL;
    stdList_t      inputFormalArgs  = NULL;
    stdList_t      outputFormalArgs = NULL;
    uInt           i, count;
    String         str;
    stdString_t    s;
    macroFun_t     macroFun;
    uInt64         adler32Hash;
    char           adler32HashString[50];

    if (inputArgPos != -1) {
        matchCallee(gblState, func, inputArgPos, sourcePos);
        inputArgsExp = gblState->parseData->arguments[inputArgPos];
        stdASSERT(inputArgsExp->kind == ptxParamListExpression, (""));
        inputFormalArgs = inputArgsExp->cases.ParamList.elements;
    }
    if (outputArgPos != -1) {
        matchCallee(gblState, func, outputArgPos, sourcePos);
        outputArgsExp = gblState->parseData->arguments[outputArgPos];
        stdASSERT(outputArgsExp->kind == ptxParamListExpression, (""));
        outputFormalArgs = outputArgsExp->cases.ParamList.elements;
    }

    initMacroState(gblState->parseData);

    s= stringNEW();
    if (gblState->parseData->guard) {
        ptxPrintExpression(gblState->parseData->guard, s);
    }
    str = stringStripToBuf(s);
    initMacroInstrGuard(gblState->parseData, str);

    initInlineFunctionArgs(gblState->parseData, nrofInputArgs, nrofOutputArgs, funcName, sourcePos);
 
    for (i = 0; i < nrofInputArgs; i++) {
        String str;
        ptxExpression inArg;
        if (!inputFormalArgs) {
            stdCHECK_WITH_POS(False, (ptxMsgCallNArgsDiffer,sourcePos));
            return;
        }
        inArg = inputFormalArgs->head;
        s = stringNEW();
        ptxPrintExpression(inArg,s);
        str = stringStripToBuf(s);
        setInlineFunctionInputArg(gblState->parseData, i, str, inArg);
        inputFormalArgs = inputFormalArgs->tail;
    }
    for (i = 0; i < nrofOutputArgs; i++) {
        String str;
        ptxExpression outArg;
        if (!outputFormalArgs) {
            stdCHECK_WITH_POS(False, (ptxMsgCallNArgsDiffer,sourcePos));
            return;
        }
        outArg = outputFormalArgs->head;
        s = stringNEW();
        ptxPrintExpression(outArg,s);
        str = stringStripToBuf(s);
        setInlineFunctionOutputArg(gblState->parseData, i, str, outArg);
        outputFormalArgs = outputFormalArgs->tail;
    }

    if (inputFormalArgs != NULL || outputFormalArgs != NULL) {
        stdASSERT(msgErrorsFound(), ("argument mismatch error not emitted"));
    }
    // First argument is 0x01 to ensure hash computation done in Perl and C exactly match.
    adler32Hash = (uInt64)adler32(0x01, (Byte*)funcName, strlen(funcName));
    count = snprintf(adler32HashString, 50, "%llu", adler32Hash);
    stdASSERT(count <= 50, ("Too many digits in the hash of inline function %s", funcName));
    macroFun = (macroFun_t)mapApply(gblState->inlineFuncsMap, adler32HashString);
    stdASSERT(macroFun, ("Unable to find the body for inline function %s", funcName));

    str = (*macroFun)(gblState, gblState->deobfuscatedMacro);

    // remove comments and set current instruction name
    CT_DEBUG_DO("macro_expansion", 1,
                 preProcessMacroForPrint(str, stdCONCATSTRING(funcName, " (FORCE INLINE FUNCTION)"), gblState););
    ptxPushMacroBody(str, msgGetFileName(bodyPos), bodyPos->lineNo, gblState, scanner);

    if (gblState->lwrInstrSrc == UserPTX) {
        gblState->parseData->lastUserSymbolTable = gblState->lwrSymbolTable;
        gblState->lwrInstrSrc         = InlineFunction;
    }
    freeInlineFunctionArgs(gblState->parseData);
}

static void recognizeMacroInstruction(ptxParsingState gblState,  String name, ptxSymbolTableEntry entry, msgSourcePos_t sourcePos, void *scanner)
{
    stdList_t      formals               = entry->aux->funcProtoAttrInfo->fparams; // list of names
    msgSourcePos_t bodyPos               = entry->aux->mbodyPos;
    stdString_t    s;
    uInt           i;
    String str;
    macroFun_t     macroFun;

        /* --- . --- */

    initMacroState(gblState->parseData);

    s= stringNEW();
    if (gblState->parseData->guard) {
        ptxPrintExpression(gblState->parseData->guard, s);
    }
    str = stringStripToBuf(s);
    initMacroInstrGuard(gblState->parseData, str);

    initMacroInstrTypes(gblState->parseData, gblState->parseData->instructionType, gblState->parseData->nrofInstructionTypes);
    initMacroNumInstrArgs(gblState->parseData, gblState->parseData->nrofArguments);

    s= stringNEW();
    if (gblState->parseData->predicateOutput) {
        ptxPrintExpression(gblState->parseData->predicateOutput, s);
    }
    str = stringStripToBuf(s);
    initMacroPredicateOutput(gblState->parseData, str);

    for (i=0; i<gblState->parseData->nrofArguments; i++) {
        if (!formals) {
            stdCHECK_WITH_POS(False,(ptxMsgTooManyOperands,sourcePos,name));
            break;
        } else {
            String str;
            s= stringNEW();
            ptxPrintExpression(gblState->parseData->arguments[i],s);
            str = stringStripToBuf(s);
            initMacroInstrArgs(gblState->parseData, str, i);
            formals= formals->tail;
        }
    }
    macroFun = (macroFun_t)mapApply(gblState->macroMap, name);
    str = (*macroFun)(gblState, gblState->deobfuscatedMacro);

    // remove comments and set current instruction name
    CT_DEBUG_DO("macro_expansion", 1, preProcessMacroForPrint(str, name, gblState););
    ptxPushMacroBody(str, msgGetFileName(bodyPos), bodyPos->lineNo, gblState, scanner);

    if (gblState->lwrInstrSrc == UserPTX) {
        gblState->parseData->lastUserSymbolTable = gblState->lwrSymbolTable;
        gblState->lwrInstrSrc         = Macro;
    }
    freeMacroState(gblState->parseData, gblState->parseData->nrofArguments);
}

static Bool isInlineFunctionCall(ptxParsingState gblState, ptxInstructionTemplate template)
{
    ptxExpression funcSym;
    ptxSymbolTableEntry lfuncSymEnt;

    if (template->code != ptx_call_Instr) {
        return False;
    }

    funcSym = gblState->parseData->arguments[getCallTargetIdx(gblState)];
    if (funcSym->kind != ptxSymbolExpression) {
        return False;
    }

    lfuncSymEnt = ptxGetSymEntFromExpr(funcSym);
    if (lfuncSymEnt->kind != ptxFunctionSymbol) {
        return False;
    }

    if (lfuncSymEnt->aux->isInlineFunc) {
        return True;
    }

    return False;
}

static ptxSymbolTableEntry getInlineFunctionCallSymEnt(ptxParsingState gblState, ptxInstructionTemplate template)
{
    ptxExpression funcSym;

    stdASSERT(isInlineFunctionCall(gblState, template),
              ("Must be called only for inline function calls"));
    funcSym = gblState->parseData->arguments[getCallTargetIdx(gblState)];
    return ptxGetSymEntFromExpr(funcSym);
}

static void recognizeInstruction(ptxParsingState gblState,  Bool macroAllowed, String name, msgSourcePos_t sourcePos, void *scanner)
{
    ptxInstructionKind lwrInstrKind = RealInstruction;
    ptxSymbolTableEntry macroInstrSym = NULL, inlineFuncSym = NULL;
    ptxInstructionTemplate template = preprocessInstruction(gblState,  name, macroAllowed, ptxUserPos(gblState, &sourcePos) );

    // Do not process instruction if template is not found.
    if (template) {
        if (macroAllowed) {
            macroInstrSym = ptxLookupSymbol(gblState->macroSymbolTable, name, True, gblState);
            if (macroInstrSym && macroInstrSym->kind == ptxMacroSymbol) {
                lwrInstrKind = MacroInstruction;
            } else if (isInlineFunctionCall(gblState, template)) {
                lwrInstrKind = InlineFunctionCall;
                inlineFuncSym = getInlineFunctionCallSymEnt(gblState, template);
            }
        }

        // Bypass internal expansions if there were parse errors. The
        // expansions manipulate ptxIR with impunity, which can cause
        // the parser to crash when pre-conditions are not met. We
        // could just bail out at this point, but pretending that the
        // instruction is "real" allows the parsing to continue and
        // report more errors.
        if (msgErrorsFound())
            lwrInstrKind = RealInstruction;

        switch (lwrInstrKind) {
        case RealInstruction:
            recognizeRealInstruction(gblState,  name, template, False, ptxUserPos(gblState, &sourcePos) ); break;
        case MacroInstruction:
            // When PTX macro instruction is expanded, all the error checks
            // present in recognizeRealInstruction happen on expanded instructions
            // and not on original instruction in input source.Therefore, to detect errors
            // in original instruction we call "recognizeRealInstruction" with flag
            // "errorCheckOnly" so that it will do only error check on instruction without
            // adding it to PTXIR.
            // NOTE: This is short term WAR,in actual fix we should move all error
            // checks into separate function and call it for every instruction.
            recognizeRealInstruction(gblState,  name, template, True, ptxUserPos(gblState, &sourcePos));
            if (msgErrorsFound()) {
                // Do not expand macro instruction if errors are present in
                // original input source
                break;
            }
            recognizeMacroInstruction(gblState,  name, macroInstrSym, sourcePos, scanner); break;
        case InlineFunctionCall:
            recognizeInlineFunction(gblState,  inlineFuncSym, sourcePos, scanner ); break;
        default:
            stdASSERT(False, ("unknown input type"));
        }
    }

    initInstrParseState(gblState);

    // After parsing an instruction completely, check for vector type of the last modifier 
    checkIsLastSeelwectorType(gblState, False, sourcePos);

    stdMEMCLEAR(&gblState->parseData->modifiers);
}

static void ptxProcessLocalMaxNRegPragma(ptxParsingState gblState,  stdList_t pragmas, msgSourcePos_t sourcePos )
{
    stdList_t l;
    String localMaxNRegStr = getLWSTOMABIPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxLocalMaxNReg_PRG);

    for (l = pragmas; l; l = l->tail) {
        uInt localMaxNReg = 0;
        String pragma = (String)l->head;

        Bool localMaxNRegPragma = stdIS_PREFIX(localMaxNRegStr, pragma);

        if (!localMaxNRegPragma) continue;

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
        localMaxNReg = ptxGetPragmaValue(gblState->parseData, pragma);

        checkFeatureVersion(gblState, 6, 3, localMaxNRegStr, sourcePos);
        checkFeatureTarget(gblState, 30,   localMaxNRegStr, sourcePos);

        stdASSERT(gblState->parseData->lwrFunc, ("pragma statement outside function body"));
        stdCHECK_WITH_POS(gblState->parseData->lwrFunc->aux->localMaxNReg == 0,
                          (ptxMsgMultiplePragmaSpecified, sourcePos,
                           localMaxNRegStr, gblState->parseData->lwrFunc->symbol->name));

        stdCHECK_WITH_POS(localMaxNReg <= gblState->gpuInfo->maxRegsPerThread,
                          (ptxMsgWrongValue, sourcePos, localMaxNRegStr, localMaxNReg,
                           gblState->gpuInfo->profileName));

        gblState->parseData->lwrFunc->aux->localMaxNReg = localMaxNReg;
#else
        stdCHECK_WITH_POS(False, (ptxMsgUnknownPragma, sourcePos, pragma));
#endif
    }
}

static void checkAbiParamRegPragma(ptxParsingState gblState, String pragma, int numParamReg, int firstParamReg,
                                   msgSourcePos_t sourcePos,
                                   Bool isModuleScopePragma)
{
    Bool isCallSitePragma = stdIS_PREFIX("call_", pragma);
    String abiParamRegStr = getLWSTOMABIPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxAbiParamReg_PRG);
    String callAbiParamRegStr = getLWSTOMABIPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxCallAbiParamReg_PRG);

    if (firstParamReg != UNSPECIFIED_ABI_REG) {
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
        checkFeatureVersion(gblState, 6, 3, pragma, sourcePos);
        checkFeatureTarget(gblState, 30,   pragma, sourcePos);
#else
        stdCHECK_WITH_POS(False, (ptxMsgIncorrectPragmaArgs, sourcePos, pragma));
        return;
#endif
    }

    if (numParamReg > (int) gblState->gpuInfo->maxRegsPerThread) {
        stdCHECK_WITH_POS(False, (ptxMsgWrongValue, sourcePos,
                                  (isCallSitePragma ? callAbiParamRegStr : abiParamRegStr),
                                  numParamReg,
                                  gblState->gpuInfo->profileName));
    }

    if (firstParamReg != UNSPECIFIED_ABI_REG) {
        stdCHECK_WITH_POS(firstParamReg <= gblState->gpuInfo->maxRegsPerThread,
                          (ptxMsgWrongValue, sourcePos,
                           (isCallSitePragma ? callAbiParamRegStr : abiParamRegStr),
                           firstParamReg, gblState->gpuInfo->profileName));

        stdCHECK_WITH_POS(firstParamReg >= GPU_INFO_FIRST_ALLOWED_PARAM_REGISTER,
                          (ptxMsgABIReservedRegsUsage, sourcePos, "parameter passing"));
    }


    if (isModuleScopePragma)
        return;

    if (isCallSitePragma)
        return;

    stdASSERT(gblState->parseData->lwrFunc, ("pragma statement outside function body"));
    if (gblState->parseData->lwrFunc->aux->isEntry) {
        stdCHECK_WITH_POS(False, (ptxMsgIlwalidPragma, sourcePos,
                                  pragma, gblState->parseData->lwrFunc->symbol->name));
        return;
    }

    stdCHECK_WITH_POS(!usesLwdaSass(gblState->parseData->lwrFunc),
                      (ptxMsgIlwalidPragma, sourcePos, pragma,
                       gblState->parseData->lwrFunc->symbol->name));

    stdCHECK_WITH_POS(gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->numAbiParamRegs == UNSPECIFIED_ABI_PARAM_REGS,
                      (ptxMsgMultiplePragmaSpecified, sourcePos,
                       pragma, gblState->parseData->lwrFunc->symbol->name));
}

static void ptxProcessAbiParamRegPragma(ptxParsingState gblState, String pragma, msgSourcePos_t sourcePos)
{
    int numParams, firstParamReg;
    ptxGetAbiParamRegPragma(pragma, &numParams, &firstParamReg, gblState);
    checkAbiParamRegPragma(gblState, pragma, numParams, firstParamReg, sourcePos, False);

    if (stdIS_PREFIX("call_", pragma)) {
        return;
    }

    gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->numAbiParamRegs = numParams;
    gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->firstParamReg   = firstParamReg;
}

static void ptxProcessRetAddrBeforeParamsPragma(ptxParsingState gblState, String pragma, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    checkFeatureVersion(gblState, 6, 3, pragma, sourcePos);
    checkFeatureTarget(gblState, 30,   pragma, sourcePos);

    if (stdIS_PREFIX("call_", pragma))
        return;

    stdASSERT(gblState->parseData->lwrFunc, ("pragma statement outside function body"));
    if (gblState->parseData->lwrFunc->aux->isEntry) {
        stdCHECK_WITH_POS(False, (ptxMsgIlwalidPragma, sourcePos,
                                  pragma, gblState->parseData->lwrFunc->symbol->name));
        return;
    }

    stdCHECK_WITH_POS(!usesLwdaSass(gblState->parseData->lwrFunc),
                      (ptxMsgIlwalidPragma, sourcePos, pragma,
                       gblState->parseData->lwrFunc->symbol->name));

    stdCHECK_WITH_POS(gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->retAddrBeforeParams != 1,
                      (ptxMsgMultiplePragmaSpecified, sourcePos,
                       pragma, gblState->parseData->lwrFunc->symbol->name));

    // Also need abi_param_reg but cannot be checked here as abi_param_reg
    // may be defined after this but before callsite/function-body
    gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->retAddrBeforeParams = 1;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownPragma, sourcePos, pragma));
#endif
}


#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
static void checkRetAddrRegPragma(ptxParsingState gblState, String pragma, int retAddrReg,
                                  msgSourcePos_t sourcePos,
                                  Bool isModuleScopePragma,
                                  Bool *isRetAddrInUReg)
{
    uInt isaMajVersion = 0, isaMilwersion = 0, smTarget = 0;
    size_t nameLen = 0, nameLen2 = 0;
    String pragmaName, pragmaWithoutRegType;
    Bool isCallSitePragma = stdIS_PREFIX("call_", pragma);
    Bool usesUReg = stdIS_PREFIX(getLWSTOMABIPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxCallRetAddrRegU_PRG), pragma) ||
                    stdIS_PREFIX(getLWSTOMABIPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxRetAddrRegU_PRG), pragma);
    Bool hasRegType = usesUReg ||
                      stdIS_PREFIX(getLWSTOMABIPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxCallRetAddrRegR_PRG), pragma) ||
                      stdIS_PREFIX(getLWSTOMABIPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxRetAddrRegR_PRG), pragma);
    uInt maxRegLimit = 0;
    
    nameLen = strcspn(pragma, " ");
    pragmaName = strncpy(stdMALLOC(nameLen + 1), pragma, nameLen);
    pragmaName[nameLen] = 0;
    
    nameLen2 = strcspn(pragmaName, "<");
    pragmaWithoutRegType = strncpy(stdMALLOC(nameLen2 + 1), pragmaName, nameLen2);
    pragmaWithoutRegType[nameLen2] = 0;

    stdASSERT(pragmaName != NULL, ("unexpected pragma"));


    if (isRetAddrInUReg) {
        *isRetAddrInUReg = usesUReg;
    }

    if (hasRegType) {
#if LWCFG(GLOBAL_ARCH_TURING) && LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_64)
        isaMajVersion = 6;
        isaMilwersion = 4;
        smTarget = usesUReg ? 75 : 70;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownPragma, sourcePos, pragma));
    return;
#endif
    } else {
        isaMajVersion = 6;
        isaMilwersion = 3;
        smTarget = 70;
    }
    checkFeatureVersion(gblState, isaMajVersion, isaMilwersion, pragma, sourcePos);
    checkFeatureTarget(gblState, smTarget, pragma, sourcePos);


    maxRegLimit = (usesUReg) ? GPU_INFO_MAX_USER_UREGS_TURING :
                               gblState->gpuInfo->maxRegsPerThread;

    if (retAddrReg < 0 || retAddrReg > maxRegLimit) {
        stdCHECK_WITH_POS(False, (ptxMsgWrongValue, sourcePos,
                                  pragmaName, retAddrReg,
                                  gblState->gpuInfo->profileName));
    }

    stdCHECK_WITH_POS(stdIMPLIES(!usesUReg,
                                 retAddrReg >= GPU_INFO_FIRST_ALLOWED_PARAM_REGISTER),
                      (ptxMsgABIReservedRegsUsage, sourcePos, "return address passing"));

    if (isModuleScopePragma)
        return;

    if (isCallSitePragma)
        return;

    stdASSERT(gblState->parseData->lwrFunc, ("pragma statement outside function body"));
    if (gblState->parseData->lwrFunc->aux->isEntry) {
        stdCHECK_WITH_POS(False, (ptxMsgIlwalidPragma, sourcePos,
                                  pragma, gblState->parseData->lwrFunc->symbol->name));
        return;
    }

    stdCHECK_WITH_POS(!usesLwdaSass(gblState->parseData->lwrFunc),
                      (ptxMsgIlwalidPragma, sourcePos, pragma,
                       gblState->parseData->lwrFunc->symbol->name));

    stdCHECK_WITH_POS((gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->retAddrReg == UNSPECIFIED_ABI_REG &&
                       gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->retAddrUReg == UNSPECIFIED_ABI_REG &&
                       gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->relRetAddrReg == UNSPECIFIED_ABI_REG),
                      (ptxMsgMultiplePragmaSpecified, sourcePos,
                       pragmaWithoutRegType, gblState->parseData->lwrFunc->symbol->name));
}
#endif

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
static void checkRelativeRetAddrRegPragma(ptxParsingState gblState, String pragma, int retAddrReg,
                                          msgSourcePos_t sourcePos,
                                          Bool isModuleScopePragma)
{
    size_t nameLen = 0, nameLen2 = 0;
    String pragmaName, pragmaWithoutRegType;
    Bool isCallSitePragma = stdIS_PREFIX("call_", pragma);

    uInt maxRegLimit = 0;
    
    nameLen = strcspn(pragma, " ");
    pragmaName = strncpy(stdMALLOC(nameLen + 1), pragma, nameLen);
    pragmaName[nameLen] = 0;
    
    nameLen2 = strcspn(pragmaName, "<");
    pragmaWithoutRegType = strncpy(stdMALLOC(nameLen2 + 1), pragmaName, nameLen2);
    pragmaWithoutRegType[nameLen2] = 0;

    stdASSERT(pragmaName != NULL, ("unexpected pragma"));
 
    checkFeatureVersion(gblState, 7, 0, pragma, sourcePos);
    checkFeatureTarget(gblState, 70, pragma, sourcePos);

    maxRegLimit = gblState->gpuInfo->maxRegsPerThread;

    if (retAddrReg < 0 || retAddrReg > maxRegLimit) {
        stdCHECK_WITH_POS(False, (ptxMsgWrongValue, sourcePos,
                                  pragmaName, retAddrReg,
                                  gblState->gpuInfo->profileName));
    }

    stdCHECK_WITH_POS((retAddrReg >= GPU_INFO_FIRST_ALLOWED_PARAM_REGISTER),
                      (ptxMsgABIReservedRegsUsage, sourcePos, "return address passing"));

    if (isModuleScopePragma)
        return;

    if (isCallSitePragma)
        return;

    stdASSERT(gblState->parseData->lwrFunc, ("pragma statement outside function body"));
    if (gblState->parseData->lwrFunc->aux->isEntry) {
        stdCHECK_WITH_POS(False, (ptxMsgIlwalidPragma, sourcePos,
                                  pragma, gblState->parseData->lwrFunc->symbol->name));
        return;
    }

    stdCHECK_WITH_POS(!usesLwdaSass(gblState->parseData->lwrFunc),
                      (ptxMsgIlwalidPragma, sourcePos, pragma,
                       gblState->parseData->lwrFunc->symbol->name));

    stdCHECK_WITH_POS((gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->retAddrReg == UNSPECIFIED_ABI_REG &&
                       gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->retAddrUReg == UNSPECIFIED_ABI_REG &&
                       gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->relRetAddrReg == UNSPECIFIED_ABI_REG),
                      (ptxMsgMultiplePragmaSpecified, sourcePos,
                       pragmaWithoutRegType, gblState->parseData->lwrFunc->symbol->name));
}
#endif

static void ptxProcessRelativeRetAddrRegPragma(ptxParsingState gblState, String pragma, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    int relRetAddrReg = ptxGetPragmaValue(gblState->parseData, pragma);
    checkRelativeRetAddrRegPragma(gblState, pragma, relRetAddrReg, sourcePos, False);

    if (stdIS_PREFIX("call_", pragma)) {
        return;
    }

    gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->relRetAddrReg = relRetAddrReg;
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownPragma, sourcePos, pragma));
#endif // ISA_70
}

static void ptxProcessRetAddrRegPragma(ptxParsingState gblState, String pragma, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
    Bool usesUReg = False;
    int retAddrReg = ptxGetPragmaValue(gblState->parseData, pragma);
    checkRetAddrRegPragma(gblState, pragma, retAddrReg, sourcePos, False, &usesUReg);

    if (stdIS_PREFIX("call_", pragma)) {
        return;
    }

    if (usesUReg) {
        gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->retAddrUReg = retAddrReg;
    } else {
        gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->retAddrReg  = retAddrReg;
    }
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownPragma, sourcePos, pragma));
#endif
}

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)
static void checkScratchRegsPragma(ptxParsingState gblState, String pragma, stdList_t scratchRegs,
                                   msgSourcePos_t sourcePos, Bool isRReg,
                                   Bool isModuleScopePragma)
{
    checkFeatureVersion(gblState, 6, 3, pragma, sourcePos);
    if (isRReg) {
        checkFeatureTarget(gblState, 30,   pragma, sourcePos);
    } else {
        checkFeatureTarget(gblState, 70,   pragma, sourcePos);
    }

    stdList_t l;
    Bool isCallSitePragma = stdIS_PREFIX("call_", pragma);

    for (l = scratchRegs; l && l->tail; l = l->tail) {
        int reg = (int)(Address)l->head;
        if (isRReg) {
            stdCHECK_WITH_POS(reg <= gblState->gpuInfo->maxRegsPerThread,
                              (ptxMsgWrongValue, sourcePos,
                               (isCallSitePragma ? getLWSTOMABIPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxCallScratchRegsR_PRG) :
                                                   getLWSTOMABIPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxScratchRegsR_PRG)),
                               reg, gblState->gpuInfo->profileName));
        } else {
            stdCHECK_WITH_POS(reg <= GPU_INFO_MAX_USER_BARRIER_REGS,
                              (ptxMsgWrongValue, sourcePos,
                               (isCallSitePragma ? getLWSTOMABIPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxCallScratchRegsB_PRG) :
                                                   getLWSTOMABIPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxScratchRegsB_PRG)),
                               reg, gblState->gpuInfo->profileName));
        }
    }

    if (isModuleScopePragma)
        return;

    if (isCallSitePragma)
        return;

    stdASSERT(gblState->parseData->lwrFunc, ("pragma statement outside function body"));
    if (gblState->parseData->lwrFunc->aux->isEntry) {
        stdCHECK_WITH_POS(False, (ptxMsgIlwalidPragma, sourcePos,
                                  pragma, gblState->parseData->lwrFunc->symbol->name));
        return;
    }

    stdCHECK_WITH_POS(!usesLwdaSass(gblState->parseData->lwrFunc),
                      (ptxMsgIlwalidPragma, sourcePos, pragma,
                       gblState->parseData->lwrFunc->symbol->name));

    stdCHECK_WITH_POS((isRReg ? gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->scratchRRegs : gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->scratchBRegs)
                       == UNSPECIFIED_ABI_REGS,
                      (ptxMsgMultiplePragmaSpecified, sourcePos,
                       pragma, gblState->parseData->lwrFunc->symbol->name));
}
#endif

static void ptxProcessScratchRegsPragma(ptxParsingState gblState, String pragma, msgSourcePos_t sourcePos, Bool isRReg)
{
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_63)

    stdList_t scratchRegs = ptxGetPragmaValueList(gblState->parseData, pragma, True, True);
    checkScratchRegsPragma(gblState, pragma, scratchRegs, sourcePos, isRReg, False);

    if (stdIS_PREFIX("call_", pragma)) {
        return;
    }

    if (isRReg) {
        gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->scratchRRegs = scratchRegs;
    } else {
        gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->scratchBRegs = scratchRegs;
    }
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownPragma, sourcePos, pragma));
#endif
}

static void ptxProcessLwstomAbi(ptxParsingState gblState,  stdList_t pragmas, msgSourcePos_t sourcePos )
{
    stdList_t l;
    stdMap_t *deobfuscatedStringMapPtr = gblState->parseData->deobfuscatedStringMapPtr;

    for (l = pragmas; l; l = l->tail) {
        String pragma = (String)l->head;

        Bool abiParamRegPragma       = stdIS_PREFIX(getLWSTOMABIPrgAsString(deobfuscatedStringMapPtr, ptxAbiParamReg_PRG),                   pragma);
        Bool callAbiParamRegPragma   = stdIS_PREFIX(getLWSTOMABIPrgAsString(deobfuscatedStringMapPtr, ptxCallAbiParamReg_PRG),               pragma);
        Bool retAddrBeforeParams     = stdIS_PREFIX(getLWSTOMABIPrgAsString(deobfuscatedStringMapPtr, ptxRetAddrRegBeforeParamReg_PRG),      pragma);
        Bool callRetAddrBeforePragma = stdIS_PREFIX(getLWSTOMABIPrgAsString(deobfuscatedStringMapPtr, ptxCallRetAddrRegBeforeParamReg_PRG),  pragma);
        Bool retAddrRegRel           = stdIS_PREFIX(getLWSTOMABIPrgAsString(deobfuscatedStringMapPtr, ptxRetAddrRegRRel32_PRG),              pragma);
        Bool callRetAddrRegRel       = stdIS_PREFIX(getLWSTOMABIPrgAsString(deobfuscatedStringMapPtr, ptxCallRetAddrRegRRel32_PRG),          pragma);
        Bool retAddrReg              = stdIS_PREFIX(getLWSTOMABIPrgAsString(deobfuscatedStringMapPtr, ptxRetAddrReg_PRG),                    pragma)
                                       && !retAddrBeforeParams
                                       && !retAddrRegRel;
        Bool callRetAddrReg          = stdIS_PREFIX(getLWSTOMABIPrgAsString(deobfuscatedStringMapPtr, ptxCallRetAddrReg_PRG),                pragma)
                                       && !callRetAddrBeforePragma
                                       && !callRetAddrRegRel;
        Bool scratchRRegPragma       = stdIS_PREFIX(getLWSTOMABIPrgAsString(deobfuscatedStringMapPtr, ptxScratchRegsR_PRG),                  pragma);
        Bool callScratchRRegPragma   = stdIS_PREFIX(getLWSTOMABIPrgAsString(deobfuscatedStringMapPtr, ptxCallScratchRegsR_PRG),              pragma);
        Bool scratchBRegPragma       = stdIS_PREFIX(getLWSTOMABIPrgAsString(deobfuscatedStringMapPtr, ptxScratchRegsB_PRG),                  pragma);
        Bool callScratchBRegPragma   = stdIS_PREFIX(getLWSTOMABIPrgAsString(deobfuscatedStringMapPtr, ptxCallScratchRegsB_PRG),              pragma);

        if (abiParamRegPragma || callAbiParamRegPragma) {
            ptxProcessAbiParamRegPragma(gblState, pragma, sourcePos);
        } else if (retAddrBeforeParams || callRetAddrBeforePragma) {
            ptxProcessRetAddrBeforeParamsPragma(gblState, pragma, sourcePos);
        } else if (retAddrRegRel || callRetAddrRegRel) {
            ptxProcessRelativeRetAddrRegPragma(gblState, pragma, sourcePos);
        } else if (retAddrReg || callRetAddrReg) {
            ptxProcessRetAddrRegPragma(gblState, pragma, sourcePos);
        } else if (scratchRRegPragma || scratchBRegPragma ||
                   callScratchBRegPragma || callScratchRRegPragma)
        {
            ptxProcessScratchRegsPragma(gblState, pragma, sourcePos,
                                        scratchRRegPragma || callScratchRRegPragma);
        }
        // ignore any other pragmas
    }
}

static void ptxCheckJetfirePragma(ptxParsingState gblState,  stdList_t pragmas, msgSourcePos_t sourcePos )
{
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_65)
#define isJetFirePragma(PrgName) stdIS_PREFIX(getJETFIREPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptx##PrgName##_PRG), pragma);
    stdList_t l;
    for (l = pragmas; l; l = l->tail) {
        String pragma = (String)l->head;
        Bool lwoptPragma       = isJetFirePragma(Lwopt)
        Bool nextKnobPragma    = isJetFirePragma(NextKnob)            
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
        Bool globalknobPragma  = isJetFirePragma(GlobalKnob)
        Bool setKnobPragma     = isJetFirePragma(SetKnob)
        Bool resetKnobPragma   = isJetFirePragma(ResetKnob)
        if (globalknobPragma || setKnobPragma || resetKnobPragma) {
            checkFeatureVersion(gblState, 7, 1, pragma, sourcePos);
            ptxSanitizeJetfirePragmaValue(pragma, sourcePos, gblState->parseData);
        }
#endif
        if (lwoptPragma || nextKnobPragma) {
            checkFeatureVersion(gblState, 6, 5, pragma, sourcePos);
            ptxSanitizeJetfirePragmaValue(pragma, sourcePos, gblState->parseData);
        }
    }
#undef isJetFirePragma
#endif
}

static void ptxCheckSyncPragma(ptxParsingState gblState,  stdList_t pragmas, msgSourcePos_t sourcePos)
{
#if LWCFG(GLOBAL_FEATURE_COMPUTE_COMPILER_INTERNAL)

    stdList_t l;
    for(l = pragmas; l; l = l->tail) {
        String pragma = (String)l->head;
        if (stdIS_PREFIX(getSYNCPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxConfirm_PRG), pragma) ||
            stdIS_PREFIX(getSYNCPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxPredict_PRG), pragma))
        {
            // sync pragma - predict and confirm require a minimum arch of sm_70
            checkFeatureTarget(gblState, 70, "Pragmas meant for user directed sync", sourcePos);
            ptxSanitizeSyncPragma(pragma, sourcePos);
        }
    }

#endif // COMPUTE_COMPILER_INTERNAL
}

static void ptxCheckCoroutineVersionTarget(ptxParsingState gblState, String pragma, msgSourcePos_t sourcePos,
                                           Bool isModuleScopePragma)
{
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
    checkFeatureVersion(gblState, 7, 0, pragma, sourcePos);
    checkFeatureTarget(gblState, 50,   pragma, sourcePos);
#else
    stdCHECK_WITH_POS(False, (ptxMsgUnknownPragma, sourcePos, pragma));
#endif
}

static void ptxCheckCoroutinePragmas(ptxParsingState gblState, stdList_t pragmas, msgSourcePos_t sourcePos)
{
    stdList_t l;
    for (l = pragmas; l; l = l->tail) {
        String pragma = (String)l->head;
        if (stdIS_PREFIX(getCOROUTINEPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxCoroutine_PRG), pragma) ||
            stdIS_PREFIX(getCOROUTINEPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxCallCoroutine_PRG), pragma))
        {
            ptxCheckCoroutineVersionTarget(gblState, pragma, sourcePos, False);
        }

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_INTERNAL)
        if (stdIS_PREFIX(getCOROUTINEPrgAsString(gblState->parseData->deobfuscatedStringMapPtr, ptxCoroutine_PRG), pragma)) {
            gblState->parseData->lwrFunc->aux->funcProtoAttrInfo->isCoroutine = True;
#if LWCFG(GLOBAL_ARCH_HOPPER) && LWCFG(GLOBAL_FEATURE_COMPUTE_COMPILER_INTERNAL)
            ptxSetNonMercFeatureUsed(gblState, ptxCoroutine);
#endif
        }
#endif
    }
}

static void addPragmaStatement(ptxParsingState gblState,  stdList_t pragmas, msgSourcePos_t sourcePos )
{
    checkFeatureVersion(gblState, 2, 0, ".pragma directive", sourcePos);
    ptxAddStatement(gblState->lwrSymbolTable, ptxCreatePragmaStatement(pragmas));

    ptxProcessLwstomAbi(gblState, pragmas, sourcePos);
    ptxProcessLocalMaxNRegPragma(gblState, pragmas, sourcePos);
    ptxCheckJetfirePragma(gblState, pragmas, sourcePos);
    ptxCheckSyncPragma(gblState, pragmas, sourcePos);
    ptxCheckCoroutinePragmas(gblState, pragmas, sourcePos);
}

static void checkGenericOperator( String ident, msgSourcePos_t sourcePos )
{
    stdCHECK_WITH_POS( strcmp(ident, "generic") == 0, (ptxMsgParsingError,sourcePos,ident,"syntax error") );
}

static void checkMaskOperator(ptxParsingState gblState,  uInt64 mask, msgSourcePos_t sourcePos )
{
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_71)
    uInt i;
    const uInt64 allowedMasks[] = {0xff, 0xff00, 0xff0000, 0xff000000,
                                   0xff00000000, 0xff0000000000, 0xff000000000000,
                                   0xff00000000000000};
    const uInt numMasks = sizeof(allowedMasks) / sizeof(allowedMasks[0]);

    checkFeatureVersion(gblState, 7, 1, "mask operator in initializer", sourcePos);
    for (i = 0; i < numMasks; ++i) {
        if (mask == allowedMasks[i])  {
            break;
        }
    }

    stdCHECK_WITH_POS(i < numMasks, (ptxMsgInitValIlwalidMask, sourcePos, mask));
#else
    stdCHECK_WITH_POS(False, (ptxMsgParsingError, sourcePos, "(", "syntax error"));
#endif
}

static ptxInitializer createExpressionInitializer( Bool isGeneric, ptxExpression expr, uInt64 mask, msgSourcePos_t sourcePos )
{
    ptxInitializer result;
    stdNEW(result);

    result->kind                       = ptxExpressionInitializer;
    result->sourcePos                  = sourcePos;
    result->cases.Expression.expr      = expr;
    result->cases.Expression.mask      = mask;
    result->cases.Expression.isGeneric = isGeneric;

    return result;
}

static ptxInitializer createNamedFieldInitializer( String name, ptxExpression expr, msgSourcePos_t sourcePos )
{
    ptxInitializer result;

    stdNEW(result);

    result->kind                  = ptxNamedFieldInitializer;
    result->sourcePos             = sourcePos;
    result->cases.NamedField.name = name;
    result->cases.NamedField.expr = expr;

    return result;
}

static ptxInitializer createStructuredInitializer( stdList_t list, msgSourcePos_t sourcePos )
{
    ptxInitializer result;

    stdNEW(result);

    result->kind                  = ptxStructuredInitializer;
    result->sourcePos             = sourcePos;
    result->cases.Structured.list = list;

    return result;
}


static ptxVariableInfo createVariableInfo( ptxSymbol symbol, ptxInitializer initializer,
                                           ptxStorageClass storage, ptxPointerAttr attr,
                                           uInt logAlignment, int allocno, uInt range )
{
    ptxVariableInfo result;
    stdNEW(result);

    result->symbol           = symbol;
    result->initializer      = initializer;
    result->storage          = storage;
    result->ptr_attr         = attr;          // pointer param state space attribute
    result->ptr_logAlignment = logAlignment;  // pointer param memory alignment attribute
    result->allocno          = allocno;
    result->range            = range;

    return result;
}


static ptxVariableInfo createMultipleVariableInfo(ptxParsingState gblState, ptxType t, String name, uInt number, uInt logAlignment, ptxStorageClass storage, msgSourcePos_t sourcePos)
{
    stdString_t s = stringNEW();
    stringAddFormat(s,"%s<",name);
    return createVariableInfo(ptxCreateSymbol(gblState, t, stringStripToBuf(s), logAlignment, 0, sourcePos), NULL, storage, ptxPtrNone, 0, -1, number);
}

/// Expand label<n> into labels "labeln-1" to "label0".
//
// This creates symbols in the reverse order, since listCons adds to
// front. But the list is used by the parser in exactly one place,
// where it is reversed again before use.
static stdList_t createMultipleSymbolInitializers(ptxParsingState gblState, String name, uInt number, msgSourcePos_t sourcePos)
{
    stdList_t syms = NULL;
    stdString_t s;
    uInt i, n;

    for (i = 0; i != number; ++i) {
        ptxExpression  sym;
        ptxInitializer init;
        n = i;
        s = stringNEW();
        stringAddFormat(s, "%s%d", name, n);
        sym  = createSymbolExpr(gblState, stringStripToBuf(s), sourcePos);
        init = createExpressionInitializer(False,createAddressOfExpr(gblState, sym),~0,sourcePos);
        syms = listCons(init, syms);
    }

    return syms;
}

static Bool isLabelOrReference(ptxInitializer I)
{
    ptxExpression L;

    if (I->kind != ptxExpressionInitializer)
        return False;

    L = I->cases.Expression.expr;
    if (L->kind == ptxLabelReferenceExpression) {
        return True;
    }
    if (L->kind != ptxSymbolExpression) return False;
    return L->cases.Symbol.symbol->kind == ptxLabelSymbol;
}

static void checkLabel(ptxInitializer E, msgSourcePos_t sourcePos)
{
    stdCHECK_WITH_POS(isLabelOrReference(E),
                      (ptxMsgIllegalBranchtarget, sourcePos));
}

static void defineBranchtargetsList(ptxParsingState gblState,  ptxSymbolTableEntry label, stdList_t targets, msgSourcePos_t sourcePos )
{
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_60)
    checkFeatureVersion(gblState, 6, 0, ".branchtargets directive", sourcePos);
    stdCHECK_WITH_POS(checkTargetArch(gblState, 30), (ptxMsgFeatureRequiresSMVersion,sourcePos,".branchtargets directive","sm_30") );
# else
    stdCHECK_WITH_POS( False, (ptxMsgUnimplementedFeature,sourcePos,".branchtargets directive") );
# endif

    listTraverse(targets, (stdEltFun)checkLabel, (Pointer)sourcePos);
    label->initialValue = createStructuredInitializer(targets, sourcePos);
    label->kind = ptxBranchTargetSymbol;
}


  static void checkCalltarget( ptxInitializer i )
  {
      stdCHECK_WITH_POS( i->kind == ptxExpressionInitializer, (ptxMsgIllegalCalltarget,i->sourcePos) ) {
          ptxExpression l = i->cases.Expression.expr;

          stdCHECK_WITH_POS( (l->kind == ptxSymbolExpression && l->cases.Symbol.symbol->kind == ptxFunctionSymbol),
                             (ptxMsgIllegalCalltarget,i->sourcePos) );
      }
  }

static void defineCalltargetsList(ptxParsingState gblState,  ptxSymbolTableEntry label, stdList_t targets, msgSourcePos_t sourcePos )
{
    checkFeatureVersion(gblState, 2, 1, ".calltargets directive", sourcePos);
    stdCHECK_WITH_POS( checkTargetArch(gblState, 20), (ptxMsgFeatureRequiresSMVersion,sourcePos,".calltargets directive","sm_20") );

    // check that list contains functions
    listTraverse( targets, (stdEltFun)checkCalltarget, NULL );

    label->initialValue = createStructuredInitializer(targets, sourcePos);
    label->kind = ptxCallTargetSymbol;
    label->aux->funcProtoAttrInfo->numAbiParamRegs = UNSPECIFIED_ABI_PARAM_REGS;
    label->aux->funcProtoAttrInfo->firstParamReg = UNSPECIFIED_ABI_REG;
    label->aux->funcProtoAttrInfo->retAddrBeforeParams = UNSPECIFIED_RET_ADDR_BEFORE_PARAMS;
    label->aux->funcProtoAttrInfo->retAddrUReg = UNSPECIFIED_ABI_REG;
    label->aux->funcProtoAttrInfo->retAddrReg = UNSPECIFIED_ABI_REG;
    label->aux->funcProtoAttrInfo->relRetAddrReg = UNSPECIFIED_ABI_REG;
    label->aux->funcProtoAttrInfo->scratchRRegs = UNSPECIFIED_ABI_REGS;
    label->aux->funcProtoAttrInfo->scratchBRegs = UNSPECIFIED_ABI_REGS;
    label->aux->funcProtoAttrInfo->isCoroutine  = False;
}


static void defineCallPrototype(ptxParsingState gblState, ptxSymbolTableEntry label, stdList_t rparams,
                                stdList_t fparams, stdList_t scratchRegs,
                                int retAddrAllocno, Bool hasNoReturn,
                                msgSourcePos_t sourcePos)
{
    deviceFuncArgInfo *pinfo;
    checkFeatureVersion(gblState, 2, 1, ".callprototype directive", sourcePos);
    stdCHECK_WITH_POS( checkTargetArch(gblState, 20), (ptxMsgFeatureRequiresSMVersion,sourcePos,".callprototype directive","sm_20") );

    pinfo = getDeviceFuncArgInfo(gblState, NULL, fparams, rparams, False, sourcePos);
    label->aux->funcProtoAttrInfo->hasAllocatedParams = pinfo->isAnyUsingAllocNo && pinfo->areAllUsingAllocNo;
    label->aux->funcProtoAttrInfo->scratchRegs = scratchRegs;
    label->aux->funcProtoAttrInfo->retAddrAllocno = retAddrAllocno;
    label->aux->funcProtoAttrInfo->numAbiParamRegs = UNSPECIFIED_ABI_PARAM_REGS;
    label->aux->funcProtoAttrInfo->firstParamReg = UNSPECIFIED_ABI_REG;
    label->aux->funcProtoAttrInfo->retAddrBeforeParams = UNSPECIFIED_RET_ADDR_BEFORE_PARAMS;
    label->aux->funcProtoAttrInfo->retAddrUReg = UNSPECIFIED_ABI_REG;
    label->aux->funcProtoAttrInfo->retAddrReg = UNSPECIFIED_ABI_REG;
    label->aux->funcProtoAttrInfo->relRetAddrReg = UNSPECIFIED_ABI_REG;
    label->aux->funcProtoAttrInfo->scratchRRegs = UNSPECIFIED_ABI_REGS;
    label->aux->funcProtoAttrInfo->scratchBRegs = UNSPECIFIED_ABI_REGS;
    label->aux->funcProtoAttrInfo->isCoroutine  = False;
    label->aux->funcProtoAttrInfo->hasNoReturn = hasNoReturn;
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_64)
        stdCHECK_WITH_POS(stdIMPLIES(hasNoReturn, rparams == NULL),
                          (ptxMsgIlwalidDirective, sourcePos, ".noreturn",
                           "protoype with return parameters"));
#endif

    stdFREE(pinfo);

    stdASSERT( label!=NULL && label->aux!=NULL && label->aux->funcProtoAttrInfo->rparams==NULL && label->aux->funcProtoAttrInfo->fparams==NULL, ("Corrupt label") );
    label->aux->funcProtoAttrInfo->rparams    = rparams;
    label->aux->funcProtoAttrInfo->fparams    = fparams;
    label->kind = ptxCallPrototypeSymbol;
}


static void defineIndexedFile(ptxParsingState gblState,  uInt fileIndex, String name, ptxExpression timestampExpr, ptxExpression filesizeExpr, msgSourcePos_t sourcePos )
{
    DebugIndexedFile *file, *previous;
    uInt64 timestamp, filesize;

    if (timestampExpr || filesizeExpr)
        checkFeatureVersion(gblState, 3, 2, "timestamp and filesize in .file directive", sourcePos);

    timestamp = filesize = 0;
    if (timestampExpr) {
        constCheckInt(timestampExpr, sourcePos);
        timestamp = timestampExpr->cases.IntConstant.i;
    }
    if (filesizeExpr) {
        constCheckInt(filesizeExpr, sourcePos);
        filesize  = filesizeExpr->cases.IntConstant.i;
    }

    stdNEW(file);
    file->index     = fileIndex;
    file->name      = name;
    file->timestamp = timestamp;
    file->size      = filesize;

    previous= mapDefine( gblState->dwarfFiles, (Pointer)(Address)fileIndex, file );
    stdCHECK_WITH_POS(!previous, (ptxMsgDuplicateFileIndex,sourcePos,fileIndex) );
}

static void defineCodeLocation(ptxParsingState gblState,  uInt fileIndex, uInt lineNo, uInt linePos, String funcName,
                                uInt offset, uInt inlineFileIndex, uInt inlineLineNo,
                                uInt inlineLinePos, msgSourcePos_t sourcePos )
{
    Pointer locMapKey;
    ptxCodeLocation  inlineAtLoc;
    if (ptxVersionAtLeast(4, 0, gblState) && !gblState->ptxDebugInfo) {
        // PTX ISA 4.0 or higher with .loc implies lineinfo generation.
        gblState->ptxDebugInfo = True;
        gblState->enableLineInfoGeneration = True;
    }
    if (gblState->ptxDebugInfo) {
        insertPtxToSourceMapRecord(gblState); //insert record of ptxsource line from previous .LOC to this .LOC in map
        gblState->parseData->lwrSourceCodeLocation->lwrLoc.fileIndex = fileIndex;
        gblState->parseData->lwrSourceCodeLocation->lwrLoc.lineNo    = lineNo;
        gblState->parseData->lwrSourceCodeLocation->lwrLoc.linePos   = linePos;
        gblState->parseData->lwrSourceCodeLocation->functionName     = NULL;
        gblState->parseData->lwrSourceCodeLocation->inlineAtLoc      = NULL;
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
        if (funcName != NULL) {
            checkFeatureVersion(gblState, 7, 0, "Line information of inline functions", sourcePos);
            if (offset != -1) {
                stdString_t funcNamePlusOffset = stringNEW();
// OPTIX_HAND_EDIT: Fix printf place holder from %llu to %u because offset is uInt
                stringAddFormat(funcNamePlusOffset, "%s+%u", funcName,
                                offset);
                funcName = stringStripToBuf(funcNamePlusOffset);
            }
            gblState->parseData->lwrSourceCodeLocation->functionName = funcName;
            locMapKey = ptxCreateKeyFromLoc(inlineFileIndex, inlineLineNo, inlineLinePos);
            inlineAtLoc =  mapApply(gblState->ptxToSourceLine.inlinedLocMap, locMapKey);
            stdCHECK_WITH_POS(inlineAtLoc, (ptxMsgNoInlineLoc, sourcePos,
                                            inlineFileIndex, inlineLineNo, inlineLinePos));
            // Add current .loc to the linked list of "inlined_At" .loc
            gblState->parseData->lwrSourceCodeLocation->inlineAtLoc = inlineAtLoc;
            stdFREE(locMapKey);
        }
#else
        stdCHECK_WITH_POS(funcName == NULL,
                          (ptxMsgParsingError, sourcePos, funcName, "syntax error"));
#endif
        initPtxToSourceMapRecord(gblState, gblState->parseData->lwrSourceCodeLocation);


        // Prologue instructions of the current function should be mapped to
        // first .loc in the current function 
        if (!gblState->parseData->prologueSourceLocation) {
            gblState->parseData->prologueSourceLocation = stdCOPY(gblState->parseData->lwrSourceCodeLocation);
        }
        if (gblState->ptxDebugOneLineBB) {
            Char buffer[10000];

            stdCHECK_WITH_POS(
                mapApply(gblState->dwarfFiles, (Pointer)(Address)fileIndex),
                (ptxMsgUnknownFileIndex,sourcePos,fileIndex)
            );

            sprintf(buffer,".L__$locationLabel$__%d", gblState->parseData->nr++ );

            defineLabel(gblState, stdCOPYSTRING(buffer),False,sourcePos,True);
        }
    }
}
/*-----------------------Functions for ptxToSourceMap--------------------------*/
static void initPtxToSourceMapRecord(ptxParsingState gblState, ptxCodeLocation lwrSourceCodeLocation)
{
    Pointer locMapKey;
    gblState->parseData->firstInstrSourcePos = -1; //-1 signifies no valid line no is present 
    gblState->parseData->lastInstrSourcePos  = -1;

    stdNEW(gblState->parseData->prvSourceCodeLocation);

    gblState->parseData->prvSourceCodeLocation->lwrLoc.fileIndex = gblState->parseData->lwrSourceCodeLocation->lwrLoc.fileIndex;
    gblState->parseData->prvSourceCodeLocation->lwrLoc.lineNo    = gblState->parseData->lwrSourceCodeLocation->lwrLoc.lineNo;
    gblState->parseData->prvSourceCodeLocation->lwrLoc.linePos   = gblState->parseData->lwrSourceCodeLocation->lwrLoc.linePos;
    gblState->parseData->prvSourceCodeLocation->functionName     = gblState->parseData->lwrSourceCodeLocation->functionName;
    gblState->parseData->prvSourceCodeLocation->inlineAtLoc      = gblState->parseData->lwrSourceCodeLocation->inlineAtLoc;
    locMapKey =  ptxCreateKeyFromLoc(gblState->parseData->lwrSourceCodeLocation->lwrLoc.fileIndex,
                                     gblState->parseData->lwrSourceCodeLocation->lwrLoc.lineNo,
                                     gblState->parseData->lwrSourceCodeLocation->lwrLoc.linePos),
    mapDefine(gblState->ptxToSourceLine.inlinedLocMap, locMapKey, gblState->parseData->prvSourceCodeLocation);
}

static void  insertPtxToSourceMapRecord(ptxParsingState gblState)
{
    rangemapDomain_t newRecord;
    if (gblState->ptxDebugInfo) {
        if (gblState->parseData->firstInstrSourcePos != -1 && gblState->parseData->lastInstrSourcePos != -1) {
            stdASSERT(gblState->parseData->prvSourceCodeLocation,
                     ("Valid gblState->parseData->prvSourceCodeLocation should be present"));
            newRecord.start = gblState->parseData->firstInstrSourcePos;
            newRecord.length = (gblState->parseData->lastInstrSourcePos - gblState->parseData->firstInstrSourcePos) + 1;
            rangemapDefine(gblState->ptxToSourceLine.instructionMap, newRecord, gblState->parseData->prvSourceCodeLocation);
            gblState->parseData->firstInstrSourcePos = -1; //-1 signifies no valid line no is present 
            gblState->parseData->lastInstrSourcePos  = -1;
        }
    }
}

static void setSourceLocForPrologue(ptxParsingState gblState, msgSourcePos_t startPos, msgSourcePos_t endPos,  ptxCodeLocation prologueLoc) {

    rangemapDomain_t newRecord;
    if (gblState->ptxDebugInfo && prologueLoc) {
        newRecord.start  = startPos->lineNo;
        newRecord.length = (endPos->lineNo - newRecord.start) + 1;
        rangemapDefine(gblState->ptxToSourceLine.functionPtxLineRangeMap,
                       newRecord, prologueLoc);
    }
}

#define dwarfVectorSize 32
static void defineDwarfSection(ptxParsingState gblState,  String name, msgSourcePos_t sourcePos, Bool IsLegacyDwarfSyntax )
{
    // NOTE: We cannot use checkFeatureVersion here, because of its
    // interaction with the "allow-all-ptx-features" command-line flag.
    if (ptxVersionAtLeast(2,0, gblState)) {
        stdCHECK_WITH_POS( !IsLegacyDwarfSyntax, (ptxMsgDeprecatedFeature,sourcePos,"@@DWARF directive","2.0") );
    } else {
        stdCHECK_WITH_POS( IsLegacyDwarfSyntax, (ptxMsgFeatureRequiresPTXVersion,sourcePos,".section directive","2.0") );
    }

    gblState->foundDebugInfo = True;

    stdNEW(gblState->parseData->lwrPtxDwarfSection);
    gblState->parseData->lwrPtxDwarfSection->name = stdCOPYSTRING(name);
    gblState->parseData->lwrPtxDwarfSection->sectionType = dwarfSectionNameToType(name);
    stdXArrayInit(gblState->parseData->lwrPtxDwarfSection->dwarfLines.dwarfLineBytes);
    gblState->parseData->lwrPtxDwarfSection->dwarfLines.dwarfLineBytesTop = 0;
    gblState->parseData->lwrPtxDwarfSection->size = 0;
    gblState->parseData->lwrPtxDwarfSection->totalBytesFilled = 0;
    gblState->parseData->lwrPtxDwarfSection->labelVector      = vectorCreate(dwarfVectorSize);
    stdXArrayInit(gblState->parseData->lwrPtxDwarfSection->dwarfLines.longConstantArr);
    gblState->parseData->lwrPtxDwarfSection->dwarfLines.longConstantArrTop = 0;
    listXPutAfter( gblState->dwarfSections, gblState->parseData->lwrPtxDwarfSection );
}

typedef struct {
    int            len;
    msgSourcePos_t sourcePos;
} DwarfBytesRec;

/*
* Function         :- Insert dwarf data into the array of dwarf records along
*                     with the encoded value of size and presence of label
* Parameters       :- metadata  : indicating presence of label
*                     dwarfData : dwarf records to insert
*                     len       : length of dwarf records in bytes
* Function result  :- It does not return anything.
*/

static void insertPackedDwarfRecord(ptxParsingState gblState,  short metadata, uInt64 dwarfData, short len)
{
    /*
    Dwarf recorords are stored in the form of metadata + dwarfdata.Metadata
    indicates information about size of data and information about presence of label
    Subsequent bytes after metadata constitutes dwarfdata.
    Records of form Metadata + Dwarf data are stored in 8 byte long array element.
    Example :   .b8 12
                .b32 1234
     ____________________________________________________________________________________________
    |            |                                           |        |                 |       |
    |    not     |                4 bytes of                 |   4    | 1 byte of Dwarf |   1   |
    |    used    |              Dwarf Data(1234)             |        |      Data(12)   |       |
    |____________|___________________________________________|________|_________________|_______|
    64           56                                          24        16               8       0

    If dwarf label is present then DWARF_LABEL_INDICATOR will be added in
    metadata and dwarfdata will indicate index of dwarf label string in labelVector.
    If the data is of 8 bytes constant dwafdata will indicate index
    of dwarfConstantArr at which actual constant is stored
    */

    Int arrayElementSize = sizeof(uInt64);
    Int bytesVacant = arrayElementSize - (gblState->parseData->lwrPtxDwarfSection->totalBytesFilled % arrayElementSize);

    // Append metadata at the end of dwarfdata
    dwarfData = (dwarfData << 8) + metadata;
    if (bytesVacant < len + 1 || bytesVacant == 8) {
        /*
         * Insert data into new element of dwarfLines array as Array element is full
         * or no continuous space is available in the top of array to store dwarfdata
         */
        stdXArrayAssign(gblState->parseData->lwrPtxDwarfSection->dwarfLines.dwarfLineBytes,
                        gblState->parseData->lwrPtxDwarfSection->dwarfLines.dwarfLineBytesTop, dwarfData);
        gblState->parseData->lwrPtxDwarfSection->dwarfLines.dwarfLineBytesTop++;
        if (bytesVacant != 8) {
            gblState->parseData->lwrPtxDwarfSection->totalBytesFilled += arrayElementSize - (gblState->parseData->lwrPtxDwarfSection->totalBytesFilled % arrayElementSize);
        }
    } else {
        // Add dwarfdata to the top of dwarfLineBytes array as
        // there is space available in the top element.
        dwarfData = dwarfData << (8 - bytesVacant) * 8;
        gblState->parseData->lwrPtxDwarfSection->dwarfLines.dwarfLineBytes[gblState->parseData->lwrPtxDwarfSection->dwarfLines.dwarfLineBytesTop - 1] += dwarfData;
    }
    gblState->parseData->lwrPtxDwarfSection->totalBytesFilled += len + 1;
}

static void defineDwarfBytes1(ptxParsingState gblState, uInt64 i, DwarfBytesRec *rec )
{
    short len = rec->len;
    short metadata = len;
    short dwarfDataSize = 0;
    uInt64 dwarfData = 0;
    short bits = len*8;

    // 8 byte values can't have values out of range since 'i' is of same size
    stdCHECK_WITH_POS(len==8 || (i>=0 && i<(1LL<<bits)), (ptxMsgDwarfValueOutOfRange, rec->sourcePos, bits, i));
    switch (len) {
    case 1:
        dwarfDataSize = 1;
        dwarfData = i;
        break;
    case 2:
        dwarfDataSize = 2;
        dwarfData = i;
        break;
    case 4:
        dwarfDataSize = 4;
        dwarfData = i;
        break;
    case 8:
        dwarfDataSize = sizeof(uInt32); // As we are storing index of
                                        // array in the dwarfdata;
        stdXArrayAssign(gblState->parseData->lwrPtxDwarfSection->dwarfLines.longConstantArr,
                        gblState->parseData->lwrPtxDwarfSection->dwarfLines.longConstantArrTop, i);
        dwarfData = gblState->parseData->lwrPtxDwarfSection->dwarfLines.longConstantArrTop;
        gblState->parseData->lwrPtxDwarfSection->dwarfLines.longConstantArrTop++;
        break;

    default:  stdASSERT( False, ("Case label out of bounds") );
    }

    insertPackedDwarfRecord(gblState, metadata, dwarfData, dwarfDataSize);

    gblState->parseData->lwrPtxDwarfSection->size += len;
}

static void defineDwarfBytes(ptxParsingState gblState, ptxType type, uInt64  intAddr, msgSourcePos_t sourcePos)
{
    DwarfBytesRec rec;

    rec.sourcePos = sourcePos;

    if (isB8(type)) {
        rec.len = 1;
    } else if (isB16(type)) {
        rec.len = 2;
    } else if (isB32(type)) {
        rec.len = 4;
    } else if (isB64(type)) {
        rec.len = 8;
    } else {
        stdCHECK_WITH_POS(False, (ptxMsgIllegalType, sourcePos, "dwarf data"));
        rec.len = 0;
    }
    defineDwarfBytes1(gblState, intAddr, &rec);
}

/* This function is used to truncate negative values in Int64 vars
 * down to unsigned values of appropriate length and then return it 
 * back as a uInt64 value.
 * For instance -1 value of 2 byte len is returned as 0x000000000000ffff
 */
 
static uInt64 truncateInt64ToUnsignedType (int bytes, Int64 value, msgSourcePos_t sourcePos)
{
    uInt64 i = 0;
    short bits = bytes*8;

    // 8 byte values can't have values out of range since 'value' is of same size
    stdCHECK_WITH_POS(bytes == 8 || (value<0 && value>=-(1LL<<(bits-1))), 
                      (ptxMsgDwarfValueOutOfRange, sourcePos, bits, value));
    switch(bytes) {
    case 1:
        i = (uInt8) value;
        break;
    case 2:
        i = (uInt16) value;
        break;
    case 4:
        i = (uInt32) value;
        break;
    case 8:
        i = (uInt64) value;
        break;
    default:
        stdCHECK_WITH_POS(False, (ptxMsgIllegalType, sourcePos, "dwarf data"));
        break;
    }
    return i;
}

static void defineDwarfNegativeByte(ptxParsingState gblState, ptxType type, ptxExpression intAddr, msgSourcePos_t sourcePos)
{
    Int64 intAddrNeg;
    uInt64 dwarfData;

    stdASSERT(intAddr->kind == ptxIntConstantExpression, ("Integer constant expression expected"));
    intAddrNeg = intAddr->cases.IntConstant.i;
    dwarfData = truncateInt64ToUnsignedType (ptxGetTypeSizeInBytes(type), intAddrNeg, sourcePos);
    defineDwarfBytes(gblState, type, dwarfData, sourcePos);
}

static void defineDwarfByteList(ptxParsingState gblState, ptxType type, stdList_t dwarfDataList, msgSourcePos_t sourcePos)
{
    DwarfBytesRec rec;

    rec.sourcePos = sourcePos;

    if (isB8(type)) {
        rec.len = 1;
    } else if (isB16(type)) {
        rec.len = 2;
    } else if (isB32(type)) {
        rec.len = 4;
    } else if (isB64(type)) {
        rec.len = 8;
    } else {
        stdCHECK_WITH_POS(False, (ptxMsgIllegalType, sourcePos, "dwarf data"));
        rec.len = 0;
    }

    while (dwarfDataList) {
        Int64 intAddr;
        uInt64 i;

        stdASSERT(((ptxExpression)dwarfDataList->head)->kind == ptxIntConstantExpression,
                  ("Integer constant expression expected"));
        intAddr = ((ptxExpression)dwarfDataList->head)->cases.IntConstant.i;
        i = intAddr < 0 ? truncateInt64ToUnsignedType(rec.len, intAddr, sourcePos) : intAddr;
        defineDwarfBytes1(gblState, i, &rec);
        dwarfDataList = dwarfDataList->tail;
    }
}

static void defineDwarfLabel(ptxParsingState gblState,  ptxType type, String label, msgSourcePos_t sourcePos )
{
    short len = 0 ;
    uInt32 labelVectorIndex = 0;
    String dwarfLabel;
    if (isB32(type)) {
        len = 4;
    } else if (isB64(type)) {
        len = 8;
    } else {
        stdCHECK_WITH_POS(False, (ptxMsgIllegalType, sourcePos, "dwarf data"));
    }

    dwarfLabel = stdCOPYSTRING(label);
    vectorPush(gblState->parseData->lwrPtxDwarfSection->labelVector, dwarfLabel);
    labelVectorIndex = vectorSize(gblState->parseData->lwrPtxDwarfSection->labelVector) - 1;

    insertPackedDwarfRecord(gblState, DWARF_LABEL_INDICATOR + len,
                            labelVectorIndex, sizeof(uInt32));
    gblState->parseData->lwrPtxDwarfSection->size += len;
}

static void defineInternalDwarfLabel(ptxParsingState gblState, String label, msgSourcePos_t sourcePos) {

#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_70)
    stdString_t sectionPlusOffset = stringNEW();
    String previous;

    checkFeatureVersion(gblState, 7, 0, "Defining labels in .section", sourcePos);

// OPTIX_HAND_EDIT: Fix printf place holder from %llu to %u because section size is uInt
    stringAddFormat(sectionPlusOffset, "%s+%u", gblState->parseData->lwrPtxDwarfSection->name,
                    gblState->parseData->lwrPtxDwarfSection->size);
    // Associate DWARF label with its "<section_name> + offset" form
    previous = mapDefine(gblState->internalDwarfLabel, label,
                         stringStripToBuf(sectionPlusOffset));

    // Report error if label is already present in the map
    stdCHECK_WITH_POS(!previous, (ptxMsgDuplicateLabel, sourcePos, label));
#else
    stdCHECK_WITH_POS(False, (ptxMsgParsingError, sourcePos, label, "syntax error"));
#endif
}

static void defineDwarfLabelPlusOffset(ptxParsingState gblState,  ptxType type, String label, uInt64 offsetVal, msgSourcePos_t sourcePos )
{
    stdString_t labelPlusOffset = stringNEW();
    short len = 0;
    uInt32 labelVectorIndex = 0;
    String dwarfLabel;

    checkFeatureVersion(gblState, 3, 2, "labels + imm expression in .section", sourcePos);

    stringAddFormat(labelPlusOffset, "%s+%llu", label, offsetVal);

    if (isB32(type)) {
        len = 4;
        stdCHECK_WITH_POS((offsetVal>=0 && offsetVal<(1LL<<32)),
                          (ptxMsgDwarfValueOutOfRange, sourcePos, 32, offsetVal));
    } else if (isB64(type)) {
        len = 8;
    } else {
        stdCHECK_WITH_POS(False, (ptxMsgIllegalType, sourcePos, "dwarf data"));
    }

    dwarfLabel = stringStripToBuf(labelPlusOffset);
    vectorPush(gblState->parseData->lwrPtxDwarfSection->labelVector, dwarfLabel);
    labelVectorIndex = vectorSize(gblState->parseData->lwrPtxDwarfSection->labelVector) - 1;

    insertPackedDwarfRecord(gblState, DWARF_LABEL_INDICATOR + len,
                            labelVectorIndex, sizeof(uInt32));
    gblState->parseData->lwrPtxDwarfSection->size += len;
}

static void defineDwarfLabelMinusLabel(ptxParsingState gblState,  ptxType type, String label1, String label2, msgSourcePos_t sourcePos )
{
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_75)
    stdString_t labelMinusLabel = stringNEW();
    short len = 0;
    uInt32 labelVectorIndex = 0;
    String dwarfLabel;

    checkFeatureVersion(gblState, 7, 5, "labels1 - labels2 expression in .section", sourcePos);

    stringAddFormat(labelMinusLabel, "%s-%s", label1, label2);

    if (isB32(type)) {
        len = 4;
    } else if (isB64(type)) {
        len = 8;
    } else {
        stdCHECK_WITH_POS(False, (ptxMsgIllegalType, sourcePos, "dwarf data"));
    }

    dwarfLabel = stringStripToBuf(labelMinusLabel);
    vectorPush(gblState->parseData->lwrPtxDwarfSection->labelVector, dwarfLabel);
    labelVectorIndex = vectorSize(gblState->parseData->lwrPtxDwarfSection->labelVector) - 1;

    insertPackedDwarfRecord(gblState, DWARF_LABEL_INDICATOR + len,
                            labelVectorIndex, sizeof(uInt32));
    gblState->parseData->lwrPtxDwarfSection->size += len;
#else
    stdCHECK_WITH_POS( False, (ptxMsgParsingError,sourcePos,"-","syntax error") );
#endif
}
 
/*
 * Function         : Create negative integer constant expression
 * Parameters       : i          (I) Positive Integer constant 
 *                    sourcePos  (I) source location of reference
 * Function Result  : Requested negative valued expression
 */
ptxExpression defineDwarfNegIntConstantExpr( Int64 i, msgSourcePos_t sourcePos, ptxParsingState parseState)
{
#if LWCFG(GLOBAL_FEATURE_PTX_ISA_VERSION_75)
    checkFeatureVersion(parseState, 7, 5, "Negative numbers in dwarf section", sourcePos);
    return ptxCreateIntConstantExpr(-i, True, parseState);
#else
    stdCHECK_WITH_POS(False, (ptxMsgParsingError, sourcePos, "-", "syntax error"));
    return NULL;
#endif
}

static void defineMetaDataSection(ptxParsingState gblState, msgSourcePos_t sourcePos)
{
    stdNEW(gblState->metadataSection);
    gblState->metadataSection->metaDataNodeMap = mapNEW(uInt, 32);
}

static void defineMetaDataNode(ptxParsingState gblState, uInt index, String name, stdList_t metaDataValues, msgSourcePos_t sourcePos)
{
    ptxMetaDataNode metaDataNode, previous;
    stdNEW(metaDataNode);

    metaDataNode->index          = index;
    metaDataNode->nodeName       = stdCOPYSTRING(name);
    metaDataNode->metaDataValues = metaDataValues;

    previous= mapDefine( gblState->metadataSection->metaDataNodeMap, (Pointer)(Address)index, metaDataNode );
    stdCHECK_WITH_POS( !previous, (ptxMsgDuplicateMetaDataNode,sourcePos,index) );
}

static String termLabel( String entryName )
{
    stdString_t s = stringNEW();
    stringAddFormat(s, PTX_ENDLABEL_NAME(%s), entryName);
    return stringStripToBuf(s);
}

static String startLabel( String entryName )
{
    stdString_t s = stringNEW();
    stringAddFormat(s, PTX_STARTLABEL_NAME(%s), entryName);
    return stringStripToBuf(s);
}

static int getVectorSize( uInt v ) 
{
    switch (v) {
    case ptxV2_MOD : return 2;
    case ptxV4_MOD : return 4;
    default        : return 1;
    }
}

static void setMaxNReg(ptxParsingState gblState,  ptxSymbolTableEntry func, uInt a, msgSourcePos_t sourcePos )
{
    checkFeatureVersion(gblState, 1,3,".maxnreg",sourcePos);
    stdCHECK_WITH_POS( a > 0, (ptxMsgPositiveValueExpected,sourcePos,"maxnreg") );

    func->aux->maxnreg = a;
}

static void setMaxNTid(ptxParsingState gblState,  ptxSymbolTableEntry func, uInt a, uInt b, uInt c, msgSourcePos_t sourcePos )
{
    checkFeatureVersion(gblState, 1,3,".maxntid",sourcePos);
    stdCHECK_WITH_POS( a > 0 && b > 0 && c > 0, (ptxMsgPositiveValueExpected,sourcePos,"maxntid") );

    func->aux->maxntid[0] = a;
    func->aux->maxntid[1] = b;
    func->aux->maxntid[2] = c;
}

/*
 * NOTE: PTX ISA 1.x defines a .maxnctapersm directive that is used to compute the maximum number
 * of registers OCG may using in a kernel.  However, if OCG uses fewer registers the number
 * of CTAs per SM at launch may exceed .maxnctapersm.  In PTX ISA 2.0, .maxnctapersm is renamed
 * to .minnctapersm to better match the actual implementation and its use in LWCA launch_bounds.
 *
 * .maxnctapersm is deprecated in PTX 2.0 but supported for PTX 1.x.  We'll issue a warning in
 * PTX 2.0 and ignore .maxnctapersm, and issue an error in PTX 2.1.
 *
 * TODO:  Internally, we should rename variables from maxnctapersm to minctapersm.
 */

static void setMaxNCtaPerSM(ptxParsingState gblState,  ptxSymbolTableEntry func, uInt a, msgSourcePos_t sourcePos )
{
    if (ptxVersionIs(gblState, 2,0)) {
        stdCHECK_WITH_POS( False, (ptxMsgWarning,sourcePos,".maxnctapersm directive deprecated in PTX version 2.0, will be ignored.") );
        return;
    }
    stdCHECK_WITH_POS( !ptxVersionAtLeast(2,1, gblState), (ptxMsgDeprecatedFeature,sourcePos,".maxnctapersm directive","2.1") );
    stdCHECK_WITH_POS( a > 0, (ptxMsgPositiveValueExpected,sourcePos,"maxnctapersm") );
    checkFeatureVersion(gblState, 1,3,".maxnctapersm",sourcePos);

    func->aux->minnctapersm = a;
}

static void setMinNCtaPerSM(ptxParsingState gblState,  ptxSymbolTableEntry func, uInt a, msgSourcePos_t sourcePos )
{
    checkFeatureVersion(gblState, 2, 0, ".minnctapersm directive", sourcePos);
    stdCHECK_WITH_POS( a > 0, (ptxMsgPositiveValueExpected,sourcePos,"minnctapersm") );

    func->aux->minnctapersm = a;
}

static void setReqNTid(ptxParsingState gblState,  ptxSymbolTableEntry func, uInt a, uInt b, uInt c, msgSourcePos_t sourcePos )
{
    checkFeatureVersion(gblState, 2, 1, ".reqntid directive", sourcePos);
    stdCHECK_WITH_POS( a > 0 && b > 0 && c > 0, (ptxMsgPositiveValueExpected,sourcePos,"reqntid") );

    func->aux->reqntid[0] = a;
    func->aux->reqntid[1] = b;
    func->aux->reqntid[2] = c;
}

/*------------------------------ Macro Handling ------------------------------*/

static void defineMacro(ptxParsingState gblState,  String name, stdList_t formals, msgSourcePos_t sourcePos )
{
    stdSet_t       formalsSet      = listToSet(formals,(stdHashFun)stdStringHash,(stdEqualFun)stdStringEqual);
    stdSet_t       reservedOverlap = setIntersection(formalsSet,gblState->parseData->reservedMacroFormals);
    msgSourcePos_t bodySourcePos   = ptxsLwrPos(gblState);
    String         body            = ptxReadMacroBody(gblState);
    
    stdCHECK_WITH_POS( gblState->ptxAllowMacros, (ptxMsgUnimplementedFeature,sourcePos,"macro definitions") );

    stdCHECK_WITH_POS(
          ptxAddMacroSymbol( gblState->macroSymbolTable, ptxCreateSymbol(gblState, ptxCreateMacroType(gblState), name, 0, 0, sourcePos ), formals, body, bodySourcePos ),
          (ptxMsgDuplicateMacro, sourcePos, name)
    );

    stdCHECK_WITH_POS( listSize(formals) == setSize(formalsSet), (ptxMsgUniqueMacroFormals,   sourcePos, name) );
    stdCHECK_WITH_POS( setSize(reservedOverlap) == 0,            (ptxMsgReservedMacroFormals, sourcePos, setAnyElement(reservedOverlap)) );
    
    setDelete( formalsSet      );
    setDelete( reservedOverlap );
}

/*----------------------------------------------------------------------------*/

%}

%pure-parser
%lex-param {void * scanner}
%parse-param {void * scanner}
%lex-param {ptxParsingState gblState}
%parse-param {ptxParsingState gblState}

%union
{
    Float                  floatVal;  
    Double                 doubleVal;
    uInt32                 intVal;
    uInt64                 int64Val;
    String                 stringVal;
    stdList_t              listVal;
    msgSourcePos_t         sourcePos;
    ptxSymbolTableEntry    symtabEntry;
    ptxSymbolTable         symbolTable;
    ptxStorageClass        storageClass;
    ptxDeclarationScope    declScope;
    ptxExpression          exprVal;
    ptxType                typeVal;
    ptxPointerAttr         ptrVal;
    ptxComparison          cmpVal;
    ptxOperator            opVal;
    ptxInitializer         initVal;
};

%{
YY_DECL;
%}

%token  T_IDENT T_DOTIDENT T_CALL T_STRING T_INT64 T_UINT64 T_WARP_SZ
%token  T_SHL T_SHR T_EQ T_NEQ T_LTEQ T_GTEQ T_EXTERN T_VISIBLE T_WEAK T_COMMON T_TYPENAME T_ENTRY T_FORCEINLINE
%token  T_MAXNREG T_MAXNTID T_MAXNCTAPERSM T_MINNCTAPERSM T_REQNTID
%token  T_ROUNDMOD T_TESTPMOD T_COPMOD T_LVLMOD T_CLAMPMOD T_SHRMOD T_VMADMOD T_PRMTMOD T_SHFLMOD T_ENDISMOD T_RANDMOD
%token  T_FOOTPRINTMOD T_COARSEMOD
%token  T_REG T_CONST T_GLOBAL T_LOCAL T_PARAM T_SHARED T_TEX T_TEXMOD T_QUERYMOD T_DIMMOD
%token  T_FLOAT T_FLOAT64 T_ANDAND T_OROR T_POINTER T_COMPARISON T_ELLIPSIS
%token  T_BOOLEAN_OP T_ATOMIC_OP T_ARITH_OP T_UNIFORMMOD T_BRANCHMOD T_SYNCMOD T_ALIGNMOD T_THREADSMOD T_TTUSLOTMOD T_TTUMOD
%token  T_SINK T_FUNCTION T_ALIGN T_ALLOCNO T_RETADDR_ALLOCNO T_SCOPEMOD T_VECTOR T_VERSION T_TARGET T_ADDRSIZE T_SCRATCH
%token  T_DWARF T_SECTION T_FILE T_LOC T_PRAGMA T_PROGBITS T_ALIAS T_INLINED_AT T_FUNCNAME
%token  T_VOTEMOD T_APRXMOD T_RELUMOD T_FTZMOD T_NOFTZMOD T_SATMOD T_SATFMOD T_CCMOD T_SHAMTMOD T_ORDERMOD T_NCMOD T_MACRO T_NANMODEMOD T_MBARRIERMOD
%token  T_BRANCHTARGETS T_CALLTARGETS T_CALLPROTOTYPE
%token  T_ATTRIBUTE T_MANAGED T_NORETURN T_UNIQUE
%token  T_METADATA_SECTION T_METADATA T_METADATA_INDEX
%token  T_SHAPE T_LAYOUT T_CACHEPREFETCH T_PREFETCHSIZE T_EXCLUSIVE T_TRANSAMOD T_NEGAMOD T_TRANSBMOD T_NEGBMOD T_IGNORECMOD T_LEVELEVICTMOD T_PROXYKINDMOD
%token  T_NUMMOD T_TRANSMOD T_THREADGROUPMOD T_TYPEMOD T_EXPANDMOD T_SPARSITY T_SEQMOD T_GROUPMOD T_NOCOMPLETEMOD T_NOINCMOD T_ABSMOD T_CACHEHINTMOD

%type  <int64Val>      T_INT64 T_UINT64 uIntImm64
%type  <floatVal>      T_FLOAT
%type  <doubleVal>     T_FLOAT64
%type  <intVal>        uIntImm
%type  <stringVal>     T_STRING T_IDENT T_DOTIDENT T_CALL T_VERSION T_DWARF T_PROGBITS LwrTarget Selector Identifier
%type  <sourcePos>     SourcePos
%type  <typeVal>       T_TYPENAME Type VectorType
%type  <listVal>       ParameterList ParameterListItems Parameter FMPs FormalMacroParams
%type  <listVal>       OptScratchAttr ScratchAttrElemList ScratchAttrElem
%type  <listVal>       VariableDefs AObject
%type  <declScope>     EntryDeclStart FunctionDeclStart
%type  <symtabEntry>   EntryDecl FunctionDecl LabelDef
%type  <symbolTable>   PushSymbolTable PopSymbolTable StatementBlock
%type  <storageClass>  StorageClass InstStorageClass

%type  <listVal>       TargetList PragmaList LabelList  LabelListItem OptIdentDefs IdentDef RIdentDefs PObject OptInitializerList InitializerList ReverseInitializerList
%type  <listVal>       ScalarList ParamList OptParamList

%type  <exprVal>       Symbol GenSym Scalar BaseOffset OperandExpr Tuple TexAddress Primary Param

%type  <exprVal>       IntConstExpr ConstExpr IConstPrimary ConstPrimary UnaryExpr CastExpr
%type  <exprVal>       MultiplicativeExpr AdditiveExpr ShiftExpr RelationalExpr EqualityExpr
%type  <exprVal>       AndExpr ExclusiveOrExpr InclusiveOrExpr LogicalAndExpr LogicalOrExpr CondExpr

%type  <ptrVal>        KernelParamAttr KernelParamAttrSpace
%type  <intVal>        OptAlignAttr OptAllocNoAttr OptRetAddrAllocNoAttr
%type  <intVal>        OptNoReturn OptUnique
%type  <cmpVal>        T_COMPARISON
%type  <opVal>         T_BOOLEAN_OP T_ATOMIC_OP T_ARITH_OP
%type  <intVal>        T_CONST T_VECTOR T_TEXMOD T_QUERYMOD T_CLAMPMOD T_SHRMOD T_VMADMOD T_PRMTMOD T_SHFLMOD T_ENDISMOD T_ROUNDMOD T_TESTPMOD T_COPMOD T_LVLMOD T_VOTEMOD T_DIMMOD
%type  <intVal>        T_FOOTPRINTMOD T_COARSEMOD
%type  <intVal>        T_UNIFORMMOD T_SYNCMOD T_BRANCHMOD T_APRXMOD T_RELUMOD T_FTZMOD T_NOFTZMOD T_SATMOD T_SATFMOD T_NANMODEMOD T_MBARRIERMOD
%type  <intVal>        T_CCMOD T_SHAMTMOD T_ORDERMOD T_NCMOD T_SCOPEMOD T_RANDMOD T_NOCOMPLETEMOD T_NOINCMOD
%type  <intVal>        T_THREADSMOD T_ALIGNMOD T_TTUSLOTMOD T_TTUMOD T_CACHEPREFETCH T_PREFETCHSIZE
%type  <intVal>        T_NUMMOD T_TRANSMOD T_THREADGROUPMOD T_TYPEMOD T_EXPANDMOD T_SEQMOD T_GROUPMOD T_LEVELEVICTMOD T_PROXYKINDMOD
%type  <intVal>        T_SHAPE T_LAYOUT T_SPARSITY T_NORETURN T_EXCLUSIVE T_UNIQUE T_TRANSAMOD T_NEGAMOD T_TRANSBMOD T_NEGBMOD T_IGNORECMOD T_ABSMOD T_CACHEHINTMOD
%type  <initVal>       OptInitialization Initializer

%type  <intVal>        DwarfInt
%type  <exprVal>       DwarfNegInt
%type  <listVal>       RDwarfByteList
%type  <listVal>       MetaDataValue MetaDataValues

%start  Start



%%
/*----------------------------- Top Level ------------------------------*/

Start                   : { initObject(gblState); } Program { termObject(gblState); }
                        ;

Program                 : VersionAndTarget
                          OptAddrSize
                          ProgramUnits
                        ;

VersionAndTarget        : VersionDef TargetDefs SourcePos   { setTexModeDefault(gblState, $3);                                            }
                        | TargetDefs VersionDef SourcePos   { stdCHECK_WITH_POS(False, (ptxMsgVersionMissing,$3,gblState->parseData->ptxfilename) ); }
                        | VersionDef            SourcePos   { stdCHECK_WITH_POS(False, (ptxMsgTargetMissing, $2,gblState->parseData->ptxfilename) ); }
                        | TargetDefs            SourcePos   { stdCHECK_WITH_POS(False, (ptxMsgVersionMissing,$2,gblState->parseData->ptxfilename) ); }
                        | Empty                 SourcePos   { stdCHECK_WITH_POS(False, (ptxMsgVersionMissing,$2,gblState->parseData->ptxfilename) );
                                                              stdCHECK_WITH_POS(False, (ptxMsgTargetMissing, $2,gblState->parseData->ptxfilename) ); }
                        ;

OptAddrSize             : T_ADDRSIZE SourcePos uIntImm      { setAddressSize(gblState, $3,$2);                                            }
                        | Empty
                        ;

ProgramUnits            : ProgramUnits ProgramUnit SourcePos { setEmptyUserPTX(gblState, False, $3);  }
                        | Empty
                        ;

LocalProgramUnits       : LocalProgramUnits LocalProgramUnit
                        | Empty
                        ;

ProgramUnit             : DataDef
                        | EntryDef
                        | FunctionDef
                        | IndexedFile
                        | DwarfBytes
                        | DwarfSection
                        | MetadataSection
                        | MacroDef
                        | PragmaDef
                        | AliasDef
                        ;

LocalProgramUnit        : TargetDef
                        | LabelDef
                        | BrxTargetsDef
                        | CallPrototype
                        | LocalDataDef
                        | CodeLocation
                        | Statement
                        | FunctionDecl ';'
                        | AliasDef
                        ;

VersionDef              : T_VERSION SourcePos                                                      { setVersion(gblState, $1,$2);                                 }
                        ;

TargetDefs              : TargetDefs TargetDef
                        | TargetDef
                        ;

TargetDef               : T_TARGET SourcePos TargetList                                            { LIST_TRAVERSE_MULTI_ARGS($3, setTarget, &$2, gblState);        } 
                        ;

TargetList              : Identifier                                                               { $$= listCons($1,NULL);                             }
                        | Identifier ',' TargetList                                                { $$= listCons($1,$3);                               }
                        ;

AliasDef                : T_ALIAS SourcePos
                          Identifier SourcePos ','
                          Identifier SourcePos ';'                                                 { defineAlias(gblState, $3, $4, $6, $7, $2);                   }

PragmaDef               : T_PRAGMA SourcePos PragmaList ';'                                        { LIST_TRAVERSE_MULTI_ARGS( $3, setPragma, &$2, gblState);        }
                        ;

PragmaList              : T_STRING                                                                 { $$= listCons($1,NULL);                             }
                        | T_STRING ',' PragmaList                                                  { $$= listCons($1,$3);                               }
                        ;

LabelDef                : Identifier SourcePos ':'                                                 { $$= defineLabel(gblState, $1,False,$2,True);}
                        ;

BrxTargetsDef           : LabelDef SourcePos T_BRANCHTARGETS LabelList ';'              { defineBranchtargetsList(gblState, $1,listReverse($4),$2);               }
                        | LabelDef SourcePos T_CALLTARGETS   LabelList ';'              { defineCalltargetsList(gblState, $1,$4,$2);                              }
                        ;

LabelListItem           : Symbol SourcePos                                              { $$= listCons(createExpressionInitializer(False,createAddressOfExpr(gblState, $1),~0,$2),NULL);   }
                        | Identifier '<' uIntImm '>' SourcePos                          { $$= createMultipleSymbolInitializers(gblState, $1,$3,$5);               }
                        ;

CallPrototype           : LabelDef SourcePos T_CALLPROTOTYPE                            { gblState->parseData->lwrIsPrototype = True;                                        }
                          ParameterList SourcePos                                       { checkNoIncompleteParamAtOutput(gblState, $6);                           }
                          T_SINK ParameterList OptScratchAttr
                          OptRetAddrAllocNoAttr OptNoReturn ';'                         { defineCallPrototype(gblState, $1,$5,$9,$10,$11,$12,$2);  gblState->parseData->lwrIsPrototype = False;    }
                        ;

LabelList               : LabelListItem                                                 { $$= $1;                                                       }
                        | LabelList ',' LabelListItem                                   { $$= listConcat($3,$1);                                        }
                        ;

WeakDef                 : T_WEAK SourcePos                                                         { checkFeatureVersion(gblState, 3,1,".weak directive",$2);     }

CommonDef               : T_COMMON SourcePos                                                       { checkFeatureVersion(gblState, 5,0,".common directive",$2);   }

DataDef                 :           { gblState->parseData->lwrScope= ptxStaticScope;   } VariableDefs ';'               { defineVars($2, False, gblState);                             }
                        | T_EXTERN  { gblState->parseData->lwrScope= ptxExternalScope; } VariableDefs ';'               { defineVars($3, False, gblState);                             }
                        | T_VISIBLE { gblState->parseData->lwrScope= ptxGlobalScope;   } VariableDefs ';'               { defineVars($3, False, gblState);                             }
                        | WeakDef   { gblState->parseData->lwrScope= ptxWeakScope;     } VariableDefs ';'               { defineVars($3, False, gblState);                             }
                        | CommonDef { gblState->parseData->lwrScope= ptxCommonScope;   } VariableDefs ';'               { defineVars($3, False, gblState);                             }
                        ;

LocalDataDef            :           { gblState->parseData->lwrScope= ptxLocalScope;    } VariableDefs ';'               { defineVars($2, False, gblState);                             }
                        ;

Statement               : Instruction
                        | PragmaStatement
                        | StatementBlock
                        ;

PragmaStatement         : T_PRAGMA SourcePos PragmaList ';'                                        { addPragmaStatement(gblState, $3, $2);                        }
                        ;

StatementBlock          : '{'                                                                      { ptxIncrementNumScopesOnLine(gblState->parseData);  }
                          LwrTarget PushSymbolTable                                                { initializeNumStatements(gblState, $4);                          }
                          LocalProgramUnits                                                        { ptxAssignIndexToSymbols(gblState->lwrSymbolTable, gblState); }
                          PopSymbolTable '}'                                                       { gblState->parseData->target_arch =  gblState->target_arch= $3; consumeSymbolTable(gblState, $8); }
                        ;

LwrTarget               : Empty                                                                    { $$= gblState->target_arch;                      }
                        ;

EntryDeclStart          :           T_ENTRY                                                     { gblState->parseData->lwrIsEntry = True;  $$ = ptxStaticScope;                 }
                        | T_EXTERN  T_ENTRY                                                     { gblState->parseData->lwrIsEntry = True;  $$ = ptxExternalScope;               }
                        | T_VISIBLE T_ENTRY                                                     { gblState->parseData->lwrIsEntry = True;  $$ = ptxGlobalScope;                 }
                        | WeakDef   T_ENTRY                                                     { gblState->parseData->lwrIsEntry = True;  $$ = ptxWeakScope;                   }
                        ;

EntryDecl               : EntryDeclStart Identifier ParameterList SourcePos                     { checkNoIncompleteParamForEntry(gblState, $4);
                                                                                                  $$ = declFunction(gblState, $1,$2,NULL,$3,True,False,NULL,~0,False,False,$4);
                                                                                                }
                        ;

EntryDef                : EntryDecl ';'                              SourcePos                  { checkFeatureVersion(gblState, 3,0,"kernel function prototype",$3); }
                        | EntryDecl                                                             { gblState->parseData->lwrFunc = $1;                                            }
                                PushSymbolTable                                                 { gblState->parseData->lwrScope = ptxLocalScope; defineParams($1, gblState);    }
                                OptEntryDirectives
                                '{'                                  SourcePos                  { defineLabel(gblState, startLabel($1->symbol->unMangledName),True,$7,False); initializeRandomGenerationSeed(gblState, $1); }
                                LocalProgramUnits                    SourcePos                  { defineLabel(gblState, termLabel($1->symbol->unMangledName),False,$10,False);
                                                                                                  ptxAssignIndexToSymbols(gblState->lwrSymbolTable, gblState);   }
                                PopSymbolTable '}'                   SourcePos                  { termKernelFunction(gblState, $1,$12,$7,$14);                                   }
                        ;

FunctionDeclStart       :                  T_FUNCTION                                           { gblState->parseData->lwrIsEntry = False;  gblState->parseData->isInlineFunc = False; $$ = ptxStaticScope;   }
                        | T_EXTERN         T_FUNCTION                                           { gblState->parseData->lwrIsEntry = False;  gblState->parseData->isInlineFunc = False; $$ = ptxExternalScope; }
                        | T_VISIBLE        T_FUNCTION                                           { gblState->parseData->lwrIsEntry = False;  gblState->parseData->isInlineFunc = False; $$ = ptxGlobalScope;   }
                        | WeakDef          T_FUNCTION                                           { gblState->parseData->lwrIsEntry = False;  gblState->parseData->isInlineFunc = False; $$ = ptxWeakScope;     }
                        | T_FORCEINLINE    T_FUNCTION                                           { gblState->parseData->lwrIsEntry = False;  gblState->parseData->isInlineFunc = True;  $$ = ptxGlobalScope;   }
                        ;

FunctionDecl            : FunctionDeclStart                                                     {                                                                   }
                          ParameterList SourcePos                                               { checkNoIncompleteParamAtOutput(gblState, $4);                               }
                          Identifier ParameterList OptScratchAttr OptRetAddrAllocNoAttr
                          OptNoReturn OptUnique SourcePos                                                 { $$ = declFunction(gblState, $1,$6,$3,$7,False,gblState->parseData->isInlineFunc,$8,$9,$10,$11,$12);  }
                        ;

FunctionDef             : FunctionDecl                                                          { /* null action, avoids type clash */                     }
                        | FunctionDecl ';'                                                      { /* null action, avoids type clash */                     }
                        | FunctionDecl '{' SourcePos  PushSymbolTable                           { gblState->parseData->lwrFunc = $1; gblState->parseData->lwrScope = ptxLocalScope; defineParams($1, gblState); initializeRandomGenerationSeed(gblState, $1); }
                          LocalProgramUnits                                                     { ptxAssignIndexToSymbols(gblState->lwrSymbolTable, gblState);    }
                          PopSymbolTable '}'  SourcePos                                         { defineFunction(gblState, $1, $8, $3, $10); gblState->parseData->lwrFunc = NULL;              }
                        ;

ParameterList           : '('                                                   { gblState->parsingParameters = True; gblState->parseData->sawIncompleteParam = False;  }
                              ParameterListItems ')'                            { $$= listReverse($3); gblState->parsingParameters = False;        }
                        | '(' ')'                                               { $$= NULL; gblState->parseData->sawIncompleteParam = False;                               }
                        | Empty                                                 { $$= NULL; gblState->parseData->sawIncompleteParam = False;                               }
                        ;

ParameterListItems      : Parameter                                             { $$= $1;                                       }
                        | ParameterListItems ',' Parameter                      { $$= listConcat($3,$1);                        }
                        ;

Parameter               : DeclType                 OptAllocNoAttr ParamAObject  { $$= listCons(createVariableInfo(gblState->parseData->lwrDecl,NULL,gblState->parseData->lwrStorageClass,ptxPtrNone,0,$2,0),NULL);  checkParameter(gblState); }
                        | DeclType KernelParamAttr OptAlignAttr   ParamAObject  { $$= listCons(createVariableInfo(gblState->parseData->lwrDecl,NULL,gblState->parseData->lwrStorageClass,$2,$3,-1,0),NULL);         checkParameter(gblState); }
                        ;

KernelParamAttr         : T_POINTER KernelParamAttrSpace SourcePos              { $$ = checkKernelParamAttr(gblState, $2,$3);             }
                        ;

KernelParamAttrSpace    : T_CONST                                               { $$ = ptxPtrConst;                             }
                        | T_GLOBAL                                              { $$ = ptxPtrGlobal;                            }
                        | T_LOCAL                                               { $$ = ptxPtrLocal;                             }
                        | T_SHARED                                              { $$ = ptxPtrShared;                            }
                        | T_TYPENAME SourcePos                                  { $$ = getPtxPtrForOpaque($1,$2);               }
                        | Empty                                                 { $$ = ptxPtrGeneric;                           }
                        ;

OptAlignAttr            : T_ALIGN uIntImm SourcePos                             { $$ = checkKernelParamAlignAttr(gblState, $2,$3);        }
                        | Empty                                                 { $$ = 0;                                       }
                        ;

OptAllocNoAttr          : T_ALLOCNO uIntImm SourcePos                           { $$ = checkAllocNoAttr(gblState, $2,$3);                 }
                        | Empty                                                 { $$ = -1;                                      }
                        ;

OptScratchAttr          : T_SCRATCH ScratchAttrElemList SourcePos               { $$= checkScratchRegs(gblState, listReverse($2),$3);     }
                        | Empty                                                 { $$= NULL;                                     }
                        ;

ScratchAttrElemList     : ScratchAttrElem                                       { $$= $1;                                       }
                        | ScratchAttrElemList ',' ScratchAttrElem               { $$= listConcat($3,$1);                        }
                        ;

ScratchAttrElem         : T_INT64                                               { $$= listCons((Pointer)(Address)$1, NULL);     }
                        | T_UINT64                                              { $$= listCons((Pointer)(Address)$1, NULL);     }
                        ;

OptRetAddrAllocNoAttr   : T_RETADDR_ALLOCNO uIntImm SourcePos                   { $$ = checkRetAddrAllocNoAttr(gblState, $2,$3);          }
                        | Empty                                                 { $$ = -1;                                      }

ParamAObject            : ParamObject '[' uIntImm ']' SourcePos                 { setSymbolType(gblState->parseData->lwrDecl, createArrayType(gblState, $3,gblState->parseData->lwrDecl->type, $5)); checkIncompleteParam(gblState, gblState->parseData->lwrDecl->type, $5); }
                        | ParamObject '[' ']' SourcePos                         { setSymbolType(gblState->parseData->lwrDecl, createArrayType(gblState, 0,gblState->parseData->lwrDecl->type, $4));  checkIncompleteParam(gblState, gblState->parseData->lwrDecl->type, $4); }
                        | ParamObject SourcePos                                 { checkIncompleteParam(gblState, gblState->parseData->lwrDecl->type, $2);                                                                                }
                        ;

ParamObject             : Identifier SourcePos                                  { gblState->parseData->lwrDecl= ptxCreateSymbol(gblState, gblState->parseData->lwrType,$1,gblState->parseData->lwrLogAlignment,gblState->parseData->lwrSymbolAttributes,$2); }
                        | T_SINK SourcePos                                      { gblState->parseData->lwrDecl= ptxCreateSymbol(gblState, gblState->parseData->lwrType,stdCOPYSTRING("_"),gblState->parseData->lwrLogAlignment,gblState->parseData->lwrSymbolAttributes,$2); }
                        ;

OptEntryDirectives      : EntryDirectives
                        | Empty
                        ;

EntryDirectives         : EntryDirective
                        | EntryDirective EntryDirectives
                        ;

OptNoReturn             : T_NORETURN                                SourcePos   { $$ = checkNoReturn(gblState, $2);               }
                        | Empty                                                 { $$ = 0;                               }
                        ;

OptUnique               : T_UNIQUE                                  SourcePos   { $$ = True;                            }
                        | Empty                                                 { $$ = False;                               }
                        ;

EntryDirective          : MaxNReg
                        | MaxNTid
                        | MaxNCtaPerSM
                        | MinNCtaPerSM
                        | ReqNTid
                        | PragmaDef
                        ;

MaxNReg                 : T_MAXNREG uIntImm                          SourcePos  { setMaxNReg(gblState, gblState->parseData->lwrFunc, $2, $3);          }
                        ;

MaxNTid                 : T_MAXNTID uIntImm                          SourcePos  { setMaxNTid(gblState, gblState->parseData->lwrFunc, $2,  1,  1, $3);  }
                        | T_MAXNTID uIntImm ',' uIntImm              SourcePos  { setMaxNTid(gblState, gblState->parseData->lwrFunc, $2, $4,  1, $5);  }
                        | T_MAXNTID uIntImm ',' uIntImm ',' uIntImm  SourcePos  { setMaxNTid(gblState, gblState->parseData->lwrFunc, $2, $4, $6, $7);  }
                        ;

MaxNCtaPerSM            : T_MAXNCTAPERSM uIntImm                     SourcePos  { setMaxNCtaPerSM(gblState, gblState->parseData->lwrFunc, $2, $3);     }
                        ;

MinNCtaPerSM            : T_MINNCTAPERSM uIntImm                     SourcePos  { setMinNCtaPerSM(gblState, gblState->parseData->lwrFunc, $2, $3);     }
                        ;

ReqNTid                 : T_REQNTID uIntImm                          SourcePos  { setReqNTid(gblState, gblState->parseData->lwrFunc, $2,  1,  1, $3);  }
                        | T_REQNTID uIntImm ',' uIntImm              SourcePos  { setReqNTid(gblState, gblState->parseData->lwrFunc, $2, $4,  1, $5);  }
                        | T_REQNTID uIntImm ',' uIntImm ',' uIntImm  SourcePos  { setReqNTid(gblState, gblState->parseData->lwrFunc, $2, $4, $6, $7);  }
                        ;

IndexedFile             : T_FILE uIntImm T_STRING                                     SourcePos { defineIndexedFile(gblState, $2,$3, NULL, NULL,$4); }
                        | T_FILE uIntImm T_STRING ',' IConstPrimary                   SourcePos { defineIndexedFile(gblState, $2,$3,   $5, NULL,$6); }
                        | T_FILE uIntImm T_STRING ',' IConstPrimary ',' IConstPrimary SourcePos { defineIndexedFile(gblState, $2,$3,   $5,   $7,$8); }
                        ;

CodeLocation            : T_LOC uIntImm uIntImm uIntImm SourcePos               { defineCodeLocation(gblState, $2, $3, $4, NULL, 0, -1, -1, -1, $5);      }
                        | T_LOC uIntImm uIntImm uIntImm ',' T_FUNCNAME Identifier ',' T_INLINED_AT uIntImm uIntImm uIntImm SourcePos                { defineCodeLocation(gblState, $2, $3, $4, $7, -1, $10, $11, $12, $13);}
                        | T_LOC uIntImm uIntImm uIntImm ',' T_FUNCNAME Identifier '+' DwarfInt ',' T_INLINED_AT uIntImm uIntImm uIntImm SourcePos   { defineCodeLocation(gblState, $2, $3, $4, $7, $9, $12, $13, $14, $15);}
                        | T_LOC uIntImm uIntImm uIntImm ',' T_FUNCNAME T_DOTIDENT ',' T_INLINED_AT uIntImm uIntImm uIntImm SourcePos                { defineCodeLocation(gblState, $2, $3, $4, $7,  0, $10, $11, $12, $13);}
                        | T_LOC uIntImm uIntImm uIntImm ',' T_FUNCNAME T_DOTIDENT '+' DwarfInt ',' T_INLINED_AT uIntImm uIntImm uIntImm SourcePos   { defineCodeLocation(gblState, $2, $3, $4, $7, $9, $12, $13, $14, $15);}

                        ;

DwarfBytes              : { gblState->parseData->parsingDwarfData = True; } DwarfByte { gblState->parseData->parsingDwarfData = False; }

DwarfByte               : T_DWARF T_SECTION T_DOTIDENT ',' T_STRING ',' T_PROGBITS SourcePos { defineDwarfSection(gblState, $3,$8,True);                             }
                        | T_DWARF T_TYPENAME DwarfInt                                      SourcePos { defineDwarfBytes(gblState, $2,$3,$4);                                 }
                        | T_DWARF T_TYPENAME DwarfInt ',' RDwarfByteList                   SourcePos { defineDwarfByteList(gblState, $2, listConcat(listCons(ptxCreateIntConstantExpr($3,False, gblState),NULL),$5),$6);}
                        | T_DWARF T_TYPENAME  T_DOTIDENT                           SourcePos { defineDwarfLabel(gblState, $2,$3,$4);                                 }
                        | T_DWARF T_TYPENAME  Identifier                           SourcePos { defineDwarfLabel(gblState, $2,$3,$4);                                 }
                        ;

DwarfSection            : T_SECTION T_DOTIDENT                  SourcePos        { defineDwarfSection(gblState, $2,$3,False);                     }
                          '{'                                                    { gblState->parseData->parsingDwarfData = True;  }
                           DwarfLines
                          '}'                                                    { gblState->parseData->parsingDwarfData = False; }
                        ;

DwarfLines              : DwarfLines DwarfLine
                        | Empty
                        ;

DwarfLine               : T_TYPENAME  DwarfInt                      SourcePos    { defineDwarfBytes(gblState, $1,$2,$3);                                         }
                        | T_TYPENAME  DwarfNegInt                   SourcePos    { defineDwarfNegativeByte(gblState, $1,$2,$3);                                  }
                        | T_TYPENAME  DwarfInt ',' RDwarfByteList   SourcePos    { defineDwarfByteList(gblState, $1,listConcat(listCons(ptxCreateIntConstantExpr($2,False, gblState),NULL),$4),$5); }
                        | T_TYPENAME  DwarfNegInt ',' RDwarfByteList SourcePos   { defineDwarfByteList(gblState, $1,listConcat(listCons($2,NULL),$4),$5);        }
                        | T_TYPENAME  T_DOTIDENT                    SourcePos    { defineDwarfLabel(gblState, $1,$2,$3);                                         }
                        | Identifier  ':'                           SourcePos    { defineInternalDwarfLabel(gblState, $1, $3);                                   }
                        | T_TYPENAME  Identifier                    SourcePos    { defineDwarfLabel(gblState, $1,$2,$3);                                         }
                        | T_TYPENAME  T_DOTIDENT '+' DwarfInt       SourcePos    { defineDwarfLabelPlusOffset(gblState, $1,$2,$4,$5);                            }
                        | T_TYPENAME  Identifier '+' DwarfInt       SourcePos    { defineDwarfLabelPlusOffset(gblState, $1,$2,$4,$5);                            }
                        | T_TYPENAME  Identifier '-' Identifier     SourcePos    { defineDwarfLabelMinusLabel(gblState, $1,$2,$4,$5);                            }                        
                        ;

RDwarfByteList          : DwarfInt                                              { $$= listCons(ptxCreateIntConstantExpr($1,False, gblState),NULL); }
                        | DwarfNegInt                                           { $$= listCons($1,NULL); }
                        | RDwarfByteList ',' DwarfInt                           { $$= listConcat($1, listCons(ptxCreateIntConstantExpr($3,False, gblState),NULL)); }
                        | RDwarfByteList ',' DwarfNegInt                        { $$= listConcat($1, listCons($3,NULL)); }
                        ;

DwarfInt                : T_UINT64                                              { $$=$1; }
                        | T_INT64                                               { $$=$1; }
                        ;


DwarfNegInt             : '-' T_INT64                               SourcePos   { $$=defineDwarfNegIntConstantExpr($2,$3,gblState); }
                        ;

MetadataSection         : T_METADATA_SECTION SourcePos                          { defineMetaDataSection(gblState, $2);                            }
                          '{' MetaDataNodes '}'
                        ;

MetaDataNodes           : MetaDataNodes MetaDataNode
                        | Empty
                        ;

MetaDataNode            : T_METADATA uIntImm '{' T_STRING ',' MetaDataValues '}' SourcePos   { defineMetaDataNode(gblState, $2,$4,listReverse($6),$8); }
                        ;

MetaDataValues          : MetaDataValue                                         { $$= $1;                                               }
                        | MetaDataValues ',' MetaDataValue                      { $$= listConcat($3, $1);                               }
                        ;

MetaDataValue           : T_TYPENAME uIntImm                    SourcePos       { $$=listCons(ptxCreateMetadataValueInt($2), NULL);     }
                        | T_STRING                              SourcePos       { $$=listCons(ptxCreateMetadataValueString($1), NULL);  }
                        | T_METADATA_INDEX uIntImm              SourcePos       { stdCHECK_WITH_POS( mapIsDefined(gblState->metadataSection->metaDataNodeMap, (Pointer)(Address)$2),
                                                                                                     (ptxMsgUnknownMetaDataIndex,$3,$2) );
                                                                                  $$=listCons(ptxCreateMetadataValueIndex($2), NULL);   
                                                                                }
                        ;


/*------------------------- Macro Declarations -------------------------*/

MacroDef                : T_MACRO Identifier SourcePos FormalMacroParams ';'    { defineMacro(gblState, $2,$4,$3); }
                        ;


FormalMacroParams       : Identifier FMPs                                       { $$ = listCons($1,$2);  }
                        | Empty                                                 { $$ = NULL;             }
                        ;

FMPs                    : ',' Identifier FMPs                                   { $$ = listCons($2,$3);  }
                        | Empty                                                 { $$ = NULL;             }
                        ;

/*------------------------ Variable Declarations -----------------------*/

VariableDefs            : DeclType OptIdentDefs                                 { $$=   $2;              }
                        ;

OptIdentDefs            : RIdentDefs                                            { $$= listReverse($1);   }
                        | Empty                                                 { $$= NULL;              }
                        ;

RIdentDefs              : IdentDef                                              { $$= $1;                }
                        | RIdentDefs ',' IdentDef                               { $$= listConcat($3,$1); }
                        ;

IdentDef                : Object            OptInitialization                   { $$= listCons(createVariableInfo(gblState->parseData->lwrDecl,$2,gblState->parseData->lwrStorageClass,ptxPtrNone,0,-1,0),NULL); }
                        | AObject SourcePos OptInitialization                   { setSymbolType(gblState->parseData->lwrDecl, createMultiDimArrayType(gblState, $1,gblState->parseData->lwrType,$3,$2));
                                                                                  $$= listCons(createVariableInfo(gblState->parseData->lwrDecl,$3,gblState->parseData->lwrStorageClass,ptxPtrNone,0,-1,0),NULL);
                                                                                  setArrayInitializer(gblState, gblState->parseData->lwrDecl, gblState->parseData->lwrFunc, ($$)->head); }
                        | PObject                                               { $$= $1;                                                         }
                        ;

Object                  : Identifier SourcePos                                  { gblState->parseData->lwrDecl= ptxCreateSymbol(gblState, gblState->parseData->lwrType,$1,gblState->parseData->lwrLogAlignment,gblState->parseData->lwrSymbolAttributes,$2);
                                                                                  if (ptxIsManglingNeeded(gblState->parseData->lwrStorageClass) && gblState->parseData->lwrScope == ptxLocalScope) {
                                                                                    gblState->parseData->lwrDecl->name = ptxMangleName(gblState->parseData->lwrDecl, gblState->parseData->numScopesOnLine) ; 
                                                                                  }
                                                                                }
                        ;

AObject                 : AObject '[' uIntImm64 ']' SourcePos                   { $$= listCons((Pointer)(Address)$3, $1); }
                        | Object  '[' uIntImm64 ']' SourcePos                   { $$= listCons((Pointer)(Address)$3, NULL); }
                        | Object  '['         ']'                               { $$= listCons((Pointer)(Address) 0,NULL); }

PObject                 : Identifier '<' uIntImm '>' SourcePos                  { $$= listCons(createMultipleVariableInfo(gblState, gblState->parseData->lwrType,$1,$3,gblState->parseData->lwrLogAlignment,gblState->parseData->lwrStorageClass,$5),NULL); }
                        ;

DeclType                : OptVarAttributes Type SourcePos                       { gblState->parseData->lwrType=$2; checkType(gblState, $3);                                      }
                        ;

OptVarAttributes        : OptVarAttributes OptVarAttribute
                        | Empty                                                 { gblState->parseData->lwrStorageClass= ptxNOSTORAGECLASS; gblState->parseData->lwrLogAlignment= 0; gblState->parseData->lwrSymbolAttributes= ptxAttributeNone;    }
                        ;

OptVarAttribute         : T_ALIGN uIntImm          SourcePos                    { setLwrAlignment   (gblState, $2, $3);             }
                        | StorageClass             SourcePos                    { setLwrStorageClass(gblState, $1, $2);             }
                        | T_ATTRIBUTE   '(' AttributeList ')' SourcePos
                        ;

AttributeList           : Attribute
                        | AttributeList ',' Attribute
                        ;

Attribute               : T_MANAGED SourcePos                                    { setLwrSymbolAttribute(gblState, ptxAttributeManaged, $2); }
                        ;

/*--------------------- Common Part of Variable Declarations --------------------------------------------------------------------------*/

InstStorageClass        : T_CONST               SourcePos       { $$= ptxCreateStorageClass( ptxConstStorage,  checkConstBank(gblState, $1,$2) ); }
                        | T_GLOBAL                              { $$= ptxCreateStorageClass( ptxGlobalStorage, -1 );                    }
                        | T_LOCAL                               { $$= ptxCreateStorageClass( ptxLocalStorage,  -1 );                    }
                        | T_PARAM                               { $$= ptxCreateStorageClass( ptxParamStorage,  -1 );                    }
                        | T_SHARED                              { $$= ptxCreateStorageClass( ptxSharedStorage, -1 );                    }
                        | T_TEX                                 { $$= ptxCreateStorageClass( ptxTexStorage,    -1 );                    }
                        ;

StorageClass            : T_REG                                 { $$= ptxCreateStorageClass( ptxRegStorage,    -1 );                    }
                        | T_CONST               SourcePos       { $$= ptxCreateStorageClass( ptxConstStorage,  checkConstBank(gblState, $1,$2) ); }
                        | T_GLOBAL                              { $$= ptxCreateStorageClass( ptxGlobalStorage, -1 );                    }
                        | T_LOCAL                               { $$= ptxCreateStorageClass( ptxLocalStorage,  -1 );                    }
                        | T_PARAM                               { $$= ptxCreateStorageClass( ptxParamStorage,  -1 );                    }
                        | T_SHARED                              { $$= ptxCreateStorageClass( ptxSharedStorage, -1 );                    }
                        | T_TEX                                 { $$= ptxCreateStorageClass( ptxTexStorage,    -1 );                    }
                        ;

/*--------------------- Type Language ---------------------------------------------------------------------------------*/

Type                    : T_TYPENAME                                    { $$= $1;                                       }
                        | VectorType                                    { $$= $1;                                       }
                        ;

VectorType              : T_VECTOR  T_TYPENAME SourcePos                { $$= createVectorType(gblState, getVectorSize($1),$2,$3); }
                        ;

/*--------------------- Initializers ----------------------------------------------------------------------------------*/

OptInitialization       : Empty                                         { $$= NULL;                                     }
                        | '=' Initializer                               { $$= $2;                                       }
                        ;

Initializer             : ConstExpr                  SourcePos                 { $$= createExpressionInitializer(False,$1,~0,$2); }
                        | Symbol                     SourcePos                 { $$= createExpressionInitializer(False,createAddressOfExpr(gblState, $1),~0,$2); }
                        | Symbol '+' IntConstExpr    SourcePos                 { $$= createExpressionInitializer(False,createBaseOffsetExpr(gblState, $1,$3,$4),~0,$4); }
                        | GenSym                     SourcePos                 { $$= createExpressionInitializer(True,createAddressOfExpr(gblState, $1),~0,$2); }
                        | GenSym '+' IntConstExpr    SourcePos                 { $$= createExpressionInitializer(True,createBaseOffsetExpr(gblState, $1,$3,$4),~0,$4); }
                        | Identifier '=' ConstExpr   SourcePos                 { $$= createNamedFieldInitializer($1,$3,$4);    }
                        | Identifier '=' Identifier  SourcePos                 { $$= createNamedFieldInitializer($1,createInitValExpr(gblState, $3,$4),$4); }
                        | uIntImm64 '(' ConstExpr ')' SourcePos                { checkMaskOperator(gblState, $1,$5); $$= createExpressionInitializer(False,constMaskImmediateExpr(gblState, $1, $3, $5), ~0, $5); }
                        | uIntImm64 '(' Symbol ')'    SourcePos                { checkMaskOperator(gblState, $1,$5); $$= createExpressionInitializer(False,createAddressOfExpr(gblState, $3),$1,$5); }
                        | uIntImm64 '(' Symbol '+' IntConstExpr ')'  SourcePos { checkMaskOperator(gblState, $1,$7); $$= createExpressionInitializer(False,createBaseOffsetExpr(gblState, $3,$5,$7),$1,$7); }
                        | uIntImm64 '(' GenSym ')'    SourcePos                { checkMaskOperator(gblState, $1,$5); $$= createExpressionInitializer(True,createAddressOfExpr(gblState, $3),$1,$5); }
                        | uIntImm64 '(' GenSym '+' IntConstExpr ')'  SourcePos { checkMaskOperator(gblState, $1,$7); $$= createExpressionInitializer(True,createBaseOffsetExpr(gblState, $3,$5,$7),$1,$7); }
                        | '{' OptInitializerList '}' SourcePos                 { $$= createStructuredInitializer($2,$4);       }
                        ;

GenSym                  : Identifier SourcePos '(' Symbol ')'           { checkGenericOperator($1,$2);  $$= $4;         }
                        ;

OptInitializerList      : InitializerList                               { $$= $1;                                       }
                        | Identifier '<' uIntImm '>'    SourcePos       { $$= createMultipleSymbolInitializers(gblState, $1,$3,$5); }
                        | Empty                                         { $$= NULL;                                     }
                        ;

  /*
   * Use left relwrsive grammar in order to avoid parser stack overflow for large inputs:
   */
InitializerList         : ReverseInitializerList                        { $$ = listReverse($1);                         }
                        ;

ReverseInitializerList  : Initializer                                   { $$ = listCons($1,NULL);                       }
                        | ReverseInitializerList ',' Initializer        { $$ = listCons($3,$1);                         }
                        ;

/*--------------------- Expressions -----------------------------------------------------------------------------------*/

BaseOffset              : Symbol       SourcePos                        { $$ = createAddressOfExpr(gblState, $1);                 }
                        | Symbol '+'   SourcePos IntConstExpr           { $$ = createBaseOffsetExpr(gblState, $1,$4,$3);          }
                        | IntConstExpr                                  { $$ = $1;                                      }
                        ;

Scalar                  : T_SINK                                        { $$ = ptxCreateSinkExpr();                     }
                        | Symbol                                        { $$ = $1;                                      }
                        | ConstExpr                                     { $$ = $1;                                      }
                        | Symbol Selector SourcePos                     { $$ = createSelectExpr(gblState, $1, $2, $3);            }
                        ;

ScalarList              : Scalar                                        { $$ = listCons($1,NULL);                       }
                        | Scalar ',' ScalarList                         { $$ = listCons($1,$3);                         }
                        ;

Tuple                   : '{' ScalarList '}'   SourcePos                { $$ = createVectorExpr(gblState, $2,$4);                 }
                        ;

TexAddress              : Symbol ',' Tuple                              { setTexAddr(gblState); pushArgument(gblState, $1); $$ = $3;      }
                        | Symbol ',' Symbol                             { setTexAddr(gblState); pushArgument(gblState, $1); $$ = $3;      }
                        | Symbol ',' Symbol ',' Tuple                   { setTexAddr(gblState); pushArgument(gblState, $1); pushArgument(gblState, $3); $$ = $5;    }
                        ;

OperandExpr             : Primary                                       { $$ = $1;                                      }
                        ;

Primary                 :     Symbol            SourcePos               { $$ = $1;                                      }
                        | '!' Symbol            SourcePos               { $$ = createNotExpr   (gblState, $2,$3);                 }
                        | '-' Symbol            SourcePos               { $$ = createNegateExpr($2,$3);                 }
                        | '-' Symbol Selector   SourcePos               { $$ = createNegateExpr(createSelectExpr (gblState, $2,$3,$4), $4); }
                        |     Symbol Selector   SourcePos               { $$ = createSelectExpr(gblState, $1,$2,$3);              }
                        | Symbol '[' BaseOffset ']' SourcePos           { $$ = createArrayIndexExpr(gblState, $1,$3,$5);          }
                        | Symbol '+' SourcePos IntConstExpr             { $$ = createBaseOffsetExpr(gblState, $1,$4,$3);          }
                        | ConstExpr                                     { $$ = $1;                                      }
                        | Tuple                                         { $$ = $1;                                      }
                        | Tuple Selector        SourcePos               { $$ = createSelectExpr(gblState, $1,$2,$3);              }
                        | '[' BaseOffset ']'    SourcePos               { $$ = createAddressRefExpr ($2,$4);            }
                        | '[' TexAddress ']'    SourcePos               { $$ = $2;                                      }
                        ;

Symbol                  : Identifier              SourcePos             { $$ = createSymbolExpr          (gblState, $1,$2);       }
                        ;

Selector                : T_DOTIDENT                                    { $$ = $1;                                      }
                        | T_TYPENAME                                    { $$ = (String) typeToString(gblState->parseData, $1);               }
                        ;

/*---------------------------- Instructions ----------------------------*/

Instruction             : GuardExpression UnGuardedInstruction
                        |                 UnGuardedInstruction
                        ;

GuardExpression         : '@'     Identifier SourcePos                   { setGuard(gblState,  createPredicateExpr (gblState, False,$2,$3)); }
                        | '@' '!' Identifier SourcePos                   { setGuard(gblState,  createPredicateExpr (gblState, True,$3,$4)); }
                        ; 

UnGuardedInstruction    : '\\' T_IDENT SourcePos OptFlags OptArguments                     ';' { recognizeInstruction(gblState, False,$2,$3, scanner); }
                        |      T_IDENT SourcePos OptFlags OptArguments                     ';' { recognizeInstruction(gblState, True, $1,$2, scanner); }
                        | T_CALL SourcePos OptFlags            CallTgt                     ';' { recognizeInstruction(gblState, True, $1,$2, scanner); }
                        | T_CALL SourcePos OptFlags            CallTgt ',' Params          ';' { recognizeInstruction(gblState, True, $1,$2, scanner); }
                        | T_CALL SourcePos OptFlags Params ',' CallTgt                     ';' { recognizeInstruction(gblState, True, $1,$2, scanner); }
                        | T_CALL SourcePos OptFlags Params ',' CallTgt ',' Params          ';' { recognizeInstruction(gblState, True, $1,$2, scanner); }
                        | T_CALL SourcePos OptFlags            CallTgt            ',' Funs ';' { recognizeInstruction(gblState, True, $1,$2, scanner); }
                        | T_CALL SourcePos OptFlags            CallTgt ',' Params ',' Funs ';' { recognizeInstruction(gblState, True, $1,$2, scanner); }
                        | T_CALL SourcePos OptFlags Params ',' CallTgt            ',' Funs ';' { recognizeInstruction(gblState, True, $1,$2, scanner); }
                        | T_CALL SourcePos OptFlags Params ',' CallTgt ',' Params ',' Funs ';' { recognizeInstruction(gblState, True, $1,$2, scanner); }
                        ;

Identifier              : T_IDENT                                             { $$ = $1;}
                        | T_CALL                                              { $$ = $1;}
                        ;

CallTgt                 : Symbol                                  { pushArgument(gblState, $1); }
                        ;

Funs                    : Symbol                                  { pushArgument(gblState, $1); }
                        ;

OptArguments            : Arguments
                        | Empty
                        ;

Arguments               : Arguments ',' Argument
                        | FirstArgument
                        | Argument
                        ;

FirstArgument           : T_SINK                                  { pushArgument(gblState, ptxCreateSinkExpr());                                          }
                        | Symbol   SourcePos '|' T_SINK           { pushArgument(gblState, $1);                                                           }
                        | T_SINK   SourcePos '|' Symbol           { pushArgument(gblState, ptxCreateSinkExpr());  setPredicateOutput(gblState, $4, $2);             }
                        | Symbol   SourcePos '|' Symbol           { pushArgument(gblState, $1);                   setPredicateOutput(gblState, $4, $2);             }
                        | Tuple    SourcePos '|' Symbol           { pushArgument(gblState, $1);                   setPredicateOutput(gblState, $4, $2);             }
                        ;

Argument                : OperandExpr                             { pushArgument(gblState, $1);                           }
                        ;

Param                   : T_SINK                                  { $$ = ptxCreateSinkExpr();                   }
                        | Symbol                                  { $$ = $1;                                    }
                        | ConstExpr                               { $$ = $1;                                    }
                        ;

Params                  : '(' OptParamList ')'   SourcePos        { pushArgument(gblState, createParamListExpr(gblState, $2,$4));   }
                        ;

OptParamList            : ParamList                               { $$= $1;                                }
                        | Empty                                   { $$= NULL;                              }
                        ;

ParamList               : Param                                   { $$= listCons($1,NULL);                 }
                        | Param ',' ParamList                     { $$= listCons($1,$3);                   }
                        ;

Flag                    : T_TYPENAME        SourcePos             { pushInstructionType(gblState, $1, $2);           checkIsLastSeelwectorType(gblState, True,  $2);  }
                        | T_LAYOUT          SourcePos             { pushMatrixLayout(gblState, $1, $2);              checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_SCOPEMOD        SourcePos             { setScopeModifier(gblState, $1, $2);              checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_UNIFORMMOD      SourcePos             { setUniformModifier(gblState, $1, $2);            checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_ALIGNMOD        SourcePos             { setAlignModifier(gblState, $1, $2);              checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_SYNCMOD         SourcePos             { setSyncModifier(gblState, $1, $2);               checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_TTUSLOTMOD      SourcePos             { setTTUSlotModifier(gblState, $1, $2);            checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_TTUMOD          SourcePos             { setTTUModifier(gblState, $1, $2);                checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_NUMMOD          SourcePos             { setNumModifier(gblState, $1, $2);                checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_GROUPMOD        SourcePos             { setGroupModifier(gblState, $1, $2);              checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_TYPEMOD         SourcePos             { pushTypeMod(gblState, $1, $2);                   checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_TRANSMOD        SourcePos             { setTransModifier(gblState, $1, $2);              checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_SEQMOD          SourcePos             { setSeqModifier(gblState, $1, $2);                checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_EXPANDMOD       SourcePos             { setExpandModifier(gblState, $1, $2);             checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_EXCLUSIVE       SourcePos             { setExclusiveModifier(gblState, $1, $2);          checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_THREADSMOD      SourcePos             { setThreadsModifier(gblState, $1, $2);            checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_THREADGROUPMOD  SourcePos             { setThreadGroupModifier(gblState, $1,$2);         checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_BRANCHMOD       SourcePos             { setBranchModifier(gblState, $1, $2);             checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_APRXMOD         SourcePos             { setApproxModifier(gblState, $1, $2);             checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_RELUMOD         SourcePos             { setReluModifier(gblState, $1, $2);               checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_MBARRIERMOD     SourcePos             { setMbarrierModifier(gblState, $1, $2);           checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_NANMODEMOD      SourcePos             { setNaNModifier(gblState, $1, $2);                checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_TRANSAMOD       SourcePos             { setTransAModifier(gblState, $1, $2);             checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_NEGAMOD         SourcePos             { setNegAModifier(gblState, $1, $2);               checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_TRANSBMOD       SourcePos             { setTransBModifier(gblState, $1, $2);             checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_NEGBMOD         SourcePos             { setNegBModifier(gblState, $1, $2);               checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_IGNORECMOD      SourcePos             { setIgnoreCModifier(gblState, $1, $2);            checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_FTZMOD          SourcePos             { setFtzModifier(gblState, $1, $2);                checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_NOFTZMOD        SourcePos             { setNoftzModifier(gblState, $1, $2);              checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_SATMOD          SourcePos             { setSatModifier(gblState, $1, $2);                checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_SATFMOD         SourcePos             { setSatfModifier(gblState, $1, $2);               checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_CCMOD           SourcePos             { setCCModifier(gblState, $1, $2);                 checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_SHAMTMOD        SourcePos             { setShamtModifier(gblState, $1, $2);              checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_ORDERMOD        SourcePos             { setOrderModifier(gblState, $1, $2);              checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_NCMOD           SourcePos             { setNCModifier(gblState, $1, $2);                 checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_VOTEMOD         SourcePos             { setVoteModifier(gblState, $1, $2);               checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_CLAMPMOD        SourcePos             { setClampModifier(gblState, $1, $2);              checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_SHRMOD          SourcePos             { setShrModifier(gblState, $1, $2);                checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_VMADMOD         SourcePos             { setVmadModifier(gblState, $1, $2);               checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_PRMTMOD         SourcePos             { setPrmtModifier(gblState, $1, $2);               checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_SHFLMOD         SourcePos             { setShflModifier(gblState, $1, $2);               checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_ENDISMOD        SourcePos             { setEnDisModifier(gblState, $1, $2);              checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_RANDMOD         SourcePos             { setRandModifier(gblState, $1, $2);               checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_VECTOR          SourcePos             { setVectorModifier(gblState, $1,$2);              setIsLastSeelwectorType(gblState, True);         }
                        | T_DIMMOD          SourcePos             { setDimModifier(gblState, $1,$2);                 checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_TEXMOD          SourcePos             { setTextureModifier(gblState, $1,$2);             checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_FOOTPRINTMOD    SourcePos             { setFootprintModifier(gblState, $1,$2);           checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_COARSEMOD       SourcePos             { setCoarseModifier(gblState, $1,$2);              checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_QUERYMOD        SourcePos             { setQueryModifier(gblState, $1,$2);               checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_ROUNDMOD        SourcePos             { setRoundModifier(gblState, $1, $2);              checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_NOCOMPLETEMOD   SourcePos             { setNoCompleteModifier(gblState, $1, $2);         checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_NOINCMOD        SourcePos             { setNoIncModifier(gblState, $1, $2);              checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_TESTPMOD        SourcePos             { setTestpModifier(gblState, $1, $2);              checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_COPMOD          SourcePos             { setCacheOpModifier(gblState, $1, $2);            checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_LVLMOD          SourcePos             { setLevelModifier(gblState, $1, $2);              checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_COMPARISON      SourcePos             { setCMP(gblState, $1,$2);                         checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_BOOLEAN_OP      SourcePos             { setPtxOp(gblState, $1,BoolOperationClass,$2);    checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_ATOMIC_OP       SourcePos             { setPtxOp(gblState, $1,AtomicOperationClass,$2);  checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_ARITH_OP        SourcePos             { setPtxOp(gblState, $1,ArithOperationClass,$2);   checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_SHAPE           SourcePos             { setMatrixShape(gblState, $1,$2);                 checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_SPARSITY        SourcePos             { setSparsityModifier(gblState, $1, $2);           checkIsLastSeelwectorType(gblState, False, $2);  }
                        // T_WEAK is explicitly handled because it clashes with .weak scope token and hence handled as a separate rule
                        | T_WEAK            SourcePos             { setWeakOrderModifier(gblState, $2);              checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_DOTIDENT        SourcePos             { setModifier(gblState, $1,$2);                    checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_CACHEPREFETCH   SourcePos             { setCachePrefetchModifier(gblState, $1,$2);       checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_PREFETCHSIZE    SourcePos             { setPrefetchSizeModifier(gblState, $1,$2);        checkIsLastSeelwectorType(gblState, False, $2);  }
                        | InstStorageClass  SourcePos             { addStorage(gblState, $1, $2);                    checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_ABSMOD          SourcePos             { setAbsModifier(gblState, $1, $2);                checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_CACHEHINTMOD    SourcePos             { setCacheHintModifier(gblState, $1, $2);          checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_LEVELEVICTMOD   SourcePos             { setLevelEvictPriorityModifier(gblState, $1, $2); checkIsLastSeelwectorType(gblState, False, $2);  }
                        // T_ALIAS is explicitly handled because it clashes with .alias directive token and hence handled as a separate rule
                        | T_ALIAS           SourcePos             { setAliasProxyKindModifier(gblState, $2);         checkIsLastSeelwectorType(gblState, False, $2);  }
                        | T_PROXYKINDMOD    SourcePos             { setProxyKindModifier(gblState, $1, $2);          checkIsLastSeelwectorType(gblState, False, $2);  }
                        ;

OptFlags                : Empty
                        | Flag OptFlags
                        ;

/*--------------------- Simple Constant Expressions -----------------------------------------------------------------------------------*/

uIntImm                 : IConstPrimary     SourcePos                           { $$ = cvtIntExprTouInt($1,$2);                         }
                        ;

uIntImm64               : IConstPrimary     SourcePos                           { $$ = cvtIntExprTouInt64($1,$2);                       }
                        ;

IntConstExpr            : ConstExpr SourcePos                                   { $$ = $1; constCheckInt($1,$2);                        }
                        ;

IConstPrimary           : T_INT64                                               { $$ = ptxCreateIntConstantExpr($1,True,  gblState);      }
                        | T_UINT64                                              { $$ = ptxCreateIntConstantExpr($1,False, gblState);      }
                        | T_WARP_SZ                                             { $$ = ptxCreateIntConstantExpr(WARP_SIZE,True, gblState);}
                        ;

ConstPrimary            : IConstPrimary                                         { $$ = $1;                                              }
                        | T_FLOAT64                                             { $$ = ptxCreateF64FloatConstantExpr($1, gblState);  }
                        | '(' ConstExpr ')'                                     { $$ = $2;                                              }
                        ;

UnaryExpr               : ConstPrimary                                          { $$ = $1;                                              }
                        | '+' SourcePos CastExpr                                { $$ = constUnaryExpr(gblState, ptxADDOp,$3,$2);                  }
                        | '-' SourcePos CastExpr                                { $$ = constUnaryExpr(gblState, ptxSUBOp,$3,$2);                  }
                        | '~' SourcePos CastExpr                                { $$ = constUnaryExpr(gblState, ptxILWOp,$3,$2);                  }
                        | '!' SourcePos CastExpr                                { $$ = constUnaryExpr(gblState, ptxNOTOp,$3,$2);                  }
                        ;

CastExpr                : UnaryExpr                                             { $$ = $1;                                              }
                        | '(' T_TYPENAME ')' SourcePos CastExpr                 { $$ = constCast(gblState, $2,$5,$4);                             }
                        ;

MultiplicativeExpr      : CastExpr                                              { $$ = $1;                                              }
                        | MultiplicativeExpr '*' CastExpr SourcePos             { $$ = constBinaryExpr(gblState, ptxMULOp,$1,$3,$4);              }
                        | MultiplicativeExpr '/' CastExpr SourcePos             { $$ = constBinaryExpr(gblState, ptxDIVOp,$1,$3,$4);              }
                        | MultiplicativeExpr '%' CastExpr SourcePos             { $$ = constBinaryExpr(gblState, ptxREMOp,$1,$3,$4);              }
                        ;

AdditiveExpr            : MultiplicativeExpr                                    { $$ = $1;                                              }
                        | AdditiveExpr '+' MultiplicativeExpr SourcePos         { $$ = constBinaryExpr(gblState, ptxADDOp,$1,$3,$4);              }
                        | AdditiveExpr '-' MultiplicativeExpr SourcePos         { $$ = constBinaryExpr(gblState, ptxSUBOp,$1,$3,$4);              }
                        ;

ShiftExpr               : AdditiveExpr                                          { $$ = $1;                                              }
                        | ShiftExpr T_SHL AdditiveExpr SourcePos                { $$ = constBinaryExpr(gblState, ptxSHLOp,$1,$3,$4);              }
                        | ShiftExpr T_SHR AdditiveExpr SourcePos                { $$ = constBinaryExpr(gblState, ptxSHROp,$1,$3,$4);              }
                        ;

RelationalExpr          : ShiftExpr                                             { $$ = $1;                                              }
                        | RelationalExpr '<'    ShiftExpr SourcePos             { $$ = constBinaryExpr(gblState, ptxLTOp,$1,$3,$4);               }
                        | RelationalExpr '>'    ShiftExpr SourcePos             { $$ = constBinaryExpr(gblState, ptxGTOp,$1,$3,$4);               }
                        | RelationalExpr T_LTEQ ShiftExpr SourcePos             { $$ = constBinaryExpr(gblState, ptxLTEQOp,$1,$3,$4);             }
                        | RelationalExpr T_GTEQ ShiftExpr SourcePos             { $$ = constBinaryExpr(gblState, ptxGTEQOp,$1,$3,$4);             }
                        ;

EqualityExpr            : RelationalExpr                                        { $$ = $1;                                              }
                        | EqualityExpr T_EQ  RelationalExpr SourcePos           { $$ = constBinaryExpr(gblState, ptxEQOp,$1,$3,$4);               }
                        | EqualityExpr T_NEQ RelationalExpr SourcePos           { $$ = constBinaryExpr(gblState, ptxNEQOp,$1,$3,$4);              }
                        ;

AndExpr                 : EqualityExpr                                          { $$ = $1;                                              }
                        | AndExpr '&' EqualityExpr SourcePos                    { $$ = constBinaryExpr(gblState, ptxANDOp,$1,$3,$4);              }
                        ;

ExclusiveOrExpr         : AndExpr                                               { $$ = $1;                                              }
                        | ExclusiveOrExpr '^' AndExpr SourcePos                 { $$ = constBinaryExpr(gblState, ptxXOROp,$1,$3,$4);              }
                        ;

InclusiveOrExpr         : ExclusiveOrExpr                                       { $$ = $1;                                              }
                        | InclusiveOrExpr '|' ExclusiveOrExpr SourcePos         { $$ = constBinaryExpr(gblState, ptxOROp,$1,$3,$4);               }
                        ;

LogicalAndExpr          : InclusiveOrExpr                                       { $$ = $1;                                              }
                        | LogicalAndExpr T_ANDAND InclusiveOrExpr SourcePos     { $$ = constBinaryExpr(gblState, ptxANDANDOp,$1,$3,$4);           }
                        ;

LogicalOrExpr           : LogicalAndExpr                                        { $$ = $1;                                              }
                        | LogicalOrExpr T_OROR LogicalAndExpr SourcePos         { $$ = constBinaryExpr(gblState, ptxOROROp,$1,$3,$4);             }
                        ;

CondExpr                : LogicalOrExpr                                         { $$ = $1;                                              }
                        | LogicalOrExpr '?' ConstExpr ':' CondExpr SourcePos    { $$ = constConditional($1,$3,$5,$6);                   }
                        ;

ConstExpr               : CondExpr                                              { $$ = $1;                                              }
                        | T_FLOAT                                               { $$ = ptxCreateF32FloatConstantExpr($1, gblState);  }
                        ;

/*--------------------- Utility functions ---------------------------------------------------------------------------------------------*/

PopSymbolTable          : { $$ = popSymbolTable(gblState);      };
PushSymbolTable         : { $$ = pushSymbolTable(gblState);     };

SourcePos               : { $$ = ptxsLwrPos(gblState);          };

Empty  :;

%%



