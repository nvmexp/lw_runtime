#!/usr/bin/elw python

import sys
from contextlib import contextmanager
import datetime


@contextmanager
def stdout_to_file(fname=None):
    '''
    Allows easy redirection of stdout to file.  Use:
    
    with stdout_to_file( 'filename.txt' ):
        print("This goes to filename.txt, not stdout\n")
    '''
    old_stdout = sys.stdout
    if fname:
        sys.stdout = open(fname,'w')
    try:
        yield
    finally:
        sys.stdout = old_stdout


def binary_to_cpp( data, var_name, fname_base,  ):
    '''
    Writes binary data to a C char array var_name in [file_base].cpp
    A header file [file_base].hpp is also generated. 
    '''

    autogen_comment = "// This file auto-generated by {} at {}".format(
            sys.argv[0],
            datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            )
    
    with stdout_to_file(fname_base+'.cpp'):
        print(autogen_comment)
        print("#ifdef __cplusplus")
        print("extern \"C\" {")
        print("#endif")
        print("")
        print("unsigned char %s[%ld] = {" % (var_name,len(data)))
        pos = 0
        for d in data:
            valstr = '0x%02x,' % ord(d)
            print(valstr,)
            pos += len(valstr)+1
            if pos > 80:
                print()
                pos = 0
        print("};")

        print("#ifdef __cplusplus")
        print("}")
        print("#endif")
        print("")
    with stdout_to_file(fname_base+'.h'):
        print(autogen_comment)
        print("#ifdef __cplusplus")
        print("extern \"C\" {")
        print("#endif")
        print("")
        print("extern char {}[];".format( var_name ))
        print("const long long {}Size={};".format( var_name, len(data) ))
        print("")
        print("#ifdef __cplusplus")
        print("}")
        print("#endif")

