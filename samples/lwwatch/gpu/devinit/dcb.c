//*****************************************************
//
// lwwatch WinDbg Extension
// dcb.c
//
//*****************************************************

/******************************** DCBCHK ***********************************\
*                                                                           *
* Module: dcb.c                                                             *
*   This file is autogenerated from *.c files inside                        *
*   //sw/main/bios/Utils/dcbchk/<*>.c                                       *
*                                                                           *
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!     *
* DO NOT UPDATE THIS FILE AT ALL.  YOU NEED TO UPDATE THE CORRESPONDING     *
* FILES IN THE DIRECTORY MENTIONED ABOVE TO MAKE MODIFICATIONS TO THIS      *
* FILE.  To create this file from the ones above, please see updating       *
* DCBCHK on the DCB Wiki page.                                              *
*                                                                           *
* Written by Steve Rogers (srogers@lwpu.com)                              *
* Let me know if you have any questions/comments/suggestions.               *
* If you want me to update the files above, just let me know.               *
*                                                                           *
\***************************************************************************/

//
// includes
//
#include "os.h"
#include "dcb.h"
#include "inst.h"
#include "os.h"
#include "print.h"
#include "chip.h"



/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2002-2022 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

/******************************** DCBChecker *******************************\
*                                                                           *
* Module: dcbtest.c                                                        *
* This module handles all generic test routines for all DCB versions.       *
*                                                                           *
* Written by Steve Rogers (srogers@lwpu.com)                              *
* Let me know if you have any questions/comments/suggestions.               *
*                                                                           *
\***************************************************************************/

#ifdef SEPARATE_COMP // Not used in LWwatch compile
#if !defined(LW_MAC_KEXT)
#include <stdio.h>
#include <stdlib.h>
#endif //!defined(LW_MAC_KEXT)
#include <string.h>

#include "dcbchk.h"
#endif //SEPARATE_COMP


void CheckTypeAndDSI(PGV pgv)
{
  LwU32 i = 0;
  LwU32 Type = 0;
  LwU32 dsi = 0;
  LwU32 InternalLink;
  LwU32 AllSkipEntries = 1;

  for(i=0; i<pgv->DCBEntryCount; i++)
  {
    Type = pgv->gIP.GetType(pgv, i);
    dsi = getDSI_2x(pgv, i);

    // DCB 3.0 has Skip Entries
    if(Type == TYPE_SKIP)
      continue;

    // if this is EOL on DCB 4.0, then go ahead and update the
    // the entry count and get out of this function.
    if( (pgv->DCBVersion >= 0x40) &&
        (pgv->gIP.GetType(pgv, i) == TYPE_EOL) )
    {
      pgv->DCBEntryCount = i;
      break;
    }

    AllSkipEntries = 0;

    switch(Type)
    {
      case TYPE_CRT:
        if( (pgv->DCBVersion < 0x40) &&
           !(pgv->gIP.GetCRTMaxFreq(pgv, i)) )
        {
          dprintf("ERROR: DCB Entry %2d: Max CRT Frequency is 0!\n", i);
          pgv->exitValue = 5;
          ErrorCountCheck(pgv);
        }
        break;

      case TYPE_TV:
        if(pgv->gIP.GetTVFamily(pgv, i) > 3)
        {
          dprintf("ERROR: DCB Entry %2d: Unknown TV Encoder Type:%d\n", i, (dsi&0xF));
          pgv->exitValue = 5;
          ErrorCountCheck(pgv);
        }


        {
          LwU32 TVDACs = pgv->gIP.GetTVDACs(pgv, i);

          if(!TVDACs)
          {
            if(pgv->Device < 0x30)
            {
              dprintf("NOTE:  DCB Entry %2d: TV DACs have no R, G, B or HD bits set.\n", i);
              dprintf("       Legacy code determines output connector types.\n");
            }
            else
            {
              dprintf("ERROR: DCB Entry %2d: TV DACs have no R, G, B or HD bits set.\n", i);
              dprintf("       LW3X+ chips should not use legacy code for output connector types.\n");
              pgv->exitValue = 5;
              ErrorCountCheck(pgv);
            }
          }

          if (pgv->DCBVersion >= 0x40)
          {
              if ( (TVDACs == 0x02) ||
                   (TVDACs == 0x03) ||
                   (TVDACs == 0x07) ||
                   (TVDACs == 0x08) ||
                   (TVDACs == 0x0D) ||
                   (TVDACs >= 0x12) )
              {
                  // These are allowed on DCB 4.x
              }
              else
              {
                  dprintf("ERROR: DCB Entry %2d: TV DACs is 0x%02x.  This value is not supported\n", i, TVDACs);
                  dprintf("       in this VBIOS.\n");
                  pgv->exitValue = 5;
                  ErrorCountCheck(pgv);
              }
          }
        }

        // TV model feild should be 0 on pgv->DCBVersions < 2.4
        switch(pgv->DCBVersion)
        {
          case 0x20:
          case 0x21:
          case 0x22:
          case 0x23:
            if(getTVModel_2x(pgv, i))
            {
              dprintf("ERROR: DCB Entry %2d: TV Model Number is %d but DCB revision is 0x%x. Need revision 0x24\n",
                     i, getTVModel_2x(pgv, i), pgv->DCBVersion);
              pgv->exitValue = 5;
              ErrorCountCheck(pgv);
            }
            break;
        }
        break;

      case TYPE_TMDS:
      case TYPE_LVDS:
      case TYPE_SDI:
      case TYPE_DP:
        InternalLink = (pgv->gIP.GetLocation(pgv, i) == LOCATION_CHIP);

        if(pgv->gIP.GetLCDDDC(pgv, i) > 2)
        {
          dprintf("ERROR: DCB Entry %2d: Unknown LCD EDID Source:%d\n",
                  i, pgv->gIP.GetLCDDDC(pgv, i));
          pgv->exitValue = 5;
          ErrorCountCheck(pgv);
        }

        if(pgv->gIP.GetLCDControl(pgv, i) > 2)
        {
          dprintf("ERROR: DCB Entry %2d: Unknown LCD PowerBacklightControl:%d\n",
                  i, pgv->gIP.GetLCDControl(pgv, i));
          pgv->exitValue = 5;
          ErrorCountCheck(pgv);
        }

        // For DCB version 2.2 or higher, ext chip can be more than zero
        // for external links.
        if(!(InternalLink) &&
            (pgv->DCBVersion >= 0x22) )
        {
          // Here we've got to make sure that the MIO Ports are correctly selected
          LwU32 OutputDevices = pgv->gIP.GetOutput(pgv, i);
          LwU32 ExtLinkType   = pgv->gIP.GetLCDExtType(pgv, i);

          // Is this a dual external chip setup?
          if(ExtLinkType == 0x3)
          {
            // Only Crush 18 and LW30+ have the ability to do dual external TMDS mode
            if( (pgv->Device < 0x30) &&
                (pgv->Device != 0x1F) )
            {
              dprintf("ERROR: DCB Entry %2d: DSI LCD ExtChip is dual link. Not supported on LW%X\n", i, pgv->Device);
              pgv->exitValue = 5;
              ErrorCountCheck(pgv);
            }
            else if( (pgv->Device != 0x30) &&
                     (pgv->Device != 0x35) &&
                     (pgv->Device != 0x40) &&
                     (pgv->Device != 0x41) &&
                     (pgv->Device != 0x45) &&
                     (pgv->Device != 0x47) &&
                     (pgv->Device != 0x49) &&
                     (pgv->Device != 0x49) )
            {
                // On Crush 18, LW31, and LW34, we must have 2 MIO ports listed to do
                // dual link external TMDS mode.  LW30, 35, 40, 41, 45, and 47 use only 1 port.
                // Check for only 1 output device
                if(!(OutputDevices & (OutputDevices - 1)))
                {
                  dprintf("ERROR: DCB Entry %2d: DSI LCD ExtChip is dual link and multiple MIOs not listed\n", i);
                  dprintf("       LW%X needs 2 MIOs for dual ext. TMDS Mode. ExtChip: %d,  MIO Ports: %d\n",
                      pgv->Device, (dsi&0xF0)>>4, OutputDevices);
                  pgv->exitValue = 5;
                  ErrorCountCheck(pgv);
                }
            }


          }
          else
          {
            // Since it's not dual link, make sure that the OutputDevices only lists one device
            if(OutputDevices & (OutputDevices - 1))
            {
              dprintf("ERROR: DCB Entry %2d: DSI LCD ExtChip is single link and multiple MIOs listed\n", i);
              dprintf("       ExtChip: %d,  MIO Ports: %d\n", (dsi&0xF0)>>4, OutputDevices);
              pgv->exitValue = 5;
              ErrorCountCheck(pgv);
            }
          }

          // Is this a SI 168/178 or dual 168/178?
          switch(ExtLinkType)
          {
            case 0x2:
            case 0x3:
              // Board Apps has made the promise that all SI chips on graphics cards
              // will use I2C Port C (Cr50/51) for communication channel.
              // On Crush riser cards, only one I2C channel is available for DDC and
              // the external SI Chips.  So, this check should not be run for Crush.
              if( (pgv->Device != 0x1A) &&
                  (pgv->Device != 0x1F) )
              {
                // check to make sure I2C Port C is list number 2
                if( (pgv->gIP.GetI2CAccess(pgv, 2) != 0) ||
                    (GetI2CCRTCReadPort(pgv, 2) != 0x50) ||
                    (GetI2CCRTCWritePort(pgv, 2) != 0x51) )
                {
                  dprintf("ERROR: DCB Entry %2d: SI 168/178 device requires ICB #2 set to I2C_C (Cr50/51).\n", i);
                  dprintf("       Current ICB Entry 2: Access:%d  ", pgv->gIP.GetI2CAccess(pgv, 2));
                  pgv->exitValue = 5;
                  ErrorCountCheck(pgv);
                  switch(pgv->gIP.GetI2CAccess(pgv, 2))
                  {
                    case 0:  dprintf("Read Port:0x%x  Write Port:0x%x\n",
                                               GetI2CCRTCReadPort(pgv, 2),
                                               GetI2CCRTCWritePort(pgv, 2));          break;
                    case 3:  dprintf("PCI IO mapping: Need to parse this out ....\n"); break;
                    default: dprintf("Unknown I2C Access Method.\n");                  break;
                  }
                }
              }
              break;
          }
        }
        else
        {
            if(pgv->gIP.GetLCDExtType(pgv, i))
            {
                // If External Link is set for Onsemi NB7NQ621M_1 or NB7NQ621M_2, then bypass check below
                // Bug 3405026- DCHCHK - Allow LOC_CHIP when ExtLInk is ONSEMI NB7QN621M
                // Bug 3331049 - Tegra234/LwDisplay/DCB Add DP Serializer" External Link Type
                if ( ( pgv->gIP.GetLCDExtType(pgv, i) != 0x10 ) && ( pgv->gIP.GetLCDExtType(pgv, i) != 0x11 ) && ( pgv->gIP.GetLCDExtType(pgv, i) != 0x0F ) )
                {
                    if(InternalLink)
                    {
                        dprintf("ERROR: DCB Entry %2d: Internal Links DSI ExtChip field must be 0. Current:%d\n",
                                i, pgv->gIP.GetLCDExtType(pgv, i));
                        pgv->exitValue = 5;
                        ErrorCountCheck(pgv);
                    }
                    else
                    {
                        dprintf("ERROR: DCB Entry %2d: Only DCB 2.2+ can define DSI ExtChip field. Current:%d\n",
                                i, pgv->gIP.GetLCDExtType(pgv, i));
                        pgv->exitValue = 5;
                        ErrorCountCheck(pgv);
                    }
                }
            }
        }

        if( (pgv->gIP.GetLCDDDC(pgv, i) == 1) &&
            (Type != TYPE_DP) )
        {
          if(pgv->gIP.GetI2CPort(pgv, i) != 0xF)
          {
            dprintf("ERROR: DCB Entry %2d: Flat Panel EDID source set to Straps and I2CPort = 0x%x\n", i, pgv->gIP.GetI2CPort(pgv, i));
            if(pgv->DCBVersion < 0x30)
              dprintf("       I2CPort must be 0xF when using Straps.\n");
            else
              dprintf("       DDCPort must be 0xF when using Straps.\n");
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }
        }

        if( (pgv->DCBVersion >= 0x40) &&
            (pgv->gIP.GetLCDDDC(pgv, i) == 2) &&
            (Type != TYPE_DP) )
        {
          if(pgv->gIP.GetI2CPort(pgv, i) != 0xF)
          {
            dprintf("ERROR: DCB Entry %2d: Flat Panel EDID source set to SBIOS and DDCPort = 0x%x\n", i, pgv->gIP.GetI2CPort(pgv, i));
            dprintf("       DDCPort must be 0xF when EDID source is SBIOS.\n");
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }
        }

        // Sublinks only available on DCB 4.0
        if(pgv->DCBVersion >= 0x40)
        {
          if(InternalLink)
          {
            LwU32 sublinks = getDFPSubLinks_4x(pgv, i);

            if(!sublinks)
            {
              dprintf("ERROR: DCB Entry %2d: Flat Panel SubLinks set to 0!\n", i);
              dprintf("       At least one Sublink must be present here!\n");
              pgv->exitValue = 5;
              ErrorCountCheck(pgv);
            }
          }
        }

        if ( (Type == TYPE_DP) &&
             (InternalLink) )
        {
            switch(pgv->Device)
            {
                case 0x80:
                case 0x82:
                case 0x84:
                case 0x86:
                case 0x88:
                case 0x92:
                case 0xA0:
                  dprintf("ERROR: DCB Entry %2d: No Internal DP on this GPU\n", i);
                  pgv->exitValue = 5;
                  ErrorCountCheck(pgv);
                  break;
                default:
                  // Default to no problem since DP support will become the standard
                  break;
            }
        }

        break;
      case TYPE_SDVO:
        break;
      case TYPE_WBD:
        break;
      default:
        dprintf("ERROR: DCB Entry %2d: Unknown Type:0x%x\n", i, Type);
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
        break;
    }
  }

  if(AllSkipEntries)
  {
    // Make note of this and set the DCBEntryCount to 0
    pgv->DCBEntryCount = 0;
  }
}

void CheckI2CPort(PGV pgv)
{
  LwU32 i = 0;

  // Skip these checks if MXM Default DCB - bug 793163
  if ((pgv->bit.MXMConfigFlags0 & 0xC) != 0xC)
  {
    for(i=0; i<pgv->DCBEntryCount; i++)
    {
      LwU32 I2CPort = pgv->gIP.GetI2CPort(pgv, i);
      LwU32 Type = pgv->gIP.GetType(pgv, i);
      LwU32 I2CAccess = pgv->gIP.GetI2CAccess(pgv, I2CPort);
      LwU8 I2LWnused = 0;
      LwU8 CCBUnused = 0;
      LwU32 portSpeed = GetCCBI2CPortSpeed(pgv, I2CPort);

      // DCB 3.0 has Skip Entries
      if(Type == TYPE_SKIP)
        continue;

      // Check on DCB 40 for I2C access 5 or 6 (bug 724573)
      // Also check on DCB 41+ for valid i2c/aux ports
      if(pgv->DCBVersion == 0x40)
      {
        CCBUnused = ((I2CAccess != 0x5) && (I2CAccess != 0x6));
      }
      else if(pgv->DCBVersion >= 0x41)
      {
        //.Bug 1577267 - DDC I2C ports should be capped at 100kHz
        I2LWnused = (GetCCBI2CPort(pgv, I2CPort) == 0x1F);
        if((I2CPort != 15) && (I2LWnused == 0))
        {
         if((portSpeed > 1) && (Type < 0x7)){
            dprintf("ERROR: DCB Display Devices entry #%2d I2C Speed is set to 0x%d, it should be 0x1.\n", i, portSpeed);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
           }
        }
        CCBUnused = ((GetCCBI2CPort(pgv, I2CPort) == 0x1F) && (GetCCBDPPort(pgv, I2CPort) == 0x1F));
     }

      // 15 signifies an unused I2C Port
      if((I2CPort == 15) || (CCBUnused))
      {
        if ((pgv->DCBVersion >=0x40) &&
            (getVirtualDevice_4x(pgv, i)) &&
            (I2CPort == 15) )
        {
          // allow EDID port == 15 - bug 751997
        }
        else
        {
          switch(Type)
          {
            case TYPE_TMDS:
            case TYPE_LVDS:
            case TYPE_SDI:
            case TYPE_DP:
              // No need to test internally generated EDID source values
              if(pgv->DCBVersion < 0x20)
                break;

              if(pgv->gIP.GetLCDDDC(pgv, i) == 0)
              {
                dprintf("ERROR: DCB Entry %2d: I2C Port %d is UNUSED and the flat panel DSI indicates that we should read EDIDs.\n", i, I2CPort);
                pgv->exitValue = 5;
                ErrorCountCheck(pgv);
              }

              break;
            case TYPE_CRT:
              dprintf("ERROR: DCB Entry %2d: CRT's I2C Port %d is either UNUSED or SKIP_ENTRY!\n", i, I2CPort);
              pgv->exitValue = 5;
              ErrorCountCheck(pgv);
              break;
            // TVs are OK to have NO I2C Port
          }
        }
      }
      else if(I2CPort > pgv->I2CEntryCount)
      {
        dprintf("ERROR: DCB Entry %2d: I2C Port%d is not defined in I2C Control Block.\n", i, I2CPort);
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }

      // Only do this check for DCB 3.0.
      // For DCB 4.0, apple will start using DCBCHK for EFI roms.  They actually
      // have TV's with DDC ports.  So, we need to allow them here.
      if(pgv->DCBVersion == 0x30)
      {
        if(Type == TYPE_TV)
        {
          if(I2CPort != 15)
          {
            // Probably need to implement some better checking for this in connector table checks.
            dprintf("ERROR: DCB Entry %2d: DDC Port%x is defined for TV.\n", i, I2CPort);
            dprintf("       Please make sure this TV provides DDC based EDID support.\n");
          }
        }
      }

#ifdef INTERNAL
      // check against BMP numbers
      if(pgv->DCBVersion < 0x20)
      {
        switch(Type)
        {
          case TYPE_CRT:
            if(pgv->bmp.CRTI2CPort != I2CPort)
            {
              dprintf("ERROR: DCB Entry %2d: I2C Port%d != BMP CRTC I2C Port%d!\n",
                     i, I2CPort, pgv->bmp.CRTI2CPort);
              pgv->exitValue = 5;
              ErrorCountCheck(pgv);
            }
            break;
          case TYPE_TV:
            if(pgv->bmp.TVI2CPort != I2CPort)
            {
              dprintf("ERROR: DCB Entry %2d: I2C Port%d != BMP TV I2C Port%d!\n",
                     i, I2CPort, pgv->bmp.TVI2CPort);
              pgv->exitValue = 5;
              ErrorCountCheck(pgv);
            }
            break;
          case TYPE_TMDS:
          case TYPE_LVDS:
          case TYPE_SDI:
          case TYPE_DP:
            if(pgv->bmp.DFPI2CPort != I2CPort)
            {
              dprintf("ERROR: DCB Entry %2d: I2C Port%d != BMP Dpgv->FP I2C Port%d!\n",
                     i, I2CPort, pgv->bmp.DFPI2CPort);
              pgv->exitValue = 5;
              ErrorCountCheck(pgv);
            }
            break;
        }
      }
#endif // Internal

    }
  }

  if(pgv->DCBVersion >= 0x40)
  {
    for(i=0; i<pgv->I2CEntryCount; i++)
    {
      switch(pgv->gIP.GetI2CAccess(pgv, i))
      {
        case 5:
          if (GetI2CPMGRPortHybridPad_4x(pgv, i))
          {
              if (pgv->Device < 0xA4)
              {
                dprintf("ERROR: CCB Entry %2d: Hybrid Pad is not supported on this GPU!\n",
                        i);
                pgv->exitValue = 5;
                ErrorCountCheck(pgv);
              }
              // Next test is for GT21x only
              else if ( (pgv->Device >= 0xA4) &&
                        (pgv->Device <= 0xA7) )
              {
                // Make sure the Hybrid DPAux Port matches the correctly I2C Port
                // I2C Port 6 == DPAux 0
                // I2C Port 7 == DPAux 1
                // I2C Port 8 == DPAux 2
                // I2C Port 9 == DPAux 3
                if (GetI2CPMGRPortDPPort_4x(pgv, i) !=
                    (GetI2CPMGRPhysicalPort(pgv,i)-6))
                {
                  dprintf("ERROR: CCB Entry %2d: I2C Physical DP Aux Port does not match required port for this GPU!\n",
                          i);
                  pgv->exitValue = 5;
                  ErrorCountCheck(pgv);
                }
              }
          }
          break;
        case 6:
          if (GetCommDpAuxHybridPad_4x(pgv, i) &&
              (pgv->Device < 0xA4))
          {
            dprintf("ERROR: CCB Entry %2d: Hybrid Pad is not supported on this GPU!\n",
                    i);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }
          // Next test is for GT21x only
          else if ( (pgv->Device >= 0xA4) &&
                    (pgv->Device <= 0xA7) )
          {
            // Make sure the Hybrid DPAux Port matches the correctly I2C Port
            // I2C Port 6 == DPAux 0
            // I2C Port 7 == DPAux 1
            // I2C Port 8 == DPAux 2
            // I2C Port 9 == DPAux 3
            if (GetDPPMGRPortI2CPort_4x(pgv, i) !=
                (GetCommDpAuxPhysicalPort(pgv,i)+6))
            {
              dprintf("ERROR: CCB Entry %2d: DP's Physical I2C Port does not match required port for this GPU!\n",
                      i);
              //pgv->exitValue = 5;
              //ErrorCountCheck(pgv);
            }
          }
          break;
        default:
          break;
      }
    }
  }
}

void CheckHeadBitmask(PGV pgv)
{
  LwU32 i = 0;

  for(i=0; i<pgv->DCBEntryCount; i++)
  {
    LwU32 HeadBitmask = pgv->gIP.GetHeadMask(pgv, i);
    LwU32 Type = pgv->gIP.GetType(pgv, i);

    // DCB 3.0 has Skip Entries
    if(Type == TYPE_SKIP)
      continue;

    if(HeadBitmask == 0)
    {
      dprintf("ERROR: DCB Entry %2d: Head Bitmask is 0. At least one head needs to be set.\n", i);
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
    // Need to update this for GF11x when we know how many heads it will support
    else if( (HeadBitmask > 3) &&
             (pgv->Device < 0xB8) )
    {
      dprintf("ERROR: DCB Entry %2d: Head Bitmask is 0x%x. LW Archtectures lwrrently only have 2 heads.\n", i, HeadBitmask);
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }

    if(pgv->Device == 0x34)
    {
      // Not TV and HeadBitmask has no Head A
      if( (Type != TYPE_TV) &&
         !(HeadBitmask & HEADMASK_A) )
      {
        dprintf("ERROR: DCB Entry %2d: Head Bitmask: 0x%x. FOS doesn't work if Head A\n", i, HeadBitmask);
        dprintf("       isn't supported. This is a performance problem for CRTs and Flat Panels.\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }
    }
  }  // end of for loop
}

void CheckBus(PGV pgv)
{
  LwU32 i = 0;

  for(i=0; i<pgv->DCBEntryCount; i++)
  {
    LwU32 Bus = pgv->gIP.GetBus(pgv, i);

    // DCB 3.0 has Skip Entries
    if(pgv->gIP.GetType(pgv, i) == TYPE_SKIP)
      continue;

    if(Bus > pgv->DCBEntryCount)
    {
      dprintf("ERROR: DCB Entry %2d: Bus %d is more than the number of DCB Entries.\n", i, Bus);
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
  }
}

void CheckLocation(PGV pgv)
{
  LwU32 i = 0;

  for(i=0; i<pgv->DCBEntryCount; i++)
  {
    LwU32 Location = pgv->gIP.GetLocation(pgv, i);
    LwU32 Type = pgv->gIP.GetType(pgv, i);

    // DCB 3.0 has Skip Entries
    if(Type == TYPE_SKIP)
      continue;

    if(Location > LOCATION_BOARD)
    {
      dprintf("ERROR: DCB Entry %2d: Unknown Location %d!\n", i, Location);
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }

    // Is this a TV?
    if(Type == TYPE_TV)
    {
      switch(pgv->gIP.GetTVFamily(pgv, i))
      {
        default:
          if(Location == LOCATION_CHIP)
          {
            dprintf("ERROR: DCB Entry %2d: Internal TV device is not listed as Lwpu/Zoran encoder!\n", i);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }
          break;
        case 3:
          if(Location == LOCATION_BOARD)
          {
            dprintf("ERROR: DCB Entry %2d: External TV device listed as Lwpu/Zoran encoder!\n", i);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }
          break;
      }

    }

  }
}

void CheckOutputDevices(PGV pgv)
{
  LwU32 i = 0;
  LwU32 j = 0;
  LwU32 gt21aSOR1DLDCBIndex = 0xffffffff;
  LwU32 gt21aSOR2DCBIndex   = 0xffffffff;

  char dfpORname[5];

  if (pgv->DCBVersion < 0x40)
  {
    strcpy(dfpORname, "SOR");
  }
  else
  {
    strcpy(dfpORname, "Pad");
  }


  for(i=0; i<pgv->DCBEntryCount; i++)
  {
    LwU32 Type = pgv->gIP.GetType(pgv, i);
    LwU32 Location = pgv->gIP.GetLocation(pgv, i);
    LwU32 OutputDevices = pgv->gIP.GetOutput(pgv, i);
    LwU32 HeadBitmask = 0;

    // DCB 3.0 has Skip Entries
    if(Type == TYPE_SKIP)
      continue;

    // No need to check this here
    if(Type == TYPE_SDVO)
      continue;

    if(OutputDevices == 0)
    {
      dprintf("ERROR: DCB Entry %2d: OutputDevices is 0! At least one bit must be set!\n", i);
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
      continue;
    }

    if(Location == LOCATION_CHIP)
    {
      switch(Type)
      {
        case TYPE_TMDS:
        case TYPE_LVDS:
        case TYPE_SDI:
        case TYPE_DP:
          // LW25, Crush, or LW28 doesn't have internal Links!
          if( (pgv->Device == 0x25) ||
              (pgv->Device == 0x1A) ||
              (pgv->Device == 0x1F) ||
              (pgv->Device == 0x28) )

          {
            dprintf("ERROR: DCB Entry %2d: OutDevs, Type, Location indicate we have internal links.\n", i);
            dprintf("       LW%X does not have internal links. OutDevs:0x%x  Type:%d  Location:%d\n",
                pgv->Device, OutputDevices, Type, Location);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
            continue;
          }

          HeadBitmask = pgv->gIP.GetHeadMask(pgv, i);

          // LW17 must use Link C only with Head B
          if( (pgv->Device == 0x17) &&
              (OutputDevices & OUTPUT_LINK_C) &&
              (HeadBitmask != HEADMASK_B) )
          {
            dprintf("ERROR: DCB Entry %2d: LW17 can only use Link C with Head B.\n", i);
            dprintf("     OutputDevices:0x%x  Type:%d  Location:%d  HeadBitmask:0x%x\n", OutputDevices, Type, Location, HeadBitmask);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
            continue;
          }

          // Check to make sure that we actually support the # of links in this chip!
          {
            LwU32 sorCheckPasses = 1;

            // Pre-LW41 chips have 3 links
            if( (pgv->Device <= 0x40) &&
                (OutputDevices >= BIT(3)) )
            {
              sorCheckPasses = 0;
            }

            // LW41+ have 4 links
            if( (pgv->Device > 0x40) &&
                (pgv->Device < 0x80) &&
                (OutputDevices >= BIT(4)) )
            {
              sorCheckPasses = 0;
            }

            // LW50->G92 have 2 internal SORs
            if( (pgv->Device >= 0x80) &&
                (pgv->Device <= 0x92) &&
                (OutputDevices >= BIT(2)) )
            {
              sorCheckPasses = 0;
            }

            // G94/96/98 have 4 internal SORs
            if( (pgv->Device >= 0x94) &&
                (pgv->Device <  0xA0) &&
                (OutputDevices >= BIT(4)) )
            {
              sorCheckPasses = 0;
            }


            // GT200/GT206/MCP79/A/B has 2 internal SORs
            if( (pgv->Device >= 0xA0) &&
                (pgv->Device <= 0xA3) &&
                (OutputDevices >= BIT(2)) )
            {
              sorCheckPasses = 0;
            }

            // GT21x has 4 internal SORs
            if( (pgv->Device >= 0xA4) &&
                (OutputDevices >= BIT(4)) )
            {
              sorCheckPasses = 0;
            }

            if (!sorCheckPasses)
            {
              if (pgv->Device < 0x80)
              {
                dprintf("ERROR: DCB Entry %2d: Unknown Output Links 0x%x!\n", i, OutputDevices);
              }
              else
              {
                dprintf("ERROR: DCB Entry %2d: Unknown %ss 0x%x!\n", i, dfpORname, OutputDevices);
              }
              pgv->exitValue = 5;
              ErrorCountCheck(pgv);
            }
          }

          if (pgv->DCBVersion < 0x40)
          {
            // Can't hook up Links A or B with Link C or D
            if( (OutputDevices & OUTPUT_LINK_AB) && (OutputDevices & OUTPUT_LINK_CD))
            {
              dprintf("ERROR: DCB Entry %2d: OutputDevices: Can't have Link A or B with Link C or D defined.\n", i);
              dprintf("     OutputDevices:0x%x\n", OutputDevices);
              pgv->exitValue = 5;
              ErrorCountCheck(pgv);
            }
          }
          else
          {
              // Can't hook up SOR X with SOR Y
              if(OutputDevices & (OutputDevices - 1))
              {
                // on GT21A, I see that we could allow SOR1/2 for dual link.  Yuck.
                if ( (pgv->Device   != 0xAA) ||
                     (OutputDevices != 0x6) )
                {
                  dprintf("ERROR: DCB Entry %2d: OutputDevices: Can't have multiple %ss defined.\n", i,dfpORname);
                  dprintf("     OutputDevices:0x%x\n", OutputDevices);
                  pgv->exitValue = 5;
                  ErrorCountCheck(pgv);
                }
              }

              // Also make sure that there's only one sublink defined
              // for SOR1 and SOR2 for GT21x
              // Don't need this check since we're already inside the else case above
              // if(pgv->DCBVersion >= 0x40)
              {
                LwU32 sublinks = getDFPSubLinks_4x(pgv, i);

                // Skip GT21A since we're going to check it separately
                if( (pgv->Device >= 0xA3) &&
                    (pgv->Device != 0xAA) &&
                    (pgv->Device <= 0xB0) &&
                    (OutputDevices & 0x6) &&
                    (sublinks > 1) )
                {
                  dprintf("ERROR: DCB Entry %2d: SOR%d only has 1 sublink!\n",
                          i, (OutputDevices&0x4)?2:1);
                  pgv->exitValue = 5;
                  ErrorCountCheck(pgv);
                }

                // Make sure that we log GT21A's use of Dual Link on SOR1
                if ( (pgv->Device == 0xAA) &&
                     (OutputDevices & 0x2) &&
                     (sublinks > 1) )
                {
                  gt21aSOR1DLDCBIndex = i;
                  if (gt21aSOR2DCBIndex != 0xFFFFFFFF)
                  {
                    dprintf("ERROR: DCB Entry %2d: SOR1 in Dual Link with SOR2 used in entry %2d!\n"
                            "       The GPU is not capable of this design.\n",
                            i, gt21aSOR2DCBIndex);
                    pgv->exitValue = 5;
                    ErrorCountCheck(pgv);
                  }
                }

                // Make sure that we log GT21A's use of Single or Dual Link on SOR2
                if ( (pgv->Device == 0xAA) &&
                     (OutputDevices & 0x4) )
                {
                  gt21aSOR2DCBIndex = i;

                  if (sublinks > 1)
                  {
                    dprintf("ERROR: DCB Entry %2d: SOR%d only has 1 sublink!\n",
                            i, (OutputDevices&0x4)?2:1);
                    pgv->exitValue = 5;
                    ErrorCountCheck(pgv);
                  }

                  if (gt21aSOR1DLDCBIndex != 0xFFFFFFFF)
                  {
                    dprintf("ERROR: DCB Entry %2d: SOR2 used with entry %2d with SOR1 in Dual Link!\n"
                            "       The GPU is not capable of this design.\n",
                            i, gt21aSOR1DLDCBIndex);
                    pgv->exitValue = 5;
                    ErrorCountCheck(pgv);
                  }
                }

              }

          }

          // Internal DP is not allowed lwrrently on SOR0
          // It will be allowed on GF11x+ and also
          // GF100, but GF100 will not productize SOR0 DP.
          // So, fail GF100 SOR 0 DP if we're on a production rom.
          // See the email inside bug 525214.
          //
          // dd.dd.00.xx.xx == simulation, emulation, or FPGA VBIOS
          // dd.dd.01.xx.xx == bringup VBIOS for real silicon (not given to Buildmeister yet)
          // dd.dd.02.xx.xx == first production release
          //
          // We lwrrently only fail on 00, but this bug was for GF100 version 01 roms.
          // So, allow those to assign DP to SOR0, but not anything past there.
          if ( (Type == TYPE_DP) &&
               (OutputDevices & 1) &&
               ( (pgv->Device < 0xB0) ||
                 ( (pgv->Device == 0xB0) &&
                   ((pgv->BiosVersion & 0x0000FF00)>=0x00000200) ) ) )
          {
            dprintf("ERROR: DCB Entry %2d: Internal DP isn't allowed on SOR0\n", i);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }

          // For any digital device on GT206/GT212->GT218, do not allow
          // SOR1/SOR2 to list Sublink B/DP_B.
          if ( (pgv->Device >= 0xA2) &&
               (pgv->Device <= 0xA8) &&
               (OutputDevices & 0x6) )
          {
            if (getDFPSubLinks_4x(pgv, i) & 0x2)
            {
              dprintf("ERROR: DCB Entry %2d: This GPU's SOR doesn't support Sublink B/DP_B.\n", i);
              pgv->exitValue = 5;
              ErrorCountCheck(pgv);
            }
          }
          // For any digital device on GT218, do not allow
          // SOR3 to list Sublink B/DP_B.
          if ( (pgv->Device == 0xA8) &&
               (OutputDevices & 0x8) )
          {
            if (getDFPSubLinks_4x(pgv, i) & 0x2)
            {
              dprintf("ERROR: DCB Entry %2d: This GPU's SOR doesn't support Sublink B/DP_B.\n", i);
              pgv->exitValue = 5;
              ErrorCountCheck(pgv);
            }
          }

          break;
        case TYPE_CRT:
        case TYPE_TV:
          // Check to make sure that we actually support the # of DACs in this chip!
          // Pre-LW41 chips have 2 DACs
          // LW41+ have 3 DACs
          if( ( (pgv->Device <= 0x40) &&
                (OutputDevices >= BIT(2)) ) ||
              ( (pgv->Device > 0x40) &&
                (OutputDevices >= BIT(3)) ) )
          {
            dprintf("ERROR: DCB Entry %2d: Unknown Output DACs 0x%x!\n", i, OutputDevices);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }

          // GT206/GT21x only has DAC 0 and DAC 1
          if ( (pgv->Device >= 0xA2) &&
               (pgv->Device <= 0xA8) &&
               (OutputDevices >= BIT(2)) )
          {
            dprintf("ERROR: DCB Entry %2d: Unknown Output DACs 0x%x!\n", i, OutputDevices);
            // Disabling this output for now since there's too many errors to stop the build.
            //pgv->exitValue = 5;
            //ErrorCountCheck(pgv);
          }

          // GT21A doesn't have DAC 0
          if ( (pgv->Device == 0xAA) &&
               (OutputDevices == BIT(0)) )
          {
             dprintf("ERROR: DCB Entry %2d: Unknown Output DACs 0x%x!\n", i, OutputDevices);
             pgv->exitValue = 5;
             ErrorCountCheck(pgv);
          }

          // GK104+ doesn't have DAC 2 - bug 721863
          if ( (pgv->Device >= 0xC8) &&
               (OutputDevices >= BIT(2)) )
          {
             dprintf("ERROR: DCB Entry %2d: Unknown Output DACs 0x%x!\n", i, OutputDevices);
             pgv->exitValue = 5;
             ErrorCountCheck(pgv);
          }

          // We can only use one dac at a time
          if(OutputDevices & (OutputDevices-1))
          {
            dprintf("ERROR: DCB Entry %2d: OutputDevices: Only use one dac at a time.\n", i);
            dprintf("     OutputDevices:0x%x\n", OutputDevices);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }

          // Check to make sure that we have an internal TV on this chip
          if( (Type == TYPE_TV) &&
              ( (pgv->Device == 0x25) || (pgv->Device == 0x28) ) )
          {
            dprintf("ERROR: DCB Entry %2d: No internal TV on LW%X.\n", i, pgv->Device);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }

          if( (pgv->Device == 0x41) ||
              (pgv->Device == 0x43) ||
              (pgv->Device == 0x47) ||
              (pgv->Device == 0x49) )
          {
            // LW41 DAC B will only be used for TV
            // LW41 DAC A and C will only be used for CRT
            if( (Type == TYPE_CRT) &&
                (OutputDevices & OUTPUT_DAC_B) )
            {
              dprintf("ERROR: DCB Entry %2d: LW41+ chips must only use DAC A or C for CRTs!\n", i);
              pgv->exitValue = 5;
              ErrorCountCheck(pgv);
            }

            if( (Type == TYPE_TV) &&
                (OutputDevices & (OUTPUT_DAC_A|OUTPUT_DAC_C)) )
            {
              dprintf("ERROR: DCB Entry %2d: LW41+ chips must only use DAC B for TVs!\n", i);
              pgv->exitValue = 5;
              ErrorCountCheck(pgv);
            }

          }
          break;
      }

    }
    else if(Location == LOCATION_BOARD)
    {
      // We're an external device
      if(OutputDevices >= BIT(2))
      {
        dprintf("ERROR: DCB Entry %2d: Unknown Output MIOs 0x%x!\n", i, OutputDevices);
        dprintf("     OutputDevices:0x%x\n", OutputDevices);
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }

      if( (pgv->Device == 0x17) &&
          (OutputDevices > OUTPUT_MIO_A) )
      {
        dprintf("ERROR: DCB Entry %2d: OutputDevices, Type, and Location indicate we 2 MIO Ports.\n", i);
        dprintf("     LW17 has only one MIO Port.  OutputDevices:0x%x\n", OutputDevices);
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }

      if( (pgv->Device >= 0x17) &&
          (Type == TYPE_CRT) )
      {
        dprintf("ERROR: DCB Entry %2d: Type, and Location indicate we have an external DAC.\n", i);
        dprintf("         With LW17 or greater chips, we shouldn't need an external DAC since\n");
        dprintf("         there are 2 internal DACs already.\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }

      // Check to make sure that only one MIO Port is listed on devices that only handle one MIO port
      // Only Crush 18 and LW30+ have the ability to do dual external TMDS mode
      // And LW30 and LW35 use only one MIO Port for it.

      // XXXXX NEED To fill this out for all chips
      switch(pgv->Device)
      {
        case 0x1F:
        case 0x31:
        case 0x34:
        case 0x36:
          // OK to list dual MIO for these chips
          break;
        default:
          if(OutputDevices & (OutputDevices-1))
          {
            dprintf("ERROR: DCB Entry %2d: Dual MIO not supported on LW%X.  MIO Ports:%d\n",
                i, pgv->Device, OutputDevices);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }
          break;
      }

    }

    // Check all remaining devices to make sure we don't have 2 I2C ports
    // for one connector.
    for(j=i+1; j<pgv->DCBEntryCount; j++)
    {
      LwU32 jType = pgv->gIP.GetType(pgv, j);
      LwU32 jLocation = pgv->gIP.GetLocation(pgv, j);
      LwU32 jOutputDevices = pgv->gIP.GetOutput(pgv, j);
      LwU32 iPort = pgv->gIP.GetI2CPort(pgv, i);
      LwU32 jPort = pgv->gIP.GetI2CPort(pgv, j);

      // DCB 3.0 has Skip Entries
      if(jType == TYPE_SKIP)
        continue;

      // If this is the same device as the current one ...
      // (probably just a different head bitmask.)
      if((jType          == Type         ) &&
         (jLocation      == Location     ) &&
         (jPort          == iPort        ) &&
         (jOutputDevices == OutputDevices) )
      {
        if( (pgv->DCBVersion >= 0x40) &&
            (Type == TYPE_TMDS) &&
            (getDFPSubLinks_4x(pgv, j) != getDFPSubLinks_4x(pgv, i)) )
        {
          // DCB 4.0 placed DFP Sublinks outside of OutputDevices.  So, if those
          // are different, then there's no need to run this check.
        }
        else if(pgv->DCBVersion >= 0x30)
        {
          LwU32 iConnector, jConnector;
          iConnector = GetConnectorEntryType(pgv, getConnectorIndex_3x(pgv, i));
          jConnector = GetConnectorEntryType(pgv, getConnectorIndex_3x(pgv, j));

          switch (iConnector|(jConnector<<8))
          {
            case 0x5150:
            case 0x5350:
            case 0x5051:
            case 0x5251:
            case 0x5152:
            case 0x5352:
            case 0x5552:
            case 0x5053:
            case 0x5253:
            case 0x5453:
            case 0x5354:
            case 0x5255:
              // Allow 2 CRTs (either 15-pin or DVI-I) if one is one the dock and the other isn't
              // Allow 2 DFPs (either DVI-D or DVI-I) if one is one the dock and the other isn't
              break;
            default:
              // Caveat here requested by Arthur Chen.
              if ( (iConnector != jConnector) &&
                   (pgv->gIP.GetBus(pgv, i) == pgv->gIP.GetBus(pgv, j)) )
              {
                dprintf("NOTE: DCB Entry %2d: Same Type, Location, Output, and Bus as entry %d.\n"
                        "      One of these entries must be disabled at runtime.\n", i, j);
              }
              else
              {
                dprintf("ERROR: DCB Entry %2d: Same Type, Location, and Output as entry %d.\n"
                        "       Multiple Entries Not Allowed for DCB 3.x+\n", i, j);
                pgv->exitValue = 5;
                ErrorCountCheck(pgv);
              }
              break;
          }
        }
        else
        {
          if(iPort != jPort)
          {
            dprintf("ERROR: DCB Entry %2d: Same device as entry %d, but the I2C Ports are different.\n", i, j);
            dprintf("       I2CPort for Entry %d = %d.  I2CPort for Entry %d = %d.\n", i, iPort, j, jPort);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }
          else
          {
            dprintf("NOTE:  DCB Entry %2d and %2d: These entries are for the same device!\n", i, j);
          }
        }
      }
      // Also look for devices that share the same DDC Port. Though, the I2C
      // port wasn't really strictly defined as the DDC Port until DCB 3.0.
      else if( (iPort == jPort) &&
               (iPort != 0xF) && // Don't check if the DDC Port is unused
               (pgv->DCBVersion >= 0x30) )
      {
        char striType[5], strjType[5];
        LwU32 iConnector, jConnector;
        LwU32 CorrectPair = 0;
        iConnector = GetConnectorEntryType(pgv, getConnectorIndex_3x(pgv, i));
        jConnector = GetConnectorEntryType(pgv, getConnectorIndex_3x(pgv, j));

        switch(Type|(jType<<8))
        {
          // DVI Connector allows for CRT and TMDS to share the same I2C port
          case (TYPE_CRT|(TYPE_TMDS<<8)):
          case (TYPE_TMDS|(TYPE_CRT<<8)):
            CorrectPair = 1;
            break;
          // Apple DVI Connector allows for TV, CRT and TMDS to share the same I2C port
          case (TYPE_CRT|(TYPE_TV<<8)):
          case (TYPE_TV|(TYPE_CRT<<8)):
          case (TYPE_TV|(TYPE_TMDS<<8)):
          case (TYPE_TMDS|(TYPE_TV<<8)):
            if ( (iConnector == jConnector) &&
                 ( (iConnector == 0x20) ||
                   (iConnector == 0x21) ||
                   (iConnector == 0x22) ) )
            {
              // Allow DVI-I-TV-* to share connectors with CRT and TMDS if it's all the same connector
              CorrectPair = 1;
            }
            break;
          case (TYPE_CRT|(TYPE_CRT<<8)):
            // This combination is now only allowed if
            // we have one connector that is "if docked"
            // and the other as "if not docked"
            {
              switch (iConnector|(jConnector<<8))
              {
                case 0x5150:
                case 0x5350:
                case 0x5051:
                case 0x5251:
                case 0x5152:
                case 0x5352:
                case 0x5053:
                case 0x5253:
                  // Allow 2 CRTs (either 15-pin or DVI-I) if one is one the dock and the other isn't
                  CorrectPair = 1;
                  break;
                default:
                  break;
              }
            }
            break;
          case (TYPE_TMDS|(TYPE_TMDS<<8)):
            // This combination is now only allowed if
            // we have one connector that is "if docked"
            // and the other as "if not docked"
            {
              LwU32 k;

              switch (iConnector|(jConnector<<8))
              {
                case 0x5352:
                case 0x5552:
                case 0x5253:
                case 0x5453:
                case 0x5354:
                case 0x5554:
                case 0x5255:
                case 0x5455:
                  // Allow 2 TMDS (either DVI-I or DVI-D) if one is one the dock and the other isn't
                  CorrectPair = 1;
                  break;

                case 0x5561:
                case 0x6155:
                  // This is a special case for Arthur's Sony MS20 project
                  // The DVI-D is on the dock only.  But the HDMI connector can be plugged in
                  // simultaneously.  And they both share the same I2C port.  To do this,
                  // if the HDMI hotplug signal is set, then the I2C will be routed to HDMI.
                  // So, only allow these if each connector here has separate Hotplug Pins,
                  // which luckily MS20 project has separate Hotplug pins.
                  if ( (GetConnectorEntryHotplugA(pgv, getConnectorIndex_3x(pgv, i)) != GetConnectorEntryHotplugA(pgv, getConnectorIndex_3x(pgv, j)) ) &&
                       (GetConnectorEntryHotplugB(pgv, getConnectorIndex_3x(pgv, i)) != GetConnectorEntryHotplugB(pgv, getConnectorIndex_3x(pgv, j)) ) )
                  {
                    CorrectPair = 1;
                  }
                  break;

                case 0x6130:
                case 0x6131:
                case 0x3061:
                case 0x3161:
                  // This is a different special case for Arthur's Sony MS20 project
                  // Specifically, if we find a GPIO that allows for I2C Select and we're choosing between
                  // DVI-I/DVI-D and HDMI, then also allow this combo.
                  for (k = 0; k < pgv->GPIOEntryCount; k++)
                  {
                    LwU32 gpioFunc = GetGPIOFunction(pgv, k, pgv->GPIOEntryBase, pgv->GPIOEntrySize);

                    if (gpioFunc == 0x3E)
                    {
                      CorrectPair = 1;
                      break;
                    }
                  }
                  break;

                default:
                  break;
              }
            }
            break;
          case (TYPE_TMDS|(TYPE_DP<<8)):
          case (TYPE_DP|(TYPE_TMDS<<8)):
            // All DisplayPorts have the ability to add a dongle to create TMDS output.
            CorrectPair = 1;
            break;
          default:
            break;
        }

        if (!CorrectPair)
        {
          // Marvin requested that I disable this check if one device is ANX9805
          if ( (Location == LOCATION_BOARD) &&
               ( (Type == TYPE_DP) ||
                 (Type == TYPE_TMDS) ) &&
               ( (getExtEncoder_3x(pgv, i) == 0xD) ||
                 (getExtEncoder_3x(pgv, i) == 0xE) ) )
          {
            CorrectPair = 1;
          }
          else if ( (jLocation == LOCATION_BOARD) &&
                    ( (jType == TYPE_DP) ||
                      (jType == TYPE_TMDS) ) &&
                    ( (getExtEncoder_3x(pgv, j) == 0xD) ||
                      (getExtEncoder_3x(pgv, j) == 0xE) ) )
          {
            CorrectPair = 1;
          }
        }

        if (!(CorrectPair) &&
             (pgv->DCBVersion >= 0x40) &&
             (pgv->g4x.swout.EntryCount) )
        {
          // Next we need to check to see if there's a switched output table governing the I2C
          // port between these two entries.
          CorrectPair = CheckSharedDDCwithSwitchedOutputs_4x(pgv, i, j);
        }


        if(!CorrectPair)
        {
          switch(Type)
          {
            case TYPE_CRT:  sprintf(striType, "CRT");  break;
            case TYPE_TV:   sprintf(striType, "TV");   break;
            case TYPE_TMDS: sprintf(striType, "TMDS"); break;
            case TYPE_LVDS: sprintf(striType, "LVDS"); break;
            case TYPE_SDVO: sprintf(striType, "SDVO"); break;
            case TYPE_SDI:  sprintf(striType, "SDI");  break;
            case TYPE_DP:   sprintf(striType, "DP");   break;
            default: sprintf(striType, "?%d?", (int)Type);  break;
          }
          switch(jType)
          {
            case TYPE_CRT:  sprintf(strjType, "CRT");  break;
            case TYPE_TV:   sprintf(strjType, "TV");   break;
            case TYPE_TMDS: sprintf(strjType, "TMDS"); break;
            case TYPE_LVDS: sprintf(strjType, "LVDS"); break;
            case TYPE_SDVO: sprintf(strjType, "SDVO"); break;
            case TYPE_SDI:  sprintf(strjType, "SDI");  break;
            case TYPE_DP:   sprintf(strjType, "DP");   break;
            default: sprintf(strjType, "?%d?", (int)jType); break;
          }
          dprintf("ERROR: DCB Entry %2d: Same DDC Port as entry %d, but no valid connector exists\n", i, j);
          dprintf("       for this combination. Entry %d type:%s.  Entry %d type:%s.\n", i, striType, j, strjType);
          pgv->exitValue = 5;
          ErrorCountCheck(pgv);
        }
      }

      // For DCB 4.1 check that DP+TMDS display devices associated w/ the same connector use the same ccb entry
      if ( (pgv->DCBVersion >= 0x41) &&
           (iPort != jPort) &&
           (iPort != 0xF) &&
           (getConnectorIndex_3x(pgv, i) == getConnectorIndex_3x(pgv, j)) )
      {
        switch(Type|(jType<<8))
        {
          case (TYPE_TMDS|(TYPE_DP<<8)):
          case (TYPE_DP|(TYPE_TMDS<<8)):
            dprintf("ERROR: DCB Entry %2d: Same connector but different DDC Port as entry %2d\n", i, j);
            dprintf("       TMDS/DP entries sharing the same connector must use the same CCB entry.\n");
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
            break;
          default:
            break;
        }
      }

    }
  }
}

void CheckICB(PGV pgv)
{
  LwU32 i = 0;
  LwU32 PrimaryUsed = 0;
  LwU32 SecondaryUsed = 0;

  // Check DCB entries for external encoders (since they will use primary or secondary)
  if (pgv->DCBVersion >= 0x30)
  {
    // Run this area only if not-MXM Default DCB - bug 793163
    if ((pgv->bit.MXMConfigFlags0 & 0xC) != 0xC)
    {
      for(i=0; i<pgv->DCBEntryCount; i++)
      {
        LwU32 Type = pgv->gIP.GetType(pgv, i);
        LwU32 Location = pgv->gIP.GetLocation(pgv, i);

        // DCB 3.0 has Skip Entries
        if(Type == TYPE_SKIP)
          continue;

        if(Location != LOCATION_BOARD)
          continue;

        switch(getExtCCBPortIndex_3x(pgv, i))
        {
          case 0:
            PrimaryUsed = 1;
            break;
          case 1:
            SecondaryUsed = 1;
            break;
          default:
            break;
        }

        // Skip testing other entries if both are used
        if (PrimaryUsed && SecondaryUsed)
        {
          break;
        }
      }
    }

    // Check input devices if we needed
    if(!(PrimaryUsed && SecondaryUsed) )
    {
      // Skipping this since it doesn't seem I check anything with it anyway.
    }

    // Check external GPIO if needed
    if(!(PrimaryUsed && SecondaryUsed) )
    {
      LwU32 j, AllSkipEntries = 1;
      LwU32 k; // loop over all Specific Tables
      LwU32 spPointer, spHeaderSize, spEntryCount, spEntrySize;
      LwU32 spEntryBase, spComPort;

      if(!(pgv->g3x.extGpio.MasterPointer) ||
         !(pgv->g3x.extGpio.MasterEntryCount) )
      {
        // Don't check anything
      }
      else
      {
        for(k=0; k<pgv->g3x.extGpio.MasterEntryCount; k++)
        {
          pgv->LwrrentFileOffset = pgv->g3x.extGpio.MasterPointer +
                                   pgv->g3x.extGpio.MasterHeaderSize +
                                   k * pgv->g3x.extGpio.MasterEntrySize;
          spPointer = pgv->gIP.GetLwU16(pgv);

          // Skip 0 pointers
          if(!spPointer)
          {
            dprintf("External GPIO Assignment Table %d: Pointer is 0. Skipping.\n", k);
            continue;
          }

          pgv->LwrrentFileOffset = spPointer+1;
          spHeaderSize = pgv->gIP.GetLwU8(pgv);
          spEntryBase  = spPointer + spHeaderSize;
          spEntryCount = pgv->gIP.GetLwU8(pgv);
          spEntrySize  = pgv->gIP.GetLwU8(pgv);
          pgv->LwrrentFileOffset = spPointer+6;
          spComPort    = (pgv->gIP.GetLwU8(pgv) & 0x10) >> 4;

          if(!spEntryCount)
          {
            dprintf("External GPIO Assignment Table %d: 0 Entries\n", k);
            continue;
          }

          // Check for all skip entries
          for (j = 0; j < spEntryCount; j++)
          {
            if(GetGPIOFunction(pgv, j, spEntryBase, spEntrySize) != 0x0)
            {
              AllSkipEntries = 0;
              break;
            }
          }
          if(AllSkipEntries)
          {
            continue;
          }

          // So, this entry is being used.  check primary or secondary
          switch(spComPort)
          {
            case 0:
              PrimaryUsed = 1;
              break;
            case 1:
              SecondaryUsed = 1;
              break;
            default:
              break;
          }

          // Skip testing other entries if both are used
          if (PrimaryUsed && SecondaryUsed)
          {
            break;
          }
        } // end of loop over master entries.
      }

    }

    // I2C Devices
    if(!(PrimaryUsed && SecondaryUsed) )
    {
      LwU32 j;
      LwU32 AllSkipEntries = 1;

      // Check for all skip entries
      for(j=0; j<pgv->g3x.i2cdev.EntryCount; j++)
      {
        if(GetI2CDevicesEntryType(pgv, j) == 0xFF)
          continue;

        AllSkipEntries = 0;
        break;
      }
      if(AllSkipEntries)
      {
        // Don't do the loop check
      }
      else
      {
        for(j=0; j<pgv->g3x.i2cdev.EntryCount; j++)
        {
          // Look for skip entries
          if(GetI2CDevicesEntryType(pgv, j) == 0xFF)
          {
            continue;
          }
          switch(GetI2CDevicesEntryExtComPort(pgv, j))
          {
            case 0:
              PrimaryUsed = 1;
              break;
            case 1:
              SecondaryUsed = 1;
              break;
            default:
              break;
          }

          // Skip testing other entries if both are used
          if (PrimaryUsed && SecondaryUsed)
          {
            break;
          }
        } // end of loop over i2c devices
      }

    } // end of the I2C Devices check
  } // end of DCB 3.0 check

  for(i=0; i<pgv->I2CEntryCount; i++)
  {
    LwU32 Access = pgv->gIP.GetI2CAccess(pgv, i);

    // DCB 3.0 has Skip Entries
    if(Access == 0xFF)
    {
      // bug 550029
      if (PrimaryUsed &&
          (pgv->g3x.PrimaryPort == i))
      {

          dprintf("ERROR: CCB Entry %2d is set to Skip Entry, but this entry is used as the\n"
                  "       Primary Communications Port on at least one device.\n", i);
          pgv->exitValue = 5;
          ErrorCountCheck(pgv);
      }
      if (SecondaryUsed &&
          (pgv->g3x.SecondaryPort == i))
      {
          dprintf("ERROR: CCB Entry %2d is set to Skip Entry, but this entry is used as the\n"
                  "       Secondary Communications Port on at least one device.\n", i);
          pgv->exitValue = 5;
          ErrorCountCheck(pgv);
      }
      continue;
    }
    else if(Access == 0)
    {
      LwU32 ReadPort  = GetI2CCRTCReadPort(pgv, i);
      LwU32 WritePort = GetI2CCRTCWritePort(pgv, i);

      if( (ReadPort != 0x36) &&
          (ReadPort != 0x3E) &&
          (ReadPort != 0x50) )
      {
        dprintf("ERROR: ICB Entry %2d: Unknown CRTC Read Port Index 0x%x!\n", i, Access);
        dprintf("       Lwrrently only CRTC Indexes 0x36, 0x3E, and 0x50 are valid Read Ports.\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }

      if( (WritePort != 0x37) &&
          (WritePort != 0x3F) &&
          (WritePort != 0x51) )
      {
        dprintf("ERROR: ICB Entry %2d: Unknown CRTC Write Port Index 0x%x!\n", i, Access);
        dprintf("       Lwrrently only CRTC Indexes 0x37, 0x3F, and 0x51 are valid Write Ports.\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }
    }
    else if(Access == 3)
    {
      // PCI I/O Mapped checks?  Probably need to write some here.
    }
    else if(Access == 4)
    {
      LwU32 PhysPort = GetI2CMMPhysicalPort(pgv, i);
      // MM checks
      if(PhysPort > 2)
      {
        dprintf("ERROR: ICB Entry %2d: Unknown Memory Mapped Physical Port 0x%x!\n", i, PhysPort);
        dprintf("       Lwrrently only Physical Ports 0, 1, and 2 are valid.\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }
    }
    else if(Access == 5)
    {
      LwU32 PhysPort = GetI2CPMGRPhysicalPort(pgv, i);

      // MM checks
      // G94+ GPUs should have 6 physical I2C ports
      // GT21x+ GPUs should have 9 physical I2C ports
      // See https://gpuhwdept/index.php/GPU_Display/ExternalFAQ#I2C
      if( ( (pgv->Device < 0x94) && (PhysPort > 3) ) ||
          ( (pgv->Device >=0x94) && (pgv->Device < 0xA4) && (PhysPort > 5) ) ||
          ( (pgv->Device >=0xA4) && (PhysPort > 9) ) )
      {
        dprintf("ERROR: CCB Entry %2d: Unknown I2C Physical Port 0x%x!\n", i, PhysPort);
        dprintf("       Lwrrently only Physical Ports 0, 1, 2, 3 are valid.\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }

      if ( (PhysPort == 2) &&
           ( (pgv->Device == 0x84) ||
             (pgv->Device == 0x86) ||
             (pgv->Device == 0x92) ) )
      {
        // bug 286348: G84/86 shouldn't allow port 2
        if ( (pgv->Device == 0x84) ||
             (pgv->Device == 0x86) )
        {
          dprintf("ERROR: CCB Entry %2d: I2C Physical Port 0x%x not allowed on G%x!\n", i, PhysPort, pgv->Device);
          pgv->exitValue = 5;
          ErrorCountCheck(pgv);
        }
      }
    }
    else if(Access == 6)
    {
      LwU32 PhysPort = GetCommDpAuxPhysicalPort(pgv, i);
      // MM checks
      if(PhysPort > 3)
      {
        dprintf("ERROR: CCB Entry %2d: Unknown DP Physical Port 0x%x!\n", i, PhysPort);
        dprintf("       Lwrrently only Physical Ports 0, 1, 2, 3 are valid.\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }
    }
    else if(Access == 0x50)
    {
      LwU32 I2CPhysPort = GetCCBI2CPort(pgv, i);

      if(I2CPhysPort == 0x1F)
      {
        // bug 550029
        if (PrimaryUsed &&
            (pgv->g3x.PrimaryPort == i))
        {

            dprintf("ERROR: CCB Entry %2d is set to Skip Entry, but this entry is used as the\n"
                    "       Primary Communications Port on at least one device.\n", i);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
        }
        if (SecondaryUsed &&
            (pgv->g3x.SecondaryPort == i))
        {
            dprintf("ERROR: CCB Entry %2d is set to Skip Entry, but this entry is used as the\n"
                    "       Secondary Communications Port on at least one device.\n", i);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
        }
      }
      else
      {
        LwU32 portSpeed = GetCCBI2CPortSpeed(pgv, i);
        if( portSpeed > 8 ) {
            dprintf("ERROR: CCB Entry %2d has I2C index defined but has an invalid I2C Port Speed: %d\n", i, portSpeed);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
        }
      }
    }
    else
    {
      if (pgv->DCBVersion >= 0x40)
      {
        dprintf("ERROR: CCB Entry %2d: Unknown Access Method 0x%x!\n", i, Access);
      }
      else
      {
        dprintf("ERROR: ICB Entry %2d: Unknown Access Method 0x%x!\n", i, Access);
      }
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
  }

  // Make sure that if Primary is used, it is defined - bug 757634
  if ( (PrimaryUsed) &&
       (pgv->g3x.PrimaryPort >= pgv->I2CEntryCount) )
  {
    dprintf("ERROR: Primary Communications Port index %d is used on at least one device, \n"
            "       but there are only %d port(s) defined.\n", pgv->g3x.PrimaryPort, pgv->I2CEntryCount);

    // Reenable this error - bug 821706
    pgv->exitValue = 5;
    ErrorCountCheck(pgv);
  }

  // Make sure that if Secondary is used, it is defined - bug 757634
  if ( (SecondaryUsed) &&
       (pgv->g3x.SecondaryPort >= pgv->I2CEntryCount) )
  {
    dprintf("ERROR: Secondary Communications Port index %d is used on at least one device, \n"
            "       but there are only %d port(s) defined.\n", pgv->g3x.SecondaryPort, pgv->I2CEntryCount);
    pgv->exitValue = 5;
    ErrorCountCheck(pgv);
  }

}

void CheckGpioAssignments(PGV pgv)
{
  LwU32 i, j;
  LwU32 MaxGPIO = 9;
  LwU32 FoundDACBSwitchSupport = 0;
  LwU32 FoundStereoSupport = 0;
  LwU32 FoundThermalSupport = 0;
  LwU32 FoundHDTVSwitchSupport = 0;
  LwU32 FoundHDTVScartLoadDetSupport = 0;
  LwU32 FoundDisablePowerSense = 0;
  LwU32 FoundThermalPowerSense = 0;
  LwU32 FoundThermalGpioRequired = 0;
  LwU32 VSelBits = 0;
  LwU32 DCB2x = ( (pgv->DCBVersion >= 0x20) & (pgv->DCBVersion <  0x30) );

  char funcText[20];

  if( (pgv->GPIOHeaderPtr != 0x0) &&
      (pgv->GPIOEntryCount == 0x0)      &&
      (pgv->Device >= 0x30) )
  {
    dprintf("ERROR: GPIO Assignment table has 0 entries!\n");
    dprintf("       LW3X+ chips must list a GPIO Assignment table!\n");
    pgv->exitValue = 5;
    ErrorCountCheck(pgv);
  }

  // If we're using the default tables, return since we can't check the driver.
  if( (pgv->GPIOHeaderPtr == 0x0) ||
      ( (pgv->GPIOEntryCount == 0x0) &&
        (pgv->Device < 0x30) ) )
    return;

  // HW Monitor can add GPIOs to the list
  // This number will only be set on DCB 2.X versions
  // But check the version, just in case:
  if( (pgv->DCBVersion >= 0x20) &&
      (pgv->DCBVersion <  0x30) &&
      (pgv->g2x.DACBSwitch&0xF0) )
    MaxGPIO = 31;

  if( pgv->VBIOSCore >= Core94 )    // Assume core94+ represents GA10x+
    MaxGPIO = 39;
  else if( pgv->Device >= 0x92 )    // G92
    MaxGPIO = 31;
  else if( pgv->Device >= 0x80 )    // G80
    MaxGPIO = 15;
  else if( pgv->Device >= 0x40 )    // LW40
    MaxGPIO = 13;

  for (i = 0; i < pgv->GPIOEntryCount; i++)
  {
    LwU32 gpioNum     = GetGPIONumber(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
    LwU32 gpioFunc    = GetGPIOFunction(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);

    // DCB 3.0 has Skip Entries
    if( (gpioFunc == 0x3F) &&
        (pgv->DCBVersion >= 0x30) )
      continue;

    if (gpioNum > MaxGPIO)
    {
      dprintf("ERROR: %sGPIO assignment table entry %d uses unknown gpio number: %d.\n",
              (pgv->DCBVersion <  0x30)?"Misc: ":"", i, gpioNum);
      ErrorCountCheck(pgv);
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }

    // Look for multiple entries with same function or gpio;
    //
    for (j = i + 1; j < pgv->GPIOEntryCount; j++)
    {
      // DCB 3.0 has Skip Entries
      if( (GetGPIOFunction(pgv, j, pgv->GPIOEntryBase, pgv->GPIOEntrySize) == 0x3F) &&
          (pgv->DCBVersion >= 0x20) )
        continue;

      if (gpioNum == GetGPIONumber(pgv, j, pgv->GPIOEntryBase, pgv->GPIOEntrySize))
      {
        dprintf("ERROR: %sGPIO assignment table entry %d and %d both use gpio %d.\n",
                (pgv->DCBVersion <  0x30)?"Misc: ":"", i, j, gpioNum);
        ErrorCountCheck(pgv);
        pgv->exitValue = 5;
      }

      if (gpioFunc == GetGPIOFunction(pgv, j, pgv->GPIOEntryBase, pgv->GPIOEntrySize))
      {
        GpioFunctionText(gpioFunc, funcText);

        dprintf("ERROR: %sGPIO assignment table entry %d and %d both use function %s.\n",
                (pgv->DCBVersion <  0x30)?"Misc: ":"", i, j, funcText);
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }
    }

    switch(gpioFunc)
    {

      case 12:
        FoundDACBSwitchSupport += 1;
        if(DCB2x)
        {
          if (((pgv->g2x.DACBGPIO>>4)&0xF) != (LwU8) gpioNum)
          {
            dprintf("ERROR: Misc: DACB Select GPIO in GPIO table (%d) does not match legacy DCB (%d).\n",
              gpioNum, ((pgv->g2x.DACBGPIO>>4)&0xF));
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }

          if (((pgv->g2x.DACBSwitch>>1)&0x1) != (LwU8) GetGPIOOffData(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize))
          {
            dprintf("ERROR: Misc: DACB Select polarity in GPIO table does not match legacy DCB.\n");
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }

        }

        break;
      case 13:
        FoundDACBSwitchSupport += 1;
        if(DCB2x)
        {
          // Remove this if legacy support is removed....
          if ((pgv->g2x.DACBGPIO&0xF) != (LwU8) gpioNum)
          {
            dprintf("ERROR: Misc: DACB AltDetect GPIO in GPIO table (%d) doesn't match old DCB (%d).\n",
              gpioNum, (pgv->g2x.DACBGPIO&0xF));
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }
        }
        break;

      case 14: // intentional fall through
      case 15:
        if(DCB2x)
          FoundStereoSupport += 1;
        break;


      case 16: // intentional fall through
        FoundThermalPowerSense = 1;
      case 17:
        FoundThermalGpioRequired = 1;
        if(DCB2x)
          FoundThermalSupport += 1;
        break;

      case 33:
        // As requested by axchen
        if(!(GetGPIOPWM(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize)) )
        {
          dprintf("ERROR: %sGPIO Entry %d: LCD Brightness doesn't have PWM set!\n",
              (pgv->DCBVersion <  0x30)?"Misc: ":"", i);
          pgv->exitValue = 5;
          ErrorCountCheck(pgv);
        }
        break;

      // We need HDTV set if we intend to use the GPIO's for HDTV switching
      case 36:
          FoundHDTVSwitchSupport = 1;
          break;
      case 37:
          FoundHDTVScartLoadDetSupport = 1;
          break;

      // If these are defined, then we need to make sure
      // that the voltage table is defined for them.
      case 4:  VSelBits |= 0x1; break;
      case 5:  VSelBits |= 0x2; break;
      case 6:  VSelBits |= 0x4; break;
      case 26: VSelBits |= 0x8; break;

      // Need to note this:
      case 44: FoundDisablePowerSense = 1; break;
    }

  } // End of for loop on all GPIO table entries

  // Only need to do this check for DCB 2.X VBIOSes
  if(DCB2x)
  {
    if( (pgv->g2x.DACBSwitch&0x1) &&
        (FoundDACBSwitchSupport < 2) )
    {
      dprintf("ERROR: Misc: Old DACB Switch enabled, but not in GPIO assignment table.\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }

    if( (pgv->g2x.StereoGlasses&0x1) &&
        (FoundStereoSupport < 1) )
    {
      dprintf("NOTE: Misc: Old Stereo enabled, but not listed in GPIO assignment table.\n");
    }

    if( (FoundThermalSupport) &&
        (!(pgv->g2x.ThermalTypePort&0xF)) )
    {
      dprintf("NOTE: Misc: GPIO table has Thermal entry, but no Thermal Diode in Misc table.\n");
    }
  }


  if(FoundDACBSwitchSupport)
  {
    LwU32 DACBDeviceCount = 0;

    for(i=0; i<pgv->DCBEntryCount; i++)
    {
      if( (pgv->gIP.GetLocation(pgv, i) == LOCATION_CHIP) &&
          (pgv->gIP.GetOutput(pgv, i) == OUTPUT_DAC_B) )
      {
        if( (pgv->gIP.GetType(pgv, i) == TYPE_CRT) ||
            (pgv->gIP.GetType(pgv, i) == TYPE_TV) )
          DACBDeviceCount += 1;
      }
    }

    if (DACBDeviceCount != 2)
    {
      dprintf("ERROR: Misc: DACB Switch in GPIO Table, but there are %d DACB device(s) listed!\n", DACBDeviceCount);
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }

  }


  if(FoundHDTVSwitchSupport)
  {
    LwU32 FoundHDTV = 0;

    for(i=0; i<pgv->DCBEntryCount; i++)
    {
      if(pgv->gIP.GetType(pgv, i) == TYPE_TV)
      {
          switch(pgv->gIP.GetTVDACs(pgv, i))
          {
            case 0x08:
            case 0x09:
            case 0x0B:
            case 0x0C:
            case 0x0D:
            case 0x0F:
            case 0x10:
              FoundHDTV = 1;
              break;
            default:
              break;
          }
      }

      if (FoundHDTV)
      {
        break;
      }
    }

    if(!FoundHDTV)
    {
      dprintf("ERROR: Misc: GPIO table has HDTV Switch entry(s), but no HDTV DCB Entry!\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
  }

  if(FoundHDTVScartLoadDetSupport)
  {
    LwU32 FoundHDTVScart = 0;

    for(i=0; i<pgv->DCBEntryCount; i++)
    {
      if(pgv->gIP.GetType(pgv, i) == TYPE_TV)
      {
          switch(pgv->gIP.GetTVDACs(pgv, i))
          {
            case 0x08:
            case 0x09:
            case 0x0A:
            case 0x0B:
            case 0x0C:
            case 0x0D:
            case 0x0E:
            case 0x0F:
            case 0x10:
              FoundHDTVScart = 1;
              break;
            default:
              break;
          }
      }

      if (FoundHDTVScart)
      {
        break;
      }
    }

    if(!FoundHDTVScart)
    {
      dprintf("ERROR: Misc: GPIO table has HDTV/Scart AltDet entry(s), but no HDTV/SCART DCB Entry!\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
  }


  if(VSelBits)
  {
    // check to make sure that there are no holes in the definition of vsel bits.
    if( (VSelBits + 1) & VSelBits)
    {
      dprintf("ERROR: GPIO table has Voltage Select holes!\n");
      dprintf("       defined:");
      for(i=0; i<4; i++)
      {
        if(VSelBits & (1<<i))
          dprintf("VSEL%d ", i);
      }
      dprintf("\n   not defined:");
      for(i=0; i<4; i++)
      {
        if( (VSelBits & (1<<(i+1))) &&
           !(VSelBits & (1<<i)) )
          dprintf("VSEL%d ", i);
      }
      dprintf("\n");

      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
  }

  if( (FoundDisablePowerSense) &&
     !(FoundThermalPowerSense) )
  {
    dprintf("ERROR: GPIO table defines Disable Power Sense, but no Thermal+Power Sense GPIO found!\n");
    pgv->exitValue = 5;
    ErrorCountCheck(pgv);
  }

  if(FoundThermalGpioRequired)
  {
    if(pgv->DCBVersion < 0x30)
    {
      if(!(pgv->g2x.ThermalTypePort&0xF) )
      {
        // See Terrence C. for issues with this one
        dprintf("ERROR: GPIO table defines Thermal Event, but no Thermal device defined!\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }
    }
    else if(pgv->Device < 0x43)
    {
      // LW43+ have internal thermal sensors that are not listed in the I2C Devices table.
      // So, don't look at them here.

      LwU32 FoundThermalDevice = 0;

      // Loop over the I2C devices
      for(i=0; i<pgv->g3x.i2cdev.EntryCount; i++)
      {
        // Look for skip entries
        if(GetI2CDevicesEntryType(pgv, i) == 0xFF)
          continue;

        switch(GetI2CDevicesEntryType(pgv, i))
        {
          case 0x01: // Th:ADM 1032
          case 0x02: // Th:MAX 6649
          case 0x03: // Th:LM99
          case 0x04: // Th:SMB MAX 6649
          case 0x05: // Th:VBIOS event
          case 0x06: // Th:MAX 1617
          case 0x07: // Th:LM64
          case 0x08: // Th:OS
          case 0x70: // Th:ADT7473
             FoundThermalDevice = 1;
             break;
        }

        if(FoundThermalDevice)
          break;
      }

      if(!FoundThermalDevice)
      {
        // See Terrence C. for issues with this one
        dprintf("ERROR: GPIO table defines Thermal Event, but no Thermal device defined in I2C Devices!\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }
    }

  }

}

void CheckMiscStructure(PGV pgv)
{
  LwU32 MaxGPIO = 9;
  LwU32 i;

  if(pgv->DCBVersion < 0x21)
    return;
  if(pgv->DCBVersion >= 0x30)
    return;

  if(pgv->g2x.MiscVersion < 0x10)
  {
    dprintf("ERROR: Miscellaneous Structure has revision 0x%02x. Revisions start at 0x10!\n", pgv->g2x.MiscVersion);
    pgv->exitValue = 5;
    ErrorCountCheck(pgv);
    return;
  }

  // Check reserved bits per revision
  if( (pgv->g2x.MiscVersion == 0x10) ||
      (pgv->g2x.MiscVersion == 0x11) )
  {
    // Check DAC B reserved bits
    if((pgv->g2x.DACBSwitch&0xC) != 0)
    {
      dprintf("ERROR: Misc: DAC B Switch Reserved bits are not 0!\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }

    // Check Stereo Reserved bits
    if((pgv->g2x.StereoGlasses&0x8) != 0)
    {
      dprintf("ERROR: Misc: Stereo Reserved bits are not 0!\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
  }

  if(!(pgv->g2x.DACBSwitch&0x1))
  {
    if((pgv->g2x.DACBGPIO&0xF))
    {
      dprintf("NOTE: Misc: DAC B Alt-Detect GPIO defined but DAC B Switch Support is not available.\n");
    }

    if(((pgv->g2x.DACBGPIO>>4)&0xF))
    {
      dprintf("NOTE: Misc: DAC B Select GPIO defined but DAC B Switch Support is not available.\n");
    }
  }
  else
  {
    // DAC B switch is defined.  So make sure that there are 2 DAC B devices on this board!!
    LwU32 NumberOfDacBDevices = 0;

    for(i=0; i<pgv->DCBEntryCount; i++)
    {
      LwU32 Type = pgv->gIP.GetType(pgv, i);
      LwU32 OutputDevices = pgv->gIP.GetOutput(pgv, i);
      LwU32 Location = pgv->gIP.GetLocation(pgv, i);

      if( (Location == LOCATION_CHIP) &&
          ( (Type == TYPE_CRT) ||
            (Type == TYPE_TV) ) &&
          (OutputDevices == OUTPUT_DAC_B) )
        NumberOfDacBDevices++;
    }

    if(NumberOfDacBDevices < 2)
    {
      if(NumberOfDacBDevices == 1)
      {
        dprintf("ERROR: Misc: DAC B Switching defined but only one DAC B device listed.\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }
      else
      {
        dprintf("ERROR: Misc: DAC B Switching defined but no DAC B devices listed.\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }
    }
  }

  if(!(pgv->g2x.StereoGlasses&0x1))
  {
    if(((pgv->g2x.StereoGlasses>>4)&0xf))
    {
      dprintf("ERROR: Misc: Stereo GPIO defined but Stereo Support is not available.\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
  }

  // Check the GPIO pins to see if they exceed the chip's maximum
  // LW30 onward has 13, all others have 9.
  // Note: LW30 has them listed in the hardware reference,
  // but the pins are not connected lwrrently.
  //
  //if(pgv->Device > 0x30)
  //  MaxGPIO = 13;

  // Check DAC B switch GPIOs if it is supported
  if(pgv->g2x.DACBSwitch&0x1)
  {
    if( ((LwU32) (pgv->g2x.DACBGPIO&0xF)) > MaxGPIO)
    {
      dprintf("ERROR: Misc: DACB AltDetect GPIO is greater than LW%X's max: %d!\n",
        pgv->Device, MaxGPIO);
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }

    if( ((LwU32) ((pgv->g2x.DACBGPIO>>4)&0xF)) > MaxGPIO)
    {
      dprintf("ERROR: Misc: DACB Select GPIO is greater than LW%X's max: %d!\n",
        pgv->Device, MaxGPIO);
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
  }

  // Check Stereo GPIO if Stereo is supported
  if((pgv->g2x.StereoGlasses&0x1))
  {
    if( ((LwU32) ((pgv->g2x.StereoGlasses>>4)&0xf)) > MaxGPIO)
    {
      dprintf("ERROR: Misc: Stereo GPIO is greater than LW%X's max: %d!\n",
        pgv->Device, MaxGPIO);
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
  }

  if(pgv->g2x.StereoGlasses & 0x6)
  {
    // Check to make sure that HD bit is set in TV Dac fields in at least one of the fields
    for(i=0; i<pgv->DCBEntryCount; i++)
    {
      LwU32 Type = pgv->gIP.GetType(pgv, i);
      LwU32 TVDacs = (getDSI_2x(pgv, i)>>8)&0xF;

      if( (Type == TYPE_TV) &&
          (TVDacs > 7) )
        break;
    }

    if(i == pgv->DCBEntryCount)
    {
      dprintf("ERROR: Misc: HDTV bit is not set in TV DACs, but ");
      if(pgv->g2x.StereoGlasses & 0x2)
      {
        dprintf("PCA9555 ");
        if(pgv->g2x.StereoGlasses & 0x4)
          dprintf("+ ");
      }
      if(pgv->g2x.StereoGlasses & 0x4)
        dprintf("EEPROM ");
      dprintf("bits are set!\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
  }

  // I could check for known types here, but I've decided to skip
  // that since I believe that known types will be added later.
  // So, rather than updating this program constantly for known
  // types, I'll just leave that alone for now.

  if(pgv->g2x.MiscVersion == 0x10)
    return;

  // Check Revision 11 additions
  if(!(pgv->g2x.ThermalTypePort&0xF) )
  {
    if(pgv->g2x.ThermalTypePort&0xF0)
    {
      dprintf("ERROR: Misc: Thermal Diode I2C Port defined but no Thermal Diode is available!\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }

    if(pgv->g2x.ThermalI2CAddr)
    {
      dprintf("ERROR: Misc: Thermal Diode I2C Addr defined but no Thermal Diode is available!\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
  }
  else
  {
    if( ((LwU32) (pgv->g2x.ThermalTypePort>>4)&0xF0) >= pgv->I2CEntryCount)
    {
      dprintf("ERROR: Misc: Thermal Diode I2C Port %d is not defined in I2C Control Block.\n", (pgv->g2x.ThermalTypePort>>4)&0xF0);
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
  }

  if(pgv->g2x.MiscVersion == 0x11)
    return;

  // Check Revision 12 additions
  if( (pgv->g2x.MiscVersion >= 0x14) &
      (pgv->g2x.SSDevices) )
  {
    // Check to see if the SpreadSpectrumDeviceMask agrees with the old SpreadSpectrumDevices
    if(pgv->g2x.SSDeviceMask == 0)
    {
      dprintf("ERROR: Misc: SpreadSpectrumDeviceMask is 0, but SpreadSpectrumDevices is not.\n");
      dprintf("       Please fill in the SpreadSpectrumDeviceMask or set Misc Revision < 14.\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
    else
    {
      if( (pgv->g2x.SSDeviceMask&0x1) &&
         !(pgv->g2x.SSDevices&0x1) )
      {
        dprintf("ERROR: Misc: SpreadSpectrumDeviceMask has Int.LVDS support, but \n");
        dprintf("       SpreadSpectrumDevices doesn't. Please make SpreadSpectrumDeviceMask\n");
        dprintf("       match SpreadSpectrumDevices.\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }
      else if(!(pgv->g2x.SSDeviceMask&0x1) &&
               (pgv->g2x.SSDevices&0x1) )
      {
        dprintf("ERROR: Misc: SpreadSpectrumDeviceMask does not have Int.LVDS support, but \n");
        dprintf("       SpreadSpectrumDevices does. Please make SpreadSpectrumDeviceMask\n");
        dprintf("       match SpreadSpectrumDevices.\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }

      if( (pgv->g2x.SSDeviceMask&0x10) &&
         !(pgv->g2x.SSDevices&0x10) )
      {
        dprintf("ERROR: Misc: SpreadSpectrumDeviceMask has Ext.LVDS support, but \n");
        dprintf("       SpreadSpectrumDevices doesn't. Please make SpreadSpectrumDeviceMask\n");
        dprintf("       match SpreadSpectrumDevices.\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }
      else if(!(pgv->g2x.SSDeviceMask&0x10) &&
               (pgv->g2x.SSDevices&0x10) )
      {
        dprintf("ERROR: Misc: SpreadSpectrumDeviceMask does not have Ext.LVDS support, but \n");
        dprintf("       SpreadSpectrumDevices does. Please make SpreadSpectrumDeviceMask\n");
        dprintf("       match SpreadSpectrumDevices.\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }

      if( (pgv->g2x.SSDeviceMask&0x100) &&
         !(pgv->g2x.SSDevices&0x8) )
      {
        dprintf("ERROR: Misc: SpreadSpectrumDeviceMask has Int.TMDS support, but \n");
        dprintf("       SpreadSpectrumDevices doesn't. Please make SpreadSpectrumDeviceMask\n");
        dprintf("       match SpreadSpectrumDevices.\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }
      else if(!(pgv->g2x.SSDeviceMask&0x100) &&
               (pgv->g2x.SSDevices&0x8) )
      {
        dprintf("ERROR: Misc: SpreadSpectrumDeviceMask does not have Int.TMDS support, but \n");
        dprintf("       SpreadSpectrumDevices does. Please make SpreadSpectrumDeviceMask\n");
        dprintf("       match SpreadSpectrumDevices.\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }

      if( (pgv->g2x.SSDeviceMask&0x1000) &&
         !(pgv->g2x.SSDevices&0x80) )
      {
        dprintf("ERROR: Misc: SpreadSpectrumDeviceMask has Ext.TMDS support, but \n");
        dprintf("       SpreadSpectrumDevices doesn't. Please make SpreadSpectrumDeviceMask\n");
        dprintf("       match SpreadSpectrumDevices.\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }
      else if(!(pgv->g2x.SSDeviceMask&0x1000) &&
               (pgv->g2x.SSDevices&0x80) )
      {
        dprintf("ERROR: Misc: SpreadSpectrumDeviceMask does not have Ext.TMDS support, but \n");
        dprintf("       SpreadSpectrumDevices does. Please make SpreadSpectrumDeviceMask\n");
        dprintf("       match SpreadSpectrumDevices.\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }
    }
  }
  else if(pgv->g2x.SSDevices & 0x22)
  {
    dprintf("ERROR: Misc: SpreadSpectrumDevices lists reserved bits! Bit 1 and 5 must be 0.\n");
    pgv->exitValue = 5;
    ErrorCountCheck(pgv);
  }

  if(pgv->g2x.MiscVersion == 0x12)
    return;

  // Check Revision 13 additions
  //if(pgv->g2x.MiscVersion >= 0x13)
  //  CheckGpioAssignments(pgv);
  // Moved outside this function since DCB 3.0 GPIO table
  // needs checking, but DCB 3.0 has no misc table

  if(pgv->g2x.MiscVersion == 0x13)
    return;

  // Check Revision 14 additions
  if((pgv->g2x.SSDeviceMask & 0xEEEEEEEE) & ~((pgv->g2x.SSDeviceMask & 0x11111111)*0xF))
  {
    dprintf("ERROR: Misc: SpreadSpectrumMask has set bits where the device is disabled!\n");
    dprintf("       SSDeviceMask:0x%08x\n", pgv->g2x.SSDeviceMask);
    pgv->exitValue = 5;
    ErrorCountCheck(pgv);
  }

  if ( ( pgv->g2x.SSDeviceMask     & 0x11111111) &
       ((pgv->g2x.SSDeviceMask>>1) & 0x11111111) &
       ((pgv->g2x.SSDeviceMask>>2) & 0x11111111) )
  {
    dprintf("ERROR: Misc: SpreadSpectrumMask has Ext. Communcation set on Int. SS Devices!\n");
    pgv->exitValue = 5;
    ErrorCountCheck(pgv);
  }

  if(pgv->g2x.MiscVersion == 0x14)
    return;

  // Check Revision 15 additions
  if(pgv->g2x.DACBSwitch&0xF0)
  {
    if(pgv->g2x.ExtHwMonitorI2C == 0)
    {
      dprintf("NOTE: Misc: External HW Monitor has 0 for I2C Address!\n");
    }
  }
  else
  {
    if(pgv->g2x.ExtHwMonitorI2C != 0)
    {
      dprintf("NOTE: Misc: External HW Monitor is not available and I2C address is non-zero!\n");
    }
  }


  if(pgv->g2x.MiscVersion == 0x15)
    return;

  // Add revision 0x16 checks here.
}

void CheckInputDevices(PGV pgv)
{
  // I could check for known types here, but I've decided to skip
  // that since I believe that known types will be added later.
  // So, rather than updating this program constantly for known
  // types, I'll just leave that alone for now.
}

// Check to ensure that DCB version 4.1+ display enabled roms have a single WBD entry
void CheckWBD(PGV pgv)
{
  LwU32 i;

  // Get display subsystem status
  LwU8 DisplayDisabled = pgv->DisplayControlFlags & NO_DISPLAY_SUBSYSTEM_MASK;

  // Only support DCB Version 4.1+, display enabled roms and Maxwell VBIOS.
  if ((pgv->DCBVersion >=0x41 && DisplayDisabled == 0) && (pgv->VBIOSCore == Core84))
  {
    // Iterate through all entries and check that only one is a WBD entry
    LwU8 NumWBDEntries = 0;

    for(i=0; i<pgv->DCBEntryCount; i++)
    {
      LwU32 Type = pgv->gIP.GetType(pgv, i);

      if(Type == TYPE_WBD)
        NumWBDEntries++;
    }

    if (NumWBDEntries == 0)
    {
      dprintf("ERROR: No WBD entry found! A WBD entry is required for DCB version 4.1+ display enabled roms!\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
  }
}

// Check to ensure that DCB version 4.1+ display enabled roms have the LVDS entry first.
void CheckLVDSfirst(PGV pgv)
{
  LwU32 i;

  // Get display subsystem status
  LwU8 DisplayDisabled = pgv->DisplayControlFlags & NO_DISPLAY_SUBSYSTEM_MASK;

  // Only DCB Version 4.1+ and display enabled roms should be checked
  if (pgv->DCBVersion >=0x41 && DisplayDisabled == 0)
  {
    // Iterate through all entries and check for a LVDS entry
    LwU8 NumLVDSEntries = 0;

    for(i=0; i<pgv->DCBEntryCount; i++)
    {
      LwU32 Type = pgv->gIP.GetType(pgv, i);

      if(Type == TYPE_LVDS)
      {
        NumLVDSEntries++;
        break;
      }
    }
    if ((NumLVDSEntries == 1)&& (i > 0))
    {
      dprintf("ERROR: The LVDS entry is not the first entry in the DCB table!\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
  }
}

// Can be used to skip dcbchk for any device ID.
void IsDisplayfullROM(PGV pgv, LwU32 PCIDeviceID)
{
   pgv->skip_dcbchk = (PCIDeviceID & 0xffff);

  // dprintf("PCIDevID = %x\n", pgv->skip_dcbchk);

  switch(pgv->skip_dcbchk)
    {
      case 0x13D9:
      case 0x13DA:
      case 0x1427:
      case 0x1407: pgv->skip_dcbchk = 1;  break;
      default:     pgv->skip_dcbchk = 0;  break;
    }
}


void CheckVBIOSCore(PGV pgv)
{
    pgv->VBIOSCore = (pgv->BiosVersion & 0x0FF000000) >> 24;
    if ( pgv->VBIOSCore < Core70 )
    {
        pgv->VBIOSCore = CoreOld;
    }
}

void CheckForValidDCBEntries(PGV pgv)
{
  LwU32 i=0;
  LwU32 I2CPort = pgv->gIP.GetI2CPort(pgv, i);

    for(i=0; i<pgv->DCBEntryCount; i++)
    {
      LwU32 Type = pgv->gIP.GetType(pgv, i);

      if( pgv->VBIOSCore >= Core86 )
      {
         if(Type == TYPE_LVDS)
         {
            dprintf("ERROR: DCB Entry %2d, 'LVDS' is not supported!\n", i);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
         }
         if(Type == TYPE_CRT)
         {
            dprintf("ERROR: DCB Entry %2d, 'CRT' is not supported!\n", i);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
         }
      }

      if( pgv->VBIOSCore >= Core86 )  // Enabling for Pascal+ (Bug 1609939)      {
        if( (getVirtualDevice_4x(pgv, i) && (I2CPort != 15) ))
        {
          dprintf("ERROR: DCB Entry %2d is a virtual device and should have the I2C Port set to UNUSED.\n", i);
          pgv->exitValue = 5;
          ErrorCountCheck(pgv);
        }
    }
}

void CheckVBIOSProduction(PGV pgv)
{
  // Check if the Emulation or Simulation flags are set.
  switch(pgv->IntFlags2 & 0x0c)
    {
    case 0x4: pgv->VBIOSType = INTFLAGS2_EMULATION;   break;                        // VB_CONTROL_FLAG_1_EMULATION_BUILD
    case 0x8: pgv->VBIOSType = INTFLAGS2_SIMULATION;  break;                        // VB_CONTROL_FLAG_1_SIMULATION_BUILD
    case 0x0c:pgv->VBIOSType = INTFLAGS2_EMULATION | INTFLAGS2_SIMULATION; break;   // Both
    break;
    default:
        pgv->VBIOSType = PRODUCTION;      // Should be production VBIOS
        break;
    }
}

void CheckConnectorTable(PGV pgv)
{
  LwU32 i,j;
  LwU32 AllSkipEntries = 1;
  LwU32 FoundDConn = 0;
  LwU32 FoundScartBlueDConn = 0;
  LwU32 spPointer, spType;
  LwU32 StereoPinCheck = 0;
  LwU32 PSRFrameLockPinCheck = 0;
  LwU32 AllVirtual = 1;
  LwU32 UsedConnectorMask = 0;

  // Check for all skip entries
  if(pgv->DCBVersion < 0x30)
    return;

  if(pgv->g3x.cnctr.EntryCount == 0)
  {
    if (pgv->DCBEntryCount != 0)
    {
      dprintf("ERROR: Connector Table has no connectors in it! This table is required!\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
    return;
  }

  for(i=0; i<pgv->g3x.cnctr.EntryCount; i++)
  {
    if(GetConnectorEntryType(pgv, i) == 0xFF)
      continue;

    AllSkipEntries = 0;
    break;
  }
  if(AllSkipEntries)
  {
    if (pgv->DCBEntryCount != 0)
    {
      if (pgv->DCBVersion >=0x40)
      {
        for(i=0; i<pgv->DCBEntryCount; i++)
        {
          LwU32 Type = pgv->gIP.GetType(pgv, i);

          // DCB 3.0 has Skip Entries
          if(Type == TYPE_SKIP)
            continue;

          if (!getVirtualDevice_4x(pgv, i))
          {
            AllVirtual = 0;
            break;
          }
        }

        // Only produce an error if there is a non-virtual entry - bug 751997
        if (AllVirtual)
        {
          AllSkipEntries = 0;
        }

      }

      if (AllSkipEntries)
      {
        dprintf("ERROR: Connector Table has ALL SKIP ENTRIES! This table is required!\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }
    }
    return;
  }

  // check to make sure that each DCB entry has a valid connector type associated with it.
  for(i=0; i<pgv->DCBEntryCount; i++)
  {
    LwU32 Type = pgv->gIP.GetType(pgv, i);
    LwU32 ConIdx = getConnectorIndex_3x(pgv, i);
    LwU32 ConType = GetConnectorEntryType(pgv, ConIdx);
    LwU32 ConCount = 1;

    // DCB 3.0 has Skip Entries
    if(Type == TYPE_SKIP)
      continue;

    if(ConType == 0xFF)
    {
      // Only cause a build error if not MXM Default DCB - bug 793163
      if ((pgv->bit.MXMConfigFlags0 & 0xC) != 0xC)
      {
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
        dprintf("ERROR: ");
      }
      else
      {
        dprintf("NOTE: ");
      }
      dprintf("DCB Entry %d points to SKIP ENTRY connector type! Invalid assignment\n", i);
      continue;
    }

    UsedConnectorMask |= (1 << ConIdx);

    // Check to make sure that the type of connector can handle the
    switch(Type)
    {
      case TYPE_CRT:
        switch(ConType)
        {
          case 0x00: // VGA 15-pin connector
          case 0x01: // DVI-A
          case 0x02: // Pod - VGA 15-pin connector
          case 0x20: // DVI-I-TV-SVideo
          case 0x21: // DVI-I-TV-Composite
          case 0x30: // DVI-I
          case 0x32: // Apple Display Connector (ADC)
          case 0x38: // LFH-DVI-I-1
          case 0x39: // LFH-DVI-I-2
          case 0x50: // VGA 15-pin if not docked
          case 0x51: // VGA 15-pin if docked
          case 0x52: // DVI-I if docked
          case 0x53: // DVI-I if not docked
          case 0x64: // LFH-DP-1
          case 0x65: // LFH-DP-2
            break;
          default:
            // Only cause a build error if not MXM Default DCB - bug 793163
            if ((pgv->bit.MXMConfigFlags0 & 0xC) != 0xC)
            {
              pgv->exitValue = 5;
              ErrorCountCheck(pgv);
              dprintf("ERROR: ");
            }
            else
            {
                dprintf("NOTE: ");
            }
            dprintf("DCB Entry %d (CRT) points to Connector type: 0x%x. Invalid assignment\n", i, ConType);
            break;
        }
        break;
      case TYPE_TV:
        ConCount = pgv->g3x.GetTVConnectorCount(pgv, i);
        for(j=0; j<ConCount; j++)
        {
          ConType = GetConnectorEntryType(pgv, ConIdx+j);
          UsedConnectorMask |= (1 << (ConIdx+j));

          switch(ConType)
          {
            case 0x10: // TV - Composite Out
            case 0x11: // TV - SVideo Out
            case 0x12: // TV - SVideo Breakout - Composite (Used for board that list 2 of the RGB bits in the TV DACs field)
            case 0x13: // TV - HDTV Component - YPrPb
            case 0x14: // TV - SCART Connector
            case 0x16: // TV Scart Blue over HDTV-EIAJ4120 (D-cnctr)
            case 0x17: // TV HDTV-EIAJ4120 (D-cnctr)
            case 0x18: // Pod - HDTV - YPrPb
            case 0x19: // Pod - SVideo
            case 0x1A: // Pod - Composite
            case 0x20: // DVI-I-TV-SVideo
            case 0x21: // DVI-I-TV-Composite
            case 0x22: // DVI-I-TV-SVideo Breakout-Composite (Used for board that list 2 of the RGB bits in the TV DACs field)
            case 0x32: // Apple Display Connector (ADC)
            case 0x3A: // LFH-SVideo
              break;
            default:
              // Only cause a build error if not MXM Default DCB - bug 793163
              if ((pgv->bit.MXMConfigFlags0 & 0xC) != 0xC)
              {
                  pgv->exitValue = 5;
                  ErrorCountCheck(pgv);
                  dprintf("ERROR: ");
              }
              else
              {
                  dprintf("NOTE: ");
              }
              dprintf("DCB Entry %d (TV) points to Connector type: 0x%x. Invalid assignment\n", i, ConType);
              break;
          }
          if (ConType == 0x17)
          {
            FoundDConn = 1;
          }
          else if (ConType == 0x16)
          {
            FoundScartBlueDConn = 1;
          }
        }
        // Requested by Ryan B.
        if (FoundScartBlueDConn && !FoundDConn)
        {
          // Only cause a build error if not MXM Default DCB - bug 793163
          if ((pgv->bit.MXMConfigFlags0 & 0xC) != 0xC)
          {
              pgv->exitValue = 5;
              ErrorCountCheck(pgv);
              dprintf("ERROR: ");
          }
          else
          {
              dprintf("NOTE: ");
          }
          dprintf("DCB Entry %d (TV) has ScartBlue over D-Connector, but no D-Connector.\n"
                  "       This is not a valid assignment!\n", i);
        }
        break;
      case TYPE_LVDS:
        switch(ConType)
        {
          case 0x40: // LVDS-SPWG-Attached (non-removeable)
          case 0x41: // LVDS-OEM-Attached (non-removeable)
          case 0x42: // LVDS-SPWG-Detached (removeable)
          case 0x43: // LVDS-OEM-Detached (removeable)
            break;
          default:
            // Only cause a build error if not MXM Default DCB - bug 793163
            if ((pgv->bit.MXMConfigFlags0 & 0xC) != 0xC)
            {
                pgv->exitValue = 5;
                ErrorCountCheck(pgv);
                dprintf("ERROR: ");
            }
            else
            {
                dprintf("NOTE: ");
            }
            dprintf("DCB Entry %d (LVDS) points to Connector type: 0x%x. Invalid assignment\n", i, ConType);
            break;
        }
        break;
      case TYPE_TMDS:
        switch(ConType)
        {
          case 0x20: // DVI-I-TV-SVideo
          case 0x21: // DVI-I-TV-Composite
          case 0x30: // DVI-I
          case 0x31: // DVI-D
          case 0x32: // Apple Display Connector (ADC)
          case 0x38: // LFH-DVI-I-1
          case 0x39: // LFH-DVI-I-2
          case 0x44: // TMDS internal (non-removeable)
          case 0x45: // TMDS-OEM-Attached (non-removeable)
          case 0x46: // Display Port (external) through dongle
          case 0x48: // DisplayPort (Mini) connector
          case 0x52: // DVI-I if not docked
          case 0x53: // DVI-I if docked
          case 0x54: // DVI-D if not docked
          case 0x55: // DVI-D if docked
          case 0x56: // DP ext. if not docked
          case 0x57: // DP ext. if docked
          case 0x58: // DP Mini ext. if not docked
          case 0x59: // DP Mini ext. if docked
          case 0x61: // HDMI-A connector
          case 0x63: // HDMI-C (mini) connector
          case 0x64: // LFH-DP-1
          case 0x65: // LFH-DP-2
            break;
          default:
            // Only cause a build error if not MXM Default DCB - bug 793163
            if ((pgv->bit.MXMConfigFlags0 & 0xC) != 0xC)
            {
                pgv->exitValue = 5;
                ErrorCountCheck(pgv);
                dprintf("ERROR: ");
            }
            else
            {
                dprintf("NOTE: ");
            }
            dprintf("DCB Entry %d (TMDS) points to Connector type: 0x%x. Invalid assignment\n", i, ConType);
            break;
        }
        break;
      case TYPE_SDI:
        switch(ConType)
        {
          case 0x3C: // BNC Connector
            break;
          default:
            // Only cause a build error if not MXM Default DCB - bug 793163
            if ((pgv->bit.MXMConfigFlags0 & 0xC) != 0xC)
            {
                pgv->exitValue = 5;
                ErrorCountCheck(pgv);
                dprintf("ERROR: ");
            }
            else
            {
                dprintf("NOTE: ");
            }
            dprintf("DCB Entry %d (SDI) points to Connector type: 0x%x. Invalid assignment\n", i, ConType);
            break;
        }
        break;
      case TYPE_DP:
        switch(ConType)
        {
          case 0x46: // DisplayPort External connector
          case 0x47: // DisplayPort Internal connector
          case 0x48: // DisplayPort (Mini) connector
          case 0x56: // DP ext. if not docked
          case 0x57: // DP ext. if docked
          case 0x58: // DP Mini ext. if not docked
          case 0x59: // DP Mini ext. if docked
          case 0x64: // LFH-DP-1
          case 0x65: // LFH-DP-2
          case 0x71: // USB Type-C
            break;
          default:
            // Only cause a build error if not MXM Default DCB - bug 793163
            if ((pgv->bit.MXMConfigFlags0 & 0xC) != 0xC)
            {
                pgv->exitValue = 5;
                ErrorCountCheck(pgv);
                dprintf("ERROR: ");
            }
            else
            {
                dprintf("NOTE: ");
            }
            dprintf("DCB Entry %d (DP) points to Connector type: 0x%x. Invalid assignment\n", i, ConType);
            break;
        }
        break;
      case TYPE_WBD:
        switch(ConType)
        {
          case 0x70: // WiFi Display Virtual Device
            break;
          default:
            // Only cause a build error if not MXM Default DCB - bug 793163
            if ((pgv->bit.MXMConfigFlags0 & 0xC) != 0xC)
            {
                pgv->exitValue = 5;
                ErrorCountCheck(pgv);
                dprintf("ERROR: ");
            }
            else
            {
                dprintf("NOTE: ");
            }
            dprintf("DCB Entry %d (WBD) points to Connector type: 0x%x. Invalid assignment\n", i, ConType);
            break;
        }
        break;
      default:
        break;
    }
  } // end of loop on displays.

  if (pgv->DCBVersion >= 0x40)
  {
    LwU32 UnassignedDisplayConnectorMask = 0;

    // Check for Stereo connector and PSR
    for(i=0; i<pgv->g3x.cnctr.EntryCount; i++)
    {
      LwU32 ConnectorType = GetConnectorEntryType(pgv, i);

      if(ConnectorType == 0x60)
      {
        StereoPinCheck |= 1;
      }

      if (GetConnectorEntryPSRFrameLockA(pgv, i))
      {
        if (ConnectorType != 0x40 &&
            ConnectorType != 0x41 &&
            ConnectorType != 0x47)
        {
            dprintf("ERROR: The connector table entry define PSR frame lock A on an external connector\n");
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
        }

        PSRFrameLockPinCheck |= 1;
      }
    }

    // Check for Stereo GPIO and PSR Frame Lock GPIO
    for (i = 0; i < pgv->GPIOEntryCount; i++)
    {
      if (GetGpioFunction_40(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize) == 0xF)
      {
        StereoPinCheck |= 0x2;
      }

      if (GetGpioFunction_40(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize) == 0x85)
      {
        // GPIO PSR frame lock pin is defined but there is no entry in connector table has PSR Refresh Frame Lock A set.
        if ((PSRFrameLockPinCheck == 0) && (pgv->DevicesPatchPtr == 0))
        {
            dprintf("ERROR: GPIO PSR frame lock pin is defined.\n"
                    "       But no entry in connector table has PSR Frame Lock A set.\n");
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
        }

        PSRFrameLockPinCheck |= 0x2;
      }
    }

    // Don't allow Stereo Connector without GPIO - Requested in bug 485398
    if (StereoPinCheck == 1)
    {
      dprintf("ERROR: Stereo requires both Connector and GPIO, but only one is defined\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }

    // Don't allow connector with PSR frame lock defined without GPIO - Requested in bug 967148
    if (PSRFrameLockPinCheck == 1)
    {
      dprintf("ERROR: PSR frame lock requires both Connector and GPIO.\n"
              "       But only one is defined.\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }


    // Check to make sure that all display connector entries have associated DCBIndexes
    // bug 826193
    for(i=0; i<pgv->g3x.cnctr.EntryCount; i++)
    {

      if (UsedConnectorMask & (1<<i))
      {
        // Skip any connectors that are already associated
        continue;
      }
      switch(GetConnectorEntryType(pgv, i))
      {
        case 0xFF:
        case 0x60:
        case 0x62:
          break;
        default:
          UnassignedDisplayConnectorMask |= (1<<i);
          break;
      }
    }

    if (UnassignedDisplayConnectorMask)
    {
      if(pgv->VBIOSCore >= Core84)
      {
         dprintf("ERROR: These connector index(es), {");
         for(i=0; i<pgv->g3x.cnctr.EntryCount; i++)
         {
           if (UnassignedDisplayConnectorMask & (1<<i))
           {
             dprintf(" %d", i);
           }
         }
         dprintf(" }, \n"
              "       do not have any associated display(s) routed to them!\n");
         pgv->exitValue = 5;
         ErrorCountCheck(pgv);
      }
    }

    // check to make sure that location is unique
    // bug 827631
    for(i=0; i<pgv->g3x.cnctr.EntryCount; i++)
    {
      LwU32 iLoc,iType,jType;
      if(GetConnectorEntryType(pgv, i) == 0xFF)
      {
        continue;
      }

      iLoc = GetConnectorEntryLocation(pgv, i);
      iType = GetConnectorEntryType(pgv, i);

      for(j=i+1; j<pgv->g3x.cnctr.EntryCount; j++)
      {
        if(GetConnectorEntryType(pgv, j) == 0xFF)
        {
          continue;
        }

        if (iLoc == GetConnectorEntryLocation(pgv,j))
        {
          jType = GetConnectorEntryType(pgv, j);

          switch(iType | (jType<<8))
          {
            // Allow for eDP and LVDS to be at the same index.
            case 0x4740: // eDP + LVDS-SPWG
            case 0x4741: // eDP + LVDS-OEM
            case 0x4047: // LVDS-SPWG + eDP
            case 0x4147: // LVDS-OEM + eDP
              break;
            // TV combos
            case 0x1110:
            case 0x1210:
            case 0x1310:
            case 0x1410:
            case 0x1510:
            case 0x1610:
            case 0x1710:
            case 0x1211:
            case 0x1311:
            case 0x1411:
            case 0x1511:
            case 0x1611:
            case 0x1711:
            case 0x1312:
            case 0x1412:
            case 0x1512:
            case 0x1612:
            case 0x1712:
            case 0x1413:
            case 0x1513:
            case 0x1613:
            case 0x1713:
            case 0x1514:
            case 0x1614:
            case 0x1714:
            case 0x1615:
            case 0x1715:
            case 0x1716:
            case 0x1011:
            case 0x1012:
            case 0x1013:
            case 0x1014:
            case 0x1015:
            case 0x1016:
            case 0x1017:
            case 0x1112:
            case 0x1113:
            case 0x1114:
            case 0x1115:
            case 0x1116:
            case 0x1117:
            case 0x1213:
            case 0x1214:
            case 0x1215:
            case 0x1216:
            case 0x1217:
            case 0x1314:
            case 0x1315:
            case 0x1316:
            case 0x1317:
            case 0x1415:
            case 0x1416:
            case 0x1417:
            case 0x1516:
            case 0x1517:
            case 0x1617:
              break;
            default:
            if( pgv->VBIOSCore >= Core84 )
              {
                 dprintf("ERROR: Connector indexes %d and %d both use Location %d!\n", i, j, iLoc);
                 pgv->exitValue = 5;
                 ErrorCountCheck(pgv);
              }
              break;
          }
        }
      }
    }


  }


  if (FoundDConn)
  {
    // Ryan Bissell requested that if we find the DConnector, we should make sure that
    // 1. we define a I2C Devices for PCA9555, or
    // 2. We define XPIO type 1.
    FoundDConn = 1;

    for(i=0; i<pgv->g3x.i2cdev.EntryCount; i++)
    {
      // Look for PCA9555
      if(GetI2CDevicesEntryType(pgv, i) == 0x60)
      {
        FoundDConn = 2;
        break;
      }
    }

    for(i=0; i<pgv->g3x.extGpio.MasterEntryCount; i++)
    {
      pgv->LwrrentFileOffset = pgv->g3x.extGpio.MasterPointer +
                               pgv->g3x.extGpio.MasterHeaderSize +
                               i * pgv->g3x.extGpio.MasterEntrySize;
      spPointer = pgv->gIP.GetLwU16(pgv);

      // Skip 0 pointers
      if(!spPointer)
      {
        continue;
      }

      pgv->LwrrentFileOffset = spPointer+4;
      spType = pgv->gIP.GetLwU8(pgv);

      if (spType == 0x1)
      {
        FoundDConn = 2;
        break;
      }
    }

    if (FoundDConn == 1)
    {
      dprintf("ERROR: DCB Connector Table has D-Connector, but PCA9555 was not found in the"
              "       I2C Devices Table or the External GPIO Assignment Table.\n");
      // For now, allow DCB 3.0 to build.  But once the G72 OEM Toshiba bios is fixed,
      // we should remove this check.
      if (pgv->DCBVersion >= 0x40)
      {
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }
    }


  }

}


// This entire function is requested by Ryan B.
void CheckHotplug(PGV pgv)
{
  LwU32 i, j;
  LwU32 FoundConnectorHotplugA = 0;
  LwU32 FoundConnectorHotplugB = 0;
  LwU32 FoundGPIOHotplugA = 0;
  LwU32 FoundGPIOHotplugB = 0;
  LwU32 FoundHotplugCapableConnector = 0;

  // This test is only relevant for DCB 3.0
  if( (pgv->DCBVersion <  0x30) ||
      (pgv->DCBVersion >= 0x40) )
    return;

  // First look through the GPIOs to see if there's any Hotplugs defined
  for (i = 0; i < pgv->GPIOEntryCount; i++)
  {
    LwU32 gpioFunc    = GetGPIOFunction(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);

    // DCB 3.0 has Skip Entries
    if(gpioFunc == 0x3F)
      continue;

    if(gpioFunc == 7)
      FoundGPIOHotplugA = 1;
    else if (gpioFunc == 8)
      FoundGPIOHotplugB = 1;

    if(FoundGPIOHotplugA && FoundGPIOHotplugB)
      break;
  }

  // check to make sure that each DCB entry has a valid connector type associated with it.
  if(pgv->g3x.cnctr.EntryCount != 0)
  {
    for(i=0; i<pgv->DCBEntryCount; i++)
    {
      LwU32 Type     = pgv->gIP.GetType(pgv, i);
      LwU32 ConIdx   = getConnectorIndex_3x(pgv, i);
      LwU32 HotplugA;
      LwU32 HotplugB;
      LwU32 ConCount = 1;

      if(Type == TYPE_TV)
        ConCount = pgv->g3x.GetTVConnectorCount(pgv, i);

      for (j=0; j<ConCount; j++)
      {
        switch(GetConnectorEntryType(pgv, ConIdx+j))
        {
          case 0x30:
          case 0x31:
          case 0x38:
          case 0x39:
          case 0x52:
          case 0x53:
          case 0x54:
          case 0x55:
          case 0x61:
            FoundHotplugCapableConnector = 1;
            break;
        }

        HotplugA = GetConnectorEntryHotplugA(pgv, ConIdx+j);
        HotplugB = GetConnectorEntryHotplugB(pgv, ConIdx+j);
        FoundConnectorHotplugA |= HotplugA;
        FoundConnectorHotplugB |= HotplugB;
        if (HotplugA && !FoundGPIOHotplugA)
        {
          // only build failure error on G78+
          if(pgv->Device >= 0x4C)
          {
            dprintf("ERROR: DCB Entry %d/Connector Index %d has Hotplug A defined, but GPIO Hotplug A isn't defined.\n", i, (ConIdx+j));
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }
          else
          {
            dprintf("ERROR: DCB Entry %d/Connector Index %d has Hotplug A defined, but GPIO Hotplug A isn't defined.\n", i, (ConIdx+j));
          }
        }

        if (HotplugB && !FoundGPIOHotplugB)
        {
          // only build failure error on G78+
          if(pgv->Device >= 0x4C)
          {
            dprintf("ERROR: DCB Entry %d/Connector Index %d has Hotplug B defined, but GPIO Hotplug B isn't defined.\n", i, (ConIdx+j));
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }
          else
          {
            dprintf("ERROR: DCB Entry %d/Connector Index %d has Hotplug B defined, but GPIO Hotplug B isn't defined.\n", i, (ConIdx+j));
          }
        }
      }
    }
  }

  // Now check to see if GPIO is defined, but Connector is not
  if (FoundGPIOHotplugA && !FoundConnectorHotplugA)
  {
    // only build failure error on G78+
    if(pgv->Device >= 0x4C)
    {
      dprintf("ERROR: GPIO Table has Hotplug A defined, but Hotplug A isn't defined on any connector.\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
    else
    {
      dprintf("ERROR: GPIO Table has Hotplug A defined, but Hotplug A isn't defined on any connector.\n");
    }
  }

  if (FoundGPIOHotplugB && !FoundConnectorHotplugB)
  {
    // only build failure error on G78+
    if(pgv->Device >= 0x4C)
    {
      dprintf("ERROR: GPIO Table has Hotplug B defined, but Hotplug B isn't defined on any connector.\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
    else
    {
      dprintf("ERROR: GPIO Table has Hotplug B defined, but Hotplug B isn't defined on any connector.\n");
    }
  }

  // If we didn't find any Hotplug, we need to issue an error.
  if ( (FoundHotplugCapableConnector) &&
      !(FoundGPIOHotplugA      ||
        FoundGPIOHotplugB      ||
        FoundConnectorHotplugA ||
        FoundConnectorHotplugB) )
  {
    // only build failure error on G78+
    if(pgv->Device >= 0x4C)
    {
      dprintf("ERROR: Entire DCB has no Hotplugs defined.\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
    else
    {
      dprintf("ERROR: Entire DCB has no Hotplugs defined.\n");
    }
  }

}

void CheckMain(PGV pgv)
{
  dprintf("\n\nNow checking the DCB ...\n");
  if (pgv->filename[0])
  {
    dprintf("  on file: %s\n", pgv->filename);
  }

  // Check to see if this is MXM Default DCB
  // Moved this here for bug 793163
  if ((pgv->bit.MXMConfigFlags0 & 0xC) == 0xC)
  {
    if( pgv->VBIOSCore >= Core84 )
    {
       CheckDP_4x(pgv);
    }
    CheckForValidDCBEntries(pgv);
    dprintf("\n"
            "NOTE: Skip checking the Main DCB Display Path entries since this \n"
            "      rom is an MXM Default DCB.\n\n");
    CheckI2CPort(pgv);
  }
  else
  {
    CheckTypeAndDSI(pgv);
    CheckI2CPort(pgv);
    CheckHeadBitmask(pgv);
    CheckBus(pgv);
    CheckLocation(pgv);
    CheckOutputDevices(pgv);
    CheckForValidDCBEntries(pgv);
  }
  CheckICB(pgv);
  CheckMiscStructure(pgv);

  // Check GPIO assignments if DCB 2.1+ Misc Revision 13 or
  // we're DCB 3.0
  if( pgv->DCBVersion >= 0x40)
  {
    CheckGpioAssignments_4x(pgv);
  }
  else if( (pgv->DCBVersion >= 0x30) ||
           ( (pgv->DCBVersion > 0x21) &&
             (pgv->g2x.MiscVersion >= 0x13) ) )
  {
    CheckGpioAssignments(pgv);
  }

  CheckInputDevices(pgv);

  // Only skip the CheckWBD if this is a simulation/emulation sku.

  CheckVBIOSProduction(pgv);
  if (pgv->VBIOSType == PRODUCTION)
  {
            CheckWBD(pgv);
  }

  // Only check this for MXM skus.
   if ((pgv->bit.MXMConfigFlags0 & 0xC) == 0xC)
   {
      CheckLVDSfirst(pgv);
   }

  // Only check for DCB Version 4.1+
  if (pgv->DCBVersion >= 0x41)
  {
      CheckDPHdmi_4x(pgv);
  }

  CheckConnectorTable(pgv);

  // Check to see if this is not MXM Default DCB
  // Moved this here for bug 793163
  if ((pgv->bit.MXMConfigFlags0 & 0xC) != 0xC)
  {
    if (pgv->DCBVersion >= 0x40)
    {
      CheckHotplug_4x(pgv);

      CheckHdcp_4x(pgv);

      CheckDP_4x(pgv);

      CheckLcdId_4x(pgv);
    }
    else
    {
      CheckHotplug(pgv);
    }

    CheckDacOutputLevelTable(pgv);

#ifdef INTERNAL
    pgv->gIP.CheckBiosStructs(pgv);
#endif
  }

  dprintf("Done!\n\n");
}




/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2002-2016 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

/******************************** DCBChecker *******************************\
*                                                                           *
* Module: dcbbmp.c                                                          *
* This module handles all BMP routines.                                     *
*                                                                           *
* Written by Steve Rogers (srogers@lwpu.com)                              *
* Let me know if you have any questions/comments/suggestions.               *
*                                                                           *
\***************************************************************************/

#ifdef SEPARATE_COMP // Not used in LWwatch compile
#if !defined(LW_MAC_KEXT)
#include <stdio.h>
#include <stdlib.h>
#endif //!defined(LW_MAC_KEXT)
#include <string.h>

#include "dcbchk.h"
#endif //SEPARATE_COMP



// BMP specific helper defines
#define CTRL_BLK_ID                 0x564e7fff
#define MAX_BIOS_SCAN               1024


// Current BMP format offsets - First setup for BMP revision 5.21
#define BMP_OFFSET_CTL_ID                       0     // ID Marker (0x7FFF)
#define BMP_OFFSET_CTL_HEADER                   2     // ID Header ("LW\0")
#define BMP_OFFSET_CTL_VERSION                  5     // Control Block Version
#define BMP_OFFSET_CTL_FLAGS                    6     // Control Block Subversion
#define BMP_OFFSET_CTL_CHKSUM                   7     // Checksum byte for Control Block

#define BMP_OFFSET_BIOS_CHECKSUM                8     // Checksum byte for BIOS
#define BMP_OFFSET_BIOS_FEATURES                9     // BIOS Feature Byte (bitfields)
#define BMP_OFFSET_BIOS_VERSION                 10    // BIOS Version in BCD (Major/Minor/Sub)
#define BMP_OFFSET_BIOS_DRIVERINFO              14    // BIOS Version in BCD (Major/Minor/Sub)

#define BMP_OFFSET_GENINITTABLE                 18    // Offset to the General Initialization Table.
#define BMP_OFFSET_EXTRAINITTABLE               20    // Offset to Extra Initialization Table.
#define BMP_OFFSET_SIZEINITTABLE                22    // Max size of Initialization Table.
#define BMP_OFFSET_MEMINITTABLE                 24    // Offset to the Memory Initialization Table.
#define BMP_OFFSET_SDRSEQUENCETABLE             26    // Offset to the SDR Sequence Table.
#define BMP_OFFSET_DDRSEQUENCETABLE             28    // Offset to the DDR Sequence Table.

#define BMP_OFFSET_SZSIGNONMSG                  30    // Offset to signon string
#define BMP_OFFSET_SIZESIGNONMSG                32    // Current length of signon message

#define BMP_OFFSET_FONTS                        34    // Pointer to pointers to fonts
#define BMP_OFFSET_FONTSIZE                     36    // Size of memory available for all fonts
#define BMP_OFFSET_INITSAVEPTR                  38    // Pointer to initial save pointer area
#define BMP_OFFSET_FUNCTIONALITY                40    // Pointer to functionality table for Function 1Bh
#define BMP_OFFSET_TBLCLOCKMNP                  42    // MNP parameters for clocks

#define BMP_OFFSET_OEMSTRING                    44    // OEM String to identify grahpics controller chip or product family (20)
#define BMP_OFFSET_OEMVENDORNAME                46    // Name of the vendor that produced the display controller board product (35)
#define BMP_OFFSET_OEMPRODUCTNAME               48    // Product name of the controller board (35)
#define BMP_OFFSET_OEMPRODUCTREV                50    // Revision of manufacturing level of the display controller board (30)
#define BMP_OFFSET_FIFOTABLE                    52    // Pointer to DAC/CRTC fifo settings table

#define BMP_OFFSET_CRTI2CPORT                   54    // Default I2C port for CRT
#define BMP_OFFSET_TVI2CPORT                    55    // Default I2C port for TV
#define BMP_OFFSET_DFPI2CPORT                   56    // Default I2C port for Dpgv->FP
#define BMP_OFFSET_RSVDI2CPORT                  57    // Reserved for future expansion
#define BMP_OFFSET_I2CPORT0IO                   58    // Read/Write reg for I2C Port 0
#define BMP_OFFSET_I2CPORT1IO                   60    // Read/Write reg for I2C Port 1

#define BMP_OFFSET_OEMREVISION                  62    // OEM Version Number (00 = Generic)
#define BMP_OFFSET_LCDEDID                      63    // Pointer to LCD_EDID
#define BMP_OFFSET_BMP_FPPARAMS                 65         // Pointer to pgv->FP_Params

#define BMP_OFFSET_FMAXVCO                      67    // Maximum internal PLL frequency
#define BMP_OFFSET_FMILWCO                      71    // Minimum internal PLL frequency

#define BMP_OFFSET_INITSCRIPTTABLEPTR           75    // Init script table pointer
#define BMP_OFFSET_MACROINDEXTABLEPTR           77    // Macro index table pointer
#define BMP_OFFSET_MACROTABLEPTR                79    // Macro table pointer
#define BMP_OFFSET_CONDITIONTABLEPTR            81    // Condition table pointer
#define BMP_OFFSET_IOCONDITIONTABLEPTR          83    // IO Condition table pointer
#define BMP_OFFSET_IOFLAGCONDITIONTABLEPTR      85    // IO Flag Condition table pointer
#define BMP_OFFSET_INITFUNCTIONTABLEPTR         87    // Init function table pointer

#define BMP_OFFSET_TMDSSINGLEAPTR               89    // TMDS single link A table
#define BMP_OFFSET_TMDSSINGLEBPTR               91    // TMDS single link B table
#define BMP_OFFSET_TMDSDUALPTR                  93    // TMDS dual link table
#define BMP_OFFSET_LVDSSINGLEAPTR               95    // LVDS single link A table
#define BMP_OFFSET_LVDSSINGLEBPTR               97    // LVDS single link B table
#define BMP_OFFSET_LVDSDUALPTR                  99    // LVDS dual link table
#define BMP_OFFSET_OFFSINGLEAPTR                101   // LVDS dual link table
#define BMP_OFFSET_OFFSINGLEBPTR                103   // LVDS dual link table

#define BMP_OFFSET_FPTABLEPTR                   105   // Pointer to internal LCD tables
#define BMP_OFFSET_FPXLATETABLEPTR              107   // Pointer to internal LCD translate table

#define BMP_OFFSET_INT15CALLBACKSPOST           109   // INT15 POST Callbacks
#define BMP_OFFSET_INT15CALLBACKSSYSTEM         111   // INT15 SYSTEM Callbacks

#define BMP_OFFSET_DISPLAY_CONFIG_BLOCK         113   // Legacy display config block

#define BMP_OFFSET_DRVSLWPARMS_BLOCK            115   // Drive/slew parameters block

#define BMP_OFFSET_LVDSMANUFACTURERPTR          117   // pointer to internal LCD Manufacturer table
#define BMP_OFFSET_FPXLATEMANUFACTURERTABLEPTR  119   // pointer to internal LCD Manufacturer translate Table
#define BMP_OFFSET_FPXLATEFLAGTABLEPTR          121   // pointer to internal LCD translate Flag Table

#define BMP_OFFSET_LVDSMANUFACTURERSUBVERSION   123   // Subversion of the LCD Manufacturer table
#define BMP_OFFSET_MULTICHIPPRIMARY             124   // PCI Device/Function of the primary chip to boot

#define BMP_OFFSET_VFIELDTABLEPTR               125   // Virtual Strap Field Table Pointer
#define BMP_OFFSET_VFIELDREGTABLEPTR            127   // Virtual Strap Field Register
#define BMP_OFFSET_TRANSLATETABLEPTR            129   // Pointer to XLAT table so virtual straps can be sparse.

#define BMP_OFFSET_PLLREGTABLEPTR               131   // Pointer to table of PLL registers.
#define BMP_OFFSET_CLOCKSCRIPT                  135   // Pointer to script to run after changing clocks.

#define BMP_OFFSET_DCBPOSTALLOWED               139   // Flags to allow selective skipping of DCBs at POST
#define BMP_OFFSET_DCBPOSTMAXHEADS              141   // Max # of heads allowed at POST

#define BMP_OFFSET_MINMAXPLLVCOPTR              142   // Pointer to 2 stage PLL Min/Max VCO values

#define BMP_OFFSET_MINMAXTEMPCNTLPTR            144   // Pointer to board temperature control limits


#define BMP_OFFSET_PRODUCTION_BOARD_INFO_PTR    146   // Pointer to ProductionBoardInfo
#define BMP_OFFSET_PERFORMANCE_LEVEL_TABLE_PTR  148   // Pointer to the Performance Level Table

#define BMP_OFFSET_MEMORY_RESET_TABLE           150   // Memory reset script.  (New for 5.23, but working in 5.24.)

#define BMP_OFFSET_VOLTAGE_VSEL_TABLE           152   // Voltage GPIO table - maps voltages to VSEL settings.  (New for 5.25.)

#define BMP_OFFSET_BOARD_ID                     154   // New to 5.27.
#define BMP_OFFSET_LVDS_DUAL_FREQ               156   // The pixel clock beyond which we consider panel to be dual link.
#define BMP_OFFSET_WFRAME_COUNT                 158   // New to 5.27.


#ifdef INTERNAL

static
void GetBMPHeaderPtr(PGV pgv)
{
  LwU32 i;
  LwU32 CTRLBlockID;

  // OK first we need to search through the entire ROM for the BMP.
  // attempt to find the init info in the BIOS
  for (i = 0; i < MAX_BIOS_SCAN-3; i++)
  {
    pgv->LwrrentFileOffset = i;
    CTRLBlockID = pgv->gIP.GetLwU32(pgv);
    if (CTRLBlockID == CTRL_BLK_ID)
        break;
  }

  if(i == MAX_BIOS_SCAN-3)
    dprintf("DCBCHK: BMP not found!\n");
  else
    pgv->bmp.BMPHeaderPtr = (LwU16) i;
}

static
void DescribeBMP(PGV pgv)
{
  LwU8 Version, Subversion;
  LwU32 bDescribeHeader = 0;

  // Now we need to make sure that the version is OK
  pgv->LwrrentFileOffset = pgv->bmp.BMPHeaderPtr + BMP_OFFSET_CTL_VERSION;
  Version = pgv->gIP.GetLwU8(pgv);
  Subversion = pgv->gIP.GetLwU8(pgv);
  if(Version < 0x4)
    return;

  if(pgv->RuntimeFlags & RT_DESCRIBE)
  {
    // This is only valid for DCB 2.0.  DCB 3.0 holds this information
    // inside it's structure
    if( (pgv->DCBVersion >= 0x20) &&
        (pgv->DCBVersion <  0x30) )
    {
      LwU16 DCBPostAllowed;
      LwU8 DCBPostMaxHeads;

      // DCB Post information was added in 5.21.
      if( (Version < 0x5) ||
          ( (Version == 0x5) && (Subversion < 0x21) ) )
        return;

      pgv->LwrrentFileOffset = pgv->bmp.BMPHeaderPtr + BMP_OFFSET_DCBPOSTALLOWED;
      DCBPostAllowed = pgv->gIP.GetLwU16(pgv);
      DCBPostMaxHeads = pgv->gIP.GetLwU8(pgv);


      if(!bDescribeHeader)
      {
        bDescribeHeader = 1;
        dprintf("BMP Table Information:\n");
      }
      dprintf("  DCB Post Allowed: 0x%x,   DCB Post Max Heads: %d\n",
          DCBPostAllowed, DCBPostMaxHeads);
    }
  }


  if(pgv->DCBVersion < 0x20)
  {
    // Port IDs were added in BMP version 4.0
    if(Version < 0x4)
      return;

    if( (pgv->RuntimeFlags & RT_DESCRIBE) &&
        (!bDescribeHeader) )
    {
      bDescribeHeader = 1;
      dprintf("BMP Table Information:\n");
    }

    pgv->LwrrentFileOffset = pgv->bmp.BMPHeaderPtr + BMP_OFFSET_CRTI2CPORT;
    pgv->bmp.CRTI2CPort  = pgv->gIP.GetLwU8(pgv);
    pgv->bmp.TVI2CPort   = pgv->gIP.GetLwU8(pgv);
    pgv->bmp.DFPI2CPort  = pgv->gIP.GetLwU8(pgv);
    pgv->bmp.RsvdI2CPort = pgv->gIP.GetLwU8(pgv);
    pgv->bmp.I2CPort0IO  = pgv->gIP.GetLwU16(pgv);
    pgv->bmp.I2CPort1IO  = pgv->gIP.GetLwU16(pgv);

    if(pgv->RuntimeFlags & RT_DESCRIBE)
    {
      dprintf("  PortIDs:\n");
      dprintf("    CRT : %d\n", pgv->bmp.CRTI2CPort);
      dprintf("    TV  : %d\n", pgv->bmp.TVI2CPort);
      dprintf("    DFP : %d\n", pgv->bmp.DFPI2CPort);
      dprintf("    Rsvd: %d\n", pgv->bmp.RsvdI2CPort);
      dprintf("      Port 0: %x\n", pgv->bmp.I2CPort0IO);
      dprintf("      Port 1: %x\n", pgv->bmp.I2CPort1IO);
    }
  }
}

static
void DescribeBMPTables(PGV pgv)
{
  DescribeBMP(pgv);
}


static
void CheckBMPTable(PGV pgv)
{
}


void InitializeBiosVersions(PGV pgv)
{
  LwU8 Version, Subversion;

  // Now we need to make sure that the version is OK
  pgv->LwrrentFileOffset = pgv->bmp.BMPHeaderPtr + BMP_OFFSET_CTL_VERSION;

  Version    = pgv->gIP.GetLwU8(pgv);
  Subversion = pgv->gIP.GetLwU8(pgv);

  pgv->LwrrentFileOffset = pgv->bmp.BMPHeaderPtr + BMP_OFFSET_BIOS_VERSION;
  pgv->BiosVersion       = (LwU32) pgv->gIP.GetLwU32(pgv);

  if(Version >= 5)
  {
    pgv->LwrrentFileOffset = pgv->bmp.BMPHeaderPtr + BMP_OFFSET_OEMREVISION;
    pgv->OemVersion        = (LwU8) pgv->gIP.GetLwU8(pgv);
  }
  else if(Version >= 1)
  {
    pgv->OemVersion        = 0;
  }


}


void InitializeBMP(PGV pgv)
{
  GetBMPHeaderPtr(pgv);
  if(pgv->bmp.BMPHeaderPtr == 0)
    return;

  InitializeBiosVersions(pgv);

  pgv->gIP.DescribeBiosStructs = DescribeBMPTables;
  pgv->gIP.CheckBiosStructs    = CheckBMPTable;
}



#endif // INTERNAL



/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2002-2016 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

/******************************** DCBChecker *******************************\
*                                                                           *
* Module: dcbbit.c                                                          *
* This module handles all BIT routines.                                     *
*                                                                           *
* Written by Steve Rogers (srogers@lwpu.com)                              *
* Let me know if you have any questions/comments/suggestions.               *
*                                                                           *
\***************************************************************************/

#ifdef SEPARATE_COMP // Not used in LWwatch compile
#if !defined(LW_MAC_KEXT)
#include <stdio.h>
#include <stdlib.h>
#endif //!defined(LW_MAC_KEXT)
#include <string.h>

#include "dcbchk.h"

#endif //SEPARATE_COMP


#ifdef INTERNAL

#define BIT_HEADER_ID                     0xB8FF
#define BIT_HEADER_SIGNATURE              0x00544942  // "BIT\0"
#define BIT_HEADER_SIZE_OFFSET            8
#define BIT_HEADER_LATEST_KNOWN_VERSION   0x100
#define BIOS_ROM_SIZE_BIT_MAX_LOCATION    0xFFFA


#define BIT_TOKEN_I2C_PTRS          0x32 // '2' I2C Script Pointers
#define BIT_TOKEN_BIOSDATA          0x42 // 'B' BIOS Data
#define BIT_TOKEN_CLOCK_PTRS        0x43 // 'C' Clock Script Pointers
#define BIT_TOKEN_DFP_PTRS          0x44 // 'D' DFP/Panel Data Pointers
#define BIT_TOKEN_LWINIT_PTRS       0x49 // 'I' Initialization Table Pointers
#define BIT_TOKEN_LVDS_PTRS         0x4C // 'L' LVDS Table Pointers
#define BIT_TOKEN_MEMORY_PTRS       0x4D // 'M' Memory Control/Programming Pointers
#define BIT_TOKEN_NOP               0x4E // 'N' No Operation
#define BIT_TOKEN_STRING_PTRS       0x53 // 'S' String Pointers
#define BIT_TOKEN_TMDS_PTRS         0x54 // 'T' TMDS Table Pointers
#define BIT_TOKEN_DISPLAY_PTRS      0x55 // 'U'  Display Control/Programming Pointers
#define BIT_TOKEN_VIRTUAL_PTRS      0x56 // 'V' Virtual Field Pointers
#define BIT_TOKEN_BMP_BIOSDATA_OVL  0x62 // 'b' BMP BIOS Data Overlay
#define BIT_TOKEN_32BIT_PTRS        0x63 // 'c' 32-bit Pointer Data
#define BIT_TOKEN_INTERNAL_USE      0x69 // 'i' Internal Use Only Data
#define BIT_TOKEN_MXM_DATA          0x78 // 'x' MXM Configuration Data


void GetBITHeaderPtr(PGV pgv)
{
  LwU32 i, j;
  LwU16 BitHeader;
  LwU32 BitSignature;
  LwU32 chksum, HeaderSize;

  // OK first we need to search through the entire ROM for the BMP.
  // attempt to find the init info in the BIOS
  for (i = 0; i < BIOS_ROM_SIZE_BIT_MAX_LOCATION; i++)
  {
    pgv->LwrrentFileOffset = i;
    BitHeader    = pgv->gIP.GetLwU16(pgv);
    BitSignature = pgv->gIP.GetLwU32(pgv);
    if ( (BitHeader    == BIT_HEADER_ID) &&
         (BitSignature == BIT_HEADER_SIGNATURE) )
        break;
  }

  if(i == BIOS_ROM_SIZE_BIT_MAX_LOCATION)
    return;
  else
  {
    // OK.. make sure the chksum works
    chksum = 0;

    pgv->LwrrentFileOffset = i+BIT_HEADER_SIZE_OFFSET;
    HeaderSize = (LwU32) pgv->gIP.GetLwU8(pgv);

    pgv->LwrrentFileOffset = i;
    for(j=0; j<HeaderSize; j++)
      chksum += (LwU32) pgv->gIP.GetLwU8(pgv);

    //Byte checksum removes upper bytes
    chksum = chksum & 0xFF;

    if(chksum)
      return;

    // check sum is valid, store the pointer
    pgv->bit.BITHeaderPtr = (LwU16) i;
  }
}


static
void DescribeBITTables(PGV pgv)
{
}

static
void CheckBITTable(PGV pgv)
{
  // As of at least 2005-02-18, initchk should be checking
  // these same issues.  So, I'm removing the calls
  //CheckPerfTable(pgv);
  //CheckVoltageTable(pgv);
}

//
//
// HISTORY:
//
// TV Connector Count was originally [mis]defined at bits [17:16] when 'dcbdef30.scp' was originally added to Core4R2 in the following change to begin development of DCB 3.0 support.
//
//   Change 773970 by ikasprzak@ikasprzak-TOTmb2 on 2003/07/02 14:14:34
//
// The definition was later supposed to be corrected, but was only shifted one bit to [18:17] instead of 5 bits to [22:21], even though the comment was correctly updated to state [22:21].  That is an easy mistake to make (a matter of forgetting to add a zero).
//
//   Change 813803 by ikasprzak@ikasprzak-DCBmb2 on 2003/08/05 17:41:41
//
//     Core4R2: DCB 3.0 Update TV and LCD/DFP DSI fields so the following fields are common:
//     Encoder/Ext. Chip Type 15:8
//     Ext. Comm I2C Speed Level 19:16
//     Ext. Comm Port 20:20
//
//     This matches the updated DCB 3.0 spec.
//
//     (Tested and reviewed by Jim)
//
// This is all well before we actually ever use the definition to populate the Connector Count, or even populated the connector table.
//
// A. Change 1151159 is the first change that uses Connector Count [incorrectly]
//
// B. Change 1275851 correctly defines Connector Count in Core5
//    Change 1276088 is the integration to Core5R2
//    Change 1276089 is the integration to Core6
//    No Core5R2 or Core6 releases oclwrred between 1275851 and 1276089
//
// C. I2C Speed was never used between A and B.
//
LwU32 getTVConnectorCount_3x_Broken(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)>> 17)&0x03)+1;
}

void InitializeBIT(PGV pgv)
{
  LwU32 i;
  LwU32 hSize, tSize, tCount;
  LwU32 tdId, tdVersion, tdSize, tdPtr;

  GetBITHeaderPtr(pgv);
  if(pgv->bit.BITHeaderPtr == 0)
  {
    InitializeBMP(pgv);
    return;
  }

  // OK now search through the bit tokens to find
  // whatever information we need
  pgv->LwrrentFileOffset = pgv->bit.BITHeaderPtr + BIT_HEADER_SIZE_OFFSET;
  hSize  = (LwU32) pgv->gIP.GetLwU8(pgv);
  tSize  = (LwU32) pgv->gIP.GetLwU8(pgv);
  tCount = (LwU32) pgv->gIP.GetLwU8(pgv);


  for(i=0; i<tCount; i++)
  {
    pgv->LwrrentFileOffset = pgv->bit.BITHeaderPtr +
                              hSize + i*tSize;
    tdId      = (LwU32) pgv->gIP.GetLwU8(pgv);
    tdVersion = (LwU32) pgv->gIP.GetLwU8(pgv);
    tdSize    = (LwU32) pgv->gIP.GetLwU16(pgv);
    tdPtr     = (LwU32) pgv->gIP.GetLwU16(pgv);

    switch(tdId)
    {
    case BIT_TOKEN_BIOSDATA:
      pgv->LwrrentFileOffset     = tdPtr;
      pgv->BiosVersion           = (LwU32) pgv->gIP.GetLwU32(pgv);
      pgv->OemVersion            = (LwU8) pgv->gIP.GetLwU8(pgv);
      break;
    case BIT_TOKEN_INTERNAL_USE:
      {
        LwU32 P4MagicNumber = 0;
        // Grab the p4 magic number
        pgv->LwrrentFileOffset = tdPtr+7;
        P4MagicNumber = pgv->gIP.GetLwU32(pgv);

        if (P4MagicNumber < 1275851)
        {
          pgv->g3x.GetTVConnectorCount = getTVConnectorCount_3x_Broken;
        }
      }

      // Use this token to figure out which chip we're really running here.
      if( (tdVersion == 2) && (tdSize >= 25) )
      {
        LwU32 PCIDevID = 0;

        // Point to the bGpuDevID field
        pgv->LwrrentFileOffset = tdPtr+23;
        PCIDevID = pgv->gIP.GetLwU16(pgv);
        if(PCIDevID)
          TranslateDevice(pgv, PCIDevID);
      }
      break;

    case BIT_TOKEN_MXM_DATA:

      // Only handle version 1 for now.
      if(tdVersion > 1)
        break;

      // We only need the 3rd byte offset in this table.
      pgv->LwrrentFileOffset     = tdPtr+2;

      // Read in the config flags
      pgv->bit.MXMConfigFlags0   = (LwU8) pgv->gIP.GetLwU8(pgv);

      break;

    case BIT_TOKEN_DISPLAY_PTRS:

      // Read in the display control flags field for WBD checking
      pgv->LwrrentFileOffset     = tdPtr + DISPLAY_CONTROL_FLAG_OFFSET;
      pgv->DisplayControlFlags   = (LwU8) pgv->gIP.GetLwU8(pgv);

      break;
    }
  }

  pgv->gIP.DescribeBiosStructs = DescribeBITTables;
  pgv->gIP.CheckBiosStructs    = CheckBITTable;
}

#endif // INTERNAL

/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2002-2003 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

/******************************** DCBChecker *******************************\
*                                                                           *
* Module: dcbi2c.c                                                          *
* This module handles all I2C generic routines                              *
*                                                                           *
* Written by Steve Rogers (srogers@lwpu.com)                              *
* Let me know if you have any questions/comments/suggestions.               *
*                                                                           *
\***************************************************************************/

#ifdef SEPARATE_COMP // Not used in LWwatch compile
#if !defined(LW_MAC_KEXT)
#include <stdio.h>
#include <stdlib.h>
#endif //!defined(LW_MAC_KEXT)
#include <string.h>

#include "dcbchk.h"
#endif //SEPARATE_COMP



LwU32 GetI2CAccess_1x(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 Access = (rec>>24)&0xFF;
  return Access;    
}

LwU32 GetI2CAccess_41(PGV pgv, LwU32 idx)
{
  // DCB 4.1 only has one type of ccb entry, so it deprecated the "i2c access" field.
  // Using a hardcoded value to represent the hardcoded ccb entry type.
  return 0x50;    
}

LwU32 GetI2CCRTCReadPort(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 ReadPort = (rec>>8)&0xFF;
  return ReadPort;    
}

LwU32 GetI2CCRTCWritePort(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 WritePort = (rec)&0xFF;
  return WritePort;    
}

LwU32 GetI2CDirIOReadPort(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 IOReadPort = ((rec>>8)&0xFF) | ((rec>>8)&0xFF00);
  return IOReadPort;    
}

LwU32 GetI2CDirIOWritePort(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 IOWritePort = ((rec)&0xFF) | ((rec>>8)&0xFF00);
  return IOWritePort;    
}

LwU32 GetI2CPCIBus(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 PCIBus = (rec)&0x7;
  return PCIBus;    
}

LwU32 GetI2CPCIDevice(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 PCIDevice = (rec>>3)&0x1F;
  return PCIDevice;    
}

LwU32 GetI2CPCIFunction(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 PCIFunction = (rec>>8)&0x7;
  return PCIFunction;    
}

LwU32 GetI2CPCIBar(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 PCIBar = (rec>>11)&0x7;
  return PCIBar;    
}

LwU32 GetI2CPCIType(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 PCIType = (rec>>14)&0x3;
  return PCIType;    
}

LwU32 GetI2CPCIOffset(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 PCIOffset = (rec>>16)&0xFF;
  return PCIOffset;    
}

LwU32 GetI2CMMPhysicalPort(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 PhysPort = (rec)&0xFF;
  return PhysPort;    
}

LwU32 GetI2CMMIOReadPortAddr(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 PhysPort = (rec>>8)&0xFFFF;
  return PhysPort;    
}

LwU32 GetI2CPMGRPhysicalPort(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 PhysPort = (rec)&0xF;
  return PhysPort;    
}

LwU32 GetI2CPMGRPortSpeed(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 PhysPort = (rec>>4)&0xF;
  return PhysPort;    
}

LwU32 GetI2CPMGRPortHybridPad_4x(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 PhysPort = (rec>>8)&0x1;
  return PhysPort;    
}

LwU32 GetI2CPMGRPortDPPort_4x(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 PhysPort = (rec>>9)&0xF;
  return PhysPort;    
}

LwU32 GetCommDpAuxPhysicalPort(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 PhysPort = (rec)&0xF;
  return PhysPort;    
}

LwU32 GetCommDpAuxHybridPad_4x(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 PhysPort = (rec>>8)&0x1;
  return PhysPort;    
}

LwU32 GetDPPMGRPortI2CPort_4x(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 PhysPort = (rec>>9)&0xF;
  return PhysPort;    
}

LwU32 GetCCBI2CPort(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 PhysPort = (rec)&0x1F;
  return PhysPort;    
}
LwU32 GetCCBI2CPortSpeed(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 PhysPort = (rec>>28)&0xF;
  return PhysPort;    
}

LwU32 GetCCBDPPort(PGV pgv, LwU32 idx)
{
  LwU32 rec = pgv->gIP.GetI2CRec(pgv, idx);
  LwU32 PhysPort = (rec>>5)&0x1F;
  return PhysPort;    
}

/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2002-2003 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

/******************************** DCBChecker *******************************\
*                                                                           *
* Module: dcb1x.c                                                           *
* This module handles all DCB 1X routines.                                  *
*                                                                           *
* Written by Steve Rogers (srogers@lwpu.com)                              *
* Let me know if you have any questions/comments/suggestions.               *
*                                                                           *
\***************************************************************************/

#ifdef SEPARATE_COMP // Not used in LWwatch compile
#if !defined(LW_MAC_KEXT)
#include <stdio.h>
#include <stdlib.h>
#endif //!defined(LW_MAC_KEXT)
#include <string.h>

#include "dcbchk.h"
#endif //SEPARATE_COMP

#ifdef INTERNAL
LwU32 getDevRec_1x(PGV pgv, LwU32 idx)
{
  pgv->LwrrentFileOffset = pgv->DCBEntryBase + idx*pgv->DCBEntrySize;
  return pgv->gIP.GetLwU32(pgv);
}

// DCB 1.x retrieval fucntions
LwU32 getType_1X(PGV pgv, LwU32 idx)
{
  LwU32 Type = 0;
  LwU32 DevRec = getDevRec_1x(pgv, idx);
  Type = (DevRec & 0xF);
  switch(Type)
  {
    case 2:
    case 3:
    case 4:
      // Look at subtype next
      switch((DevRec>>4)&0xF)
      {
        case 0: Type = TYPE_TMDS; break;
        case 1: Type = TYPE_LVDS; break;
        default:
          // Only LW11 really has LVDS support
          // An only if the I2C Port was >= 2.
          if(pgv->Device != 0x11)
            Type = TYPE_TMDS;
          else if(pgv->gIP.GetI2CPort(pgv, idx) > 2)
            Type = TYPE_LVDS;
          else
            Type = TYPE_TMDS;
      }
      break;
  }

  return Type;  
}

LwU32 getI2CPort_1X(PGV pgv, LwU32 idx)
{
  return ((getDevRec_1x(pgv, idx)>>14) & 0xF);
}

LwU32 getHeadMask_1X(PGV pgv, LwU32 idx)
{
  return BIT((getDevRec_1x(pgv, idx)>>18) & 0x7);
}

LwU32 getBus_1X(PGV pgv, LwU32 idx)
{
  return ((getDevRec_1x(pgv, idx)>>25) & 0x7);
}

LwU32 getLocation_1X(PGV pgv, LwU32 idx)
{
  LwU32 DevRec = 0;
  LwU32 Location = 0;
  DevRec = getDevRec_1x(pgv, idx);
  Location = (DevRec>>21) & 0xF;
  if(Location > LOCATION_BOARD)
  {
    if(pgv->gIP.GetType(pgv, idx) == TYPE_CRT)
    {
      // LW11 only had one internal DAC on Head A
      if( (pgv->Device == 0x11) && 
          (pgv->gIP.GetHeadMask(pgv, idx) == HEADMASK_B) )
        Location = LOCATION_BOARD;
      else
        Location = LOCATION_CHIP;
    }
    else
      Location = LOCATION_BOARD;
    
  }
  return Location;
}

LwU16 getDataPtr(PGV pgv, LwU32 idx)
{
  pgv->LwrrentFileOffset = pgv->DCBEntryBase + idx*pgv->DCBEntrySize + 4;
  return pgv->gIP.GetLwU16(pgv);
}


LwU32 getOutput_1X(PGV pgv, LwU32 idx)
{
  LwU32 DataPtr = getDataPtr(pgv, idx);
  LwU32 Output  = DataPtr & 0xFF;
  if(DataPtr == 0xFFFF)
  {
    // Use heuristics to determine this value
    if(pgv->gIP.GetLocation(pgv, idx) == LOCATION_CHIP)
    {
      switch(pgv->gIP.GetType(pgv, idx))
      {
        case TYPE_LVDS: Output = OUTPUT_LINK_AB; break;
        case TYPE_TMDS: Output = OUTPUT_LINK_A;  break;
        default:
          if(pgv->gIP.GetHeadMask(pgv, idx) == HEADMASK_B)
            Output = OUTPUT_DAC_B;
          else
            Output = OUTPUT_DAC_A;
          break;
      }
    }
    else 
      // We know it's external here ...
      Output = OUTPUT_MIO_A;
  }

  return Output;
}


LwU32 getDataDword_1x(PGV pgv, LwU32 idx)
{
  LwU32 DataDword = 0;
  pgv->LwrrentFileOffset = pgv->DCBEntryBase + idx*pgv->DCBEntrySize + 6;
  DataDword = pgv->gIP.GetLwU32(pgv);
  return DataDword;
}

LwU32 getCRTMaxFreq_1x(PGV pgv, LwU32 idx)
{
  return ((getDataDword_1x(pgv, idx)&0xFFFFF)/100);  
}

LwU32 getLCDDDC_1x(PGV pgv, LwU32 idx)
{
  LwU32 lcdEdid = 0;

  if(pgv->gIP.GetType(pgv, idx) == TYPE_LVDS)
    lcdEdid = 1;

  switch(getDevRec_1x(pgv, idx) & 0x3F00)
  {
    case 0x1000:  lcdEdid = 0; break;
    case 0x1F00:  lcdEdid = 1; break;
  }

  return lcdEdid;
}

LwU32 getLCDControl_1x(PGV pgv, LwU32 idx)
{
  return (pgv->gIP.GetType(pgv, idx) == TYPE_LVDS);
}

LwU32 getLCDExtType_1x(PGV pgv, LwU32 idx)
{
  return 0;
}


LwU32 getTVFamily_1x(PGV pgv, LwU32 idx)
{
  return ((getDevRec_1x(pgv, idx)>>4)&0xF);
}

LwU32 getTVFormat_1x(PGV pgv, LwU32 idx)
{
  return ((getDevRec_1x(pgv, idx)>>8)&0x3F);
}

LwU32 getTVDACs_1x(PGV pgv, LwU32 idx)
{
  return 0;
}

LwU32 getI2CRec_1x(PGV pgv, LwU32 idx)
{
  LwU32 I2C1xRec = 0, I2CRec;
  LwU32 Access, ReadPort, WritePort, IOPortHi;
  pgv->LwrrentFileOffset = pgv->I2CEntryBase + idx*4;
  I2C1xRec = pgv->gIP.GetLwU32(pgv);

  Access    = (I2C1xRec>>24)&0x7;
  ReadPort  = (I2C1xRec>>8) &0xFF;
  WritePort = (I2C1xRec   ) &0xFF;
  IOPortHi  = (I2C1xRec>>16)&0xFF;


  if(Access == 0x7)
  {
    I2CRec = 0xFFFFFFFF;
  }
  else if(Access == 0x0)
  {
    I2CRec = WritePort | (ReadPort<<8);
  }
  else
  {
    I2CRec =  WritePort      |
              (ReadPort<<8)  |
              (IOPortHi<<16) |
              (Access  <<24);
  }

  return I2CRec;
}

void strcatTVEncoderName_1x(PGV pgv, LwU32 idx, char*str)
{
  switch(pgv->gIP.GetTVFamily(pgv, idx))
  {
    case 0x0: strcpy(str, "BT"MYFS); break;
    case 0x1: strcat(str, "CH"MYFS); break;
    case 0x2: strcat(str, "PH"MYFS); break;
    default:  strcat(str, "??"MYFS); break;
  }
}

void strcatLCDEncoderName_1x(PGV pgv, LwU32 idx, char*str)
{
  return;
}

void getMiscStr_1x(PGV pgv, LwU32 idx, char*str)
{
  char Misc[MISC_STR_SPACE*2] = {0};

  strcatMiscStr_Generic(pgv, idx, Misc);

  if(strlen(Misc) > MISC_STR_SPACE)
  {
    dprintf("DCBCHK: Misc string space is too long.  Cropping to %d.\n", MISC_STR_SPACE);
    Misc[MISC_STR_SPACE-1] = '\0';
  }

  strcpy(str, Misc);
}

void DescribeMisc_1x(PGV pgv)
{
}

void DescribeTables_1x(PGV pgv)
{
}

void InitializeDCB1XData(PGV pgv)
{
  // Initialize base pointers 
  pgv->LwrrentFileOffset = pgv->DCBHeaderPtr+2;
  pgv->DCBEntryBase = pgv->DCBHeaderPtr+4;
  pgv->DCBEntrySize = 10;
  pgv->I2CEntryBase = pgv->gIP.GetLwU16(pgv);
  pgv->I2CEntrySize = 4;

  // intitialize function pointers
  pgv->gIP.GetType         = getType_1X;
  pgv->gIP.GetHeadMask     = getHeadMask_1X;
  pgv->gIP.GetI2CPort      = getI2CPort_1X;
  pgv->gIP.GetBus          = getBus_1X;
  pgv->gIP.GetLocation     = getLocation_1X;
  pgv->gIP.GetOutput       = getOutput_1X;
  pgv->gIP.GetI2CRec       = getI2CRec_1x;
  pgv->gIP.GetI2CAccess    = GetI2CAccess_1x;

  // initialize Generic Device Specific Information
  pgv->gIP.GetCRTMaxFreq   = getCRTMaxFreq_1x;
  pgv->gIP.GetLCDDDC       = getLCDDDC_1x;
  pgv->gIP.GetLCDControl   = getLCDControl_1x;
  pgv->gIP.GetLCDExtType   = getLCDExtType_1x;
  pgv->gIP.GetTVFamily     = getTVFamily_1x;
  pgv->gIP.GetTVFormat     = getTVFormat_1x;
  pgv->gIP.GetTVDACs       = getTVDACs_1x;

  // initialize string and describe functions
  pgv->gIP.strcatLCDEncoderName = strcatLCDEncoderName_1x;
  pgv->gIP.strcatTVEncoderName  = strcatTVEncoderName_1x;
  pgv->gIP.GetMiscStr           = getMiscStr_1x;
  pgv->gIP.DescribeMisc         = DescribeMisc_1x;
  pgv->gIP.DescribeTables       = DescribeTables_1x;

  // Count number of entries here:
  // Get DCB Entry Count
  for(pgv->DCBEntryCount=0; pgv->DCBEntryCount<16; pgv->DCBEntryCount++)
  {
    if(pgv->gIP.GetType(pgv, pgv->DCBEntryCount) == TYPE_EOF)
      break;
  }

  if( (pgv->DCBVersion == 0x14) &&
      (pgv->DCBEntryCount == 1) )
  {
    dprintf("\nFound DCB 1.4 Version with only 1 device.\n");
    dprintf("Default DCB stored in the driver will be used.\n");
    dprintf("Exiting ...\n\n");
    LW_FCLOSE(pgv);
    pgv->exitValue = 4;
    return;
  }

  // Get I2C Entry Count
  for(pgv->I2CEntryCount=0; pgv->I2CEntryCount<16; pgv->I2CEntryCount++)
  {
    if(pgv->gIP.GetI2CAccess(pgv, pgv->I2CEntryCount) == ICB_ACCESS_EOF)
      break;
  }
}

#endif



/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2002-2019 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

/******************************** DCBChecker *******************************\
*                                                                           *
* Module: dcb2x.c                                                           *
* This module handles all DCB 2X routines.                                  *
*                                                                           *
* Written by Steve Rogers (srogers@lwpu.com)                              *
* Let me know if you have any questions/comments/suggestions.               *
*                                                                           *
\***************************************************************************/

#ifdef SEPARATE_COMP // Not used in LWwatch compile
#if !defined(LW_MAC_KEXT)
#include <stdio.h>
#include <stdlib.h>
#endif //!defined(LW_MAC_KEXT)
#include <string.h>

#include "dcbchk.h"
#endif //SEPARATE_COMP

LwU32 getDisplayPath_2x(PGV pgv, LwU32 idx)
{
  pgv->LwrrentFileOffset = pgv->DCBEntryBase + idx*pgv->DCBEntrySize;
  return pgv->gIP.GetLwU32(pgv);
}

LwU32 getType_2x(PGV pgv, LwU32 idx)
{
  return (getDisplayPath_2x(pgv, idx) & 0xF);
}

LwU32 getI2CPort_2x(PGV pgv, LwU32 idx)
{
  return ((getDisplayPath_2x(pgv, idx)>>4) & 0xF);
}

LwU32 getHeadMask_2x(PGV pgv, LwU32 idx)
{
  return ((getDisplayPath_2x(pgv, idx)>>8) & 0xFF);
}

LwU32 getBus_2x(PGV pgv, LwU32 idx)
{
  return ((getDisplayPath_2x(pgv, idx)>>16) & 0xF);
}

LwU32 getLocation_2x(PGV pgv, LwU32 idx)
{
  return ((getDisplayPath_2x(pgv, idx)>>20) & 0xF);
}

LwU32 getOutput_2x(PGV pgv, LwU32 idx)
{
  return ((getDisplayPath_2x(pgv, idx)>>24) & 0xFF);
}

LwU32 getDSI_2x(PGV pgv, LwU32 idx)
{
  pgv->LwrrentFileOffset = pgv->DCBEntryBase + idx*pgv->DCBEntrySize + 4;
  return pgv->gIP.GetLwU32(pgv);
}

LwU32 getCRTMaxFreq_2x(PGV pgv, LwU32 idx)
{
  return ((getDSI_2x(pgv, idx)&0xFFFFF)/100);
}

LwU32 getLCDDDC_2x    (PGV pgv, LwU32 idx)
{
  return ((getDSI_2x(pgv, idx)   )&0x3);
}

LwU32 getLCDControl_2x(PGV pgv, LwU32 idx)
{
  return ((getDSI_2x(pgv, idx)>> 2)&0x3);
}

LwU32 getLCDExtType_2x(PGV pgv, LwU32 idx)
{
  return ((getDSI_2x(pgv, idx)>> 4)&0xF);
}

LwU32 getTVFamily_2x  (PGV pgv, LwU32 idx)
{
  return ((getDSI_2x(pgv, idx)    )&0xF);
}

LwU32 getTVFormat_2x  (PGV pgv, LwU32 idx)
{
  return ((getDSI_2x(pgv, idx)>> 4)&0xF);
}

LwU32 getTVDACs_2x    (PGV pgv, LwU32 idx)
{
  return ((getDSI_2x(pgv, idx)>> 8)&0x0F) |
         ((getDSI_2x(pgv, idx)>>12)&0xF0);
}

LwU32 getTVModel_2x   (PGV pgv, LwU32 idx)
{
  return ((getDSI_2x(pgv, idx)>>12)&0xF);
}



LwU32 getI2CRec_2x(PGV pgv, LwU32 idx)
{
  pgv->LwrrentFileOffset = pgv->I2CEntryBase + idx*pgv->I2CEntrySize;
  return pgv->gIP.GetLwU32(pgv);
}


void strcatTVEncoderName_2x(PGV pgv, LwU32 idx, char*str)
{
  switch(pgv->gIP.GetTVFamily(pgv, idx))
  {
    case 0x0: strcpy(str, "BT"MYFS); break;
    case 0x1:
      if(getTVModel_2x(pgv, idx) == 0x1)
              strcat(str, "CH7019"MYFS);
      else
              strcat(str, "CH"MYFS);
      break;
    case 0x2: strcat(str, "PH"MYFS); break;
    case 0x3: strcat(str, "NZ"MYFS); break;
    default:  strcat(str, "??"MYFS); break;
  }
}
void strcatLCDEncoderName_2x(PGV pgv, LwU32 idx, char*str)
{
  char spfvar[16] = {0};

  if( (pgv->DCBVersion >= 0x22) &&
      (pgv->gIP.GetLocation(pgv, idx) == LOCATION_BOARD) )
  {
    switch(getLCDExtType_2x(pgv, idx))
    {
      case 0x0: strcat(str, MYFS"Default");   break;
      case 0x1: strcat(str, MYFS"SI164");     break;
      case 0x2: strcat(str, MYFS"SI178");     break;
      case 0x3: strcat(str, MYFS"2xSI178");   break;
      case 0x4: strcat(str, MYFS"CH7009");    break;
      case 0x5: strcat(str, MYFS"CH7019");    break;
      case 0x6: strcat(str, MYFS"DS90C387");  break;
      case 0x7: strcat(str, MYFS"ALTSI164");  break;
      case 0x8: strcat(str, MYFS"CH7301");    break;
      case 0x9: strcat(str, MYFS"ALTSI1162"); break;
      case 0xA: strcat(str, MYFS"ANX9801");   break;
      case 0xB: strcat(str, MYFS"PTDP501");   break;
      case 0xC: strcat(str, MYFS"AX9805");    break;
      case 0xD: strcat(str, MYFS"ALTAX9805"); break;
      default:
        strcat(str, MYFS);
        sprintf(spfvar, "?0x%x?", (int)getLCDExtType_2x(pgv, idx));
        strcat(str, spfvar);
        break;
    }
  }
}


void getMiscStr_2x(PGV pgv, LwU32 idx, char*str)
{
  char Misc[MISC_STR_SPACE*2] = {0};
  char spfvar[16] = {0};
  LwU32 dsi = getDSI_2x(pgv, idx);

  strcatMiscStr_Generic(pgv, idx, Misc);

  // Handle DCB 2.X Hotplug data
  if(dsi&0x300000)
  {
    strcat(Misc, MYFS"HP:");
    switch(dsi&0x300000)
    {
      case 0x100000: strcat(Misc, "A,");  break;
      case 0x200000: strcat(Misc, "D,");  break;
      case 0x300000: strcat(Misc, "AD,"); break;
    }

    // DCB versions <= 2.2 had more bits defined for Hotplug
    if(pgv->DCBVersion <= 0x22)
    {
      if(dsi&0x100000)
      {
        if(dsi&0x400000)
          strcat(Misc, "A+");
        else
          strcat(Misc, "A-");
      }

      if(dsi&0x200000)
      {
        if(dsi&0x800000)
          strcat(Misc, "D+,");
        else
          strcat(Misc, "D-,");
      }

      if(dsi&0x100000)
      {
        sprintf(spfvar, "A#%d", (int)((dsi&0xF000000)>>24));
        strcat(Misc, spfvar);
      }

      if((dsi&0x300000) == 0x300000)
        strcat(Misc, ",");

      if(dsi&0x200000)
      {
        sprintf(spfvar, "D#%d", (int)((dsi&0xF0000000)>>28));
        strcat(Misc, spfvar);
      }
    } // end of DCB Revsion <= 2.2
    else
    {
      // DCB Revision >= 2.3
      if(dsi&0x400000)
        strcat(Misc, "Pol+,");
      else
        strcat(Misc, "Pol-,");

      sprintf(spfvar, "GPIO#%d", (int)((dsi&0xF000000)>>24));
      strcat(Misc, spfvar);
    }

  }

  if(strlen(Misc) > MISC_STR_SPACE)
  {
    dprintf("DCBCHK: Misc string space is too long.  Cropping to %d.\n", MISC_STR_SPACE);
    Misc[MISC_STR_SPACE-1] = '\0';
  }

  strcpy(str, Misc);
}

void DescribeMisc_2x(PGV pgv)
{
  if(pgv->DCBVersion < 0x21)
    return;

  dprintf("Misc Struct: Revision: 0x%02x\n", pgv->g2x.MiscVersion);
  if(pgv->g2x.DACBSwitch&1)
  {
    dprintf("  DAC B Mux: Yes CRT Pol:%s  Alt-Det GPIO:%d  Sel GPIO:%d\n",
           ((pgv->g2x.DACBSwitch&0x2) ? "+":"-"),
           (pgv->g2x.DACBGPIO&0xF),
           ((pgv->g2x.DACBGPIO>>4)&0xF));
  }
#ifdef INTERNAL
  else if(pgv->RuntimeFlags & RT_VERBOSE)
  {
    dprintf("  DAC B Mux: NOT SUPPORTED! CRT Pol:%s  Alt-Det GPIO:%d  Sel GPIO:%d\n",
           ((pgv->g2x.DACBSwitch&0x2) ? "+":"-"),
           (pgv->g2x.DACBGPIO&0xF),
           ((pgv->g2x.DACBGPIO>>4)&0xF));
  }
#endif

  if(pgv->g2x.StereoGlasses&0x1)
  {
    dprintf("  Stereo Support: Yes  GPIO:%d\n", ((pgv->g2x.StereoGlasses>>4)&0xF));
  }
#ifdef INTERNAL
  else if(pgv->RuntimeFlags & RT_VERBOSE)
  {
    dprintf("  Stereo Support: NOT SUPPORTED!  Stereo GPIO:%d\n", ((pgv->g2x.StereoGlasses>>4)&0xF));
  }
#endif

  if(pgv->g2x.StereoGlasses&0x6)
  {
    dprintf("  HDTV: ");
    if(pgv->g2x.StereoGlasses&0x2)
    {
      dprintf("PCA9555 ");
      if(pgv->g2x.StereoGlasses&0x4)
      {
        dprintf("+ ");
      }
    }
    if(pgv->g2x.StereoGlasses&0x4)
    {
      dprintf("EEPROM");
    }
    dprintf("\n");
  }
  else if(pgv->RuntimeFlags & RT_VERBOSE)
  {
    dprintf("  NO HDTV PCA9555 or EEPROM\n");
  }

  if(pgv->g2x.MiscVersion >= 0x11)
  {
    switch(pgv->g2x.ThermalTypePort&0xF)
    {
      case 1:  dprintf("  Thermal Diode: ADM 1032     "); break;
      case 2:  dprintf("  Thermal Diode: MAX 6649     "); break;
      case 3:  dprintf("  Thermal Diode: LM 99        "); break;
      case 4:  dprintf("  Thermal Diode: SMB MAX 6649 "); break;
      case 5:  dprintf("  Thermal Diode: VBIOS Event  "); break;
      case 6:  dprintf("  Thermal Diode: MAX 1617     "); break;
      case 7:  dprintf("  Thermal Diode: LM 64        "); break;
      case 8:  dprintf("  Thermal Diode: OS control   "); break;
      case 0:
#ifdef INTERNAL
      if(pgv->RuntimeFlags & RT_VERBOSE)
               dprintf("  Thermal Diode: NONE!!!   ");
#endif
      break;
      default: dprintf("  Thermal Diode: ???%d???      ", pgv->g2x.ThermalTypePort&0xF); break;
      break;
    }
    if( ((pgv->g2x.ThermalTypePort&0xF) == 4) &&
       !(pgv->RuntimeFlags & RT_VERBOSE) )
      dprintf("\n");
    else if( ((pgv->g2x.ThermalTypePort&0xF) != 0) ||
             (pgv->RuntimeFlags & RT_VERBOSE) )
      dprintf("I2C Port:%c  I2C Addr:0x%02x\n",
              GetCharPerValueWithMax( ((pgv->g2x.ThermalTypePort>>4)&0xF), pgv->I2CEntryCount, '?'),
              pgv->g2x.ThermalI2CAddr);
  } // end of revision 11 additions.

  // print out revision 15 additions
  if(pgv->g2x.MiscVersion >= 0x15)
  {
    if( ((pgv->g2x.DACBSwitch>>4)&0xF) ||
        (pgv->RuntimeFlags & RT_VERBOSE) )
    {
      dprintf("  HW Monitor: ");
      switch((pgv->g2x.DACBSwitch>>4)&0xF)
      {
        case 0:  dprintf("NONE!!    "); break;
        case 1:  dprintf("W83L785R  "); break;
        default: dprintf("???%d???   ",((pgv->g2x.DACBSwitch>>4)&0xF)); break;
      }
      dprintf("I2C Addr:0x%02x\n",
              pgv->g2x.ExtHwMonitorI2C);
    }
  } // end of revision 15 additions.

  // print out revision 12 additions
  // Since Rev 12 only added SpreadSpectrumDevices byte,
  // this has been overwritten with Spread Spectrum Device Mask
  // added in MiscRevision 14.
  if( (pgv->RuntimeFlags & RT_VERBOSE) ||
      ( (pgv->g2x.MiscVersion >= 0x12) &&
        ( (pgv->g2x.MiscVersion < 0x14) ||
          ((pgv->g2x.SSDeviceMask & 0x11111111) == 0) ) ) )
  {
    if(pgv->g2x.SSDevices)
    {
      dprintf("  Spread Spectrum:");

      if( (pgv->g2x.SSDevices & 0x11) == 0x11)  dprintf("Int+Ext.LVDS");
      else if (pgv->g2x.SSDevices & 0x1)        dprintf("Int.LVDS");
      else if (pgv->g2x.SSDevices & 0x10)       dprintf("Ext.LVDS");

      // Add separator if necessary
      if(pgv->g2x.SSDevices & 0xCC)             dprintf(MYFS);

      if( (pgv->g2x.SSDevices & 0x44) == 0x44)  dprintf("Int+Ext.TV");
      else if (pgv->g2x.SSDevices & 0x4)        dprintf("Int.TV");
      else if (pgv->g2x.SSDevices & 0x40)       dprintf("Ext.TV");

      // Add separator if necessary
      if( (pgv->g2x.SSDevices & 0x88) &&
          (pgv->g2x.SSDevices & 0x44) )         dprintf(MYFS);


      if( (pgv->g2x.SSDevices & 0x88) == 0x88)  dprintf("Int+Ext.TMDS");
      else if (pgv->g2x.SSDevices & 0x8)        dprintf("Int.TMDS");
      else if (pgv->g2x.SSDevices & 0x80)       dprintf("Ext.TMDS");

      dprintf("\n");
    }
  } // end of revision 12 additions.

  // print out revision 14 additions
  if(pgv->g2x.MiscVersion >= 0x14)
  {
    if( (pgv->g2x.SSDeviceMask & 0x11111111) ||
        (pgv->RuntimeFlags & RT_VERBOSE) )
    {
      dprintf("  Spread Spectrum: ");

      if(!(pgv->g2x.SSDeviceMask & 0x11111111))
        dprintf("NOT SUPPORTED!\n                   ");

      // Do we have any external SS devices?
      if( (pgv->RuntimeFlags & RT_VERBOSE) ||
          ((pgv->g2x.SSDeviceMask & 0x11111111) & ~(((pgv->g2x.SSDeviceMask>>1) & 0x11111111))) )
        dprintf("ExtSSLvl:%d (%d.%02d%%)",
            pgv->g2x.SSExtLevel,
            ((pgv->g2x.SSExtLevel*25)/100),
            ((pgv->g2x.SSExtLevel*25)%100));

      // Put some space between the two if needed
      if( (pgv->RuntimeFlags & RT_VERBOSE) ||
          ( ((pgv->g2x.SSDeviceMask & 0x11111111) & ~(((pgv->g2x.SSDeviceMask>>1) & 0x11111111))) &&
            ((pgv->g2x.SSDeviceMask & 0x11111111) & (((pgv->g2x.SSDeviceMask>>1) & 0x11111111))) ) )
        dprintf("   ");

      // Do we have any internal SS devices?
      if( (pgv->RuntimeFlags & RT_VERBOSE) ||
          ((pgv->g2x.SSDeviceMask & 0x11111111) & (((pgv->g2x.SSDeviceMask>>1) & 0x11111111))) )
        dprintf("IntSS:%d.%d%%",
            ((pgv->g2x.SSIntPercent*25)/100),
            ((pgv->g2x.SSIntPercent*25)%100));

      dprintf("\n");

      // Version 17 added Spread Spectrum Header data
      if(pgv->g2x.MiscVersion >= 0x17)
      {
        dprintf("    Flags:0x%x,  Minimum PLL Update:%d.%d MHz,  Period:%d\n",
                pgv->g2x.SSFlags,
                pgv->g2x.SSMinPLLUpdate/10,
                pgv->g2x.SSMinPLLUpdate%10,
                pgv->g2x.SpreadPeriod);
      }

      if( (pgv->RuntimeFlags & RT_VERBOSE) ||
          (pgv->g2x.SSDeviceMask & 0x00000001) )
      {
        dprintf("    Int.LVDS:");
        if(!(pgv->g2x.SSDeviceMask & 0x00000001))
          dprintf("NOT SUPPORTED!\n             ");

        if(pgv->g2x.SSDeviceMask & 0x00000002)
          dprintf("IntSS,%s\n",
            ((pgv->g2x.SSDeviceMask & 0x00000008)?"Center":"Down"));
        else
          dprintf("ExtSS,%s,%s\n",
            ((pgv->g2x.SSDeviceMask & 0x00000004)?"GPIO":"I2C"),
            ((pgv->g2x.SSDeviceMask & 0x00000008)?"Center":"Down"));
      }

      if( (pgv->RuntimeFlags & RT_VERBOSE) ||
          (pgv->g2x.SSDeviceMask & 0x00000010) )
      {
        dprintf("    Ext.LVDS:");
        if(!(pgv->g2x.SSDeviceMask & 0x00000010))
          dprintf("NOT SUPPORTED!\n             ");

        if(pgv->g2x.SSDeviceMask & 0x00000020)
          dprintf("IntSS,%s\n",
            ((pgv->g2x.SSDeviceMask & 0x00000080)?"Center":"Down"));
        else
          dprintf("ExtSS,%s,%s\n",
            ((pgv->g2x.SSDeviceMask & 0x00000040)?"GPIO":"I2C"),
            ((pgv->g2x.SSDeviceMask & 0x00000080)?"Center":"Down"));
      }

      if( (pgv->RuntimeFlags & RT_VERBOSE) ||
          (pgv->g2x.SSDeviceMask & 0x00000100) )
      {
        dprintf("    Int.TMDS:");
        if(!(pgv->g2x.SSDeviceMask & 0x00000100))
          dprintf("NOT SUPPORTED!\n             ");

        if(pgv->g2x.SSDeviceMask & 0x00000200)
          dprintf("IntSS,%s\n",
            ((pgv->g2x.SSDeviceMask & 0x00000800)?"Center":"Down"));
        else
          dprintf("ExtSS,%s,%s\n",
            ((pgv->g2x.SSDeviceMask & 0x00000400)?"GPIO":"I2C"),
            ((pgv->g2x.SSDeviceMask & 0x00000800)?"Center":"Down"));
      }

      if( (pgv->RuntimeFlags & RT_VERBOSE) ||
          (pgv->g2x.SSDeviceMask & 0x00001000) )
      {
        dprintf("    Ext.TMDS:");
        if(!(pgv->g2x.SSDeviceMask & 0x00001000))
          dprintf("NOT SUPPORTED!\n             ");

        if(pgv->g2x.SSDeviceMask & 0x00002000)
          dprintf("IntSS,%s\n",
            ((pgv->g2x.SSDeviceMask & 0x00008000)?"Center":"Down"));
        else
          dprintf("ExtSS,%s,%s\n",
            ((pgv->g2x.SSDeviceMask & 0x00004000)?"GPIO":"I2C"),
            ((pgv->g2x.SSDeviceMask & 0x00008000)?"Center":"Down"));
      }

      if( (pgv->RuntimeFlags & RT_VERBOSE) ||
          (pgv->g2x.SSDeviceMask & 0x00010000) )
      {
        dprintf("      MemClk:");
        if(!(pgv->g2x.SSDeviceMask & 0x00010000))
          dprintf("NOT SUPPORTED!\n             ");

        if(pgv->g2x.SSDeviceMask & 0x00020000)
          dprintf("IntSS,%s\n",
            ((pgv->g2x.SSDeviceMask & 0x00080000)?"Center":"Down"));
        else
          dprintf("ExtSS,%s,%s\n",
            ((pgv->g2x.SSDeviceMask & 0x00040000)?"GPIO":"I2C"),
            ((pgv->g2x.SSDeviceMask & 0x00080000)?"Center":"Down"));
      }

    }

    // There are new Input parameters for revision 14,
    // but I'm going to dump those with the old paramters.

  } // end of revision 14 additions.


}


// Input Devices functions here
// This should all be shared between DCB 2.0 and 3.0 for now
LwU8 GetIDEntry(PGV pgv, LwU32 idx)
{
  pgv->LwrrentFileOffset = pgv->InputDevicesBase + idx*pgv->InputDevicesSize;
  return pgv->gIP.GetLwU8(pgv);
}

LwU32 GetIDMode(PGV pgv, LwU32 idx)
{
  return ((GetIDEntry(pgv, idx))&0xF);
}

LwU32 GetIDType(PGV pgv, LwU32 idx)
{
  return ((GetIDEntry(pgv, idx)>>4)&0x3);
}

LwU32 GetIDVidType(PGV pgv, LwU32 idx)
{
  return ((GetIDEntry(pgv, idx)>>6)&0x3);
}

void DescribeInputDevices_2x(PGV pgv)
{
  LwU32 i, AllSkipEntries = 1;

  if(pgv->InputDevicesCount)
  {
    // Need to check for all skip entries for DCB 3.0+
    if(pgv->DCBVersion >= 0x30)
    {
      for(i=0; i<pgv->InputDevicesCount; i++)
      {
        // DCB 3.0 has skip entries
        if(GetIDMode(pgv, i) != 0xF)
        {
          AllSkipEntries = 0;
          break;
        }
      }

      if(AllSkipEntries)
      {
        if (pgv->RuntimeFlags & RT_VERBOSE)
        {
          dprintf("Input Devices: All Skip Entries\n");
        }

        return;
      }
    }

    if(pgv->DCBVersion < 0x30) dprintf("  ");
    if((pgv->gPCD.VendorID == 0) && (pgv->gPCD.BoardID == 0))
      dprintf("Input Device List for Generic VIVO Board:\n");
    else
      dprintf("Input Devices:\n");

    if(pgv->DCBVersion < 0x30) dprintf("  ");
    dprintf("  D# Mode Type VidType\n");


    for(i=0; i<pgv->InputDevicesCount; i++)
    {
      char IDType[8] = "??? ";
      char IDVidType[8] = "????? ";

      // DCB 3.0 has skip entries
      if( (GetIDMode(pgv, i) == 0xF) &&
          (pgv->DCBVersion >= 0x30) )
      {
        if (pgv->RuntimeFlags & RT_VERBOSE)
        {
            dprintf("  %02x  SKIP ENTRY\n", i);
        }
        continue;
      }

      switch(GetIDType(pgv, i))
      {
        case 0: strcpy(IDType, "VCR "); break;
        case 1: strcpy(IDType, "TV  "); break;
      }

      switch(GetIDVidType(pgv, i))
      {
        case 0: strcpy(IDVidType, "CVBS   "); break;
        case 1: strcpy(IDVidType, "TUNER  "); break;
        case 2: strcpy(IDVidType, "SVIDEO "); break;
      }

      if(pgv->DCBVersion < 0x30) dprintf("  ");
      dprintf("  %02x  %02x  %s %s\n",
             i, GetIDMode(pgv, i), IDType, IDVidType);
    }
  }
}

void DescribeSoundDecoderName(PGV pgv, LwU32 SoundDecoder)
{
#ifdef INTERNAL
  switch(SoundDecoder)
  {
    case 0x0: dprintf("Mono\n");                         break;
    case 0x2: dprintf("A2 (TDA9873)\n");                 break;
    case 0x3: dprintf("NICAM (TDA9874)\n");              break;
    case 0x4: dprintf("BTSC (TDA9850)\n");               break;
    case 0x5: dprintf("FM-FM Japan (TA8874z)\n");        break;
    case 0x6: dprintf("BTSC/EIAJ (SAA7133/SAA7173)\n");  break;
    case 0x7: dprintf("A2,NICAM (SAA7134/SAA7174)\n");   break;
    case 0x8: dprintf("Worldwide (SAA7135/SAA7175)\n");  break;
    case 0x9: dprintf("Micronas MSP 3425G (NTSC)\n");    break;
    case 0xA: dprintf("Micronas MSP 3415G (PAL)\n");     break;
    case 0xB: dprintf("SAA7174A\n");                     break;
    case 0xC: dprintf("SAA7171\n");                      break;
    default:  dprintf("?? 0x%02x ??\n", SoundDecoder);   break;
  }
#endif // INTERNAL
}

void DescribeTunerName(PGV pgv, LwU32 Tuner)
{
#ifdef INTERNAL
  switch(Tuner)
  {
    case 0x01: dprintf("Philips FI1216 MK2\n");                          break;
    case 0x02: dprintf("Philips FI1216 MF\n");                           break;
    case 0x03: dprintf("Philips FI1236 MK2\n");                          break;
    case 0x04: dprintf("Philips FI1246 MK2\n");                          break;
    case 0x05: dprintf("Philips FI1256 MK2\n");                          break;
    case 0x06: dprintf("Philips FQ1216 ME\n");                           break;
    case 0x07: dprintf("Philips FQ1216 ME MK3\n");                       break;
    case 0x08: dprintf("Philips FQ1236 ME MK3\n");                       break;
    case 0x09: dprintf("Philips TDA 8275\n");                            break;
    case 0x11: dprintf("Temic 4036FY5,4032FY5\n");                       break;
    case 0x12: dprintf("Temic 4006FH5,4002FH5\n");                       break;
    case 0x13: dprintf("Temic 4066FY5,4036FY5\n");                       break;
    case 0x14: dprintf("Temic 4016FY5,4012FY5\n");                       break;
    case 0x15: dprintf("Temic 4136\n");                                  break;
    case 0x16: dprintf("Temic 4146\n");                                  break;
    case 0x17: dprintf("Microtune MT2040\n");                            break;
    case 0x18: dprintf("Microtune MT2050\n");                            break;
    case 0x19: dprintf("Microtune 7102DT5\n");                           break;
    case 0x20: dprintf("Microtune 7132DT5\n");                           break;
    case 0x21: dprintf("Microtune MT2060\n");                            break;
    case 0x22: dprintf("Microtune 4039FR5\n");                           break;
    case 0x23: dprintf("Microtune 4049FM5\n");                           break;
    case 0x30: dprintf("LG TALN-M200T (PAL)\n");                         break;
    case 0x31: dprintf("LG TALN-H200T (NTSC)\n");                        break;
    case 0x32: dprintf("TALN-S200T (SECAM L/L' & PAL B/G, I/I, D/K)\n"); break;
    case 0x60: dprintf("Samsung TEBN9282PK01A\n");                       break;
    case 0x81: dprintf("Philips FM1216\n");                              break;
    case 0x82: dprintf("Philips FM1216MF\n");                            break;
    case 0x83: dprintf("Philips FM1236\n");                              break;
    case 0x84: dprintf("Philips FM1246\n");                              break;
    case 0x85: dprintf("Philips FM1256\n");                              break;
    case 0x86: dprintf("Philips FM1216 ME\n");                           break;
    case 0x87: dprintf("Philips FM1216 ME MK3\n");                       break;
    case 0x88: dprintf("Philips FM1236 ME MK3\n");                       break;
    default:   dprintf("?? 0x%02x ??\n", Tuner);                         break;
  }
#endif // INTERNAL
}

void DescribeDigitalTunerName(PGV pgv, LwU32 DigitalTuner)
{
#ifdef INTERNAL
  switch(DigitalTuner)
  {
    case 0x01: dprintf("TDA9885 (PAL/NTSC Analog)\n");           break;
    case 0x02: dprintf("TDA9886 (PAL/NTSC/SECAM Analog)\n");     break;
    case 0x03: dprintf("TDA9887 (PAL/NTSC/SECAM QSS Analog)\n"); break;
    case 0x04: dprintf("Philips SAA7171\n");                     break;
    case 0x10: dprintf("Conexant CX24121\n");                    break;
    case 0x15: dprintf("Philips TDA8260TW\n");                   break;
    default:   dprintf("?? 0x%02x ??\n", DigitalTuner);          break;
  }
#endif // INTERNAL
}


// Personal Cinema Table here:
void DescribePersonalCinemaInfo_2x(PGV pgv)
{
  // Do we need to print the Input devices??
  // This only really needs to be done for Personal Cinema boards.
  if( ( (pgv->gPCD.VendorID != 0) &&
        (pgv->gPCD.BoardID != 0) ) ||
      (pgv->RuntimeFlags & RT_VERBOSE) )
  {
#ifdef INTERNAL
    if(pgv->RuntimeFlags & RT_VERBOSE)
    {
      if(pgv->DCBVersion < 0x30) dprintf("  ");
      dprintf("Personal Cinema Table:");
      if(pgv->DCBVersion >= 0x30)
        dprintf(" Version: 0x%x\n", pgv->gPCD.Version);
      else
        dprintf("\n");

      if(pgv->DCBVersion < 0x30) dprintf("  ");
      dprintf("  Vendor ID: ");
      switch(pgv->gPCD.VendorID)
      {
        case 0xde: dprintf("LWPU\n");  break;
        case 0xcb: dprintf("Compro\n");  break;
        case 0x81: dprintf("ASUS\n");    break;
        default: dprintf("?? 0x%02x ??\n", pgv->gPCD.VendorID); break;
      }

      if(pgv->DCBVersion < 0x30) dprintf("  ");
      dprintf("  Board ID: ");
      switch(pgv->gPCD.BoardID)
      {
        case 0x01: dprintf("P79\n");              break;
        case 0x02: dprintf("P104\n");             break;
        case 0x03: dprintf("P164-LW31\n");        break;
        case 0x04: dprintf("P164-LW34\n");        break;
        case 0x05: dprintf("P186-LW35\n");        break;
        case 0x06: dprintf("P187-LW35\n");        break;
        case 0x07: dprintf("P178-LW36\n");        break;
        case 0x08: dprintf("P253-LW43\n");        break;
        case 0x09: dprintf("P254-LW44\n");        break;
        case 0x0A: dprintf("P178-LW36-A2M\n");    break;
        case 0x0B: dprintf("P293\n");             break;
        case 0x0C: dprintf("P178-LW36-FPGA\n");   break;
        case 0x0D: dprintf("P143-LW34-FPGA\n");   break;
        case 0x0E: dprintf("P143-LW34\n");        break;
        case 0x10: dprintf("P256-LW43\n");        break;
        case 0x11: dprintf("Compro\n");           break;
        case 0x21: dprintf("Asus AIO\n");         break;
        case 0x22: dprintf("Asus ext tuner\n");   break;
        case 0x30: dprintf("Samsung PC Phone\n"); break;
        case 0x31: dprintf("Samsung Rsvd. 1\n");  break;
        case 0x32: dprintf("Samsung Rsvd. 2\n");  break;
        default: dprintf("?? 0x%02x ??\n", pgv->gPCD.BoardID); break;
      }


      if(pgv->DCBVersion < 0x30) dprintf("  ");
      dprintf("  Sound Decoder 1: ");
      DescribeSoundDecoderName(pgv, (pgv->gPCD.SoundExpStd>>4)&0xF);

      if(pgv->DCBVersion < 0x30) dprintf("  ");
      dprintf("  Expander IO: ");
      switch((pgv->gPCD.SoundExpStd)&0x3)
      {
        case 0x01: dprintf("8 bits\n");                   break;
        case 0x02: dprintf("16 bits\n");                  break;
        case 0x03: dprintf("RF Remote\n");                break;
        default:   dprintf("?? 0x%02x ??\n", ((pgv->gPCD.SoundExpStd)&0x3)); break;
      }

      if(pgv->DCBVersion < 0x30) dprintf("  ");
      dprintf("  Analog Tuner 1: ");
      DescribeTunerName(pgv, pgv->gPCD.TunerType);

      if(pgv->DCBVersion < 0x30) dprintf("  ");
      dprintf("  TV Standard: ");
      switch((pgv->gPCD.SoundExpStd>>2)&0x3)
      {
        case 0x00: dprintf("NTSC\n");      break;
        case 0x01: dprintf("PAL/SECAM\n"); break;
        case 0x02: dprintf("Worldwide\n"); break;
        case 0x03: dprintf("Reserved\n");  break;
        default:   dprintf("?? 0x%02x ??\n", ((pgv->gPCD.SoundExpStd>>2)&0x3));  break;
      }

      // Revision 14 added 3 parameters
      // Also available on DCB 3.0 Personal Cinema Header
      if( (pgv->g2x.MiscVersion >= 0x14) ||
          (pgv->DCBVersion >=0x30) )
      {
        if(pgv->gPCD.Demodulator)
        {
          if(pgv->DCBVersion < 0x30) dprintf("  ");
          dprintf("  Digital Tuner 1: ");
          DescribeDigitalTunerName(pgv, pgv->gPCD.Demodulator);
        }


        if((pgv->gPCD.MCandPC>>4)&0xF)
        {
          if(pgv->DCBVersion < 0x30) dprintf("  ");
          dprintf("  Power Control IC: ");
          switch((pgv->gPCD.MCandPC>>4)&0xF)
          {
            case 0x1: dprintf("LNBP21\n"); break;
            default:  dprintf("?? 0x%02x ??\n", ((pgv->gPCD.MCandPC>>4)&0xF)); break;
          }
        }

        if(pgv->gPCD.MCandPC&0xF)
        {
          if(pgv->DCBVersion < 0x30) dprintf("  ");
          dprintf("  Microcontroller: ");
          switch(pgv->gPCD.MCandPC&0xF)
          {
            case 0x6: dprintf("PIC12F629\n");  break;
            case 0x7: dprintf("PIC12CE673\n"); break;
            default:  dprintf("?? 0x%02x ??\n", (pgv->gPCD.MCandPC&0xF)); break;
          }
        }
      }
    }
    else
#endif // INTERNAL
    {
      if(pgv->DCBVersion < 0x30) dprintf("  InputDev: ");
      else                       dprintf("P.Cinema: ");
      dprintf("VenID:0x%02x  BrdID:0x%02x  Snd1:0x%x  ExpIO:%d  Tuner1:0x%02x  TV.Std:%d\n",
            pgv->gPCD.VendorID, pgv->gPCD.BoardID,
            ((pgv->gPCD.SoundExpStd>>4)&0xF),
            ((pgv->gPCD.SoundExpStd)&0x3),
            pgv->gPCD.TunerType,
            ((pgv->gPCD.SoundExpStd>>2)&0x3));

      // Revision 14 added 3 parameters
      // Also available on DCB 3.0 Personal Cinema Header
      if( (pgv->g2x.MiscVersion >= 0x14) ||
          (pgv->DCBVersion >=0x30) )
        dprintf("          Demod1:0x%02x  PwrCtrlIC:0x%x  mCtrl:0x%x\n",
               pgv->gPCD.Demodulator,
               ((pgv->gPCD.MCandPC>>4)&0xF), (pgv->gPCD.MCandPC&0xF));
    }

  }
}


// GPIO functions here
// This should all be shared between DCB 2.0 and 3.0 for now
LwU16 GetGPIOEntry(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  pgv->LwrrentFileOffset = Base + idx*Size;
  return pgv->gIP.GetLwU16(pgv);
}

LwU32 GetGPIONumber(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGPIOEntry(pgv, idx, Base, Size))&0x1F);
}

LwU32 GetGPIOFunction(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGPIOEntry(pgv, idx, Base, Size)>>5)&0x3F);
}

LwU32 GetGPIOOffData(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGPIOEntry(pgv, idx, Base, Size)>>11)&0x1);
}

LwU32 GetGPIOOffEnable(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGPIOEntry(pgv, idx, Base, Size)>>12)&0x1);
}

LwU32 GetGPIOOnData(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGPIOEntry(pgv, idx, Base, Size)>>13)&0x1);
}

LwU32 GetGPIOOnEnable(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGPIOEntry(pgv, idx, Base, Size)>>14)&0x1);
}

LwU32 GetGPIOPWM(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGPIOEntry(pgv, idx, Base, Size)>>15)&0x1);
}


void GpioFunctionText(LwU32 gpioFunc, char *funcText)
{
  char FuncTextTable[][16] =
  {
      "LCD0 backlight", // 0
      "LCD0 power",     // 1
      "LCD0 Pwr Stat",  // 2
      "VSYNC",          // 3
      "VSEL0",          // 4
      "VSEL1",          // 5
      "VSEL2",          // 6
      "Hotplug A",      // 7
      "Hotplug B",      // 8
      "Fan",            // 9
      "Hydra-A",        // 10
      "Auxwin",         // 11
      "DAC1 Select",    // 12
      "DAC1 AltLoad",   // 13
      "Stereo DAC",     // 14
      "Stereo toggle",  // 15
      "Therm/ExtPwr",   // 16
      "Thermal",        // 17
      "Vtg rst",        // 18
      "Sus stat",       // 19
      "Spread0",        // 20
      "Spread1",        // 21
      "VDS FrameID0",   // 22
      "VDS FrameID1",   // 23
      "FBVDDQ Select",  // 24
      "Customer",       // 25
      "VSEL3",          // 26
      "VSEL Default",   // 27
      "Tuner",          // 28
      "Current Share",  // 29
      "Lwr. Share En",  // 30
      "LCD0 Self Test", // 31
      "LCD0 Lamp Stat", // 32
      "LCD0 Brightnss", // 33
      "Req.Pwr Sense",  // 34
      "Overtemp",       // 35
      "HDTV Select",    // 36
      "HDTV AltLoad",   // 37
      "Hydra-B",        // 38
      "Opt.Pwr Sense",  // 39
      "DAC0 Select",    // 40
      "Framelock Int",  // 41
      "SW Slowdown",    // 42
      "HWSlow Batt",    // 43
      "Dis.Pwr Sense",  // 44
      "RSET.SD Sel",    // 45
      "FBVREF Sel",     // 46
      "Service Req.",   // 47
      "Gen.Init",       // 48
      "Inq HD/SD",      // 49
      "DigEnc.IntEn",   // 50
      "Sel.DDC/I2C",    // 51
      "Therm.Alert",    // 52
      "Therm.Crit",     // 53
      "DTERM_LINE1A",   // 54
      "DTERM_LINE1B",   // 55
      "DTERM_LINE2A",   // 56
      "DTERM_LINE3A",   // 57
      "DTERM_LINE3B",   // 58
      "DTERM_SENSE",    // 59
      "SCART Select",   // 60
      "Fan Sense",      // 61
      "I2C Line Sel",   // 62
      "ExtSync0",       // 63 end of DCB 2.x and 3.x table
                        // ExtSync0 is defined in DCB 4.0, but 2.x and 3.x
                        // define 63 as SKIP_ENTRY
      // DCB 4 starts here
      "SLI.RasSyncA",   // 64
      "SLI.RasSyncB",   // 65
      "SwapReadyInA",   // 66
      "SwapReadyOut",   // 67
      "FrameLockRS",    // 68
      "Scart0",         // 69
      "Scart1",         // 70
      "HD Dongle 0",    // 71
      "HD Dongle 1",    // 72
      "ThAlertOutp",    // 73
      "DPtoDVI A",      // 74
      "DPtoDVI B",      // 75
      "Power Alert",    // 76
      "DAC0 AltLoad",   // 77
      "Anlgx Reset",    // 78
      "I2C SCL KCEn",   // 79
      "DVI2DAC Swtc",   // 80
      "Hotplug C",      // 81
      "Hotplug D",      // 82
      "DPtoDVI C",      // 83
      "DPtoDVI D",      // 84
      "Max6305ExtRes",  // 85
      "SLI.LED.Disp",   // 86
      "SPDIF input",    // 87
      "TOSLINK Input",  // 88
      "SPF/TOSL Sel",   // 89
      "AUX/I2C Sel A",  // 90
      "AUX/I2C Sel B",  // 91
      "AUX/I2C Sel C",  // 92
      "AUX/I2C Sel D",  // 93
      "Hotplug E",      // 94
      "Hotplug F",      // 95
      "Hotplug G",      // 96
      "",               // 97
      "",               // 98
      "ExtDevice Int",  // 99
      "",               // 100
      "",               // 101
      "",               // 102
      "",               // 103
      "",               // 104
      "",               // 105
      "Switch Output",  // 106
      "Lwst.Async.RW",  // 107
      "MXM GPIO 0",     // 108
      "MXM GPIO 1",     // 109
      "MXM GPIO 2",     // 110
      "HW Slowdown",    // 111
      "SwapReadyInB",   // 112
      "PMU Trigger",    // 113
      "Rsvd",           // 114
      "VSEL4",          // 115
      "VSEL5",          // 116
      "VSEL6",          // 117
      "VSEL7",          // 118
      "LVDSFastSwtch",  // 119
      "Fan Fsafe PwM",  // 120
      "ExtPwrEmrgncy",  // 121
      "LWDD PSI",       // 122
      "Fan+Overtemp",   // 123
      "Post GPU LED",   // 124
      "Pwr_Bal_PWM0",   // 125
      "Pwr_Bal_PWM1",   // 126
      "FBVDD PSI",      // 127
      "SMPBIEvent",     // 128
      "PWM VID con L",  // 129
      "PWM VID con S",  // 130
      "SLIBriLedBrig",  // 131
      "CoverLEDBri",    // 132
      "PSRFramLock",    // 133
      "FB Clamp",       // 134
      "FBClampTogReq",  // 135
      "",               // 136
      "",               // 137
      "LCD1 backlight", // 138
      "LCD1 power",     // 139
      "LCD1 Pwr Stat",  // 140
      "LCD1 Self Test", // 141
      "LCD1 Lamp Stat", // 142
      "LCD1 Brightnss", // 143
      "LCD2 backlight", // 138
      "LCD2 power",     // 139
      "LCD2 Pwr Stat",  // 140
      "LCD2 Self Test", // 141
      "LCD2 Lamp Stat", // 142
      "LCD2 Brightnss", // 143
      "LCD3 backlight", // 138
      "LCD3 power",     // 139
      "LCD3 Pwr Stat",  // 140
      "LCD3 Self Test", // 141
      "LCD3 Lamp Stat", // 142
      "LCD3 Brightnss", // 143
      "LCD4 backlight", // 138
      "LCD4 power",     // 139
      "LCD4 Pwr Stat",  // 140
      "LCD4 Self Test", // 141
      "LCD4 Lamp Stat", // 142
      "LCD4 Brightnss", // 143
      "LCD5 backlight", // 138
      "LCD5 power",     // 139
      "LCD5 Pwr Stat",  // 140
      "LCD5 Self Test", // 141
      "LCD5 Lamp Stat", // 142
      "LCD5 Brightnss", // 143
      "LCD6 backlight", // 138
      "LCD6 power",     // 139
      "LCD6 Pwr Stat",  // 140
      "LCD6 Self Test", // 141
      "LCD6 Lamp Stat", // 142
      "LCD6 Brightnss", // 143
      "LCD7 backlight", // 138
      "LCD7 power",     // 139
      "LCD7 Pwr Stat",  // 140
      "LCD7 Self Test", // 141
      "LCD7 Lamp Stat", // 142
      "LCD7 Brightnss", // 143
      "LCD2 backlight", // 144
      "GPU Event",      // 145
      "GC6 FbEn",       // 146
      "GC5 Mode",       // 147
      "GPU PexRstHold", // 148
      "SYS PexRstMon",  // 149
      "3V3 MAIN_EN",    // 150
      "VSEL_LWVDD_S_0", // 187
      "VSEL_LWVDD_S_1", // 188
      "VSEL_LWVDD_S_2", // 189
      "VSEL_LWVDD_S_3", // 190
      "VSEL_LWVDD_S_4", // 191
      "VSEL_LWVDD_S_5", // 192
      "VSEL_LWVDD_S_6", // 193
      "VSEL_LWVDD_S_7", // 194
      "LWHS01_PRESENT", // 195
      "LWHS23_PRESENT", // 196
      "LED1_EN",        // 197
      "LED2_EN",        // 198
      "MODULE_ID_1",    // 199
      "MODULE_ID_0",    // 200
      "1V8_MAIN_EN",    // 201
      "VRDUTY_LWVDD",   // 202
      "INT_HT",         // 203
      "DEBUG_HEADER",   // 204
      "LWHS45_PRESENT", // 205
      "HBMVDD_PWMVID",  // 206
      "IDLE_IN_SW",     // 207
      "FLD_PROG_FUSE",  // 208
      "FAN_1",          // 209
      "FAN_TACH_1",     // 210
      "NB_FGC6",        // 211
      "PWR_GPUADC",     // 212
      "ILLUM_RED_DR",   // 213
      "ILLUM_BLUE_DR",  // 214
      "ILLUM_GREEN_DR", // 215
      "ILLUM_LED_BIN1", // 216
      "ILLUM_LED_BIN2", // 217
      "ILLUM_LED_BIN3", // 218
      "SER_VID_PEXVDD", // 219
      "SER_VID_MSVDD",  // 220
      "LWVDD_EN",       // 221
      "MSVDD_PSI",      // 222
      "MODULE_ID_2",    // 223
      "MODULE_ID_3",    // 224
      "MODULE_ID_4",    // 225
      "ROM_WP",         // 226
      "PWM_MSVDD_EN",   // 227
      "CEC_IB_UPD_EN",  // 228
      "CCI_PART0_INT",  // 229
      "CCI_PART0_RST",  // 230
      "CCI_PART1_INT",  // 231
      "CCI_PART1_RST",  // 232
      "EROT_REQ",       // 233
      "EROT_GRANT",     // 234
      "EROT_SPIOPER",   // 235
      "EROT_SP0APINT",  // 236
  };

  if( (gpioFunc >= (sizeof(FuncTextTable) / sizeof(FuncTextTable[0])) ) ||
      (FuncTextTable[gpioFunc][0] == 0) )
    sprintf(funcText, "??? %d ???", (int)gpioFunc);
  else
    strcpy(funcText, FuncTextTable[gpioFunc]);
}

void DescribeGpioAssignments_2x(PGV pgv)
{
  LwU32 i, AllSkipEntries = 1;

  char funcText[20];
  char *inout[] = {"output", "input"};

  if( (pgv->GPIOHeaderPtr == 0x0) ||
      ( (pgv->GPIOEntryCount == 0x0) &&
        (pgv->Device < 0x30) ) )
  {
    if(pgv->DCBVersion < 0x30) dprintf("  ");
    dprintf("Using Default GPIO Assignment table listed in the driver\n");
    return;
  }

  if (pgv->GPIOEntryCount == 0)
  {
    if(pgv->DCBVersion < 0x30) dprintf("  ");
    dprintf("GPIO Assignment table has 0 entries.\n");
    return;
  }

  // Check for all skip entries
  if(pgv->DCBVersion >= 0x30)
  {
    for (i = 0; i < pgv->GPIOEntryCount; i++)
    {
      // DCB 3.0 has skip entries
      if(GetGPIOFunction(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize) != 0x3F)
        AllSkipEntries = 0;
    }
    if(AllSkipEntries)
    {
      if (pgv->RuntimeFlags & RT_VERBOSE)
      {
        if(pgv->DCBVersion < 0x30) dprintf("  ");
        dprintf("GPIO Assignment Table: ALL SKIP ENTRIES\n");
      }
      return;
    }
  }

  if(pgv->DCBVersion < 0x30) dprintf("  ");
  dprintf("GPIO Assignment Table:\n");
  if(pgv->DCBVersion < 0x30) dprintf("  ");
  dprintf("  GPIO  F#  Function       Type\n");

  for (i = 0; i < pgv->GPIOEntryCount; i++)
  {
    LwU32 gpioOffData   = GetGPIOOffData  (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
    LwU32 gpioOffEnable = GetGPIOOffEnable(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
    LwU32 gpioOnData    = GetGPIOOnData   (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
    LwU32 gpioOnEnable  = GetGPIOOnEnable (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
    LwU32 gpioFunction  = GetGPIOFunction (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);

    // DCB 3.0 has skip entries
    if( (gpioFunction == 0x3F) &&
        (pgv->DCBVersion >= 0x20) )
    {
      if (pgv->RuntimeFlags & RT_VERBOSE)
      {
        if(pgv->DCBVersion < 0x30) dprintf("  ");
        dprintf ("  SKIP ENTRY\n");
      }
      continue;
    }

    GpioFunctionText(gpioFunction, funcText);

    if(pgv->DCBVersion < 0x30) dprintf("  ");
    dprintf ("  %-4d  %-3d %-13s  ",
             GetGPIONumber(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize),
             gpioFunction,
             funcText);

    if ( (gpioOffData   == 0) &&
         (gpioOffEnable == 0) &&
         (gpioOnData    == 1) &&
         (gpioOnEnable  == 0) )
      dprintf ("standard output  ");
    else if ( (gpioOffData   == 1) &&
              (gpioOffEnable == 0) &&
              (gpioOnData    == 0) &&
              (gpioOnEnable  == 0) )
      dprintf ("ilwerted output  ");
    else if ( (gpioOffData   == 0) &&
              (gpioOffEnable == 1) &&
              (gpioOnData    == 1) &&
              (gpioOnEnable  == 1) )
      dprintf ("standard input   ");
    else if ( (gpioOffData   == 1) &&
              (gpioOffEnable == 1) &&
              (gpioOnData    == 0) &&
              (gpioOnEnable  == 1) )
      dprintf ("ilwerted input   ");
    else if ( (gpioOffData   == 0) &&
              (gpioOffEnable == 0) &&
              (gpioOnData    == 1) &&
              (gpioOnEnable  == 1) )
      dprintf ("tristate voltage ");
    else
      dprintf ("OFF: %s %d  ON: %s %d ",
        inout[gpioOffEnable], gpioOffData,
        inout[gpioOnEnable], gpioOnData);

    if (GetGPIOPWM(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize))
        dprintf ("PWM ");

    dprintf("\n");
  }
}


void DescribeTables_2x(PGV pgv)
{
  // GPIO table
  DescribeGpioAssignments_2x(pgv);

  // Input Devices
  DescribeInputDevices_2x(pgv);

  // Personal Cinema Info
  DescribePersonalCinemaInfo_2x(pgv);
}


void InitializeDCB20Data(PGV pgv)
{
  LwU32 DCBSignature;
  // Offset from DCBBasePtr for Misc table revisions. This
  // corresponds to rev. (hex) 10, 11, 12, 13, 14, 15, 16, 17
  LwU32 MiscRevisionOffset[] = {10, 12, 13, 15, 23, 24, 24, 28};

  LwU8 temp08 = 0;

  // Initialize base pointers
  pgv->DCBEntryBase = pgv->DCBHeaderPtr+8;
  pgv->DCBEntrySize = 8;
  pgv->LwrrentFileOffset = pgv->DCBHeaderPtr+2;
  pgv->I2CEntryBase = pgv->gIP.GetLwU16(pgv);
  pgv->I2CEntrySize = 4;

  // Check for bad signature
  pgv->LwrrentFileOffset = pgv->DCBHeaderPtr+4;
  if(DCB_SIGNATURE != (DCBSignature = pgv->gIP.GetLwU32(pgv)))
  {
    dprintf("\nERROR! DCB Version 0x%02x has bad signature: 0x%08x.\n", pgv->DCBVersion, DCBSignature);
    dprintf("Exiting ...\n\n");
    LW_FCLOSE(pgv);
    pgv->exitValue = 4;
    return;
  }


  // intitialize function pointers
  pgv->gIP.GetType         = getType_2x;
  pgv->gIP.GetHeadMask     = getHeadMask_2x;
  pgv->gIP.GetI2CPort      = getI2CPort_2x;
  pgv->gIP.GetBus          = getBus_2x;
  pgv->gIP.GetLocation     = getLocation_2x;
  pgv->gIP.GetOutput       = getOutput_2x;
  pgv->gIP.GetI2CRec       = getI2CRec_2x;
  pgv->gIP.GetI2CAccess    = GetI2CAccess_1x;

  // Device Specific functions
  pgv->gIP.GetCRTMaxFreq   = getCRTMaxFreq_2x;
  pgv->gIP.GetLCDDDC       = getLCDDDC_2x;
  pgv->gIP.GetLCDControl   = getLCDControl_2x;
  pgv->gIP.GetLCDExtType   = getLCDExtType_2x;
  pgv->gIP.GetTVFamily     = getTVFamily_2x;
  pgv->gIP.GetTVFormat     = getTVFormat_2x;
  pgv->gIP.GetTVDACs       = getTVDACs_2x;

  // initialize string and describe functions
  pgv->gIP.strcatLCDEncoderName = strcatLCDEncoderName_2x;
  pgv->gIP.strcatTVEncoderName  = strcatTVEncoderName_2x;
  pgv->gIP.GetMiscStr           = getMiscStr_2x;
  pgv->gIP.DescribeMisc         = DescribeMisc_2x;
  pgv->gIP.DescribeTables       = DescribeTables_2x;


  // Get DCB Entry Count
  for(pgv->DCBEntryCount=0; pgv->DCBEntryCount<16; pgv->DCBEntryCount++)
  {
    if(pgv->gIP.GetType(pgv, pgv->DCBEntryCount) == TYPE_EOF)
      break;
  }

  // Get I2C Entry Count
  for(pgv->I2CEntryCount=0; pgv->I2CEntryCount<16; pgv->I2CEntryCount++)
  {
    if(pgv->gIP.GetI2CAccess(pgv, pgv->I2CEntryCount) == ICB_ACCESS_EOF)
      break;
  }

  // We need to read in Input Devices as needed
  if(pgv->DCBVersion >= 0x21)
  {
    // Get the pgv->g2x.MiscVersion
    pgv->LwrrentFileOffset = pgv->DCBHeaderPtr-1;
    pgv->g2x.MiscVersion = pgv->gIP.GetLwU8(pgv);
    if(pgv->g2x.MiscVersion < 0x10)
      pgv->g2x.MiscVersion = 0x0;
    if(pgv->g2x.MiscVersion > 0x17)
    {
#ifdef INTERNAL
      dprintf("DCBCHK: Need code to handle pgv->g2x.MiscVersion 0x%02x. Assuming version 0x17.\n\n",
              pgv->g2x.MiscVersion);
#endif // #ifdef INTERNAL
      pgv->g2x.MiscVersion = 0x17;
    }

    if(pgv->g2x.MiscVersion)
      pgv->LwrrentFileOffset = pgv->DCBHeaderPtr - MiscRevisionOffset[pgv->g2x.MiscVersion-0x10];

    switch(pgv->g2x.MiscVersion)
    {
      case 0x17:
        pgv->g2x.SSFlags         = pgv->gIP.GetLwU8(pgv);
        pgv->g2x.SSMinPLLUpdate  = pgv->gIP.GetLwU8(pgv);
        pgv->g2x.SpreadPeriod    = pgv->gIP.GetLwU16(pgv);
        // intentional fall through
      case 0x16:
      case 0x15:
        pgv->g2x.ExtHwMonitorI2C = pgv->gIP.GetLwU8(pgv);
        // intentional fall through
      case 0x14:
        pgv->gPCD.MCandPC        = pgv->gIP.GetLwU8(pgv);
        pgv->gPCD.Demodulator    = pgv->gIP.GetLwU8(pgv);
        pgv->g2x.SSDeviceMask    = pgv->gIP.GetLwU32(pgv);
        pgv->g2x.SSIntPercent    = pgv->gIP.GetLwU8(pgv);
        pgv->g2x.SSExtLevel      = pgv->gIP.GetLwU8(pgv);
        // intentional fall through
      case 0x13:
        pgv->GPIOHeaderPtr       = pgv->gIP.GetLwU16(pgv);
        // intentional fall through
      case 0x12:
        pgv->g2x.SSDevices       = pgv->gIP.GetLwU8(pgv);
        // intentional fall through
      case 0x11:
        pgv->g2x.ThermalTypePort = pgv->gIP.GetLwU8(pgv);
        pgv->g2x.ThermalI2CAddr  = pgv->gIP.GetLwU8(pgv);
        // intentional fall through
      case 0x10:
        pgv->gPCD.TunerType      = pgv->gIP.GetLwU8(pgv);
        // Because DCB 3.0 switch the nibbles, lets promote the
        // DCB 2.0 version to the DCB 3.0 version byte format.
        temp08                   = pgv->gIP.GetLwU8(pgv);
        pgv->gPCD.SoundExpStd    = ((temp08>>4)&0xF) | ((temp08<<4)&0xF0);
        pgv->gPCD.BoardID        = pgv->gIP.GetLwU8(pgv);
        pgv->gPCD.VendorID       = pgv->gIP.GetLwU8(pgv);
        pgv->g2x.StereoGlasses   = pgv->gIP.GetLwU8(pgv);
        pgv->g2x.DACBSwitch      = pgv->gIP.GetLwU8(pgv);
        pgv->g2x.DACBGPIO        = pgv->gIP.GetLwU8(pgv);
        pgv->InputDevicesBase    = pgv->gIP.GetLwU16(pgv);
        pgv->InputDevicesPtr     = pgv->InputDevicesBase;
        pgv->InputDevicesSize    = 1;
        break;
      case 0: // do nothing here
        break;
    }

    // Get the GPIO table information
    if(pgv->GPIOHeaderPtr)
    {
      pgv->LwrrentFileOffset = pgv->GPIOHeaderPtr;
      if(pgv->gIP.GetLwU8(pgv) != 0x10)
      {
        dprintf("  This GPIO Assignment table version is not handled.\n");
        pgv->GPIOHeaderPtr = 0;
      }
      else
      {
        pgv->GPIOEntrySize     = pgv->gIP.GetLwU8(pgv);
        pgv->GPIOEntryCount    = pgv->gIP.GetLwU8(pgv);
        pgv->GPIOEntryBase     = (LwU16) pgv->LwrrentFileOffset;


        if(pgv->GPIOEntrySize != 2)
        {
          dprintf("  GPIO Assignment Entry Size, %d, is not handled.\n", pgv->GPIOEntrySize);
          pgv->GPIOHeaderPtr = 0;
        }
      }


    }

    // Get Input Devices Count
    if(pgv->InputDevicesPtr)
    {
      for(pgv->InputDevicesCount=0; pgv->InputDevicesCount<8; pgv->InputDevicesCount++)
      {
        if(GetIDMode(pgv, pgv->InputDevicesCount) == INPUT_DEVICES_EOF)
          break;
      }
    }
  }

}



/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2002-2022 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

/******************************** DCBChecker *******************************\
*                                                                           *
* Module: dcb1x.c                                                           *
* This module handles all DCB 2X routines.                                  *
*                                                                           *
* Written by Steve Rogers (srogers@lwpu.com)                              *
* Let me know if you have any questions/comments/suggestions.               *
*                                                                           *
\***************************************************************************/

#ifdef SEPARATE_COMP // Not used in LWwatch compile
#if !defined(LW_MAC_KEXT)
#include <stdio.h>
#include <stdlib.h>
#endif //!defined(LW_MAC_KEXT)
#include <string.h>

#include "dcbchk.h"
#endif //SEPARATE_COMP

LwU32 getDisplayPath_3x(PGV pgv, LwU32 idx)
{
  pgv->LwrrentFileOffset = pgv->DCBEntryBase + idx*pgv->DCBEntrySize;
  return pgv->gIP.GetLwU32(pgv);
}

LwU32 getHeadMask_3x(PGV pgv, LwU32 idx)
{
  return ((getDisplayPath_3x(pgv, idx)>>8) & 0x3);
}

LwU32 getConnectorIndex_3x(PGV pgv, LwU32 idx)
{
  return ((getDisplayPath_3x(pgv, idx)>>12) & 0xF);
}

LwU32 getLocation_3x(PGV pgv, LwU32 idx)
{
  return ((getDisplayPath_3x(pgv, idx)>>20) & 0x3);
}

LwU32 getBootRemoved_3x(PGV pgv, LwU32 idx)
{
  return ((getDisplayPath_3x(pgv, idx)>>22) & 0x1);
}

LwU32 getBlindBootRemoved_3x(PGV pgv, LwU32 idx)
{
  return ((getDisplayPath_3x(pgv, idx)>>23) & 0x1);
}

LwU32 getOutput_3x(PGV pgv, LwU32 idx)
{
  return ((getDisplayPath_3x(pgv, idx)>>24) & 0xF);
}

LwU32 getDisplaySpecific_3x(PGV pgv, LwU32 idx)
{
  pgv->LwrrentFileOffset = pgv->DCBEntryBase + idx*pgv->DCBEntrySize + 4;
  return pgv->gIP.GetLwU32(pgv);
}

LwU32 getCRTMaxFreq_3x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)&0xFF)*10);
}

LwU32 getLCDDDC_3x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)    )&0x03);
}

LwU32 getLCDControl_3x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)>> 2)&0x03);
}

LwU32 getLCDHDCP_3x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)>> 6)&0x01);
}

LwU32 getLCDHDMI_3x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)>> 7)&0x01);
}

LwU32 getLCDExtType_3x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)>> 8)&0xFF);
}

LwU32 getTVFamily_3x(PGV pgv, LwU32 idx)
{
  // By default, this will return:
  // 0 (Brooktree/Conexant) for Encoder values 0x00-0x3F
  // 1 (Chrontel)           for Encoder values 0x40-0x7F
  // 2 (Philips)            for Encoder values 0x80-0xBF
  // 3 (Lwpu/Zoran)       for Encoder values 0xC0-0xFF
  // If this is not correct, we'll probably need to move
  // this to a switch statement or if/else clauses.
  return ((getDisplaySpecific_3x(pgv, idx)>>14)&0x03);
}

LwU32 getExtEncoder_3x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)>> 8)&0xFF);
}

LwU32 getTVFormat_3x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)    )&0x0F) |
         ((getDisplaySpecific_3x(pgv, idx)>>22)&0x10);
}

LwU32 getTVDACs_3x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)>> 4)&0x0F) |
         ((getDisplaySpecific_3x(pgv, idx)>>12)&0xF0) ;
}

LwU32 getExtI2CSpeed_3x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)>>16)&0x0F);
}

LwU32 getExtCCBPortIndex_3x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)>>20)&0x01);
}

LwU32 getExtI2CPort_3x(PGV pgv, LwU32 idx)
{
  if(getExtCCBPortIndex_3x(pgv, idx))
    return pgv->g3x.SecondaryPort;
  else
    return pgv->g3x.PrimaryPort;
}

LwU32 getTVConnectorCount_3x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)>> 21)&0x03)+1;
}

LwU32 getTVRSETParams_3x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)>> 23)&0x01);
}

LwU32 getExtMIOWidth_3x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)>>24)&0x03);
}

LwU32 getSDVOType_3x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)>>8)&0xFF);
}

LwU32 getSDVOEDCBPtr_3x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)>>16)&0xFFFF);
}


void strcatTVEncoderName_3x(PGV pgv, LwU32 idx, char*str)
{
  char spfvar[16] = {0};

  switch(getExtEncoder_3x(pgv, idx))
  {
    case 0x00: strcat(str, "BT868"MYFS);   break;
    case 0x01: strcat(str, "BT869"MYFS);   break;
    case 0x02: strcat(str, "CX870"MYFS);   break;
    case 0x03: strcat(str, "CX871"MYFS);   break;
    case 0x04: strcat(str, "CX872"MYFS);   break;
    case 0x05: strcat(str, "CX873"MYFS);   break;
    case 0x06: strcat(str, "CX874"MYFS);   break;
    case 0x07: strcat(str, "CX875"MYFS);   break;
    case 0x40: strcat(str, "CH7003"MYFS);  break;
    case 0x41: strcat(str, "CH7004"MYFS);  break;
    case 0x42: strcat(str, "CH7005"MYFS);  break;
    case 0x43: strcat(str, "CH7006"MYFS);  break;
    case 0x44: strcat(str, "CH7007"MYFS);  break;
    case 0x45: strcat(str, "CH7008"MYFS);  break;
    case 0x46: strcat(str, "CH7009"MYFS);  break;
    case 0x47: strcat(str, "CH7010"MYFS);  break;
    case 0x48: strcat(str, "CH7011"MYFS);  break;
    case 0x49: strcat(str, "CH7012"MYFS);  break;
    case 0x4A: strcat(str, "CH7019"MYFS);  break;
    case 0x4B: strcat(str, "CH7021"MYFS);  break;
    case 0x80: strcat(str, "PH7102"MYFS);  break;
    case 0x81: strcat(str, "PH7103"MYFS);  break;
    case 0x82: strcat(str, "PH7104"MYFS);  break;
    case 0x83: strcat(str, "PH7105"MYFS);  break;
    case 0x84: strcat(str, "PH7108"MYFS);  break;
    case 0x85: strcat(str, "PH7108A"MYFS); break;
    case 0x86: strcat(str, "PH7108B"MYFS); break;
    case 0x87: strcat(str, "PH7109"MYFS);  break;
    case 0x88: strcat(str, "PH7109A"MYFS); break;
    case 0xC0: strcat(str, "LW"MYFS);      break;
    default:
      strcat(str, MYFS);
      sprintf(spfvar, "?0x%x?", (int)getExtEncoder_3x(pgv, idx));
      strcat(str, spfvar);
      break;
  }
}
void strcatLCDEncoderName_3x(PGV pgv, LwU32 idx, char*str)
{
  char spfvar[16] = {0};

  switch(getExtEncoder_3x(pgv, idx))
  {
    case 0x00: strcat(str, MYFS"Default");     break;
    case 0x01: strcat(str, MYFS"SI164");       break;
    case 0x02: strcat(str, MYFS"SI178");       break;
    case 0x03: strcat(str, MYFS"2xSI178");     break;
    case 0x04: strcat(str, MYFS"CH7009");      break;
    case 0x05: strcat(str, MYFS"CH7019");      break;
    case 0x06: strcat(str, MYFS"DS90C387");    break;
    case 0x07: strcat(str, MYFS"ALTSI164");    break;
    case 0x08: strcat(str, MYFS"CH7301");      break;
    case 0x09: strcat(str, MYFS"ALTSI1162");   break;
    // case A: removed (was CX25892)
    case 0x0B: strcat(str, MYFS"ANX9081");     break;
    case 0x0C: strcat(str, MYFS"PTDP501");     break;
    case 0x0D: strcat(str, MYFS"ANX9805");     break;
    case 0x0E: strcat(str, MYFS"AltAX9805");   break;
    case 0x0F: strcat(str, MYFS"DPSerial");    break;
    case 0x10: strcat(str, MYFS"NB7NQ621M_1"); break;
    case 0x11: strcat(str, MYFS"NB7NQ621M_2"); break;
    default:
      strcat(str, MYFS);
      sprintf(spfvar, "?0x%x?", (int)getExtEncoder_3x(pgv, idx));
      strcat(str, spfvar);
      break;
  }
}


void getMiscStr_3x(PGV pgv, LwU32 idx, char*str)
{
  char Misc[MISC_STR_SPACE*2] = {0};
  char spfvar[16] = {0};

  sprintf(spfvar, "%c %c %x ",
          (getBootRemoved_3x(pgv, idx)?'N':'Y'),
          (getBlindBootRemoved_3x(pgv, idx)?'N':'Y'),
          (int)getConnectorIndex_3x(pgv, idx));
  strcat(Misc, spfvar);

  strcatMiscStr_Generic(pgv, idx, Misc);

  switch(pgv->gIP.GetType(pgv, idx))
  {
    case TYPE_TV:
      sprintf(spfvar, MYFS"ctrs:%d",
              (int)pgv->g3x.GetTVConnectorCount(pgv, idx));
      strcat(Misc, spfvar);
      if(getTVRSETParams_3x(pgv, idx))
        sprintf(spfvar, MYFS"RSET:SD");
      else
        sprintf(spfvar, MYFS"RSET:HD");
      strcat(Misc, spfvar);
      // intentional fall through
    case TYPE_TMDS:
    case TYPE_LVDS:
      if(pgv->gIP.GetLocation(pgv, idx) == LOCATION_BOARD)
      {
        sprintf(spfvar, MYFS"I2CCom:%c",
                GetCharPerValueWithMax(getExtI2CPort_3x(pgv, idx), pgv->I2CEntryCount, '?'));
        strcat(Misc, spfvar);

        /* This has been defeatured in DCB 3.x due to lack of use
        switch(getExtI2CSpeed_3x(pgv,idx))
        {
          case 0:  spfvar[0] = 0;                     break;
          case 1:  sprintf(spfvar, MYFS"I2C.Sp:Std"); break;
          case 2:  sprintf(spfvar, MYFS"I2C.Sp:200"); break;
          case 3:  sprintf(spfvar, MYFS"I2C.Sp:Fst"); break;
          case 4:  sprintf(spfvar, MYFS"I2C.Sp:800"); break;
          case 5:  sprintf(spfvar, MYFS"I2C.Sp:1.6"); break;
          case 6:  sprintf(spfvar, MYFS"I2C.Sp:HSp"); break;
          default: sprintf(spfvar, MYFS"??%d??",
                           getExtI2CSpeed_3x(pgv,idx)); break;
        }
        strcat(Misc, spfvar);
        */

        // Need to add in MIO Port width
        switch(getExtMIOWidth_3x(pgv, idx))
        {
            case 0:  spfvar[0] = 0;                 break;
            case 1:  sprintf(spfvar, MYFS"MW:12U"); break;
            case 2:  sprintf(spfvar, MYFS"MW:12L"); break;
            case 3:  sprintf(spfvar, MYFS"MW:24");  break;
        }
        strcat(Misc, spfvar);
      }

      // NOTE HCDP field is negative polarity: 0=Allow, 1=Disable
      if(!getLCDHDCP_3x(pgv, idx))
      {
        sprintf(spfvar, MYFS"HDCP");
        strcat(Misc, spfvar);
      }

      if(getLCDHDMI_3x(pgv, idx))
      {
        sprintf(spfvar, MYFS"HDMI");
        strcat(Misc, spfvar);
      }

      break;

    case TYPE_SDVO:
      sprintf(spfvar, "Type:0x%02x",
              (int)getSDVOType_3x(pgv, idx));
      strcat(Misc, spfvar);
      sprintf(spfvar, MYFS"Ptr:0x%04x",
              (int)getSDVOEDCBPtr_3x(pgv, idx));
      strcat(Misc, spfvar);
      break;
  }

  if(strlen(Misc) > MISC_STR_SPACE)
  {
    dprintf("DCBCHK ERROR: Misc string space is too long.  Cropping to %d.\n", MISC_STR_SPACE);
    Misc[MISC_STR_SPACE-1] = '\0';
  }

  strcpy(str, Misc);
}

void DescribeMisc_3x(PGV pgv)
{
}


void DescribeMultichipMIOPorts(PGV pgv)
{
  if(pgv->g3x.Flags & 0xF0)
  {
    dprintf("Multichip: ");
    if(pgv->g3x.Flags & 0x30)
    {
      dprintf("MIO A:");
      if(pgv->g3x.Flags & 0x10)
        dprintf("Input");
      if( (pgv->g3x.Flags & 0x30) == 0x30)
        dprintf("+");
      if(pgv->g3x.Flags & 0x20)
        dprintf("Output");
      dprintf("  ");
    }
    if(pgv->g3x.Flags & 0xC0)
    {
      dprintf("MIO B:");
      if(pgv->g3x.Flags & 0x40)
        dprintf("Input");
      if( (pgv->g3x.Flags & 0xC0) == 0xC0)
        dprintf("+");
      if(pgv->g3x.Flags & 0x80)
        dprintf("Output");
    }
    dprintf("\n");
  }
}

void ExtGpioFunctionText(LwU32 spType, LwU32 gpioFunc, char *funcText)
{
  switch (spType)
  {
    default:
    case 0:
      // Unknown... assume it works just like internal type.
      GpioFunctionText(gpioFunc, funcText);
      break;
    case 1: // PCA9555 for 10-pin Personal Cinema VIVO pods
    {
      char FuncTextTable[][16] =
      {
          "SKIP ENTRY",    // 0
          "DTERM_LINE1A",  // 1
          "CFG_480p576p",  // 2
          "DTERM_LINE1B",  // 3
          "CFG_720p",      // 4
          "DTERM_LINE2A",  // 5
          "CFG_1080i",     // 6
          "DTERM_LINE2B",  // 7
          "DTERM_LINE3A",  // 8
          "POD_LOAD_DET",  // 9
          "DTERM_LINE3B",  // 10
          "POD_SELECT",    // 11
          "DTERM_SENSE",   // 12
          "CFG_SDTV",      // 13
          "POD_LOC0",      // 14
          "POD_LOC1",      // 15
        };

      if( gpioFunc >= (sizeof(FuncTextTable) / sizeof(FuncTextTable[0])) )
        sprintf(funcText, "??? %d ???", (int)gpioFunc);
      else
        strcpy(funcText, FuncTextTable[gpioFunc]);
      break;
    }
    case 2: // ADT7473 Automatic Fan Controller Chip
    {
      char FuncTextTable[][16] =
      {
          "SKIP ENTRY",    // 0
          "FANCONTROL",    // 1
      };

      if( gpioFunc >= (sizeof(FuncTextTable) / sizeof(FuncTextTable[0])) )
        sprintf(funcText, "??? %d ???", (int)gpioFunc);
      else
        strcpy(funcText, FuncTextTable[gpioFunc]);
      break;
    }
    case 3: // CX25875 General Purpose Output Pins
    {
      char FuncTextTable[][16] =
      {
          "SKIP ENTRY",            // 0
          "SCART_VID_ASPC0",       // 1
          "SCART_VID_ASPC1",       // 2
      };

      if( gpioFunc >= (sizeof(FuncTextTable) / sizeof(FuncTextTable[0])) )
        sprintf(funcText, "??? %d ???", (int)gpioFunc);
      else
        strcpy(funcText, FuncTextTable[gpioFunc]);
      break;
    }
    case 4: // PCA9555 for GPIO pins on MXM external HDMI control
    {
      char FuncTextTable[][16] =
      {
          "SKIP ENTRY",    // 0
          "DigEnc IntEn",  // 1
          "si1930 Prog",   // 2
          "si1930 Reset",  // 3
        };

      if( gpioFunc >= (sizeof(FuncTextTable) / sizeof(FuncTextTable[0])) )
        sprintf(funcText, "??? %d ???", (int)gpioFunc);
      else
        strcpy(funcText, FuncTextTable[gpioFunc]);
      break;
    }
    case 5: // PCA9536 for GPIO pins for HDMI/DVI Multiplexing
    {
      char FuncTextTable[][16] =
      {
          "SKIP ENTRY",    // 0
          "DVI/HDMI Sel",  // 1
          "I2C HDMI En",   // 2
          "I2C DVI En",    // 3
        };

      if( gpioFunc >= (sizeof(FuncTextTable) / sizeof(FuncTextTable[0])) )
        sprintf(funcText, "??? %d ???", (int)gpioFunc);
      else
        strcpy(funcText, FuncTextTable[gpioFunc]);
      break;
    }
    case 6: // PCA9555 for MXM GPIOs
    case 7: // PCA9536 for MXM GPIOs
    {
      char FuncTextTable[][16] =
      {
          "SKIP ENTRY",    // 0
          "OutputDevCtrl", // 1
          "",              // 2
          "",              // 3
          "",              // 4
          "D Connector 1", // 5
          "D Connector 2", // 6
          "D Connector 3", // 7
          "D Conn Detect", // 8
          "D Con Spare 1", // 9
          "D Con Spare 2", // 10
          "D Con Spare 3", // 11
          "VSEL0",         // 12
          "VSEL1",         // 13
          "VSEL2",         // 14
          "VSEL3",         // 15
          "VSEL4",         // 16
          "VSEL5",         // 17
          "VSEL6",         // 18
          "VSEL7",         // 19
          "",              // 20
          "",              // 21
          "",              // 22
          "",              // 23
          "",              // 24
          "",              // 25
          "",              // 26
          "",              // 27
          "",              // 28
          "",              // 29
          "",              // 30
          "LCD Self Test", // 31
          "",              // 32
          "",              // 33
          "",              // 34
          "",              // 35
          "HDTV Select",   // 36
          "HDTV AltDet",   // 37
        };

      if( gpioFunc >= (sizeof(FuncTextTable) / sizeof(FuncTextTable[0])) )
        sprintf(funcText, "??? %d ???", (int)gpioFunc);
      else
        strcpy(funcText, FuncTextTable[gpioFunc]);
      break;
    }
    case 8: // PCA9555 for SPDif Detect and tv resolution LEDs
    {
      char FuncTextTable[][16] =
      {
          "SKIP ENTRY",    // 0
          "LED-480/576i",  // 1
          "LED-480/576p",  // 2
          "LED-720p",      // 3
          "LED-1080i",     // 4
          "LED-1080p",     // 5
          "HDAudio Det",   // 6
          "SPDif 0 Det",   // 7
          "SPDif 1 Det",   // 8
          "SPDif Select",  // 9
          "Panic Button",  // 10
          "ResChangeBtn",  // 11
        };

      if( gpioFunc >= (sizeof(FuncTextTable) / sizeof(FuncTextTable[0])) )
        sprintf(funcText, "??? %d ???", (int)gpioFunc);
      else
        strcpy(funcText, FuncTextTable[gpioFunc]);
      break;
    }
    case 9: // ANX9805 External DP Encoder GPIO
    {
      char FuncTextTable[][16] =
      {
          "SKIP ENTRY",    // 0
          "DPtoDVI A",     // 1
          "DPtoDVI B",     // 2
          "DPtoDVI C",     // 3
          "DPtoDVI D",     // 4
        };

      if( gpioFunc >= (sizeof(FuncTextTable) / sizeof(FuncTextTable[0])) )
        sprintf(funcText, "??? %d ???", (int)gpioFunc);
      else
        strcpy(funcText, FuncTextTable[gpioFunc]);
      break;
    }
    case 0xA: // Pic18f24k20 GPIO expander for P678/668
    {
      char FuncTextTable[][16] =
      {
          "SKIP ENTRY",    // 0
          "OutputDevCtrl", // 1
      };

      if( gpioFunc >= (sizeof(FuncTextTable) / sizeof(FuncTextTable[0])) )
        sprintf(funcText, "??? %d ???", (int)gpioFunc);
      else
        strcpy(funcText, FuncTextTable[gpioFunc]);
      break;
    }
  }
}



void DescribeExternalGpioAssignments_3x(PGV pgv)
{
  LwU32 i, AllSkipEntries = 1;
  LwU32 k; // loop over all Specific Tables
  LwU32 spPointer, spHeaderSize, spEntryCount, spEntrySize;
  LwU32 spEntryBase, spType, spI2CAddr, spI2CSpeed, spComPort;

  char funcText[20];
  char *inout[] = {"output", "input"};

  if(!(pgv->g3x.extGpio.MasterPointer) ||
     !(pgv->g3x.extGpio.MasterEntryCount) )
  {
    return;
  }

  for(k=0; k<pgv->g3x.extGpio.MasterEntryCount; k++)
  {
    pgv->LwrrentFileOffset = pgv->g3x.extGpio.MasterPointer +
                             pgv->g3x.extGpio.MasterHeaderSize +
                             k * pgv->g3x.extGpio.MasterEntrySize;
    spPointer = pgv->gIP.GetLwU16(pgv);

    // Skip 0 pointers
    if(!spPointer)
    {
      dprintf("External GPIO Assignment Table %d: Pointer is 0. Skipping.\n", k);
      continue;
    }

    pgv->LwrrentFileOffset = spPointer+1;
    spHeaderSize = pgv->gIP.GetLwU8(pgv);
    spEntryBase  = spPointer + spHeaderSize;
    spEntryCount = pgv->gIP.GetLwU8(pgv);
    spEntrySize  = pgv->gIP.GetLwU8(pgv);
    spType       = pgv->gIP.GetLwU8(pgv);
    spI2CAddr    = pgv->gIP.GetLwU8(pgv);
    spI2CSpeed   = pgv->gIP.GetLwU8(pgv);
    spComPort    = (spI2CSpeed & 0x10) >> 4;
    spI2CSpeed  &= 0xF;

    if(!spEntryCount)
    {
      dprintf("External GPIO Assignment Table %d: 0 Entries\n", k);
      continue;
    }

    // Check for all skip entries
    for (i = 0; i < spEntryCount; i++)
    {
      if(GetGPIOFunction(pgv, i, spEntryBase, spEntrySize) != 0x0)
      {
        AllSkipEntries = 0;
        break;
      }
    }
    if(AllSkipEntries)
    {
      if (pgv->RuntimeFlags & RT_VERBOSE)
      {
        dprintf("External GPIO Assignment Table %d: All Skip Entries\n", k);
      }
      continue;
    }

    dprintf("External GPIO Assignment Table %d:\n", k);
    dprintf("  Type: ");
    switch(spType)
    {
      case 1:   dprintf("PCA9555 for 10-pin Personal Cinema VIVO pods  "); break;
      case 2:   dprintf("ADT7473 Automatic Fan Controller Chip   ");       break;
      case 3:   dprintf("CX25875 General Purpose Output Pins   ");         break;
      case 4:   dprintf("PCA9555 for MXM External HDMI Control   ");       break;
      case 5:   dprintf("PCA9536 for HDMI/DVI Multiplexing   ");           break;
      case 6:   dprintf("PCA9555 for MXM GPIOs   ");                       break;
      case 7:   dprintf("PCA9536 for MXM GPIOs   ");                       break;
      case 8:   dprintf("PCA9555 for Napoleon    ");                       break;

      default:  dprintf("??%x??  ", spType); break;
    }
    dprintf("I2CAddr: 0x%x  S:%d  C:%d\n", spI2CAddr, spI2CSpeed, spComPort);

    dprintf("  GPIO  F#  Function       Type\n");

    for (i = 0; i < spEntryCount; i++)
    {
      LwU32 gpioOffData   = GetGPIOOffData  (pgv, i, spEntryBase, spEntrySize);
      LwU32 gpioOffEnable = GetGPIOOffEnable(pgv, i, spEntryBase, spEntrySize);
      LwU32 gpioOnData    = GetGPIOOnData   (pgv, i, spEntryBase, spEntrySize);
      LwU32 gpioOnEnable  = GetGPIOOnEnable (pgv, i, spEntryBase, spEntrySize);
      LwU32 gpioFunction  = GetGPIOFunction (pgv, i, spEntryBase, spEntrySize);

      // DCB 3.0 has skip entries, but unfortunately, external gpios
      // define skip entries as 0 instead of 0x3F like GPU gpios
      if(gpioFunction == 0x0)
      {
        if (pgv->RuntimeFlags & RT_VERBOSE)
        {
          dprintf ("  SKIP ENTRY\n");
        }
        continue;
      }

      ExtGpioFunctionText(spType, gpioFunction, funcText);

      dprintf ("  %-4d  %-3d %-13s  ",
               GetGPIONumber(pgv, i, spEntryBase, spEntrySize),
               gpioFunction,
               funcText);

      if ( (gpioOffData   == 0) &&
           (gpioOffEnable == 0) &&
           (gpioOnData    == 1) &&
           (gpioOnEnable  == 0) )
        dprintf ("standard output  ");
      else if ( (gpioOffData   == 1) &&
                (gpioOffEnable == 0) &&
                (gpioOnData    == 0) &&
                (gpioOnEnable  == 0) )
        dprintf ("ilwerted output  ");
      else if ( (gpioOffData   == 0) &&
                (gpioOffEnable == 1) &&
                (gpioOnData    == 1) &&
                (gpioOnEnable  == 1) )
        dprintf ("standard input   ");
      else if ( (gpioOffData   == 1) &&
                (gpioOffEnable == 1) &&
                (gpioOnData    == 0) &&
                (gpioOnEnable  == 1) )
        dprintf ("ilwerted input   ");
      else if ( (gpioOffData   == 0) &&
                (gpioOffEnable == 0) &&
                (gpioOnData    == 1) &&
                (gpioOnEnable  == 1) )
        dprintf ("tristate voltage ");
      else
        dprintf ("OFF: %s %d  ON: %s %d ",
          inout[gpioOffEnable], gpioOffData,
          inout[gpioOnEnable], gpioOnData);

      if (GetGPIOPWM(pgv, i, spEntryBase, spEntrySize))
          dprintf ("PWM ");

      dprintf("\n");
    }

  }


}

void DescribeExtendedI2CControlBlock_3x(PGV pgv)
{
  LwU8 data08;
  LwU32 i;
  LwU32 HeaderSize, EntryCount, EntrySize, CSECount, CSESize;
  LwU32 EntryOffset;

  // Check to see if there was any SDVO define in all the entries
  for(i=0; i<pgv->DCBEntryCount; i++)
  {
    if(pgv->gIP.GetType(pgv, i) == TYPE_SKIP)
      continue;

    if(pgv->gIP.GetLocation(pgv,i) == LOCATION_SDVO)
    {
      break;
    }
  }

  // If not, skip out.
  if(i == pgv->DCBEntryCount)
    return;

  pgv->LwrrentFileOffset = pgv->I2CEntryBase + pgv->I2CEntrySize*pgv->I2CEntrySize + 1;
  HeaderSize = (LwU32)pgv->gIP.GetLwU8(pgv);
  EntryCount = (LwU32)pgv->gIP.GetLwU8(pgv);
  EntrySize  = (LwU32)pgv->gIP.GetLwU8(pgv);
  CSECount   = (LwU32)pgv->gIP.GetLwU8(pgv);
  CSESize    = (LwU32)pgv->gIP.GetLwU8(pgv);

  EntryOffset = pgv->I2CEntryBase + pgv->I2CEntrySize*pgv->I2CEntrySize + HeaderSize;

  if (!EntryCount)
    return;

  dprintf("Extended I2C:\n");

  for (i=0; i<EntryCount; i++)
  {
    pgv->LwrrentFileOffset = EntryOffset + i * EntrySize;
    switch (i)
    {
      case 0:  dprintf("  SDVO: ");    break;
      case 1:  dprintf("  PROM: ");    break;
      case 2:  dprintf("  EDID: ");    break;
      default: dprintf("  ?%3d: ", i); break;
    }

    data08 = pgv->gIP.GetLwU8(pgv);
    dprintf("Con:%d ", data08);
    data08 = pgv->gIP.GetLwU8(pgv);
    dprintf("Rel:%d ", data08);
    data08 = pgv->gIP.GetLwU8(pgv);
    dprintf("D:%d us\n", data08);
  }
}

void DescribeTables_3x(PGV pgv)
{
  // Multi-chip bits
  DescribeExtendedI2CControlBlock_3x(pgv);

  // Multi-chip bits
  DescribeMultichipMIOPorts(pgv);

  // GPIO table
  DescribeGpioAssignments_2x(pgv);

  // GPIO table
  DescribeExternalGpioAssignments_3x(pgv);

  // InputDevices
  DescribeInputDevices_2x(pgv);

  // Personal Cinema Info
  DescribePersonalCinemaInfo_2x(pgv);
  if(pgv->gPCD.Version > 0x30)
    DescribePersonalCinemaInfo_3x(pgv);

  // Spread Spectrum Info
  DescribeSSTable(pgv);

  // I2C Devices Table
  DescribeI2CDevicesTable_3x(pgv);

  // Connector Table
  DescribeConnectorTable(pgv);

  DescribeDacOutputTable(pgv);
}

void DescribeTunerFunctionality(PGV pgv, LwU32 Func)
{
#ifdef INTERNAL
  switch(Func)
  {
    case 0: dprintf("None\n");                 break;
    case 1: dprintf("Digital TV\n");           break;
    case 2: dprintf("Analog TV\n");            break;
    case 3: dprintf("Analog + Digital TV\n");  break;
    case 4: dprintf("FM\n");                   break;
    case 5: dprintf("Digital + FM\n");         break;
    case 6: dprintf("Analog + FM\n");          break;
    case 7: dprintf("Analog + Digital +FM\n"); break;
  }
#endif // INTERNAL
}

void DescribePersonalCinemaInfo_3x(PGV pgv)
{
#ifdef INTERNAL
  if(pgv->RuntimeFlags & RT_VERBOSE)
  {
    dprintf("  Tuner 1 Functionality:");
    DescribeTunerFunctionality(pgv, pgv->gPCD.TunerFunc&0x7);
    dprintf("  Sound Decoder 2: ");
    DescribeSoundDecoderName(pgv, pgv->gPCD.Sound2&0xF);
    dprintf("  Analog Tuner 2: ");
    DescribeTunerName(pgv, pgv->gPCD.Tuner2);
    dprintf("  Digital Tuner 2: ");
    DescribeDigitalTunerName(pgv, pgv->gPCD.Demod2);
    dprintf("  Tuner 2 Functionality:");
    DescribeTunerFunctionality(pgv, (pgv->gPCD.TunerFunc>>4)&0x7);
  }
  else
#endif // INTERNAL
  if( (pgv->gPCD.VendorID != 0) &&
      (pgv->gPCD.BoardID  != 0) )
  {
    dprintf("          TF1:%d  Snd2:0x%x Tuner2:0x%x  Demod2:0x%x TF2:%d\n",
           (pgv->gPCD.TunerFunc&0x7),
           (pgv->gPCD.Sound2&0xF), pgv->gPCD.Tuner2, pgv->gPCD.Demod2,
           ((pgv->gPCD.TunerFunc>>4)&0x7));
  }
}


void InitializeDCB30Data(PGV pgv)
{
  LwU8 HeaderSize        = 0;
  LwU16 I2CControlPtr     = 0;
  LwU8 I2CHeaderSize     = 0;
  LwU32 DCBSignature      = 0;
  LwU8 GPIOHeaderSize    = 0;
  LwU8 InpDevHeaderSize  = 0;
  LwU16 PersonalCinemaPtr = 0;
  LwU16 SpreadSpectrumPtr = 0;
  LwU8 SSHeaderSize      = 0;
  LwU16 I2CDevicesPtr     = 0;
  LwU8 I2CDevHeaderSize  = 0;
  LwU16 ConnectorPtr      = 0;
  LwU8 ConnectHeaderSize = 0;
  LwU8 PriSecI2CPort     = 0;
  LwU8 DacOutHeaderSize  = 0;

  // Initialize base pointers
#ifndef SEPARATE_COMP // !LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
  dprintf("Reading DCB Base Ptrs\r");
#endif
#endif
  pgv->LwrrentFileOffset = pgv->DCBHeaderPtr+1;
  HeaderSize             = pgv->gIP.GetLwU8(pgv);
  pgv->DCBEntryCount     = pgv->gIP.GetLwU8(pgv);
  pgv->DCBEntrySize      = pgv->gIP.GetLwU8(pgv);
  I2CControlPtr          = pgv->gIP.GetLwU16(pgv);
  DCBSignature           = pgv->gIP.GetLwU32(pgv);
  if(DCBSignature != DCB_SIGNATURE)
  {
    dprintf("\nERROR! DCB Version 0x%02x has bad signature: 0x%08x.\n", pgv->DCBVersion, DCBSignature);
    dprintf("Exiting ...\n\n");
    LW_FCLOSE(pgv);
    pgv->exitValue = 4;
    return;
  }
  pgv->GPIOHeaderPtr     = pgv->gIP.GetLwU16(pgv);
  pgv->InputDevicesPtr   = pgv->gIP.GetLwU16(pgv);
  PersonalCinemaPtr      = pgv->gIP.GetLwU16(pgv);
  SpreadSpectrumPtr      = pgv->gIP.GetLwU16(pgv);
  I2CDevicesPtr          = pgv->gIP.GetLwU16(pgv);
  ConnectorPtr           = pgv->gIP.GetLwU16(pgv);
  pgv->g3x.Flags         = pgv->gIP.GetLwU8(pgv);
  pgv->g3x.dacOut.TablePointer = 0;
  if(HeaderSize >= 25)
  {
    pgv->g3x.dacOut.TablePointer = pgv->gIP.GetLwU16(pgv);
  }

  pgv->DCBEntryBase = pgv->DCBHeaderPtr+HeaderSize;

  pgv->LwrrentFileOffset = I2CControlPtr+1;
  I2CHeaderSize          = pgv->gIP.GetLwU8(pgv);
  pgv->I2CEntryCount     = pgv->gIP.GetLwU8(pgv);
  pgv->I2CEntrySize      = pgv->gIP.GetLwU8(pgv);
  PriSecI2CPort          = pgv->gIP.GetLwU8(pgv);
  pgv->g3x.PrimaryPort   = (PriSecI2CPort   )&0xF;
  pgv->g3x.SecondaryPort = (PriSecI2CPort>>4)&0xF;
  pgv->I2CEntryBase      = (LwU16) pgv->LwrrentFileOffset;

  // intitialize function pointers

  // Reuse these since they are the same right now
  pgv->gIP.GetType         = getType_2x;
  pgv->gIP.GetI2CPort      = getI2CPort_2x;
  pgv->gIP.GetBus          = getBus_2x;
  pgv->gIP.GetI2CRec       = getI2CRec_2x;
  pgv->gIP.GetI2CAccess    = GetI2CAccess_1x;

  // Use these separately
  pgv->gIP.GetHeadMask     = getHeadMask_3x;
  pgv->gIP.GetLocation     = getLocation_3x;
  pgv->gIP.GetOutput       = getOutput_3x;

  // Device Specific functions
  pgv->gIP.GetCRTMaxFreq   = getCRTMaxFreq_3x;
  pgv->gIP.GetLCDDDC       = getLCDDDC_3x;
  pgv->gIP.GetLCDControl   = getLCDControl_3x;
  pgv->gIP.GetLCDExtType   = getExtEncoder_3x;
  pgv->gIP.GetTVFamily     = getTVFamily_3x;
  pgv->gIP.GetTVFormat     = getTVFormat_3x;
  pgv->gIP.GetTVDACs       = getTVDACs_3x;

  pgv->g3x.GetTVConnectorCount = getTVConnectorCount_3x;

  // initialize string and describe functions
  pgv->gIP.strcatLCDEncoderName = strcatLCDEncoderName_3x;
  pgv->gIP.strcatTVEncoderName  = strcatTVEncoderName_3x;
  pgv->gIP.GetMiscStr           = getMiscStr_3x;
  pgv->gIP.DescribeMisc         = DescribeMisc_3x;
  pgv->gIP.DescribeTables       = DescribeTables_3x;

  // Get GPIO Table Data
  if(pgv->GPIOHeaderPtr)
  {
#ifndef SEPARATE_COMP // LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
  dprintf("Reading GPIO Table   \r");
#endif
#endif
    pgv->LwrrentFileOffset = pgv->GPIOHeaderPtr+1;
    GPIOHeaderSize         = pgv->gIP.GetLwU8(pgv);
    pgv->GPIOEntryCount    = pgv->gIP.GetLwU8(pgv);
    pgv->GPIOEntrySize     = pgv->gIP.GetLwU8(pgv);
    pgv->GPIOEntryBase     = pgv->GPIOHeaderPtr + GPIOHeaderSize;

    if(pgv->GPIOEntrySize != 2)
    {
      dprintf("GPIO Assignment Entry Size, %d, is not handled.\n", pgv->GPIOEntrySize);
      pgv->GPIOHeaderPtr = 0;
    }

    // Initialize this to 0
    pgv->g3x.extGpio.MasterPointer = 0;

    if(GPIOHeaderSize >= 6)
    {
      pgv->g3x.extGpio.MasterPointer = pgv->gIP.GetLwU16(pgv);
      if(pgv->g3x.extGpio.MasterPointer)
      {
        pgv->LwrrentFileOffset            = pgv->g3x.extGpio.MasterPointer+1;
        pgv->g3x.extGpio.MasterHeaderSize = pgv->gIP.GetLwU8(pgv);
        pgv->g3x.extGpio.MasterEntryCount = pgv->gIP.GetLwU8(pgv);
        pgv->g3x.extGpio.MasterEntrySize  = pgv->gIP.GetLwU8(pgv);
      }
    }

  }

  // Get InputDevices data
  if(pgv->InputDevicesPtr)
  {
#ifndef SEPARATE_COMP // LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
  dprintf("Reading Input Devices\r");
#endif
#endif
    pgv->LwrrentFileOffset = pgv->InputDevicesPtr+1;
    InpDevHeaderSize       = pgv->gIP.GetLwU8(pgv);
    pgv->InputDevicesCount = pgv->gIP.GetLwU8(pgv);
    pgv->InputDevicesSize  = pgv->gIP.GetLwU8(pgv);
    pgv->InputDevicesBase  = pgv->InputDevicesPtr + InpDevHeaderSize;
  }

  // Get Personal Cinema Data
  if(PersonalCinemaPtr)
  {
#ifndef SEPARATE_COMP // LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
  dprintf("Reading PC Table     \r");
#endif
#endif
    pgv->LwrrentFileOffset = PersonalCinemaPtr;
    pgv->gPCD.Version      = pgv->gIP.GetLwU8(pgv);
    pgv->LwrrentFileOffset = PersonalCinemaPtr+2;
    pgv->gPCD.BoardID      = pgv->gIP.GetLwU8(pgv);
    pgv->gPCD.VendorID     = pgv->gIP.GetLwU8(pgv);
    pgv->gPCD.SoundExpStd  = pgv->gIP.GetLwU8(pgv);
    pgv->gPCD.TunerType    = pgv->gIP.GetLwU8(pgv);
    pgv->gPCD.Demodulator  = pgv->gIP.GetLwU8(pgv);
    pgv->gPCD.MCandPC      = pgv->gIP.GetLwU8(pgv);
    if(pgv->gPCD.Version > 0x30)
    {
      pgv->gPCD.Sound2     = pgv->gIP.GetLwU8(pgv);
      pgv->gPCD.Tuner2     = pgv->gIP.GetLwU8(pgv);
      pgv->gPCD.TunerFunc  = pgv->gIP.GetLwU8(pgv);
      pgv->gPCD.Demod2     = pgv->gIP.GetLwU8(pgv);
    }
  }

  // Get the Spread Spectrum Data
  if(SpreadSpectrumPtr)
  {
#ifndef SEPARATE_COMP // LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
  dprintf("Reading SS Table     \r");
#endif
#endif
    pgv->LwrrentFileOffset = SpreadSpectrumPtr;
    pgv->g3x.ss.Version    = pgv->gIP.GetLwU8(pgv);
    SSHeaderSize           = pgv->gIP.GetLwU8(pgv);
    pgv->g3x.ss.EntryCount = pgv->gIP.GetLwU8(pgv);
    pgv->g3x.ss.EntrySize  = pgv->gIP.GetLwU8(pgv);
    pgv->g3x.ss.EntryBase  = SpreadSpectrumPtr + SSHeaderSize;

    pgv->g3x.ss.InternalPercentage = pgv->gIP.GetLwU8(pgv);
    pgv->g3x.ss.ExternalLevel      = pgv->gIP.GetLwU8(pgv);
    if(pgv->g3x.ss.Version > 0x31)
    {
      pgv->g3x.ss.SSFlags          = pgv->gIP.GetLwU8(pgv);
      pgv->g3x.ss.SSMinPLLUpdate   = pgv->gIP.GetLwU8(pgv);
      pgv->g3x.ss.SpreadPeriod     = pgv->gIP.GetLwU16(pgv);
    }

  }

  // Get the I2C Devices Data
  if(I2CDevicesPtr)
  {
#ifndef SEPARATE_COMP // LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
  dprintf("Reading I2C Devices  \r");
#endif
#endif
    pgv->LwrrentFileOffset     = I2CDevicesPtr+1;
    I2CDevHeaderSize           = pgv->gIP.GetLwU8(pgv);
    pgv->g3x.i2cdev.EntryCount = pgv->gIP.GetLwU8(pgv);
    pgv->g3x.i2cdev.EntrySize  = pgv->gIP.GetLwU8(pgv);
    if (I2CDevHeaderSize >=5)
    {
      pgv->g3x.i2cdev.Flags    = pgv->gIP.GetLwU8(pgv);
    }
    pgv->g3x.i2cdev.EntryBase  = I2CDevicesPtr + I2CDevHeaderSize;
  }

  if(ConnectorPtr)
  {
#ifndef SEPARATE_COMP // LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
  dprintf("Reading Connector Tbl\r");
#endif
#endif
    pgv->LwrrentFileOffset    = ConnectorPtr+1;
    ConnectHeaderSize         = pgv->gIP.GetLwU8(pgv);
    pgv->g3x.cnctr.EntryCount = pgv->gIP.GetLwU8(pgv);
    pgv->g3x.cnctr.EntrySize  = pgv->gIP.GetLwU8(pgv);
    pgv->g3x.cnctr.EntryBase  = ConnectorPtr + ConnectHeaderSize;
    pgv->g3x.cnctr.Platform   = pgv->gIP.GetLwU8(pgv);
  }

  if(pgv->g3x.dacOut.TablePointer)
  {
#ifndef SEPARATE_COMP // LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
  dprintf("Reading Dac Ouptut Tbl\r");
#endif
#endif
    pgv->LwrrentFileOffset     = pgv->g3x.dacOut.TablePointer;
    pgv->g3x.dacOut.Version    = pgv->gIP.GetLwU8(pgv);
    DacOutHeaderSize           = pgv->gIP.GetLwU8(pgv);
    pgv->g3x.dacOut.EntryBase  = pgv->g3x.dacOut.TablePointer + DacOutHeaderSize;
    pgv->g3x.dacOut.EntryCount = pgv->gIP.GetLwU8(pgv);
    pgv->g3x.dacOut.EntrySize  = pgv->gIP.GetLwU8(pgv);

    pgv->g3x.dacOut.DACFuseMap[0] = 0;

    if(DacOutHeaderSize >= 0xa)
    {
      pgv->g3x.dacOut.DACFuseMap[0] = pgv->gIP.GetLwU16(pgv);
      pgv->g3x.dacOut.DACFuseMap[1] = pgv->gIP.GetLwU16(pgv);
      pgv->g3x.dacOut.DACFuseMap[2] = pgv->gIP.GetLwU16(pgv);
    }
  }
}

LwU8 GetSSEntry(PGV pgv, LwU32 idx)
{
  pgv->LwrrentFileOffset = pgv->g3x.ss.EntryBase + idx*pgv->g3x.ss.EntrySize;
  return pgv->gIP.GetLwU8(pgv);
}

LwU8 GetSSEntryType(PGV pgv, LwU32 idx)
{
  return ((GetSSEntry(pgv, idx)   )&0xF);
}

LwU8 GetSSEntryLocation(PGV pgv, LwU32 idx)
{
  return ((GetSSEntry(pgv, idx)>>4)&0x1);
}

LwU8 GetSSEntryExtCom(PGV pgv, LwU32 idx)
{
  return ((GetSSEntry(pgv, idx)>>5)&0x1);
}

LwU8 GetSSEntryDirection(PGV pgv, LwU32 idx)
{
  return ((GetSSEntry(pgv, idx)>>6)&0x1);
}

void DescribeSSTable(PGV pgv)
{
  LwU32 i;
  LwU32 ExternalFound = 0;
  LwU32 InternalFound = 0;
  LwU32 AllSkipEntries = 1;

  if(!pgv->g3x.ss.EntryCount)
    return;

  for(i=0; i<pgv->g3x.ss.EntryCount; i++)
  {
    if(GetSSEntryType(pgv, i) != 0xF)
    {
      AllSkipEntries = 0;
      if(GetSSEntryLocation(pgv, i))
        InternalFound++;
      else
        ExternalFound++;
    }
  }

  if(AllSkipEntries)
  {
    if(pgv->RuntimeFlags & RT_VERBOSE)
    {
      dprintf("Spread Spectrum Table: All SKIP ENTRIES\n");
    }
    return;
  }

  dprintf("Spread Spectrum: ");
  if( (pgv->RuntimeFlags & RT_VERBOSE) ||
      (ExternalFound) )
    dprintf("ExtSSLvl:%d    ",
            pgv->g3x.ss.ExternalLevel);

  if( (pgv->RuntimeFlags & RT_VERBOSE) ||
      (InternalFound) )
    dprintf("IntSS:%d.%d%%",
            ((pgv->g3x.ss.InternalPercentage*25)/100),
            ((pgv->g3x.ss.InternalPercentage*25)%100));
  dprintf("\n");
  if(pgv->g3x.ss.Version >= 0x31)
  {
    if( (pgv->RuntimeFlags & RT_VERBOSE) ||
        (InternalFound) ||
        (ExternalFound) )
    {
        dprintf("       SpreadFlags:0x%x,  Minimum PLL Update:%d.%d MHz,   Period:%d\n",
                pgv->g3x.ss.SSFlags,
                pgv->g3x.ss.SSMinPLLUpdate/10,
                pgv->g3x.ss.SSMinPLLUpdate%10,
                pgv->g3x.ss.SpreadPeriod);
    }
  }

  for(i=0; i<pgv->g3x.ss.EntryCount; i++)
  {
    if(GetSSEntryType(pgv, i) == 0xF)
    {
      if(pgv->RuntimeFlags & RT_VERBOSE)
        dprintf("  %02d: SKIP ENTRY\n", i);
      continue;
    }

    dprintf("  %02d: ",i);
    switch(GetSSEntryType(pgv, i))
    {
      case 0x0: dprintf("Int.LVDS:  "); break;
      case 0x1: dprintf("Ext.LVDS:  "); break;
      case 0x2: dprintf("Int.TMDS:  "); break;
      case 0x3: dprintf("Ext.TMDS:  "); break;
      case 0x4: dprintf("Mem.PLLA:  "); break;
      case 0x5: dprintf("Core.Clk:  "); break;
      case 0x6: dprintf("Int.TVE:   "); break;
      case 0x7: dprintf("Ext.TVE:   "); break;
      case 0x8: dprintf("Mem.PLLB:  "); break;
      default:  dprintf("??%d??:    ", GetSSEntryType(pgv, i)); break;
    }

    dprintf("Loc:%s  %sDir:%s\n",
            (GetSSEntryLocation(pgv, i)?"Int":"Ext"),
            (GetSSEntryLocation(pgv, i)?"":
                (GetSSEntryExtCom(pgv, i)?"Ext.Com:GPIO  ":"Ext.Com:I2C  ")),
            (GetSSEntryDirection(pgv, i)?"Center":"Down") );
  }
}

LwU32 GetI2CDevicesEntry(PGV pgv, LwU32 idx)
{
  pgv->LwrrentFileOffset = pgv->g3x.i2cdev.EntryBase +
          idx*pgv->g3x.i2cdev.EntrySize;
  return pgv->gIP.GetLwU32(pgv);
}

LwU32 GetI2CDevicesEntryType(PGV pgv, LwU32 idx)
{
  return ((GetI2CDevicesEntry(pgv, idx)    ) & 0xFF);
}

LwU32 GetI2CDevicesEntryAddress(PGV pgv, LwU32 idx)
{
  return ((GetI2CDevicesEntry(pgv, idx)>> 8) & 0xFF);
}


LwU32 GetI2CDevicesEntryExtComPort(PGV pgv, LwU32 idx)
{
  return ((GetI2CDevicesEntry(pgv, idx)>>20) & 0x1);
}


void DescribeI2CDevicesTable_3x(PGV pgv)
{
  LwU32 i;
  LwU32 AllSkipEntries = 1;
  char strDevType[16];

  // Check for all skip entries
  for(i=0; i<pgv->g3x.i2cdev.EntryCount; i++)
  {
    if(GetI2CDevicesEntryType(pgv, i) == 0xFF)
      continue;

    AllSkipEntries = 0;
    break;
  }
  if(AllSkipEntries)
  {
    if(pgv->RuntimeFlags & RT_VERBOSE)
    {
      dprintf("I2C Devices Table: ALL SKIP ENTRIES!\n");
    }
    return;
  }

  dprintf("I2C Devices Table:  Flags: 0x%x\n", pgv->g3x.i2cdev.Flags);
  dprintf("  # Type             Addr C\n");
  for(i=0; i<pgv->g3x.i2cdev.EntryCount; i++)
  {
    // Look for skip entries
    if(GetI2CDevicesEntryType(pgv, i) == 0xFF)
    {
      if(pgv->RuntimeFlags & RT_VERBOSE)
      {
        dprintf(" %02x SKIP ENTRY\n", i);
      }
      continue;
    }

    switch(GetI2CDevicesEntryType(pgv, i))
    {
      case 0x01: sprintf(strDevType, "Th:ADM 1032");     break;
      case 0x02: sprintf(strDevType, "Th:MAX 6649");     break;
      case 0x03: sprintf(strDevType, "Th:LM99");         break;
      case 0x04: sprintf(strDevType, "Th:SMB MAX 6649"); break;
      case 0x05: sprintf(strDevType, "Th:VBIOS event");  break;
      case 0x06: sprintf(strDevType, "Th:MAX 1617");     break;
      case 0x07: sprintf(strDevType, "Th:LM64");         break;
      case 0x08: sprintf(strDevType, "Th:OS");           break;
      case 0x09: sprintf(strDevType, "Th:ADT7473");      break;
      case 0x0a: sprintf(strDevType, "Th:ADT7473");      break;
      case 0x0b: sprintf(strDevType, "Th:LM89");         break;
      case 0x0c: sprintf(strDevType, "Th:TMP411");       break;
      case 0x40: sprintf(strDevType, "Pc:VT1103");       break;
      case 0x50: sprintf(strDevType, "Cg:CY2XP304");     break;
      case 0x60: sprintf(strDevType, "Gp:PCA9555");      break;
      case 0x70: sprintf(strDevType, "Fn:ADT7473");      break;
      case 0x80: sprintf(strDevType, "Hm:Si1930uC");     break;
      default:   sprintf(strDevType, "??0x%x??",
                         (int)GetI2CDevicesEntryType(pgv,i)); break;
    }
    dprintf(" %02x %-16s 0x%02x %d\n", i, strDevType,
            GetI2CDevicesEntryAddress(pgv, i),
            GetI2CDevicesEntryExtComPort(pgv, i));

  }


}

LwU32 GetConnectorEntry(PGV pgv, LwU32 idx)
{
  LwU32 data = 0;
  pgv->LwrrentFileOffset = pgv->g3x.cnctr.EntryBase +
          idx*pgv->g3x.cnctr.EntrySize;
  if (pgv->g3x.cnctr.EntrySize == 2)
  {
      data = (LwU32) pgv->gIP.GetLwU16(pgv);
      data &= 0xFFFF;
  }
  else
  {
      data = pgv->gIP.GetLwU32(pgv);
  }
  return data;
}

LwU32 GetConnectorEntryType(PGV pgv, LwU32 idx)
{
  return ((GetConnectorEntry(pgv, idx)    ) & 0xFF);
}

LwU32 GetConnectorEntryLocation(PGV pgv, LwU32 idx)
{
  return ((GetConnectorEntry(pgv, idx)>> 8) & 0x0F);
}

LwU32 GetConnectorEntryHotplugA(PGV pgv, LwU32 idx)
{
  return ((GetConnectorEntry(pgv, idx)>>12) & 0x01);
}

LwU32 GetConnectorEntryHotplugB(PGV pgv, LwU32 idx)
{
  return ((GetConnectorEntry(pgv, idx)>>13) & 0x01);
}

LwU32 GetConnectorEntryPSRFrameLockA(PGV pgv, LwU32 idx)
{
  return ((GetConnectorEntry(pgv, idx)>>27) & 0x01);
}

void DescribeConnectorTable(PGV pgv)
{
  LwU32 i;
  LwU32 AllSkipEntries = 1;
  char strCnctrType[32];

  // Check for all skip entries
  for(i=0; i<pgv->g3x.cnctr.EntryCount; i++)
  {
    if(GetConnectorEntryType(pgv, i) == 0xFF)
      continue;

    AllSkipEntries = 0;
    break;
  }
  if(AllSkipEntries)
  {
    if(pgv->RuntimeFlags & RT_VERBOSE)
    {
      dprintf("Connector Table: ALL SKIP ENTRIES!\n\n");
    }
    return;
  }

  dprintf("Connector Table:\n");
  dprintf("  Platform: ");
  switch(pgv->g3x.cnctr.Platform)
  {
    case 0x00: dprintf("Normal Add-in Card\n");                    break;
    case 0x01: dprintf("Two Back Plate Add-in Card\n");            break;
    case 0x02: dprintf("Add-in Configurable Card\n");              break;
    case 0x07: dprintf("Desktop with Integrated full DP\n");       break;
    case 0x08: dprintf("Mobile Add-in Card\n");                    break;
    case 0x09: dprintf("MXM Module\n");                            break;
    case 0x10: dprintf("Mobile with back connectors\n");           break;
    case 0x11: dprintf("Mobile with back and left connectors\n");  break;
    case 0x18: dprintf("Mobile with dock connectors\n");           break;
    case 0x20: dprintf("Crush normal back plate\n");               break;
    default:   dprintf("???0x%02x???\n", pgv->g3x.cnctr.Platform); break;
  }
  if (pgv->DCBVersion >= 0x40)
    dprintf("  #  Type                      Location HP DP DIS LCDID\n");
  else
    dprintf("  #  Type                      Location A B\n");

  for(i=0; i<pgv->g3x.cnctr.EntryCount; i++)
  {
    // Look for skip entries
    if(GetConnectorEntryType(pgv, i) == 0xFF)
    {
      if(pgv->RuntimeFlags & RT_VERBOSE)
      {
          dprintf("  %-2d SKIP ENTRY\n", i);
      }
      continue;
    }

    switch(GetConnectorEntryType(pgv, i))
    {
      case 0x00: sprintf(strCnctrType, "VGA 15-pin");                     break;
      case 0x01: sprintf(strCnctrType, "DVI-A");                          break;
      case 0x02: sprintf(strCnctrType, "Pod - VGA 15-pin");               break;
      case 0x10: sprintf(strCnctrType, "TV Composite");                   break;
      case 0x11: sprintf(strCnctrType, "TV SVideo");                      break;
      case 0x12: sprintf(strCnctrType, "TV SVideo->Composite");           break;
      case 0x13: sprintf(strCnctrType, "TV HDTV - YPrPb");                break;
      case 0x14: sprintf(strCnctrType, "TV SCART");                       break;
      case 0x16: sprintf(strCnctrType, "TV Cmpst SCART on Blue D-cnctr"); break;
      case 0x17: sprintf(strCnctrType, "TV HDTV-EIAJ4120 (D-cnctr)");     break;
      case 0x18: sprintf(strCnctrType, "Pod HDTV - YPrPb");               break;
      case 0x19: sprintf(strCnctrType, "Pod SVideo");                     break;
      case 0x1A: sprintf(strCnctrType, "Pod Composite");                  break;
      case 0x20: sprintf(strCnctrType, "DVI-I+TV SVideo");                break;
      case 0x21: sprintf(strCnctrType, "DVI-I+TV Composite");             break;
      case 0x22: sprintf(strCnctrType, "DVI-I+TV Svideo->Composite");     break;
      case 0x30: sprintf(strCnctrType, "DVI-I");                          break;
      case 0x31: sprintf(strCnctrType, "DVI-D");                          break;
      case 0x32: sprintf(strCnctrType, "Apple Display Connector");        break;
      case 0x38: sprintf(strCnctrType, "LFH->DVI-I-1");                   break;
      case 0x39: sprintf(strCnctrType, "LFH->DVI-I-2");                   break;
      case 0x3A: sprintf(strCnctrType, "LFH->SVideo");                    break;
      case 0x3C: sprintf(strCnctrType, "BNC Connector");                  break;
      case 0x40: sprintf(strCnctrType, "LVDS-SPWG-Attached");             break;
      case 0x41: sprintf(strCnctrType, "LVDS-OEM-Attached");              break;
      case 0x42: sprintf(strCnctrType, "LVDS-SPWG-Detached");             break;
      case 0x43: sprintf(strCnctrType, "LVDS-OEM-Detached");              break;
      case 0x45: sprintf(strCnctrType, "TMDS-OEM-Attached");              break;
      case 0x46: sprintf(strCnctrType, "DisplayPort External");           break;
      case 0x47: sprintf(strCnctrType, "DisplayPort Internal");           break;
      case 0x48: sprintf(strCnctrType, "DisplayPort (Mini) External");    break;
      case 0x50: sprintf(strCnctrType, "VGA 15-pin if not docked");       break;
      case 0x51: sprintf(strCnctrType, "VGA 15-pin if docked");           break;
      case 0x52: sprintf(strCnctrType, "DVI-I if not docked");            break;
      case 0x53: sprintf(strCnctrType, "DVI-I if docked");                break;
      case 0x54: sprintf(strCnctrType, "DVI-D if not docked");            break;
      case 0x55: sprintf(strCnctrType, "DVI-D if docked");                break;
      case 0x56: sprintf(strCnctrType, "DP Ext. if not docked");          break;
      case 0x57: sprintf(strCnctrType, "DP Ext. if docked");              break;
      case 0x58: sprintf(strCnctrType, "DP Mini Ext. if not docked");     break;
      case 0x59: sprintf(strCnctrType, "DP Mini Ext. if docked");         break;
      case 0x60: sprintf(strCnctrType, "Stereo 3-Pin DIN");               break;
      case 0x61: sprintf(strCnctrType, "HDMI-A");                         break;
      case 0x62: sprintf(strCnctrType, "Audio S/PDIF");                   break;
      case 0x63: sprintf(strCnctrType, "HDMI-C (Mini)");                  break;
      case 0x64: sprintf(strCnctrType, "LFH-DP-1");                       break;
      case 0x65: sprintf(strCnctrType, "LDH-DP-2");                       break;
      case 0x70: sprintf(strCnctrType, "Virtual WiFi Display");           break;
      case 0x71: sprintf(strCnctrType, "USB Type -C");                    break;
      case 0x72: sprintf(strCnctrType, "DSI");                            break;

      default: sprintf(strCnctrType, "??0x%x??", GetConnectorEntryType(pgv, i));  break;
    }

    if (pgv->DCBVersion >= 0x40)
    {
      dprintf("  %-2d %-27s 0x%02x   %s  %s  %s    0x%x\n", i, strCnctrType,
              GetConnectorEntryLocation(pgv, i),
              (GetConnectorEntryHotplugA(pgv, i)?"A":
                (GetConnectorEntryHotplugB(pgv, i)?"B":
                  (GetConnectorEntryHotplugC_4x(pgv, i)?"C":
                    (GetConnectorEntryHotplugD_4x(pgv, i)?"D":
                      (GetConnectorEntryHotplugE_4x(pgv, i)?"E":
                        (GetConnectorEntryHotplugF_4x(pgv, i)?"F":
                          (GetConnectorEntryHotplugG_4x(pgv, i)?"G":" "))))))),
              (GetConnectorEntryDP2DVIA_4x(pgv, i)?"A":
                (GetConnectorEntryDP2DVIB_4x(pgv, i)?"B":
                  (GetConnectorEntryDP2DVIC_4x(pgv, i)?"C":
                    (GetConnectorEntryDP2DVID_4x(pgv, i)?"D":" ")))),
              (GetConnectorEntryDPAuxI2CSelectA_4x(pgv, i)?"A":
                (GetConnectorEntryDPAuxI2CSelectB_4x(pgv, i)?"B":
                  (GetConnectorEntryDPAuxI2CSelectC_4x(pgv, i)?"C":
                    (GetConnectorEntryDPAuxI2CSelectD_4x(pgv, i)?"D":" ")))),
              (GetConnectorEntryLcdId_4x(pgv, i)));
    }
    else
    {
      dprintf("  %02x %-27s 0x%02x   %s %s\n", i, strCnctrType,
              GetConnectorEntryLocation(pgv, i),
              (GetConnectorEntryHotplugA(pgv, i)?"Y":" "),
              (GetConnectorEntryHotplugB(pgv, i)?"Y":" ") );
    }

  }

#ifdef INTERNAL
  if (pgv->RuntimeFlags & RT_VERBOSE)
  {
    dprintf("  Column Definitions:\n");
    dprintf("          #: Index in Connector Table\n");
    dprintf("       Type: Connector Name/Type\n");
    dprintf("   Location: Number value representation of location\n");
    dprintf("         HP: Hotplug association to GPIO\n");
    dprintf("         DP: Display Port to DVI Hotplug association to GPIO\n");
    dprintf("        DIS: DPAux/I2C switch association to GPIO\n");
  }
#endif
}

LwU16 GetDacOutputEntry(PGV pgv, LwU32 idx)
{
  pgv->LwrrentFileOffset = pgv->g3x.dacOut.EntryBase + idx*pgv->g3x.dacOut.EntrySize;
  return pgv->gIP.GetLwU16(pgv);
}

LwU16 GetDacOutputEntryAmp10(PGV pgv, LwU32 idx)
{
  return ((GetDacOutputEntry(pgv, idx)    ) & 0x1F);
}

LwU16 GetDacOutputEntryScalerValue10(PGV pgv, LwU32 idx)
{
  return ((GetDacOutputEntry(pgv, idx)>> 5) & 0x3FF);
}

LwU16 GetDacOutputEntryScalerBypass10(PGV pgv, LwU32 idx)
{
  return ((GetDacOutputEntry(pgv, idx)>>15) &   0x1);
}

LwU16 GetDacOutputEntryAmp(PGV pgv, LwU32 idx)
{
  return ((GetDacOutputEntry(pgv, idx)    ) & 0xFF);
}

LwU16 GetDacOutputEntryScalerValue(PGV pgv, LwU32 idx)
{
  return ((GetDacOutputEntry(pgv, idx)>> 8) & 0x7F);
}

LwU16 GetDacOutputEntryScalerBypass(PGV pgv, LwU32 idx)
{
  return ((GetDacOutputEntry(pgv, idx)>>15) &   0x1);
}


LwU8 GetDacFusemapCount(PGV pgv, LwU32 dac)
{
  pgv->LwrrentFileOffset = pgv->g3x.dacOut.DACFuseMap[dac];
  return pgv->gIP.GetLwU8(pgv);
}

LwU32 GetDacFusemapEntryRegister(PGV pgv, LwU32 dac, LwU32 idx)
{
  // First entry is right after the count (1 byte)
  // Each entry is defined specifically as 5 bytes wide where the register is the first 4 bytes
  pgv->LwrrentFileOffset = pgv->g3x.dacOut.DACFuseMap[dac] + 1 + idx*5;
  return pgv->gIP.GetLwU32(pgv);
}

LwU8 GetDacFusemapEntryShift(PGV pgv, LwU32 dac, LwU32 idx)
{
  // First entry is right after the count (1 byte)
  // Each entry is defined specifically as 5 bytes wide where the shift is the last byte
  pgv->LwrrentFileOffset = pgv->g3x.dacOut.DACFuseMap[dac] + 1 + idx*5 + 4;
  return pgv->gIP.GetLwU8(pgv);
}


void DescribeDacOutputTable(PGV pgv)
{
#ifdef INTERNAL
  LwU32 i, j, count;
  char strOutputType[32];

  if(!pgv->g3x.dacOut.TablePointer)
  {
     return;
  }

  if(!pgv->g3x.dacOut.DACFuseMap[0])
  {
    dprintf("DAC Output Table:\n");
    dprintf("  D# Dev  Scaler Amp  Byp:\n");

    for(i=0; i<pgv->g3x.dacOut.EntryCount; i++)
    {
      if (pgv->g3x.dacOut.Version <= 0x10)
      {
        dprintf("  %d  %s 0x%03x  %2d   %c\n",
                i,
                (i==0)?"CRT ":
                  (i==1)?"SDTV":
                    (i==2)?"HDTV":"????",
                GetDacOutputEntryScalerValue10(pgv, i),
                GetDacOutputEntryAmp10(pgv, i),
                GetDacOutputEntryScalerBypass10(pgv, i)?'Y':'N');
      }
      else
      {
        dprintf("  %d  %s 0x%03x  %2d   %c\n",
                i,
                (i==0)?"CRT ":
                  (i==1)?"SDTV":
                    (i==2)?"HDTV":"????",
                GetDacOutputEntryScalerValue(pgv, i),
                GetDacOutputEntryAmp(pgv, i),
                GetDacOutputEntryScalerBypass(pgv, i)?'Y':'N');
      }
    }
  }
  else
  {
    dprintf("DAC Output Table:\n");
    dprintf("  D#  FV Dev        Scaler Amp  Byp:\n");

    for(i=0; i<pgv->g3x.dacOut.EntryCount; i++)
    {
      switch(i%7)
      {
        case 0x00: sprintf(strOutputType, "DAC B CRT ");         break;
        case 0x01: sprintf(strOutputType, "DAC B SDTV");         break;
        case 0x02: sprintf(strOutputType, "DAC B HDTV");         break;
        case 0x03: sprintf(strOutputType, "DAC A CRT ");         break;
        case 0x04: sprintf(strOutputType, "DAC A SDTV");         break;
        case 0x05: sprintf(strOutputType, "DAC A HDTV");         break;
        case 0x06: sprintf(strOutputType, "DAC C CRT ");         break;
        default:   sprintf(strOutputType, " ???%d???  ",(int)i); break;
      }

      dprintf("  %2d  %2d %s 0x%03x  %2d   %c\n",
              i,
              i/7,
              strOutputType,
              GetDacOutputEntryScalerValue(pgv, i),
              GetDacOutputEntryAmp(pgv, i),
              GetDacOutputEntryScalerBypass(pgv, i)?'Y':'N');
    }

    // Loop over 3 dacs (A, B, C)
    for(i=0; i<3; i++)
    {
      count = GetDacFusemapCount(pgv, i);
      dprintf("DAC%c Fusemap Table: Entry Count: %d\n",
              (char)('A'+(char)i),
              count);
      for(j=0; j<count; j++)
      {
        dprintf("  FUSE VALUE BIT(%d): Bar0 Offset: 0x%08x   Shift: %d\n",
                 count-j-1,
                 GetDacFusemapEntryRegister(pgv, i, j),
                 GetDacFusemapEntryShift(pgv, i, j));
      }
    }

  }
#endif // INTERNAL
}

void CheckDacOutputLevelTable(PGV pgv)
{
#ifdef INTERNAL
  LwU32 maxEntries, countA, countB, countC;

  // Check for version
  if(pgv->DCBVersion < 0x30)
    return;

  // Not in DCB 4.0!
  if(pgv->DCBVersion >= 0x40)
    return;

  if ( (pgv->g3x.dacOut.DACFuseMap[0]) ||
       (pgv->g3x.dacOut.DACFuseMap[1]) ||
       (pgv->g3x.dacOut.DACFuseMap[2]) )
  {
    if (!pgv->g3x.dacOut.DACFuseMap[0])
    {
      dprintf("ERROR: DCB DAC Output Level Table DAC A Fusemap Ptr == 0\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
    if (!pgv->g3x.dacOut.DACFuseMap[1])
    {
      dprintf("ERROR: DCB DAC Output Level Table DAC B Fusemap Ptr == 0\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
    if (!pgv->g3x.dacOut.DACFuseMap[2])
    {
      dprintf("ERROR: DCB DAC Output Level Table DAC C Fusemap Ptr == 0\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }

    // Get the max count for each DACFuseMap table
    countA = (LwU32) GetDacFusemapCount(pgv, 0);
    countB = (LwU32) GetDacFusemapCount(pgv, 1);
    countC = (LwU32) GetDacFusemapCount(pgv, 2);

    // Max FUSE VALUE = 2^(max number of Fuse entries)
    // Each set of entries requires 7 different values
    // But let's shave one set here so that we can add subsets later...
    maxEntries = 7 * ((1 << countA)-1);

    //
    // We're removing the ERROR check here since it's possible that the VBIOS itself
    // will not allocate all possible values for each of the fuse tables since HW
    // might only assign fuse numbers for specific FUSEVALUEs.  Kaymann found this
    // and requested this change.
    //

    // Max number of entries needed defined depends on the count for each fusemap
    // For DAC A, we need to define entries 3, 4, and 5 of each set.
    if (pgv->g3x.dacOut.EntryCount < (maxEntries+6))
    {
    //   dprintf("ERROR: DCB DAC Output Level Table Entry Count is too low to satify the possible DAC A FUSE VALUEs\n");
    //   dprintf("       Entry Count: %d    Max DAC A FUSE VALUE: %d    Max Entry count needed for DAC A: %d\n",
    //                   pgv->g3x.dacOut.EntryCount, ((1 << countA)-1), (maxEntries+6));
    //   pgv->exitValue = 5;
    //  ErrorCountCheck(pgv);
    }

    maxEntries = 7 * ((1 << countB)-1);

    // Max number of entries needed defined depends on the count for each fusemap
    // For DAC B, we need to define entries 0, 1, and 2 of each set.
    if (pgv->g3x.dacOut.EntryCount < (maxEntries+3))
    {
    //    dprintf("ERROR: DCB DAC Output Level Table Entry Count is too low to satify the possible DAC B FUSE VALUEs\n");
    //    dprintf("       Entry Count: %d    Max DAC B FUSE VALUE: %d    Max Entry count needed for DAC B: %d\n",
    //                    pgv->g3x.dacOut.EntryCount, ((1 << countB)-1), (maxEntries+3));
    //    pgv->exitValue = 5;
    //    ErrorCountCheck(pgv);
    }

    maxEntries = 7 * ((1 << countC)-1);

    // Max number of entries needed defined depends on the count for each fusemap
    // For DAC C, we need to define entry 6 of each set.
    if (pgv->g3x.dacOut.EntryCount < (maxEntries+7))
    {
    //    dprintf("ERROR: DCB DAC Output Level Table Entry Count is too low to satify the possible DAC A FUSE VALUEs\n");
    //    dprintf("       Entry Count: %d    Max DAC C FUSE VALUE: %d    Max Entry count needed for DAC C: %d\n",
    //                    pgv->g3x.dacOut.EntryCount, ((1 << countC)-1), (maxEntries+7));
    //    pgv->exitValue = 5;
    //    ErrorCountCheck(pgv);
    }
  }

#endif // INTERNAL
}








/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2002-2020 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

/******************************** DCBChecker *******************************\
*                                                                           *
* Module: dcb1x.c                                                           *
* This module handles all DCB 2X routines.                                  *
*                                                                           *
* Written by Steve Rogers (srogers@lwpu.com)                              *
* Let me know if you have any questions/comments/suggestions.               *
*                                                                           *
\***************************************************************************/

#ifdef SEPARATE_COMP // Not used in LWwatch compile
#if !defined(LW_MAC_KEXT)
#include <stdio.h>
#include <stdlib.h>
#endif //!defined(LW_MAC_KEXT)
#include <string.h>

#include "dcbchk.h"
#endif //SEPARATE_COMP


LwU32 getHeadMask_4x(PGV pgv, LwU32 idx)
{
  return ((getDisplayPath_3x(pgv, idx)>>8) & 0xF);
}

LwU32 getVirtualDevice_4x(PGV pgv, LwU32 idx)
{
  return ((getDisplayPath_3x(pgv, idx)>>28) & 0x1);
}

LwU32 getDFPSubLinks_4x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)>>4 )&0x03);
}
LwU32 getDFPDPLink_4x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)>>4 )&0x03);
}


LwU32 getDFPDPMaxLinkRate_4x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)>>21)&0x07);
}
LwU32 getDFPDPMaxLaneMask_4x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)>>24)&0x0F);
}

LwU32 getTVSDFormat_4x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)    )&0x07);
}

LwU32 getTVHDFormat_4x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)>>23)&0x0F);
}


LwU32 getLCDHDCP_4x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)>>16)&0x01);
}

LwU32 getLCDHDMI_4x(PGV pgv, LwU32 idx)
{
  return ((getDisplaySpecific_3x(pgv, idx)>>17)&0x01);
}


void strcatMiscStr_4x(PGV pgv, LwU32 idx, char*str)
{
  char spfvar[16]      = {0};
  switch(pgv->gIP.GetType(pgv, idx))
  {
    case TYPE_CRT:
      break;
    case TYPE_TV:
      pgv->gIP.strcatTVEncoderName(pgv, idx, str);
      strcat(str, "SD:");
      switch(getTVSDFormat_4x(pgv, idx))
      {
        case 0x0: strcat(str, "NTSC-M");     break;
        case 0x1: strcat(str, "NTSC-J");     break;
        case 0x2: strcat(str, "PAL-M");      break;
        case 0x3: strcat(str, "PAL-BDGHI");  break;
        case 0x4: strcat(str, "PAL-N");      break;
        case 0x5: strcat(str, "PAL-NC");     break;
        case 0x7: strcat(str, "Straps");     break;
        default:
            sprintf(spfvar, "??%d??", (int)getTVSDFormat_4x(pgv, idx));
            strcat(str, spfvar);
            break;
      }
      strcat(str, MYFS"HD:");
      switch(getTVHDFormat_4x(pgv, idx))
      {
        case 0x0: strcat(str, "576i");    break;
        case 0x1: strcat(str, "480i");    break;
        case 0x2: strcat(str, "480p60");  break;
        case 0x3: strcat(str, "576p50");  break;
        case 0x4: strcat(str, "720p50");  break;
        case 0x5: strcat(str, "720p60");  break;
        case 0x6: strcat(str, "1080i50"); break;
        case 0x7: strcat(str, "1080i60"); break;
        case 0x8: strcat(str, "1080p24"); break;
        case 0xF: strcat(str, "Straps");  break;
        default:
            sprintf(spfvar, "??%d??", (int)getTVHDFormat_4x(pgv, idx));
            strcat(str, spfvar);
            break;
      }
      {
        LwU32 TVDACs = pgv->gIP.GetTVDACs(pgv, idx);
        if(TVDACs)
        {
          strcat(str, MYFS"DACS:");
          switch(TVDACs)
          {
            case 0x01: strcat(str, "R");       break;
            case 0x02: strcat(str, "G");       break;
            case 0x03: strcat(str, "RG");      break;
            case 0x04: strcat(str, "B");       break;
            case 0x05: strcat(str, "BR");      break;
            case 0x06: strcat(str, "BG");      break;
            case 0x07: strcat(str, "BGR");     break;
            case 0x08: strcat(str, "Std.HD");  break;
            case 0x09: strcat(str, "HD+B=Ch"); break;
            case 0x0A: strcat(str, "SCARTA");  break;
            case 0x0B: strcat(str, "HD+CV=D"); break;
            case 0x0C: strcat(str, "SCRT+HD"); break;
            case 0x0D: strcat(str, "HD!SD");   break;
            case 0x0E: strcat(str, "SCARTE");  break;
            case 0x0F: strcat(str, "SCARTF");  break;
            case 0x11: strcat(str, "HD+Cmps"); break;
            case 0x12: strcat(str, "SCT+HD1"); break;
            case 0x13: strcat(str, "SVideo");  break;
            default:
              sprintf(spfvar, "?0x%02x?", (int)TVDACs);
              strcat(str, spfvar);
              break;
          }
        }
      }
      break;
    case TYPE_LVDS:
    case TYPE_TMDS:
    case TYPE_SDI:
    case TYPE_DP:
      switch(pgv->gIP.GetLCDDDC(pgv, idx))
      {
        case 0x0:  strcat(str, "DDC"MYFS);   break;
        case 0x1:  strcat(str, "Strap"MYFS); break;
        case 0x2:  strcat(str, "SBIOS"MYFS); break;
      }
      switch(pgv->gIP.GetLCDControl(pgv, idx))
      {
        case 0x0:  strcat(str, "Ext");    break;
        case 0x1:  strcat(str, "Script"); break;
        case 0x2:  strcat(str, "SBIOS");  break;
      }
      pgv->gIP.strcatLCDEncoderName(pgv, idx, str);
      break;
    case TYPE_WBD:
      // NOTE HCDP field is negative polarity: 0=Allow, 1=Disable
      if(!getLCDHDCP_4x(pgv, idx))
      {
        strcat(str, "HDCP");
      }
      break;
    default: // do nothing!
      break;
  }

}



void getMiscStr_4x(PGV pgv, LwU32 idx, char*str)
{
}

void DescribeMisc_4x(PGV pgv, LwU32 idx)
{
  char Misc[MISC_STR_SPACE*2] = {0};
  char spfvar[16] = {0};

  sprintf(spfvar, "%c %c %-2d ",
          (getBootRemoved_3x(pgv, idx)?'N':'Y'),
          (getBlindBootRemoved_3x(pgv, idx)?'N':'Y'),
          (int)getConnectorIndex_3x(pgv, idx));
  strcat(Misc, spfvar);

  strcatMiscStr_4x(pgv, idx, Misc);

  switch(pgv->gIP.GetType(pgv, idx))
  {
    case TYPE_TV:
      sprintf(spfvar, MYFS"ctrs:%d",
              (int)pgv->g3x.GetTVConnectorCount(pgv, idx));
      strcat(Misc, spfvar);
      if(pgv->gIP.GetLocation(pgv, idx) == LOCATION_BOARD)
      {
        sprintf(spfvar, MYFS"I2CCom:%d", getExtI2CPort_3x(pgv, idx));
        strcat(Misc, spfvar);
      }
      break;
    case TYPE_TMDS:
    case TYPE_LVDS:
    case TYPE_SDI:
      if(pgv->gIP.GetLocation(pgv, idx) == LOCATION_BOARD)
      {
        sprintf(spfvar, MYFS"I2CCom:%d", getExtI2CPort_3x(pgv, idx));
        strcat(Misc, spfvar);
      }
      else if(pgv->DCBVersion < 0x41)
      {
        sprintf(spfvar, MYFS"SL:");
        strcat(Misc, spfvar);
        switch(getDFPSubLinks_4x(pgv, idx))
        {
          case 1:  sprintf(spfvar, "A");  break;
          case 2:  sprintf(spfvar, "B");  break;
          case 3:  sprintf(spfvar, "AB"); break;
          default: sprintf(spfvar, "?%d?", (int)getDFPSubLinks_4x(pgv, idx)); break;
        }
        strcat(Misc, spfvar);
      }
      else
      {
        sprintf(spfvar, MYFS"PL:");
        strcat(Misc, spfvar);
        switch(getDFPSubLinks_4x(pgv, idx))
        {
          case 1:  sprintf(spfvar, "0");  break;
          case 2:  sprintf(spfvar, "1");  break;
          case 3:  sprintf(spfvar, "0,1"); break;
          default: sprintf(spfvar, "?%d?", (int)getDFPSubLinks_4x(pgv, idx)); break;
        }
        strcat(Misc, spfvar);
      }

      // NOTE HCDP field is negative polarity: 0=Allow, 1=Disable
      if(!getLCDHDCP_4x(pgv, idx))
      {
        sprintf(spfvar, MYFS"HDCP");
        strcat(Misc, spfvar);
      }

      if(getLCDHDMI_4x(pgv, idx))
      {
        sprintf(spfvar, MYFS"HDMI");
        strcat(Misc, spfvar);
      }

      break;
    case TYPE_DP:
      if(pgv->gIP.GetLocation(pgv, idx) == LOCATION_BOARD)
      {
        sprintf(spfvar, MYFS"I2CCom:%d", getExtI2CPort_3x(pgv, idx));
        strcat(Misc, spfvar);
      }

      sprintf(spfvar, MYFS"DPLink:0x");
      strcat(Misc, spfvar);
      sprintf(spfvar, "%x", getDFPDPLink_4x(pgv, idx));
      strcat(Misc, spfvar);

      // Go ahead and split this up.  It's going over 80 columns
      dprintf("%s\n", Misc);

      Misc[0] = '\0';

      strcat(Misc, "                                 ");

      sprintf(spfvar, MYFS"MLR:");
      strcat(Misc, spfvar);
      switch(getDFPDPMaxLinkRate_4x(pgv, idx))
      {
        case 0:  sprintf(spfvar, "1.62Gbs");  break;
        case 1:  sprintf(spfvar, "2.7Gbs");   break;
        case 2:  sprintf(spfvar, "5.4Gbs");   break;
        case 3:  sprintf(spfvar, "8.1Gbs");   break;
        default: sprintf(spfvar, "?%d?", (int)getDFPDPMaxLinkRate_4x(pgv, idx)); break;
      }
      strcat(Misc, spfvar);

      sprintf(spfvar, MYFS"MxLM:0x");
      strcat(Misc, spfvar);
      sprintf(spfvar, "%x", getDFPDPMaxLaneMask_4x(pgv, idx));
      strcat(Misc, spfvar);

      // NOTE HCDP field is negative polarity: 0=Allow, 1=Disable
      if(!getLCDHDCP_4x(pgv, idx))
      {
        sprintf(spfvar, MYFS"HDCP");
        strcat(Misc, spfvar);
      }

      if(getLCDHDMI_4x(pgv, idx))
      {
        sprintf(spfvar, MYFS"HDMI");
        strcat(Misc, spfvar);
      }

      break;
  }

  if (getVirtualDevice_4x(pgv, idx))
  {
    if (strlen(Misc) > 7)
    {
      sprintf(spfvar, MYFS"Virtual");
    }
    else
    {
      sprintf(spfvar, "Virtual");
    }
    strcat(Misc, spfvar);
  }

  if(strlen(Misc) > MISC_STR_SPACE)
  {
    dprintf("DCBCHK ERROR: Misc string space is too long.  Cropping to %d.\n", MISC_STR_SPACE);
    Misc[MISC_STR_SPACE-1] = '\0';
  }

  dprintf("%s\n", Misc);
}

void DescribeMultichipMIOPorts_4x(PGV pgv)
{
  if(pgv->g3x.Flags & 0xFC)
  {
    dprintf("Multichip: ");
    /*
    if(pgv->g3x.Flags & 0x0C)
    {
      dprintf("PIOR 0:");
      if(pgv->g3x.Flags & 0x0C)
        dprintf("Pin Set:");
      if(pgv->g3x.Flags & 0x04)
        dprintf("Input");
      if( (pgv->g3x.Flags & 0x0C) == 0x0C)
        dprintf("+");
      if(pgv->g3x.Flags & 0x08)
        dprintf("Output");
    }
    if(pgv->g3x.Flags & 0x30)
    {
      dprintf("PIOR 1:");
      if(pgv->g3x.Flags & 0x10)
        dprintf("Input");
      if( (pgv->g3x.Flags & 0x30) == 0x30)
        dprintf("+");
      if(pgv->g3x.Flags & 0x20)
        dprintf("Output");
      dprintf("  ");
    }
    */
    if(pgv->g3x.Flags & 0xC0)
    {
      if(pgv->g3x.Flags & 0xC0)
        dprintf("Pin Set:");
      if(pgv->g3x.Flags & 0x40)
        dprintf("A");
      if( (pgv->g3x.Flags & 0xC0) == 0xC0)
        dprintf("+");
      if(pgv->g3x.Flags & 0x80)
        dprintf("B");
    }
    dprintf("\n");
  }
}


// GPIO functions here
// This is new to DCB 4.0 since we have 32 bits per GPIO entry now
LwU32 GetGpioEntry_40(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  pgv->LwrrentFileOffset = Base + idx*Size;
  return pgv->gIP.GetLwU32(pgv);
}

LwU32 GetGpioNumber_40(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry_40(pgv, idx, Base, Size))&0x1F);
}

LwU32 GetGpioLockPin_40(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry_40(pgv, idx, Base, Size)>>5)&0x07);
}

LwU32 GetGpioFunction_40(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry_40(pgv, idx, Base, Size)>>8)&0xFF);
}

LwU32 GetGpioIOType_40(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry_40(pgv, idx, Base, Size)>>16)&0x7);
}

LwU32 GetGPIOGSYNCRasterSync_40(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry_40(pgv, idx, Base, Size)>>20)&0x1);
}

LwU32 GetGPIOGSYNCFlipLock_40(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry_40(pgv, idx, Base, Size)>>21)&0x1);
}

LwU32 GetGpioOnMode_40(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry_40(pgv, idx, Base, Size)>>22)&0x3);
}

LwU32 GetGpioInit_40(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry_40(pgv, idx, Base, Size)>>24)&0x1);
}

LwU32 GetGpioOffMode_40(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry_40(pgv, idx, Base, Size)>>25)&0x3);
}

LwU32 GetGpioOffData_40(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry_40(pgv, idx, Base, Size)>>27)&0x1);
}

LwU32 GetGpioOffEnable_40(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry_40(pgv, idx, Base, Size)>>28)&0x1);
}

LwU32 GetGpioOnData_40(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry_40(pgv, idx, Base, Size)>>29)&0x1);
}

LwU32 GetGpioOnEnable_40(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry_40(pgv, idx, Base, Size)>>30)&0x1);
}

LwU32 GetGpioPWM_40(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry_40(pgv, idx, Base, Size)>>31)&0x1);
}

// GPIO Table version 4.1 will change the size and location of fields
// For starters, the entry size is 5 bytes now.  So, we'll use
// GetGpioEntry_40() for the first four bytes.
LwU32 GetGpioEntry2_41(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  pgv->LwrrentFileOffset = Base + idx*Size + 4;
  return (LwU32) pgv->gIP.GetLwU8(pgv);
}

LwU32 GetGpioNumber_41(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry_40(pgv, idx, Base, Size))&0x3F);
}

LwU32 GetGpioIOType_41(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry_40(pgv, idx, Base, Size)>>6)&0x1);
}

LwU32 GetGpioInit_41(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry_40(pgv, idx, Base, Size)>>7)&0x1);
}

// Version 4.1 Function is the same as before

LwU32 GetGpioOutputHwSelect_41(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry_40(pgv, idx, Base, Size)>>16)&0xFF);
}

LwU32 GetGpioInputHwSelect_41(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry_40(pgv, idx, Base, Size)>>24)&0x1F);
}

LwU32 GetGpioGSYNC_41(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry_40(pgv, idx, Base, Size)>>29)&0x1);
}

LwU32 GetGpioPWM_41(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry_40(pgv, idx, Base, Size)>>31)&0x1);
}

LwU32 GetGpioLockPin_41(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry2_41(pgv, idx, Base, Size))&0xF);
}

LwU32 GetGpioOffData_41(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry2_41(pgv, idx, Base, Size)>>4)&0x1);
}

LwU32 GetGpioOffEnable_41(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry2_41(pgv, idx, Base, Size)>>5)&0x1);
}

LwU32 GetGpioOnData_41(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry2_41(pgv, idx, Base, Size)>>6)&0x1);
}

LwU32 GetGpioOnEnable_41(PGV pgv, LwU32 idx, LwU32 Base, LwU32 Size)
{
  return ((GetGpioEntry2_41(pgv, idx, Base, Size)>>7)&0x1);
}


void DescribeExternalGpioAssignments_4x(PGV pgv)
{
  LwU32 i, AllSkipEntries = 1;
  LwU32 k; // loop over all Specific Tables
  LwU32 spPointer, spHeaderSize, spEntryCount, spEntrySize;
  LwU32 spEntryBase, spType, spI2CAddr, spByte7, spExtDevInt, spComPort;
  LwU32 spVersion;

  char funcText[20];
  char *inout[] = {"output", "input"};

  if(!(pgv->g3x.extGpio.MasterPointer) ||
     !(pgv->g3x.extGpio.MasterEntryCount) )
  {
    return;
  }

  for(k=0; k<pgv->g3x.extGpio.MasterEntryCount; k++)
  {
    pgv->LwrrentFileOffset = pgv->g3x.extGpio.MasterPointer +
                             pgv->g3x.extGpio.MasterHeaderSize +
                             k * pgv->g3x.extGpio.MasterEntrySize;
    spPointer = pgv->gIP.GetLwU16(pgv);

    // Skip 0 pointers
    if(!spPointer)
    {
      dprintf("External GPIO Assignment Table %d: Pointer is 0. Skipping.\n", k);
      continue;
    }

    pgv->LwrrentFileOffset = spPointer;
    spVersion    = pgv->gIP.GetLwU8(pgv);
    spHeaderSize = pgv->gIP.GetLwU8(pgv);
    spEntryBase  = spPointer + spHeaderSize;
    spEntryCount = pgv->gIP.GetLwU8(pgv);
    spEntrySize  = pgv->gIP.GetLwU8(pgv);
    spType       = pgv->gIP.GetLwU8(pgv);
    spI2CAddr    = pgv->gIP.GetLwU8(pgv);
    spByte7      = pgv->gIP.GetLwU8(pgv);
    spComPort    = (spByte7 & 0x10) >> 4;
    spExtDevInt  = (spByte7 & 0x3);

    if(!spType)
    {
      // This is a skip entry.  No need to do anything else
      continue;
    }

    if(!spEntryCount)
    {
      dprintf("External GPIO Assignment Table %d: 0 Entries\n", k);
      continue;
    }

    // Check for all skip entries
    for (i = 0; i < spEntryCount; i++)
    {
      if(GetGpioFunction_40(pgv, i, spEntryBase, spEntrySize) != 0x3F)
      {
        AllSkipEntries = 0;
        break;
      }
    }
    if(AllSkipEntries)
    {
      if(pgv->RuntimeFlags & RT_VERBOSE)
      {
        dprintf("External GPIO Assignment Table %d: All Skip Entries\n", k);
      }
      continue;
    }

    dprintf("External GPIO Assignment Table %d:\n", k);
    dprintf("  Type:");
    switch(spType)
    {
      case 1:   dprintf("PCA9555 for 10-pin Personal Cinema VIVO pods  ");   break;
      case 2:   dprintf("ADT7473 Automatic Fan Controller Chip   ");         break;
      case 3:   dprintf("CX25875 General Purpose Output Pins   ");           break;
      case 4:   dprintf("PCA9555 for MXM External HDMI Control   ");         break;
      case 5:   dprintf("PCA9536 for HDMI/DVI Multiplexing   ");             break;
      case 6:   dprintf("PCA9555 for MXM GPIOs   ");                         break;
      case 7:   dprintf("PCA9536 for MXM GPIOs   ");                         break;
      case 8:   dprintf("PCA9555 for SPDif Detect and TV Resolution LEDs  ");break;
      case 9:   dprintf("ANX9805 External DP Encoder GPIOs  ");              break;

      default:  dprintf("??%x??  ", spType); break;
    }
    dprintf("I2CAddr:0x%x  C:%d  Int:%d\n", spI2CAddr, spComPort, spExtDevInt);

    for (i = 0; i < spEntryCount; i++)
    {
      LwU32 gpioOffData, gpioOffEnable, gpioOnData, gpioOnEnable;
      LwU32 gpioFunction, gpioPinNumber, gpioPWM, gpioInit;

      // This is the same between 40 and 41
      gpioFunction  = GetGpioFunction_40 (pgv, i, spEntryBase, spEntrySize);

      if (spVersion == 0x40)
      {
        gpioOffData   = GetGpioOffData_40  (pgv, i, spEntryBase, spEntrySize);
        gpioOffEnable = GetGpioOffEnable_40(pgv, i, spEntryBase, spEntrySize);
        gpioOnData    = GetGpioOnData_40   (pgv, i, spEntryBase, spEntrySize);
        gpioOnEnable  = GetGpioOnEnable_40 (pgv, i, spEntryBase, spEntrySize);
        gpioPinNumber = GetGpioNumber_40   (pgv, i, spEntryBase, spEntrySize);
        gpioPWM       = GetGpioPWM_40      (pgv, i, spEntryBase, spEntrySize);
        gpioInit      = GetGpioInit_40     (pgv, i, spEntryBase, spEntrySize);
      }
      else if (spVersion == 0x41)
      {
        gpioOffData   = GetGpioOffData_41  (pgv, i, spEntryBase, spEntrySize);
        gpioOffEnable = GetGpioOffEnable_41(pgv, i, spEntryBase, spEntrySize);
        gpioOnData    = GetGpioOnData_41   (pgv, i, spEntryBase, spEntrySize);
        gpioOnEnable  = GetGpioOnEnable_41 (pgv, i, spEntryBase, spEntrySize);
        gpioPinNumber = GetGpioNumber_41   (pgv, i, spEntryBase, spEntrySize);
        gpioPWM       = GetGpioPWM_41      (pgv, i, spEntryBase, spEntrySize);
        gpioInit      = GetGpioInit_41     (pgv, i, spEntryBase, spEntrySize);
      }
      else
      {
        dprintf("  Unknown GPIO Specific Table Version: 0x%x\n", spVersion);
        break;
      }

      // DCB 3.0 has skip entries, but unfortunately, external gpios
      // define skip entries as 0 instead of 0x3F like GPU gpios
      if(gpioFunction == 0x0)
      {
        if(pgv->RuntimeFlags & RT_VERBOSE)
        {
            dprintf ("  SKIP ENTRY\n");
        }
        continue;
      }

      ExtGpioFunctionText(spType, gpioFunction, funcText);

      dprintf ("  %-4d  %-13s  ", gpioPinNumber, funcText);

      if ( (gpioOffData   == 0) &&
           (gpioOffEnable == 0) &&
           (gpioOnData    == 1) &&
           (gpioOnEnable  == 0) )
        dprintf ("standard output  ");
      else if ( (gpioOffData   == 1) &&
                (gpioOffEnable == 0) &&
                (gpioOnData    == 0) &&
                (gpioOnEnable  == 0) )
        dprintf ("ilwerted output  ");
      else if ( (gpioOffData   == 0) &&
                (gpioOffEnable == 1) &&
                (gpioOnData    == 1) &&
                (gpioOnEnable  == 1) )
        dprintf ("standard input   ");
      else if ( (gpioOffData   == 1) &&
                (gpioOffEnable == 1) &&
                (gpioOnData    == 0) &&
                (gpioOnEnable  == 1) )
        dprintf ("ilwerted input   ");
      else if ( (gpioOffData   == 0) &&
                (gpioOffEnable == 0) &&
                (gpioOnData    == 1) &&
                (gpioOnEnable  == 1) )
        dprintf ("tristate voltage ");
      else
        dprintf ("OFF: %s %d  ON: %s %d ",
          inout[gpioOffEnable], gpioOffData,
          inout[gpioOnEnable], gpioOnData);

      if (gpioPWM)
          dprintf ("PWM ");

      // Note: External GPIOs do not have a mode, output/input HW
      // select, I/O type, nor GSYNC capabilities

      if (gpioInit)
          dprintf ("Init:On ");
      else
          dprintf ("Init:Off ");

      dprintf("\n");
    }

  }


}

void DescribeGpioAssignments_4x(PGV pgv)
{
  LwU32 i, AllSkipEntries = 1;

  char funcText[20];
  char *inout[] = {"output", "input"};

  if (pgv->GPIOHeaderPtr == 0x0)
  {
    dprintf("No GPIO Assignment table allocated.\n");
    return;
  }

  if (pgv->GPIOEntryCount == 0)
  {
    dprintf("GPIO Assignment table has 0 entries.\n");
    return;
  }

  // Check for all skip entries
  if(pgv->DCBVersion >= 0x30)
  {
    for (i = 0; i < pgv->GPIOEntryCount; i++)
    {
      // DCB 3.0 has skip entries
      if(GetGpioFunction_40(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize) != 0xFF)
        AllSkipEntries = 0;
    }
    if(AllSkipEntries)
    {
      if(pgv->RuntimeFlags & RT_VERBOSE)
      {
        dprintf("GPIO Assignment table has all Skip Entries.\n");
      }
      return;
    }
  }

  dprintf("GPIO Assignment Table:\n");
  dprintf("  GPIO L# F#  Function       Type\n");

  for (i = 0; i < pgv->GPIOEntryCount; i++)
  {
    LwU32 gpioOffData, gpioOffEnable, gpioOnData, gpioOnEnable;
    LwU32 gpioFunction, gpioIOType, gpioPinNumber, gpioLockPin;
    LwU32 gpioPWM, gpioInit;

    // This is the same between 40 and 41
    gpioFunction  = GetGpioFunction_40 (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);

    if (pgv->GPIOVersion == 0x40)
    {
      gpioOffData   = GetGpioOffData_40  (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      gpioOffEnable = GetGpioOffEnable_40(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      gpioOnData    = GetGpioOnData_40   (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      gpioOnEnable  = GetGpioOnEnable_40 (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      gpioIOType    = GetGpioIOType_40   (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      gpioPinNumber = GetGpioNumber_40   (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      gpioLockPin   = GetGpioLockPin_40  (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      gpioPWM       = GetGpioPWM_40      (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      gpioInit      = GetGpioInit_40     (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
    }
    else if (pgv->GPIOVersion == 0x41)
    {
      gpioOffData   = GetGpioOffData_41  (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      gpioOffEnable = GetGpioOffEnable_41(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      gpioOnData    = GetGpioOnData_41   (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      gpioOnEnable  = GetGpioOnEnable_41 (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      gpioIOType    = GetGpioIOType_41   (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      gpioPinNumber = GetGpioNumber_41   (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      gpioLockPin   = GetGpioLockPin_41  (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      gpioPWM       = GetGpioPWM_41      (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      gpioInit      = GetGpioInit_41     (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
    }
    else
    {
      dprintf("  Unknown GPIO Table Version: 0x%x\n", pgv->GPIOVersion);
      break;
    }

    // DCB 4.0 has skip entries
    if(gpioFunction == 0xFF)
    {
      if(pgv->RuntimeFlags & RT_VERBOSE)
      {
        dprintf ("           SKIP ENTRY\n");
      }
      continue;
    }

    GpioFunctionText(gpioFunction, funcText);

    // Print the GPIO pin # first.
    switch (gpioIOType)
    {
      // IO_TYPE_GPIO
      case 0:
        dprintf ("  %-4d ", gpioPinNumber);
        break;
      // IO_TYPE_DEDICATED_LOCK_PIN
      case 1:
        dprintf ("       ");
        break;
      default:
        dprintf ("  ???? ");
        break;
    }

    // print out the lock pin number if needed next - bug 550879
    switch(gpioFunction)
    {
      case 15:  // StereoToggle
      case 63:  // ExtSync0
      case 64:  // SLI Raster Sync A
      case 65:  // SLI Raster Sync B
      case 66:  // Swap Ready In A
      case 112: // Swap Ready In B
      case 133: // PSR FrameLock pin
          dprintf ("%-2d ", gpioLockPin);
          break;
      default:
          dprintf ("   ");
          break;
    }

    dprintf ("%-3d %-13s  ",
             gpioFunction,
             funcText);

    if ( (gpioOffData   == 0) &&
         (gpioOffEnable == 0) &&
         (gpioOnData    == 1) &&
         (gpioOnEnable  == 0) )
      dprintf ("std.out  ");
    else if ( (gpioOffData   == 1) &&
              (gpioOffEnable == 0) &&
              (gpioOnData    == 0) &&
              (gpioOnEnable  == 0) )
      dprintf ("ilw.out  ");
    else if ( (gpioOffData   == 0) &&
              (gpioOffEnable == 1) &&
              (gpioOnData    == 1) &&
              (gpioOnEnable  == 1) )
      dprintf ("std.in   ");
    else if ( (gpioOffData   == 1) &&
              (gpioOffEnable == 1) &&
              (gpioOnData    == 0) &&
              (gpioOnEnable  == 1) )
      dprintf ("ilw.in   ");
    else if ( (gpioOffData   == 0) &&
              (gpioOffEnable == 0) &&
              (gpioOnData    == 1) &&
              (gpioOnEnable  == 1) )
      dprintf ("tristate ");
    else
      dprintf ("OFF: %s %d  ON: %s %d ",
        inout[gpioOffEnable], gpioOffData,
        inout[gpioOnEnable], gpioOnData);

    if (gpioPWM)
      dprintf ("PWM ");
    else
      dprintf ("    ");

    if (pgv->GPIOVersion == 0x40)
    {
      dprintf ("Mode: Off:");
      switch (GetGpioOffMode_40(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize))
      {
          default:
          case 0: dprintf ("Nrm"); break;
          case 1: dprintf ("Alt"); break;
          case 2: dprintf ("Seq"); break;
          case 3: dprintf ("?3?"); break;
      }
      dprintf ("On:");
      switch (GetGpioOnMode_40(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize))
      {
          default:
          case 0: dprintf ("Nrm"); break;
          case 1: dprintf ("Alt"); break;
          case 2: dprintf ("Seq"); break;
          case 3: dprintf ("?3?"); break;
      }
    }

    if (gpioInit)
        dprintf (" Init:On ");
    else
        dprintf (" Init:Off");

    if (pgv->GPIOVersion == 0x40)
    {
      if (GetGPIOGSYNCRasterSync_40(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize))
      {
        dprintf(" GS:RS");
      }

      if (GetGPIOGSYNCFlipLock_40(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize))
      {
        dprintf(" GS:FL");
      }
    }
    else if (pgv->GPIOVersion == 0x41)
    {
      dprintf ("  HWSel: %02X:%02X",
               GetGpioOutputHwSelect_41(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize),
               GetGpioInputHwSelect_41(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize));


      if (GetGpioGSYNC_41(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize))
      {
        dprintf(" GS");
      }
    }

    dprintf("\n");
  }

#ifdef INTERNAL
  if (pgv->RuntimeFlags & RT_VERBOSE)
  {
    dprintf("  Column Definitions:\n");
    dprintf("       GPIO: GPIO Pin - This can be empty for dedicated lock pins.\n");
    dprintf("         L#: Lock Pin - This can be empty for GPIOs that don't use a lock pin.\n");
    dprintf("         F#: The GPIO function number.\n");
    dprintf("   Function: The GPIO function description.\n");
    dprintf("       Type: The extra information about the GPIO setup.  Here's some defines:\n");
    dprintf("             std.out: Standard Output\n");
    dprintf("             ilw.out: Ilwerted Output\n");
    dprintf("              std.in: Standard Input\n");
    dprintf("              ilw.in: Ilwerted Input\n");
    dprintf("            tristate: Tristate voltage\n");
    dprintf("             OFF a b: In logical OFF state, set the data output to a, and \n");
    dprintf("                      the enable bit to b.\n");
    dprintf("              ON c d: In logical ON state, set the data output to c, and \n");
    dprintf("                      the enable bit to d.\n");
    dprintf("                 PWM: This GPIO support pulse width modulation on it's output.\n");
    if (pgv->GPIOVersion == 0x40)
    {
      dprintf("     Mode Off:x On:y: The GPIO mode in the logical OFF/ON states. Examples:\n");
      dprintf("                      Nrm: Normal GPIO.\n");
      dprintf("                      Alt: Alternate use enabled.\n");
      dprintf("                      Seq: Sequencer use enabled.\n");
    }
    dprintf("                Init: The logical OFF/ON state to set during initialization.\n");
    if (pgv->GPIOVersion == 0x40)
    {
      dprintf("               GS:RS: GSYNC Raster Sync.\n");
      dprintf("               GS:FL: GSYNC Flip Lock.\n");
    }
    else if (pgv->GPIOVersion == 0x41)
    {
      dprintf("               HWSel: HW Select: Output:Input\n");
      dprintf("                  GS: GSYNC\n");
    }
  }
#endif

}

LwU16 GetSSEntry_4x(PGV pgv, LwU32 idx)
{
  LwU16 mask = 0xFFFF;
  pgv->LwrrentFileOffset = pgv->g4x.ss.EntryBase + idx*pgv->g4x.ss.EntrySize;
  if (pgv->g4x.ss.EntrySize == 1)
  {
      mask = 0xFF;
  }
  return (pgv->gIP.GetLwU16(pgv) & mask);
}

LwU16 GetSSEntryValid_4x(PGV pgv, LwU32 idx)
{
  return ((GetSSEntry_4x(pgv, idx)   )&0x1);
}
LwU16 GetSSEntryVPLLSource_4x(PGV pgv, LwU32 idx)
{
  return ((GetSSEntry_4x(pgv, idx)>>1)&0x3);
}
LwU16 GetSSEntryDCBIndex_4x(PGV pgv, LwU32 idx)
{
  return ((GetSSEntry_4x(pgv, idx)>>4)&0xF);
}
LwU16 GetSSEntryFreqDelta_4x(PGV pgv, LwU32 idx)
{
  return ((GetSSEntry_4x(pgv, idx)>>8)&0x3F);
}
LwU16 GetSSEntryType_4x(PGV pgv, LwU32 idx)
{
  return ((GetSSEntry_4x(pgv, idx)>>14)&0x1);
}


void DescribeSSTable_4x(PGV pgv)
{
  LwU32 i;
  LwU32 AllSkipEntries = 1;

  if(pgv->g3x.ss.Version != 0x41)
    return;

  if(!pgv->g4x.ss.EntryCount)
    return;

  for(i=0; i<pgv->g4x.ss.EntryCount; i++)
  {
    if(GetSSEntryValid_4x(pgv, i))
    {
      if (GetSSEntryDCBIndex_4x(pgv, i) < pgv->DCBEntryCount)
      {
        AllSkipEntries = 0;
      }
    }
  }

  if(AllSkipEntries)
  {
    if(pgv->RuntimeFlags & RT_VERBOSE)
    {
      dprintf("Spread Spectrum Table: All SKIP ENTRIES\n");
    }
    return;
  }

  dprintf("Spread Spectrum Table:\n");

  dprintf("  Index  VPLL Source\n");
  for(i=0; i<pgv->g4x.ss.EntryCount; i++)
  {
    if(!GetSSEntryValid_4x(pgv, i))
    {
      if(pgv->RuntimeFlags & RT_VERBOSE)
      {
        dprintf("   INVALID ENTRY\n");
      }
      continue;
    }

    if (GetSSEntryDCBIndex_4x(pgv, i) >= pgv->DCBEntryCount)
    {
      if(pgv->RuntimeFlags & RT_VERBOSE)
      {
          dprintf("   INVALID DCB INDEX\n");
      }
      continue;
    }

    dprintf("   %-3d   ", GetSSEntryDCBIndex_4x(pgv, i));
    switch(GetSSEntryVPLLSource_4x(pgv, i))
    {
      case 0x0: dprintf("GPU Internal Source 0   "); break;
      case 0x1: dprintf("GPU Internal Source 1   "); break;
      case 0x2: dprintf("GPU External Source     ");   break;
      case 0x3: dprintf("Pll Internal Mechanism  ");   break;
      default:  dprintf("??%d??:    ", GetSSEntryVPLLSource_4x(pgv, i)); break;
    }

    if ( (pgv->g4x.ss.EntrySize >= 2) &&
         (GetSSEntryVPLLSource_4x(pgv, i) == 3) )
    {
        dprintf("FreqDelta: %d.%02d%%,  Type: %s",
                (GetSSEntryFreqDelta_4x(pgv, i)*5)/100,
                (GetSSEntryFreqDelta_4x(pgv, i)*5)%100,
                ((GetSSEntryType_4x(pgv, i)==1)?"Down":"Center"));
    }
    dprintf("\n");
  }
}


LwU32 GetI2CDevicesEntryWriteAccess_40(PGV pgv, LwU32 idx)
{
  return ((GetI2CDevicesEntry(pgv, idx)>>21) & 0x7);
}
LwU32 GetI2CDevicesEntryReadAccess_40(PGV pgv, LwU32 idx)
{
  return ((GetI2CDevicesEntry(pgv, idx)>>24) & 0x7);
}


void DescribeI2CDevicesTable_4x(PGV pgv)
{
  LwU32 i;
  LwU32 AllSkipEntries = 1;
  char strDevType[16];
  char strWAccess[16];
  char strRAccess[16];

  // Check for all skip entries
  for(i=0; i<pgv->g3x.i2cdev.EntryCount; i++)
  {
    if(GetI2CDevicesEntryType(pgv, i) == 0xFF)
      continue;

    AllSkipEntries = 0;
    break;
  }
  if(AllSkipEntries)
  {
    if(pgv->RuntimeFlags & RT_VERBOSE)
    {
      dprintf("I2C Devices Table: ALL SKIP ENTRIES!\n");
    }
    return;
  }

  dprintf("I2C Devices Table:  Flags: 0x%x\n", pgv->g3x.i2cdev.Flags);
  dprintf("  #  Type             Addr C       Write / Read\n");
  for(i=0; i<pgv->g3x.i2cdev.EntryCount; i++)
  {
    // Look for skip entries
    if(GetI2CDevicesEntryType(pgv, i) == 0xFF)
    {
      if(pgv->RuntimeFlags & RT_VERBOSE)
      {
        dprintf("  %-2d SKIP ENTRY\n", i);
      }
      continue;
    }

    switch(GetI2CDevicesEntryType(pgv, i))
    {
      case 0x01: sprintf(strDevType, "Th:ADM 1032");     break;
      case 0x02: sprintf(strDevType, "Th:MAX 6649");     break;
      case 0x03: sprintf(strDevType, "Th:LM99");         break;
      case 0x06: sprintf(strDevType, "Th:MAX 1617");     break;
      case 0x07: sprintf(strDevType, "Th:LM64");         break;
      case 0x0A: sprintf(strDevType, "Th:ADT7473");      break;
      case 0x0B: sprintf(strDevType, "Th:LM89");         break;
      case 0x0C: sprintf(strDevType, "Th:TMP411");       break;
      case 0x0D: sprintf(strDevType, "Th:ADT7461");      break;
      case 0x0E: sprintf(strDevType, "Th:TMP451");       break;
      case 0x0F: sprintf(strDevType, "Th:TMP461");       break;

      case 0x30: sprintf(strDevType, "AD:ADS1112");      break;
      case 0x3F: sprintf(strDevType, "Pc:NCP81276");     break;
      case 0x40: sprintf(strDevType, "Pc:VT1103");       break;
      case 0x41: sprintf(strDevType, "Pc:PX3540");       break;
      case 0x42: sprintf(strDevType, "Pc:VT1165");       break;
      case 0x43: sprintf(strDevType, "Pc:CHL8203+");     break;
      case 0x44: sprintf(strDevType, "Pc:NCP4208");      break;
      case 0x45: sprintf(strDevType, "Pc:MP2888+");      break;
      case 0x46: sprintf(strDevType, "Pc:NCP81610");     break;
      case 0x47: sprintf(strDevType, "Pc:uP9512");       break;
      case 0x48: sprintf(strDevType, "Pc:CHL8221A//B+"); break;
      case 0x49: sprintf(strDevType, "Pc:CHL8266+");     break;
      case 0x4A: sprintf(strDevType, "Pc:DS4424N");      break;
      case 0x4B: sprintf(strDevType, "Pc:NCT3933U");     break;
      case 0x4C: sprintf(strDevType, "Ps:INA219");       break;
      case 0x4D: sprintf(strDevType, "Ps:INA209");       break;
      case 0x4E: sprintf(strDevType, "Ps:INA3221");      break;
      case 0x4F: sprintf(strDevType, "Ps:INA226");       break;
      case 0x50: sprintf(strDevType, "Cg:CY2XP304");     break;
      case 0x51: sprintf(strDevType, "Cg:SI570");        break;
      case 0x60: sprintf(strDevType, "Gp:PCA9555");      break;
      case 0x61: sprintf(strDevType, "Gp:TCA6408ARGTR"); break;
      case 0x62: sprintf(strDevType, "Gp:TCA6424ARGJR"); break;
      case 0x70: sprintf(strDevType, "Fn:ADT7473");      break;
      case 0x80: sprintf(strDevType, "HDMI:SI1930uC");   break;
      case 0x82: sprintf(strDevType, "Gp:PCA9536");      break;
      case 0x90: sprintf(strDevType, "HDCP:KeyEEPROM");  break;
      case 0x91: sprintf(strDevType, "MLW:STM_RGB_LED"); break;
      case 0x92: sprintf(strDevType, "MLW:STM_SLI_LED"); break;
      case 0x95: sprintf(strDevType, "MLW:CCIPORTCPLD"); break;
      case 0x98: sprintf(strDevType, "MLW:GMAC_MC");     break;
      case 0xA0: sprintf(strDevType, "InfoRom");         break;
      case 0xA1: sprintf(strDevType, "Bridge ID ROM");   break;
      case 0xA2: sprintf(strDevType, "MLW:CCIPART0IPM"); break;
      case 0xA3: sprintf(strDevType, "MLW:CCIPART1IPM"); break;
      case 0xAA: sprintf(strDevType, "CEC1702/CEC1712"); break;
      case 0xB0: sprintf(strDevType, "I2CS:GPU");        break;
      case 0xB1: sprintf(strDevType, "I2CS:GPU:GF11X");  break;
      case 0xC0: sprintf(strDevType, "Pc:PIC16F690SYN"); break;
      case 0xD2: sprintf(strDevType, "CDFPLOWERPADDLE"); break;
      case 0xD3: sprintf(strDevType, "CDFPUPPERPADDLE"); break;
      case 0xE0: sprintf(strDevType, "I2CS:PSR");        break;
      default:   sprintf(strDevType, "??0x%x??",
                         (int)GetI2CDevicesEntryType(pgv,i)); break;
    }

    // Printing this out is for bug 800809
    switch (GetI2CDevicesEntryWriteAccess_40(pgv, i))
    {
      case 0x00: sprintf(strWAccess, "     Public");     break;
      case 0x01: sprintf(strWAccess, "Priviledged");     break;
      case 0x02: sprintf(strWAccess, "   Internal");     break;
      case 0x03: sprintf(strWAccess, "  No Access");     break;
      default:   sprintf(strWAccess, "   ??0x%x??",
                         (int)GetI2CDevicesEntryWriteAccess_40(pgv,i)); break;
    }

    switch (GetI2CDevicesEntryReadAccess_40(pgv, i))
    {
      case 0x00: sprintf(strRAccess, "Public     ");     break;
      case 0x01: sprintf(strRAccess, "Priviledged");     break;
      case 0x02: sprintf(strRAccess, "Internal   ");     break;
      case 0x03: sprintf(strRAccess, "No Access  ");     break;
      default:   sprintf(strRAccess, "??0x%x??   ",
                         (int)GetI2CDevicesEntryReadAccess_40(pgv,i)); break;
    }

    dprintf("  %-2d %-16s 0x%02x %d %s / %s\n", i, strDevType,
            (int)GetI2CDevicesEntryAddress(pgv, i),
            GetI2CDevicesEntryExtComPort(pgv, i),
            strWAccess, strRAccess);

  }
  if (pgv->RuntimeFlags & RT_VERBOSE)
  {
    dprintf("  Column Definitions:\n");
    dprintf("          #: Entry index\n");
    dprintf("       Type: Type of device.\n");
    dprintf("       Addr: 8-bit aligned, right shifted 7-bit address of the I2C device.\n");
    dprintf("          C: External Communications Port, 0=Primary, 1=Secondary.\n");
    dprintf("      Write: Write Access to this device\n");
    dprintf("       Read: Read Access to this device\n");
  }
}

LwU32 GetConnectorEntryDP2DVIA_4x(PGV pgv, LwU32 idx)
{
  return ((GetConnectorEntry(pgv, idx)>>14) & 0x01);
}
LwU32 GetConnectorEntryDP2DVIB_4x(PGV pgv, LwU32 idx)
{
  return ((GetConnectorEntry(pgv, idx)>>15) & 0x01);
}


LwU32 GetConnectorEntryHotplugC_4x(PGV pgv, LwU32 idx)
{
  return ((GetConnectorEntry(pgv, idx)>>16) & 0x01);
}

LwU32 GetConnectorEntryHotplugD_4x(PGV pgv, LwU32 idx)
{
  return ((GetConnectorEntry(pgv, idx)>>17) & 0x01);
}

LwU32 GetConnectorEntryDP2DVIC_4x(PGV pgv, LwU32 idx)
{
  return ((GetConnectorEntry(pgv, idx)>>18) & 0x01);
}

LwU32 GetConnectorEntryDP2DVID_4x(PGV pgv, LwU32 idx)
{
  return ((GetConnectorEntry(pgv, idx)>>19) & 0x01);
}


LwU32 GetConnectorEntryDPAuxI2CSelectA_4x(PGV pgv, LwU32 idx)
{
  return ((GetConnectorEntry(pgv, idx)>>20) & 0x01);
}
LwU32 GetConnectorEntryDPAuxI2CSelectB_4x(PGV pgv, LwU32 idx)
{
  return ((GetConnectorEntry(pgv, idx)>>21) & 0x01);
}
LwU32 GetConnectorEntryDPAuxI2CSelectC_4x(PGV pgv, LwU32 idx)
{
  return ((GetConnectorEntry(pgv, idx)>>22) & 0x01);
}
LwU32 GetConnectorEntryDPAuxI2CSelectD_4x(PGV pgv, LwU32 idx)
{
  return ((GetConnectorEntry(pgv, idx)>>23) & 0x01);
}

LwU32 GetConnectorEntryHotplugE_4x(PGV pgv, LwU32 idx)
{
  return ((GetConnectorEntry(pgv, idx)>>24) & 0x01);
}
LwU32 GetConnectorEntryHotplugF_4x(PGV pgv, LwU32 idx)
{
  return ((GetConnectorEntry(pgv, idx)>>25) & 0x01);
}
LwU32 GetConnectorEntryHotplugG_4x(PGV pgv, LwU32 idx)
{
  return ((GetConnectorEntry(pgv, idx)>>26) & 0x01);
}

LwU32 GetConnectorEntryPSRFrameLockA_4x(PGV pgv, LwU32 idx)
{
  return ((GetConnectorEntry(pgv, idx)>>27) & 0x01);
}

LwU32 GetConnectorEntryLcdId_4x(PGV pgv, LwU32 idx)
{
  return ((GetConnectorEntry(pgv, idx)>>28) & 0x07);
}

LwU8 GetHdtvXlateEntry(PGV pgv, LwU32 idx)
{
  pgv->LwrrentFileOffset = pgv->g4x.hdxl.EntryBase +
                             idx * pgv->g4x.hdxl.EntrySize;
  return pgv->gIP.GetLwU8(pgv);
}

LwU8 GetHdtvXlateStandard(PGV pgv, LwU32 idx)
{
  return (GetHdtvXlateEntry(pgv, idx) & 0xF);
}

void DescribeHdtvTranslationTable(PGV pgv)
{
  LwU32 i;

  if (!pgv->g4x.hdxl.EntryCount)
  {
    return;
  }

  dprintf("HDTV Translation Table:\n");
  dprintf("  # Standard\n");
  for (i=0; i<pgv->g4x.hdxl.EntryCount; i++)
  {
    dprintf(" %2d ", i);
    switch(GetHdtvXlateStandard(pgv, i))
    {
      case 0:  dprintf("HD576i");     break;
      case 1:  dprintf("HD480i");     break;
      case 2:  dprintf("HD480p_60");  break;
      case 3:  dprintf("HD576p_50");  break;
      case 4:  dprintf("HD720p_50");  break;
      case 5:  dprintf("HD720p_60");  break;
      case 6:  dprintf("HD1080i_50"); break;
      case 7:  dprintf("HD1080i_60"); break;
      case 8:  dprintf("HD1080p_24"); break;
      default: dprintf("??0x%x??", (int)GetHdtvXlateStandard(pgv, i)); break;
    }
    dprintf("\n");
  }
}

LwU32 GetSwitchedOutputsEntryField0(PGV pgv, LwU32 idx)
{
  pgv->LwrrentFileOffset = pgv->g4x.swout.EntryBase +
                             idx * pgv->g4x.swout.EntrySize;
  return pgv->gIP.GetLwU32(pgv);
}
LwU8 GetSwitchedOutputsEntryField1(PGV pgv, LwU32 idx)
{
  pgv->LwrrentFileOffset = pgv->g4x.swout.EntryBase +
                             idx * pgv->g4x.swout.EntrySize + 4;
  return pgv->gIP.GetLwU8(pgv);
}

LwU32 GetSwitchedOutputsDcbIndex(PGV pgv, LwU32 idx)
{
  return ((GetSwitchedOutputsEntryField0(pgv, idx)      ) & 0x1F);
}

LwU32 GetSwitchedOutputsDeviceSelectionType(PGV pgv, LwU32 idx)
{
  return ((GetSwitchedOutputsEntryField0(pgv, idx) >>  8) & 0x01);
}
LwU32 GetSwitchedOutputsDeviceSelectionPin(PGV pgv, LwU32 idx)
{
  return ((GetSwitchedOutputsEntryField0(pgv, idx) >>  9) & 0x1F);
}
LwU32 GetSwitchedOutputsDeviceSelectionState(PGV pgv, LwU32 idx)
{
  return ((GetSwitchedOutputsEntryField0(pgv, idx) >> 14) & 0x01);
}

LwU32 GetSwitchedOutputsDeviceDetectionType(PGV pgv, LwU32 idx)
{
  return ((GetSwitchedOutputsEntryField0(pgv, idx) >> 16) & 0x01);
}
LwU32 GetSwitchedOutputsDeviceDetectionPin(PGV pgv, LwU32 idx)
{
  return ((GetSwitchedOutputsEntryField0(pgv, idx) >> 17) & 0x1F);
}
LwU32 GetSwitchedOutputsDeviceDetectionState(PGV pgv, LwU32 idx)
{
  return ((GetSwitchedOutputsEntryField0(pgv, idx) >> 22) & 0x01);
}

LwU32 GetSwitchedOutputsDeviceLoadType(PGV pgv, LwU32 idx)
{
  return ((GetSwitchedOutputsEntryField0(pgv, idx) >> 24) & 0x01);
}
LwU32 GetSwitchedOutputsDeviceLoadPin(PGV pgv, LwU32 idx)
{
  return ((GetSwitchedOutputsEntryField0(pgv, idx) >> 25) & 0x1F);
}
LwU32 GetSwitchedOutputsDeviceLoadState(PGV pgv, LwU32 idx)
{
  return ((GetSwitchedOutputsEntryField0(pgv, idx) >> 30) & 0x01);
}

LwU32 GetSwitchedOutputsDeviceDDCType(PGV pgv, LwU32 idx)
{
  return (LwU32)((GetSwitchedOutputsEntryField1(pgv, idx)      ) & 0x01);
}
LwU32 GetSwitchedOutputsDeviceDDCPin(PGV pgv, LwU32 idx)
{
  return (LwU32)((GetSwitchedOutputsEntryField1(pgv, idx) >>  1) & 0x1F);
}
LwU32 GetSwitchedOutputsDeviceDDCState(PGV pgv, LwU32 idx)
{
  return (LwU32)((GetSwitchedOutputsEntryField1(pgv, idx) >>  6) & 0x01);
}


void DescribeSwitchedOutputsTable(PGV pgv)
{
  LwU32 i;
  LwU32 AllSkips = 1;

  if (!pgv->g4x.swout.EntryCount)
  {
    return;
  }

  // First search to make sure there are entries
  for (i=0; i<pgv->g4x.swout.EntryCount; i++)
  {
    if (GetSwitchedOutputsDcbIndex(pgv, i) < pgv->DCBEntryCount)
    {
      if ( ((GetSwitchedOutputsEntryField0(pgv, i) & 0x3E3E3E00) != 0x3E3E3E00) ||
           ((GetSwitchedOutputsEntryField1(pgv, i) & 0x3E) != 0x3E) )
      {
        AllSkips = 0;
        break;
      }
    }
  }

  if (AllSkips)
  {
    if(pgv->RuntimeFlags & RT_VERBOSE)
    {
      dprintf("Switch Outputs Table: All SKIP ENTRIES\n");
    }
    return;
  }

  dprintf("Switched Outputs Table:\n");
  dprintf("  ##  Select  Device  Load    DDC\n");
  dprintf("      L P  S  L P  S  L P  S  L P  S\n");
  for (i=0; i<pgv->g4x.swout.EntryCount; i++)
  {
    if (GetSwitchedOutputsDcbIndex(pgv, i) >= pgv->DCBEntryCount)
    {
      if(pgv->RuntimeFlags & RT_VERBOSE)
      {
        dprintf(" DCB Index > DCB Entry Count\n");
      }
      continue;
    }

    if ( ((GetSwitchedOutputsEntryField0(pgv, i) & 0x3E3E3E00) == 0x3E3E3E00) &&
         ((GetSwitchedOutputsEntryField1(pgv, i) &       0x3E) ==       0x3E) )
    {
      if(pgv->RuntimeFlags & RT_VERBOSE)
      {
        dprintf("  SKIP ENTRY\n");
      }
      continue;
    }

    dprintf(" %2d   ", GetSwitchedOutputsDcbIndex(pgv, i));


    if (GetSwitchedOutputsDeviceSelectionPin(pgv, i) != 0x1F)
    {
      dprintf("%c %-2d %d  ",
              (GetSwitchedOutputsDeviceSelectionType(pgv, i)?'E':'I'),
              GetSwitchedOutputsDeviceSelectionPin(pgv, i),
              GetSwitchedOutputsDeviceSelectionState(pgv, i));
    }
    else
    {
      dprintf("        ");
    }

    if (GetSwitchedOutputsDeviceDetectionPin(pgv, i) != 0x1F)
    {
      dprintf("%c %-2d %d  ",
              (GetSwitchedOutputsDeviceDetectionType(pgv, i)?'E':'I'),
              GetSwitchedOutputsDeviceDetectionPin(pgv, i),
              GetSwitchedOutputsDeviceDetectionState(pgv, i));
    }
    else
    {
      dprintf("        ");
    }

    if (GetSwitchedOutputsDeviceLoadPin(pgv, i) != 0x1F)
    {
      dprintf("%c %-2d %d  ",
              (GetSwitchedOutputsDeviceLoadType(pgv, i)?'E':'I'),
              GetSwitchedOutputsDeviceLoadPin(pgv, i),
              GetSwitchedOutputsDeviceLoadState(pgv, i));
    }
    else
    {
      dprintf("        ");
    }


    if (GetSwitchedOutputsDeviceDDCPin(pgv, i) != 0x1F)
    {
      dprintf("%c %-2d %d  ",
              (GetSwitchedOutputsDeviceDDCType(pgv, i)?'E':'I'),
              GetSwitchedOutputsDeviceDDCPin(pgv, i),
              GetSwitchedOutputsDeviceDDCState(pgv, i));
    }
    else
    {
      dprintf("        ");
    }

    dprintf("\n");
  }

#ifdef INTERNAL
  if (pgv->RuntimeFlags & RT_VERBOSE)
  {
    dprintf("  Column Definitions:\n");
    dprintf("         ##: DCB Index associated with this entry\n");
    dprintf("     Select: GPIO state to select this device.\n");
    dprintf("     Detect: GPIO state to set before detecting device.\n");
    dprintf("       Load: GPIO state to read for load detecting this device.\n");
    dprintf("        DDC: GPIO state to set before using DDC for this device.\n");
    dprintf("          L: Location of GPIO control, I=Internal, E=External\n");
    dprintf("          P: GPIO Pin number\n");
    dprintf("          S: GPIO Logical State, 0=OFF 1=ON\n");
  }
#endif
}


void DescribeTables_4x(PGV pgv)
{
  // Multi-chip bits
  DescribeMultichipMIOPorts_4x(pgv);

  // GPIO table
  DescribeGpioAssignments_4x(pgv);

  // GPIO table
  DescribeExternalGpioAssignments_4x(pgv);

  // InputDevices
  DescribeInputDevices_2x(pgv);

  // Personal Cinema Info
  DescribePersonalCinemaInfo_2x(pgv);
  if(pgv->gPCD.Version > 0x30)
    DescribePersonalCinemaInfo_3x(pgv);

  // Spread Spectrum Info
  if (pgv->g3x.ss.Version == 0x40)
  {
    DescribeSSTable(pgv);
  }
  else
  {
    DescribeSSTable_4x(pgv);
  }

  // I2C Devices Table
  DescribeI2CDevicesTable_4x(pgv);

  // Connector Table
  DescribeConnectorTable(pgv);

  DescribeHdtvTranslationTable(pgv);

  DescribeSwitchedOutputsTable(pgv);
}

void InitializeDCB40Data(PGV pgv)
{
  LwU8 HeaderSize        = 0;
  LwU16 I2CControlPtr     = 0;
  LwU8 I2CHeaderSize     = 0;
  LwU32 DCBSignature      = 0;
  LwU8 GPIOHeaderSize    = 0;
  LwU8 InpDevHeaderSize  = 0;
  LwU16 PersonalCinemaPtr = 0;
  LwU16 SpreadSpectrumPtr = 0;
  LwU8 SSHeaderSize      = 0;
  LwU16 I2CDevicesPtr     = 0;
  LwU8 I2CDevHeaderSize  = 0;
  LwU16 ConnectorPtr      = 0;
  LwU8 ConnectHeaderSize = 0;
  LwU8 PriSecI2CPort     = 0;
  LwU16 HdtvXlatePtr      = 0;
  LwU8 HdtvXlateHdrSize  = 0;
  LwU16 SwitchOutPtr      = 0;
  LwU8 SwitchOutHdrSize  = 0;
  LwU32 DevicesPatchPtr         = 0;
  LwU8 DevicesPatchHdrSize     = 0;
  LwU32 ConnectorsPatchPtr      = 0;
  LwU8 ConnectorsPatchHdrSize  = 0;

  // Initialize base pointers
#ifndef SEPARATE_COMP // !LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
  dprintf("Reading DCB Base Ptrs\r");
#endif
#endif
  pgv->LwrrentFileOffset = pgv->DCBHeaderPtr+1;
  HeaderSize             = pgv->gIP.GetLwU8(pgv);
  pgv->DCBEntryCount     = pgv->gIP.GetLwU8(pgv);
  pgv->DCBEntrySize      = pgv->gIP.GetLwU8(pgv);
  I2CControlPtr          = pgv->gIP.GetLwU16(pgv);
  DCBSignature           = pgv->gIP.GetLwU32(pgv);
  if(DCBSignature != DCB_SIGNATURE)
  {
    dprintf("\nERROR! DCB Version 0x%02x has bad signature: 0x%08x.\n", pgv->DCBVersion, DCBSignature);
    dprintf("Exiting ...\n\n");
    LW_FCLOSE(pgv);
    pgv->exitValue = 4;
    return;
  }
  pgv->GPIOHeaderPtr     = pgv->gIP.GetLwU16(pgv);
  pgv->InputDevicesPtr   = pgv->gIP.GetLwU16(pgv);
  PersonalCinemaPtr      = pgv->gIP.GetLwU16(pgv);
  SpreadSpectrumPtr      = pgv->gIP.GetLwU16(pgv);
  I2CDevicesPtr          = pgv->gIP.GetLwU16(pgv);
  ConnectorPtr           = pgv->gIP.GetLwU16(pgv);
  pgv->g3x.Flags         = pgv->gIP.GetLwU8(pgv);

  if (HeaderSize >= 25)
  {
    HdtvXlatePtr           = pgv->gIP.GetLwU16(pgv);
  }

  if (HeaderSize >= 27)
  {
    SwitchOutPtr           = pgv->gIP.GetLwU16(pgv);
  }

  if (HeaderSize >= 31)
  {
    pgv->DevicesPatchPtr   = pgv->gIP.GetLwU32(pgv);
  }

  if (HeaderSize >= 35)
  {
    ConnectorsPatchPtr     = pgv->gIP.GetLwU32(pgv);
  }

  pgv->DCBEntryBase = pgv->DCBHeaderPtr+HeaderSize;

  pgv->LwrrentFileOffset = I2CControlPtr+1;
  I2CHeaderSize          = pgv->gIP.GetLwU8(pgv);
  pgv->I2CEntryCount     = pgv->gIP.GetLwU8(pgv);
  pgv->I2CEntrySize      = pgv->gIP.GetLwU8(pgv);
  if (pgv->DCBVersion >= 0x41 )
  {
      pgv->g3x.PrimaryPort   = pgv->gIP.GetLwU8(pgv);
      pgv->g3x.SecondaryPort = pgv->gIP.GetLwU8(pgv);
  }
  else
  {
      PriSecI2CPort          = pgv->gIP.GetLwU8(pgv);
      pgv->g3x.PrimaryPort   = (PriSecI2CPort   )&0xF;
      pgv->g3x.SecondaryPort = (PriSecI2CPort>>4)&0xF;
  }
  pgv->I2CEntryBase      = (LwU16) I2CControlPtr+I2CHeaderSize;

  // intitialize function pointers

  // Reuse these since they are the same right now
  pgv->gIP.GetType         = getType_2x;
  pgv->gIP.GetI2CPort      = getI2CPort_2x;
  pgv->gIP.GetBus          = getBus_2x;
  pgv->gIP.GetI2CRec       = getI2CRec_2x;

  // Use these separately
  pgv->gIP.GetHeadMask     = getHeadMask_4x;
  pgv->gIP.GetLocation     = getLocation_3x;
  pgv->gIP.GetOutput       = getOutput_3x;

  if (pgv->DCBVersion >= 0x41 )
  {
    pgv->gIP.GetI2CAccess            = GetI2CAccess_41;
  }
  else
  {
    pgv->gIP.GetI2CAccess            = GetI2CAccess_1x;
  }

  pgv->g3x.GetTVConnectorCount = getTVConnectorCount_3x;

  // Device Specific functions
  pgv->gIP.GetCRTMaxFreq   = getCRTMaxFreq_3x;
  pgv->gIP.GetLCDDDC       = getLCDDDC_3x;
  pgv->gIP.GetLCDControl   = getLCDControl_3x;
  pgv->gIP.GetLCDExtType   = getExtEncoder_3x;
  pgv->gIP.GetTVFamily     = getTVFamily_3x;
  pgv->gIP.GetTVFormat     = getTVSDFormat_4x;
  pgv->gIP.GetTVDACs       = getTVDACs_3x;

  // initialize string and describe functions
  pgv->gIP.strcatLCDEncoderName = strcatLCDEncoderName_3x;
  pgv->gIP.strcatTVEncoderName  = strcatTVEncoderName_3x;
  pgv->gIP.GetMiscStr           = getMiscStr_4x;
  pgv->gIP.DescribeTables       = DescribeTables_4x;

  // Get GPIO Table Data
  if(pgv->GPIOHeaderPtr)
  {
#ifndef SEPARATE_COMP // LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
    dprintf("Reading GPIO Table   \r");
#endif
#endif
    pgv->LwrrentFileOffset = pgv->GPIOHeaderPtr;
    pgv->GPIOVersion       = pgv->gIP.GetLwU8(pgv);
    GPIOHeaderSize         = pgv->gIP.GetLwU8(pgv);
    pgv->GPIOEntryCount    = pgv->gIP.GetLwU8(pgv);
    pgv->GPIOEntrySize     = pgv->gIP.GetLwU8(pgv);
    pgv->GPIOEntryBase     = pgv->GPIOHeaderPtr + GPIOHeaderSize;

    // DCB4.1 Assignment table size increased by 1 byte. Bug 1826386
    if( (pgv->GPIOEntrySize < 4) ||
        (pgv->GPIOEntrySize > 6) )
    {
      dprintf("GPIO Assignment Entry Size, %d, is not handled.\n", pgv->GPIOEntrySize);
      pgv->GPIOHeaderPtr = 0;
    }

    // Initialize this to 0
    pgv->g3x.extGpio.MasterPointer = 0;

    if(GPIOHeaderSize >= 6)
    {
      pgv->g3x.extGpio.MasterPointer = pgv->gIP.GetLwU16(pgv);
      if(pgv->g3x.extGpio.MasterPointer)
      {
        pgv->LwrrentFileOffset            = pgv->g3x.extGpio.MasterPointer;
        pgv->g3x.extGpio.MasterVersion    = pgv->gIP.GetLwU8(pgv);
        pgv->g3x.extGpio.MasterHeaderSize = pgv->gIP.GetLwU8(pgv);
        pgv->g3x.extGpio.MasterEntryCount = pgv->gIP.GetLwU8(pgv);
        pgv->g3x.extGpio.MasterEntrySize  = pgv->gIP.GetLwU8(pgv);
      }
    }

  }

  // Get InputDevices data
  if(pgv->InputDevicesPtr)
  {
#ifndef SEPARATE_COMP // LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
    dprintf("Reading Input Devices\r");
#endif
#endif
    pgv->LwrrentFileOffset = pgv->InputDevicesPtr+1;
    InpDevHeaderSize       = pgv->gIP.GetLwU8(pgv);
    pgv->InputDevicesCount = pgv->gIP.GetLwU8(pgv);
    pgv->InputDevicesSize  = pgv->gIP.GetLwU8(pgv);
    pgv->InputDevicesBase  = pgv->InputDevicesPtr + InpDevHeaderSize;
  }

  // Get Personal Cinema Data
  if(PersonalCinemaPtr)
  {
#ifndef SEPARATE_COMP // LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
    dprintf("Reading PC Table     \r");
#endif
#endif
    pgv->LwrrentFileOffset = PersonalCinemaPtr;
    pgv->gPCD.Version      = pgv->gIP.GetLwU8(pgv);
    pgv->LwrrentFileOffset = PersonalCinemaPtr+2;
    pgv->gPCD.BoardID      = pgv->gIP.GetLwU8(pgv);
    pgv->gPCD.VendorID     = pgv->gIP.GetLwU8(pgv);
    pgv->gPCD.SoundExpStd  = pgv->gIP.GetLwU8(pgv);
    pgv->gPCD.TunerType    = pgv->gIP.GetLwU8(pgv);
    pgv->gPCD.Demodulator  = pgv->gIP.GetLwU8(pgv);
    pgv->gPCD.MCandPC      = pgv->gIP.GetLwU8(pgv);
    if(pgv->gPCD.Version > 0x30)
    {
      pgv->gPCD.Sound2     = pgv->gIP.GetLwU8(pgv);
      pgv->gPCD.Tuner2     = pgv->gIP.GetLwU8(pgv);
      pgv->gPCD.TunerFunc  = pgv->gIP.GetLwU8(pgv);
      pgv->gPCD.Demod2     = pgv->gIP.GetLwU8(pgv);
    }
  }

  // Get the Spread Spectrum Data
  if(SpreadSpectrumPtr)
  {
#ifndef SEPARATE_COMP // LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
    dprintf("Reading SS Table     \r");
#endif
#endif
    pgv->LwrrentFileOffset = SpreadSpectrumPtr;
    pgv->g3x.ss.Version    = pgv->gIP.GetLwU8(pgv);
    SSHeaderSize           = pgv->gIP.GetLwU8(pgv);
    if (pgv->g3x.ss.Version == 0x40)
    {
        pgv->g3x.ss.EntryCount = pgv->gIP.GetLwU8(pgv);
        pgv->g3x.ss.EntrySize  = pgv->gIP.GetLwU8(pgv);
        pgv->g3x.ss.EntryBase  = SpreadSpectrumPtr + SSHeaderSize;

        pgv->g3x.ss.InternalPercentage = pgv->gIP.GetLwU8(pgv);
        pgv->g3x.ss.ExternalLevel      = pgv->gIP.GetLwU8(pgv);
        pgv->g3x.ss.SSFlags          = pgv->gIP.GetLwU8(pgv);
        pgv->g3x.ss.SSMinPLLUpdate   = pgv->gIP.GetLwU8(pgv);
        pgv->g3x.ss.SpreadPeriod     = pgv->gIP.GetLwU16(pgv);
    }
    else if (pgv->g3x.ss.Version == 0x41)
    {
        // Version 4.1
        pgv->g4x.ss.EntryCount = pgv->gIP.GetLwU8(pgv);
        pgv->g4x.ss.EntrySize  = pgv->gIP.GetLwU8(pgv);
        pgv->g4x.ss.Flags      = pgv->gIP.GetLwU8(pgv);
        pgv->g4x.ss.EntryBase  = SpreadSpectrumPtr + SSHeaderSize;
    }

  }

  // Get the I2C Devices Data
  if(I2CDevicesPtr)
  {
#ifndef SEPARATE_COMP // LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
    dprintf("Reading I2C Devices  \r");
#endif
#endif
    pgv->LwrrentFileOffset     = I2CDevicesPtr+1;
    I2CDevHeaderSize           = pgv->gIP.GetLwU8(pgv);
    pgv->g3x.i2cdev.EntryCount = pgv->gIP.GetLwU8(pgv);
    pgv->g3x.i2cdev.EntrySize  = pgv->gIP.GetLwU8(pgv);
    if (I2CDevHeaderSize >=5)
    {
      pgv->g3x.i2cdev.Flags    = pgv->gIP.GetLwU8(pgv);
    }
    pgv->g3x.i2cdev.EntryBase  = I2CDevicesPtr + I2CDevHeaderSize;
  }

  if(ConnectorPtr)
  {
#ifndef SEPARATE_COMP // LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
    dprintf("Reading Connector Tbl\r");
#endif
#endif
    pgv->LwrrentFileOffset    = ConnectorPtr+1;
    ConnectHeaderSize         = pgv->gIP.GetLwU8(pgv);
    pgv->g3x.cnctr.EntryCount = pgv->gIP.GetLwU8(pgv);
    pgv->g3x.cnctr.EntrySize  = pgv->gIP.GetLwU8(pgv);
    pgv->g3x.cnctr.EntryBase  = ConnectorPtr + ConnectHeaderSize;
    pgv->g3x.cnctr.Platform   = pgv->gIP.GetLwU8(pgv);
  }

  if (HdtvXlatePtr)
  {
#ifndef SEPARATE_COMP // LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
    dprintf("Reading HDTV Translation Tbl\r");
#endif
#endif
    pgv->LwrrentFileOffset    = HdtvXlatePtr+1;
    HdtvXlateHdrSize          = pgv->gIP.GetLwU8(pgv);
    pgv->g4x.hdxl.EntryCount  = pgv->gIP.GetLwU8(pgv);
    pgv->g4x.hdxl.EntrySize   = pgv->gIP.GetLwU8(pgv);
    pgv->g4x.hdxl.EntryBase   = HdtvXlatePtr + HdtvXlateHdrSize;
  }

  if (SwitchOutPtr)
  {
#ifndef SEPARATE_COMP // LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
    dprintf("Reading Switched Outputs Tbl\r");
#endif
#endif
    pgv->LwrrentFileOffset    = SwitchOutPtr+1;
    SwitchOutHdrSize          = pgv->gIP.GetLwU8(pgv);
    pgv->g4x.swout.EntryCount = pgv->gIP.GetLwU8(pgv);
    pgv->g4x.swout.EntrySize  = pgv->gIP.GetLwU8(pgv);
    pgv->g4x.swout.EntryBase  = SwitchOutPtr + SwitchOutHdrSize;
  }

  if(DevicesPatchPtr)
  {
#ifndef SEPARATE_COMP // LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
    dprintf("Reading DPIIM DCB Device Entry Tbl\r");
#endif
#endif
    pgv->LwrrentFileOffset    = DevicesPatchPtr+1;
    DevicesPatchHdrSize       = pgv->gIP.GetLwU8(pgv);
    pgv->g4x.dept.EntryCount  = pgv->gIP.GetLwU8(pgv);
    pgv->g4x.dept.EntrySize   = pgv->gIP.GetLwU8(pgv);
    pgv->g4x.dept.EntryBase   = DevicesPatchPtr + DevicesPatchHdrSize;
  }

  if(ConnectorsPatchPtr)
  {
#ifndef SEPARATE_COMP // LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
    dprintf("Reading DPIIM Connector Entry Tbl\r");
#endif

#endif
    pgv->LwrrentFileOffset   = ConnectorsPatchPtr+1;
    ConnectorsPatchHdrSize   = pgv->gIP.GetLwU8(pgv);
    pgv->g4x.cpt.EntryCount  = pgv->gIP.GetLwU8(pgv);
    pgv->g4x.cpt.EntrySize   = pgv->gIP.GetLwU8(pgv);
    pgv->g4x.cpt.EntryBase   = ConnectorsPatchPtr + ConnectorsPatchHdrSize;
  }
}

void strcatNumPerMask(char *str, LwU32 Mask)
{
  char ThisCharStr[33];
  LwU32 i, j;

  j=0;
  for(i=0; i<32; i++)
  {
    if(Mask & BIT(i))
    {
      ThisCharStr[j] = (char) (((char) '0') + ((char) i));
      j++;
    }
  }
  ThisCharStr[j] = 0;

  strcat(str, ThisCharStr);
}

char GetNumCharPerValueWithMax(LwU32 Value, LwU32 Max, char mChar)
{
  if(Value>Max)
    return mChar;

  return '0' + (char)Value;
}


void Describe_4x(PGV pgv)
{
  LwU32 i;

  dprintf("DCB Version: 0x%02x\n", pgv->DCBVersion);
  // print the header here
  dprintf("# TYPE C  B  HM OUTPUT LOC O/L N  MISC\n");

  for(i=0; i<pgv->DCBEntryCount; i++)
  {
    char TypeStr[5];
    char OutputStr[37];
    //char HeadMaskStr[33] = {0};
    char LocationStr[4];

    if(pgv->gIP.GetType(pgv, i) == TYPE_SKIP)
    {
      if (pgv->RuntimeFlags & RT_VERBOSE)
      {
        dprintf("%x SKIP ENTRY\n", i);
      }
      continue;
    }

    // if this is EOL, then go ahead and update the
    // the entry count and get out of this function.
    if(pgv->gIP.GetType(pgv, i) == TYPE_EOL)
    {
      if (pgv->RuntimeFlags & RT_VERBOSE)
      {
        dprintf("%x EOL\n", i);
      }
      pgv->DCBEntryCount = i;
      break;
    }

    switch(pgv->gIP.GetType(pgv, i))
    {
      case TYPE_CRT:  strcpy(TypeStr, "CRT "); break;
      case TYPE_TV:   strcpy(TypeStr, "TV  "); break;
      case TYPE_TMDS: strcpy(TypeStr, "TMDS"); break;
      case TYPE_LVDS: strcpy(TypeStr, "LVDS"); break;
      case TYPE_SDI:  strcpy(TypeStr, "SDI "); break;
      case TYPE_DP:   strcpy(TypeStr, "DP  "); break;
      case TYPE_WBD:  strcpy(TypeStr, "WBD "); break;
      default:        sprintf(TypeStr, "?%d? ",(int)pgv->gIP.GetType(pgv, i)); break;
    }

    //strcatNumPerMask(HeadMaskStr, pgv->gIP.GetHeadMask(pgv, i));

    // Get Output String and Location Str.
    switch(pgv->gIP.GetLocation(pgv, i))
    {
      case LOCATION_CHIP:
        switch(pgv->gIP.GetType(pgv, i))
        {
          case TYPE_CRT:  // Intentional fall through
          case TYPE_TV:   strcpy(OutputStr, "DAC  "); break;

          case TYPE_DP:   // Intentional fall through
          case TYPE_SDI:
          case TYPE_TMDS:
          case TYPE_LVDS:
            if( pgv->DCBVersion >= 0x41 )
            {
              strcpy(OutputStr, "PAD  ");
            }
            else
            {
              strcpy(OutputStr, "SOR  ");
            }
            break;

          case TYPE_WBD:  strcpy(OutputStr, "WBOR "); break;

          default:        sprintf(OutputStr, "??? "); break;
        }
        strcpy(LocationStr, "CHP");
        break;
      case LOCATION_BOARD:
        strcpy(OutputStr,   "PIOR ");
        strcpy(LocationStr, "BRD");
        break;
      default:
        break;
    }
    strcatNumPerMask(OutputStr, pgv->gIP.GetOutput(pgv, i));


       //dprintf("# TYPE C B HM OUTPUT LOC O/L N MISC\n");
    dprintf("%x %-4s %-2d %-2d %2x %-6s %-3s ",
         i, // Entry number
         TypeStr,
         pgv->gIP.GetI2CPort(pgv, i),
         pgv->gIP.GetBus(pgv, i),
         pgv->gIP.GetHeadMask(pgv, i),
         OutputStr,
         LocationStr);

    DescribeMisc_4x(pgv, i);

  }

  if (pgv->RuntimeFlags & RT_VERBOSE)
  {
    dprintf("   Column definitions:\n"
            "        # : DCB Index (in hex)\n"
            "     TYPE : Type of output\n"
            "        C : Communications Port Index\n"
            "        B : Bus\n"
            "       HM : Head Mask\n"
            "    OUTPUT: GPU outputs used\n"
            "      LOC : Board Signal Generator Location\n"
            "            CHP : Inside the GPU\n"
            "            BRD : External to the GPU\n"
            "      O/L : Boot Removed / Blind Boot Removed\n"
            "        N : Connector Index\n"
            "     MISC : Miscellaneous Type specific data\n");

#ifdef INTERNAL
    // we only want internal copies to explain MISC fields
    dprintf("  Misc Information for CRTs:\n"
            "    # MHz : Max CRT Frequency\n"
            "  Misc Information for TVs:\n"
            "     SD:* : Default SD Format\n"
            "     HD:* : Default HD Format\n"
            "      DACS: Default TV encoder outputs\n"
            "    ctrs:#: Number of connector entries for this Display\n"
            "    I2CCom: Communication Port Index for external chip\n"
            "  Misc Information for LVDS/TMDS/SDI/DPs:\n"
            "       DDC: EDID is read via DDC\n"
            "     Strap: EDID is generated via Strap\n"
            "       Ext: Panel Power is controlled by the panel\n"
            "    Script: Panel Power is controlled by a script\n"
            "     SBIOS: Panel Power is controlled by the SBIOS\n"
            "    I2CCom: Communication Port Index for external chip\n"
            "      HDCP: This display supports HDCP\n"
            "      HDMI: This display supports HDMI\n"
            "  Misc Information for LVDS/TMDS/SDI:\n"
            "      SL:*: Sublinks used for this display output\n"
            "      PL:*: Padlinks used for this display output\n"
            "  Misc Information for DP:\n"
            "    DPLink: Bitmask of supported links\n"
            "       MLR: Max Link Rate\n"
            "      MxLM: Max Lane Mask\n"
            );
#endif
  }

  dprintf("Communications Control Block:  Primary: %d   Secondary: %d\n",
          pgv->g3x.PrimaryPort, pgv->g3x.SecondaryPort);

  for(i=0; i<pgv->I2CEntryCount; i++)
  {
    LwU32 i2cPhysPort;
    LwU32 dpauxPhysPort;

    switch(pgv->gIP.GetI2CAccess(pgv, i))
    {
      case 0:
        dprintf("    %-2d    0=CRTC  ReadPort:0x%x  WritePort:0x%x\n",
                i,
                GetI2CCRTCReadPort(pgv, i), GetI2CCRTCWritePort(pgv, i));
        break;
      case 3:
        dprintf("    %-2d    3=PCI   Type:%s Bus:%d Dev:%d Fn:%d Bar:%d Offset:0x%x\n",
            i,
            ( (GetI2CPCIType(pgv, i)==0) ? "nForce" : "?????" ),
            GetI2CPCIBus(pgv, i),
            GetI2CPCIDevice(pgv, i),
            GetI2CPCIFunction(pgv, i),
            GetI2CPCIBar(pgv, i),
            GetI2CPCIOffset(pgv, i));
        break;
      case 4:
        dprintf("    %-2d    4=MM    Physical Port:0x%x   IO Port Addr:0x%x\n",
                i,
                GetI2CMMPhysicalPort(pgv, i),
                GetI2CMMIOReadPortAddr(pgv, i));
        break;
      case 5:
        dprintf("    %-2d    5=I2C   Physical Port:0x%x   Speed:0x%x",
                i,
                GetI2CPMGRPhysicalPort(pgv, i),
                GetI2CPMGRPortSpeed(pgv, i));
        if (GetI2CPMGRPortHybridPad_4x(pgv, i))
        {
            dprintf("   Hybrid  DPAux Port:0x%x\n",
                    GetI2CPMGRPortDPPort_4x(pgv, i));
        }
        else
        {
            dprintf("\n");
        }
        break;
      case 6:
        dprintf("    %-2d    6=DPAux Physical Port:0x%x",
                i,
                GetCommDpAuxPhysicalPort(pgv, i));
        if (GetCommDpAuxHybridPad_4x(pgv, i))
        {
            dprintf("   Hybrid  I2C Port:0x%x\n",
                    GetDPPMGRPortI2CPort_4x(pgv, i));
        }
        else
        {
            dprintf("\n");
        }
        break;
      case 0x50:
        i2cPhysPort = GetCCBI2CPort(pgv, i);
        dpauxPhysPort = GetCCBDPPort(pgv, i);

        if( (i2cPhysPort!=0x1F) || (dpauxPhysPort!=0x1F) || (pgv->RuntimeFlags & RT_VERBOSE) )
        {
          dprintf("    %-2d    ",i);

          if(i2cPhysPort!=0x1F)
          {
            dprintf("    I2C Port:0x%x   I2C Speed:0x%x", i2cPhysPort, GetCCBI2CPortSpeed(pgv, i));
          }
          else
          {
            dprintf("    I2C Port:UNUSED   I2C Speed:NA");
          }

          if(dpauxPhysPort!=0x1F)
          {
            dprintf("   DPAux Port:0x%x\n", dpauxPhysPort);
          }
          else
          {
            dprintf("   DPAux Port:UNUSED\n");
          }

        }
        break;
      case 0xFF:
        // This is a skip entry
        if (pgv->RuntimeFlags & RT_VERBOSE)
        {
          dprintf("    %-2d    SKIP ENTRY\n", i);
        }
        break;
      default:
        dprintf("    %-2d    %d=Unknown Comm Access Method.\n",
                i, pgv->gIP.GetI2CAccess(pgv, i));
        break;
    }
  }

  // Allow DCB 2.X to print out Miscellaneous Table information:
  // no need for this in DCB 4.x describe function!!
  //pgv->gIP.DescribeMisc(pgv);

  // Print out all other tables that are valid for a particular DCB version
  pgv->gIP.DescribeTables(pgv);
}


void CheckGpioAssignments_4x(PGV pgv)
{
  LwU32 i, j;
  LwU32 MaxGPIO = 9;
  LwU32 FoundDACBSwitchSupport = 0;
  LwU32 FoundHDTVSwitchSupport = 0;
  LwU32 FoundHDTVScartLoadDetSupport = 0;
  LwU32 FoundDisablePowerSense = 0;
  LwU32 FoundThermalPowerSense = 0;
  LwU32 FoundThermalGpioRequired = 0;
  LwU32 FoundLWHSSupport = 0;
  LwU32 VSelBits = 0;
  LwU32 MaxLockPin = 4;
  LwU32 FoundRasterSyncMask = 0;
  LwU32 FoundSwapReadyMask = 0;
  LwU32 FanGPIOs = 0;

  char funcText[20];

  if( (pgv->GPIOHeaderPtr != 0x0) &&
      (pgv->GPIOEntryCount == 0x0)      &&
      (pgv->Device >= 0x30) )
  {
    dprintf("ERROR: GPIO Assignment table has 0 entries!\n");
    dprintf("       LW3X+ chips must list a GPIO Assignment table!\n");
    pgv->exitValue = 5;
    ErrorCountCheck(pgv);
  }

  // If we're using the default tables, return since we can't check the driver.
  if( (pgv->GPIOHeaderPtr == 0x0) ||
      ( (pgv->GPIOEntryCount == 0x0) &&
        (pgv->Device < 0x30) ) )
    return;

  if( pgv->VBIOSCore >= Core94 )    // Assume core94+ represents GA10x+
    MaxGPIO = 39;
  else if( pgv->Device >= 0x92 )    // G92
    MaxGPIO = 31;
  else if( pgv->Device >= 0x80 )    // G80
    MaxGPIO = 15;
  else if( pgv->Device >= 0x40 )    // LW40
    MaxGPIO = 13;

  if ( pgv->Device >= 0xB0 )
  {
      // From Dhawal:
      // LW50, G8x, G9x, GT20X: 4 lock pins
      // GT21X and GF10X: 5 lock pins.
      //    5'th lock pin is unusable in GT21X, though, because it
      //    doesn't have any capability bit turned on. So, you can
      //    even put in the category of 4 lock pins.
      // GF11X: Let's deal with this later like you said.
      MaxLockPin = 5;
  }

  for (i = 0; i < pgv->GPIOEntryCount; i++)
  {
    LwU32 gpioFunction, gpioIOType, gpioPinNumber, gpioLockPin;
    LwU32 gpioPWM;

    LwU32 loopFunction = 0, loopIOType = 0, loopPinNumber = 0, loopLockPin = 0;

    // This is the same between 40 and 41
    gpioFunction  = GetGpioFunction_40 (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);

    if (pgv->GPIOVersion == 0x40)
    {
      gpioIOType    = GetGpioIOType_40   (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      gpioPinNumber = GetGpioNumber_40   (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      gpioLockPin   = GetGpioLockPin_40  (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      gpioPWM       = GetGpioPWM_40      (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
    }
    else if (pgv->GPIOVersion == 0x41)
    {
      gpioIOType    = GetGpioIOType_41   (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      gpioPinNumber = GetGpioNumber_41   (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      gpioLockPin   = GetGpioLockPin_41  (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      gpioPWM       = GetGpioPWM_41      (pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
    }
    else
    {
      dprintf("  Unknown GPIO Table Version: 0x%x\n", pgv->GPIOVersion);
      break;
    }

    // DCB 4.0 has Skip Entries
    if(gpioFunction == 0xFF)
      continue;

    if (gpioPinNumber > MaxGPIO)
    {
      dprintf("ERROR: GPIO assignment table entry %d uses unknown gpio number: %d.\n",
              i, gpioPinNumber);
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }

    // Look for multiple entries with same function or gpio;
    //
    for (j = i + 1; j < pgv->GPIOEntryCount; j++)
    {
      loopFunction  = GetGpioFunction_40 (pgv, j, pgv->GPIOEntryBase, pgv->GPIOEntrySize);

      if (pgv->GPIOVersion == 0x40)
      {
        loopIOType    = GetGpioIOType_40   (pgv, j, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
        loopPinNumber = GetGpioNumber_40   (pgv, j, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      }
      else if (pgv->GPIOVersion == 0x41)
      {
        loopIOType    = GetGpioIOType_41   (pgv, j, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
        loopPinNumber = GetGpioNumber_41   (pgv, j, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
      }
      else
      {
        break;
      }

      // DCB 4.0 has Skip Entries
      if (loopFunction == 0xFF)
        continue;

      // Only compare true GPIOs here.  not lock pins
      if (gpioIOType != 0)
        continue;
      if (loopIOType != 0)
        continue;

      if (gpioPinNumber == loopPinNumber)
      {
        dprintf("ERROR: GPIO assignment table entry %d and %d both use gpio %d.\n",
                i, j, gpioPinNumber);
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }

      // Allow multiple GPIO entries to use the Switch Output or Gen. Init function
      // Also allow LCD Power, backlight and brightness for dual LVDS systems.
      if ( (gpioFunction == loopFunction) &&
           (gpioFunction != 107) && // bug 454518
           (gpioFunction != 106) &&
           (gpioFunction !=  48) &&
           (gpioFunction !=  33) &&
           (gpioFunction !=   1) &&
           (gpioFunction !=   0) )
      {
        GpioFunctionText(gpioFunction, funcText);

        dprintf("ERROR: GPIO assignment table entry %d and %d both use function %s.\n",
                i, j, funcText);

        // Check to see if this is MXM Default DCB - bug 793163
        // P1028 needs to be fixed before we fail the build for MXM boards.
        if ((pgv->bit.MXMConfigFlags0 & 0xC) != 0xC)
        {
          pgv->exitValue = 5;
          ErrorCountCheck(pgv);
        }
      }
    }


    // Lockpin checks 1-4 : These checks requested by Dhawal
    if (gpioIOType)
    {
      // This is a lockpin
      // Check #1: Make sure gpioFunction is unused - Unfortunately, there's
      // no unused function # that we can associate here.  Skipping this check.
      //if (gpioLockPin)

      // Check #2: Make sure LockPin is 0-3
      if (gpioLockPin >= MaxLockPin)
      {
        dprintf("ERROR: GPIO assignment table entry %d has TYPE DEDICATED_LOCK_PIN\n"
                "       and the lockpin value %d must be a value of 0, 1, 2, or 3.\n",
                i, gpioLockPin);
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }
    }
    else
    {
      // This is not a Lockpin, but a normal GPIO.
      // Check #3: If Lockpin is 0-3, then this is only allowed on specific GPIOs
      if (gpioLockPin < MaxLockPin)
      {
        switch(gpioFunction)
        {
          case 63: // EXTSYNC0
          case 64: // SLI_RASTER_SYNC_A
          case 65: // SLI_RASTER_SYNC_B
          case 66: // SWAP_READY_IN
          case 68: // VRR_RASTER_SYNC
          case 15: // STEREO_TOGGLE
          case 133: // PANEL_SELF_REFRESH_FRAME_LOCK
            break;

          default:
            GpioFunctionText(gpioFunction, funcText);
            dprintf("ERROR: GPIO assignment table entry %d has TYPE GPIO, and the lockpin\n"
                    "       value %d, which isn't valid for function %s.\n",
                    i, gpioLockPin, funcText);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
            break;
        }
      }
    }

    // Check #4: Don't allow same lockpin to be used twice
    // except for unused (7) or if not G80 and not GV100 and later
    if (pgv->Device != 0x80 && pgv->VBIOSCore < Core88)
    {
      for (j = i + 1; j < pgv->GPIOEntryCount; j++)
      {
        loopFunction = GetGpioFunction_40(pgv, j, pgv->GPIOEntryBase, pgv->GPIOEntrySize);

        // DCB 4.0 has Skip Entries
        if (loopFunction == 0xFF)
          continue;

        if (pgv->GPIOVersion == 0x40)
        {
          loopLockPin = GetGpioLockPin_40   (pgv, j, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
        }
        else if (pgv->GPIOVersion == 0x41)
        {
          loopLockPin = GetGpioLockPin_41   (pgv, j, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
        }
        else
        {
          loopLockPin = 0;
        }

        if (gpioLockPin == loopLockPin)
        {
          if ( ( (gpioLockPin != 0x7) &&
                 (pgv->GPIOVersion == 0x40) ) ||
               ( (gpioLockPin != 0xF) &&
                 (pgv->GPIOVersion == 0x41) ) )
          {
            dprintf("ERROR: GPIO assignment table entry %d and %d both use lockPin %d.\n",
                    i, j, gpioLockPin);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }
        }
      }
    }


    switch(gpioFunction)
    {
      case 9: FanGPIOs++; break;

      case 12: FoundDACBSwitchSupport += 1; break;
      case 13: FoundDACBSwitchSupport += 1; break;

      case 14: // intentional fall through
      case 15:
        break;


      case 16: // intentional fall through
        FoundThermalPowerSense = 1;
      case 17:
        FoundThermalGpioRequired = 1;
        break;

      case 33:
        // As requested by axchen
        if(!(gpioPWM) )
        {
          dprintf("ERROR: GPIO Entry %d: LCD Brightness doesn't have PWM set!\n",i);
          pgv->exitValue = 5;
          ErrorCountCheck(pgv);
        }
        break;

      // We need HDTV set if we intend to use the GPIO's for HDTV switching
      case 36:
          FoundHDTVSwitchSupport = 1;
          break;
      case 37:
          FoundHDTVScartLoadDetSupport = 1;
          break;

      // If these are defined, then we need to make sure
      // that the voltage table is defined for them.
      case 4:  VSelBits |= 0x1; break;
      case 5:  VSelBits |= 0x2; break;
      case 6:  VSelBits |= 0x4; break;
      case 26: VSelBits |= 0x8; break;

      // Need to note this:
      case 44: FoundDisablePowerSense = 1; break;

      case 64: FoundRasterSyncMask |= 0x1; break;
      case 65: FoundRasterSyncMask |= 0x2; break;

      case 66:  FoundSwapReadyMask |= 0x1; break;
      case 112: FoundSwapReadyMask |= 0x2; break;

      case 123: FanGPIOs++; break;
      case 195:
      case 196:
          FoundLWHSSupport = 1;
          break;
    }

  } // End of for loop on all GPIO table entries

  // Run this if not MXM Default DCB - bug 793163
  if ((pgv->bit.MXMConfigFlags0 & 0xC) != 0xC)
  {
    if(FoundDACBSwitchSupport)
    {
      LwU32 DACBDeviceCount = 0;

      for(i=0; i<pgv->DCBEntryCount; i++)
      {
        if( (pgv->gIP.GetLocation(pgv, i) == LOCATION_CHIP) &&
            (pgv->gIP.GetOutput(pgv, i) == OUTPUT_DAC_B) )
        {
          if( (pgv->gIP.GetType(pgv, i) == TYPE_CRT) ||
              (pgv->gIP.GetType(pgv, i) == TYPE_TV) )
            DACBDeviceCount += 1;
        }
      }

      if (DACBDeviceCount != 2)
      {
        dprintf("ERROR: DAC 1 Switch lists in the GPIO Table, but only %d DAC 1 device(s) listed!\n", DACBDeviceCount);
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }

    }


    if(FoundHDTVSwitchSupport)
    {
      LwU32 FoundHDTV = 0;

      for(i=0; i<pgv->DCBEntryCount; i++)
      {
        if(pgv->gIP.GetType(pgv, i) == TYPE_TV)
        {
            switch(pgv->gIP.GetTVDACs(pgv, i))
            {
              case 0x08:
              case 0x09:
              case 0x0B:
              case 0x0C:
              case 0x0D:
              case 0x0F:
              case 0x10:
                FoundHDTV = 1;
                break;
              default:
                break;
            }
        }

        if (FoundHDTV)
        {
          break;
        }
      }

      if(!FoundHDTV)
      {
        dprintf("ERROR: Misc: GPIO table has HDTV Switch entry(s), but no HDTV DCB Entry!\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }
    }

    if(FoundHDTVScartLoadDetSupport)
    {
      LwU32 FoundHDTVScart = 0;

      for(i=0; i<pgv->DCBEntryCount; i++)
      {
        if(pgv->gIP.GetType(pgv, i) == TYPE_TV)
        {
            switch(pgv->gIP.GetTVDACs(pgv, i))
            {
              case 0x08:
              case 0x09:
              case 0x0A:
              case 0x0B:
              case 0x0C:
              case 0x0D:
              case 0x0E:
              case 0x0F:
              case 0x10:
                FoundHDTVScart = 1;
                break;
              default:
                break;
            }
        }

        if (FoundHDTVScart)
        {
          break;
        }
      }

      if(!FoundHDTVScart)
      {
        dprintf("ERROR: Misc: GPIO table has HDTV/Scart AltDet entry(s), but no HDTV/SCART DCB Entry!\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }
    }
  }



  if(VSelBits)
  {
    // check to make sure that there are no holes in the definition of vsel bits.
    if( (VSelBits + 1) & VSelBits)
    {
      dprintf("ERROR: GPIO table has Voltage Select holes!\n");
      dprintf("       defined:");
      for(i=0; i<4; i++)
      {
        if(VSelBits & (1<<i))
          dprintf("VSEL%d ", i);
      }
      dprintf("\n   not defined:");
      for(i=0; i<4; i++)
      {
        if( (VSelBits & (1<<(i+1))) &&
           !(VSelBits & (1<<i)) )
          dprintf("VSEL%d ", i);
      }
      dprintf("\n");

      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
  }

  if( (FoundDisablePowerSense) &&
     !(FoundThermalPowerSense) )
  {
    dprintf("ERROR: GPIO table defines Disable Power Sense, but no Thermal+Power Sense GPIO found!\n");
    pgv->exitValue = 5;
    ErrorCountCheck(pgv);
  }

  if(FoundThermalGpioRequired)
  {
    if(pgv->Device < 0x43)
    {
      // LW43+ have internal thermal sensors that are not listed in the I2C Devices table.
      // So, don't look at them here.

      LwU32 FoundThermalDevice = 0;

      // Loop over the I2C devices
      for(i=0; i<pgv->g3x.i2cdev.EntryCount; i++)
      {
        // Look for skip entries
        if(GetI2CDevicesEntryType(pgv, i) == 0xFF)
          continue;

        switch(GetI2CDevicesEntryType(pgv, i))
        {
          case 0x01: // Th:ADM 1032
          case 0x02: // Th:MAX 6649
          case 0x03: // Th:LM99
          case 0x04: // Th:SMB MAX 6649
          case 0x05: // Th:VBIOS event
          case 0x06: // Th:MAX 1617
          case 0x07: // Th:LM64
          case 0x08: // Th:OS
             FoundThermalDevice = 1;
             break;
        }

        if(FoundThermalDevice)
          break;
      }

      if(!FoundThermalDevice)
      {
        // See Terrence C. for issues with this one
        dprintf("ERROR: GPIO table defines Thermal Event, but no Thermal device defined in I2C Devices!\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }
    }

  }

  // Only do this check for GT212+
  if (pgv->Device >= 0xA4 )
  {
    // GP100 introduces LWLINK SLI, no pin set check needed: bug 1702793
    // Core90/Turing: MIO SLI is deprecated altogether: bug 2169066
    if( pgv->VBIOSCore >= Core90 )
    {
        // restore check after ROMs are corrected
        if ( 0 ) // if ((pgv->g3x.Flags & 0x40) || (pgv->g3x.Flags & 0x80))
        {
          dprintf("ERROR: Pin Set A and Pin Set B must both be cleared!\n");
          pgv->exitValue = 5;
          ErrorCountCheck(pgv);
        }
    }
    else if (FoundLWHSSupport == 0 && pgv->VBIOSCore > Core86)
    {
      // Check for pin Set, Raster Sync and Swap Ready required links
      // Requested by Dhawal.
      //  Removing this check until the VBIOSes are fixed

      // If Pin Set A is routed to SLI finger, then raster sync A must be defined
      // Or if raster sync A is defined, then Pin Set A must be routed to SLI finger
      if ( ( (pgv->g3x.Flags & 0x40) && !(FoundRasterSyncMask & 0x1)) ||
           (!(pgv->g3x.Flags & 0x40) &&  (FoundRasterSyncMask & 0x1)) )
      {
        dprintf("ERROR: Pin Set A and Raster Sync A GPIO must both be defined!\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }

      // Same for B
      if ( ( (pgv->g3x.Flags & 0x80) && !(FoundRasterSyncMask & 0x2)) ||
           (!(pgv->g3x.Flags & 0x80) &&  (FoundRasterSyncMask & 0x2)) )
      {
        dprintf("ERROR: Pin Set B and Raster Sync B GPIO must both be defined!\n");
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }
    }

    // If Swap ready A is defined, it requires raster sync A to be defined
    if ( (FoundSwapReadyMask & 0x1) && !(FoundRasterSyncMask & 0x1))
    {
      dprintf("ERROR: Swap Ready A requires Raster Sync A GPIO to be defined!\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }

    // Same for B
    if ( (FoundSwapReadyMask & 0x2) && !(FoundRasterSyncMask & 0x2))
    {
      dprintf("ERROR: Swap Ready B requires Raster Sync B GPIO to be defined!\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
  }

  // Requested by Jatin and Aron
  if (FanGPIOs > 1)
  {
    dprintf("ERROR: More than one Fan defined inside the GPIO table.\n");
    //pgv->exitValue = 5;
    //ErrorCountCheck(pgv);
  }

}


// This entire function is requested by Ryan B.
void CheckHotplug_4x(PGV pgv)
{
  LwU32 i, j, x, y;

  LwU32 FoundConnectorHotplugMask = 0;
  LwU32 FoundGPIOHotplugMask = 0;
  LwU32 FoundHotplugCapableConnector = 0;
  LwU32 FoundGPIODP2DVIMask = 0;
  LwU32 FoundConnectorDP2DVIMask = 0;

  char str[] = "A\0";

  // This test is only relevant for DCB 4.0+
  if (pgv->DCBVersion <  0x40)
    return;

  // First look through the GPIOs to see if there's any Hotplugs defined
  for (i = 0; i < pgv->GPIOEntryCount; i++)
  {
    LwU32 gpioFunc    = GetGpioFunction_40(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);

    // DCB 4.0 has Skip Entries
    if(gpioFunc == 0xFF)
      continue;

    switch(gpioFunc)
    {
      // Hotplug A
      case 7:
        FoundGPIOHotplugMask |= 0x01;
        break;
      // Hotplug B
      case 8:
        FoundGPIOHotplugMask |= 0x02;
        break;
      // Hotplug C
      case 81:
        FoundGPIOHotplugMask |= 0x04;
        break;
      // Hotplug D
      case 82:
        FoundGPIOHotplugMask |= 0x08;
        break;
      // Hotplug E
      case 94:
        FoundGPIOHotplugMask |= 0x10;
        break;
      // Hotplug F
      case 95:
        FoundGPIOHotplugMask |= 0x20;
        break;
      // Hotplug G
      case 96:
        FoundGPIOHotplugMask |= 0x40;
        break;

      // DP2DVI A
      case 74:
        FoundGPIODP2DVIMask |= 0x01;
        break;
      // DP2DVI B
      case 75:
        FoundGPIODP2DVIMask |= 0x02;
        break;
      // DP2DVI C
      case 83:
        FoundGPIODP2DVIMask |= 0x04;
        break;
      // DP2DVI D
      case 84:
        FoundGPIODP2DVIMask |= 0x08;
        break;
    }
  }

  for (j = 0; j < pgv->g3x.extGpio.MasterEntryCount; j++)
  {
      LwU32 spPointer, spHeaderSize, spEntryCount, spEntrySize;
      LwU32 spEntryBase, spType;

      pgv->LwrrentFileOffset = pgv->g3x.extGpio.MasterPointer +
                               pgv->g3x.extGpio.MasterHeaderSize +
                               j * pgv->g3x.extGpio.MasterEntrySize;
      spPointer = pgv->gIP.GetLwU16(pgv);

      // Skip 0 pointers
      if(!spPointer)
      {
        continue;
      }

      pgv->LwrrentFileOffset = spPointer+1;
      spHeaderSize = pgv->gIP.GetLwU8(pgv);
      spEntryBase  = spPointer + spHeaderSize;
      spEntryCount = pgv->gIP.GetLwU8(pgv);
      spEntrySize  = pgv->gIP.GetLwU8(pgv);
      spType       = pgv->gIP.GetLwU8(pgv);

      switch(spType)
      {
        case 9:
          // OK, we have DP2DVI off this type.  Search the entries for them.
          for(i = 0; i < spEntryCount; i++)
          {
            LwU32 gpioFunction  = GetGpioFunction_40 (pgv, i, spEntryBase, spEntrySize);

            switch(gpioFunction)
            {
              // DP2DVI A
              case 1:
                if (FoundGPIODP2DVIMask & 0x1)
                {
                  dprintf("ERROR: GPIO table has both internal GPU and external GPIO\n"
                          "       defined for DP2DVI A.  This is not allowed.\n");
                  pgv->exitValue = 5;
                  ErrorCountCheck(pgv);
                }
                FoundGPIODP2DVIMask |= 0x1;
                break;
              // DP2DVI B
              case 2:
                if (FoundGPIODP2DVIMask & 0x2)
                {
                  dprintf("ERROR: GPIO table has both internal GPU and external GPIO\n"
                          "       defined for DP2DVI B.  This is not allowed.\n");
                  pgv->exitValue = 5;
                  ErrorCountCheck(pgv);
                }
                FoundGPIODP2DVIMask |= 0x2;
                break;
              // DP2DVI C
              case 3:
                if (FoundGPIODP2DVIMask & 0x4)
                {
                  dprintf("ERROR: GPIO table has both internal GPU and external GPIO\n"
                          "       defined for DP2DVI C.  This is not allowed.\n");
                  pgv->exitValue = 5;
                  ErrorCountCheck(pgv);
                }
                FoundGPIODP2DVIMask |= 0x4;
                break;
              // DP2DVI D
              case 4:
                if (FoundGPIODP2DVIMask & 0x8)
                {
                  dprintf("ERROR: GPIO table has both internal GPU and external GPIO\n"
                          "       defined for DP2DVI D.  This is not allowed.\n");
                  pgv->exitValue = 5;
                  ErrorCountCheck(pgv);
                }
                FoundGPIODP2DVIMask |= 0x8;
                break;
              default:
                break;
            }

          }
          break;
        default:
          break;
      }

  }



  if(pgv->g3x.cnctr.EntryCount != 0)
  {
    for(i=0; i<pgv->DCBEntryCount; i++)
    {
      LwU32 Type     = pgv->gIP.GetType(pgv, i);
      LwU32 ConIdx   = getConnectorIndex_3x(pgv, i);
      LwU32 HotplugMask;
      LwU32 DP2DVIMask;
      LwU32 ConCount = 1;

      if(Type == TYPE_SKIP)
        continue;

      if(Type == TYPE_TV)
        ConCount = pgv->g3x.GetTVConnectorCount(pgv, i);

      for (j=0; j<ConCount; j++)
      {
        switch(GetConnectorEntryType(pgv, ConIdx+j))
        {
          case 0x30: // DVI-I
          case 0x31: // DVI-D
          case 0x38: // LFH-DVI-I
          case 0x39: // LFH-DVI-D
          case 0x46: // DisplayPort External
          case 0x47: // DisplayPort Internal (Non-removeable)
          case 0x52: // DVI-I if not docked
          case 0x53: // DVI-I if docked
          case 0x54: // DVI-D if not docked
          case 0x55: // DVI-D if docked
          case 0x56: // DisplayPort External if not docked
          case 0x57: // DisplayPort External if docked
          case 0x61: // HDMI-A
            FoundHotplugCapableConnector = 1;
            break;
        }

        HotplugMask = 0;
        HotplugMask |= (GetConnectorEntryHotplugA(pgv, ConIdx+j)) << 0;
        HotplugMask |= (GetConnectorEntryHotplugB(pgv, ConIdx+j)) << 1;
        HotplugMask |= (GetConnectorEntryHotplugC_4x(pgv, ConIdx+j)) << 2;
        HotplugMask |= (GetConnectorEntryHotplugD_4x(pgv, ConIdx+j)) << 3;
        HotplugMask |= (GetConnectorEntryHotplugE_4x(pgv, ConIdx+j)) << 4;
        HotplugMask |= (GetConnectorEntryHotplugF_4x(pgv, ConIdx+j)) << 5;
        HotplugMask |= (GetConnectorEntryHotplugG_4x(pgv, ConIdx+j)) << 6;
        FoundConnectorHotplugMask |= HotplugMask;

        if (HotplugMask)
        {
          // Check to make sure that if the Hotlpug is defined that we have
          // the GPIO defined for it.
          for (x=0; x<7; x++)
          {
            y = 1<<x;
            str[0] = 'A' + (char)x;

            if ( (HotplugMask & y) &&
                !(FoundGPIOHotplugMask & y) )
            {
              // We only have problems on GPUs < G78, which at the time, only had
              // hotplug A and B defined.  So, if it's A or B and we're < g78,
              // then use a non-build failure ERROR.
              if( (x<2) && (pgv->Device < 0x4C) )
              {
                dprintf("ERROR: DCB Entry %d/Connector Index %d has Hotplug %s defined,\n"
                        "       but GPIO Hotplug %s isn't defined.\n", i, (ConIdx+j),
                        str, str);
              }
              else
              {
                dprintf("ERROR: DCB Entry %d/Connector Index %d has Hotplug %s defined,\n"
                        "       but GPIO Hotplug %s isn't defined.\n", i, (ConIdx+j),
                        str, str);
                pgv->exitValue = 5;
                ErrorCountCheck(pgv);
              }
            }
          }
        }

        // disallow the one Connector to have more than one Hotplug defined for it.
        if (HotplugMask & (HotplugMask-1))
        {
          dprintf("ERROR: DCB Entry %d/Connector Index %d has more than one Hotplug defined.\n"
                  "       Lwrrently we see Hotplug %s%s%s%s%s%s%s defined.\n", i, (ConIdx+j),
                  ((HotplugMask&1)?"A":""), ((HotplugMask&2)?"B":""),
                  ((HotplugMask&4)?"C":""), ((HotplugMask&8)?"D":""),
                  ((HotplugMask&10)?"E":""), ((HotplugMask&20)?"F":""),
                  ((HotplugMask&40)?"G":""));
          pgv->exitValue = 5;
          ErrorCountCheck(pgv);
        }

        DP2DVIMask = 0;
        DP2DVIMask |= (GetConnectorEntryDP2DVIA_4x(pgv, ConIdx+j)) << 0;
        DP2DVIMask |= (GetConnectorEntryDP2DVIB_4x(pgv, ConIdx+j)) << 1;
        DP2DVIMask |= (GetConnectorEntryDP2DVIC_4x(pgv, ConIdx+j)) << 2;
        DP2DVIMask |= (GetConnectorEntryDP2DVID_4x(pgv, ConIdx+j)) << 3;
        FoundConnectorDP2DVIMask |= DP2DVIMask;

        if (DP2DVIMask)
        {
          // Check to make sure that if the DP2DVI is defined that we have
          // the GPIO defined for it.
          for (x=0; x<4; x++)
          {
            y = 1<<x;
            str[0] = 'A' + (char)x;

            if ( (DP2DVIMask & y) &&
                !(FoundGPIODP2DVIMask & y) )
            {
              // We only have problems on GPUs < G78, which at the time, only had
              // hotplug A and B defined.  So, if it's A or B and we're < g78,
              // then use a non-build failure ERROR.
              dprintf("ERROR: DCB Entry %d/Connector Index %d has DP2DVI %s defined,\n"
                      "       but GPIO DP2DVI %s isn't defined.\n", i, (ConIdx+j),
                      str, str);
              pgv->exitValue = 5;
              ErrorCountCheck(pgv);
            }
          }
        }

        // disallow the one Connector to have more than one DP2DVI defined for it.
        if (DP2DVIMask & (DP2DVIMask-1))
        {
          dprintf("ERROR: DCB Entry %d/Connector Index %d has more than one DP2DVI defined.\n"
                  "       Lwrrently we see DP2DVI %s%s%s%s defined.\n", i, (ConIdx+j),
                  ((HotplugMask&1)?"A":""), ((HotplugMask&2)?"B":""),
                  ((HotplugMask&4)?"C":""), ((HotplugMask&8)?"D":""));
          pgv->exitValue = 5;
          ErrorCountCheck(pgv);
        }

      }
    }
  }

  if (FoundGPIOHotplugMask)
  {
    // Now check to see if GPIO is defined, but Connector is not
    for (i=0; i<7; i++)
    {
      j = 1<<i;
      str[0] = 'A' + (char) i;

      if ( (FoundGPIOHotplugMask & j) &&
          !(FoundConnectorHotplugMask & j) )
      {
        // We only have problems on GPUs < G78, which at the time, only had
        // hotplug A and B defined.  So, if it's A or B and we're < g78,
        // then use a non-build failure ERROR.
        if ( (i<2) && (pgv->Device < 0x4C) )
        {
          dprintf("ERROR: GPIO Table has Hotplug %s defined, but Hotplug %s \n"
                  "       isn't defined on any used connector.\n",
                  str, str);
        }
        else
        {
          dprintf("ERROR: GPIO Table has Hotplug %s defined, but Hotplug %s \n"
                  "       isn't defined on any used connector.\n",
                  str, str);
          pgv->exitValue = 5;
          ErrorCountCheck(pgv);
        }
      }
    }
  }


  // If we didn't find any Hotplug, we need to issue an error.
  if ( (FoundHotplugCapableConnector) &&
      !(FoundGPIOHotplugMask ||
        FoundConnectorHotplugMask) )
  {
    // only build failure error on G78+
    if(pgv->Device >= 0x4C)
    {
      dprintf("ERROR: Entire DCB has no Hotplugs defined.\n");
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
    else
    {
      dprintf("ERROR: Entire DCB has no Hotplugs defined.\n");
    }
  }

  if (FoundGPIODP2DVIMask)
  {
    // Now check to see if GPIO is defined, but Connector is not
    for (i=0; i<4; i++)
    {
      j = 1<<i;
      str[0] = 'A' + (char) i;

      if ( (FoundGPIODP2DVIMask & j) &&
          !(FoundConnectorDP2DVIMask & j) )
      {
        dprintf("ERROR: GPIO Table has DP2DVI %s defined, but DP2DVI %s \n"
                 "       isn't defined on any used connector.\n",
                 str, str);
        pgv->exitValue = 5;
        ErrorCountCheck(pgv);
      }
    }
  }


}




void CheckHdcp_4x(PGV pgv)
{
  LwU32 i;

  // see bug 291801
  // Make sure that there are no LVDS displays that have HDCP set
  // Requested by Christian Green
  for(i=0; i<pgv->DCBEntryCount; i++)
  {
    if(pgv->gIP.GetType(pgv, i) != TYPE_LVDS)
      continue;

    // Note the HDCP bit == 0 for Allow HDCP and 1 for Disallow HDCP
    if (!getLCDHDCP_4x(pgv, i))
    {
      dprintf("ERROR: DCB Entry %d is LVDS and has HDCP set!  This isn't allowed.\n", i);
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
  }

}

void CheckDPHdmi_4x(PGV pgv)
{
  LwU32 i;

  // see bug 200061527
  // Make sure that there are no DP displays that have HDMI capable enabled.
  for(i=0; i<pgv->DCBEntryCount; i++)
  {
    if(pgv->gIP.GetType(pgv, i) != TYPE_DP)
      continue;

    // Note the HDMI bit == 1 for HDMI capable
    if (getLCDHDMI_4x(pgv, i))
    {
      dprintf("ERROR: DCB Entry %d is DP and has HDMI Capable enabled!  This isn't allowed.\n", i);
      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }
  }

}

LwU32 CheckSharedDDCwithSwitchedOutputs_4x(PGV pgv, LwU32 i, LwU32 j)
{
  LwU32 k, AllSkips = 1;
  LwU32 requiredbitmask = 0;
  // Assume that we're already sharing a DDC port.
  // Check to see if i and j is inside the SwitchedOutputTable

  // First search to make sure there are valid DDC entries here
  for (k=0; k<pgv->g4x.swout.EntryCount; k++)
  {
    if (GetSwitchedOutputsDcbIndex(pgv, k) < pgv->DCBEntryCount)
    {
      if ((GetSwitchedOutputsEntryField1(pgv, k) & 0x3E) != 0x3E)
      {
        AllSkips = 0;
        break;
      }
    }
  }

  // If no switchoutputs for DDC, then skip testing.
  if (AllSkips)
  {
    return 0;
  }

  for (k=0; k<pgv->g4x.swout.EntryCount; k++)
  {
    if (GetSwitchedOutputsDcbIndex(pgv, k) == i)
    {
      if (GetSwitchedOutputsDeviceDDCPin(pgv, k) != 0x1F)
      {
        requiredbitmask |= 0x1;
      }
    }
    else if (GetSwitchedOutputsDcbIndex(pgv, k) == j)
    {
      if (GetSwitchedOutputsDeviceDDCPin(pgv, k) != 0x1F)
      {
        requiredbitmask |= 0x2;
      }
    }
  }

  if (requiredbitmask == 0x3)
  {
      return 1;
  }

  return 0;
}



void CheckDP_4x(PGV pgv)
{
  LwU32 i,j;
  LwU32 connectorIndex;
  LwU32 connectorType;
  LwU32 DPTMDSConnectorPairMask = 0;
  LwU32 DP2DVIPresent = 0;
  LwU32 I2CDPAuxSwtichPresent = 0;
  LwU32 HotplugPresent = 0;
  LwU32 gpioFuncSearch = 0xFF;
  LwU32 RequireDPandTMDS = 0;
  LwU32 RequireDPOnly = 0;
  LwU32 RequireDPandTMDSAll = 0;
  LwU32 entryType = 0;

  for(i=0; i<pgv->DCBEntryCount; i++)
  {
    entryType = pgv->gIP.GetType(pgv, i);
    if(entryType == TYPE_SKIP)
      continue;

    RequireDPandTMDS = 0;
    RequireDPOnly = 0;

    connectorIndex = getConnectorIndex_3x(pgv, i);
    connectorType = GetConnectorEntryType(pgv, connectorIndex);

    // Only allow DP Connectors through here
    switch(connectorType)
    {
        case 0x46: // DisplayPort External
        case 0x56: // DisplayPort External if not docked
        case 0x57: // DisplayPort External if docked
        case 0x64: // LFH-DP-1
        case 0x65: // LFH-DP-2
            break;
        default:
            continue;
    }

    // Discard LFH-DP-1 on CRT connectors as the code below assumes TMDS or DP
    if (entryType == TYPE_CRT)
    {
        continue;
    }

    // Flip the bit associated with the connectorIndex
    DPTMDSConnectorPairMask ^= (1 << connectorIndex);

    HotplugPresent = 0;
    gpioFuncSearch = 0xFF;
    if (GetConnectorEntryHotplugA(pgv, connectorIndex))
    {
      HotplugPresent = 1;
      gpioFuncSearch = 7;
    }
    else if(GetConnectorEntryHotplugB(pgv, connectorIndex))
    {
      HotplugPresent = 1;
      gpioFuncSearch = 8;
    }
    else if(GetConnectorEntryHotplugC_4x(pgv, connectorIndex))
    {
      HotplugPresent = 1;
      gpioFuncSearch = 81;
    }
    else if(GetConnectorEntryHotplugD_4x(pgv, connectorIndex))
    {
      HotplugPresent = 1;
      gpioFuncSearch = 82;
    }
    else if(GetConnectorEntryHotplugE_4x(pgv, connectorIndex))
    {
      HotplugPresent = 1;
      gpioFuncSearch = 94;
    }
    else if(GetConnectorEntryHotplugF_4x(pgv, connectorIndex))
    {
      HotplugPresent = 1;
      gpioFuncSearch = 95;
    }
    else if(GetConnectorEntryHotplugG_4x(pgv, connectorIndex))
    {
      HotplugPresent = 1;
      gpioFuncSearch = 96;
    }

    if (!HotplugPresent)
    {
      dprintf("ERROR: DCB Entry %d has DP Connector, but a Hotplug GPIO is not defined.\n"
              "       External DP connectors require a Hotplug per DP spec.\n",
              i);

      pgv->exitValue = 5;
      ErrorCountCheck(pgv);
    }

    if(pgv->gIP.GetLocation(pgv, i) != LOCATION_BOARD)
    {
      if ( (pgv->Device >= 0x94) &&
           (pgv->Device <= 0xA7) )
      {
        // OK, for internal DP on G9x, we need to make sure that there is
        // DP2DVI or I2C/DPAux switch GPIO for every DP connector
        // Rather than check to make sure that we have the GPIO defined
        // I'm just going to look to make sure that we have a DP2DVI or
        // I2C/DPAux Switch defined in the connector entry.  We already
        // make sure that if those are defined in the connectors that
        // the GPIO is also defined inside CheckHotplug_4x().
        DP2DVIPresent = 0;
        DP2DVIPresent |= GetConnectorEntryDP2DVIA_4x(pgv, connectorIndex);
        DP2DVIPresent |= GetConnectorEntryDP2DVIB_4x(pgv, connectorIndex);
        DP2DVIPresent |= GetConnectorEntryDP2DVIC_4x(pgv, connectorIndex);
        DP2DVIPresent |= GetConnectorEntryDP2DVID_4x(pgv, connectorIndex);

        I2CDPAuxSwtichPresent = 0;
        I2CDPAuxSwtichPresent |= GetConnectorEntryDPAuxI2CSelectA_4x(pgv, connectorIndex);
        I2CDPAuxSwtichPresent |= GetConnectorEntryDPAuxI2CSelectB_4x(pgv, connectorIndex);
        I2CDPAuxSwtichPresent |= GetConnectorEntryDPAuxI2CSelectC_4x(pgv, connectorIndex);
        I2CDPAuxSwtichPresent |= GetConnectorEntryDPAuxI2CSelectD_4x(pgv, connectorIndex);

        if (DP2DVIPresent | I2CDPAuxSwtichPresent)
        {
          RequireDPandTMDS = (1 << connectorIndex);
          RequireDPandTMDSAll |= RequireDPandTMDS;
        }
        else
        {
          RequireDPOnly = (1 << connectorIndex);
        }

        if ( (pgv->gIP.GetType(pgv, i) == TYPE_TMDS) &&
             (RequireDPOnly) )
        {
          dprintf("ERROR: TMDS DCB Entry %d has internal DP Connector, but DP2DVI or DPAuxI2C\n"
                  "       Select are neither defined.  One of these must be defined per DP\n"
                  "       connector that supports a DP and TMDS entry.\n",
                  i);
          pgv->exitValue = 5;
          ErrorCountCheck(pgv);
        }
      }
    }

    if( (pgv->gIP.GetType(pgv, i) == TYPE_DP) &&
        (pgv->gIP.GetLocation(pgv, i) != LOCATION_BOARD) )
    {
      if ( (pgv->Device >= 0x94) &&
           (pgv->Device <= 0xA7) )
      {
        LwU32 ccbIndex;
        LwU32 dpAuxPhysicalPort = 0x1F; // init to an invalid value for both dcb 4.0 and dcb 4.1+
        LwU32 gpioPin = 0xFF;

        // We need to make sure that DPAux physical ports and GPIO pairs
        // match here since there's a link inside the GPU between these.

        // Start with the DPAux port
        ccbIndex = pgv->gIP.GetI2CPort(pgv, i);

        if( pgv->DCBVersion >= 0x41 )
        {
          dpAuxPhysicalPort = GetCCBDPPort(pgv, ccbIndex);
        }
        else if( pgv->gIP.GetI2CAccess(pgv, ccbIndex) == 6 )
        {
          dpAuxPhysicalPort = GetCommDpAuxPhysicalPort(pgv, ccbIndex);
        }

        // Make sure that we're hooked up to a DP Aux port.
        if( dpAuxPhysicalPort == 0x1F )
        {
          dprintf("ERROR: DCB Entry %d has internal DP Connector, but the associated DDC Port\n"
                  "       is not a DPAux port!  It must be DPAux for a DP display device.\n",
                  i);
          pgv->exitValue = 5;
          ErrorCountCheck(pgv);
        }
        else
        {
          // OK, now find the GPIO with the specific Hotplug functionality
          // lwrrently assigned to this connector
          for (j = 0; j < pgv->GPIOEntryCount; j++)
          {
            // Skip the non-matches
            if(gpioFuncSearch != GetGpioFunction_40(pgv, j, pgv->GPIOEntryBase, pgv->GPIOEntrySize))
              continue;

            // Grab the pin number
            if (pgv->GPIOVersion == 0x40)
            {
              gpioPin = GetGpioNumber_40(pgv, j, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
            }
            else if (pgv->GPIOVersion == 0x41)
            {
              gpioPin = GetGpioNumber_41(pgv, j, pgv->GPIOEntryBase, pgv->GPIOEntrySize);
            }
            else
            {
              gpioPin = 0xFF;
            }

            break;
          }

          // OK let's match up DPAux port and Pin now
          if ( (dpAuxPhysicalPort == 0) &&
               (gpioPin != 1) )
          {
            dprintf("ERROR: DCB Entry %d: The physical DPAux port, 0, doesn't match the required\n"
                    "       GPIO pin, 1.  This must be fixed on the board since there is a link\n"
                    "       inside the GPU between the DPAux Port and the GPIO Pin.\n",
                    i);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }
          // GT21x does not pin out GPIO 20.  So, they moved the DPAux port 1 association to GPIO 19
          else if( (dpAuxPhysicalPort == 1) &&
                   ( ( (gpioPin != 20) && (pgv->Device < 0xA4) ) ||
                     ( (gpioPin != 19) && (pgv->Device >=0xA4) ) ) )
          {
            dprintf("ERROR: DCB Entry %d: The physical DPAux port, 1, doesn't match the required\n"
                    "       GPIO pin, %d.  This must be fixed on the board since there is a link\n"
                    "       inside the GPU between the DPAux Port and the GPIO Pin.\n",
                    i, ((pgv->Device < 0xA4)?20:19));
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }
          else if( (dpAuxPhysicalPort == 2) &&
                   (gpioPin != 15) )
          {
            dprintf("ERROR: DCB Entry %d: The physical DPAux port, 2, doesn't match the required\n"
                    "       GPIO pin, 15.  This must be fixed on the board since there is a link\n"
                    "       inside the GPU between the DPAux Port and the GPIO Pin.\n",
                    i);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }
          else if( (dpAuxPhysicalPort == 3) &&
                   (gpioPin != 21) )
          {
            dprintf("ERROR: DCB Entry %d: The physical DPAux port, 3, doesn't match the required\n"
                    "       GPIO pin, 21.  This must be fixed on the board since there is a link\n"
                    "       inside the GPU between the DPAux Port and the GPIO Pin.\n",
                    i);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }
        }
      }

      // Bug 781780 - On GF119+, make sure DPAUx_* lines up with GPIO HWSEL_AUX_HPD*
      if (pgv->GPIOVersion == 0x41)
      {
        LwU32 ccbIndex = pgv->gIP.GetI2CPort(pgv, i);
        LwU32 dpAuxPhysicalPort = 0x1F; // init to an invalid value for both dcb 4.0 and dcb 4.1+
        LwU32 gpioInputHwSelect;
        LwU32 combo;

        if( pgv->DCBVersion >= 0x41 )
        {
          dpAuxPhysicalPort = GetCCBDPPort(pgv, ccbIndex);
        }
        else if( pgv->gIP.GetI2CAccess(pgv, ccbIndex) == 6 )
        {
          dpAuxPhysicalPort = GetCommDpAuxPhysicalPort(pgv, ccbIndex);
        }

        // Make sure that we're hooked up to a DP Aux port.
        if( dpAuxPhysicalPort == 0x1F )
        {
          dprintf("ERROR: DCB Entry %d is an internal DP Connector, but the associated DDC Port\n"
                  "       is not a DPAux port!  It must be DPAux for a DP display device.\n",
                  i);
          pgv->exitValue = 5;
          ErrorCountCheck(pgv);
        }
        else
        {
          // OK, now find the GPIO with the specific Hotplug functionality
          // lwrrently assigned to this connector
          for (j = 0; j < pgv->GPIOEntryCount; j++)
          {
            // Skip the non-matches
            if(gpioFuncSearch != GetGpioFunction_40(pgv, j, pgv->GPIOEntryBase, pgv->GPIOEntrySize))
              continue;

            gpioInputHwSelect = GetGpioInputHwSelect_41(pgv, j, pgv->GPIOEntryBase, pgv->GPIOEntrySize);

            combo = (dpAuxPhysicalPort) | (gpioInputHwSelect<<8);

            switch (combo)
            {
              case 0x100:
              case 0x201:
              case 0x302:
              case 0x403:
              case 0x504:
              case 0x605:
              case 0x706:
                // These are all fine.
                break;
              default:
                // this is an error
                dprintf("ERROR: DCB Entry %d is an GPU-sourced DP signal, and the DP Physical\n"
                        "       Port is %d.  But the associated Hotplug GPIO Input HW select \n"
                        "       is set to LW_PMGR_GPIO_INPUT_FUNC_AUX_HPD(%d)!\n",
                        i, dpAuxPhysicalPort, (gpioInputHwSelect-1));

                pgv->exitValue = 5;
                ErrorCountCheck(pgv);
                break;
            }

            // We've found what we need.  Break out.
            break;
          }
        }
      }
    }

    // If we're using external DP, we need to check other items
    if (pgv->gIP.GetLocation(pgv, i) == LOCATION_BOARD)
    {
      // First, let's see if we have a DP2DVI dongle detect.
      // It's not required to have a DP2DVI on external DP, but we need
      // make sure that if it's defined, we have the GPIO defined as well.
      DP2DVIPresent = 0;
      DP2DVIPresent |= GetConnectorEntryDP2DVIA_4x(pgv, connectorIndex);
      DP2DVIPresent |= GetConnectorEntryDP2DVIB_4x(pgv, connectorIndex);
      DP2DVIPresent |= GetConnectorEntryDP2DVIC_4x(pgv, connectorIndex);
      DP2DVIPresent |= GetConnectorEntryDP2DVID_4x(pgv, connectorIndex);

      if (DP2DVIPresent)
      {
        RequireDPandTMDS = (1 << connectorIndex);
        RequireDPandTMDSAll |= RequireDPandTMDS;
      }
    }


  }

  // This should be 0 at the end of the list.  If not, then it means
  // that a DP was defined without a TMDS.  Or a TMDS was defined
  // without a DP.
  if (DPTMDSConnectorPairMask)
  {
    // Find the offending index
    for(i=0; i<pgv->DCBEntryCount; i++)
    {
      j = pgv->gIP.GetType(pgv, i);
      if(j == TYPE_SKIP)
        continue;

      connectorIndex = getConnectorIndex_3x(pgv, i);

      if (DPTMDSConnectorPairMask & (1 << connectorIndex))
      {
        if (!(RequireDPandTMDSAll & (1 << connectorIndex)) &&
             (j == TYPE_DP) )
        {
          dprintf("Note: DCB Entry %d has DP Connector, but no partner TMDS DCB entry is defined.\n"
                  "      This means no DP Dongles will be supported on this connector.\n",
                  i);
        }
        else if ( (RequireDPandTMDSAll & (1 << connectorIndex)) &&
                  (j == TYPE_DP) )
        {
          dprintf("ERROR: DP DCB Entry %d has DP Connector, but no TMDS DCB entry is defined.\n"
                  "       Yet, there's a DP2DVI or I2CSwitch GPIO defined.  So, either the GPIO\n"
                  "       should be removed, or a TMDS entry should be added.\n",
                  i);
          pgv->exitValue = 5;
          ErrorCountCheck(pgv);
        }
        else
        {
          dprintf("ERROR: TMDS DCB Entry %d has DP Connector, but no DP DCB entry is defined.\n"
                  "       DP connectors should be used for DP output or DP + TMDS outputs only.\n",
                  i);
          pgv->exitValue = 5;
          ErrorCountCheck(pgv);
        }
      }
    }
  }
}




//
// 1. If the connector table entry has a non LCDID type, then ERROR if the LCDID field is non-0.
// 2. If the connector table entry has a LCDID type, make sure that there exists at least one
//    GPIO from the LCDID # set inside the GPIO assignment table. Otherwise, ERROR.
// 3. If the GPIO assignment table has any of the 6 types of GPIOs for LCDs, make sure that
//    theres a connector associated with it defined inside the connector table. Otherwise, ERROR.
//
void CheckLcdId_4x(PGV pgv)
{
  LwU32 i;
  LwU32 gpioFunc;
  LwU32 entryType;
  LwU32 connectorIndex;
  LwU32 connectorType;
  LwU32 connectorLcdId;
  LwU32 FoundValidLcdPanelconnector = 0;
  LwU32 FoundLcdIdMask = 0;

  //
  // Total 8 LCD IDs, each can have below GPIO functions
  // bit 0: backlight
  // bit 1: power
  // bit 2: power status
  // bit 3: Self Test
  // bit 4: Lamp Status
  // bit 5: Brightness
  //
  LwU32 FoundLcdPanelGpioMask[8] = {0};

  // This test is only relevant for DCB 4.0+ with GPIO Assignment Table 4.1+
  if ((pgv->DCBVersion < 0x40) || (pgv->GPIOVersion < 0x41))
    return;

  // Find out if any GPIO for an LCD ID is defined
  for (i = 0; i < pgv->GPIOEntryCount; i++)
  {
    gpioFunc = GetGpioFunction_40(pgv, i, pgv->GPIOEntryBase, pgv->GPIOEntrySize);

    // DCB 4.0 has Skip Entries
    if(gpioFunc == 0xFF)
      continue;

    switch(gpioFunc)
    {
      case 0:    // LCD0 backlight
        FoundLcdPanelGpioMask[0] |= 0x01;
        break;
      case 1:    // LCD0 power
        FoundLcdPanelGpioMask[0] |= 0x02;
        break;
      case 2:    // LCD0 power status
        FoundLcdPanelGpioMask[0] |= 0x04;
        break;
      case 31:   // LCD0 Self Test
        FoundLcdPanelGpioMask[0] |= 0x08;
        break;
      case 32:   // LCD0 Lamp Status
        FoundLcdPanelGpioMask[0] |= 0x10;
        break;
      case 33:   // LCD0 Brightness
        FoundLcdPanelGpioMask[0] |= 0x20;
        break;
      case 138:  // LCD1 backlight
        FoundLcdPanelGpioMask[1] |= 0x01;
        break;
      case 139:  // LCD1 power
        FoundLcdPanelGpioMask[1] |= 0x02;
        break;
      case 140:  // LCD1 power status
        FoundLcdPanelGpioMask[1] |= 0x04;
        break;
      case 141:  // LCD1 Self Test
        FoundLcdPanelGpioMask[1] |= 0x08;
        break;
      case 142:  // LCD1 Lamp Status
        FoundLcdPanelGpioMask[1] |= 0x10;
        break;
      case 143:  // LCD1 Brightness
        FoundLcdPanelGpioMask[1] |= 0x20;
        break;
      case 144:  // LCD2 backlight
        FoundLcdPanelGpioMask[2] |= 0x01;
        break;
      case 145:  // LCD2 power
        FoundLcdPanelGpioMask[2] |= 0x02;
        break;
      case 146:  // LCD2 power status
        FoundLcdPanelGpioMask[2] |= 0x04;
        break;
      case 147:  // LCD2 Self Test
        FoundLcdPanelGpioMask[2] |= 0x08;
        break;
      case 148:  // LCD2 Lamp Status
        FoundLcdPanelGpioMask[2] |= 0x10;
        break;
      case 149:  // LCD2 Brightness
        FoundLcdPanelGpioMask[2] |= 0x20;
        break;
      case 150:  // LCD3 backlight
        FoundLcdPanelGpioMask[3] |= 0x01;
        break;
      case 151:  // LCD3 power
        FoundLcdPanelGpioMask[3] |= 0x02;
        break;
      case 152:  // LCD3 power status
        FoundLcdPanelGpioMask[3] |= 0x04;
        break;
      case 153:  // LCD3 Self Test
        FoundLcdPanelGpioMask[3] |= 0x08;
        break;
      case 154:  // LCD3 Lamp Status
        FoundLcdPanelGpioMask[3] |= 0x10;
        break;
      case 155:  // LCD3 Brightness
        FoundLcdPanelGpioMask[3] |= 0x20;
        break;
      case 156:  // LCD4 backlight
        FoundLcdPanelGpioMask[4] |= 0x01;
        break;
      case 157:  // LCD4 power
        FoundLcdPanelGpioMask[4] |= 0x02;
        break;
      case 158:  // LCD4 power status
        FoundLcdPanelGpioMask[4] |= 0x04;
        break;
      case 159:  // LCD4 Self Test
        FoundLcdPanelGpioMask[4] |= 0x08;
        break;
      case 160:  // LCD4 Lamp Status
        FoundLcdPanelGpioMask[4] |= 0x10;
        break;
      case 161:  // LCD4 Brightness
        FoundLcdPanelGpioMask[4] |= 0x20;
        break;
      case 162:  // LCD5 backlight
        FoundLcdPanelGpioMask[5] |= 0x01;
        break;
      case 163:  // LCD5 power
        FoundLcdPanelGpioMask[5] |= 0x02;
        break;
      case 164:  // LCD5 power status
        FoundLcdPanelGpioMask[5] |= 0x04;
        break;
      case 165:  // LCD5 Self Test
        FoundLcdPanelGpioMask[5] |= 0x08;
        break;
      case 166:  // LCD5 Lamp Status
        FoundLcdPanelGpioMask[5] |= 0x10;
        break;
      case 167:  // LCD5 Brightness
        FoundLcdPanelGpioMask[5] |= 0x20;
        break;
      case 168:  // LCD6 backlight
        FoundLcdPanelGpioMask[6] |= 0x01;
        break;
      case 169:  // LCD6 power
        FoundLcdPanelGpioMask[6] |= 0x02;
        break;
      case 170:  // LCD6 power status
        FoundLcdPanelGpioMask[6] |= 0x04;
        break;
      case 171:  // LCD6 Self Test
        FoundLcdPanelGpioMask[6] |= 0x08;
        break;
      case 172:  // LCD6 Lamp Status
        FoundLcdPanelGpioMask[6] |= 0x10;
        break;
      case 173:  // LCD6 Brightness
        FoundLcdPanelGpioMask[6] |= 0x20;
        break;
      case 174:  // LCD7 backlight
        FoundLcdPanelGpioMask[7] |= 0x01;
        break;
      case 175:  // LCD7 power
        FoundLcdPanelGpioMask[7] |= 0x02;
        break;
      case 176:  // LCD7 power status
        FoundLcdPanelGpioMask[7] |= 0x04;
        break;
      case 177:  // LCD7 Self Test
        FoundLcdPanelGpioMask[7] |= 0x08;
        break;
      case 178:  // LCD7 Lamp Status
        FoundLcdPanelGpioMask[7] |= 0x10;
        break;
      case 179:  // LCD7 Brightness
        FoundLcdPanelGpioMask[7] |= 0x20;
        break;
    }
  }

  if(pgv->g3x.cnctr.EntryCount != 0)
  {
    for(i=0; i<pgv->DCBEntryCount; i++)
    {
      entryType = pgv->gIP.GetType(pgv, i);
      if(entryType == TYPE_SKIP)
        continue;

      connectorIndex = getConnectorIndex_3x(pgv, i);
      connectorType = GetConnectorEntryType(pgv, connectorIndex);

      if (connectorType == 0xFF)
        continue;

      switch(connectorType)
      {
        case 0x40: // LVDS-SPWG-Attached
        case 0x41: // LVDS-OEM-Attached
        case 0x42: // LVDS-SPWG-Detached
        case 0x43: // LVDS-OEM-Detached
        case 0x45: // TMDS-OEM-Attached
        case 0x47: // DisplayPort Internal
          FoundValidLcdPanelconnector = 1;
          break;
        case 0x46: // DisplayPort External
          //Location is LOCATION_CHIP and Platform is "Desktop with Integrated full DP"
          if ((pgv->gIP.GetLocation(pgv, i) == LOCATION_CHIP) && (pgv->g3x.cnctr.Platform == 0x07))
          {
              FoundValidLcdPanelconnector = 1;
              break;
          }

        default: // Invalid connector types for non-0 LCD ID
          FoundValidLcdPanelconnector = 0;

          // 1. If the connector table entry has a non LCDID type, then ERROR if the LCDID field is non-0
          if (GetConnectorEntryLcdId_4x(pgv, connectorIndex) != 0x0)
          {
            dprintf("ERROR: Connector Entry %d has non-0 LCD ID, but connector Type is invalid.\n"
                    "       LCD ID should be used for panels connected to internal GPIOs only.\n",
                    connectorIndex);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }
          break;
      }

      if (FoundValidLcdPanelconnector == 1)
      {
          connectorLcdId = GetConnectorEntryLcdId_4x(pgv, connectorIndex);
          FoundLcdIdMask |= (1 << connectorLcdId);

          //
          // 2. If the connector table entry has a LCDID type and the associated DCB entry has
          //    LCD power control set with "Scripts", make sure that there exists at least one
          //    GPIO from the LCDID # set inside the GPIO assignment table. Otherwise, ERROR.
          //
          if ( (!FoundLcdPanelGpioMask[connectorLcdId]) && ( pgv->gIP.GetLCDControl(pgv, i)== 0x01 ) )
          {
            dprintf("ERROR: Connector Entry %d has a valid Type for LCD ID 0x%x and Scripts is used\n"
                    "       for LCD power Control, but no LCD GPIO is defined in DCB GPIO Table.\n"
                    "       At least one GPIO must be defined for a connector with one of the valid\n"
                    "       LCD ID Types.\n",
                    connectorIndex,
                    connectorLcdId);
            pgv->exitValue = 5;
            ErrorCountCheck(pgv);
          }
      }
    }
  }

  //
  // 3. If the GPIO assignment table has any of the 6 types of GPIOs for LCDs, Warning out
  //    if there is no connector associated with it defined inside the connector table.
  //    This is for the case of variants image build for DPIIM support on E boards.
  //
  for (connectorLcdId = 0; connectorLcdId < 8; connectorLcdId++)
  {
    if (FoundLcdPanelGpioMask[connectorLcdId] &&
        !((1 << connectorLcdId) & FoundLcdIdMask))
    {
      if (FoundLcdPanelGpioMask[connectorLcdId] & 0x01)
      {
        dprintf("WARNING: GPIO LCD%d backlight is defined in GPIO Assignment Table, but no valid connector for LCD ID 0x%x is defined in Connector Table.\n"
                "       A valid connector with corresponding LCD ID must be defined in Connector Table if any LCD GPIO is defined.\n",
                connectorLcdId,
                connectorLcdId);
      }
      if (FoundLcdPanelGpioMask[connectorLcdId] & 0x02)
      {
        dprintf("WARNING: GPIO LCD%d power is defined in GPIO Assignment Table, but no valid connector for LCD ID 0x%x is defined in Connector Table.\n"
                "       A valid connector with corresponding LCD ID must be defined in Connector Table if any LCD GPIO is defined.\n",
                connectorLcdId,
                connectorLcdId);
      }
      if (FoundLcdPanelGpioMask[connectorLcdId] & 0x04)
      {
        dprintf("WARNING: GPIO LCD%d power status is defined in GPIO Assignment Table, but no valid connector for LCD ID 0x%x is defined in Connector Table.\n"
                "       A valid connector with corresponding LCD ID must be defined in Connector Table if any LCD GPIO is defined.\n",
                connectorLcdId,
                connectorLcdId);
      }
      if (FoundLcdPanelGpioMask[connectorLcdId] & 0x08)
      {
        dprintf("WARNING: GPIO LCD%d Self Test is defined in GPIO Assignment Table, but no valid connector for LCD ID 0x%x is defined in Connector Table.\n"
                "       A valid connector with corresponding LCD ID must be defined in Connector Table if any LCD GPIO is defined.\n",
                connectorLcdId,
                connectorLcdId);
      }
      if (FoundLcdPanelGpioMask[connectorLcdId] & 0x10)
      {
        dprintf("WARNING: GPIO LCD%d Lamp Status is defined in GPIO Assignment Table, but no valid connector for LCD ID 0x%x is defined in Connector Table.\n"
                "       A valid connector with corresponding LCD ID must be defined in Connector Table if any LCD GPIO is defined.\n",
                connectorLcdId,
                connectorLcdId);
      }
      if (FoundLcdPanelGpioMask[connectorLcdId] & 0x20)
      {
        dprintf("WARNING: GPIO LCD%d Brightness is defined in GPIO Assignment Table, but no valid connector for LCD ID 0x%x is defined in Connector Table.\n"
                "       A valid connector with corresponding LCD ID must be defined in Connector Table if any LCD GPIO is defined.\n",
                connectorLcdId,
                connectorLcdId);
      }
    }
  }

  return;
}



/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2002-2021 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

/******************************** DCBChecker *******************************\
*                                                                           *
* Module: dcbchk.c                                                          *
*                                                                           *
* Written by Steve Rogers (srogers@lwpu.com)                              *
* Let me know if you have any questions/comments/suggestions.               *
*                                                                           *
\***************************************************************************/


#ifdef SEPARATE_COMP // Not used in LWwatch compile
#if !defined(LW_MAC_KEXT)
#include <stdio.h>
#include <stdlib.h>
#endif //!defined(LW_MAC_KEXT)
#include <string.h>

#include "dcbchk.h"
#include "version.h"

// This function is defined to allow separate compiles to work correctly
// with the _LwWatch functions
#define LW_INST_START_ADDR 0
#define readPhysicalMem(a, b, c, d) ((LwU32) (0))
#define readVirtMem(a, b, c, d) ((LwU32) (0))


// Get the next byte in the file
LwU8 GetLwU8_File(PGV pgv)
{
  LwU32 bytesread = 0;
  LwU8 buffer = 0;

  if(pgv->LwrrentFileOffset + pgv->IfrSize > (pgv->ImageSize-1))
    return 0;
  if(fseek(pgv->FP, pgv->LwrrentFileOffset + pgv->IfrSize, SEEK_SET))
    return 0;
  bytesread = (LwU32) fread(&buffer, 1, 1, pgv->FP);

  if(bytesread == 0)
  {
    dprintf("Can't find the next byte at offset 0x%x.\n", pgv->LwrrentFileOffset);
    dprintf("Exiting ...\n\n");
    LW_FCLOSE(pgv);
    pgv->exitValue = 1;
    LW_EXIT(pgv);
  }

  pgv->LwrrentFileOffset += 1;

  return buffer;
}
#endif //SEPARATE_COMP
#ifdef WCC
// Get the next byte in the image
LwU8 GetLwU8_Image(PGV pgv)
{
  LwU8 buffer = 0;

  buffer = *((LwU8 *) (pgv->pBiosImage + pgv->LwrrentFileOffset + pgv->IfrSize));

  pgv->LwrrentFileOffset += 1;

  return buffer;
}
#endif //WCC
// Get the next byte inside LwWatch
LwU8 GetLwU8_LwWatch(PGV pgv)
{
  LwU64 bytesread = 0;
  LwU8 buffer = 0;
  LwU32 status;

  status = readPhysicalMem(LW_INST_START_ADDR + pgv->LwrrentFileOffset + pgv->IfrSize, (void *) &buffer, 1, &bytesread);

  if(bytesread == 0)
  {
    dprintf("Can't find the next byte at offset 0x%x.\n", pgv->LwrrentFileOffset);
    pgv->exitValue = 1;
  }

  pgv->LwrrentFileOffset += 1;

  return buffer;
}
#ifdef SWAK_READ_FUNCTIONS
// Get the next byte inside LwWatch using Virtual offset
LwU8 GetLwU8_SwakVirtual(PGV pgv)
{
  LwU8 *buf = (LwU8 *)pgv->lwwVirtBiosImage;
  return buf[pgv->LwrrentFileOffset++ + pgv->IfrSize];
}

#else // !SWAK_READ_FUNCTIONS


// Get the next byte inside LwWatch using Virtual offset
LwU8 GetLwU8_LwWatchVirtual(PGV pgv)
{
  LwU64 bytesread = 0;
  LwU8 buffer = 0;
  LwU32 status;

  status = readVirtMem(pgv->lwwVirtBiosImage + pgv->LwrrentFileOffset + pgv->IfrSize, (void *) &buffer, 1, &bytesread);

  if(bytesread == 0)
  {
    dprintf("Can't find the next byte at offset 0x%x.\n", pgv->LwrrentFileOffset);
    pgv->exitValue = 1;
  }

  pgv->LwrrentFileOffset += 1;

  return buffer;
}
#endif // !SWAK_READ_FUNCTIONS
#ifdef SEPARATE_COMP // Not used in LWwatch compile
// Get the next word in the file
LwU16 GetLwU16_File(PGV pgv)
{
  LwU32 bytesread = 0;
  LwU16 buffer = 0;

  if(pgv->LwrrentFileOffset + pgv->IfrSize > (pgv->ImageSize-2))
    return 0;
  if(fseek(pgv->FP, pgv->LwrrentFileOffset + pgv->IfrSize, SEEK_SET))
    return 0;
  bytesread = (LwU32) fread(&buffer, 2, 1, pgv->FP);

#ifdef LW_BIG_ENDIAN // Host big endian
  buffer = ((buffer & 0xff00) >> 8) |
           ((buffer & 0x00ff) << 8);
#endif

  if(bytesread == 0)
  {
    dprintf("Can't find the next byte at offset 0x%x.\n", pgv->LwrrentFileOffset);
    dprintf("Exiting ...\n\n");
    LW_FCLOSE(pgv);
    pgv->exitValue = 1;
    LW_EXIT(pgv);
  }

  pgv->LwrrentFileOffset += 2;

  return buffer;
}
#endif // SEPARATE_COMP
#ifdef WCC
// Get the next word in the image
LwU16 GetLwU16_Image(PGV pgv)
{
  LwU16 buffer = 0;

  buffer = *((LwU16 *) (pgv->pBiosImage + pgv->LwrrentFileOffset + pgv->IfrSize));

#ifdef LW_BIG_ENDIAN // Host big endian
  buffer = ((buffer & 0xff00) >> 8) |
           ((buffer & 0x00ff) << 8);
#endif

  pgv->LwrrentFileOffset += 2;

  return buffer;
}
#endif //WCC
// Get the next word inside LwWatch
LwU16 GetLwU16_LwWatch(PGV pgv)
{
  LwU64 bytesread = 0;
  LwU16 wordret = 0;
  LwU32 status;

  status = readPhysicalMem(LW_INST_START_ADDR + pgv->LwrrentFileOffset + pgv->IfrSize, (void*) &wordret, 2, &bytesread);

#ifdef LW_BIG_ENDIAN // Host big endian
  wordret = ((wordret & 0xff00) >> 8) |
            ((wordret & 0x00ff) << 8);
#endif

  if(bytesread == 0)
  {
    dprintf("Can't find the next word offset 0x%x.\n", pgv->LwrrentFileOffset);
    pgv->exitValue = 1;
  }

  pgv->LwrrentFileOffset += 2;

  return wordret;
}


#ifdef SWAK_READ_FUNCTIONS
// Get the next byte inside LwWatch using Virtual offset
LwU16 GetLwU16_SwakVirtual(PGV pgv)
{
  LwU8 *buf = (LwU8 *)pgv->lwwVirtBiosImage;
  LwU16 wordret = 0;

  wordret =  ((LwU16) (buf[pgv->LwrrentFileOffset + pgv->IfrSize    ])) |
            (((LwU16) (buf[pgv->LwrrentFileOffset + pgv->IfrSize + 1]))<<8);

  pgv->LwrrentFileOffset += 2;

  return wordret;
}

#else // !SWAK_READ_FUNCTIONS
// Get the next word inside LwWatch using the virtual pointer
LwU16 GetLwU16_LwWatchVirtual(PGV pgv)
{
  LwU64 bytesread = 0;
  LwU16 wordret = 0;
  LwU32 status;

  status = readVirtMem(pgv->lwwVirtBiosImage + pgv->LwrrentFileOffset + pgv->IfrSize, (void*) &wordret, 2, &bytesread);

#ifdef LW_BIG_ENDIAN // Host big endian
  wordret = ((wordret & 0xff00) >> 8) |
            ((wordret & 0x00ff) << 8);
#endif

  if(bytesread == 0)
  {
    dprintf("Can't find the next word offset 0x%x.\n", pgv->LwrrentFileOffset);
    pgv->exitValue = 1;
  }

  pgv->LwrrentFileOffset += 2;

  return wordret;
}
#endif // !SWAK_READ_FUNCTIONS

#ifdef SEPARATE_COMP // Not used in LWwatch compile
// Get the next word in the file
LwU32 GetLwU32_File(PGV pgv)
{
  LwU32 bytesread = 0;
  LwU32 buffer = 0;

  if(pgv->LwrrentFileOffset + pgv->IfrSize > (pgv->ImageSize-4))
    return 0;
  if(fseek(pgv->FP, pgv->LwrrentFileOffset + pgv->IfrSize, SEEK_SET))
    return 0;
  bytesread = (LwU32) fread(&buffer, 4, 1, pgv->FP);

#ifdef LW_BIG_ENDIAN // Host big endian
  buffer = ((buffer & 0xff000000) >> 24) |
           ((buffer & 0x00ff0000) >>  8) |
           ((buffer & 0x0000ff00) <<  8) |
           ((buffer & 0x000000ff) << 24) ;
#endif

  if(bytesread == 0)
  {
    dprintf("Can't find the next dword at offset 0x%x.\n", pgv->LwrrentFileOffset);
    dprintf("Exiting ...\n\n");
    LW_FCLOSE(pgv);
    pgv->exitValue = 1;
    LW_EXIT(pgv);
  }

  pgv->LwrrentFileOffset += 4;

  return buffer;
}
#endif // SEPARATE_COMP
#ifdef WCC
// Get the next word in the image
LwU32 GetLwU32_Image(PGV pgv)
{
  LwU32 buffer = 0;

  buffer = *((LwU32 *) (pgv->pBiosImage + pgv->LwrrentFileOffset + pgv->IfrSize));

#ifdef LW_BIG_ENDIAN // Host big endian
  buffer = ((buffer & 0xff000000) >> 24) |
           ((buffer & 0x00ff0000) >>  8) |
           ((buffer & 0x0000ff00) <<  8) |
           ((buffer & 0x000000ff) << 24) ;
#endif

  pgv->LwrrentFileOffset += 4;

  return buffer;
}
#endif //WCC
// Get the next dword inside LwWatch
LwU32 GetLwU32_LwWatch(PGV pgv)
{
  LwU64 bytesread = 0;
  LwU32 dwordret = 0;
  LwU32 status;

  status = readPhysicalMem(LW_INST_START_ADDR + pgv->LwrrentFileOffset + pgv->IfrSize, (void*) &dwordret, 4, &bytesread);

#ifdef LW_BIG_ENDIAN // Host big endian
  dwordret = ((dwordret & 0xff000000) >> 24) |
             ((dwordret & 0x00ff0000) >>  8) |
             ((dwordret & 0x0000ff00) <<  8) |
             ((dwordret & 0x000000ff) << 24) ;
#endif

  if(bytesread == 0)
  {
    dprintf("Can't find the next dword offset 0x%x.\n", pgv->LwrrentFileOffset);
    pgv->exitValue = 1;
  }

  pgv->LwrrentFileOffset += 4;

  return dwordret;
}
#ifdef SWAK_READ_FUNCTIONS
// Get the next byte inside LwWatch using Virtual offset
LwU32 GetLwU32_SwakVirtual(PGV pgv)
{
  LwU8 *buf = (LwU8 *)pgv->lwwVirtBiosImage;
  LwU32 dwordret = 0;

  dwordret =  ((LwU32) (buf[pgv->LwrrentFileOffset + pgv->IfrSize    ]))      |
             (((LwU32) (buf[pgv->LwrrentFileOffset + pgv->IfrSize + 1]))<< 8) |
             (((LwU32) (buf[pgv->LwrrentFileOffset + pgv->IfrSize + 2]))<<16) |
             (((LwU32) (buf[pgv->LwrrentFileOffset + pgv->IfrSize + 3]))<<24);

  pgv->LwrrentFileOffset += 4;

  return dwordret;
}

#else // !SWAK_READ_FUNCTIONS
// Get the next dword inside LwWatch using the virtual address of image
LwU32 GetLwU32_LwWatchVirtual(PGV pgv)
{
  LwU64 bytesread = 0;
  LwU32 dwordret = 0;
  LwU32 status;

  status = readVirtMem(pgv->lwwVirtBiosImage + pgv->LwrrentFileOffset + pgv->IfrSize, (void*) &dwordret, 4, &bytesread);

#ifdef LW_BIG_ENDIAN // Host big endian
  dwordret = ((dwordret & 0xff000000) >> 24) |
             ((dwordret & 0x00ff0000) >>  8) |
             ((dwordret & 0x0000ff00) <<  8) |
             ((dwordret & 0x000000ff) << 24) ;
#endif

  if(bytesread == 0)
  {
    dprintf("Can't find the next dword offset 0x%x.\n", pgv->LwrrentFileOffset);
    pgv->exitValue = 1;
  }

  pgv->LwrrentFileOffset += 4;

  return dwordret;
}
#endif // !SWAK_READ_FUNCTIONS

void dcbInitializegIP(PGV pgv)
{
#ifdef SEPARATE_COMP // Not used in LWwatch compile
  pgv->gIP.GetLwU8 = GetLwU8_File;
  pgv->gIP.GetLwU16 = GetLwU16_File;
  pgv->gIP.GetLwU32 = GetLwU32_File;
#else // If !SEPRATE_COMP  i.e. Lwwatch
  if (pgv->lwwVirtBiosImage)
  {
#ifdef SWAK_READ_FUNCTIONS
    pgv->gIP.GetLwU8 = GetLwU8_SwakVirtual;
    pgv->gIP.GetLwU16 = GetLwU16_SwakVirtual;
    pgv->gIP.GetLwU32 = GetLwU32_SwakVirtual;
#else // !SWAK_READ_FUNCTIONS
    pgv->gIP.GetLwU8 = GetLwU8_LwWatchVirtual;
    pgv->gIP.GetLwU16 = GetLwU16_LwWatchVirtual;
    pgv->gIP.GetLwU32 = GetLwU32_LwWatchVirtual;
#endif // !SWAK_READ_FUNCTIONS
  }
  else
  {
    pgv->gIP.GetLwU8 = GetLwU8_LwWatch;
    pgv->gIP.GetLwU16 = GetLwU16_LwWatch;
    pgv->gIP.GetLwU32 = GetLwU32_LwWatch;
  }
#endif
}


#ifdef WCC
void UpdategIPForImage(PGV pgv)
{
  pgv->gIP.GetLwU8 = GetLwU8_Image;
  pgv->gIP.GetLwU16 = GetLwU16_Image;
  pgv->gIP.GetLwU32 = GetLwU32_Image;
}
#endif

#ifdef SEPARATE_COMP // Not used in LWwatch compile
void usage(PGV pgv)
{
#ifdef WIN32
  dprintf("WDCBCHK - Version " VERSION_STR "\n");
  dprintf("USAGE: ");
  dprintf("wdcbchk.exe <ROM FILENAME> <ARGS>\n");
  dprintf("<ROM FILENAME>: An LWPU VBIOS ROM file. This argument must be present.\n");
#else
  dprintf("IDCBCHK - Version " VERSION_STR "\n");
  dprintf("USAGE: ");
  dprintf("idcbchk.exe <ROM FILENAME> <ARGS>\n");
  dprintf("<ROM FILENAME>: An LWPU VBIOS ROM file. ");
#if !defined(WCC)
  dprintf("This argument must be present.\n");
#elif defined(INTERNAL)
  dprintf("Not used for -i or -t options.\n");
#else
  dprintf("Not used for -i option.\n");
#endif
#endif
  dprintf("  ARGS:\n");
#ifdef WCC
  dprintf("  -i, --image : Reads current VBIOS image at C000:0000\n");
#endif
  dprintf("  -o, --outdcb: Dump the DCB to the screen\n");
  dprintf(" -co,--outcomb: Output the combinations of the devices allowed\n");
#ifdef INTERNAL
  dprintf("-co2,--out2com: Output the combinations and reverse head mappings.\n");
  dprintf("        -cosod: Output the combinations in SOD.EXE format.\n");
  dprintf("            -v: Output verbose mode.\n");
  dprintf("            -p: Used to dump performance tables to the screen. As of 4.81 does nothing.\n");
#ifdef WCC
  dprintf("  -t, --timage: Reads current TSR VBIOS image found at Int10 Vector Table\n");
#endif
#endif
  dprintf("  -?,/?,-h,/h : Show this Usage screen\n\n");
  dprintf("Copyright " COPYDATE " by LWPU Corporation.  All rights reserved.\n");
  LW_FCLOSE(pgv);
  pgv->exitValue = -1;
  LW_EXIT(pgv);
}

#if defined(LW_UNIX)
#define stricmp(s1, s2) strcmp(s1, s2)
#endif

void ParseCommandLineOptions(PGV pgv, int argn, char *argp[])
{
  int i,j;
  int filefound = 0;

  if(argn==1)
  {
    usage(pgv);
  }

  for(i=1; i<argn; i++)
  {
    if( (stricmp(argp[i], "-h")==0) ||
        (stricmp(argp[i], "/h")==0) ||
        (stricmp(argp[i], "-?")==0) ||
        (stricmp(argp[i], "/?")==0) ||
        (stricmp(argp[i], "--help")==0) )
    {
      usage(pgv);
    }
#ifdef WCC
    else if( (stricmp(argp[i], "-i")==0) ||
             (stricmp(argp[i], "--image")==0) )
    {
      UpdategIPForImage(pgv);
      filefound = 1;
    }
#ifdef INTERNAL
    else if( (stricmp(argp[i], "-t")==0) ||
             (stricmp(argp[i], "--timage")==0) )
    {
      LwU16 Selector;

      UpdategIPForImage(pgv);

      // This allows TSRed VBIOS to be read correctly
      // We need to update the pointer to the pgv->pBiosImage
      // To do this, we'll read the selector offset
      // from the Interupt vector table
      Selector = *((LwU16 *) 0x10E);
      if(Selector != 0xC000)
      {
          pgv->pBiosImage = ((LwU32) Selector) << 4;
          dprintf("New VBIOS found at selector: 0x%04x.\n\n", Selector);
      }
      filefound = 1;
    }
#endif
#endif
    else if( (stricmp(argp[i], "-o")==0) ||
             (stricmp(argp[i], "--outdcb")==0) )
    {
      pgv->RuntimeFlags |= RT_DESCRIBE;
    }
    else if((stricmp(argp[i], "-co")==0) ||
            (stricmp(argp[i], "--outcomb")==0))
    {
      pgv->RuntimeFlags |= RT_COMBOS;
    }
#ifdef INTERNAL
    else if(stricmp(argp[i], "-v")==0)
    {
      pgv->RuntimeFlags |= RT_VERBOSE;
    }
    else if((stricmp(argp[i], "-co2")==0) ||
            (stricmp(argp[i], "--out2com")==0))
    {
      pgv->RuntimeFlags |= RT_REVCOMBOS;
    }
    else if(stricmp(argp[i], "-cosod")==0)
    {
      pgv->RuntimeFlags |= RT_SODCOMBOS;
    }
    else if(stricmp(argp[i], "-p")==0)
    {
      pgv->RuntimeFlags |= RT_PERFDESCRIBE;
    }
    else if(stricmp(argp[i], "-d")==0)
    {
      i++;
      if (i<argn)
      {
        pgv->FakePCIDevid = strtoul(argp[i], NULL, 16);
      }
      else
      {
        dprintf("Need a hex argument after -d option.\n");
        pgv->exitValue = 1;
        LW_EXIT(pgv);
      }
    }
#endif
    else // It's got to be the filename!
    {

      pgv->FP = fopen(argp[i], "rb");
      if(pgv->FP == NULL)
      {
        dprintf("Can't open ROMFileName, %s, for reading.\n\n", argp[i]);
        usage(pgv);
      }
      fseek(pgv->FP, 0, SEEK_END);
      pgv->ImageSize = ftell(pgv->FP);
      filefound = 1;

      for(j=0; (j<1023)&&(argp[i][j]); j++ )
      {
          pgv->filename[j] = argp[i][j];
      }

    }

  }

  if(!filefound)
  {
    dprintf("No filename listed as argument!\n\n");
    usage(pgv);
  }
}
#else // if !SEPARATE_COMP

#ifndef SWAK_HEADER
void dcbusage()
{
  dprintf("dcb - Based on DCBCHK.EXE - " VERSION_STR "\n");
  dprintf("  This command reads the BIOS copy stored in instance memory and\n");
  dprintf("  outputs the dcb as it reads it from this image.\n");
  dprintf("USAGE: dcb <flags>\n");
  dprintf(" Bitmask flags:\n");
  dprintf("    0x00000001: Output verbose mode.\n");
  dprintf("    0x00000002: Dumps performance tables to the screen.\n");
  dprintf("    0x00000004: Output the combinations of the devices allowed\n");
  dprintf("    0x00000008: Output the combinations and reverse head mappings.\n");
  dprintf("    0x00000010: Output the combinations in SOD.EXE format.\n");
  dprintf("    0x00000020: Output BMP DCB information.\n");
  dprintf(" any other bit: Show this Usage screen\n\n");
}
#endif // !SWAK_HEADER

void ParseLWWatchOptions(PGV pgv, LwU32 flags)
{
  // This should be automatically enabled
  // Since the lwwatch version started as a dump utility
  pgv->RuntimeFlags |= RT_DESCRIBE;

  if(flags & 0x00000001)
  {
    pgv->RuntimeFlags |= RT_VERBOSE;
  }
  if(flags & 0x00000002)
  {
    pgv->RuntimeFlags |= RT_PERFDESCRIBE;
  }
  if(flags & 0x00000004)
  {
    pgv->RuntimeFlags |= RT_COMBOS;
  }
  if(flags & 0x00000008)
  {
    pgv->RuntimeFlags |= RT_REVCOMBOS;
  }
  if(flags & 0x00000010)
  {
    pgv->RuntimeFlags |= RT_SODCOMBOS;
  }
}
#endif // else side of #ifdef SEPARATE_COMP

// Translates the device from PCIDevID to LW numbers
void TranslateDevice(PGV pgv, LwU32 PCIDevID)
{
  pgv->Device = ((PCIDevID>>4) & 0xfff);

  // Some device's PCI ID don't match the HW name
  switch(pgv->Device)
  {
    case 0x032: pgv->Device = 0x034; break;
    case 0x033: pgv->Device = 0x035; break;
    case 0x034: pgv->Device = 0x036; break;
    case 0x004: pgv->Device = 0x040; break;
    case 0x021: pgv->Device = 0x040; break; // LW48 (LW40A02)
    case 0x00C: pgv->Device = 0x041; break;
    case 0x012: pgv->Device = 0x042; break;
    case 0x013: pgv->Device = 0x04E; break; // Crush 50
    case 0x027: pgv->Device = 0x04E; break; // Crush 51
    case 0x03D: pgv->Device = 0x061; break; // MCP61
    case 0x04F: pgv->Device = 0x066; break; // C61/LW66
    case 0x053: pgv->Device = 0x067; break; // MCP67/LW67
    case 0x066: pgv->Device = 0x06B; break; // MCP6B/LW6B
    case 0x07E: pgv->Device = 0x073; break; // MCP73/LW67
    case 0x014: pgv->Device = 0x043; break;
    case 0x016: pgv->Device = 0x044; break;
    case 0x022: pgv->Device = 0x04A; break; // LW44A
    case 0x01D: pgv->Device = 0x046; break;
    case 0x023: pgv->Device = 0x046; break;
    case 0x048: pgv->Device = 0x046; break; // G74
    case 0x009: pgv->Device = 0x047; break;
    case 0x035: pgv->Device = 0x047; break; // same as 47
    case 0x029: pgv->Device = 0x049; break;
    case 0x039: pgv->Device = 0x049; break; // Actually g73, but same as lw49
    case 0x04C: pgv->Device = 0x04C; break; // G78
    // Here we separate from the lw4x name to the G80 names...
    case 0x019: pgv->Device = 0x080; break; // G80
    case 0x040: pgv->Device = 0x082; break; // G82
    case 0x041: pgv->Device = 0x084; break; // G84
    case 0x042: pgv->Device = 0x086; break; // G86
    case 0x060: pgv->Device = 0x092; break; // G92
    case 0x061: pgv->Device = 0x092; break; // G92
    case 0x062: pgv->Device = 0x094; break; // G94
    case 0x063: pgv->Device = 0x094; break; // G94
    case 0x064: pgv->Device = 0x096; break; // G96
    case 0x065: pgv->Device = 0x096; break; // G96
    case 0x06E: pgv->Device = 0x098; break; // G98
    case 0x06F: pgv->Device = 0x098; break; // G98
    case 0x05E: pgv->Device = 0x0A0; break; // GT200/G100?
    case 0x05F: pgv->Device = 0x0A0; break; // GT200/G100?
    case 0x084: pgv->Device = 0x0A3; break; // MCP77/GT206
    case 0x085: pgv->Device = 0x0A3; break; // MCP77/GT206
    case 0x086: pgv->Device = 0x0A3; break; // MCP79/GT206
    case 0x087: pgv->Device = 0x0A3; break; // MCP79/GT206
    case 0x08E: pgv->Device = 0x0A3; break; // iGT206
    case 0x08F: pgv->Device = 0x0A3; break; // iGT206
    case 0x05C: pgv->Device = 0x0A2; break; // GT206/G102?
    case 0x05D: pgv->Device = 0x0A2; break; // GT206/G102?
    case 0x0A0: pgv->Device = 0x0A4; break; // GT212/G104
    case 0x0A1: pgv->Device = 0x0A4; break; // GT212/G104
    case 0x06A: pgv->Device = 0x0A5; break; // GT214/G105?
    case 0x06B: pgv->Device = 0x0A5; break; // GT214/G105?
    case 0x0CA: pgv->Device = 0x0A5; break; // GT215/G105?
    case 0x0CB: pgv->Device = 0x0A5; break; // GT215/G105?
    case 0x0A2: pgv->Device = 0x0A6; break; // GT216/G106?
    case 0x0A3: pgv->Device = 0x0A6; break; // GT216/G106?
    case 0x0A6: pgv->Device = 0x0A7; break; // GT218/G107?
    case 0x0A7: pgv->Device = 0x0A7; break; // GT218/G107?
    case 0x06C: pgv->Device = 0x0B0; break; // GF100
    case 0x06D: pgv->Device = 0x0B0; break; // GF100
#ifdef INTERNAL
    case 0x043: pgv->Device = 0x088; break; // G88
    case 0x0B0: pgv->Device = 0x0A3; break; // iGT209
    case 0x0B1: pgv->Device = 0x0A3; break; // iGT209
    case 0x088: pgv->Device = 0x0AA; break; // MCP87/GT21A or MCP88/GT21A
    case 0x089: pgv->Device = 0x0AA; break; // MCP87/GT21A or MCP88/GT21A
    case 0x08A: pgv->Device = 0x0AA; break; // MCP8A/GT21A or MCP89/GT21A
    case 0x08B: pgv->Device = 0x0AA; break; // MCP8A/GT21A or MCP89/GT21A
    case 0x0E1: pgv->Device = 0x0AD; break; // MCP8D / igt21d iGPU sim model
    case 0x092: pgv->Device = 0x0AD; break; // MCP8D / gt21d
    case 0x093: pgv->Device = 0x0AD; break; // MCP8D / gt21d
    case 0x108: pgv->Device = 0x0B0; break; // GF100B
    case 0x109: pgv->Device = 0x0B0; break; // GF100B
    case 0x10A: pgv->Device = 0x0B0; break; // GF100B_B
    case 0x10B: pgv->Device = 0x0B0; break; // GF100B_B
    case 0x0A4: pgv->Device = 0x0B1; break; // GF10x_arch
    case 0x0A5: pgv->Device = 0x0B1; break; // GF10x_arch
    case 0x0D0: pgv->Device = 0x0B2; break; // GF102
    case 0x0D1: pgv->Device = 0x0B2; break; // GF102
    case 0x0D2: pgv->Device = 0x0B3; break; // GF103
    case 0x0D3: pgv->Device = 0x0B3; break; // GF103
    case 0x0E2: pgv->Device = 0x0B4; break; // GF104
    case 0x0E3: pgv->Device = 0x0B4; break; // GF104
    case 0x0F2: pgv->Device = 0x0B4; break; // GF104_B
    case 0x0F3: pgv->Device = 0x0B4; break; // GF104_B
    case 0x0DA: pgv->Device = 0x0B5; break; // GF105
    case 0x0DB: pgv->Device = 0x0B5; break; // GF105
    case 0x0DC: pgv->Device = 0x0B6; break; // GF106
    case 0x0DD: pgv->Device = 0x0B6; break; // GF106
    case 0x0EE: pgv->Device = 0x0B6; break; // GF106_B
    case 0x0EF: pgv->Device = 0x0B6; break; // GF106_B
    case 0x0DE: pgv->Device = 0x0B7; break; // GF108
    case 0x0DF: pgv->Device = 0x0B7; break; // GF108
    case 0x0F0: pgv->Device = 0x0B7; break; // GF108_B
    case 0x0F1: pgv->Device = 0x0B7; break; // GF108_B

    case 0x0CC: pgv->Device = 0x0B8; break; // gf110d display simulation prototype
    case 0x0CD: pgv->Device = 0x0B8; break; // gf110d display simulation prototype
    case 0x0CE: pgv->Device = 0x0B8; break; // gf110f display FPGA prototype
    case 0x0CF: pgv->Device = 0x0B8; break; // gf110f display FPGA prototype
    case 0x0FA: pgv->Device = 0x0B8; break; // gf110f3 Display Class 022x FPGA prototype

    case 0x0E4: pgv->Device = 0x0B9; break; // GF110_old
    case 0x0E5: pgv->Device = 0x0B9; break; // GF110_old
    case 0x110: pgv->Device = 0x0C0; break; // GF110
    case 0x111: pgv->Device = 0x0C0; break; // GF110
    case 0x112: pgv->Device = 0x0C0; break; // GF110
    case 0x113: pgv->Device = 0x0C0; break; // GF110
    case 0x0E6: pgv->Device = 0x0C0; break; // GF112
    case 0x0E7: pgv->Device = 0x0C0; break; // GF112
    case 0x120: pgv->Device = 0x0C0; break; // GF114
    case 0x121: pgv->Device = 0x0C0; break; // GF114
    case 0x122: pgv->Device = 0x0C0; break; // GF114
    case 0x123: pgv->Device = 0x0C0; break; // GF114
    case 0x0E8: pgv->Device = 0x0C0; break; // GF116_old
    case 0x0E9: pgv->Device = 0x0C0; break; // GF116_old
    case 0x124: pgv->Device = 0x0C0; break; // GF116
    case 0x125: pgv->Device = 0x0C0; break; // GF116
    case 0x126: pgv->Device = 0x0C0; break; // GF116
    case 0x127: pgv->Device = 0x0C0; break; // GF116
    case 0x0EC: pgv->Device = 0x0C0; break; // GF117_old
    case 0x0ED: pgv->Device = 0x0C0; break; // GF117_old
    case 0x114: pgv->Device = 0x0C0; break; // GF117
    case 0x115: pgv->Device = 0x0C0; break; // GF117
    case 0x116: pgv->Device = 0x0C0; break; // GF117
    case 0x117: pgv->Device = 0x0C0; break; // GF117
    case 0x0EA: pgv->Device = 0x0C0; break; // GF118
    case 0x0EB: pgv->Device = 0x0C0; break; // GF118
    case 0x0F8: pgv->Device = 0x0C0; break; // GF118_B
    case 0x0F9: pgv->Device = 0x0C0; break; // GF118_B
    case 0x104: pgv->Device = 0x0C0; break; // GF119
    case 0x105: pgv->Device = 0x0C0; break; // GF119
    case 0x106: pgv->Device = 0x0C0; break; // GF119
    case 0x107: pgv->Device = 0x0C0; break; // GF119

    case 0x100: pgv->Device = 0x0C8; break; // GK110
    case 0x101: pgv->Device = 0x0C8; break; // GK110
    case 0x102: pgv->Device = 0x0C8; break; // GK110
    case 0x103: pgv->Device = 0x0C8; break; // GK110
    case 0x118: pgv->Device = 0x0C8; break; // GK104
    case 0x119: pgv->Device = 0x0C8; break; // GK104
    case 0x11A: pgv->Device = 0x0C8; break; // GK104
    case 0x11B: pgv->Device = 0x0C8; break; // GK104
    case 0x11C: pgv->Device = 0x0C8; break; // GK106
    case 0x11D: pgv->Device = 0x0C8; break; // GK106
    case 0x11E: pgv->Device = 0x0C8; break; // GK106
    case 0x11F: pgv->Device = 0x0C8; break; // GK106
    case 0x0FC: pgv->Device = 0x0C8; break; // GK107
    case 0x0FD: pgv->Device = 0x0C8; break; // GK107
    case 0x0FE: pgv->Device = 0x0C8; break; // GK107
    case 0x0FF: pgv->Device = 0x0C8; break; // GK107
    case 0x128: pgv->Device = 0x0C8; break; // GK208
    case 0x129: pgv->Device = 0x0C8; break; // GK208
    case 0x12A: pgv->Device = 0x0C8; break; // GK208
    case 0x12B: pgv->Device = 0x0C8; break; // GK208
    case 0x12C: pgv->Device = 0x0C8; break; // GK209
    case 0x12D: pgv->Device = 0x0C8; break; // GK209
    case 0x12E: pgv->Device = 0x0C8; break; // GK209
    case 0x12F: pgv->Device = 0x0C8; break; // GK209
    case 0x130: pgv->Device = 0x0C8; break; // GK207
    case 0x131: pgv->Device = 0x0C8; break; // GK207
    case 0x132: pgv->Device = 0x0C8; break; // GK207
    case 0x133: pgv->Device = 0x0C8; break; // GK207
#endif

    case 0x0F: // BR02 chip.. must look at low nibble
               // of PCI Device ID to determine chip
               // connected.
      switch(PCIDevID&0xF)
      {
        // Note I'm using the GPU's original name since the output devices
        // don't change when you tack on a BR02.
        case 0x1: pgv->Device = 0x43; break; // Information found in //hw/br02/doc/DEVID.txt
        case 0x2: pgv->Device = 0x43; break; //
        case 0x8: pgv->Device = 0x40; break; //
        case 0x9: pgv->Device = 0x40; break; //
        case 0xA: pgv->Device = 0x36; break; //
        case 0xB: pgv->Device = 0x35; break; //
        case 0xC: pgv->Device = 0x34; break; //
        case 0xD: pgv->Device = 0x34; break;
        case 0xE: pgv->Device = 0x35; break;
        case 0xF: pgv->Device = 0x18; break; // MEP18
        default:
#ifdef INTERNAL
          dprintf("This is an unknown PCIDEVID(0x%x)+BR02 chip -- Assuming LW18.\n", PCIDevID);
          dprintf("  Please send the line above to srogers with the board+GPU name\n");
#endif // #ifdef INTERNAL
          pgv->Device = 0x18;
          break;
      }
      break;
  }
}

// dcbCheckIfr
// This function check for an IFR rom and will modify the IfrSize field accordingly
void dcbCheckIfr(PGV pgv)
{
  LwU8 VersionSw;
  LwU32 TotalDataSize;
  LwU32 RomDirOffset;
  LwU32 RomDirSignature;
  pgv->LwrrentFileOffset = 0;
  pgv->IfrSize = 0;
  if (pgv->gIP.GetLwU32(pgv) == IFR_SIGNATURE)
  {
    VersionSw = (pgv->gIP.GetLwU32(pgv) >> 8) & 0xFF;
    TotalDataSize = (pgv->gIP.GetLwU32(pgv) >> 0) & 0xFFFFF;
    switch(VersionSw)
    {
      case 0x01:
      case 0x02:
        pgv->LwrrentFileOffset = IFR_SIZE_OFFSET;
        pgv->IfrSize = pgv->gIP.GetLwU32(pgv);
        break;
      case 0x03:
        pgv->LwrrentFileOffset = TotalDataSize;
        RomDirOffset = pgv->gIP.GetLwU32(pgv);   // FlashStatus
        RomDirOffset += 4096;                   // RomDirectory
        pgv->LwrrentFileOffset = RomDirOffset;
        RomDirSignature = pgv->gIP.GetLwU32(pgv);
        if (RomDirSignature == ROMDIR_SIGNATURE)
        {
          pgv->LwrrentFileOffset = RomDirOffset + ROMDIR_OPROM_OFFSET;
          pgv->IfrSize = pgv->gIP.GetLwU32(pgv);
        }
        else
        {
          dprintf("\nERROR! ROM Directory has bad signature: 0x%08x.\n", RomDirSignature);
          dprintf("Exiting ...\n\n");
          LW_FCLOSE(pgv);
          pgv->exitValue = 4;
          return;
        }
        break;
      default:
        dprintf("\nERROR! Unsupported IFR SW version: 0x%02x.\n", VersionSw);
        dprintf("Exiting ...\n\n");
        LW_FCLOSE(pgv);
        pgv->exitValue = 4;
        return;
        break;
    }
  }
}

// dcbCheckBootfsm
// This function checks for a bootfsm ROM and will modifies the IfrSize field
void dcbCheckBootfsm(PGV pgv)
{
  LwU32 SavedFileOffset = pgv->LwrrentFileOffset;
  LwU32 SavedIfrSize = pgv->IfrSize;
  LwU32 Signature;
  pgv->LwrrentFileOffset = 0;
  pgv->IfrSize = 0;
  if (pgv->gIP.GetLwU8(pgv) == BOOTFSM_SIGNATURE)
  {
    pgv->LwrrentFileOffset = BOOTFSM_INSTANCE0_OFFSET;
    Signature = pgv->gIP.GetLwU32(pgv);
    if (Signature == BOOTFSM_INSTANCE0_SIGNATURE1 ||
        Signature == BOOTFSM_INSTANCE0_SIGNATURE2)
    {
      LwU32 Addr = BOOTFSM_INSTANCE0_OFFSET;
      const LwU32 FspTcmSize = 0x60000;
      const LwU32 PciBlockAlignment = 0x200;
      const LwU32 RomDirectoryReservedSize = 48;
      const LwU32 FspImageStartingAddr = Addr;
      const LwU32 RomDirectoryOffsetUpperBound = FspImageStartingAddr +
        FspTcmSize + PciBlockAlignment;
      LwU32 NextStep = PciBlockAlignment - RomDirectoryReservedSize;
      LwU16 RomDirectoryVersion;

      for (Addr += NextStep;
          Addr < RomDirectoryOffsetUpperBound;
          Addr += NextStep)
      {
        if (NextStep == RomDirectoryReservedSize)
        {
          NextStep = PciBlockAlignment - RomDirectoryReservedSize;
        }
        else
        {
          NextStep = RomDirectoryReservedSize;
        }
        pgv->LwrrentFileOffset = Addr;
        if (pgv->gIP.GetLwU32(pgv) != ROMDIR_SIGNATURE)
        {
          continue;
        }

        pgv->LwrrentFileOffset = Addr + ROMDIR_VER_OFFSET;
        RomDirectoryVersion = pgv->gIP.GetLwU16(pgv);

        // ROM Directory Sanitization
        if (RomDirectoryVersion == 3)
        {
          if (Addr % PciBlockAlignment == 0)
          {
            continue;
          }

          pgv->LwrrentFileOffset = Addr + ROMDIR_OPROM_OFFSET;
          pgv->IfrSize = pgv->gIP.GetLwU32(pgv);
          break;
        }
        if (RomDirectoryVersion == 4)
        {
          if (Addr % PciBlockAlignment != 0)
          {
            continue;
          }

          pgv->LwrrentFileOffset = Addr + ROMDIR_OPROM_OFFSET;
          pgv->IfrSize = BOOTFSM_INSTANCE0_OFFSET + pgv->gIP.GetLwU32(pgv);
          break;
        }
      }
    }
  }
  if (pgv->IfrSize == 0)
  {
    pgv->IfrSize = SavedIfrSize;
    pgv->LwrrentFileOffset = SavedFileOffset;
  }
}

// dcbGetDevice
// This function will get the device number from
// the rom file at a word offset+4 located at 18 hex in the file
void dcbGetDevice(PGV pgv)
{
  LwU16 WordOffset = 0;
  LwU16 PCIDeviceID = 0;

  pgv->LwrrentFileOffset = 0x18;
  WordOffset = pgv->gIP.GetLwU16(pgv);

  pgv->LwrrentFileOffset = WordOffset + 6;
  PCIDeviceID = pgv->gIP.GetLwU16(pgv);

  if (pgv->FakePCIDevid)
  {
    // Translate the device from PCIDevID to LW numbers
    TranslateDevice(pgv, pgv->FakePCIDevid);
  }
  else
  {
    // Translate the device from PCIDevID to LW numbers
    IsDisplayfullROM(pgv, PCIDeviceID);
    TranslateDevice(pgv, PCIDeviceID);
  }

  // Don't allow external exelwtables to handle DCB 1.X
#ifndef INTERNAL
  if( (pgv->Device < 0x17) ||
      (pgv->Device ==0x1A) )
  {
    dprintf("This script is only ready to devices LW17 or later.\n");
    // Temporary print out the DeviceID found
    dprintf("PCIDeviceID == 0x%04x.\n", PCIDeviceID);
    dprintf("Exiting ...\n\n");
    LW_FCLOSE(pgv);
    pgv->exitValue = 2;
  }
#endif
}




void dcbGetDCBVersion(PGV pgv)
{
  // Here we will get the version byte from the table
  // and initialie all the function pointers and table offsets.
  pgv->LwrrentFileOffset = DCB_TABLE_PTR_OFFSET;
  pgv->LwrrentFileOffset = (LwU32) (pgv->DCBHeaderPtr = pgv->gIP.GetLwU16(pgv));

  pgv->DCBVersion = pgv->gIP.GetLwU8(pgv);

  if(pgv->DCBVersion >= 0x40)
    InitializeDCB40Data(pgv);
  else if(pgv->DCBVersion >= 0x30)
    InitializeDCB30Data(pgv);
  else if(pgv->DCBVersion >= 0x20)
    InitializeDCB20Data(pgv);
#ifdef INTERNAL
  else if(pgv->DCBVersion >= 0x14)
    InitializeDCB1XData(pgv);
#endif
  else
  {
    dprintf("\nThe DCB Revision 0x%x predates valid DCBs.\n", pgv->DCBVersion);
    dprintf("Default DCB stored in the driver will be used.\n");
    dprintf("Exiting ...\n\n");
    LW_FCLOSE(pgv);
    pgv->exitValue = 3;
  }
  if(pgv->exitValue)
    return;

#ifdef INTERNAL
#ifndef SEPARATE_COMP // LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
  dprintf("Reading BMP/BIT Tables  \r");
#endif
#endif
  InitializeBIT(pgv);

  if(pgv->DCBVersion >= 0x30)
  {
    pgv->LwrrentFileOffset = INTFLAGS2_OFFSET;
    pgv->IntFlags2 = pgv->gIP.GetLwU8(pgv);
  }
  else
    pgv->IntFlags2 = 0;
#endif
}

char GetCharPerValueWithMax(LwU32 Value, LwU32 Max, char mChar)
{
  if(Value>Max)
    return mChar;

  return 'A' + (char)Value;
}

void strcatCharPerMask(char *str, LwU32 Mask)
{
  char ThisCharStr[33];
  LwU32 i, j;

  j=0;
  for(i=0; i<32; i++)
  {
    if(Mask & BIT(i))
    {
      ThisCharStr[j] = (char) (((char) 'A') + ((char) i));
      j++;
    }
  }
  ThisCharStr[j] = 0;

  strcat(str, ThisCharStr);
}

// Called from the DCB specific routines
// Used for DCB 1x, 2x, and 3x.  DCB 4x has it's own.
void strcatMiscStr_Generic(PGV pgv, LwU32 idx, char*str)
{
  char spfvar[16]      = {0};
  switch(pgv->gIP.GetType(pgv, idx))
  {
    case TYPE_CRT:
      // DCB 4.0 doesn't define CRT Max Freq.
      if (pgv->DCBVersion < 0x40)
      {
        sprintf(spfvar, "%dMHZ", (int)pgv->gIP.GetCRTMaxFreq(pgv, idx));
        strcat(str, spfvar);
      }
      break;
    case TYPE_TV:
      pgv->gIP.strcatTVEncoderName(pgv, idx, str);
      switch(pgv->gIP.GetTVFormat(pgv, idx))
      {
        case 0x00: strcat(str, "NTSC-M");     break;
        case 0x01: strcat(str, "NTSC-J");     break;
        case 0x02: strcat(str, "PAL-M");      break;
        case 0x03: strcat(str, "PAL-BDGHI");  break;
        case 0x04: strcat(str, "PAL-N");      break;
        case 0x05: strcat(str, "PAL-NC");     break;

        case 0x08: strcat(str, "HD576i");     break;
        case 0x09: strcat(str, "HD480i");     break;
        case 0x0A: strcat(str, "HD480p");     break;
        case 0x0B: strcat(str, "HD576p");     break;
        case 0x0C: strcat(str, "HD720p");     break;
        case 0x0D: strcat(str, "HD1080i");    break;
        case 0x0E: strcat(str, "HD1080p");    break;
        case 0x0F: strcat(str, "Straps");     break;
        case 0x10: strcat(str, "HD720p50");   break;
        case 0x11: strcat(str, "HD1080i50");  break;

        default:
            sprintf(spfvar, "??%d??", (int)pgv->gIP.GetTVFormat(pgv, idx));
            strcat(str, spfvar);
            break;
      }
      {
        LwU32 TVDACs = pgv->gIP.GetTVDACs(pgv, idx);
        if(TVDACs)
        {
          strcat(str, MYFS"DACS:");
          switch(TVDACs)
          {
            case 0x01: strcat(str, "R");       break;
            case 0x02: strcat(str, "G");       break;
            case 0x03: strcat(str, "RG");      break;
            case 0x04: strcat(str, "B");       break;
            case 0x05: strcat(str, "BR");      break;
            case 0x06: strcat(str, "BG");      break;
            case 0x07: strcat(str, "BGR");     break;
            case 0x08: strcat(str, "Std.HD");  break;
            case 0x09: strcat(str, "HD+B=Ch"); break;
            case 0x0A: strcat(str, "SCARTA");  break;
            case 0x0B: strcat(str, "HD+CV=D"); break;
            case 0x0C: strcat(str, "SCRT+HD"); break;
            case 0x0D: strcat(str, "HD!SD");   break;
            case 0x0E: strcat(str, "SCARTE");  break;
            case 0x0F: strcat(str, "SCARTF");  break;
            case 0x10: strcat(str, "SCART10");  break;
            default:
              sprintf(spfvar, "?0x%02x?", (int)TVDACs);
              strcat(str, spfvar);
              break;
          }
        }
      }
      break;
    case TYPE_LVDS:
    case TYPE_TMDS:
    case TYPE_SDI:
    case TYPE_DP:
      switch(pgv->gIP.GetLCDDDC(pgv, idx))
      {
        case 0x0:  strcat(str, "DDC"MYFS);   break;
        case 0x1:  strcat(str, "Strap"MYFS); break;
      }
      switch(pgv->gIP.GetLCDControl(pgv, idx))
      {
        case 0x0:  strcat(str, "Ext");    break;
        case 0x1:  strcat(str, "Script"); break;
        case 0x2:  strcat(str, "SBIOS");  break;
      }
      pgv->gIP.strcatLCDEncoderName(pgv, idx, str);
      break;
    default: // do nothing!
      break;
  }

}


void Describe(PGV pgv)
{
  LwU32 i;

  dprintf("DCB Version: 0x%02x\n", pgv->DCBVersion);
  // print the header here
  dprintf("# TYPE %c B HM OUTPUT LOC %sMISC\n",
         (pgv->DCBVersion>=0x30)?'D':'I',
         (pgv->DCBVersion>=0x30)?"O/L C ":"");

  for(i=0; i<pgv->DCBEntryCount; i++)
  {
    char TypeStr[5];
    char OutputStr[37];
    char HeadMaskStr[33] = {0};
    char LocationStr[4];
    char Misc[MISC_STR_SPACE];

    if(pgv->gIP.GetType(pgv, i) == TYPE_SKIP)
      continue;

    switch(pgv->gIP.GetType(pgv, i))
    {
      case TYPE_CRT:  strcpy(TypeStr, "CRT "); break;
      case TYPE_TV:   strcpy(TypeStr, "TV  "); break;
      case TYPE_TMDS: strcpy(TypeStr, "TMDS"); break;
      case TYPE_LVDS: strcpy(TypeStr, "LVDS"); break;
      case TYPE_SDVO:
        if (pgv->DCBVersion >= 0x30)
        {
          strcpy(TypeStr, "SDVO");
          break;
        }
        // intentional fall-through
      case TYPE_SDI:
        if (pgv->DCBVersion >= 0x40)
        {
          strcpy(TypeStr, "SDI ");
          break;
        }
      case TYPE_DP:
        if (pgv->DCBVersion >= 0x40)
        {
          strcpy(TypeStr, "DP ");
          break;
        }
        // intentional fall-through
      default:        sprintf(TypeStr, "?%d? ",(int)pgv->gIP.GetType(pgv, i)); break;
    }

    strcatCharPerMask(HeadMaskStr, pgv->gIP.GetHeadMask(pgv, i));

    // Get Output String and Location Str.
    switch(pgv->gIP.GetLocation(pgv, i))
    {
      case LOCATION_CHIP:
        switch(pgv->gIP.GetType(pgv, i))
        {
          case TYPE_CRT:  // Intentional fall through
          case TYPE_TV:   strcpy(OutputStr, "DAC "); break;

          case TYPE_TMDS:
          case TYPE_LVDS: strcpy(OutputStr, "LNK "); break;

          default:        sprintf(OutputStr, "??? "); break;
        }
        strcpy(LocationStr, "CHP");
        break;
      case LOCATION_BOARD:
        strcpy(OutputStr,   "MIO ");
        strcpy(LocationStr, "BRD");
        break;
      case LOCATION_SDVO:
        strcpy(OutputStr,   "SDV ");
        strcpy(LocationStr, "BRD");
        break;
      default:
        break;
    }
    strcatCharPerMask(OutputStr, pgv->gIP.GetOutput(pgv, i));

    pgv->gIP.GetMiscStr(pgv, i, Misc);

    //dprintf("# TYPE %c B HM OUTPUTS LOC MISC\n",
    dprintf("%x %-4s %c %d %-2s %-6s %-3s %s\n",
         i, // Entry number
         TypeStr,
         GetCharPerValueWithMax(pgv->gIP.GetI2CPort(pgv, i), pgv->I2CEntryCount, ' '),
         pgv->gIP.GetBus(pgv, i),
         HeadMaskStr,
         OutputStr,
         LocationStr,
         Misc);
  }

  if(pgv->DCBVersion >= 0x30)
  {
    dprintf("I2C Port Access  Data   Primary: %c   Secondary: %c\n",
            GetCharPerValueWithMax(pgv->g3x.PrimaryPort,   pgv->I2CEntryCount, '?'),
            GetCharPerValueWithMax(pgv->g3x.SecondaryPort, pgv->I2CEntryCount, '?'));
  }
  else
  {
    dprintf("I2C Port Access  Data\n");
  }
  for(i=0; i<pgv->I2CEntryCount; i++)
  {
    switch(pgv->gIP.GetI2CAccess(pgv, i))
    {
      case 0:
        dprintf("    %c    0=CRTC  ReadPort:0x%x  WritePort:0x%x\n",
                GetCharPerValueWithMax(i, pgv->I2CEntryCount, '?'),
                GetI2CCRTCReadPort(pgv, i), GetI2CCRTCWritePort(pgv, i));
        break;
      case 3:
        dprintf("    %c    3=PCI   Type:%s Bus:%d Dev:%d Fn:%d Bar:%d Offset:0x%x\n",
            GetCharPerValueWithMax(i, pgv->I2CEntryCount, '?'),
            ( (GetI2CPCIType(pgv, i)==0) ? "nForce" : "?????" ),
            GetI2CPCIBus(pgv, i),
            GetI2CPCIDevice(pgv, i),
            GetI2CPCIFunction(pgv, i),
            GetI2CPCIBar(pgv, i),
            GetI2CPCIOffset(pgv, i));
        break;
      case 4:
        dprintf("    %c    4=MM    Physical Port:0x%x   IO Port Addr:0x%x\n",
                GetCharPerValueWithMax(i, pgv->I2CEntryCount, '?'),
                GetI2CMMPhysicalPort(pgv, i),
                GetI2CMMIOReadPortAddr(pgv, i));
        break;
      case 0xFF:
        // This is a skip entry
        break;
      default:
        dprintf("    %c    %d=Unknown I2C Access Method.\n",
                GetCharPerValueWithMax(i, pgv->I2CEntryCount, '?'),
                pgv->gIP.GetI2CAccess(pgv, i));
        break;
    }
  }

  // Allow DCB 2.X to print out Miscellaneous Table information:
  pgv->gIP.DescribeMisc(pgv);

  // Print out all other tables that are valid for a particular DCB version
  pgv->gIP.DescribeTables(pgv);
}


// This function was colwerted from dacMapDeviceToHead() in dac.c
// It has since been modified to work with DCB 2.0.
//
// DeviceBitmaps are created like this:  DCB Entry x = (0x1<<x)
LwU32 MapDeviceToHead
(
  PGV  pgv,
  LwU32 DevBitMap,        // devices in configuration
  LwU32 HeadsUsed,        // assigned heads
  LwU32 BusesUsed,        // assigned buses
  LwU32 DACsUsed,         // assigned DACs
  LwU32 LinksUsed,        // assigned internal Links
  LwU32 MIOPortsUsed,     // assigned MIO Ports
  LwU32 I2CPortsUsed,     // assigned I2C Port (mask: port = 0x1, port 2=0x4)
  LwU32 LwrrDev           // current device
)
{
  LwU32 DacsToAdd = 0;
  LwU32 LinksToAdd = 0;
  LwU32 MioPortsToAdd = 0;
  LwU32 I2CPortsToAdd = 0;
  LwU32 HeadsToAdd = 0;
  LwU32 HeadBitmask = 0;
  LwU32 LwrrentHead = 0;

  // Print statement to find errors
  //dprintf("DevBitMap=0x%x, Heads=0x%x, Buses=0x%x, MIO=0x%x, LwrrDev=0x%x\n",
  //       DevBitMap, HeadsUsed, BusesUsed, MIOPortsUsed, LwrrDev);

  // done, no more device
  if(DevBitMap == 0)
  {
    return 1;
  }

  // look for the rightmost set bit
  while ((DevBitMap & 1) == 0)
  {
    DevBitMap >>= 1;
    LwrrDev++;
  }

  // use relwrsion to map device to head, one at a time.
  // First check to see if more than one head is listed in the bitmask
  HeadBitmask = pgv->gIP.GetHeadMask(pgv, LwrrDev);
  if(HeadBitmask & (HeadBitmask - 1))
  {
    // Multiple heads in the bitmask.
    // Try the first one.
    HeadsToAdd = 1;
    while(HeadBitmask)
    {
      // Get the first bit in the bitmask
      while((HeadBitmask & HeadsToAdd) == 0)
        HeadsToAdd <<= 1;

      // Check to see if it's already used
      if (HeadsToAdd & HeadsUsed)
        //
        // Remove it from the bitmask
        HeadBitmask &= ~HeadsToAdd;  // This head is already used
      else
        break;
    }

    if(HeadBitmask == 0)
      return 0;
  }
  else
  {
    // Only one head in the bitmask.  Just go ahead and check.
    if (HeadBitmask & HeadsUsed)
      return 0;
    else
      HeadsToAdd = HeadBitmask;
  }

  if((1<<pgv->gIP.GetBus(pgv, LwrrDev)) & BusesUsed)
    return 0;


  // Don't allow two devices to share the same MIO port
  DacsToAdd = 0;
  LinksToAdd = 0;
  MioPortsToAdd = 0;
  I2CPortsToAdd = 0;
  if(pgv->gIP.GetLocation(pgv, LwrrDev) == LOCATION_CHIP)
  {
    LwU32 Type = pgv->gIP.GetType(pgv, LwrrDev);
    if((Type == TYPE_CRT) || (Type == TYPE_TV))
    {
      if (pgv->gIP.GetOutput(pgv, LwrrDev) & DACsUsed)
        return 0;

      DacsToAdd = pgv->gIP.GetOutput(pgv, LwrrDev);
    }
    else if((Type == TYPE_TMDS) || (Type == TYPE_LVDS))
    {
      if (pgv->gIP.GetOutput(pgv, LwrrDev) & LinksUsed)
        return 0;

      LinksToAdd = pgv->gIP.GetOutput(pgv, LwrrDev);
    }
  }
  else if(pgv->gIP.GetLocation(pgv, LwrrDev) == LOCATION_BOARD)
  {
    if (pgv->gIP.GetOutput(pgv, LwrrDev) & MIOPortsUsed)
      return 0;

    // Go ahead and add this to the MIOPorts Used.
    MioPortsToAdd = pgv->gIP.GetOutput(pgv, LwrrDev);
  }

  I2CPortsToAdd = 1<<pgv->gIP.GetI2CPort(pgv, LwrrDev);
  if(pgv->gIP.GetType(pgv, LwrrDev) == TYPE_TV)
    I2CPortsToAdd = 0;
  if(I2CPortsToAdd == 1<<15)
    I2CPortsToAdd = 0;

  if(I2CPortsToAdd & I2CPortsUsed)
    return 0;


  while((HeadsToAdd & (1<<LwrrentHead)) == 0)
    LwrrentHead++;

  // Make sure to add the Heads allowed on this device
  pgv->HeadAssignment[pgv->HeadAIndex++] = (LwU8) LwrrentHead;

  if (MapDeviceToHead(pgv,
                      (DevBitMap >> 1),
                      HeadsUsed    | HeadsToAdd,
                      BusesUsed    | (1<<pgv->gIP.GetBus(pgv, LwrrDev)),
                      DACsUsed     | DacsToAdd,
                      LinksUsed    | LinksToAdd,
                      MIOPortsUsed | MioPortsToAdd,
                      I2CPortsUsed | I2CPortsToAdd,
                      (LwrrDev + 1)) == 1)
    return 1;

  return 0;
}

void QuickDeviceDump(PGV pgv, LwU32 Head, LwU32 dcbIndex)
{
  LwU32 Type          = pgv->gIP.GetType(pgv, dcbIndex);
  LwU32 Location      = pgv->gIP.GetLocation(pgv, dcbIndex);
  LwU32 OutputDevices = pgv->gIP.GetOutput(pgv, dcbIndex);
  char OutDevStr[8];

  OutDevStr[0] = 0;

  // print out the OutDevs like "A", "AB", "B"
  strcatCharPerMask(OutDevStr, OutputDevices);
  if(strlen(OutDevStr) == 1) strcat(OutDevStr," ");

  switch(Type)
  {
    case 0:  dprintf("CRT ("); break;
    case 1:  dprintf(" TV ("); break;
    case 2:  dprintf("TMDS("); break;
    case 3:  dprintf("LVDS("); break;
    default: dprintf("??? ("); break;
  }

  if(Location == 1)
    dprintf("MIO  %s) ", OutDevStr);
  else if(Location == 0)
  {
    switch(Type)
    {
      case 0:
      case 1: dprintf("DAC  %s) ", OutDevStr); break;
      case 2:
      case 3: dprintf("Link %s) ", OutDevStr); break;
    }
  }
  else
  {
    dprintf("(Bad location: 0x%x) ?? ", Location);
  }

  // Print out Head parameter passed into this function
  dprintf("on Head %c ", GetCharPerValueWithMax(Head, 2, '?'));
}

void DescribeCombos(PGV pgv)
{
  LwU32 i = 0;
  LwU32 j = 0;
  LwU32 DacsToAdd = 0;
  LwU32 LinksToAdd = 0;
  LwU32 MioPortsToAdd = 0;
  LwU32 I2CPortsToAdd = 0;
  LwU32 DevMask = 0;
  LwU32 HeadBitmask = 0;
  LwU32 LwrrentHead = 0;
  LwU32 Type = 0;
  char SOD[16][5];

#ifdef INTERNAL
  // Create the SODNames for each device
  if(pgv->RuntimeFlags & RT_SODCOMBOS)
  {
    LwU32 CRTs = 0;
    LwU32 TVs = 0;
    LwU32 LCDs = 0;
    LwU32 DFPs = 0;

    for(i=0; i<pgv->DCBEntryCount; i++)
    {
      // create an SOD name for each entry in the DCB table
      Type = pgv->gIP.GetType(pgv, i);
      switch(pgv->gIP.GetType(pgv, i))
      {
        case 0: strcpy(&SOD[i][0],"CRT"); SOD[i][3]=(char)('1'+CRTs);                SOD[i][4]=0; CRTs++; break;
        case 1: strcpy(&SOD[i][0],"TV");  SOD[i][3]=(char)('1'+TVs);  SOD[i][3]=' '; SOD[i][4]=0; TVs++;  break;
        case 2: strcpy(&SOD[i][0],"DFP"); SOD[i][3]=(char)('1'+DFPs);                SOD[i][4]=0; DFPs++; break;
        case 3: strcpy(&SOD[i][0],"LCD"); SOD[i][3]=(char)('1'+LCDs);                SOD[i][4]=0; LCDs++; break;
        default: strcpy(&SOD[i][0], "???");
      }
    }
  }
#endif

  for(i = 0; i < pgv->DCBEntryCount; i++)
  {
    if(pgv->gIP.GetType(pgv, i) == TYPE_SKIP)
      continue;

    for(j = i + 1; j < pgv->DCBEntryCount; j++)
    {
      if(pgv->gIP.GetType(pgv, j) == TYPE_SKIP)
        continue;

      // if this is EOL, then go ahead and update the
      // the entry count and get out of this function.
      if( (pgv->DCBVersion >= 0x40) &&
          (pgv->gIP.GetType(pgv, j) == TYPE_EOL) )
      {
        pgv->DCBEntryCount = j;
        break;
      }

      DevMask = (1<<i);
      DevMask |= (1<<j);

      // initialize the pgv->HeadAIndex pointer
      pgv->HeadAIndex = 0;

      // Start with HeadBitmask from i
      HeadBitmask = pgv->gIP.GetHeadMask(pgv, i);
      LwrrentHead = 0;

      while(HeadBitmask)
      {
        while((HeadBitmask & (1<<LwrrentHead)) == 0)
        {
          LwrrentHead += 1;
        }

        // initialize the pgv->HeadAIndex pointer
        pgv->HeadAIndex = 0;

        pgv->HeadAssignment[pgv->HeadAIndex++] = (LwU8) LwrrentHead;

        // Don't allow two devices to share the same MIO port
        DacsToAdd = 0;
        LinksToAdd = 0;
        MioPortsToAdd = 0;
        I2CPortsToAdd = 0;

        if(pgv->gIP.GetLocation(pgv, i) == 0)
        {
          switch(pgv->gIP.GetType(pgv, i))
          {
            case 0:
            case 1: DacsToAdd  = pgv->gIP.GetOutput(pgv, i); break;
            case 2:
            case 3: LinksToAdd = pgv->gIP.GetOutput(pgv, i); break;
          }
        }
        else if(pgv->gIP.GetLocation(pgv, i) == 1)
          // Go ahead and add this to the MIOPorts Used.
          MioPortsToAdd = pgv->gIP.GetOutput(pgv, i);

        I2CPortsToAdd = 1<<pgv->gIP.GetI2CPort(pgv, i);
        if(pgv->gIP.GetType(pgv, i) == TYPE_TV)
          I2CPortsToAdd = 0;
        if(I2CPortsToAdd == 1<<15)
          I2CPortsToAdd = 0;

        // Send off to find if the second device is available
        if(MapDeviceToHead(pgv,
                           (DevMask >> (i+1)),
                           (1<<LwrrentHead),
                           (1<<pgv->gIP.GetBus(pgv, i)),
                           DacsToAdd,
                           LinksToAdd,
                           MioPortsToAdd,
                           I2CPortsToAdd,
                           i+1) == 1)
        {
          // We've got a match....
          dprintf("Device%02d + Device%02d: ", i, j);

#ifdef INTERNAL
          if(pgv->RuntimeFlags & RT_SODCOMBOS)
          {
            dprintf("%s + %s\n", SOD[i], SOD[j]);
          }
          else
#endif
          {
            QuickDeviceDump(pgv, pgv->HeadAssignment[0], i);
            dprintf("+ ");
            QuickDeviceDump(pgv, pgv->HeadAssignment[1], j);
            dprintf("\n");
          }

          // Only output all Head permutations if requested.
          if(!(pgv->RuntimeFlags & RT_REVCOMBOS) )
          {
            HeadBitmask = 0;
          }
        }

        HeadBitmask &= ~(1<<LwrrentHead);
      } // end of while(HeadBitmask)
    } // end of for(j = i + 1; j < DCBNumEntries; j++)
  } // end of for(i = 0; i < DCBNumEntries; i++)
}

void ErrorCountCheck(PGV pgv)
{
    pgv->errorcount++;
    // Bug 1474525 - Remove override - Fail pre-production builds that have errors - Below Core84
    // Don't fail the build if we're on an emulation/simulation rom
    //
    // The Version number is not reliable. We need to check the Emulation/Simulation flags.
    // A value of PRODUCTION means neither the Emulation or Simulation flag(s) are set.

    CheckVBIOSProduction(pgv);
    //dprintf("VBIOS Core%02x \n", pgv->VBIOSCore);
    //dprintf("VBIOSProduction %02x \n", pgv->VBIOSType);

    if (( pgv->VBIOSCore >= Core84) || ( pgv->VBIOSCore < Core84 && ( pgv->VBIOSType == PRODUCTION )))
    {
       if (pgv->errorcount > 100 )
       {
        dprintf("Error count exceeds 100!  Stopping all checks...\n");
        LW_EXIT(pgv);
       }
    }
}

#ifdef SEPARATE_COMP // !LwWatch compile
int main(int argn, char *argp[])
{
#else // LwWatch and SWAK compile
#ifdef SWAK_HEADER // SWAK compile
void getDCB(PGV pgv, LwU32 flags, LwU64 offset)
{
#else // LwWatch compile
void getDCB(LwU32 flags, LwU64 offset)
{
#endif
#endif

#ifdef SWAK_HEADER // SWAK compile
  if (!pgv->lwwVirtBiosImage)
  {
    dprintf("SWAK didn't fill in the VBIOS image address.\n");
  }
  dprintf("SWAK included DCBCHK Version " VERSION_STR "\n");

#else // !SWAK_HEADER
  struct GLOBAL_VARIABLES gv;
  PGV pgv = &gv;

  memset(pgv, 0, sizeof(gv));
#endif

  pgv->pBiosImage        = 0xC0000;
#ifndef SEPARATE_COMP // LwWatch compile
  pgv->lwwVirtBiosImage  = offset;
#endif

  dcbInitializegIP(pgv);

#ifdef SEPARATE_COMP // !LwWatch compile
  ParseCommandLineOptions(pgv, argn, argp);
#else // !SEPARATE_COMP LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
#ifndef USERMODE
  if (lwBar0 == 0)
  {
    dprintf("lw: lwBar0 has not been set, call !lw.init\n");
    return;
  }
#else
  dprintf("lw: Note: dcb will work only if DCB info is mapped through instance memory.\n");
  dprintf("lw:       Verify that this is the case. Else dcb will fail.\n");
#endif
#endif // !SWAK_HEADER - !SWAK Compile

#ifdef SWAK_HEADER // SWAK compile
  pgv->RuntimeFlags = flags;
#else // !SWAK_HEADER
  ParseLWWatchOptions(pgv, flags);
#endif // !SWAK_HEADER
#endif // !SEPARATE_COMP

#ifndef SEPARATE_COMP // LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
  dprintf("Determining Device...\r");
#endif
#endif
  dcbCheckIfr(pgv);
  dcbCheckBootfsm(pgv);
  dcbGetDevice(pgv);
  if(pgv->exitValue)
#ifdef SEPARATE_COMP // !LwWatch compile
    return pgv->exitValue;
#else // LwWatch compile
    return;
#endif

#ifndef SEPARATE_COMP // LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
  dprintf("Parsing DCB tables...\r");
#endif
#endif
  dcbGetDCBVersion(pgv);
  CheckVBIOSCore(pgv);

  if(pgv->exitValue)
#ifdef SEPARATE_COMP // !LwWatch compile
    return pgv->exitValue;
#else // LwWatch compile
    return;
#endif

#ifndef SEPARATE_COMP // LwWatch compile
#ifndef SWAK_HEADER // !SWAK compile
  dprintf("                     \r");
#endif
#endif
  if(pgv->RuntimeFlags & RT_DESCRIBE)
  {
    if(pgv->DCBVersion >=0x40)
    {
      Describe_4x(pgv);
    }
    else
    {
      Describe(pgv);
    }
  }

  if(pgv->RuntimeFlags & RT_COMBOMASK)
    DescribeCombos(pgv);

#ifdef INTERNAL
  pgv->gIP.DescribeBiosStructs(pgv);
#endif

  if (pgv->skip_dcbchk != 0x1)   // Used to skip dcbchk for certain skus.
  {
    CheckMain(pgv);
  }

  LW_FCLOSE((pgv));

 // Bug 1474525 - Remove override - Fail pre-production builds that have errors - Core84+ only
#ifdef SEPARATE_COMP // !LwWatch compile
  // Only fail the build when this is not a simulation/emulation issue
  CheckVBIOSProduction(pgv);
  if (pgv->VBIOSType != PRODUCTION)
  {
    if ((pgv->VBIOSCore < Core84) && (pgv->exitValue))
     {
        dprintf("This ROM does have DCB ERRORs, but it's a pre-production ROM.\n"
                "So, DCBCHK will not fail the build, but there are production bugs\n"
                "that still should be fixed.\n");
     }
  }

  return pgv->exitValue;
#endif
}



