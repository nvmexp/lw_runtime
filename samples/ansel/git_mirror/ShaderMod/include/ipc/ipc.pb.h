// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ipc.proto

#ifndef PROTOBUF_ipc_2eproto__INCLUDED
#define PROTOBUF_ipc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace AnselIpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ipc_2eproto();
void protobuf_AssignDesc_ipc_2eproto();
void protobuf_ShutdownFile_ipc_2eproto();

class IpcVersionRequest;
class IpcVersionResponse;
class AnselReadyRequest;
class AnselReadyResponse;
class AnselStatusReportRequest;
class AnselStatusReportRequest_OneofOptionalData;
class AnselStatusReportResponse;
class SetStyleTransferEnabledRequest;
class SetStyleTransferEnabledResponse;
class SetStyleTransferStyleRequest;
class SetStyleTransferStyleResponse;
class GetStyleTransferModelListRequest;
class GetStyleTransferModelListResponse;
class GetStyleTransferModelListResponse_ModelDescription;
class SetStyleTransferModelRequest;
class SetStyleTransferModelResponse;
class StyleTransferStatusRequest;
class StyleTransferStatusResponse;
class StyleTransferSideloadChoiceRequest;
class StyleTransferSideloadChoiceResponse;
class StyleTransferSideloadProgressRequest;
class StyleTransferSideloadProgressResponse;
class UIReadyRequest;
class UIReadyResponse;
class UIDescButton;
class UIDescSlider;
class UIDescEdit;
class UIDescBoolean;
class UIDescLabel;
class MapFieldEntry;
class UIDescList;
class UIDescPulldown;
class AddUIElementRequest;
class AddUIElementResponse;
class UIControlChangedRequest;
class UIControlChangedResponse;
class UIControlRemoveAllRequest;
class UIControlRemoveAllResponse;
class UIControlRemoveRequest;
class UIControlRemoveResponse;
class UIControlSetVisibilityRequest;
class UIControlSetVisibilityResponse;
class UIControlGetVisibilityRequest;
class UIControlGetVisibilityResponse;
class GetGameSpecificControlsRequest;
class GetSettingsRequest;
class GetSettingsResponse;
class GetSettingsResponse_Setting;
class GetFeatureSetRequest;
class GetFeatureSetResponse;
class SetCMSInfoRequest;
class SetCMSInfoResponse;
class GetEnabledFeatureSetRequest;
class GetEnabledFeatureSetResponse;
class IsAnselModdingAvailableRequest;
class IsAnselModdingAvailableResponse;
class IsAnselSDKIntegrationAvailableRequest;
class IsAnselSDKIntegrationAvailableResponse;
class ScreenResolutionChangedRequest;
class ScreenResolutionChangedResponse;
class SetGridOfThirdsEnabledRequest;
class SetGridOfThirdsEnabledResponse;
class GetProcessInfoRequest;
class GetProcessInfoResponse;
class SetAnselEnabledRequest;
class SetAnselEnabledResponse;
class GetAnselEnabledRequest;
class GetAnselEnabledResponse;
class GetAnselShotPermissionsRequest;
class GetAnselShotPermissionsResponse;
class SetLangIdRequest;
class SetLangIdResponse;
class GetFOVRangeRequest;
class GetFOVRangeResponse;
class SetFOVRequest;
class SetFOVResponse;
class GetLwrrentFOVRequest;
class GetLwrrentFOVResponse;
class GetRollRangeRequest;
class GetRollRangeResponse;
class SetRollRequest;
class SetRollResponse;
class UpdateRollRequest;
class UpdateRollResponse;
class UpdateFovRequest;
class UpdateFovResponse;
class GetScreenResolutionRequest;
class GetScreenResolutionResponse;
class CaptureShotRequest;
class CaptureShotStartedResponse;
class CaptureShotProgressResponse;
class CaptureShotFinishedResponse;
class CaptureShotProcessingFinishedResponse;
class EstimateCaptureRequest;
class EstimateCaptureResponse;
class AbortCaptureRequest;
class AbortCaptureResponse;
class GetHighresResolutionListRequest;
class GetHighresResolutionListResponse;
class GetHighresResolutionListResponse_HighresResolution;
class Get360ResolutionRangeRequest;
class Get360ResolutionRangeResponse;
class GetFilterListRequest;
class GetFilterListResponse;
class ResetEntireStackRequest;
class ResetEntireStackResponse;
class ResetFilterValuesRequest;
class ResetFilterValuesResponse;
class ResetAllFilterValuesRequest;
class SetFilterRequest;
class SetFilterResponse;
class SetFilterAndAttributesRequest;
class SetFilterAndAttributesResponse;
class InsertFilterRequest;
class InsertFilterResponse;
class RemoveFilterRequest;
class RemoveFilterResponse;
class MoveFilterRequest;
class MoveFilterResponse;
class GetStackInfoRequest;
class GetStackInfoResponse;
class FilterProperties;
class FilterProperties_ValuesFloat;
class FilterProperties_ValuesInt;
class FilterProperties_ValuesUInt;
class FilterProperties_ValuesBool;
class FilterProperties_ControlDescription;
class GetFilterInfoRequest;
class GetFilterInfoResponse;
class IsAnselAvailableRequest;
class IsAnselAvailableResponse;
class SetFilterAttributeRequest;
class SetFilterAttributeResponse;
class MouseEventRequest;
class KeyboardEventRequest;
class InputEventRequest;
class InputEventResponse;
class MultipleInputEventRequest;
class LogFilenameResponse;
class ReportErrorResponse;
class SetHighQualityRequest;
class SetHighQualityResponse;
class AnselIPCRequest;
class AnselIPCResponse;
class AnselIPCMessage;

enum ErrorType {
  kFatal = 1,
  kNonFatal = 2
};
bool ErrorType_IsValid(int value);
const ErrorType ErrorType_MIN = kFatal;
const ErrorType ErrorType_MAX = kNonFatal;
const int ErrorType_ARRAYSIZE = ErrorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ErrorType_descriptor();
inline const ::std::string& ErrorType_Name(ErrorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ErrorType_descriptor(), value);
}
inline bool ErrorType_Parse(
    const ::std::string& name, ErrorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorType>(
    ErrorType_descriptor(), name, value);
}
enum Status {
  kOk = 1,
  kFailed = 2,
  kStarted = 3,
  kFailedToStart = 4,
  kNoSpaceLeft = 5,
  kPermissionDenied = 6,
  kIlwalidRequest = 7,
  kFailedToProcess = 8,
  kProcessDeclined = 9,
  kAlreadyEnabled = 10,
  kAlreadyDisabled = 11,
  kOutOfRange = 12,
  kAlreadySet = 13,
  kIncompatibleVersion = 14,
  kDisabled = 15,
  kOkAnsel = 16,
  kOkModsOnly = 17,
  kEffectRequiresDepth = 18,
  kErrorParsingFile = 19,
  kCouldntSaveFile = 20,
  kShotWithUISaved = 21,
  kUnableToSaveShotWithUI = 22,
  kFailedToFinishCapture = 23,
  kFailedToSaveShotFailedCreateDiretory = 24,
  kFailedToSaveShotNoSpaceLeft = 25,
  kProcessingCompleted = 26,
  kNFilesRemainingToProcess = 27,
  kShotSaved = 28,
  kProcessingFile = 29,
  kFailedToSaveShot = 30,
  kStyleCantStartDownload = 31,
  kStyleDownloading = 32,
  kStyleInstallSuccess = 33,
  kStyleInstallFailed = 34,
  kStyleComputeCapTooLow = 35,
  kStyleCouldntLoadLibrestyle = 36,
  kStyleNoModelFound = 37,
  kStyleNotEnoughVRAM = 38,
  kStyleFailedToLoadStyle = 39,
  kStyleFailedToInitalizeStyleTransfer = 40,
  kStyleUnspecifiedNetwork = 41,
  kStyleUnspecifiedStyle = 42,
  kStyleAnselSessionRequired = 43
};
bool Status_IsValid(int value);
const Status Status_MIN = kOk;
const Status Status_MAX = kStyleAnselSessionRequired;
const int Status_ARRAYSIZE = Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_descriptor();
inline const ::std::string& Status_Name(Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_descriptor(), value);
}
inline bool Status_Parse(
    const ::std::string& name, Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
enum ControlType {
  kControlSlider = 1,
  kControlBoolean = 2,
  kControlButton = 3,
  kControlList = 4,
  kControlEdit = 5,
  kControlLabel = 6,
  kControlPulldown = 7,
  kControlColorPicker = 8,
  kControlRadioButton = 9
};
bool ControlType_IsValid(int value);
const ControlType ControlType_MIN = kControlSlider;
const ControlType ControlType_MAX = kControlRadioButton;
const int ControlType_ARRAYSIZE = ControlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ControlType_descriptor();
inline const ::std::string& ControlType_Name(ControlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ControlType_descriptor(), value);
}
inline bool ControlType_Parse(
    const ::std::string& name, ControlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControlType>(
    ControlType_descriptor(), name, value);
}
enum SideloadChoice {
  kYes = 1,
  kNo = 2
};
bool SideloadChoice_IsValid(int value);
const SideloadChoice SideloadChoice_MIN = kYes;
const SideloadChoice SideloadChoice_MAX = kNo;
const int SideloadChoice_ARRAYSIZE = SideloadChoice_MAX + 1;

const ::google::protobuf::EnumDescriptor* SideloadChoice_descriptor();
inline const ::std::string& SideloadChoice_Name(SideloadChoice value) {
  return ::google::protobuf::internal::NameOfEnum(
    SideloadChoice_descriptor(), value);
}
inline bool SideloadChoice_Parse(
    const ::std::string& name, SideloadChoice* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SideloadChoice>(
    SideloadChoice_descriptor(), name, value);
}
enum SideloadProgress {
  kSideloadProgressIdle = 1,
  kSideloadProgressDownloading = 2,
  kSideloadProgressInstalling = 3,
  kSideloadProgressOk = 4,
  kSideloadProgressFailed = 5
};
bool SideloadProgress_IsValid(int value);
const SideloadProgress SideloadProgress_MIN = kSideloadProgressIdle;
const SideloadProgress SideloadProgress_MAX = kSideloadProgressFailed;
const int SideloadProgress_ARRAYSIZE = SideloadProgress_MAX + 1;

const ::google::protobuf::EnumDescriptor* SideloadProgress_descriptor();
inline const ::std::string& SideloadProgress_Name(SideloadProgress value) {
  return ::google::protobuf::internal::NameOfEnum(
    SideloadProgress_descriptor(), value);
}
inline bool SideloadProgress_Parse(
    const ::std::string& name, SideloadProgress* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SideloadProgress>(
    SideloadProgress_descriptor(), name, value);
}
enum State {
  kStateUp = 1,
  kStateDown = 2
};
bool State_IsValid(int value);
const State State_MIN = kStateUp;
const State State_MAX = kStateDown;
const int State_ARRAYSIZE = State_MAX + 1;

const ::google::protobuf::EnumDescriptor* State_descriptor();
inline const ::std::string& State_Name(State value) {
  return ::google::protobuf::internal::NameOfEnum(
    State_descriptor(), value);
}
inline bool State_Parse(
    const ::std::string& name, State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<State>(
    State_descriptor(), name, value);
}
enum ShotTypeIPC {
  kRegular = 0,
  kRegularStereo = 1,
  kHighres = 2,
  kPanorama360Mono = 3,
  kPanorama360Stereo = 4
};
bool ShotTypeIPC_IsValid(int value);
const ShotTypeIPC ShotTypeIPC_MIN = kRegular;
const ShotTypeIPC ShotTypeIPC_MAX = kPanorama360Stereo;
const int ShotTypeIPC_ARRAYSIZE = ShotTypeIPC_MAX + 1;

const ::google::protobuf::EnumDescriptor* ShotTypeIPC_descriptor();
inline const ::std::string& ShotTypeIPC_Name(ShotTypeIPC value) {
  return ::google::protobuf::internal::NameOfEnum(
    ShotTypeIPC_descriptor(), value);
}
inline bool ShotTypeIPC_Parse(
    const ::std::string& name, ShotTypeIPC* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ShotTypeIPC>(
    ShotTypeIPC_descriptor(), name, value);
}
enum EditAllowedType {
  kInt = 0,
  kUint = 1,
  kFloat = 2,
  kAlphaonly = 3,
  kAny = 4
};
bool EditAllowedType_IsValid(int value);
const EditAllowedType EditAllowedType_MIN = kInt;
const EditAllowedType EditAllowedType_MAX = kAny;
const int EditAllowedType_ARRAYSIZE = EditAllowedType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EditAllowedType_descriptor();
inline const ::std::string& EditAllowedType_Name(EditAllowedType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EditAllowedType_descriptor(), value);
}
inline bool EditAllowedType_Parse(
    const ::std::string& name, EditAllowedType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EditAllowedType>(
    EditAllowedType_descriptor(), name, value);
}
enum ListSelectionType {
  kFlyout = 1,
  kCombobox = 2
};
bool ListSelectionType_IsValid(int value);
const ListSelectionType ListSelectionType_MIN = kFlyout;
const ListSelectionType ListSelectionType_MAX = kCombobox;
const int ListSelectionType_ARRAYSIZE = ListSelectionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ListSelectionType_descriptor();
inline const ::std::string& ListSelectionType_Name(ListSelectionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ListSelectionType_descriptor(), value);
}
inline bool ListSelectionType_Parse(
    const ::std::string& name, ListSelectionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ListSelectionType>(
    ListSelectionType_descriptor(), name, value);
}
// ===================================================================

class IpcVersionRequest : public ::google::protobuf::Message {
 public:
  IpcVersionRequest();
  virtual ~IpcVersionRequest();

  IpcVersionRequest(const IpcVersionRequest& from);

  inline IpcVersionRequest& operator=(const IpcVersionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IpcVersionRequest& default_instance();

  void Swap(IpcVersionRequest* other);

  // implements Message ----------------------------------------------

  IpcVersionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IpcVersionRequest& from);
  void MergeFrom(const IpcVersionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.IpcVersionRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static IpcVersionRequest* default_instance_;
};
// -------------------------------------------------------------------

class IpcVersionResponse : public ::google::protobuf::Message {
 public:
  IpcVersionResponse();
  virtual ~IpcVersionResponse();

  IpcVersionResponse(const IpcVersionResponse& from);

  inline IpcVersionResponse& operator=(const IpcVersionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IpcVersionResponse& default_instance();

  void Swap(IpcVersionResponse* other);

  // implements Message ----------------------------------------------

  IpcVersionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IpcVersionResponse& from);
  void MergeFrom(const IpcVersionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 major = 1 [default = 7];
  inline bool has_major() const;
  inline void clear_major();
  static const int kMajorFieldNumber = 1;
  inline ::google::protobuf::uint32 major() const;
  inline void set_major(::google::protobuf::uint32 value);

  // required uint32 minor = 2 [default = 8];
  inline bool has_minor() const;
  inline void clear_minor();
  static const int kMinorFieldNumber = 2;
  inline ::google::protobuf::uint32 minor() const;
  inline void set_minor(::google::protobuf::uint32 value);

  // required uint32 patch = 3 [default = 0];
  inline bool has_patch() const;
  inline void clear_patch();
  static const int kPatchFieldNumber = 3;
  inline ::google::protobuf::uint32 patch() const;
  inline void set_patch(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AnselIpc.IpcVersionResponse)
 private:
  inline void set_has_major();
  inline void clear_has_major();
  inline void set_has_minor();
  inline void clear_has_minor();
  inline void set_has_patch();
  inline void clear_has_patch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 major_;
  ::google::protobuf::uint32 minor_;
  ::google::protobuf::uint32 patch_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static IpcVersionResponse* default_instance_;
};
// -------------------------------------------------------------------

class AnselReadyRequest : public ::google::protobuf::Message {
 public:
  AnselReadyRequest();
  virtual ~AnselReadyRequest();

  AnselReadyRequest(const AnselReadyRequest& from);

  inline AnselReadyRequest& operator=(const AnselReadyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnselReadyRequest& default_instance();

  void Swap(AnselReadyRequest* other);

  // implements Message ----------------------------------------------

  AnselReadyRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnselReadyRequest& from);
  void MergeFrom(const AnselReadyRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 creationCounter = 1;
  inline bool has_creationcounter() const;
  inline void clear_creationcounter();
  static const int kCreationCounterFieldNumber = 1;
  inline ::google::protobuf::uint32 creationcounter() const;
  inline void set_creationcounter(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AnselIpc.AnselReadyRequest)
 private:
  inline void set_has_creationcounter();
  inline void clear_has_creationcounter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 creationcounter_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static AnselReadyRequest* default_instance_;
};
// -------------------------------------------------------------------

class AnselReadyResponse : public ::google::protobuf::Message {
 public:
  AnselReadyResponse();
  virtual ~AnselReadyResponse();

  AnselReadyResponse(const AnselReadyResponse& from);

  inline AnselReadyResponse& operator=(const AnselReadyResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnselReadyResponse& default_instance();

  void Swap(AnselReadyResponse* other);

  // implements Message ----------------------------------------------

  AnselReadyResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnselReadyResponse& from);
  void MergeFrom(const AnselReadyResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.AnselReadyResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static AnselReadyResponse* default_instance_;
};
// -------------------------------------------------------------------

class AnselStatusReportRequest_OneofOptionalData : public ::google::protobuf::Message {
 public:
  AnselStatusReportRequest_OneofOptionalData();
  virtual ~AnselStatusReportRequest_OneofOptionalData();

  AnselStatusReportRequest_OneofOptionalData(const AnselStatusReportRequest_OneofOptionalData& from);

  inline AnselStatusReportRequest_OneofOptionalData& operator=(const AnselStatusReportRequest_OneofOptionalData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnselStatusReportRequest_OneofOptionalData& default_instance();

  enum DataCase {
    kIntegerValue = 1,
    kStringValue = 2,
    kFloatValue = 3,
    kBoolValue = 4,
    DATA_NOT_SET = 0,
  };

  void Swap(AnselStatusReportRequest_OneofOptionalData* other);

  // implements Message ----------------------------------------------

  AnselStatusReportRequest_OneofOptionalData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnselStatusReportRequest_OneofOptionalData& from);
  void MergeFrom(const AnselStatusReportRequest_OneofOptionalData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 integerValue = 1;
  inline bool has_integervalue() const;
  inline void clear_integervalue();
  static const int kIntegerValueFieldNumber = 1;
  inline ::google::protobuf::int32 integervalue() const;
  inline void set_integervalue(::google::protobuf::int32 value);

  // optional string stringValue = 2;
  inline bool has_stringvalue() const;
  inline void clear_stringvalue();
  static const int kStringValueFieldNumber = 2;
  inline const ::std::string& stringvalue() const;
  inline void set_stringvalue(const ::std::string& value);
  inline void set_stringvalue(const char* value);
  inline void set_stringvalue(const char* value, size_t size);
  inline ::std::string* mutable_stringvalue();
  inline ::std::string* release_stringvalue();
  inline void set_allocated_stringvalue(::std::string* stringvalue);

  // optional float floatValue = 3;
  inline bool has_floatvalue() const;
  inline void clear_floatvalue();
  static const int kFloatValueFieldNumber = 3;
  inline float floatvalue() const;
  inline void set_floatvalue(float value);

  // optional bool boolValue = 4;
  inline bool has_boolvalue() const;
  inline void clear_boolvalue();
  static const int kBoolValueFieldNumber = 4;
  inline bool boolvalue() const;
  inline void set_boolvalue(bool value);

  inline DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:AnselIpc.AnselStatusReportRequest.OneofOptionalData)
 private:
  inline void set_has_integervalue();
  inline void set_has_stringvalue();
  inline void set_has_floatvalue();
  inline void set_has_boolvalue();

  inline bool has_data();
  void clear_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union DataUnion {
    ::google::protobuf::int32 integervalue_;
    ::std::string* stringvalue_;
    float floatvalue_;
    bool boolvalue_;
  } data_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static AnselStatusReportRequest_OneofOptionalData* default_instance_;
};
// -------------------------------------------------------------------

class AnselStatusReportRequest : public ::google::protobuf::Message {
 public:
  AnselStatusReportRequest();
  virtual ~AnselStatusReportRequest();

  AnselStatusReportRequest(const AnselStatusReportRequest& from);

  inline AnselStatusReportRequest& operator=(const AnselStatusReportRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnselStatusReportRequest& default_instance();

  void Swap(AnselStatusReportRequest* other);

  // implements Message ----------------------------------------------

  AnselStatusReportRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnselStatusReportRequest& from);
  void MergeFrom(const AnselStatusReportRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AnselStatusReportRequest_OneofOptionalData OneofOptionalData;

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // repeated .AnselIpc.AnselStatusReportRequest.OneofOptionalData data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::AnselIpc::AnselStatusReportRequest_OneofOptionalData& data(int index) const;
  inline ::AnselIpc::AnselStatusReportRequest_OneofOptionalData* mutable_data(int index);
  inline ::AnselIpc::AnselStatusReportRequest_OneofOptionalData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::AnselStatusReportRequest_OneofOptionalData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::AnselStatusReportRequest_OneofOptionalData >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:AnselIpc.AnselStatusReportRequest)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::AnselIpc::AnselStatusReportRequest_OneofOptionalData > data_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static AnselStatusReportRequest* default_instance_;
};
// -------------------------------------------------------------------

class AnselStatusReportResponse : public ::google::protobuf::Message {
 public:
  AnselStatusReportResponse();
  virtual ~AnselStatusReportResponse();

  AnselStatusReportResponse(const AnselStatusReportResponse& from);

  inline AnselStatusReportResponse& operator=(const AnselStatusReportResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnselStatusReportResponse& default_instance();

  void Swap(AnselStatusReportResponse* other);

  // implements Message ----------------------------------------------

  AnselStatusReportResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnselStatusReportResponse& from);
  void MergeFrom(const AnselStatusReportResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.AnselStatusReportResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static AnselStatusReportResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetStyleTransferEnabledRequest : public ::google::protobuf::Message {
 public:
  SetStyleTransferEnabledRequest();
  virtual ~SetStyleTransferEnabledRequest();

  SetStyleTransferEnabledRequest(const SetStyleTransferEnabledRequest& from);

  inline SetStyleTransferEnabledRequest& operator=(const SetStyleTransferEnabledRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetStyleTransferEnabledRequest& default_instance();

  void Swap(SetStyleTransferEnabledRequest* other);

  // implements Message ----------------------------------------------

  SetStyleTransferEnabledRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetStyleTransferEnabledRequest& from);
  void MergeFrom(const SetStyleTransferEnabledRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool enabled = 1;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetStyleTransferEnabledRequest)
 private:
  inline void set_has_enabled();
  inline void clear_has_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool enabled_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetStyleTransferEnabledRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetStyleTransferEnabledResponse : public ::google::protobuf::Message {
 public:
  SetStyleTransferEnabledResponse();
  virtual ~SetStyleTransferEnabledResponse();

  SetStyleTransferEnabledResponse(const SetStyleTransferEnabledResponse& from);

  inline SetStyleTransferEnabledResponse& operator=(const SetStyleTransferEnabledResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetStyleTransferEnabledResponse& default_instance();

  void Swap(SetStyleTransferEnabledResponse* other);

  // implements Message ----------------------------------------------

  SetStyleTransferEnabledResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetStyleTransferEnabledResponse& from);
  void MergeFrom(const SetStyleTransferEnabledResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetStyleTransferEnabledResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetStyleTransferEnabledResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetStyleTransferStyleRequest : public ::google::protobuf::Message {
 public:
  SetStyleTransferStyleRequest();
  virtual ~SetStyleTransferStyleRequest();

  SetStyleTransferStyleRequest(const SetStyleTransferStyleRequest& from);

  inline SetStyleTransferStyleRequest& operator=(const SetStyleTransferStyleRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetStyleTransferStyleRequest& default_instance();

  void Swap(SetStyleTransferStyleRequest* other);

  // implements Message ----------------------------------------------

  SetStyleTransferStyleRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetStyleTransferStyleRequest& from);
  void MergeFrom(const SetStyleTransferStyleRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fullyQualifiedPath = 1;
  inline bool has_fullyqualifiedpath() const;
  inline void clear_fullyqualifiedpath();
  static const int kFullyQualifiedPathFieldNumber = 1;
  inline const ::std::string& fullyqualifiedpath() const;
  inline void set_fullyqualifiedpath(const ::std::string& value);
  inline void set_fullyqualifiedpath(const char* value);
  inline void set_fullyqualifiedpath(const char* value, size_t size);
  inline ::std::string* mutable_fullyqualifiedpath();
  inline ::std::string* release_fullyqualifiedpath();
  inline void set_allocated_fullyqualifiedpath(::std::string* fullyqualifiedpath);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetStyleTransferStyleRequest)
 private:
  inline void set_has_fullyqualifiedpath();
  inline void clear_has_fullyqualifiedpath();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fullyqualifiedpath_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetStyleTransferStyleRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetStyleTransferStyleResponse : public ::google::protobuf::Message {
 public:
  SetStyleTransferStyleResponse();
  virtual ~SetStyleTransferStyleResponse();

  SetStyleTransferStyleResponse(const SetStyleTransferStyleResponse& from);

  inline SetStyleTransferStyleResponse& operator=(const SetStyleTransferStyleResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetStyleTransferStyleResponse& default_instance();

  void Swap(SetStyleTransferStyleResponse* other);

  // implements Message ----------------------------------------------

  SetStyleTransferStyleResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetStyleTransferStyleResponse& from);
  void MergeFrom(const SetStyleTransferStyleResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetStyleTransferStyleResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetStyleTransferStyleResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetStyleTransferModelListRequest : public ::google::protobuf::Message {
 public:
  GetStyleTransferModelListRequest();
  virtual ~GetStyleTransferModelListRequest();

  GetStyleTransferModelListRequest(const GetStyleTransferModelListRequest& from);

  inline GetStyleTransferModelListRequest& operator=(const GetStyleTransferModelListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetStyleTransferModelListRequest& default_instance();

  void Swap(GetStyleTransferModelListRequest* other);

  // implements Message ----------------------------------------------

  GetStyleTransferModelListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetStyleTransferModelListRequest& from);
  void MergeFrom(const GetStyleTransferModelListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.GetStyleTransferModelListRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetStyleTransferModelListRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetStyleTransferModelListResponse_ModelDescription : public ::google::protobuf::Message {
 public:
  GetStyleTransferModelListResponse_ModelDescription();
  virtual ~GetStyleTransferModelListResponse_ModelDescription();

  GetStyleTransferModelListResponse_ModelDescription(const GetStyleTransferModelListResponse_ModelDescription& from);

  inline GetStyleTransferModelListResponse_ModelDescription& operator=(const GetStyleTransferModelListResponse_ModelDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetStyleTransferModelListResponse_ModelDescription& default_instance();

  void Swap(GetStyleTransferModelListResponse_ModelDescription* other);

  // implements Message ----------------------------------------------

  GetStyleTransferModelListResponse_ModelDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetStyleTransferModelListResponse_ModelDescription& from);
  void MergeFrom(const GetStyleTransferModelListResponse_ModelDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string localizedName = 2;
  inline bool has_localizedname() const;
  inline void clear_localizedname();
  static const int kLocalizedNameFieldNumber = 2;
  inline const ::std::string& localizedname() const;
  inline void set_localizedname(const ::std::string& value);
  inline void set_localizedname(const char* value);
  inline void set_localizedname(const char* value, size_t size);
  inline ::std::string* mutable_localizedname();
  inline ::std::string* release_localizedname();
  inline void set_allocated_localizedname(::std::string* localizedname);

  // @@protoc_insertion_point(class_scope:AnselIpc.GetStyleTransferModelListResponse.ModelDescription)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_localizedname();
  inline void clear_has_localizedname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* localizedname_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetStyleTransferModelListResponse_ModelDescription* default_instance_;
};
// -------------------------------------------------------------------

class GetStyleTransferModelListResponse : public ::google::protobuf::Message {
 public:
  GetStyleTransferModelListResponse();
  virtual ~GetStyleTransferModelListResponse();

  GetStyleTransferModelListResponse(const GetStyleTransferModelListResponse& from);

  inline GetStyleTransferModelListResponse& operator=(const GetStyleTransferModelListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetStyleTransferModelListResponse& default_instance();

  void Swap(GetStyleTransferModelListResponse* other);

  // implements Message ----------------------------------------------

  GetStyleTransferModelListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetStyleTransferModelListResponse& from);
  void MergeFrom(const GetStyleTransferModelListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GetStyleTransferModelListResponse_ModelDescription ModelDescription;

  // accessors -------------------------------------------------------

  // repeated .AnselIpc.GetStyleTransferModelListResponse.ModelDescription models = 1;
  inline int models_size() const;
  inline void clear_models();
  static const int kModelsFieldNumber = 1;
  inline const ::AnselIpc::GetStyleTransferModelListResponse_ModelDescription& models(int index) const;
  inline ::AnselIpc::GetStyleTransferModelListResponse_ModelDescription* mutable_models(int index);
  inline ::AnselIpc::GetStyleTransferModelListResponse_ModelDescription* add_models();
  inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::GetStyleTransferModelListResponse_ModelDescription >&
      models() const;
  inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::GetStyleTransferModelListResponse_ModelDescription >*
      mutable_models();

  // @@protoc_insertion_point(class_scope:AnselIpc.GetStyleTransferModelListResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::AnselIpc::GetStyleTransferModelListResponse_ModelDescription > models_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetStyleTransferModelListResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetStyleTransferModelRequest : public ::google::protobuf::Message {
 public:
  SetStyleTransferModelRequest();
  virtual ~SetStyleTransferModelRequest();

  SetStyleTransferModelRequest(const SetStyleTransferModelRequest& from);

  inline SetStyleTransferModelRequest& operator=(const SetStyleTransferModelRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetStyleTransferModelRequest& default_instance();

  void Swap(SetStyleTransferModelRequest* other);

  // implements Message ----------------------------------------------

  SetStyleTransferModelRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetStyleTransferModelRequest& from);
  void MergeFrom(const SetStyleTransferModelRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string modelId = 1;
  inline bool has_modelid() const;
  inline void clear_modelid();
  static const int kModelIdFieldNumber = 1;
  inline const ::std::string& modelid() const;
  inline void set_modelid(const ::std::string& value);
  inline void set_modelid(const char* value);
  inline void set_modelid(const char* value, size_t size);
  inline ::std::string* mutable_modelid();
  inline ::std::string* release_modelid();
  inline void set_allocated_modelid(::std::string* modelid);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetStyleTransferModelRequest)
 private:
  inline void set_has_modelid();
  inline void clear_has_modelid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* modelid_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetStyleTransferModelRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetStyleTransferModelResponse : public ::google::protobuf::Message {
 public:
  SetStyleTransferModelResponse();
  virtual ~SetStyleTransferModelResponse();

  SetStyleTransferModelResponse(const SetStyleTransferModelResponse& from);

  inline SetStyleTransferModelResponse& operator=(const SetStyleTransferModelResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetStyleTransferModelResponse& default_instance();

  void Swap(SetStyleTransferModelResponse* other);

  // implements Message ----------------------------------------------

  SetStyleTransferModelResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetStyleTransferModelResponse& from);
  void MergeFrom(const SetStyleTransferModelResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetStyleTransferModelResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetStyleTransferModelResponse* default_instance_;
};
// -------------------------------------------------------------------

class StyleTransferStatusRequest : public ::google::protobuf::Message {
 public:
  StyleTransferStatusRequest();
  virtual ~StyleTransferStatusRequest();

  StyleTransferStatusRequest(const StyleTransferStatusRequest& from);

  inline StyleTransferStatusRequest& operator=(const StyleTransferStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StyleTransferStatusRequest& default_instance();

  void Swap(StyleTransferStatusRequest* other);

  // implements Message ----------------------------------------------

  StyleTransferStatusRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StyleTransferStatusRequest& from);
  void MergeFrom(const StyleTransferStatusRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.StyleTransferStatusRequest)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static StyleTransferStatusRequest* default_instance_;
};
// -------------------------------------------------------------------

class StyleTransferStatusResponse : public ::google::protobuf::Message {
 public:
  StyleTransferStatusResponse();
  virtual ~StyleTransferStatusResponse();

  StyleTransferStatusResponse(const StyleTransferStatusResponse& from);

  inline StyleTransferStatusResponse& operator=(const StyleTransferStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StyleTransferStatusResponse& default_instance();

  void Swap(StyleTransferStatusResponse* other);

  // implements Message ----------------------------------------------

  StyleTransferStatusResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StyleTransferStatusResponse& from);
  void MergeFrom(const StyleTransferStatusResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.StyleTransferStatusResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static StyleTransferStatusResponse* default_instance_;
};
// -------------------------------------------------------------------

class StyleTransferSideloadChoiceRequest : public ::google::protobuf::Message {
 public:
  StyleTransferSideloadChoiceRequest();
  virtual ~StyleTransferSideloadChoiceRequest();

  StyleTransferSideloadChoiceRequest(const StyleTransferSideloadChoiceRequest& from);

  inline StyleTransferSideloadChoiceRequest& operator=(const StyleTransferSideloadChoiceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StyleTransferSideloadChoiceRequest& default_instance();

  void Swap(StyleTransferSideloadChoiceRequest* other);

  // implements Message ----------------------------------------------

  StyleTransferSideloadChoiceRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StyleTransferSideloadChoiceRequest& from);
  void MergeFrom(const StyleTransferSideloadChoiceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 packageSizeInBytes = 1;
  inline bool has_packagesizeinbytes() const;
  inline void clear_packagesizeinbytes();
  static const int kPackageSizeInBytesFieldNumber = 1;
  inline ::google::protobuf::uint32 packagesizeinbytes() const;
  inline void set_packagesizeinbytes(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AnselIpc.StyleTransferSideloadChoiceRequest)
 private:
  inline void set_has_packagesizeinbytes();
  inline void clear_has_packagesizeinbytes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 packagesizeinbytes_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static StyleTransferSideloadChoiceRequest* default_instance_;
};
// -------------------------------------------------------------------

class StyleTransferSideloadChoiceResponse : public ::google::protobuf::Message {
 public:
  StyleTransferSideloadChoiceResponse();
  virtual ~StyleTransferSideloadChoiceResponse();

  StyleTransferSideloadChoiceResponse(const StyleTransferSideloadChoiceResponse& from);

  inline StyleTransferSideloadChoiceResponse& operator=(const StyleTransferSideloadChoiceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StyleTransferSideloadChoiceResponse& default_instance();

  void Swap(StyleTransferSideloadChoiceResponse* other);

  // implements Message ----------------------------------------------

  StyleTransferSideloadChoiceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StyleTransferSideloadChoiceResponse& from);
  void MergeFrom(const StyleTransferSideloadChoiceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.SideloadChoice choice = 1;
  inline bool has_choice() const;
  inline void clear_choice();
  static const int kChoiceFieldNumber = 1;
  inline ::AnselIpc::SideloadChoice choice() const;
  inline void set_choice(::AnselIpc::SideloadChoice value);

  // @@protoc_insertion_point(class_scope:AnselIpc.StyleTransferSideloadChoiceResponse)
 private:
  inline void set_has_choice();
  inline void clear_has_choice();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int choice_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static StyleTransferSideloadChoiceResponse* default_instance_;
};
// -------------------------------------------------------------------

class StyleTransferSideloadProgressRequest : public ::google::protobuf::Message {
 public:
  StyleTransferSideloadProgressRequest();
  virtual ~StyleTransferSideloadProgressRequest();

  StyleTransferSideloadProgressRequest(const StyleTransferSideloadProgressRequest& from);

  inline StyleTransferSideloadProgressRequest& operator=(const StyleTransferSideloadProgressRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StyleTransferSideloadProgressRequest& default_instance();

  void Swap(StyleTransferSideloadProgressRequest* other);

  // implements Message ----------------------------------------------

  StyleTransferSideloadProgressRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StyleTransferSideloadProgressRequest& from);
  void MergeFrom(const StyleTransferSideloadProgressRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.StyleTransferSideloadProgressRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static StyleTransferSideloadProgressRequest* default_instance_;
};
// -------------------------------------------------------------------

class StyleTransferSideloadProgressResponse : public ::google::protobuf::Message {
 public:
  StyleTransferSideloadProgressResponse();
  virtual ~StyleTransferSideloadProgressResponse();

  StyleTransferSideloadProgressResponse(const StyleTransferSideloadProgressResponse& from);

  inline StyleTransferSideloadProgressResponse& operator=(const StyleTransferSideloadProgressResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StyleTransferSideloadProgressResponse& default_instance();

  void Swap(StyleTransferSideloadProgressResponse* other);

  // implements Message ----------------------------------------------

  StyleTransferSideloadProgressResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StyleTransferSideloadProgressResponse& from);
  void MergeFrom(const StyleTransferSideloadProgressResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.SideloadProgress status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::SideloadProgress status() const;
  inline void set_status(::AnselIpc::SideloadProgress value);

  // optional int32 progress = 2;
  inline bool has_progress() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 2;
  inline ::google::protobuf::int32 progress() const;
  inline void set_progress(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AnselIpc.StyleTransferSideloadProgressResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_progress();
  inline void clear_has_progress();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  ::google::protobuf::int32 progress_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static StyleTransferSideloadProgressResponse* default_instance_;
};
// -------------------------------------------------------------------

class UIReadyRequest : public ::google::protobuf::Message {
 public:
  UIReadyRequest();
  virtual ~UIReadyRequest();

  UIReadyRequest(const UIReadyRequest& from);

  inline UIReadyRequest& operator=(const UIReadyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIReadyRequest& default_instance();

  void Swap(UIReadyRequest* other);

  // implements Message ----------------------------------------------

  UIReadyRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIReadyRequest& from);
  void MergeFrom(const UIReadyRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.UIReadyRequest)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UIReadyRequest* default_instance_;
};
// -------------------------------------------------------------------

class UIReadyResponse : public ::google::protobuf::Message {
 public:
  UIReadyResponse();
  virtual ~UIReadyResponse();

  UIReadyResponse(const UIReadyResponse& from);

  inline UIReadyResponse& operator=(const UIReadyResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIReadyResponse& default_instance();

  void Swap(UIReadyResponse* other);

  // implements Message ----------------------------------------------

  UIReadyResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIReadyResponse& from);
  void MergeFrom(const UIReadyResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.UIReadyResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UIReadyResponse* default_instance_;
};
// -------------------------------------------------------------------

class UIDescButton : public ::google::protobuf::Message {
 public:
  UIDescButton();
  virtual ~UIDescButton();

  UIDescButton(const UIDescButton& from);

  inline UIDescButton& operator=(const UIDescButton& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIDescButton& default_instance();

  void Swap(UIDescButton* other);

  // implements Message ----------------------------------------------

  UIDescButton* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIDescButton& from);
  void MergeFrom(const UIDescButton& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:AnselIpc.UIDescButton)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* text_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UIDescButton* default_instance_;
};
// -------------------------------------------------------------------

class UIDescSlider : public ::google::protobuf::Message {
 public:
  UIDescSlider();
  virtual ~UIDescSlider();

  UIDescSlider(const UIDescSlider& from);

  inline UIDescSlider& operator=(const UIDescSlider& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIDescSlider& default_instance();

  void Swap(UIDescSlider* other);

  // implements Message ----------------------------------------------

  UIDescSlider* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIDescSlider& from);
  void MergeFrom(const UIDescSlider& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional float milwalue = 3;
  inline bool has_milwalue() const;
  inline void clear_milwalue();
  static const int kMilwalueFieldNumber = 3;
  inline float milwalue() const;
  inline void set_milwalue(float value);

  // optional float maxValue = 4;
  inline bool has_maxvalue() const;
  inline void clear_maxvalue();
  static const int kMaxValueFieldNumber = 4;
  inline float maxvalue() const;
  inline void set_maxvalue(float value);

  // optional float value = 5;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 5;
  inline float value() const;
  inline void set_value(float value);

  // optional float interval = 6;
  inline bool has_interval() const;
  inline void clear_interval();
  static const int kIntervalFieldNumber = 6;
  inline float interval() const;
  inline void set_interval(float value);

  // @@protoc_insertion_point(class_scope:AnselIpc.UIDescSlider)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_milwalue();
  inline void clear_has_milwalue();
  inline void set_has_maxvalue();
  inline void clear_has_maxvalue();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_interval();
  inline void clear_has_interval();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* text_;
  ::google::protobuf::int32 id_;
  float milwalue_;
  float maxvalue_;
  float value_;
  float interval_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UIDescSlider* default_instance_;
};
// -------------------------------------------------------------------

class UIDescEdit : public ::google::protobuf::Message {
 public:
  UIDescEdit();
  virtual ~UIDescEdit();

  UIDescEdit(const UIDescEdit& from);

  inline UIDescEdit& operator=(const UIDescEdit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIDescEdit& default_instance();

  void Swap(UIDescEdit* other);

  // implements Message ----------------------------------------------

  UIDescEdit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIDescEdit& from);
  void MergeFrom(const UIDescEdit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional .AnselIpc.EditAllowedType allowedType = 3;
  inline bool has_allowedtype() const;
  inline void clear_allowedtype();
  static const int kAllowedTypeFieldNumber = 3;
  inline ::AnselIpc::EditAllowedType allowedtype() const;
  inline void set_allowedtype(::AnselIpc::EditAllowedType value);

  // optional string data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:AnselIpc.UIDescEdit)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_allowedtype();
  inline void clear_has_allowedtype();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* text_;
  ::google::protobuf::int32 id_;
  int allowedtype_;
  ::std::string* data_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UIDescEdit* default_instance_;
};
// -------------------------------------------------------------------

class UIDescBoolean : public ::google::protobuf::Message {
 public:
  UIDescBoolean();
  virtual ~UIDescBoolean();

  UIDescBoolean(const UIDescBoolean& from);

  inline UIDescBoolean& operator=(const UIDescBoolean& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIDescBoolean& default_instance();

  void Swap(UIDescBoolean* other);

  // implements Message ----------------------------------------------

  UIDescBoolean* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIDescBoolean& from);
  void MergeFrom(const UIDescBoolean& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional bool set = 3;
  inline bool has_set() const;
  inline void clear_set();
  static const int kSetFieldNumber = 3;
  inline bool set() const;
  inline void set_set(bool value);

  // @@protoc_insertion_point(class_scope:AnselIpc.UIDescBoolean)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_set();
  inline void clear_has_set();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* text_;
  ::google::protobuf::int32 id_;
  bool set_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UIDescBoolean* default_instance_;
};
// -------------------------------------------------------------------

class UIDescLabel : public ::google::protobuf::Message {
 public:
  UIDescLabel();
  virtual ~UIDescLabel();

  UIDescLabel(const UIDescLabel& from);

  inline UIDescLabel& operator=(const UIDescLabel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIDescLabel& default_instance();

  void Swap(UIDescLabel* other);

  // implements Message ----------------------------------------------

  UIDescLabel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIDescLabel& from);
  void MergeFrom(const UIDescLabel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:AnselIpc.UIDescLabel)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* text_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UIDescLabel* default_instance_;
};
// -------------------------------------------------------------------

class MapFieldEntry : public ::google::protobuf::Message {
 public:
  MapFieldEntry();
  virtual ~MapFieldEntry();

  MapFieldEntry(const MapFieldEntry& from);

  inline MapFieldEntry& operator=(const MapFieldEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapFieldEntry& default_instance();

  void Swap(MapFieldEntry* other);

  // implements Message ----------------------------------------------

  MapFieldEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapFieldEntry& from);
  void MergeFrom(const MapFieldEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline ::google::protobuf::int32 key() const;
  inline void set_key(::google::protobuf::int32 value);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:AnselIpc.MapFieldEntry)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* value_;
  ::google::protobuf::int32 key_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static MapFieldEntry* default_instance_;
};
// -------------------------------------------------------------------

class UIDescList : public ::google::protobuf::Message {
 public:
  UIDescList();
  virtual ~UIDescList();

  UIDescList(const UIDescList& from);

  inline UIDescList& operator=(const UIDescList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIDescList& default_instance();

  void Swap(UIDescList* other);

  // implements Message ----------------------------------------------

  UIDescList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIDescList& from);
  void MergeFrom(const UIDescList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // repeated .AnselIpc.MapFieldEntry values = 3;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 3;
  inline const ::AnselIpc::MapFieldEntry& values(int index) const;
  inline ::AnselIpc::MapFieldEntry* mutable_values(int index);
  inline ::AnselIpc::MapFieldEntry* add_values();
  inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::MapFieldEntry >&
      values() const;
  inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::MapFieldEntry >*
      mutable_values();

  // optional int32 selected = 4;
  inline bool has_selected() const;
  inline void clear_selected();
  static const int kSelectedFieldNumber = 4;
  inline ::google::protobuf::int32 selected() const;
  inline void set_selected(::google::protobuf::int32 value);

  // optional .AnselIpc.ListSelectionType type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::AnselIpc::ListSelectionType type() const;
  inline void set_type(::AnselIpc::ListSelectionType value);

  // @@protoc_insertion_point(class_scope:AnselIpc.UIDescList)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_selected();
  inline void clear_has_selected();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* text_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 selected_;
  ::google::protobuf::RepeatedPtrField< ::AnselIpc::MapFieldEntry > values_;
  int type_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UIDescList* default_instance_;
};
// -------------------------------------------------------------------

class UIDescPulldown : public ::google::protobuf::Message {
 public:
  UIDescPulldown();
  virtual ~UIDescPulldown();

  UIDescPulldown(const UIDescPulldown& from);

  inline UIDescPulldown& operator=(const UIDescPulldown& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIDescPulldown& default_instance();

  void Swap(UIDescPulldown* other);

  // implements Message ----------------------------------------------

  UIDescPulldown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIDescPulldown& from);
  void MergeFrom(const UIDescPulldown& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // repeated int32 controlIdList = 3;
  inline int controlidlist_size() const;
  inline void clear_controlidlist();
  static const int kControlIdListFieldNumber = 3;
  inline ::google::protobuf::int32 controlidlist(int index) const;
  inline void set_controlidlist(int index, ::google::protobuf::int32 value);
  inline void add_controlidlist(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      controlidlist() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_controlidlist();

  // @@protoc_insertion_point(class_scope:AnselIpc.UIDescPulldown)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* text_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > controlidlist_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UIDescPulldown* default_instance_;
};
// -------------------------------------------------------------------

class AddUIElementRequest : public ::google::protobuf::Message {
 public:
  AddUIElementRequest();
  virtual ~AddUIElementRequest();

  AddUIElementRequest(const AddUIElementRequest& from);

  inline AddUIElementRequest& operator=(const AddUIElementRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddUIElementRequest& default_instance();

  enum ControlDescriptionCase {
    kUiDescButton = 4,
    kUiDescSlider = 5,
    kUiDescEdit = 6,
    kUiDescBoolean = 7,
    kUiDescLabel = 8,
    kUiDescList = 9,
    kUiDescPulldown = 10,
    CONTROLDESCRIPTION_NOT_SET = 0,
  };

  void Swap(AddUIElementRequest* other);

  // implements Message ----------------------------------------------

  AddUIElementRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddUIElementRequest& from);
  void MergeFrom(const AddUIElementRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 requestId = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // required .AnselIpc.ControlType controlType = 2;
  inline bool has_controltype() const;
  inline void clear_controltype();
  static const int kControlTypeFieldNumber = 2;
  inline ::AnselIpc::ControlType controltype() const;
  inline void set_controltype(::AnselIpc::ControlType value);

  // optional bool visible = 3;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 3;
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional .AnselIpc.UIDescButton uiDescButton = 4;
  inline bool has_uidescbutton() const;
  inline void clear_uidescbutton();
  static const int kUiDescButtonFieldNumber = 4;
  inline const ::AnselIpc::UIDescButton& uidescbutton() const;
  inline ::AnselIpc::UIDescButton* mutable_uidescbutton();
  inline ::AnselIpc::UIDescButton* release_uidescbutton();
  inline void set_allocated_uidescbutton(::AnselIpc::UIDescButton* uidescbutton);

  // optional .AnselIpc.UIDescSlider uiDescSlider = 5;
  inline bool has_uidescslider() const;
  inline void clear_uidescslider();
  static const int kUiDescSliderFieldNumber = 5;
  inline const ::AnselIpc::UIDescSlider& uidescslider() const;
  inline ::AnselIpc::UIDescSlider* mutable_uidescslider();
  inline ::AnselIpc::UIDescSlider* release_uidescslider();
  inline void set_allocated_uidescslider(::AnselIpc::UIDescSlider* uidescslider);

  // optional .AnselIpc.UIDescEdit uiDescEdit = 6;
  inline bool has_uidescedit() const;
  inline void clear_uidescedit();
  static const int kUiDescEditFieldNumber = 6;
  inline const ::AnselIpc::UIDescEdit& uidescedit() const;
  inline ::AnselIpc::UIDescEdit* mutable_uidescedit();
  inline ::AnselIpc::UIDescEdit* release_uidescedit();
  inline void set_allocated_uidescedit(::AnselIpc::UIDescEdit* uidescedit);

  // optional .AnselIpc.UIDescBoolean uiDescBoolean = 7;
  inline bool has_uidescboolean() const;
  inline void clear_uidescboolean();
  static const int kUiDescBooleanFieldNumber = 7;
  inline const ::AnselIpc::UIDescBoolean& uidescboolean() const;
  inline ::AnselIpc::UIDescBoolean* mutable_uidescboolean();
  inline ::AnselIpc::UIDescBoolean* release_uidescboolean();
  inline void set_allocated_uidescboolean(::AnselIpc::UIDescBoolean* uidescboolean);

  // optional .AnselIpc.UIDescLabel uiDescLabel = 8;
  inline bool has_uidesclabel() const;
  inline void clear_uidesclabel();
  static const int kUiDescLabelFieldNumber = 8;
  inline const ::AnselIpc::UIDescLabel& uidesclabel() const;
  inline ::AnselIpc::UIDescLabel* mutable_uidesclabel();
  inline ::AnselIpc::UIDescLabel* release_uidesclabel();
  inline void set_allocated_uidesclabel(::AnselIpc::UIDescLabel* uidesclabel);

  // optional .AnselIpc.UIDescList uiDescList = 9;
  inline bool has_uidesclist() const;
  inline void clear_uidesclist();
  static const int kUiDescListFieldNumber = 9;
  inline const ::AnselIpc::UIDescList& uidesclist() const;
  inline ::AnselIpc::UIDescList* mutable_uidesclist();
  inline ::AnselIpc::UIDescList* release_uidesclist();
  inline void set_allocated_uidesclist(::AnselIpc::UIDescList* uidesclist);

  // optional .AnselIpc.UIDescPulldown uiDescPulldown = 10;
  inline bool has_uidescpulldown() const;
  inline void clear_uidescpulldown();
  static const int kUiDescPulldownFieldNumber = 10;
  inline const ::AnselIpc::UIDescPulldown& uidescpulldown() const;
  inline ::AnselIpc::UIDescPulldown* mutable_uidescpulldown();
  inline ::AnselIpc::UIDescPulldown* release_uidescpulldown();
  inline void set_allocated_uidescpulldown(::AnselIpc::UIDescPulldown* uidescpulldown);

  inline ControlDescriptionCase controlDescription_case() const;
  // @@protoc_insertion_point(class_scope:AnselIpc.AddUIElementRequest)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_controltype();
  inline void clear_has_controltype();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_uidescbutton();
  inline void set_has_uidescslider();
  inline void set_has_uidescedit();
  inline void set_has_uidescboolean();
  inline void set_has_uidesclabel();
  inline void set_has_uidesclist();
  inline void set_has_uidescpulldown();

  inline bool has_controlDescription();
  void clear_controlDescription();
  inline void clear_has_controlDescription();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 requestid_;
  int controltype_;
  bool visible_;
  union ControlDescriptionUnion {
    ::AnselIpc::UIDescButton* uidescbutton_;
    ::AnselIpc::UIDescSlider* uidescslider_;
    ::AnselIpc::UIDescEdit* uidescedit_;
    ::AnselIpc::UIDescBoolean* uidescboolean_;
    ::AnselIpc::UIDescLabel* uidesclabel_;
    ::AnselIpc::UIDescList* uidesclist_;
    ::AnselIpc::UIDescPulldown* uidescpulldown_;
  } controlDescription_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static AddUIElementRequest* default_instance_;
};
// -------------------------------------------------------------------

class AddUIElementResponse : public ::google::protobuf::Message {
 public:
  AddUIElementResponse();
  virtual ~AddUIElementResponse();

  AddUIElementResponse(const AddUIElementResponse& from);

  inline AddUIElementResponse& operator=(const AddUIElementResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddUIElementResponse& default_instance();

  enum ControlDescriptionCase {
    kUiDescButton = 3,
    kUiDescSlider = 4,
    kUiDescEdit = 5,
    kUiDescBoolean = 6,
    kUiDescLabel = 7,
    kUiDescList = 8,
    kUiDescPulldown = 9,
    CONTROLDESCRIPTION_NOT_SET = 0,
  };

  void Swap(AddUIElementResponse* other);

  // implements Message ----------------------------------------------

  AddUIElementResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddUIElementResponse& from);
  void MergeFrom(const AddUIElementResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 requestId = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // required .AnselIpc.Status status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // optional .AnselIpc.UIDescButton uiDescButton = 3;
  inline bool has_uidescbutton() const;
  inline void clear_uidescbutton();
  static const int kUiDescButtonFieldNumber = 3;
  inline const ::AnselIpc::UIDescButton& uidescbutton() const;
  inline ::AnselIpc::UIDescButton* mutable_uidescbutton();
  inline ::AnselIpc::UIDescButton* release_uidescbutton();
  inline void set_allocated_uidescbutton(::AnselIpc::UIDescButton* uidescbutton);

  // optional .AnselIpc.UIDescSlider uiDescSlider = 4;
  inline bool has_uidescslider() const;
  inline void clear_uidescslider();
  static const int kUiDescSliderFieldNumber = 4;
  inline const ::AnselIpc::UIDescSlider& uidescslider() const;
  inline ::AnselIpc::UIDescSlider* mutable_uidescslider();
  inline ::AnselIpc::UIDescSlider* release_uidescslider();
  inline void set_allocated_uidescslider(::AnselIpc::UIDescSlider* uidescslider);

  // optional .AnselIpc.UIDescEdit uiDescEdit = 5;
  inline bool has_uidescedit() const;
  inline void clear_uidescedit();
  static const int kUiDescEditFieldNumber = 5;
  inline const ::AnselIpc::UIDescEdit& uidescedit() const;
  inline ::AnselIpc::UIDescEdit* mutable_uidescedit();
  inline ::AnselIpc::UIDescEdit* release_uidescedit();
  inline void set_allocated_uidescedit(::AnselIpc::UIDescEdit* uidescedit);

  // optional .AnselIpc.UIDescBoolean uiDescBoolean = 6;
  inline bool has_uidescboolean() const;
  inline void clear_uidescboolean();
  static const int kUiDescBooleanFieldNumber = 6;
  inline const ::AnselIpc::UIDescBoolean& uidescboolean() const;
  inline ::AnselIpc::UIDescBoolean* mutable_uidescboolean();
  inline ::AnselIpc::UIDescBoolean* release_uidescboolean();
  inline void set_allocated_uidescboolean(::AnselIpc::UIDescBoolean* uidescboolean);

  // optional .AnselIpc.UIDescLabel uiDescLabel = 7;
  inline bool has_uidesclabel() const;
  inline void clear_uidesclabel();
  static const int kUiDescLabelFieldNumber = 7;
  inline const ::AnselIpc::UIDescLabel& uidesclabel() const;
  inline ::AnselIpc::UIDescLabel* mutable_uidesclabel();
  inline ::AnselIpc::UIDescLabel* release_uidesclabel();
  inline void set_allocated_uidesclabel(::AnselIpc::UIDescLabel* uidesclabel);

  // optional .AnselIpc.UIDescList uiDescList = 8;
  inline bool has_uidesclist() const;
  inline void clear_uidesclist();
  static const int kUiDescListFieldNumber = 8;
  inline const ::AnselIpc::UIDescList& uidesclist() const;
  inline ::AnselIpc::UIDescList* mutable_uidesclist();
  inline ::AnselIpc::UIDescList* release_uidesclist();
  inline void set_allocated_uidesclist(::AnselIpc::UIDescList* uidesclist);

  // optional .AnselIpc.UIDescPulldown uiDescPulldown = 9;
  inline bool has_uidescpulldown() const;
  inline void clear_uidescpulldown();
  static const int kUiDescPulldownFieldNumber = 9;
  inline const ::AnselIpc::UIDescPulldown& uidescpulldown() const;
  inline ::AnselIpc::UIDescPulldown* mutable_uidescpulldown();
  inline ::AnselIpc::UIDescPulldown* release_uidescpulldown();
  inline void set_allocated_uidescpulldown(::AnselIpc::UIDescPulldown* uidescpulldown);

  inline ControlDescriptionCase controlDescription_case() const;
  // @@protoc_insertion_point(class_scope:AnselIpc.AddUIElementResponse)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_uidescbutton();
  inline void set_has_uidescslider();
  inline void set_has_uidescedit();
  inline void set_has_uidescboolean();
  inline void set_has_uidesclabel();
  inline void set_has_uidesclist();
  inline void set_has_uidescpulldown();

  inline bool has_controlDescription();
  void clear_controlDescription();
  inline void clear_has_controlDescription();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 requestid_;
  int status_;
  union ControlDescriptionUnion {
    ::AnselIpc::UIDescButton* uidescbutton_;
    ::AnselIpc::UIDescSlider* uidescslider_;
    ::AnselIpc::UIDescEdit* uidescedit_;
    ::AnselIpc::UIDescBoolean* uidescboolean_;
    ::AnselIpc::UIDescLabel* uidesclabel_;
    ::AnselIpc::UIDescList* uidesclist_;
    ::AnselIpc::UIDescPulldown* uidescpulldown_;
  } controlDescription_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static AddUIElementResponse* default_instance_;
};
// -------------------------------------------------------------------

class UIControlChangedRequest : public ::google::protobuf::Message {
 public:
  UIControlChangedRequest();
  virtual ~UIControlChangedRequest();

  UIControlChangedRequest(const UIControlChangedRequest& from);

  inline UIControlChangedRequest& operator=(const UIControlChangedRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIControlChangedRequest& default_instance();

  enum ControlDescriptionCase {
    kUiDescButton = 3,
    kUiDescSlider = 4,
    kUiDescEdit = 5,
    kUiDescBoolean = 6,
    kUiDescLabel = 7,
    kUiDescList = 8,
    CONTROLDESCRIPTION_NOT_SET = 0,
  };

  void Swap(UIControlChangedRequest* other);

  // implements Message ----------------------------------------------

  UIControlChangedRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIControlChangedRequest& from);
  void MergeFrom(const UIControlChangedRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .AnselIpc.UIDescButton uiDescButton = 3;
  inline bool has_uidescbutton() const;
  inline void clear_uidescbutton();
  static const int kUiDescButtonFieldNumber = 3;
  inline const ::AnselIpc::UIDescButton& uidescbutton() const;
  inline ::AnselIpc::UIDescButton* mutable_uidescbutton();
  inline ::AnselIpc::UIDescButton* release_uidescbutton();
  inline void set_allocated_uidescbutton(::AnselIpc::UIDescButton* uidescbutton);

  // optional .AnselIpc.UIDescSlider uiDescSlider = 4;
  inline bool has_uidescslider() const;
  inline void clear_uidescslider();
  static const int kUiDescSliderFieldNumber = 4;
  inline const ::AnselIpc::UIDescSlider& uidescslider() const;
  inline ::AnselIpc::UIDescSlider* mutable_uidescslider();
  inline ::AnselIpc::UIDescSlider* release_uidescslider();
  inline void set_allocated_uidescslider(::AnselIpc::UIDescSlider* uidescslider);

  // optional .AnselIpc.UIDescEdit uiDescEdit = 5;
  inline bool has_uidescedit() const;
  inline void clear_uidescedit();
  static const int kUiDescEditFieldNumber = 5;
  inline const ::AnselIpc::UIDescEdit& uidescedit() const;
  inline ::AnselIpc::UIDescEdit* mutable_uidescedit();
  inline ::AnselIpc::UIDescEdit* release_uidescedit();
  inline void set_allocated_uidescedit(::AnselIpc::UIDescEdit* uidescedit);

  // optional .AnselIpc.UIDescBoolean uiDescBoolean = 6;
  inline bool has_uidescboolean() const;
  inline void clear_uidescboolean();
  static const int kUiDescBooleanFieldNumber = 6;
  inline const ::AnselIpc::UIDescBoolean& uidescboolean() const;
  inline ::AnselIpc::UIDescBoolean* mutable_uidescboolean();
  inline ::AnselIpc::UIDescBoolean* release_uidescboolean();
  inline void set_allocated_uidescboolean(::AnselIpc::UIDescBoolean* uidescboolean);

  // optional .AnselIpc.UIDescLabel uiDescLabel = 7;
  inline bool has_uidesclabel() const;
  inline void clear_uidesclabel();
  static const int kUiDescLabelFieldNumber = 7;
  inline const ::AnselIpc::UIDescLabel& uidesclabel() const;
  inline ::AnselIpc::UIDescLabel* mutable_uidesclabel();
  inline ::AnselIpc::UIDescLabel* release_uidesclabel();
  inline void set_allocated_uidesclabel(::AnselIpc::UIDescLabel* uidesclabel);

  // optional .AnselIpc.UIDescList uiDescList = 8;
  inline bool has_uidesclist() const;
  inline void clear_uidesclist();
  static const int kUiDescListFieldNumber = 8;
  inline const ::AnselIpc::UIDescList& uidesclist() const;
  inline ::AnselIpc::UIDescList* mutable_uidesclist();
  inline ::AnselIpc::UIDescList* release_uidesclist();
  inline void set_allocated_uidesclist(::AnselIpc::UIDescList* uidesclist);

  inline ControlDescriptionCase controlDescription_case() const;
  // @@protoc_insertion_point(class_scope:AnselIpc.UIControlChangedRequest)
 private:
  inline void set_has_uidescbutton();
  inline void set_has_uidescslider();
  inline void set_has_uidescedit();
  inline void set_has_uidescboolean();
  inline void set_has_uidesclabel();
  inline void set_has_uidesclist();

  inline bool has_controlDescription();
  void clear_controlDescription();
  inline void clear_has_controlDescription();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union ControlDescriptionUnion {
    ::AnselIpc::UIDescButton* uidescbutton_;
    ::AnselIpc::UIDescSlider* uidescslider_;
    ::AnselIpc::UIDescEdit* uidescedit_;
    ::AnselIpc::UIDescBoolean* uidescboolean_;
    ::AnselIpc::UIDescLabel* uidesclabel_;
    ::AnselIpc::UIDescList* uidesclist_;
  } controlDescription_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UIControlChangedRequest* default_instance_;
};
// -------------------------------------------------------------------

class UIControlChangedResponse : public ::google::protobuf::Message {
 public:
  UIControlChangedResponse();
  virtual ~UIControlChangedResponse();

  UIControlChangedResponse(const UIControlChangedResponse& from);

  inline UIControlChangedResponse& operator=(const UIControlChangedResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIControlChangedResponse& default_instance();

  void Swap(UIControlChangedResponse* other);

  // implements Message ----------------------------------------------

  UIControlChangedResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIControlChangedResponse& from);
  void MergeFrom(const UIControlChangedResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.UIControlChangedResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UIControlChangedResponse* default_instance_;
};
// -------------------------------------------------------------------

class UIControlRemoveAllRequest : public ::google::protobuf::Message {
 public:
  UIControlRemoveAllRequest();
  virtual ~UIControlRemoveAllRequest();

  UIControlRemoveAllRequest(const UIControlRemoveAllRequest& from);

  inline UIControlRemoveAllRequest& operator=(const UIControlRemoveAllRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIControlRemoveAllRequest& default_instance();

  void Swap(UIControlRemoveAllRequest* other);

  // implements Message ----------------------------------------------

  UIControlRemoveAllRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIControlRemoveAllRequest& from);
  void MergeFrom(const UIControlRemoveAllRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.UIControlRemoveAllRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UIControlRemoveAllRequest* default_instance_;
};
// -------------------------------------------------------------------

class UIControlRemoveAllResponse : public ::google::protobuf::Message {
 public:
  UIControlRemoveAllResponse();
  virtual ~UIControlRemoveAllResponse();

  UIControlRemoveAllResponse(const UIControlRemoveAllResponse& from);

  inline UIControlRemoveAllResponse& operator=(const UIControlRemoveAllResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIControlRemoveAllResponse& default_instance();

  void Swap(UIControlRemoveAllResponse* other);

  // implements Message ----------------------------------------------

  UIControlRemoveAllResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIControlRemoveAllResponse& from);
  void MergeFrom(const UIControlRemoveAllResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.UIControlRemoveAllResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UIControlRemoveAllResponse* default_instance_;
};
// -------------------------------------------------------------------

class UIControlRemoveRequest : public ::google::protobuf::Message {
 public:
  UIControlRemoveRequest();
  virtual ~UIControlRemoveRequest();

  UIControlRemoveRequest(const UIControlRemoveRequest& from);

  inline UIControlRemoveRequest& operator=(const UIControlRemoveRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIControlRemoveRequest& default_instance();

  void Swap(UIControlRemoveRequest* other);

  // implements Message ----------------------------------------------

  UIControlRemoveRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIControlRemoveRequest& from);
  void MergeFrom(const UIControlRemoveRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 id = 1;
  inline int id_size() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id(int index) const;
  inline void set_id(int index, ::google::protobuf::int32 value);
  inline void add_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_id();

  // @@protoc_insertion_point(class_scope:AnselIpc.UIControlRemoveRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > id_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UIControlRemoveRequest* default_instance_;
};
// -------------------------------------------------------------------

class UIControlRemoveResponse : public ::google::protobuf::Message {
 public:
  UIControlRemoveResponse();
  virtual ~UIControlRemoveResponse();

  UIControlRemoveResponse(const UIControlRemoveResponse& from);

  inline UIControlRemoveResponse& operator=(const UIControlRemoveResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIControlRemoveResponse& default_instance();

  void Swap(UIControlRemoveResponse* other);

  // implements Message ----------------------------------------------

  UIControlRemoveResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIControlRemoveResponse& from);
  void MergeFrom(const UIControlRemoveResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.UIControlRemoveResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UIControlRemoveResponse* default_instance_;
};
// -------------------------------------------------------------------

class UIControlSetVisibilityRequest : public ::google::protobuf::Message {
 public:
  UIControlSetVisibilityRequest();
  virtual ~UIControlSetVisibilityRequest();

  UIControlSetVisibilityRequest(const UIControlSetVisibilityRequest& from);

  inline UIControlSetVisibilityRequest& operator=(const UIControlSetVisibilityRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIControlSetVisibilityRequest& default_instance();

  void Swap(UIControlSetVisibilityRequest* other);

  // implements Message ----------------------------------------------

  UIControlSetVisibilityRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIControlSetVisibilityRequest& from);
  void MergeFrom(const UIControlSetVisibilityRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required bool visible = 2;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 2;
  inline bool visible() const;
  inline void set_visible(bool value);

  // @@protoc_insertion_point(class_scope:AnselIpc.UIControlSetVisibilityRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_visible();
  inline void clear_has_visible();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  bool visible_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UIControlSetVisibilityRequest* default_instance_;
};
// -------------------------------------------------------------------

class UIControlSetVisibilityResponse : public ::google::protobuf::Message {
 public:
  UIControlSetVisibilityResponse();
  virtual ~UIControlSetVisibilityResponse();

  UIControlSetVisibilityResponse(const UIControlSetVisibilityResponse& from);

  inline UIControlSetVisibilityResponse& operator=(const UIControlSetVisibilityResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIControlSetVisibilityResponse& default_instance();

  void Swap(UIControlSetVisibilityResponse* other);

  // implements Message ----------------------------------------------

  UIControlSetVisibilityResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIControlSetVisibilityResponse& from);
  void MergeFrom(const UIControlSetVisibilityResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.UIControlSetVisibilityResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UIControlSetVisibilityResponse* default_instance_;
};
// -------------------------------------------------------------------

class UIControlGetVisibilityRequest : public ::google::protobuf::Message {
 public:
  UIControlGetVisibilityRequest();
  virtual ~UIControlGetVisibilityRequest();

  UIControlGetVisibilityRequest(const UIControlGetVisibilityRequest& from);

  inline UIControlGetVisibilityRequest& operator=(const UIControlGetVisibilityRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIControlGetVisibilityRequest& default_instance();

  void Swap(UIControlGetVisibilityRequest* other);

  // implements Message ----------------------------------------------

  UIControlGetVisibilityRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIControlGetVisibilityRequest& from);
  void MergeFrom(const UIControlGetVisibilityRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AnselIpc.UIControlGetVisibilityRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UIControlGetVisibilityRequest* default_instance_;
};
// -------------------------------------------------------------------

class UIControlGetVisibilityResponse : public ::google::protobuf::Message {
 public:
  UIControlGetVisibilityResponse();
  virtual ~UIControlGetVisibilityResponse();

  UIControlGetVisibilityResponse(const UIControlGetVisibilityResponse& from);

  inline UIControlGetVisibilityResponse& operator=(const UIControlGetVisibilityResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIControlGetVisibilityResponse& default_instance();

  void Swap(UIControlGetVisibilityResponse* other);

  // implements Message ----------------------------------------------

  UIControlGetVisibilityResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIControlGetVisibilityResponse& from);
  void MergeFrom(const UIControlGetVisibilityResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool visible = 1;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 1;
  inline bool visible() const;
  inline void set_visible(bool value);

  // @@protoc_insertion_point(class_scope:AnselIpc.UIControlGetVisibilityResponse)
 private:
  inline void set_has_visible();
  inline void clear_has_visible();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool visible_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UIControlGetVisibilityResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetGameSpecificControlsRequest : public ::google::protobuf::Message {
 public:
  GetGameSpecificControlsRequest();
  virtual ~GetGameSpecificControlsRequest();

  GetGameSpecificControlsRequest(const GetGameSpecificControlsRequest& from);

  inline GetGameSpecificControlsRequest& operator=(const GetGameSpecificControlsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetGameSpecificControlsRequest& default_instance();

  void Swap(GetGameSpecificControlsRequest* other);

  // implements Message ----------------------------------------------

  GetGameSpecificControlsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetGameSpecificControlsRequest& from);
  void MergeFrom(const GetGameSpecificControlsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.GetGameSpecificControlsRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetGameSpecificControlsRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetSettingsRequest : public ::google::protobuf::Message {
 public:
  GetSettingsRequest();
  virtual ~GetSettingsRequest();

  GetSettingsRequest(const GetSettingsRequest& from);

  inline GetSettingsRequest& operator=(const GetSettingsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSettingsRequest& default_instance();

  void Swap(GetSettingsRequest* other);

  // implements Message ----------------------------------------------

  GetSettingsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSettingsRequest& from);
  void MergeFrom(const GetSettingsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.GetSettingsRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetSettingsRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetSettingsResponse_Setting : public ::google::protobuf::Message {
 public:
  GetSettingsResponse_Setting();
  virtual ~GetSettingsResponse_Setting();

  GetSettingsResponse_Setting(const GetSettingsResponse_Setting& from);

  inline GetSettingsResponse_Setting& operator=(const GetSettingsResponse_Setting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSettingsResponse_Setting& default_instance();

  void Swap(GetSettingsResponse_Setting* other);

  // implements Message ----------------------------------------------

  GetSettingsResponse_Setting* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSettingsResponse_Setting& from);
  void MergeFrom(const GetSettingsResponse_Setting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:AnselIpc.GetSettingsResponse.Setting)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetSettingsResponse_Setting* default_instance_;
};
// -------------------------------------------------------------------

class GetSettingsResponse : public ::google::protobuf::Message {
 public:
  GetSettingsResponse();
  virtual ~GetSettingsResponse();

  GetSettingsResponse(const GetSettingsResponse& from);

  inline GetSettingsResponse& operator=(const GetSettingsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSettingsResponse& default_instance();

  void Swap(GetSettingsResponse* other);

  // implements Message ----------------------------------------------

  GetSettingsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSettingsResponse& from);
  void MergeFrom(const GetSettingsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GetSettingsResponse_Setting Setting;

  // accessors -------------------------------------------------------

  // repeated .AnselIpc.GetSettingsResponse.Setting settings = 1;
  inline int settings_size() const;
  inline void clear_settings();
  static const int kSettingsFieldNumber = 1;
  inline const ::AnselIpc::GetSettingsResponse_Setting& settings(int index) const;
  inline ::AnselIpc::GetSettingsResponse_Setting* mutable_settings(int index);
  inline ::AnselIpc::GetSettingsResponse_Setting* add_settings();
  inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::GetSettingsResponse_Setting >&
      settings() const;
  inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::GetSettingsResponse_Setting >*
      mutable_settings();

  // @@protoc_insertion_point(class_scope:AnselIpc.GetSettingsResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::AnselIpc::GetSettingsResponse_Setting > settings_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetSettingsResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetFeatureSetRequest : public ::google::protobuf::Message {
 public:
  GetFeatureSetRequest();
  virtual ~GetFeatureSetRequest();

  GetFeatureSetRequest(const GetFeatureSetRequest& from);

  inline GetFeatureSetRequest& operator=(const GetFeatureSetRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFeatureSetRequest& default_instance();

  void Swap(GetFeatureSetRequest* other);

  // implements Message ----------------------------------------------

  GetFeatureSetRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFeatureSetRequest& from);
  void MergeFrom(const GetFeatureSetRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .AnselIpc.IpcVersionResponse requestorsIPCVersion = 1;
  inline bool has_requestorsipcversion() const;
  inline void clear_requestorsipcversion();
  static const int kRequestorsIPCVersionFieldNumber = 1;
  inline const ::AnselIpc::IpcVersionResponse& requestorsipcversion() const;
  inline ::AnselIpc::IpcVersionResponse* mutable_requestorsipcversion();
  inline ::AnselIpc::IpcVersionResponse* release_requestorsipcversion();
  inline void set_allocated_requestorsipcversion(::AnselIpc::IpcVersionResponse* requestorsipcversion);

  // @@protoc_insertion_point(class_scope:AnselIpc.GetFeatureSetRequest)
 private:
  inline void set_has_requestorsipcversion();
  inline void clear_has_requestorsipcversion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::AnselIpc::IpcVersionResponse* requestorsipcversion_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetFeatureSetRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetFeatureSetResponse : public ::google::protobuf::Message {
 public:
  GetFeatureSetResponse();
  virtual ~GetFeatureSetResponse();

  GetFeatureSetResponse(const GetFeatureSetResponse& from);

  inline GetFeatureSetResponse& operator=(const GetFeatureSetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFeatureSetResponse& default_instance();

  void Swap(GetFeatureSetResponse* other);

  // implements Message ----------------------------------------------

  GetFeatureSetResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFeatureSetResponse& from);
  void MergeFrom(const GetFeatureSetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool sdkDetected = 1;
  inline bool has_sdkdetected() const;
  inline void clear_sdkdetected();
  static const int kSdkDetectedFieldNumber = 1;
  inline bool sdkdetected() const;
  inline void set_sdkdetected(bool value);

  // required bool modsAvailable = 2;
  inline bool has_modsavailable() const;
  inline void clear_modsavailable();
  static const int kModsAvailableFieldNumber = 2;
  inline bool modsavailable() const;
  inline void set_modsavailable(bool value);

  // required bool restyleAvailable = 3;
  inline bool has_restyleavailable() const;
  inline void clear_restyleavailable();
  static const int kRestyleAvailableFieldNumber = 3;
  inline bool restyleavailable() const;
  inline void set_restyleavailable(bool value);

  // optional bool allowOffline = 4;
  inline bool has_allowoffline() const;
  inline void clear_allowoffline();
  static const int kAllowOfflineFieldNumber = 4;
  inline bool allowoffline() const;
  inline void set_allowoffline(bool value);

  // @@protoc_insertion_point(class_scope:AnselIpc.GetFeatureSetResponse)
 private:
  inline void set_has_sdkdetected();
  inline void clear_has_sdkdetected();
  inline void set_has_modsavailable();
  inline void clear_has_modsavailable();
  inline void set_has_restyleavailable();
  inline void clear_has_restyleavailable();
  inline void set_has_allowoffline();
  inline void clear_has_allowoffline();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool sdkdetected_;
  bool modsavailable_;
  bool restyleavailable_;
  bool allowoffline_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetFeatureSetResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetCMSInfoRequest : public ::google::protobuf::Message {
 public:
  SetCMSInfoRequest();
  virtual ~SetCMSInfoRequest();

  SetCMSInfoRequest(const SetCMSInfoRequest& from);

  inline SetCMSInfoRequest& operator=(const SetCMSInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetCMSInfoRequest& default_instance();

  void Swap(SetCMSInfoRequest* other);

  // implements Message ----------------------------------------------

  SetCMSInfoRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetCMSInfoRequest& from);
  void MergeFrom(const SetCMSInfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cmsid = 1;
  inline bool has_cmsid() const;
  inline void clear_cmsid();
  static const int kCmsidFieldNumber = 1;
  inline const ::std::string& cmsid() const;
  inline void set_cmsid(const ::std::string& value);
  inline void set_cmsid(const char* value);
  inline void set_cmsid(const char* value, size_t size);
  inline ::std::string* mutable_cmsid();
  inline ::std::string* release_cmsid();
  inline void set_allocated_cmsid(::std::string* cmsid);

  // optional string shortName = 2;
  inline bool has_shortname() const;
  inline void clear_shortname();
  static const int kShortNameFieldNumber = 2;
  inline const ::std::string& shortname() const;
  inline void set_shortname(const ::std::string& value);
  inline void set_shortname(const char* value);
  inline void set_shortname(const char* value, size_t size);
  inline ::std::string* mutable_shortname();
  inline ::std::string* release_shortname();
  inline void set_allocated_shortname(::std::string* shortname);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetCMSInfoRequest)
 private:
  inline void set_has_cmsid();
  inline void clear_has_cmsid();
  inline void set_has_shortname();
  inline void clear_has_shortname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* cmsid_;
  ::std::string* shortname_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetCMSInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetCMSInfoResponse : public ::google::protobuf::Message {
 public:
  SetCMSInfoResponse();
  virtual ~SetCMSInfoResponse();

  SetCMSInfoResponse(const SetCMSInfoResponse& from);

  inline SetCMSInfoResponse& operator=(const SetCMSInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetCMSInfoResponse& default_instance();

  void Swap(SetCMSInfoResponse* other);

  // implements Message ----------------------------------------------

  SetCMSInfoResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetCMSInfoResponse& from);
  void MergeFrom(const SetCMSInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetCMSInfoResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetCMSInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetEnabledFeatureSetRequest : public ::google::protobuf::Message {
 public:
  GetEnabledFeatureSetRequest();
  virtual ~GetEnabledFeatureSetRequest();

  GetEnabledFeatureSetRequest(const GetEnabledFeatureSetRequest& from);

  inline GetEnabledFeatureSetRequest& operator=(const GetEnabledFeatureSetRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEnabledFeatureSetRequest& default_instance();

  void Swap(GetEnabledFeatureSetRequest* other);

  // implements Message ----------------------------------------------

  GetEnabledFeatureSetRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetEnabledFeatureSetRequest& from);
  void MergeFrom(const GetEnabledFeatureSetRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.GetEnabledFeatureSetRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetEnabledFeatureSetRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetEnabledFeatureSetResponse : public ::google::protobuf::Message {
 public:
  GetEnabledFeatureSetResponse();
  virtual ~GetEnabledFeatureSetResponse();

  GetEnabledFeatureSetResponse(const GetEnabledFeatureSetResponse& from);

  inline GetEnabledFeatureSetResponse& operator=(const GetEnabledFeatureSetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEnabledFeatureSetResponse& default_instance();

  void Swap(GetEnabledFeatureSetResponse* other);

  // implements Message ----------------------------------------------

  GetEnabledFeatureSetResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetEnabledFeatureSetResponse& from);
  void MergeFrom(const GetEnabledFeatureSetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool modsAvailable = 1;
  inline bool has_modsavailable() const;
  inline void clear_modsavailable();
  static const int kModsAvailableFieldNumber = 1;
  inline bool modsavailable() const;
  inline void set_modsavailable(bool value);

  // @@protoc_insertion_point(class_scope:AnselIpc.GetEnabledFeatureSetResponse)
 private:
  inline void set_has_modsavailable();
  inline void clear_has_modsavailable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool modsavailable_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetEnabledFeatureSetResponse* default_instance_;
};
// -------------------------------------------------------------------

class IsAnselModdingAvailableRequest : public ::google::protobuf::Message {
 public:
  IsAnselModdingAvailableRequest();
  virtual ~IsAnselModdingAvailableRequest();

  IsAnselModdingAvailableRequest(const IsAnselModdingAvailableRequest& from);

  inline IsAnselModdingAvailableRequest& operator=(const IsAnselModdingAvailableRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IsAnselModdingAvailableRequest& default_instance();

  void Swap(IsAnselModdingAvailableRequest* other);

  // implements Message ----------------------------------------------

  IsAnselModdingAvailableRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IsAnselModdingAvailableRequest& from);
  void MergeFrom(const IsAnselModdingAvailableRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.IsAnselModdingAvailableRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static IsAnselModdingAvailableRequest* default_instance_;
};
// -------------------------------------------------------------------

class IsAnselModdingAvailableResponse : public ::google::protobuf::Message {
 public:
  IsAnselModdingAvailableResponse();
  virtual ~IsAnselModdingAvailableResponse();

  IsAnselModdingAvailableResponse(const IsAnselModdingAvailableResponse& from);

  inline IsAnselModdingAvailableResponse& operator=(const IsAnselModdingAvailableResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IsAnselModdingAvailableResponse& default_instance();

  void Swap(IsAnselModdingAvailableResponse* other);

  // implements Message ----------------------------------------------

  IsAnselModdingAvailableResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IsAnselModdingAvailableResponse& from);
  void MergeFrom(const IsAnselModdingAvailableResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.IsAnselModdingAvailableResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static IsAnselModdingAvailableResponse* default_instance_;
};
// -------------------------------------------------------------------

class IsAnselSDKIntegrationAvailableRequest : public ::google::protobuf::Message {
 public:
  IsAnselSDKIntegrationAvailableRequest();
  virtual ~IsAnselSDKIntegrationAvailableRequest();

  IsAnselSDKIntegrationAvailableRequest(const IsAnselSDKIntegrationAvailableRequest& from);

  inline IsAnselSDKIntegrationAvailableRequest& operator=(const IsAnselSDKIntegrationAvailableRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IsAnselSDKIntegrationAvailableRequest& default_instance();

  void Swap(IsAnselSDKIntegrationAvailableRequest* other);

  // implements Message ----------------------------------------------

  IsAnselSDKIntegrationAvailableRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IsAnselSDKIntegrationAvailableRequest& from);
  void MergeFrom(const IsAnselSDKIntegrationAvailableRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.IsAnselSDKIntegrationAvailableRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static IsAnselSDKIntegrationAvailableRequest* default_instance_;
};
// -------------------------------------------------------------------

class IsAnselSDKIntegrationAvailableResponse : public ::google::protobuf::Message {
 public:
  IsAnselSDKIntegrationAvailableResponse();
  virtual ~IsAnselSDKIntegrationAvailableResponse();

  IsAnselSDKIntegrationAvailableResponse(const IsAnselSDKIntegrationAvailableResponse& from);

  inline IsAnselSDKIntegrationAvailableResponse& operator=(const IsAnselSDKIntegrationAvailableResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IsAnselSDKIntegrationAvailableResponse& default_instance();

  void Swap(IsAnselSDKIntegrationAvailableResponse* other);

  // implements Message ----------------------------------------------

  IsAnselSDKIntegrationAvailableResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IsAnselSDKIntegrationAvailableResponse& from);
  void MergeFrom(const IsAnselSDKIntegrationAvailableResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.IsAnselSDKIntegrationAvailableResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static IsAnselSDKIntegrationAvailableResponse* default_instance_;
};
// -------------------------------------------------------------------

class ScreenResolutionChangedRequest : public ::google::protobuf::Message {
 public:
  ScreenResolutionChangedRequest();
  virtual ~ScreenResolutionChangedRequest();

  ScreenResolutionChangedRequest(const ScreenResolutionChangedRequest& from);

  inline ScreenResolutionChangedRequest& operator=(const ScreenResolutionChangedRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScreenResolutionChangedRequest& default_instance();

  void Swap(ScreenResolutionChangedRequest* other);

  // implements Message ----------------------------------------------

  ScreenResolutionChangedRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScreenResolutionChangedRequest& from);
  void MergeFrom(const ScreenResolutionChangedRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.ScreenResolutionChangedRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static ScreenResolutionChangedRequest* default_instance_;
};
// -------------------------------------------------------------------

class ScreenResolutionChangedResponse : public ::google::protobuf::Message {
 public:
  ScreenResolutionChangedResponse();
  virtual ~ScreenResolutionChangedResponse();

  ScreenResolutionChangedResponse(const ScreenResolutionChangedResponse& from);

  inline ScreenResolutionChangedResponse& operator=(const ScreenResolutionChangedResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScreenResolutionChangedResponse& default_instance();

  void Swap(ScreenResolutionChangedResponse* other);

  // implements Message ----------------------------------------------

  ScreenResolutionChangedResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScreenResolutionChangedResponse& from);
  void MergeFrom(const ScreenResolutionChangedResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.ScreenResolutionChangedResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static ScreenResolutionChangedResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetGridOfThirdsEnabledRequest : public ::google::protobuf::Message {
 public:
  SetGridOfThirdsEnabledRequest();
  virtual ~SetGridOfThirdsEnabledRequest();

  SetGridOfThirdsEnabledRequest(const SetGridOfThirdsEnabledRequest& from);

  inline SetGridOfThirdsEnabledRequest& operator=(const SetGridOfThirdsEnabledRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetGridOfThirdsEnabledRequest& default_instance();

  void Swap(SetGridOfThirdsEnabledRequest* other);

  // implements Message ----------------------------------------------

  SetGridOfThirdsEnabledRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetGridOfThirdsEnabledRequest& from);
  void MergeFrom(const SetGridOfThirdsEnabledRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool enabled = 1;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetGridOfThirdsEnabledRequest)
 private:
  inline void set_has_enabled();
  inline void clear_has_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool enabled_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetGridOfThirdsEnabledRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetGridOfThirdsEnabledResponse : public ::google::protobuf::Message {
 public:
  SetGridOfThirdsEnabledResponse();
  virtual ~SetGridOfThirdsEnabledResponse();

  SetGridOfThirdsEnabledResponse(const SetGridOfThirdsEnabledResponse& from);

  inline SetGridOfThirdsEnabledResponse& operator=(const SetGridOfThirdsEnabledResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetGridOfThirdsEnabledResponse& default_instance();

  void Swap(SetGridOfThirdsEnabledResponse* other);

  // implements Message ----------------------------------------------

  SetGridOfThirdsEnabledResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetGridOfThirdsEnabledResponse& from);
  void MergeFrom(const SetGridOfThirdsEnabledResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetGridOfThirdsEnabledResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetGridOfThirdsEnabledResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetProcessInfoRequest : public ::google::protobuf::Message {
 public:
  GetProcessInfoRequest();
  virtual ~GetProcessInfoRequest();

  GetProcessInfoRequest(const GetProcessInfoRequest& from);

  inline GetProcessInfoRequest& operator=(const GetProcessInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetProcessInfoRequest& default_instance();

  void Swap(GetProcessInfoRequest* other);

  // implements Message ----------------------------------------------

  GetProcessInfoRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetProcessInfoRequest& from);
  void MergeFrom(const GetProcessInfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.GetProcessInfoRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetProcessInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetProcessInfoResponse : public ::google::protobuf::Message {
 public:
  GetProcessInfoResponse();
  virtual ~GetProcessInfoResponse();

  GetProcessInfoResponse(const GetProcessInfoResponse& from);

  inline GetProcessInfoResponse& operator=(const GetProcessInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetProcessInfoResponse& default_instance();

  void Swap(GetProcessInfoResponse* other);

  // implements Message ----------------------------------------------

  GetProcessInfoResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetProcessInfoResponse& from);
  void MergeFrom(const GetProcessInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // required uint32 processId = 2;
  inline bool has_processid() const;
  inline void clear_processid();
  static const int kProcessIdFieldNumber = 2;
  inline ::google::protobuf::uint32 processid() const;
  inline void set_processid(::google::protobuf::uint32 value);

  // required string processPath = 3;
  inline bool has_processpath() const;
  inline void clear_processpath();
  static const int kProcessPathFieldNumber = 3;
  inline const ::std::string& processpath() const;
  inline void set_processpath(const ::std::string& value);
  inline void set_processpath(const char* value);
  inline void set_processpath(const char* value, size_t size);
  inline ::std::string* mutable_processpath();
  inline ::std::string* release_processpath();
  inline void set_allocated_processpath(::std::string* processpath);

  // @@protoc_insertion_point(class_scope:AnselIpc.GetProcessInfoResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_processid();
  inline void clear_has_processid();
  inline void set_has_processpath();
  inline void clear_has_processpath();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  ::google::protobuf::uint32 processid_;
  ::std::string* processpath_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetProcessInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetAnselEnabledRequest : public ::google::protobuf::Message {
 public:
  SetAnselEnabledRequest();
  virtual ~SetAnselEnabledRequest();

  SetAnselEnabledRequest(const SetAnselEnabledRequest& from);

  inline SetAnselEnabledRequest& operator=(const SetAnselEnabledRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetAnselEnabledRequest& default_instance();

  void Swap(SetAnselEnabledRequest* other);

  // implements Message ----------------------------------------------

  SetAnselEnabledRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetAnselEnabledRequest& from);
  void MergeFrom(const SetAnselEnabledRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 major = 1;
  inline bool has_major() const;
  inline void clear_major();
  static const int kMajorFieldNumber = 1;
  inline ::google::protobuf::uint32 major() const;
  inline void set_major(::google::protobuf::uint32 value);

  // required uint32 minor = 2;
  inline bool has_minor() const;
  inline void clear_minor();
  static const int kMinorFieldNumber = 2;
  inline ::google::protobuf::uint32 minor() const;
  inline void set_minor(::google::protobuf::uint32 value);

  // required uint32 patch = 3;
  inline bool has_patch() const;
  inline void clear_patch();
  static const int kPatchFieldNumber = 3;
  inline ::google::protobuf::uint32 patch() const;
  inline void set_patch(::google::protobuf::uint32 value);

  // required bool enabled = 4;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 4;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // optional bool leaveFiltersEnabled = 5;
  inline bool has_leavefiltersenabled() const;
  inline void clear_leavefiltersenabled();
  static const int kLeaveFiltersEnabledFieldNumber = 5;
  inline bool leavefiltersenabled() const;
  inline void set_leavefiltersenabled(bool value);

  // optional bool pauseApplication = 6;
  inline bool has_pauseapplication() const;
  inline void clear_pauseapplication();
  static const int kPauseApplicationFieldNumber = 6;
  inline bool pauseapplication() const;
  inline void set_pauseapplication(bool value);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetAnselEnabledRequest)
 private:
  inline void set_has_major();
  inline void clear_has_major();
  inline void set_has_minor();
  inline void clear_has_minor();
  inline void set_has_patch();
  inline void clear_has_patch();
  inline void set_has_enabled();
  inline void clear_has_enabled();
  inline void set_has_leavefiltersenabled();
  inline void clear_has_leavefiltersenabled();
  inline void set_has_pauseapplication();
  inline void clear_has_pauseapplication();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 major_;
  ::google::protobuf::uint32 minor_;
  ::google::protobuf::uint32 patch_;
  bool enabled_;
  bool leavefiltersenabled_;
  bool pauseapplication_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetAnselEnabledRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetAnselEnabledResponse : public ::google::protobuf::Message {
 public:
  SetAnselEnabledResponse();
  virtual ~SetAnselEnabledResponse();

  SetAnselEnabledResponse(const SetAnselEnabledResponse& from);

  inline SetAnselEnabledResponse& operator=(const SetAnselEnabledResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetAnselEnabledResponse& default_instance();

  void Swap(SetAnselEnabledResponse* other);

  // implements Message ----------------------------------------------

  SetAnselEnabledResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetAnselEnabledResponse& from);
  void MergeFrom(const SetAnselEnabledResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetAnselEnabledResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetAnselEnabledResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetAnselEnabledRequest : public ::google::protobuf::Message {
 public:
  GetAnselEnabledRequest();
  virtual ~GetAnselEnabledRequest();

  GetAnselEnabledRequest(const GetAnselEnabledRequest& from);

  inline GetAnselEnabledRequest& operator=(const GetAnselEnabledRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAnselEnabledRequest& default_instance();

  void Swap(GetAnselEnabledRequest* other);

  // implements Message ----------------------------------------------

  GetAnselEnabledRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAnselEnabledRequest& from);
  void MergeFrom(const GetAnselEnabledRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.GetAnselEnabledRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetAnselEnabledRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetAnselEnabledResponse : public ::google::protobuf::Message {
 public:
  GetAnselEnabledResponse();
  virtual ~GetAnselEnabledResponse();

  GetAnselEnabledResponse(const GetAnselEnabledResponse& from);

  inline GetAnselEnabledResponse& operator=(const GetAnselEnabledResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAnselEnabledResponse& default_instance();

  void Swap(GetAnselEnabledResponse* other);

  // implements Message ----------------------------------------------

  GetAnselEnabledResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAnselEnabledResponse& from);
  void MergeFrom(const GetAnselEnabledResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool enabled = 1;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:AnselIpc.GetAnselEnabledResponse)
 private:
  inline void set_has_enabled();
  inline void clear_has_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool enabled_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetAnselEnabledResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetAnselShotPermissionsRequest : public ::google::protobuf::Message {
 public:
  GetAnselShotPermissionsRequest();
  virtual ~GetAnselShotPermissionsRequest();

  GetAnselShotPermissionsRequest(const GetAnselShotPermissionsRequest& from);

  inline GetAnselShotPermissionsRequest& operator=(const GetAnselShotPermissionsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAnselShotPermissionsRequest& default_instance();

  void Swap(GetAnselShotPermissionsRequest* other);

  // implements Message ----------------------------------------------

  GetAnselShotPermissionsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAnselShotPermissionsRequest& from);
  void MergeFrom(const GetAnselShotPermissionsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.GetAnselShotPermissionsRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetAnselShotPermissionsRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetAnselShotPermissionsResponse : public ::google::protobuf::Message {
 public:
  GetAnselShotPermissionsResponse();
  virtual ~GetAnselShotPermissionsResponse();

  GetAnselShotPermissionsResponse(const GetAnselShotPermissionsResponse& from);

  inline GetAnselShotPermissionsResponse& operator=(const GetAnselShotPermissionsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAnselShotPermissionsResponse& default_instance();

  void Swap(GetAnselShotPermissionsResponse* other);

  // implements Message ----------------------------------------------

  GetAnselShotPermissionsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAnselShotPermissionsResponse& from);
  void MergeFrom(const GetAnselShotPermissionsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool isIntegrationDetected = 1;
  inline bool has_isintegrationdetected() const;
  inline void clear_isintegrationdetected();
  static const int kIsIntegrationDetectedFieldNumber = 1;
  inline bool isintegrationdetected() const;
  inline void set_isintegrationdetected(bool value);

  // required bool isHDRAllowed = 2;
  inline bool has_ishdrallowed() const;
  inline void clear_ishdrallowed();
  static const int kIsHDRAllowedFieldNumber = 2;
  inline bool ishdrallowed() const;
  inline void set_ishdrallowed(bool value);

  // repeated bool isShotAllowed = 3;
  inline int isshotallowed_size() const;
  inline void clear_isshotallowed();
  static const int kIsShotAllowedFieldNumber = 3;
  inline bool isshotallowed(int index) const;
  inline void set_isshotallowed(int index, bool value);
  inline void add_isshotallowed(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      isshotallowed() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_isshotallowed();

  // @@protoc_insertion_point(class_scope:AnselIpc.GetAnselShotPermissionsResponse)
 private:
  inline void set_has_isintegrationdetected();
  inline void clear_has_isintegrationdetected();
  inline void set_has_ishdrallowed();
  inline void clear_has_ishdrallowed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< bool > isshotallowed_;
  bool isintegrationdetected_;
  bool ishdrallowed_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetAnselShotPermissionsResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetLangIdRequest : public ::google::protobuf::Message {
 public:
  SetLangIdRequest();
  virtual ~SetLangIdRequest();

  SetLangIdRequest(const SetLangIdRequest& from);

  inline SetLangIdRequest& operator=(const SetLangIdRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetLangIdRequest& default_instance();

  void Swap(SetLangIdRequest* other);

  // implements Message ----------------------------------------------

  SetLangIdRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetLangIdRequest& from);
  void MergeFrom(const SetLangIdRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 lang = 1;
  inline bool has_lang() const;
  inline void clear_lang();
  static const int kLangFieldNumber = 1;
  inline ::google::protobuf::int32 lang() const;
  inline void set_lang(::google::protobuf::int32 value);

  // required int32 subLang = 2;
  inline bool has_sublang() const;
  inline void clear_sublang();
  static const int kSubLangFieldNumber = 2;
  inline ::google::protobuf::int32 sublang() const;
  inline void set_sublang(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetLangIdRequest)
 private:
  inline void set_has_lang();
  inline void clear_has_lang();
  inline void set_has_sublang();
  inline void clear_has_sublang();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 lang_;
  ::google::protobuf::int32 sublang_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetLangIdRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetLangIdResponse : public ::google::protobuf::Message {
 public:
  SetLangIdResponse();
  virtual ~SetLangIdResponse();

  SetLangIdResponse(const SetLangIdResponse& from);

  inline SetLangIdResponse& operator=(const SetLangIdResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetLangIdResponse& default_instance();

  void Swap(SetLangIdResponse* other);

  // implements Message ----------------------------------------------

  SetLangIdResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetLangIdResponse& from);
  void MergeFrom(const SetLangIdResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetLangIdResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetLangIdResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetFOVRangeRequest : public ::google::protobuf::Message {
 public:
  GetFOVRangeRequest();
  virtual ~GetFOVRangeRequest();

  GetFOVRangeRequest(const GetFOVRangeRequest& from);

  inline GetFOVRangeRequest& operator=(const GetFOVRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFOVRangeRequest& default_instance();

  void Swap(GetFOVRangeRequest* other);

  // implements Message ----------------------------------------------

  GetFOVRangeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFOVRangeRequest& from);
  void MergeFrom(const GetFOVRangeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.GetFOVRangeRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetFOVRangeRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetFOVRangeResponse : public ::google::protobuf::Message {
 public:
  GetFOVRangeResponse();
  virtual ~GetFOVRangeResponse();

  GetFOVRangeResponse(const GetFOVRangeResponse& from);

  inline GetFOVRangeResponse& operator=(const GetFOVRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFOVRangeResponse& default_instance();

  void Swap(GetFOVRangeResponse* other);

  // implements Message ----------------------------------------------

  GetFOVRangeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFOVRangeResponse& from);
  void MergeFrom(const GetFOVRangeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float minFov = 1;
  inline bool has_minfov() const;
  inline void clear_minfov();
  static const int kMinFovFieldNumber = 1;
  inline float minfov() const;
  inline void set_minfov(float value);

  // required float maxFov = 2;
  inline bool has_maxfov() const;
  inline void clear_maxfov();
  static const int kMaxFovFieldNumber = 2;
  inline float maxfov() const;
  inline void set_maxfov(float value);

  // @@protoc_insertion_point(class_scope:AnselIpc.GetFOVRangeResponse)
 private:
  inline void set_has_minfov();
  inline void clear_has_minfov();
  inline void set_has_maxfov();
  inline void clear_has_maxfov();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float minfov_;
  float maxfov_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetFOVRangeResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetFOVRequest : public ::google::protobuf::Message {
 public:
  SetFOVRequest();
  virtual ~SetFOVRequest();

  SetFOVRequest(const SetFOVRequest& from);

  inline SetFOVRequest& operator=(const SetFOVRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetFOVRequest& default_instance();

  void Swap(SetFOVRequest* other);

  // implements Message ----------------------------------------------

  SetFOVRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetFOVRequest& from);
  void MergeFrom(const SetFOVRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float fov = 1;
  inline bool has_fov() const;
  inline void clear_fov();
  static const int kFovFieldNumber = 1;
  inline float fov() const;
  inline void set_fov(float value);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetFOVRequest)
 private:
  inline void set_has_fov();
  inline void clear_has_fov();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float fov_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetFOVRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetFOVResponse : public ::google::protobuf::Message {
 public:
  SetFOVResponse();
  virtual ~SetFOVResponse();

  SetFOVResponse(const SetFOVResponse& from);

  inline SetFOVResponse& operator=(const SetFOVResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetFOVResponse& default_instance();

  void Swap(SetFOVResponse* other);

  // implements Message ----------------------------------------------

  SetFOVResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetFOVResponse& from);
  void MergeFrom(const SetFOVResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetFOVResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetFOVResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetLwrrentFOVRequest : public ::google::protobuf::Message {
 public:
  GetLwrrentFOVRequest();
  virtual ~GetLwrrentFOVRequest();

  GetLwrrentFOVRequest(const GetLwrrentFOVRequest& from);

  inline GetLwrrentFOVRequest& operator=(const GetLwrrentFOVRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLwrrentFOVRequest& default_instance();

  void Swap(GetLwrrentFOVRequest* other);

  // implements Message ----------------------------------------------

  GetLwrrentFOVRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetLwrrentFOVRequest& from);
  void MergeFrom(const GetLwrrentFOVRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.GetLwrrentFOVRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetLwrrentFOVRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetLwrrentFOVResponse : public ::google::protobuf::Message {
 public:
  GetLwrrentFOVResponse();
  virtual ~GetLwrrentFOVResponse();

  GetLwrrentFOVResponse(const GetLwrrentFOVResponse& from);

  inline GetLwrrentFOVResponse& operator=(const GetLwrrentFOVResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLwrrentFOVResponse& default_instance();

  void Swap(GetLwrrentFOVResponse* other);

  // implements Message ----------------------------------------------

  GetLwrrentFOVResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetLwrrentFOVResponse& from);
  void MergeFrom(const GetLwrrentFOVResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float fov = 1;
  inline bool has_fov() const;
  inline void clear_fov();
  static const int kFovFieldNumber = 1;
  inline float fov() const;
  inline void set_fov(float value);

  // @@protoc_insertion_point(class_scope:AnselIpc.GetLwrrentFOVResponse)
 private:
  inline void set_has_fov();
  inline void clear_has_fov();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float fov_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetLwrrentFOVResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetRollRangeRequest : public ::google::protobuf::Message {
 public:
  GetRollRangeRequest();
  virtual ~GetRollRangeRequest();

  GetRollRangeRequest(const GetRollRangeRequest& from);

  inline GetRollRangeRequest& operator=(const GetRollRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRollRangeRequest& default_instance();

  void Swap(GetRollRangeRequest* other);

  // implements Message ----------------------------------------------

  GetRollRangeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetRollRangeRequest& from);
  void MergeFrom(const GetRollRangeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.GetRollRangeRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetRollRangeRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetRollRangeResponse : public ::google::protobuf::Message {
 public:
  GetRollRangeResponse();
  virtual ~GetRollRangeResponse();

  GetRollRangeResponse(const GetRollRangeResponse& from);

  inline GetRollRangeResponse& operator=(const GetRollRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRollRangeResponse& default_instance();

  void Swap(GetRollRangeResponse* other);

  // implements Message ----------------------------------------------

  GetRollRangeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetRollRangeResponse& from);
  void MergeFrom(const GetRollRangeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float minRoll = 1;
  inline bool has_minroll() const;
  inline void clear_minroll();
  static const int kMinRollFieldNumber = 1;
  inline float minroll() const;
  inline void set_minroll(float value);

  // required float maxRoll = 2;
  inline bool has_maxroll() const;
  inline void clear_maxroll();
  static const int kMaxRollFieldNumber = 2;
  inline float maxroll() const;
  inline void set_maxroll(float value);

  // @@protoc_insertion_point(class_scope:AnselIpc.GetRollRangeResponse)
 private:
  inline void set_has_minroll();
  inline void clear_has_minroll();
  inline void set_has_maxroll();
  inline void clear_has_maxroll();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float minroll_;
  float maxroll_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetRollRangeResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetRollRequest : public ::google::protobuf::Message {
 public:
  SetRollRequest();
  virtual ~SetRollRequest();

  SetRollRequest(const SetRollRequest& from);

  inline SetRollRequest& operator=(const SetRollRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetRollRequest& default_instance();

  void Swap(SetRollRequest* other);

  // implements Message ----------------------------------------------

  SetRollRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetRollRequest& from);
  void MergeFrom(const SetRollRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float roll = 1;
  inline bool has_roll() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 1;
  inline float roll() const;
  inline void set_roll(float value);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetRollRequest)
 private:
  inline void set_has_roll();
  inline void clear_has_roll();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float roll_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetRollRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetRollResponse : public ::google::protobuf::Message {
 public:
  SetRollResponse();
  virtual ~SetRollResponse();

  SetRollResponse(const SetRollResponse& from);

  inline SetRollResponse& operator=(const SetRollResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetRollResponse& default_instance();

  void Swap(SetRollResponse* other);

  // implements Message ----------------------------------------------

  SetRollResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetRollResponse& from);
  void MergeFrom(const SetRollResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetRollResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetRollResponse* default_instance_;
};
// -------------------------------------------------------------------

class UpdateRollRequest : public ::google::protobuf::Message {
 public:
  UpdateRollRequest();
  virtual ~UpdateRollRequest();

  UpdateRollRequest(const UpdateRollRequest& from);

  inline UpdateRollRequest& operator=(const UpdateRollRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateRollRequest& default_instance();

  void Swap(UpdateRollRequest* other);

  // implements Message ----------------------------------------------

  UpdateRollRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateRollRequest& from);
  void MergeFrom(const UpdateRollRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float roll = 1;
  inline bool has_roll() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 1;
  inline float roll() const;
  inline void set_roll(float value);

  // @@protoc_insertion_point(class_scope:AnselIpc.UpdateRollRequest)
 private:
  inline void set_has_roll();
  inline void clear_has_roll();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float roll_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UpdateRollRequest* default_instance_;
};
// -------------------------------------------------------------------

class UpdateRollResponse : public ::google::protobuf::Message {
 public:
  UpdateRollResponse();
  virtual ~UpdateRollResponse();

  UpdateRollResponse(const UpdateRollResponse& from);

  inline UpdateRollResponse& operator=(const UpdateRollResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateRollResponse& default_instance();

  void Swap(UpdateRollResponse* other);

  // implements Message ----------------------------------------------

  UpdateRollResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateRollResponse& from);
  void MergeFrom(const UpdateRollResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.UpdateRollResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UpdateRollResponse* default_instance_;
};
// -------------------------------------------------------------------

class UpdateFovRequest : public ::google::protobuf::Message {
 public:
  UpdateFovRequest();
  virtual ~UpdateFovRequest();

  UpdateFovRequest(const UpdateFovRequest& from);

  inline UpdateFovRequest& operator=(const UpdateFovRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateFovRequest& default_instance();

  void Swap(UpdateFovRequest* other);

  // implements Message ----------------------------------------------

  UpdateFovRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateFovRequest& from);
  void MergeFrom(const UpdateFovRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float fov = 1;
  inline bool has_fov() const;
  inline void clear_fov();
  static const int kFovFieldNumber = 1;
  inline float fov() const;
  inline void set_fov(float value);

  // @@protoc_insertion_point(class_scope:AnselIpc.UpdateFovRequest)
 private:
  inline void set_has_fov();
  inline void clear_has_fov();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float fov_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UpdateFovRequest* default_instance_;
};
// -------------------------------------------------------------------

class UpdateFovResponse : public ::google::protobuf::Message {
 public:
  UpdateFovResponse();
  virtual ~UpdateFovResponse();

  UpdateFovResponse(const UpdateFovResponse& from);

  inline UpdateFovResponse& operator=(const UpdateFovResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateFovResponse& default_instance();

  void Swap(UpdateFovResponse* other);

  // implements Message ----------------------------------------------

  UpdateFovResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateFovResponse& from);
  void MergeFrom(const UpdateFovResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.UpdateFovResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static UpdateFovResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetScreenResolutionRequest : public ::google::protobuf::Message {
 public:
  GetScreenResolutionRequest();
  virtual ~GetScreenResolutionRequest();

  GetScreenResolutionRequest(const GetScreenResolutionRequest& from);

  inline GetScreenResolutionRequest& operator=(const GetScreenResolutionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetScreenResolutionRequest& default_instance();

  void Swap(GetScreenResolutionRequest* other);

  // implements Message ----------------------------------------------

  GetScreenResolutionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetScreenResolutionRequest& from);
  void MergeFrom(const GetScreenResolutionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.GetScreenResolutionRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetScreenResolutionRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetScreenResolutionResponse : public ::google::protobuf::Message {
 public:
  GetScreenResolutionResponse();
  virtual ~GetScreenResolutionResponse();

  GetScreenResolutionResponse(const GetScreenResolutionResponse& from);

  inline GetScreenResolutionResponse& operator=(const GetScreenResolutionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetScreenResolutionResponse& default_instance();

  void Swap(GetScreenResolutionResponse* other);

  // implements Message ----------------------------------------------

  GetScreenResolutionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetScreenResolutionResponse& from);
  void MergeFrom(const GetScreenResolutionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // required int32 xResolution = 2;
  inline bool has_xresolution() const;
  inline void clear_xresolution();
  static const int kXResolutionFieldNumber = 2;
  inline ::google::protobuf::int32 xresolution() const;
  inline void set_xresolution(::google::protobuf::int32 value);

  // required int32 yResolution = 3;
  inline bool has_yresolution() const;
  inline void clear_yresolution();
  static const int kYResolutionFieldNumber = 3;
  inline ::google::protobuf::int32 yresolution() const;
  inline void set_yresolution(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AnselIpc.GetScreenResolutionResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_xresolution();
  inline void clear_has_xresolution();
  inline void set_has_yresolution();
  inline void clear_has_yresolution();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  ::google::protobuf::int32 xresolution_;
  ::google::protobuf::int32 yresolution_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetScreenResolutionResponse* default_instance_;
};
// -------------------------------------------------------------------

class CaptureShotRequest : public ::google::protobuf::Message {
 public:
  CaptureShotRequest();
  virtual ~CaptureShotRequest();

  CaptureShotRequest(const CaptureShotRequest& from);

  inline CaptureShotRequest& operator=(const CaptureShotRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CaptureShotRequest& default_instance();

  void Swap(CaptureShotRequest* other);

  // implements Message ----------------------------------------------

  CaptureShotRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CaptureShotRequest& from);
  void MergeFrom(const CaptureShotRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.ShotTypeIPC type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::AnselIpc::ShotTypeIPC type() const;
  inline void set_type(::AnselIpc::ShotTypeIPC value);

  // optional int32 highresMultiplier = 2;
  inline bool has_highresmultiplier() const;
  inline void clear_highresmultiplier();
  static const int kHighresMultiplierFieldNumber = 2;
  inline ::google::protobuf::int32 highresmultiplier() const;
  inline void set_highresmultiplier(::google::protobuf::int32 value);

  // optional int32 horizontal360Resolution = 3;
  inline bool has_horizontal360resolution() const;
  inline void clear_horizontal360resolution();
  static const int kHorizontal360ResolutionFieldNumber = 3;
  inline ::google::protobuf::int32 horizontal360resolution() const;
  inline void set_horizontal360resolution(::google::protobuf::int32 value);

  // optional bool generateThumbnail = 4;
  inline bool has_generatethumbnail() const;
  inline void clear_generatethumbnail();
  static const int kGenerateThumbnailFieldNumber = 4;
  inline bool generatethumbnail() const;
  inline void set_generatethumbnail(bool value);

  // optional bool isExr = 5;
  inline bool has_isexr() const;
  inline void clear_isexr();
  static const int kIsExrFieldNumber = 5;
  inline bool isexr() const;
  inline void set_isexr(bool value);

  // optional bool highresEnhance = 6;
  inline bool has_highresenhance() const;
  inline void clear_highresenhance();
  static const int kHighresEnhanceFieldNumber = 6;
  inline bool highresenhance() const;
  inline void set_highresenhance(bool value);

  // optional bool isJxr = 7;
  inline bool has_isjxr() const;
  inline void clear_isjxr();
  static const int kIsJxrFieldNumber = 7;
  inline bool isjxr() const;
  inline void set_isjxr(bool value);

  // @@protoc_insertion_point(class_scope:AnselIpc.CaptureShotRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_highresmultiplier();
  inline void clear_has_highresmultiplier();
  inline void set_has_horizontal360resolution();
  inline void clear_has_horizontal360resolution();
  inline void set_has_generatethumbnail();
  inline void clear_has_generatethumbnail();
  inline void set_has_isexr();
  inline void clear_has_isexr();
  inline void set_has_highresenhance();
  inline void clear_has_highresenhance();
  inline void set_has_isjxr();
  inline void clear_has_isjxr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  ::google::protobuf::int32 highresmultiplier_;
  ::google::protobuf::int32 horizontal360resolution_;
  bool generatethumbnail_;
  bool isexr_;
  bool highresenhance_;
  bool isjxr_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static CaptureShotRequest* default_instance_;
};
// -------------------------------------------------------------------

class CaptureShotStartedResponse : public ::google::protobuf::Message {
 public:
  CaptureShotStartedResponse();
  virtual ~CaptureShotStartedResponse();

  CaptureShotStartedResponse(const CaptureShotStartedResponse& from);

  inline CaptureShotStartedResponse& operator=(const CaptureShotStartedResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CaptureShotStartedResponse& default_instance();

  void Swap(CaptureShotStartedResponse* other);

  // implements Message ----------------------------------------------

  CaptureShotStartedResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CaptureShotStartedResponse& from);
  void MergeFrom(const CaptureShotStartedResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // optional int32 totalShotCount = 3;
  inline bool has_totalshotcount() const;
  inline void clear_totalshotcount();
  static const int kTotalShotCountFieldNumber = 3;
  inline ::google::protobuf::int32 totalshotcount() const;
  inline void set_totalshotcount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AnselIpc.CaptureShotStartedResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_totalshotcount();
  inline void clear_has_totalshotcount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  ::google::protobuf::int32 totalshotcount_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static CaptureShotStartedResponse* default_instance_;
};
// -------------------------------------------------------------------

class CaptureShotProgressResponse : public ::google::protobuf::Message {
 public:
  CaptureShotProgressResponse();
  virtual ~CaptureShotProgressResponse();

  CaptureShotProgressResponse(const CaptureShotProgressResponse& from);

  inline CaptureShotProgressResponse& operator=(const CaptureShotProgressResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CaptureShotProgressResponse& default_instance();

  void Swap(CaptureShotProgressResponse* other);

  // implements Message ----------------------------------------------

  CaptureShotProgressResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CaptureShotProgressResponse& from);
  void MergeFrom(const CaptureShotProgressResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 lwrrentShot = 1;
  inline bool has_lwrrentshot() const;
  inline void clear_lwrrentshot();
  static const int kLwrrentShotFieldNumber = 1;
  inline ::google::protobuf::int32 lwrrentshot() const;
  inline void set_lwrrentshot(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AnselIpc.CaptureShotProgressResponse)
 private:
  inline void set_has_lwrrentshot();
  inline void clear_has_lwrrentshot();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 lwrrentshot_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static CaptureShotProgressResponse* default_instance_;
};
// -------------------------------------------------------------------

class CaptureShotFinishedResponse : public ::google::protobuf::Message {
 public:
  CaptureShotFinishedResponse();
  virtual ~CaptureShotFinishedResponse();

  CaptureShotFinishedResponse(const CaptureShotFinishedResponse& from);

  inline CaptureShotFinishedResponse& operator=(const CaptureShotFinishedResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CaptureShotFinishedResponse& default_instance();

  void Swap(CaptureShotFinishedResponse* other);

  // implements Message ----------------------------------------------

  CaptureShotFinishedResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CaptureShotFinishedResponse& from);
  void MergeFrom(const CaptureShotFinishedResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.CaptureShotFinishedResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static CaptureShotFinishedResponse* default_instance_;
};
// -------------------------------------------------------------------

class CaptureShotProcessingFinishedResponse : public ::google::protobuf::Message {
 public:
  CaptureShotProcessingFinishedResponse();
  virtual ~CaptureShotProcessingFinishedResponse();

  CaptureShotProcessingFinishedResponse(const CaptureShotProcessingFinishedResponse& from);

  inline CaptureShotProcessingFinishedResponse& operator=(const CaptureShotProcessingFinishedResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CaptureShotProcessingFinishedResponse& default_instance();

  void Swap(CaptureShotProcessingFinishedResponse* other);

  // implements Message ----------------------------------------------

  CaptureShotProcessingFinishedResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CaptureShotProcessingFinishedResponse& from);
  void MergeFrom(const CaptureShotProcessingFinishedResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // optional string absoluteFilePath = 2;
  inline bool has_absolutefilepath() const;
  inline void clear_absolutefilepath();
  static const int kAbsoluteFilePathFieldNumber = 2;
  inline const ::std::string& absolutefilepath() const;
  inline void set_absolutefilepath(const ::std::string& value);
  inline void set_absolutefilepath(const char* value);
  inline void set_absolutefilepath(const char* value, size_t size);
  inline ::std::string* mutable_absolutefilepath();
  inline ::std::string* release_absolutefilepath();
  inline void set_allocated_absolutefilepath(::std::string* absolutefilepath);

  // @@protoc_insertion_point(class_scope:AnselIpc.CaptureShotProcessingFinishedResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_absolutefilepath();
  inline void clear_has_absolutefilepath();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* absolutefilepath_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static CaptureShotProcessingFinishedResponse* default_instance_;
};
// -------------------------------------------------------------------

class EstimateCaptureRequest : public ::google::protobuf::Message {
 public:
  EstimateCaptureRequest();
  virtual ~EstimateCaptureRequest();

  EstimateCaptureRequest(const EstimateCaptureRequest& from);

  inline EstimateCaptureRequest& operator=(const EstimateCaptureRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EstimateCaptureRequest& default_instance();

  void Swap(EstimateCaptureRequest* other);

  // implements Message ----------------------------------------------

  EstimateCaptureRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EstimateCaptureRequest& from);
  void MergeFrom(const EstimateCaptureRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.ShotTypeIPC type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::AnselIpc::ShotTypeIPC type() const;
  inline void set_type(::AnselIpc::ShotTypeIPC value);

  // optional int32 highresMultiplier = 2;
  inline bool has_highresmultiplier() const;
  inline void clear_highresmultiplier();
  static const int kHighresMultiplierFieldNumber = 2;
  inline ::google::protobuf::int32 highresmultiplier() const;
  inline void set_highresmultiplier(::google::protobuf::int32 value);

  // optional int32 horizontal360Resolution = 3;
  inline bool has_horizontal360resolution() const;
  inline void clear_horizontal360resolution();
  static const int kHorizontal360ResolutionFieldNumber = 3;
  inline ::google::protobuf::int32 horizontal360resolution() const;
  inline void set_horizontal360resolution(::google::protobuf::int32 value);

  // optional bool generateThumbnail = 4;
  inline bool has_generatethumbnail() const;
  inline void clear_generatethumbnail();
  static const int kGenerateThumbnailFieldNumber = 4;
  inline bool generatethumbnail() const;
  inline void set_generatethumbnail(bool value);

  // optional bool isExr = 5;
  inline bool has_isexr() const;
  inline void clear_isexr();
  static const int kIsExrFieldNumber = 5;
  inline bool isexr() const;
  inline void set_isexr(bool value);

  // optional bool highresEnhance = 6;
  inline bool has_highresenhance() const;
  inline void clear_highresenhance();
  static const int kHighresEnhanceFieldNumber = 6;
  inline bool highresenhance() const;
  inline void set_highresenhance(bool value);

  // @@protoc_insertion_point(class_scope:AnselIpc.EstimateCaptureRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_highresmultiplier();
  inline void clear_has_highresmultiplier();
  inline void set_has_horizontal360resolution();
  inline void clear_has_horizontal360resolution();
  inline void set_has_generatethumbnail();
  inline void clear_has_generatethumbnail();
  inline void set_has_isexr();
  inline void clear_has_isexr();
  inline void set_has_highresenhance();
  inline void clear_has_highresenhance();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  ::google::protobuf::int32 highresmultiplier_;
  ::google::protobuf::int32 horizontal360resolution_;
  bool generatethumbnail_;
  bool isexr_;
  bool highresenhance_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static EstimateCaptureRequest* default_instance_;
};
// -------------------------------------------------------------------

class EstimateCaptureResponse : public ::google::protobuf::Message {
 public:
  EstimateCaptureResponse();
  virtual ~EstimateCaptureResponse();

  EstimateCaptureResponse(const EstimateCaptureResponse& from);

  inline EstimateCaptureResponse& operator=(const EstimateCaptureResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EstimateCaptureResponse& default_instance();

  void Swap(EstimateCaptureResponse* other);

  // implements Message ----------------------------------------------

  EstimateCaptureResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EstimateCaptureResponse& from);
  void MergeFrom(const EstimateCaptureResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 inputDatasetSizeTotalInBytes = 1;
  inline bool has_inputdatasetsizetotalinbytes() const;
  inline void clear_inputdatasetsizetotalinbytes();
  static const int kInputDatasetSizeTotalInBytesFieldNumber = 1;
  inline ::google::protobuf::uint64 inputdatasetsizetotalinbytes() const;
  inline void set_inputdatasetsizetotalinbytes(::google::protobuf::uint64 value);

  // required uint64 inputDatasetFrameCount = 2;
  inline bool has_inputdatasetframecount() const;
  inline void clear_inputdatasetframecount();
  static const int kInputDatasetFrameCountFieldNumber = 2;
  inline ::google::protobuf::uint64 inputdatasetframecount() const;
  inline void set_inputdatasetframecount(::google::protobuf::uint64 value);

  // required uint64 inputDatasetFrameSizeInBytes = 3;
  inline bool has_inputdatasetframesizeinbytes() const;
  inline void clear_inputdatasetframesizeinbytes();
  static const int kInputDatasetFrameSizeInBytesFieldNumber = 3;
  inline ::google::protobuf::uint64 inputdatasetframesizeinbytes() const;
  inline void set_inputdatasetframesizeinbytes(::google::protobuf::uint64 value);

  // required uint64 stitcherMemoryRequirementsInBytes = 4;
  inline bool has_stitchermemoryrequirementsinbytes() const;
  inline void clear_stitchermemoryrequirementsinbytes();
  static const int kStitcherMemoryRequirementsInBytesFieldNumber = 4;
  inline ::google::protobuf::uint64 stitchermemoryrequirementsinbytes() const;
  inline void set_stitchermemoryrequirementsinbytes(::google::protobuf::uint64 value);

  // required uint64 outputResolutionX = 5;
  inline bool has_outputresolutionx() const;
  inline void clear_outputresolutionx();
  static const int kOutputResolutionXFieldNumber = 5;
  inline ::google::protobuf::uint64 outputresolutionx() const;
  inline void set_outputresolutionx(::google::protobuf::uint64 value);

  // required uint64 outputResolutionY = 6;
  inline bool has_outputresolutiony() const;
  inline void clear_outputresolutiony();
  static const int kOutputResolutionYFieldNumber = 6;
  inline ::google::protobuf::uint64 outputresolutiony() const;
  inline void set_outputresolutiony(::google::protobuf::uint64 value);

  // required uint64 outputMPixels = 7;
  inline bool has_outputmpixels() const;
  inline void clear_outputmpixels();
  static const int kOutputMPixelsFieldNumber = 7;
  inline ::google::protobuf::uint64 outputmpixels() const;
  inline void set_outputmpixels(::google::protobuf::uint64 value);

  // required uint64 outputSizeInBytes = 8;
  inline bool has_outputsizeinbytes() const;
  inline void clear_outputsizeinbytes();
  static const int kOutputSizeInBytesFieldNumber = 8;
  inline ::google::protobuf::uint64 outputsizeinbytes() const;
  inline void set_outputsizeinbytes(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:AnselIpc.EstimateCaptureResponse)
 private:
  inline void set_has_inputdatasetsizetotalinbytes();
  inline void clear_has_inputdatasetsizetotalinbytes();
  inline void set_has_inputdatasetframecount();
  inline void clear_has_inputdatasetframecount();
  inline void set_has_inputdatasetframesizeinbytes();
  inline void clear_has_inputdatasetframesizeinbytes();
  inline void set_has_stitchermemoryrequirementsinbytes();
  inline void clear_has_stitchermemoryrequirementsinbytes();
  inline void set_has_outputresolutionx();
  inline void clear_has_outputresolutionx();
  inline void set_has_outputresolutiony();
  inline void clear_has_outputresolutiony();
  inline void set_has_outputmpixels();
  inline void clear_has_outputmpixels();
  inline void set_has_outputsizeinbytes();
  inline void clear_has_outputsizeinbytes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 inputdatasetsizetotalinbytes_;
  ::google::protobuf::uint64 inputdatasetframecount_;
  ::google::protobuf::uint64 inputdatasetframesizeinbytes_;
  ::google::protobuf::uint64 stitchermemoryrequirementsinbytes_;
  ::google::protobuf::uint64 outputresolutionx_;
  ::google::protobuf::uint64 outputresolutiony_;
  ::google::protobuf::uint64 outputmpixels_;
  ::google::protobuf::uint64 outputsizeinbytes_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static EstimateCaptureResponse* default_instance_;
};
// -------------------------------------------------------------------

class AbortCaptureRequest : public ::google::protobuf::Message {
 public:
  AbortCaptureRequest();
  virtual ~AbortCaptureRequest();

  AbortCaptureRequest(const AbortCaptureRequest& from);

  inline AbortCaptureRequest& operator=(const AbortCaptureRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AbortCaptureRequest& default_instance();

  void Swap(AbortCaptureRequest* other);

  // implements Message ----------------------------------------------

  AbortCaptureRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AbortCaptureRequest& from);
  void MergeFrom(const AbortCaptureRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.AbortCaptureRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static AbortCaptureRequest* default_instance_;
};
// -------------------------------------------------------------------

class AbortCaptureResponse : public ::google::protobuf::Message {
 public:
  AbortCaptureResponse();
  virtual ~AbortCaptureResponse();

  AbortCaptureResponse(const AbortCaptureResponse& from);

  inline AbortCaptureResponse& operator=(const AbortCaptureResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AbortCaptureResponse& default_instance();

  void Swap(AbortCaptureResponse* other);

  // implements Message ----------------------------------------------

  AbortCaptureResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AbortCaptureResponse& from);
  void MergeFrom(const AbortCaptureResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.AbortCaptureResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static AbortCaptureResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetHighresResolutionListRequest : public ::google::protobuf::Message {
 public:
  GetHighresResolutionListRequest();
  virtual ~GetHighresResolutionListRequest();

  GetHighresResolutionListRequest(const GetHighresResolutionListRequest& from);

  inline GetHighresResolutionListRequest& operator=(const GetHighresResolutionListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetHighresResolutionListRequest& default_instance();

  void Swap(GetHighresResolutionListRequest* other);

  // implements Message ----------------------------------------------

  GetHighresResolutionListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetHighresResolutionListRequest& from);
  void MergeFrom(const GetHighresResolutionListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.GetHighresResolutionListRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetHighresResolutionListRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetHighresResolutionListResponse_HighresResolution : public ::google::protobuf::Message {
 public:
  GetHighresResolutionListResponse_HighresResolution();
  virtual ~GetHighresResolutionListResponse_HighresResolution();

  GetHighresResolutionListResponse_HighresResolution(const GetHighresResolutionListResponse_HighresResolution& from);

  inline GetHighresResolutionListResponse_HighresResolution& operator=(const GetHighresResolutionListResponse_HighresResolution& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetHighresResolutionListResponse_HighresResolution& default_instance();

  void Swap(GetHighresResolutionListResponse_HighresResolution* other);

  // implements Message ----------------------------------------------

  GetHighresResolutionListResponse_HighresResolution* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetHighresResolutionListResponse_HighresResolution& from);
  void MergeFrom(const GetHighresResolutionListResponse_HighresResolution& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 multiplier = 1;
  inline bool has_multiplier() const;
  inline void clear_multiplier();
  static const int kMultiplierFieldNumber = 1;
  inline ::google::protobuf::int32 multiplier() const;
  inline void set_multiplier(::google::protobuf::int32 value);

  // required int32 xResolution = 2;
  inline bool has_xresolution() const;
  inline void clear_xresolution();
  static const int kXResolutionFieldNumber = 2;
  inline ::google::protobuf::int32 xresolution() const;
  inline void set_xresolution(::google::protobuf::int32 value);

  // required int32 yResolution = 3;
  inline bool has_yresolution() const;
  inline void clear_yresolution();
  static const int kYResolutionFieldNumber = 3;
  inline ::google::protobuf::int32 yresolution() const;
  inline void set_yresolution(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AnselIpc.GetHighresResolutionListResponse.HighresResolution)
 private:
  inline void set_has_multiplier();
  inline void clear_has_multiplier();
  inline void set_has_xresolution();
  inline void clear_has_xresolution();
  inline void set_has_yresolution();
  inline void clear_has_yresolution();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 multiplier_;
  ::google::protobuf::int32 xresolution_;
  ::google::protobuf::int32 yresolution_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetHighresResolutionListResponse_HighresResolution* default_instance_;
};
// -------------------------------------------------------------------

class GetHighresResolutionListResponse : public ::google::protobuf::Message {
 public:
  GetHighresResolutionListResponse();
  virtual ~GetHighresResolutionListResponse();

  GetHighresResolutionListResponse(const GetHighresResolutionListResponse& from);

  inline GetHighresResolutionListResponse& operator=(const GetHighresResolutionListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetHighresResolutionListResponse& default_instance();

  void Swap(GetHighresResolutionListResponse* other);

  // implements Message ----------------------------------------------

  GetHighresResolutionListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetHighresResolutionListResponse& from);
  void MergeFrom(const GetHighresResolutionListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GetHighresResolutionListResponse_HighresResolution HighresResolution;

  // accessors -------------------------------------------------------

  // repeated .AnselIpc.GetHighresResolutionListResponse.HighresResolution resolutions = 1;
  inline int resolutions_size() const;
  inline void clear_resolutions();
  static const int kResolutionsFieldNumber = 1;
  inline const ::AnselIpc::GetHighresResolutionListResponse_HighresResolution& resolutions(int index) const;
  inline ::AnselIpc::GetHighresResolutionListResponse_HighresResolution* mutable_resolutions(int index);
  inline ::AnselIpc::GetHighresResolutionListResponse_HighresResolution* add_resolutions();
  inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::GetHighresResolutionListResponse_HighresResolution >&
      resolutions() const;
  inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::GetHighresResolutionListResponse_HighresResolution >*
      mutable_resolutions();

  // @@protoc_insertion_point(class_scope:AnselIpc.GetHighresResolutionListResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::AnselIpc::GetHighresResolutionListResponse_HighresResolution > resolutions_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetHighresResolutionListResponse* default_instance_;
};
// -------------------------------------------------------------------

class Get360ResolutionRangeRequest : public ::google::protobuf::Message {
 public:
  Get360ResolutionRangeRequest();
  virtual ~Get360ResolutionRangeRequest();

  Get360ResolutionRangeRequest(const Get360ResolutionRangeRequest& from);

  inline Get360ResolutionRangeRequest& operator=(const Get360ResolutionRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Get360ResolutionRangeRequest& default_instance();

  void Swap(Get360ResolutionRangeRequest* other);

  // implements Message ----------------------------------------------

  Get360ResolutionRangeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Get360ResolutionRangeRequest& from);
  void MergeFrom(const Get360ResolutionRangeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.Get360ResolutionRangeRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static Get360ResolutionRangeRequest* default_instance_;
};
// -------------------------------------------------------------------

class Get360ResolutionRangeResponse : public ::google::protobuf::Message {
 public:
  Get360ResolutionRangeResponse();
  virtual ~Get360ResolutionRangeResponse();

  Get360ResolutionRangeResponse(const Get360ResolutionRangeResponse& from);

  inline Get360ResolutionRangeResponse& operator=(const Get360ResolutionRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Get360ResolutionRangeResponse& default_instance();

  void Swap(Get360ResolutionRangeResponse* other);

  // implements Message ----------------------------------------------

  Get360ResolutionRangeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Get360ResolutionRangeResponse& from);
  void MergeFrom(const Get360ResolutionRangeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 minimumXResolution = 3;
  inline bool has_minimumxresolution() const;
  inline void clear_minimumxresolution();
  static const int kMinimumXResolutionFieldNumber = 3;
  inline ::google::protobuf::int32 minimumxresolution() const;
  inline void set_minimumxresolution(::google::protobuf::int32 value);

  // required int32 maximumXResolution = 4;
  inline bool has_maximumxresolution() const;
  inline void clear_maximumxresolution();
  static const int kMaximumXResolutionFieldNumber = 4;
  inline ::google::protobuf::int32 maximumxresolution() const;
  inline void set_maximumxresolution(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AnselIpc.Get360ResolutionRangeResponse)
 private:
  inline void set_has_minimumxresolution();
  inline void clear_has_minimumxresolution();
  inline void set_has_maximumxresolution();
  inline void clear_has_maximumxresolution();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 minimumxresolution_;
  ::google::protobuf::int32 maximumxresolution_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static Get360ResolutionRangeResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetFilterListRequest : public ::google::protobuf::Message {
 public:
  GetFilterListRequest();
  virtual ~GetFilterListRequest();

  GetFilterListRequest(const GetFilterListRequest& from);

  inline GetFilterListRequest& operator=(const GetFilterListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFilterListRequest& default_instance();

  void Swap(GetFilterListRequest* other);

  // implements Message ----------------------------------------------

  GetFilterListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFilterListRequest& from);
  void MergeFrom(const GetFilterListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.GetFilterListRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetFilterListRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetFilterListResponse : public ::google::protobuf::Message {
 public:
  GetFilterListResponse();
  virtual ~GetFilterListResponse();

  GetFilterListResponse(const GetFilterListResponse& from);

  inline GetFilterListResponse& operator=(const GetFilterListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFilterListResponse& default_instance();

  void Swap(GetFilterListResponse* other);

  // implements Message ----------------------------------------------

  GetFilterListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFilterListResponse& from);
  void MergeFrom(const GetFilterListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string filterIdList = 1;
  inline int filteridlist_size() const;
  inline void clear_filteridlist();
  static const int kFilterIdListFieldNumber = 1;
  inline const ::std::string& filteridlist(int index) const;
  inline ::std::string* mutable_filteridlist(int index);
  inline void set_filteridlist(int index, const ::std::string& value);
  inline void set_filteridlist(int index, const char* value);
  inline void set_filteridlist(int index, const char* value, size_t size);
  inline ::std::string* add_filteridlist();
  inline void add_filteridlist(const ::std::string& value);
  inline void add_filteridlist(const char* value);
  inline void add_filteridlist(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& filteridlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filteridlist();

  // repeated string filterNameList = 2;
  inline int filternamelist_size() const;
  inline void clear_filternamelist();
  static const int kFilterNameListFieldNumber = 2;
  inline const ::std::string& filternamelist(int index) const;
  inline ::std::string* mutable_filternamelist(int index);
  inline void set_filternamelist(int index, const ::std::string& value);
  inline void set_filternamelist(int index, const char* value);
  inline void set_filternamelist(int index, const char* value, size_t size);
  inline ::std::string* add_filternamelist();
  inline void add_filternamelist(const ::std::string& value);
  inline void add_filternamelist(const char* value);
  inline void add_filternamelist(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& filternamelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filternamelist();

  // @@protoc_insertion_point(class_scope:AnselIpc.GetFilterListResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filteridlist_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filternamelist_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetFilterListResponse* default_instance_;
};
// -------------------------------------------------------------------

class ResetEntireStackRequest : public ::google::protobuf::Message {
 public:
  ResetEntireStackRequest();
  virtual ~ResetEntireStackRequest();

  ResetEntireStackRequest(const ResetEntireStackRequest& from);

  inline ResetEntireStackRequest& operator=(const ResetEntireStackRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetEntireStackRequest& default_instance();

  void Swap(ResetEntireStackRequest* other);

  // implements Message ----------------------------------------------

  ResetEntireStackRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResetEntireStackRequest& from);
  void MergeFrom(const ResetEntireStackRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.ResetEntireStackRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static ResetEntireStackRequest* default_instance_;
};
// -------------------------------------------------------------------

class ResetEntireStackResponse : public ::google::protobuf::Message {
 public:
  ResetEntireStackResponse();
  virtual ~ResetEntireStackResponse();

  ResetEntireStackResponse(const ResetEntireStackResponse& from);

  inline ResetEntireStackResponse& operator=(const ResetEntireStackResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetEntireStackResponse& default_instance();

  void Swap(ResetEntireStackResponse* other);

  // implements Message ----------------------------------------------

  ResetEntireStackResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResetEntireStackResponse& from);
  void MergeFrom(const ResetEntireStackResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.ResetEntireStackResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static ResetEntireStackResponse* default_instance_;
};
// -------------------------------------------------------------------

class ResetFilterValuesRequest : public ::google::protobuf::Message {
 public:
  ResetFilterValuesRequest();
  virtual ~ResetFilterValuesRequest();

  ResetFilterValuesRequest(const ResetFilterValuesRequest& from);

  inline ResetFilterValuesRequest& operator=(const ResetFilterValuesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetFilterValuesRequest& default_instance();

  void Swap(ResetFilterValuesRequest* other);

  // implements Message ----------------------------------------------

  ResetFilterValuesRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResetFilterValuesRequest& from);
  void MergeFrom(const ResetFilterValuesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 stackIdx = 1;
  inline bool has_stackidx() const;
  inline void clear_stackidx();
  static const int kStackIdxFieldNumber = 1;
  inline ::google::protobuf::int32 stackidx() const;
  inline void set_stackidx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AnselIpc.ResetFilterValuesRequest)
 private:
  inline void set_has_stackidx();
  inline void clear_has_stackidx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 stackidx_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static ResetFilterValuesRequest* default_instance_;
};
// -------------------------------------------------------------------

class ResetFilterValuesResponse : public ::google::protobuf::Message {
 public:
  ResetFilterValuesResponse();
  virtual ~ResetFilterValuesResponse();

  ResetFilterValuesResponse(const ResetFilterValuesResponse& from);

  inline ResetFilterValuesResponse& operator=(const ResetFilterValuesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetFilterValuesResponse& default_instance();

  void Swap(ResetFilterValuesResponse* other);

  // implements Message ----------------------------------------------

  ResetFilterValuesResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResetFilterValuesResponse& from);
  void MergeFrom(const ResetFilterValuesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 stackIdx = 1;
  inline bool has_stackidx() const;
  inline void clear_stackidx();
  static const int kStackIdxFieldNumber = 1;
  inline ::google::protobuf::int32 stackidx() const;
  inline void set_stackidx(::google::protobuf::int32 value);

  // required .AnselIpc.Status status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.ResetFilterValuesResponse)
 private:
  inline void set_has_stackidx();
  inline void clear_has_stackidx();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 stackidx_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static ResetFilterValuesResponse* default_instance_;
};
// -------------------------------------------------------------------

class ResetAllFilterValuesRequest : public ::google::protobuf::Message {
 public:
  ResetAllFilterValuesRequest();
  virtual ~ResetAllFilterValuesRequest();

  ResetAllFilterValuesRequest(const ResetAllFilterValuesRequest& from);

  inline ResetAllFilterValuesRequest& operator=(const ResetAllFilterValuesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetAllFilterValuesRequest& default_instance();

  void Swap(ResetAllFilterValuesRequest* other);

  // implements Message ----------------------------------------------

  ResetAllFilterValuesRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResetAllFilterValuesRequest& from);
  void MergeFrom(const ResetAllFilterValuesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.ResetAllFilterValuesRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static ResetAllFilterValuesRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetFilterRequest : public ::google::protobuf::Message {
 public:
  SetFilterRequest();
  virtual ~SetFilterRequest();

  SetFilterRequest(const SetFilterRequest& from);

  inline SetFilterRequest& operator=(const SetFilterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetFilterRequest& default_instance();

  void Swap(SetFilterRequest* other);

  // implements Message ----------------------------------------------

  SetFilterRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetFilterRequest& from);
  void MergeFrom(const SetFilterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string filterId = 1;
  inline bool has_filterid() const;
  inline void clear_filterid();
  static const int kFilterIdFieldNumber = 1;
  inline const ::std::string& filterid() const;
  inline void set_filterid(const ::std::string& value);
  inline void set_filterid(const char* value);
  inline void set_filterid(const char* value, size_t size);
  inline ::std::string* mutable_filterid();
  inline ::std::string* release_filterid();
  inline void set_allocated_filterid(::std::string* filterid);

  // required int32 stackIdx = 2;
  inline bool has_stackidx() const;
  inline void clear_stackidx();
  static const int kStackIdxFieldNumber = 2;
  inline ::google::protobuf::int32 stackidx() const;
  inline void set_stackidx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetFilterRequest)
 private:
  inline void set_has_filterid();
  inline void clear_has_filterid();
  inline void set_has_stackidx();
  inline void clear_has_stackidx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* filterid_;
  ::google::protobuf::int32 stackidx_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetFilterRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetFilterResponse : public ::google::protobuf::Message {
 public:
  SetFilterResponse();
  virtual ~SetFilterResponse();

  SetFilterResponse(const SetFilterResponse& from);

  inline SetFilterResponse& operator=(const SetFilterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetFilterResponse& default_instance();

  void Swap(SetFilterResponse* other);

  // implements Message ----------------------------------------------

  SetFilterResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetFilterResponse& from);
  void MergeFrom(const SetFilterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // required int32 stackIdx = 2;
  inline bool has_stackidx() const;
  inline void clear_stackidx();
  static const int kStackIdxFieldNumber = 2;
  inline ::google::protobuf::int32 stackidx() const;
  inline void set_stackidx(::google::protobuf::int32 value);

  // optional .AnselIpc.FilterProperties filterProperties = 3;
  inline bool has_filterproperties() const;
  inline void clear_filterproperties();
  static const int kFilterPropertiesFieldNumber = 3;
  inline const ::AnselIpc::FilterProperties& filterproperties() const;
  inline ::AnselIpc::FilterProperties* mutable_filterproperties();
  inline ::AnselIpc::FilterProperties* release_filterproperties();
  inline void set_allocated_filterproperties(::AnselIpc::FilterProperties* filterproperties);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetFilterResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_stackidx();
  inline void clear_has_stackidx();
  inline void set_has_filterproperties();
  inline void clear_has_filterproperties();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  ::google::protobuf::int32 stackidx_;
  ::AnselIpc::FilterProperties* filterproperties_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetFilterResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetFilterAndAttributesRequest : public ::google::protobuf::Message {
 public:
  SetFilterAndAttributesRequest();
  virtual ~SetFilterAndAttributesRequest();

  SetFilterAndAttributesRequest(const SetFilterAndAttributesRequest& from);

  inline SetFilterAndAttributesRequest& operator=(const SetFilterAndAttributesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetFilterAndAttributesRequest& default_instance();

  void Swap(SetFilterAndAttributesRequest* other);

  // implements Message ----------------------------------------------

  SetFilterAndAttributesRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetFilterAndAttributesRequest& from);
  void MergeFrom(const SetFilterAndAttributesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string filterId = 1;
  inline bool has_filterid() const;
  inline void clear_filterid();
  static const int kFilterIdFieldNumber = 1;
  inline const ::std::string& filterid() const;
  inline void set_filterid(const ::std::string& value);
  inline void set_filterid(const char* value);
  inline void set_filterid(const char* value, size_t size);
  inline ::std::string* mutable_filterid();
  inline ::std::string* release_filterid();
  inline void set_allocated_filterid(::std::string* filterid);

  // required int32 stackIdx = 2;
  inline bool has_stackidx() const;
  inline void clear_stackidx();
  static const int kStackIdxFieldNumber = 2;
  inline ::google::protobuf::int32 stackidx() const;
  inline void set_stackidx(::google::protobuf::int32 value);

  // repeated int32 intControlIds = 3;
  inline int intcontrolids_size() const;
  inline void clear_intcontrolids();
  static const int kIntControlIdsFieldNumber = 3;
  inline ::google::protobuf::int32 intcontrolids(int index) const;
  inline void set_intcontrolids(int index, ::google::protobuf::int32 value);
  inline void add_intcontrolids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      intcontrolids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_intcontrolids();

  // repeated int32 intValues = 4;
  inline int intvalues_size() const;
  inline void clear_intvalues();
  static const int kIntValuesFieldNumber = 4;
  inline ::google::protobuf::int32 intvalues(int index) const;
  inline void set_intvalues(int index, ::google::protobuf::int32 value);
  inline void add_intvalues(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      intvalues() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_intvalues();

  // repeated int32 uintControlIds = 5;
  inline int uintcontrolids_size() const;
  inline void clear_uintcontrolids();
  static const int kUintControlIdsFieldNumber = 5;
  inline ::google::protobuf::int32 uintcontrolids(int index) const;
  inline void set_uintcontrolids(int index, ::google::protobuf::int32 value);
  inline void add_uintcontrolids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      uintcontrolids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_uintcontrolids();

  // repeated uint32 uintValues = 6;
  inline int uintvalues_size() const;
  inline void clear_uintvalues();
  static const int kUintValuesFieldNumber = 6;
  inline ::google::protobuf::uint32 uintvalues(int index) const;
  inline void set_uintvalues(int index, ::google::protobuf::uint32 value);
  inline void add_uintvalues(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      uintvalues() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_uintvalues();

  // repeated int32 floatControlIds = 7;
  inline int floatcontrolids_size() const;
  inline void clear_floatcontrolids();
  static const int kFloatControlIdsFieldNumber = 7;
  inline ::google::protobuf::int32 floatcontrolids(int index) const;
  inline void set_floatcontrolids(int index, ::google::protobuf::int32 value);
  inline void add_floatcontrolids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      floatcontrolids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_floatcontrolids();

  // repeated float floatValues = 8;
  inline int floatvalues_size() const;
  inline void clear_floatvalues();
  static const int kFloatValuesFieldNumber = 8;
  inline float floatvalues(int index) const;
  inline void set_floatvalues(int index, float value);
  inline void add_floatvalues(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      floatvalues() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_floatvalues();

  // repeated int32 boolControlIds = 9;
  inline int boolcontrolids_size() const;
  inline void clear_boolcontrolids();
  static const int kBoolControlIdsFieldNumber = 9;
  inline ::google::protobuf::int32 boolcontrolids(int index) const;
  inline void set_boolcontrolids(int index, ::google::protobuf::int32 value);
  inline void add_boolcontrolids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      boolcontrolids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_boolcontrolids();

  // repeated bool boolValues = 10;
  inline int boolvalues_size() const;
  inline void clear_boolvalues();
  static const int kBoolValuesFieldNumber = 10;
  inline bool boolvalues(int index) const;
  inline void set_boolvalues(int index, bool value);
  inline void add_boolvalues(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      boolvalues() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_boolvalues();

  // @@protoc_insertion_point(class_scope:AnselIpc.SetFilterAndAttributesRequest)
 private:
  inline void set_has_filterid();
  inline void clear_has_filterid();
  inline void set_has_stackidx();
  inline void clear_has_stackidx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* filterid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > intcontrolids_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > intvalues_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > uintcontrolids_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > uintvalues_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > floatcontrolids_;
  ::google::protobuf::RepeatedField< float > floatvalues_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > boolcontrolids_;
  ::google::protobuf::RepeatedField< bool > boolvalues_;
  ::google::protobuf::int32 stackidx_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetFilterAndAttributesRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetFilterAndAttributesResponse : public ::google::protobuf::Message {
 public:
  SetFilterAndAttributesResponse();
  virtual ~SetFilterAndAttributesResponse();

  SetFilterAndAttributesResponse(const SetFilterAndAttributesResponse& from);

  inline SetFilterAndAttributesResponse& operator=(const SetFilterAndAttributesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetFilterAndAttributesResponse& default_instance();

  void Swap(SetFilterAndAttributesResponse* other);

  // implements Message ----------------------------------------------

  SetFilterAndAttributesResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetFilterAndAttributesResponse& from);
  void MergeFrom(const SetFilterAndAttributesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.SetFilterResponse setFilterResponse = 1;
  inline bool has_setfilterresponse() const;
  inline void clear_setfilterresponse();
  static const int kSetFilterResponseFieldNumber = 1;
  inline const ::AnselIpc::SetFilterResponse& setfilterresponse() const;
  inline ::AnselIpc::SetFilterResponse* mutable_setfilterresponse();
  inline ::AnselIpc::SetFilterResponse* release_setfilterresponse();
  inline void set_allocated_setfilterresponse(::AnselIpc::SetFilterResponse* setfilterresponse);

  // repeated int32 attributeControlIds = 2;
  inline int attributecontrolids_size() const;
  inline void clear_attributecontrolids();
  static const int kAttributeControlIdsFieldNumber = 2;
  inline ::google::protobuf::int32 attributecontrolids(int index) const;
  inline void set_attributecontrolids(int index, ::google::protobuf::int32 value);
  inline void add_attributecontrolids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      attributecontrolids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_attributecontrolids();

  // repeated .AnselIpc.SetFilterAttributeResponse setFilterAttributeResponses = 3;
  inline int setfilterattributeresponses_size() const;
  inline void clear_setfilterattributeresponses();
  static const int kSetFilterAttributeResponsesFieldNumber = 3;
  inline const ::AnselIpc::SetFilterAttributeResponse& setfilterattributeresponses(int index) const;
  inline ::AnselIpc::SetFilterAttributeResponse* mutable_setfilterattributeresponses(int index);
  inline ::AnselIpc::SetFilterAttributeResponse* add_setfilterattributeresponses();
  inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::SetFilterAttributeResponse >&
      setfilterattributeresponses() const;
  inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::SetFilterAttributeResponse >*
      mutable_setfilterattributeresponses();

  // @@protoc_insertion_point(class_scope:AnselIpc.SetFilterAndAttributesResponse)
 private:
  inline void set_has_setfilterresponse();
  inline void clear_has_setfilterresponse();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::AnselIpc::SetFilterResponse* setfilterresponse_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > attributecontrolids_;
  ::google::protobuf::RepeatedPtrField< ::AnselIpc::SetFilterAttributeResponse > setfilterattributeresponses_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetFilterAndAttributesResponse* default_instance_;
};
// -------------------------------------------------------------------

class InsertFilterRequest : public ::google::protobuf::Message {
 public:
  InsertFilterRequest();
  virtual ~InsertFilterRequest();

  InsertFilterRequest(const InsertFilterRequest& from);

  inline InsertFilterRequest& operator=(const InsertFilterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InsertFilterRequest& default_instance();

  void Swap(InsertFilterRequest* other);

  // implements Message ----------------------------------------------

  InsertFilterRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InsertFilterRequest& from);
  void MergeFrom(const InsertFilterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string filterId = 1;
  inline bool has_filterid() const;
  inline void clear_filterid();
  static const int kFilterIdFieldNumber = 1;
  inline const ::std::string& filterid() const;
  inline void set_filterid(const ::std::string& value);
  inline void set_filterid(const char* value);
  inline void set_filterid(const char* value, size_t size);
  inline ::std::string* mutable_filterid();
  inline ::std::string* release_filterid();
  inline void set_allocated_filterid(::std::string* filterid);

  // required int32 stackIdx = 2;
  inline bool has_stackidx() const;
  inline void clear_stackidx();
  static const int kStackIdxFieldNumber = 2;
  inline ::google::protobuf::int32 stackidx() const;
  inline void set_stackidx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AnselIpc.InsertFilterRequest)
 private:
  inline void set_has_filterid();
  inline void clear_has_filterid();
  inline void set_has_stackidx();
  inline void clear_has_stackidx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* filterid_;
  ::google::protobuf::int32 stackidx_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static InsertFilterRequest* default_instance_;
};
// -------------------------------------------------------------------

class InsertFilterResponse : public ::google::protobuf::Message {
 public:
  InsertFilterResponse();
  virtual ~InsertFilterResponse();

  InsertFilterResponse(const InsertFilterResponse& from);

  inline InsertFilterResponse& operator=(const InsertFilterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InsertFilterResponse& default_instance();

  void Swap(InsertFilterResponse* other);

  // implements Message ----------------------------------------------

  InsertFilterResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InsertFilterResponse& from);
  void MergeFrom(const InsertFilterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // required int32 stackIdx = 2;
  inline bool has_stackidx() const;
  inline void clear_stackidx();
  static const int kStackIdxFieldNumber = 2;
  inline ::google::protobuf::int32 stackidx() const;
  inline void set_stackidx(::google::protobuf::int32 value);

  // optional .AnselIpc.FilterProperties filterProperties = 3;
  inline bool has_filterproperties() const;
  inline void clear_filterproperties();
  static const int kFilterPropertiesFieldNumber = 3;
  inline const ::AnselIpc::FilterProperties& filterproperties() const;
  inline ::AnselIpc::FilterProperties* mutable_filterproperties();
  inline ::AnselIpc::FilterProperties* release_filterproperties();
  inline void set_allocated_filterproperties(::AnselIpc::FilterProperties* filterproperties);

  // @@protoc_insertion_point(class_scope:AnselIpc.InsertFilterResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_stackidx();
  inline void clear_has_stackidx();
  inline void set_has_filterproperties();
  inline void clear_has_filterproperties();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  ::google::protobuf::int32 stackidx_;
  ::AnselIpc::FilterProperties* filterproperties_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static InsertFilterResponse* default_instance_;
};
// -------------------------------------------------------------------

class RemoveFilterRequest : public ::google::protobuf::Message {
 public:
  RemoveFilterRequest();
  virtual ~RemoveFilterRequest();

  RemoveFilterRequest(const RemoveFilterRequest& from);

  inline RemoveFilterRequest& operator=(const RemoveFilterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveFilterRequest& default_instance();

  void Swap(RemoveFilterRequest* other);

  // implements Message ----------------------------------------------

  RemoveFilterRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveFilterRequest& from);
  void MergeFrom(const RemoveFilterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 stackIdx = 1;
  inline bool has_stackidx() const;
  inline void clear_stackidx();
  static const int kStackIdxFieldNumber = 1;
  inline ::google::protobuf::int32 stackidx() const;
  inline void set_stackidx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AnselIpc.RemoveFilterRequest)
 private:
  inline void set_has_stackidx();
  inline void clear_has_stackidx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 stackidx_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static RemoveFilterRequest* default_instance_;
};
// -------------------------------------------------------------------

class RemoveFilterResponse : public ::google::protobuf::Message {
 public:
  RemoveFilterResponse();
  virtual ~RemoveFilterResponse();

  RemoveFilterResponse(const RemoveFilterResponse& from);

  inline RemoveFilterResponse& operator=(const RemoveFilterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveFilterResponse& default_instance();

  void Swap(RemoveFilterResponse* other);

  // implements Message ----------------------------------------------

  RemoveFilterResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveFilterResponse& from);
  void MergeFrom(const RemoveFilterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.RemoveFilterResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static RemoveFilterResponse* default_instance_;
};
// -------------------------------------------------------------------

class MoveFilterRequest : public ::google::protobuf::Message {
 public:
  MoveFilterRequest();
  virtual ~MoveFilterRequest();

  MoveFilterRequest(const MoveFilterRequest& from);

  inline MoveFilterRequest& operator=(const MoveFilterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveFilterRequest& default_instance();

  void Swap(MoveFilterRequest* other);

  // implements Message ----------------------------------------------

  MoveFilterRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoveFilterRequest& from);
  void MergeFrom(const MoveFilterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 desiredStackIndices = 1;
  inline int desiredstackindices_size() const;
  inline void clear_desiredstackindices();
  static const int kDesiredStackIndicesFieldNumber = 1;
  inline ::google::protobuf::uint32 desiredstackindices(int index) const;
  inline void set_desiredstackindices(int index, ::google::protobuf::uint32 value);
  inline void add_desiredstackindices(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      desiredstackindices() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_desiredstackindices();

  // @@protoc_insertion_point(class_scope:AnselIpc.MoveFilterRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > desiredstackindices_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static MoveFilterRequest* default_instance_;
};
// -------------------------------------------------------------------

class MoveFilterResponse : public ::google::protobuf::Message {
 public:
  MoveFilterResponse();
  virtual ~MoveFilterResponse();

  MoveFilterResponse(const MoveFilterResponse& from);

  inline MoveFilterResponse& operator=(const MoveFilterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveFilterResponse& default_instance();

  void Swap(MoveFilterResponse* other);

  // implements Message ----------------------------------------------

  MoveFilterResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoveFilterResponse& from);
  void MergeFrom(const MoveFilterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.MoveFilterResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static MoveFilterResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetStackInfoRequest : public ::google::protobuf::Message {
 public:
  GetStackInfoRequest();
  virtual ~GetStackInfoRequest();

  GetStackInfoRequest(const GetStackInfoRequest& from);

  inline GetStackInfoRequest& operator=(const GetStackInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetStackInfoRequest& default_instance();

  void Swap(GetStackInfoRequest* other);

  // implements Message ----------------------------------------------

  GetStackInfoRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetStackInfoRequest& from);
  void MergeFrom(const GetStackInfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.GetStackInfoRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetStackInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetStackInfoResponse : public ::google::protobuf::Message {
 public:
  GetStackInfoResponse();
  virtual ~GetStackInfoResponse();

  GetStackInfoResponse(const GetStackInfoResponse& from);

  inline GetStackInfoResponse& operator=(const GetStackInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetStackInfoResponse& default_instance();

  void Swap(GetStackInfoResponse* other);

  // implements Message ----------------------------------------------

  GetStackInfoResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetStackInfoResponse& from);
  void MergeFrom(const GetStackInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string filterIds = 1;
  inline int filterids_size() const;
  inline void clear_filterids();
  static const int kFilterIdsFieldNumber = 1;
  inline const ::std::string& filterids(int index) const;
  inline ::std::string* mutable_filterids(int index);
  inline void set_filterids(int index, const ::std::string& value);
  inline void set_filterids(int index, const char* value);
  inline void set_filterids(int index, const char* value, size_t size);
  inline ::std::string* add_filterids();
  inline void add_filterids(const ::std::string& value);
  inline void add_filterids(const char* value);
  inline void add_filterids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& filterids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filterids();

  // @@protoc_insertion_point(class_scope:AnselIpc.GetStackInfoResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filterids_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetStackInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class FilterProperties_ValuesFloat : public ::google::protobuf::Message {
 public:
  FilterProperties_ValuesFloat();
  virtual ~FilterProperties_ValuesFloat();

  FilterProperties_ValuesFloat(const FilterProperties_ValuesFloat& from);

  inline FilterProperties_ValuesFloat& operator=(const FilterProperties_ValuesFloat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterProperties_ValuesFloat& default_instance();

  void Swap(FilterProperties_ValuesFloat* other);

  // implements Message ----------------------------------------------

  FilterProperties_ValuesFloat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FilterProperties_ValuesFloat& from);
  void MergeFrom(const FilterProperties_ValuesFloat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float current = 1;
  inline bool has_lwrrent() const;
  inline void clear_lwrrent();
  static const int kLwrrentFieldNumber = 1;
  inline float current() const;
  inline void set_lwrrent(float value);

  // required float default = 2;
  inline bool has_default_() const;
  inline void clear_default_();
  static const int kDefaultFieldNumber = 2;
  inline float default_() const;
  inline void set_default_(float value);

  // required float minimum = 3;
  inline bool has_minimum() const;
  inline void clear_minimum();
  static const int kMinimumFieldNumber = 3;
  inline float minimum() const;
  inline void set_minimum(float value);

  // required float maximum = 4;
  inline bool has_maximum() const;
  inline void clear_maximum();
  static const int kMaximumFieldNumber = 4;
  inline float maximum() const;
  inline void set_maximum(float value);

  // required float stepSize = 5;
  inline bool has_stepsize() const;
  inline void clear_stepsize();
  static const int kStepSizeFieldNumber = 5;
  inline float stepsize() const;
  inline void set_stepsize(float value);

  // optional float stepSizeUi = 6;
  inline bool has_stepsizeui() const;
  inline void clear_stepsizeui();
  static const int kStepSizeUiFieldNumber = 6;
  inline float stepsizeui() const;
  inline void set_stepsizeui(float value);

  // optional float milwalueUi = 7;
  inline bool has_milwalueui() const;
  inline void clear_milwalueui();
  static const int kMilwalueUiFieldNumber = 7;
  inline float milwalueui() const;
  inline void set_milwalueui(float value);

  // optional float maxValueUi = 8;
  inline bool has_maxvalueui() const;
  inline void clear_maxvalueui();
  static const int kMaxValueUiFieldNumber = 8;
  inline float maxvalueui() const;
  inline void set_maxvalueui(float value);

  // optional string displayName = 9;
  inline bool has_displayname() const;
  inline void clear_displayname();
  static const int kDisplayNameFieldNumber = 9;
  inline const ::std::string& displayname() const;
  inline void set_displayname(const ::std::string& value);
  inline void set_displayname(const char* value);
  inline void set_displayname(const char* value, size_t size);
  inline ::std::string* mutable_displayname();
  inline ::std::string* release_displayname();
  inline void set_allocated_displayname(::std::string* displayname);

  // @@protoc_insertion_point(class_scope:AnselIpc.FilterProperties.ValuesFloat)
 private:
  inline void set_has_lwrrent();
  inline void clear_has_lwrrent();
  inline void set_has_default_();
  inline void clear_has_default_();
  inline void set_has_minimum();
  inline void clear_has_minimum();
  inline void set_has_maximum();
  inline void clear_has_maximum();
  inline void set_has_stepsize();
  inline void clear_has_stepsize();
  inline void set_has_stepsizeui();
  inline void clear_has_stepsizeui();
  inline void set_has_milwalueui();
  inline void clear_has_milwalueui();
  inline void set_has_maxvalueui();
  inline void clear_has_maxvalueui();
  inline void set_has_displayname();
  inline void clear_has_displayname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float lwrrent_;
  float default__;
  float minimum_;
  float maximum_;
  float stepsize_;
  float stepsizeui_;
  float milwalueui_;
  float maxvalueui_;
  ::std::string* displayname_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static FilterProperties_ValuesFloat* default_instance_;
};
// -------------------------------------------------------------------

class FilterProperties_ValuesInt : public ::google::protobuf::Message {
 public:
  FilterProperties_ValuesInt();
  virtual ~FilterProperties_ValuesInt();

  FilterProperties_ValuesInt(const FilterProperties_ValuesInt& from);

  inline FilterProperties_ValuesInt& operator=(const FilterProperties_ValuesInt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterProperties_ValuesInt& default_instance();

  void Swap(FilterProperties_ValuesInt* other);

  // implements Message ----------------------------------------------

  FilterProperties_ValuesInt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FilterProperties_ValuesInt& from);
  void MergeFrom(const FilterProperties_ValuesInt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 current = 1;
  inline bool has_lwrrent() const;
  inline void clear_lwrrent();
  static const int kLwrrentFieldNumber = 1;
  inline ::google::protobuf::int32 current() const;
  inline void set_lwrrent(::google::protobuf::int32 value);

  // required int32 default = 2;
  inline bool has_default_() const;
  inline void clear_default_();
  static const int kDefaultFieldNumber = 2;
  inline ::google::protobuf::int32 default_() const;
  inline void set_default_(::google::protobuf::int32 value);

  // required int32 minimum = 3;
  inline bool has_minimum() const;
  inline void clear_minimum();
  static const int kMinimumFieldNumber = 3;
  inline ::google::protobuf::int32 minimum() const;
  inline void set_minimum(::google::protobuf::int32 value);

  // required int32 maximum = 4;
  inline bool has_maximum() const;
  inline void clear_maximum();
  static const int kMaximumFieldNumber = 4;
  inline ::google::protobuf::int32 maximum() const;
  inline void set_maximum(::google::protobuf::int32 value);

  // required uint32 stepSize = 5;
  inline bool has_stepsize() const;
  inline void clear_stepsize();
  static const int kStepSizeFieldNumber = 5;
  inline ::google::protobuf::uint32 stepsize() const;
  inline void set_stepsize(::google::protobuf::uint32 value);

  // optional uint32 stepSizeUi = 6;
  inline bool has_stepsizeui() const;
  inline void clear_stepsizeui();
  static const int kStepSizeUiFieldNumber = 6;
  inline ::google::protobuf::uint32 stepsizeui() const;
  inline void set_stepsizeui(::google::protobuf::uint32 value);

  // optional int32 milwalueUi = 7;
  inline bool has_milwalueui() const;
  inline void clear_milwalueui();
  static const int kMilwalueUiFieldNumber = 7;
  inline ::google::protobuf::int32 milwalueui() const;
  inline void set_milwalueui(::google::protobuf::int32 value);

  // optional int32 maxValueUi = 8;
  inline bool has_maxvalueui() const;
  inline void clear_maxvalueui();
  static const int kMaxValueUiFieldNumber = 8;
  inline ::google::protobuf::int32 maxvalueui() const;
  inline void set_maxvalueui(::google::protobuf::int32 value);

  // optional string displayName = 9;
  inline bool has_displayname() const;
  inline void clear_displayname();
  static const int kDisplayNameFieldNumber = 9;
  inline const ::std::string& displayname() const;
  inline void set_displayname(const ::std::string& value);
  inline void set_displayname(const char* value);
  inline void set_displayname(const char* value, size_t size);
  inline ::std::string* mutable_displayname();
  inline ::std::string* release_displayname();
  inline void set_allocated_displayname(::std::string* displayname);

  // @@protoc_insertion_point(class_scope:AnselIpc.FilterProperties.ValuesInt)
 private:
  inline void set_has_lwrrent();
  inline void clear_has_lwrrent();
  inline void set_has_default_();
  inline void clear_has_default_();
  inline void set_has_minimum();
  inline void clear_has_minimum();
  inline void set_has_maximum();
  inline void clear_has_maximum();
  inline void set_has_stepsize();
  inline void clear_has_stepsize();
  inline void set_has_stepsizeui();
  inline void clear_has_stepsizeui();
  inline void set_has_milwalueui();
  inline void clear_has_milwalueui();
  inline void set_has_maxvalueui();
  inline void clear_has_maxvalueui();
  inline void set_has_displayname();
  inline void clear_has_displayname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 lwrrent_;
  ::google::protobuf::int32 default__;
  ::google::protobuf::int32 minimum_;
  ::google::protobuf::int32 maximum_;
  ::google::protobuf::uint32 stepsize_;
  ::google::protobuf::uint32 stepsizeui_;
  ::google::protobuf::int32 milwalueui_;
  ::google::protobuf::int32 maxvalueui_;
  ::std::string* displayname_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static FilterProperties_ValuesInt* default_instance_;
};
// -------------------------------------------------------------------

class FilterProperties_ValuesUInt : public ::google::protobuf::Message {
 public:
  FilterProperties_ValuesUInt();
  virtual ~FilterProperties_ValuesUInt();

  FilterProperties_ValuesUInt(const FilterProperties_ValuesUInt& from);

  inline FilterProperties_ValuesUInt& operator=(const FilterProperties_ValuesUInt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterProperties_ValuesUInt& default_instance();

  void Swap(FilterProperties_ValuesUInt* other);

  // implements Message ----------------------------------------------

  FilterProperties_ValuesUInt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FilterProperties_ValuesUInt& from);
  void MergeFrom(const FilterProperties_ValuesUInt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 current = 1;
  inline bool has_lwrrent() const;
  inline void clear_lwrrent();
  static const int kLwrrentFieldNumber = 1;
  inline ::google::protobuf::uint32 current() const;
  inline void set_lwrrent(::google::protobuf::uint32 value);

  // required uint32 default = 2;
  inline bool has_default_() const;
  inline void clear_default_();
  static const int kDefaultFieldNumber = 2;
  inline ::google::protobuf::uint32 default_() const;
  inline void set_default_(::google::protobuf::uint32 value);

  // required uint32 minimum = 3;
  inline bool has_minimum() const;
  inline void clear_minimum();
  static const int kMinimumFieldNumber = 3;
  inline ::google::protobuf::uint32 minimum() const;
  inline void set_minimum(::google::protobuf::uint32 value);

  // required uint32 maximum = 4;
  inline bool has_maximum() const;
  inline void clear_maximum();
  static const int kMaximumFieldNumber = 4;
  inline ::google::protobuf::uint32 maximum() const;
  inline void set_maximum(::google::protobuf::uint32 value);

  // required uint32 stepSize = 5;
  inline bool has_stepsize() const;
  inline void clear_stepsize();
  static const int kStepSizeFieldNumber = 5;
  inline ::google::protobuf::uint32 stepsize() const;
  inline void set_stepsize(::google::protobuf::uint32 value);

  // optional uint32 stepSizeUi = 6;
  inline bool has_stepsizeui() const;
  inline void clear_stepsizeui();
  static const int kStepSizeUiFieldNumber = 6;
  inline ::google::protobuf::uint32 stepsizeui() const;
  inline void set_stepsizeui(::google::protobuf::uint32 value);

  // optional uint32 milwalueUi = 7;
  inline bool has_milwalueui() const;
  inline void clear_milwalueui();
  static const int kMilwalueUiFieldNumber = 7;
  inline ::google::protobuf::uint32 milwalueui() const;
  inline void set_milwalueui(::google::protobuf::uint32 value);

  // optional uint32 maxValueUi = 8;
  inline bool has_maxvalueui() const;
  inline void clear_maxvalueui();
  static const int kMaxValueUiFieldNumber = 8;
  inline ::google::protobuf::uint32 maxvalueui() const;
  inline void set_maxvalueui(::google::protobuf::uint32 value);

  // optional string displayName = 9;
  inline bool has_displayname() const;
  inline void clear_displayname();
  static const int kDisplayNameFieldNumber = 9;
  inline const ::std::string& displayname() const;
  inline void set_displayname(const ::std::string& value);
  inline void set_displayname(const char* value);
  inline void set_displayname(const char* value, size_t size);
  inline ::std::string* mutable_displayname();
  inline ::std::string* release_displayname();
  inline void set_allocated_displayname(::std::string* displayname);

  // @@protoc_insertion_point(class_scope:AnselIpc.FilterProperties.ValuesUInt)
 private:
  inline void set_has_lwrrent();
  inline void clear_has_lwrrent();
  inline void set_has_default_();
  inline void clear_has_default_();
  inline void set_has_minimum();
  inline void clear_has_minimum();
  inline void set_has_maximum();
  inline void clear_has_maximum();
  inline void set_has_stepsize();
  inline void clear_has_stepsize();
  inline void set_has_stepsizeui();
  inline void clear_has_stepsizeui();
  inline void set_has_milwalueui();
  inline void clear_has_milwalueui();
  inline void set_has_maxvalueui();
  inline void clear_has_maxvalueui();
  inline void set_has_displayname();
  inline void clear_has_displayname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 lwrrent_;
  ::google::protobuf::uint32 default__;
  ::google::protobuf::uint32 minimum_;
  ::google::protobuf::uint32 maximum_;
  ::google::protobuf::uint32 stepsize_;
  ::google::protobuf::uint32 stepsizeui_;
  ::google::protobuf::uint32 milwalueui_;
  ::google::protobuf::uint32 maxvalueui_;
  ::std::string* displayname_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static FilterProperties_ValuesUInt* default_instance_;
};
// -------------------------------------------------------------------

class FilterProperties_ValuesBool : public ::google::protobuf::Message {
 public:
  FilterProperties_ValuesBool();
  virtual ~FilterProperties_ValuesBool();

  FilterProperties_ValuesBool(const FilterProperties_ValuesBool& from);

  inline FilterProperties_ValuesBool& operator=(const FilterProperties_ValuesBool& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterProperties_ValuesBool& default_instance();

  void Swap(FilterProperties_ValuesBool* other);

  // implements Message ----------------------------------------------

  FilterProperties_ValuesBool* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FilterProperties_ValuesBool& from);
  void MergeFrom(const FilterProperties_ValuesBool& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool current = 1;
  inline bool has_lwrrent() const;
  inline void clear_lwrrent();
  static const int kLwrrentFieldNumber = 1;
  inline bool current() const;
  inline void set_lwrrent(bool value);

  // required bool default = 2;
  inline bool has_default_() const;
  inline void clear_default_();
  static const int kDefaultFieldNumber = 2;
  inline bool default_() const;
  inline void set_default_(bool value);

  // required bool minimum = 3;
  inline bool has_minimum() const;
  inline void clear_minimum();
  static const int kMinimumFieldNumber = 3;
  inline bool minimum() const;
  inline void set_minimum(bool value);

  // required bool maximum = 4;
  inline bool has_maximum() const;
  inline void clear_maximum();
  static const int kMaximumFieldNumber = 4;
  inline bool maximum() const;
  inline void set_maximum(bool value);

  // optional string displayName = 5;
  inline bool has_displayname() const;
  inline void clear_displayname();
  static const int kDisplayNameFieldNumber = 5;
  inline const ::std::string& displayname() const;
  inline void set_displayname(const ::std::string& value);
  inline void set_displayname(const char* value);
  inline void set_displayname(const char* value, size_t size);
  inline ::std::string* mutable_displayname();
  inline ::std::string* release_displayname();
  inline void set_allocated_displayname(::std::string* displayname);

  // @@protoc_insertion_point(class_scope:AnselIpc.FilterProperties.ValuesBool)
 private:
  inline void set_has_lwrrent();
  inline void clear_has_lwrrent();
  inline void set_has_default_();
  inline void clear_has_default_();
  inline void set_has_minimum();
  inline void clear_has_minimum();
  inline void set_has_maximum();
  inline void clear_has_maximum();
  inline void set_has_displayname();
  inline void clear_has_displayname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* displayname_;
  bool lwrrent_;
  bool default__;
  bool minimum_;
  bool maximum_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static FilterProperties_ValuesBool* default_instance_;
};
// -------------------------------------------------------------------

class FilterProperties_ControlDescription : public ::google::protobuf::Message {
 public:
  FilterProperties_ControlDescription();
  virtual ~FilterProperties_ControlDescription();

  FilterProperties_ControlDescription(const FilterProperties_ControlDescription& from);

  inline FilterProperties_ControlDescription& operator=(const FilterProperties_ControlDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterProperties_ControlDescription& default_instance();

  void Swap(FilterProperties_ControlDescription* other);

  // implements Message ----------------------------------------------

  FilterProperties_ControlDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FilterProperties_ControlDescription& from);
  void MergeFrom(const FilterProperties_ControlDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 controlId = 1;
  inline bool has_controlid() const;
  inline void clear_controlid();
  static const int kControlIdFieldNumber = 1;
  inline ::google::protobuf::int32 controlid() const;
  inline void set_controlid(::google::protobuf::int32 value);

  // required string displayName = 2;
  inline bool has_displayname() const;
  inline void clear_displayname();
  static const int kDisplayNameFieldNumber = 2;
  inline const ::std::string& displayname() const;
  inline void set_displayname(const ::std::string& value);
  inline void set_displayname(const char* value);
  inline void set_displayname(const char* value, size_t size);
  inline ::std::string* mutable_displayname();
  inline ::std::string* release_displayname();
  inline void set_allocated_displayname(::std::string* displayname);

  // required float milwalueUi = 3;
  inline bool has_milwalueui() const;
  inline void clear_milwalueui();
  static const int kMilwalueUiFieldNumber = 3;
  inline float milwalueui() const;
  inline void set_milwalueui(float value);

  // required float maxValueUi = 4;
  inline bool has_maxvalueui() const;
  inline void clear_maxvalueui();
  static const int kMaxValueUiFieldNumber = 4;
  inline float maxvalueui() const;
  inline void set_maxvalueui(float value);

  // required .AnselIpc.ControlType type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::AnselIpc::ControlType type() const;
  inline void set_type(::AnselIpc::ControlType value);

  // repeated .AnselIpc.FilterProperties.ValuesFloat valuesFloat = 6;
  inline int valuesfloat_size() const;
  inline void clear_valuesfloat();
  static const int kValuesFloatFieldNumber = 6;
  inline const ::AnselIpc::FilterProperties_ValuesFloat& valuesfloat(int index) const;
  inline ::AnselIpc::FilterProperties_ValuesFloat* mutable_valuesfloat(int index);
  inline ::AnselIpc::FilterProperties_ValuesFloat* add_valuesfloat();
  inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ValuesFloat >&
      valuesfloat() const;
  inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ValuesFloat >*
      mutable_valuesfloat();

  // repeated .AnselIpc.FilterProperties.ValuesBool valuesBool = 7;
  inline int valuesbool_size() const;
  inline void clear_valuesbool();
  static const int kValuesBoolFieldNumber = 7;
  inline const ::AnselIpc::FilterProperties_ValuesBool& valuesbool(int index) const;
  inline ::AnselIpc::FilterProperties_ValuesBool* mutable_valuesbool(int index);
  inline ::AnselIpc::FilterProperties_ValuesBool* add_valuesbool();
  inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ValuesBool >&
      valuesbool() const;
  inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ValuesBool >*
      mutable_valuesbool();

  // repeated .AnselIpc.FilterProperties.ValuesInt valuesInt = 8;
  inline int valuesint_size() const;
  inline void clear_valuesint();
  static const int kValuesIntFieldNumber = 8;
  inline const ::AnselIpc::FilterProperties_ValuesInt& valuesint(int index) const;
  inline ::AnselIpc::FilterProperties_ValuesInt* mutable_valuesint(int index);
  inline ::AnselIpc::FilterProperties_ValuesInt* add_valuesint();
  inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ValuesInt >&
      valuesint() const;
  inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ValuesInt >*
      mutable_valuesint();

  // repeated .AnselIpc.FilterProperties.ValuesUInt valuesUInt = 9;
  inline int valuesuint_size() const;
  inline void clear_valuesuint();
  static const int kValuesUIntFieldNumber = 9;
  inline const ::AnselIpc::FilterProperties_ValuesUInt& valuesuint(int index) const;
  inline ::AnselIpc::FilterProperties_ValuesUInt* mutable_valuesuint(int index);
  inline ::AnselIpc::FilterProperties_ValuesUInt* add_valuesuint();
  inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ValuesUInt >&
      valuesuint() const;
  inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ValuesUInt >*
      mutable_valuesuint();

  // required int32 uiPrecision = 10;
  inline bool has_uiprecision() const;
  inline void clear_uiprecision();
  static const int kUiPrecisionFieldNumber = 10;
  inline ::google::protobuf::int32 uiprecision() const;
  inline void set_uiprecision(::google::protobuf::int32 value);

  // optional string uiMeasurementUnit = 11;
  inline bool has_uimeasurementunit() const;
  inline void clear_uimeasurementunit();
  static const int kUiMeasurementUnitFieldNumber = 11;
  inline const ::std::string& uimeasurementunit() const;
  inline void set_uimeasurementunit(const ::std::string& value);
  inline void set_uimeasurementunit(const char* value);
  inline void set_uimeasurementunit(const char* value, size_t size);
  inline ::std::string* mutable_uimeasurementunit();
  inline ::std::string* release_uimeasurementunit();
  inline void set_allocated_uimeasurementunit(::std::string* uimeasurementunit);

  // repeated string labelsUi = 12;
  inline int labelsui_size() const;
  inline void clear_labelsui();
  static const int kLabelsUiFieldNumber = 12;
  inline const ::std::string& labelsui(int index) const;
  inline ::std::string* mutable_labelsui(int index);
  inline void set_labelsui(int index, const ::std::string& value);
  inline void set_labelsui(int index, const char* value);
  inline void set_labelsui(int index, const char* value, size_t size);
  inline ::std::string* add_labelsui();
  inline void add_labelsui(const ::std::string& value);
  inline void add_labelsui(const char* value);
  inline void add_labelsui(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& labelsui() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_labelsui();

  // optional string tooltip = 13;
  inline bool has_tooltip() const;
  inline void clear_tooltip();
  static const int kTooltipFieldNumber = 13;
  inline const ::std::string& tooltip() const;
  inline void set_tooltip(const ::std::string& value);
  inline void set_tooltip(const char* value);
  inline void set_tooltip(const char* value, size_t size);
  inline ::std::string* mutable_tooltip();
  inline ::std::string* release_tooltip();
  inline void set_allocated_tooltip(::std::string* tooltip);

  // optional string displayNameEnglish = 14;
  inline bool has_displaynameenglish() const;
  inline void clear_displaynameenglish();
  static const int kDisplayNameEnglishFieldNumber = 14;
  inline const ::std::string& displaynameenglish() const;
  inline void set_displaynameenglish(const ::std::string& value);
  inline void set_displaynameenglish(const char* value);
  inline void set_displaynameenglish(const char* value, size_t size);
  inline ::std::string* mutable_displaynameenglish();
  inline ::std::string* release_displaynameenglish();
  inline void set_allocated_displaynameenglish(::std::string* displaynameenglish);

  // @@protoc_insertion_point(class_scope:AnselIpc.FilterProperties.ControlDescription)
 private:
  inline void set_has_controlid();
  inline void clear_has_controlid();
  inline void set_has_displayname();
  inline void clear_has_displayname();
  inline void set_has_milwalueui();
  inline void clear_has_milwalueui();
  inline void set_has_maxvalueui();
  inline void clear_has_maxvalueui();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_uiprecision();
  inline void clear_has_uiprecision();
  inline void set_has_uimeasurementunit();
  inline void clear_has_uimeasurementunit();
  inline void set_has_tooltip();
  inline void clear_has_tooltip();
  inline void set_has_displaynameenglish();
  inline void clear_has_displaynameenglish();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* displayname_;
  ::google::protobuf::int32 controlid_;
  float milwalueui_;
  float maxvalueui_;
  int type_;
  ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ValuesFloat > valuesfloat_;
  ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ValuesBool > valuesbool_;
  ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ValuesInt > valuesint_;
  ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ValuesUInt > valuesuint_;
  ::std::string* uimeasurementunit_;
  ::google::protobuf::RepeatedPtrField< ::std::string> labelsui_;
  ::std::string* tooltip_;
  ::std::string* displaynameenglish_;
  ::google::protobuf::int32 uiprecision_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static FilterProperties_ControlDescription* default_instance_;
};
// -------------------------------------------------------------------

class FilterProperties : public ::google::protobuf::Message {
 public:
  FilterProperties();
  virtual ~FilterProperties();

  FilterProperties(const FilterProperties& from);

  inline FilterProperties& operator=(const FilterProperties& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterProperties& default_instance();

  void Swap(FilterProperties* other);

  // implements Message ----------------------------------------------

  FilterProperties* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FilterProperties& from);
  void MergeFrom(const FilterProperties& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FilterProperties_ValuesFloat ValuesFloat;
  typedef FilterProperties_ValuesInt ValuesInt;
  typedef FilterProperties_ValuesUInt ValuesUInt;
  typedef FilterProperties_ValuesBool ValuesBool;
  typedef FilterProperties_ControlDescription ControlDescription;

  // accessors -------------------------------------------------------

  // required string filterId = 1;
  inline bool has_filterid() const;
  inline void clear_filterid();
  static const int kFilterIdFieldNumber = 1;
  inline const ::std::string& filterid() const;
  inline void set_filterid(const ::std::string& value);
  inline void set_filterid(const char* value);
  inline void set_filterid(const char* value, size_t size);
  inline ::std::string* mutable_filterid();
  inline ::std::string* release_filterid();
  inline void set_allocated_filterid(::std::string* filterid);

  // required string filterDisplayName = 2;
  inline bool has_filterdisplayname() const;
  inline void clear_filterdisplayname();
  static const int kFilterDisplayNameFieldNumber = 2;
  inline const ::std::string& filterdisplayname() const;
  inline void set_filterdisplayname(const ::std::string& value);
  inline void set_filterdisplayname(const char* value);
  inline void set_filterdisplayname(const char* value, size_t size);
  inline ::std::string* mutable_filterdisplayname();
  inline ::std::string* release_filterdisplayname();
  inline void set_allocated_filterdisplayname(::std::string* filterdisplayname);

  // repeated .AnselIpc.FilterProperties.ControlDescription controls = 3;
  inline int controls_size() const;
  inline void clear_controls();
  static const int kControlsFieldNumber = 3;
  inline const ::AnselIpc::FilterProperties_ControlDescription& controls(int index) const;
  inline ::AnselIpc::FilterProperties_ControlDescription* mutable_controls(int index);
  inline ::AnselIpc::FilterProperties_ControlDescription* add_controls();
  inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ControlDescription >&
      controls() const;
  inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ControlDescription >*
      mutable_controls();

  // optional string filterDisplayNameEnglish = 4;
  inline bool has_filterdisplaynameenglish() const;
  inline void clear_filterdisplaynameenglish();
  static const int kFilterDisplayNameEnglishFieldNumber = 4;
  inline const ::std::string& filterdisplaynameenglish() const;
  inline void set_filterdisplaynameenglish(const ::std::string& value);
  inline void set_filterdisplaynameenglish(const char* value);
  inline void set_filterdisplaynameenglish(const char* value, size_t size);
  inline ::std::string* mutable_filterdisplaynameenglish();
  inline ::std::string* release_filterdisplaynameenglish();
  inline void set_allocated_filterdisplaynameenglish(::std::string* filterdisplaynameenglish);

  // @@protoc_insertion_point(class_scope:AnselIpc.FilterProperties)
 private:
  inline void set_has_filterid();
  inline void clear_has_filterid();
  inline void set_has_filterdisplayname();
  inline void clear_has_filterdisplayname();
  inline void set_has_filterdisplaynameenglish();
  inline void clear_has_filterdisplaynameenglish();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* filterid_;
  ::std::string* filterdisplayname_;
  ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ControlDescription > controls_;
  ::std::string* filterdisplaynameenglish_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static FilterProperties* default_instance_;
};
// -------------------------------------------------------------------

class GetFilterInfoRequest : public ::google::protobuf::Message {
 public:
  GetFilterInfoRequest();
  virtual ~GetFilterInfoRequest();

  GetFilterInfoRequest(const GetFilterInfoRequest& from);

  inline GetFilterInfoRequest& operator=(const GetFilterInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFilterInfoRequest& default_instance();

  void Swap(GetFilterInfoRequest* other);

  // implements Message ----------------------------------------------

  GetFilterInfoRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFilterInfoRequest& from);
  void MergeFrom(const GetFilterInfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 stackIdx = 1;
  inline bool has_stackidx() const;
  inline void clear_stackidx();
  static const int kStackIdxFieldNumber = 1;
  inline ::google::protobuf::int32 stackidx() const;
  inline void set_stackidx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AnselIpc.GetFilterInfoRequest)
 private:
  inline void set_has_stackidx();
  inline void clear_has_stackidx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 stackidx_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetFilterInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetFilterInfoResponse : public ::google::protobuf::Message {
 public:
  GetFilterInfoResponse();
  virtual ~GetFilterInfoResponse();

  GetFilterInfoResponse(const GetFilterInfoResponse& from);

  inline GetFilterInfoResponse& operator=(const GetFilterInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFilterInfoResponse& default_instance();

  void Swap(GetFilterInfoResponse* other);

  // implements Message ----------------------------------------------

  GetFilterInfoResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFilterInfoResponse& from);
  void MergeFrom(const GetFilterInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // required int32 stackIdx = 2;
  inline bool has_stackidx() const;
  inline void clear_stackidx();
  static const int kStackIdxFieldNumber = 2;
  inline ::google::protobuf::int32 stackidx() const;
  inline void set_stackidx(::google::protobuf::int32 value);

  // optional .AnselIpc.FilterProperties filterProperties = 3;
  inline bool has_filterproperties() const;
  inline void clear_filterproperties();
  static const int kFilterPropertiesFieldNumber = 3;
  inline const ::AnselIpc::FilterProperties& filterproperties() const;
  inline ::AnselIpc::FilterProperties* mutable_filterproperties();
  inline ::AnselIpc::FilterProperties* release_filterproperties();
  inline void set_allocated_filterproperties(::AnselIpc::FilterProperties* filterproperties);

  // @@protoc_insertion_point(class_scope:AnselIpc.GetFilterInfoResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_stackidx();
  inline void clear_has_stackidx();
  inline void set_has_filterproperties();
  inline void clear_has_filterproperties();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  ::google::protobuf::int32 stackidx_;
  ::AnselIpc::FilterProperties* filterproperties_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static GetFilterInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class IsAnselAvailableRequest : public ::google::protobuf::Message {
 public:
  IsAnselAvailableRequest();
  virtual ~IsAnselAvailableRequest();

  IsAnselAvailableRequest(const IsAnselAvailableRequest& from);

  inline IsAnselAvailableRequest& operator=(const IsAnselAvailableRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IsAnselAvailableRequest& default_instance();

  void Swap(IsAnselAvailableRequest* other);

  // implements Message ----------------------------------------------

  IsAnselAvailableRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IsAnselAvailableRequest& from);
  void MergeFrom(const IsAnselAvailableRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AnselIpc.IsAnselAvailableRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static IsAnselAvailableRequest* default_instance_;
};
// -------------------------------------------------------------------

class IsAnselAvailableResponse : public ::google::protobuf::Message {
 public:
  IsAnselAvailableResponse();
  virtual ~IsAnselAvailableResponse();

  IsAnselAvailableResponse(const IsAnselAvailableResponse& from);

  inline IsAnselAvailableResponse& operator=(const IsAnselAvailableResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IsAnselAvailableResponse& default_instance();

  void Swap(IsAnselAvailableResponse* other);

  // implements Message ----------------------------------------------

  IsAnselAvailableResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IsAnselAvailableResponse& from);
  void MergeFrom(const IsAnselAvailableResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool available = 1;
  inline bool has_available() const;
  inline void clear_available();
  static const int kAvailableFieldNumber = 1;
  inline bool available() const;
  inline void set_available(bool value);

  // @@protoc_insertion_point(class_scope:AnselIpc.IsAnselAvailableResponse)
 private:
  inline void set_has_available();
  inline void clear_has_available();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool available_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static IsAnselAvailableResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetFilterAttributeRequest : public ::google::protobuf::Message {
 public:
  SetFilterAttributeRequest();
  virtual ~SetFilterAttributeRequest();

  SetFilterAttributeRequest(const SetFilterAttributeRequest& from);

  inline SetFilterAttributeRequest& operator=(const SetFilterAttributeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetFilterAttributeRequest& default_instance();

  void Swap(SetFilterAttributeRequest* other);

  // implements Message ----------------------------------------------

  SetFilterAttributeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetFilterAttributeRequest& from);
  void MergeFrom(const SetFilterAttributeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string filterId = 1;
  inline bool has_filterid() const;
  inline void clear_filterid();
  static const int kFilterIdFieldNumber = 1;
  inline const ::std::string& filterid() const;
  inline void set_filterid(const ::std::string& value);
  inline void set_filterid(const char* value);
  inline void set_filterid(const char* value, size_t size);
  inline ::std::string* mutable_filterid();
  inline ::std::string* release_filterid();
  inline void set_allocated_filterid(::std::string* filterid);

  // required int32 stackIdx = 2;
  inline bool has_stackidx() const;
  inline void clear_stackidx();
  static const int kStackIdxFieldNumber = 2;
  inline ::google::protobuf::int32 stackidx() const;
  inline void set_stackidx(::google::protobuf::int32 value);

  // required int32 controlId = 3;
  inline bool has_controlid() const;
  inline void clear_controlid();
  static const int kControlIdFieldNumber = 3;
  inline ::google::protobuf::int32 controlid() const;
  inline void set_controlid(::google::protobuf::int32 value);

  // repeated float floatValue = 4;
  inline int floatvalue_size() const;
  inline void clear_floatvalue();
  static const int kFloatValueFieldNumber = 4;
  inline float floatvalue(int index) const;
  inline void set_floatvalue(int index, float value);
  inline void add_floatvalue(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      floatvalue() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_floatvalue();

  // repeated bool boolValue = 5;
  inline int boolvalue_size() const;
  inline void clear_boolvalue();
  static const int kBoolValueFieldNumber = 5;
  inline bool boolvalue(int index) const;
  inline void set_boolvalue(int index, bool value);
  inline void add_boolvalue(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      boolvalue() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_boolvalue();

  // repeated uint32 uintValue = 6;
  inline int uintvalue_size() const;
  inline void clear_uintvalue();
  static const int kUintValueFieldNumber = 6;
  inline ::google::protobuf::uint32 uintvalue(int index) const;
  inline void set_uintvalue(int index, ::google::protobuf::uint32 value);
  inline void add_uintvalue(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      uintvalue() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_uintvalue();

  // repeated int32 intValue = 7;
  inline int intvalue_size() const;
  inline void clear_intvalue();
  static const int kIntValueFieldNumber = 7;
  inline ::google::protobuf::int32 intvalue(int index) const;
  inline void set_intvalue(int index, ::google::protobuf::int32 value);
  inline void add_intvalue(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      intvalue() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_intvalue();

  // @@protoc_insertion_point(class_scope:AnselIpc.SetFilterAttributeRequest)
 private:
  inline void set_has_filterid();
  inline void clear_has_filterid();
  inline void set_has_stackidx();
  inline void clear_has_stackidx();
  inline void set_has_controlid();
  inline void clear_has_controlid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* filterid_;
  ::google::protobuf::int32 stackidx_;
  ::google::protobuf::int32 controlid_;
  ::google::protobuf::RepeatedField< float > floatvalue_;
  ::google::protobuf::RepeatedField< bool > boolvalue_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > uintvalue_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > intvalue_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetFilterAttributeRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetFilterAttributeResponse : public ::google::protobuf::Message {
 public:
  SetFilterAttributeResponse();
  virtual ~SetFilterAttributeResponse();

  SetFilterAttributeResponse(const SetFilterAttributeResponse& from);

  inline SetFilterAttributeResponse& operator=(const SetFilterAttributeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetFilterAttributeResponse& default_instance();

  void Swap(SetFilterAttributeResponse* other);

  // implements Message ----------------------------------------------

  SetFilterAttributeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetFilterAttributeResponse& from);
  void MergeFrom(const SetFilterAttributeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetFilterAttributeResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetFilterAttributeResponse* default_instance_;
};
// -------------------------------------------------------------------

class MouseEventRequest : public ::google::protobuf::Message {
 public:
  MouseEventRequest();
  virtual ~MouseEventRequest();

  MouseEventRequest(const MouseEventRequest& from);

  inline MouseEventRequest& operator=(const MouseEventRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MouseEventRequest& default_instance();

  void Swap(MouseEventRequest* other);

  // implements Message ----------------------------------------------

  MouseEventRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MouseEventRequest& from);
  void MergeFrom(const MouseEventRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float absoluteX = 1;
  inline bool has_absolutex() const;
  inline void clear_absolutex();
  static const int kAbsoluteXFieldNumber = 1;
  inline float absolutex() const;
  inline void set_absolutex(float value);

  // optional float absoluteY = 2;
  inline bool has_absolutey() const;
  inline void clear_absolutey();
  static const int kAbsoluteYFieldNumber = 2;
  inline float absolutey() const;
  inline void set_absolutey(float value);

  // optional float deltaX = 3;
  inline bool has_deltax() const;
  inline void clear_deltax();
  static const int kDeltaXFieldNumber = 3;
  inline float deltax() const;
  inline void set_deltax(float value);

  // optional float deltaY = 4;
  inline bool has_deltay() const;
  inline void clear_deltay();
  static const int kDeltaYFieldNumber = 4;
  inline float deltay() const;
  inline void set_deltay(float value);

  // required int32 keyState = 5;
  inline bool has_keystate() const;
  inline void clear_keystate();
  static const int kKeyStateFieldNumber = 5;
  inline ::google::protobuf::int32 keystate() const;
  inline void set_keystate(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AnselIpc.MouseEventRequest)
 private:
  inline void set_has_absolutex();
  inline void clear_has_absolutex();
  inline void set_has_absolutey();
  inline void clear_has_absolutey();
  inline void set_has_deltax();
  inline void clear_has_deltax();
  inline void set_has_deltay();
  inline void clear_has_deltay();
  inline void set_has_keystate();
  inline void clear_has_keystate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float absolutex_;
  float absolutey_;
  float deltax_;
  float deltay_;
  ::google::protobuf::int32 keystate_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static MouseEventRequest* default_instance_;
};
// -------------------------------------------------------------------

class KeyboardEventRequest : public ::google::protobuf::Message {
 public:
  KeyboardEventRequest();
  virtual ~KeyboardEventRequest();

  KeyboardEventRequest(const KeyboardEventRequest& from);

  inline KeyboardEventRequest& operator=(const KeyboardEventRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyboardEventRequest& default_instance();

  void Swap(KeyboardEventRequest* other);

  // implements Message ----------------------------------------------

  KeyboardEventRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyboardEventRequest& from);
  void MergeFrom(const KeyboardEventRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline ::google::protobuf::int32 key() const;
  inline void set_key(::google::protobuf::int32 value);

  // required .AnselIpc.State state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::AnselIpc::State state() const;
  inline void set_state(::AnselIpc::State value);

  // @@protoc_insertion_point(class_scope:AnselIpc.KeyboardEventRequest)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 key_;
  int state_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static KeyboardEventRequest* default_instance_;
};
// -------------------------------------------------------------------

class InputEventRequest : public ::google::protobuf::Message {
 public:
  InputEventRequest();
  virtual ~InputEventRequest();

  InputEventRequest(const InputEventRequest& from);

  inline InputEventRequest& operator=(const InputEventRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InputEventRequest& default_instance();

  void Swap(InputEventRequest* other);

  // implements Message ----------------------------------------------

  InputEventRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InputEventRequest& from);
  void MergeFrom(const InputEventRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline ::google::protobuf::int32 message() const;
  inline void set_message(::google::protobuf::int32 value);

  // required int32 wParam = 2;
  inline bool has_wparam() const;
  inline void clear_wparam();
  static const int kWParamFieldNumber = 2;
  inline ::google::protobuf::int32 wparam() const;
  inline void set_wparam(::google::protobuf::int32 value);

  // required int32 lParam = 3;
  inline bool has_lparam() const;
  inline void clear_lparam();
  static const int kLParamFieldNumber = 3;
  inline ::google::protobuf::int32 lparam() const;
  inline void set_lparam(::google::protobuf::int32 value);

  // optional bool isDeltaCoords = 4;
  inline bool has_isdeltacoords() const;
  inline void clear_isdeltacoords();
  static const int kIsDeltaCoordsFieldNumber = 4;
  inline bool isdeltacoords() const;
  inline void set_isdeltacoords(bool value);

  // optional float leftStickXValue = 5;
  inline bool has_leftstickxvalue() const;
  inline void clear_leftstickxvalue();
  static const int kLeftStickXValueFieldNumber = 5;
  inline float leftstickxvalue() const;
  inline void set_leftstickxvalue(float value);

  // optional float leftStickYValue = 6;
  inline bool has_leftstickyvalue() const;
  inline void clear_leftstickyvalue();
  static const int kLeftStickYValueFieldNumber = 6;
  inline float leftstickyvalue() const;
  inline void set_leftstickyvalue(float value);

  // optional float rightStickXValue = 7;
  inline bool has_rightstickxvalue() const;
  inline void clear_rightstickxvalue();
  static const int kRightStickXValueFieldNumber = 7;
  inline float rightstickxvalue() const;
  inline void set_rightstickxvalue(float value);

  // optional float rightStickYValue = 8;
  inline bool has_rightstickyvalue() const;
  inline void clear_rightstickyvalue();
  static const int kRightStickYValueFieldNumber = 8;
  inline float rightstickyvalue() const;
  inline void set_rightstickyvalue(float value);

  // optional float leftTriggerValue = 9;
  inline bool has_lefttriggervalue() const;
  inline void clear_lefttriggervalue();
  static const int kLeftTriggerValueFieldNumber = 9;
  inline float lefttriggervalue() const;
  inline void set_lefttriggervalue(float value);

  // optional float rightTriggerValue = 10;
  inline bool has_righttriggervalue() const;
  inline void clear_righttriggervalue();
  static const int kRightTriggerValueFieldNumber = 10;
  inline float righttriggervalue() const;
  inline void set_righttriggervalue(float value);

  // @@protoc_insertion_point(class_scope:AnselIpc.InputEventRequest)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_wparam();
  inline void clear_has_wparam();
  inline void set_has_lparam();
  inline void clear_has_lparam();
  inline void set_has_isdeltacoords();
  inline void clear_has_isdeltacoords();
  inline void set_has_leftstickxvalue();
  inline void clear_has_leftstickxvalue();
  inline void set_has_leftstickyvalue();
  inline void clear_has_leftstickyvalue();
  inline void set_has_rightstickxvalue();
  inline void clear_has_rightstickxvalue();
  inline void set_has_rightstickyvalue();
  inline void clear_has_rightstickyvalue();
  inline void set_has_lefttriggervalue();
  inline void clear_has_lefttriggervalue();
  inline void set_has_righttriggervalue();
  inline void clear_has_righttriggervalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 message_;
  ::google::protobuf::int32 wparam_;
  ::google::protobuf::int32 lparam_;
  bool isdeltacoords_;
  float leftstickxvalue_;
  float leftstickyvalue_;
  float rightstickxvalue_;
  float rightstickyvalue_;
  float lefttriggervalue_;
  float righttriggervalue_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static InputEventRequest* default_instance_;
};
// -------------------------------------------------------------------

class InputEventResponse : public ::google::protobuf::Message {
 public:
  InputEventResponse();
  virtual ~InputEventResponse();

  InputEventResponse(const InputEventResponse& from);

  inline InputEventResponse& operator=(const InputEventResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InputEventResponse& default_instance();

  void Swap(InputEventResponse* other);

  // implements Message ----------------------------------------------

  InputEventResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InputEventResponse& from);
  void MergeFrom(const InputEventResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.InputEventResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static InputEventResponse* default_instance_;
};
// -------------------------------------------------------------------

class MultipleInputEventRequest : public ::google::protobuf::Message {
 public:
  MultipleInputEventRequest();
  virtual ~MultipleInputEventRequest();

  MultipleInputEventRequest(const MultipleInputEventRequest& from);

  inline MultipleInputEventRequest& operator=(const MultipleInputEventRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultipleInputEventRequest& default_instance();

  void Swap(MultipleInputEventRequest* other);

  // implements Message ----------------------------------------------

  MultipleInputEventRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MultipleInputEventRequest& from);
  void MergeFrom(const MultipleInputEventRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AnselIpc.InputEventRequest inputEvents = 1;
  inline int inputevents_size() const;
  inline void clear_inputevents();
  static const int kInputEventsFieldNumber = 1;
  inline const ::AnselIpc::InputEventRequest& inputevents(int index) const;
  inline ::AnselIpc::InputEventRequest* mutable_inputevents(int index);
  inline ::AnselIpc::InputEventRequest* add_inputevents();
  inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::InputEventRequest >&
      inputevents() const;
  inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::InputEventRequest >*
      mutable_inputevents();

  // @@protoc_insertion_point(class_scope:AnselIpc.MultipleInputEventRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::AnselIpc::InputEventRequest > inputevents_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static MultipleInputEventRequest* default_instance_;
};
// -------------------------------------------------------------------

class LogFilenameResponse : public ::google::protobuf::Message {
 public:
  LogFilenameResponse();
  virtual ~LogFilenameResponse();

  LogFilenameResponse(const LogFilenameResponse& from);

  inline LogFilenameResponse& operator=(const LogFilenameResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogFilenameResponse& default_instance();

  void Swap(LogFilenameResponse* other);

  // implements Message ----------------------------------------------

  LogFilenameResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogFilenameResponse& from);
  void MergeFrom(const LogFilenameResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // @@protoc_insertion_point(class_scope:AnselIpc.LogFilenameResponse)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* filename_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static LogFilenameResponse* default_instance_;
};
// -------------------------------------------------------------------

class ReportErrorResponse : public ::google::protobuf::Message {
 public:
  ReportErrorResponse();
  virtual ~ReportErrorResponse();

  ReportErrorResponse(const ReportErrorResponse& from);

  inline ReportErrorResponse& operator=(const ReportErrorResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportErrorResponse& default_instance();

  void Swap(ReportErrorResponse* other);

  // implements Message ----------------------------------------------

  ReportErrorResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReportErrorResponse& from);
  void MergeFrom(const ReportErrorResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.ErrorType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::AnselIpc::ErrorType type() const;
  inline void set_type(::AnselIpc::ErrorType value);

  // required uint32 code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 code() const;
  inline void set_code(::google::protobuf::uint32 value);

  // required string filename = 3;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 3;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // required uint32 line = 4;
  inline bool has_line() const;
  inline void clear_line();
  static const int kLineFieldNumber = 4;
  inline ::google::protobuf::uint32 line() const;
  inline void set_line(::google::protobuf::uint32 value);

  // required string reason = 5;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 5;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // @@protoc_insertion_point(class_scope:AnselIpc.ReportErrorResponse)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_line();
  inline void clear_has_line();
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  ::google::protobuf::uint32 code_;
  ::std::string* filename_;
  ::std::string* reason_;
  ::google::protobuf::uint32 line_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static ReportErrorResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetHighQualityRequest : public ::google::protobuf::Message {
 public:
  SetHighQualityRequest();
  virtual ~SetHighQualityRequest();

  SetHighQualityRequest(const SetHighQualityRequest& from);

  inline SetHighQualityRequest& operator=(const SetHighQualityRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetHighQualityRequest& default_instance();

  void Swap(SetHighQualityRequest* other);

  // implements Message ----------------------------------------------

  SetHighQualityRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetHighQualityRequest& from);
  void MergeFrom(const SetHighQualityRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool setting = 1;
  inline bool has_setting() const;
  inline void clear_setting();
  static const int kSettingFieldNumber = 1;
  inline bool setting() const;
  inline void set_setting(bool value);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetHighQualityRequest)
 private:
  inline void set_has_setting();
  inline void clear_has_setting();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool setting_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetHighQualityRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetHighQualityResponse : public ::google::protobuf::Message {
 public:
  SetHighQualityResponse();
  virtual ~SetHighQualityResponse();

  SetHighQualityResponse(const SetHighQualityResponse& from);

  inline SetHighQualityResponse& operator=(const SetHighQualityResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetHighQualityResponse& default_instance();

  void Swap(SetHighQualityResponse* other);

  // implements Message ----------------------------------------------

  SetHighQualityResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetHighQualityResponse& from);
  void MergeFrom(const SetHighQualityResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AnselIpc.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::AnselIpc::Status status() const;
  inline void set_status(::AnselIpc::Status value);

  // @@protoc_insertion_point(class_scope:AnselIpc.SetHighQualityResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static SetHighQualityResponse* default_instance_;
};
// -------------------------------------------------------------------

class AnselIPCRequest : public ::google::protobuf::Message {
 public:
  AnselIPCRequest();
  virtual ~AnselIPCRequest();

  AnselIPCRequest(const AnselIPCRequest& from);

  inline AnselIPCRequest& operator=(const AnselIPCRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnselIPCRequest& default_instance();

  enum RequestCase {
    kSetAnselEnabledRequest = 1,
    kCaptureShotRequest = 2,
    kGetFilterListRequest = 3,
    kGetHighresResolutionListRequest = 4,
    kAbortCaptureRequest = 5,
    kGet360ResolutionRangeRequest = 6,
    kGetFOVRangeRequest = 7,
    kSetFOVRequest = 8,
    kGetRollRangeRequest = 9,
    kSetRollRequest = 10,
    kGetAnselEnabledRequest = 11,
    kGetLwrrentFOVRequest = 12,
    kSetFilterRequest = 13,
    kSetFilterAttributeRequest = 14,
    kIsAnselAvailableRequest = 17,
    kScreenResolutionChangedRequest = 18,
    kGetAnselShotPermissionsRequest = 19,
    kInputEventRequest = 20,
    kSetLangIdRequest = 21,
    kGetFilterInfoRequest = 22,
    kResetFilterValuesRequest = 23,
    kResetAllFilterValuesRequest = 24,
    kIsAnselSDKIntegrationAvailableRequest = 25,
    kIpcVersionRequest = 26,
    kAddUIElementRequest = 27,
    kUiReadyRequest = 28,
    kUiControlChangedRequest = 29,
    kUiControlRemoveRequest = 30,
    kUiControlSetVisibilityRequest = 31,
    kUiControlGetVisibilityRequest = 32,
    kGetProcessInfoRequest = 33,
    kGetScreenResolutionRequest = 34,
    kIsAnselModdingAvailableRequest = 35,
    kSetGridOfThirdsEnabledRequest = 36,
    kResetEntireStackRequest = 37,
    kGetFeatureSetRequest = 38,
    kSetStyleTransferEnabledRequest = 39,
    kSetStyleTransferStyleRequest = 40,
    kGetStyleTransferModelListRequest = 41,
    kSetStyleTransferModelRequest = 42,
    kStyleTransferStatusRequest = 43,
    kInsertFilterRequest = 44,
    kRemoveFilterRequest = 45,
    kMoveFilterRequest = 46,
    kGetStackInfoRequest = 47,
    kEstimateCaptureRequest = 48,
    kUiControlRemoveAllRequest = 49,
    kGetSettingsRequest = 50,
    kAnselStatusReportRequest = 51,
    kStyleTransferSideloadChoiceRequest = 52,
    kStyleTransferSideloadProgressRequest = 53,
    kUpdateRollRequest = 54,
    kGetGameSpecificControlsRequest = 55,
    kGetEnabledFeatureSetRequest = 56,
    kUpdateFovRequest = 57,
    kAnselReadyRequest = 58,
    kSetHighQualityRequest = 59,
    kSetFilterAndAttributesRequest = 60,
    kSetCMSInfoRequest = 61,
    kMultipleInputEventRequest = 62,
    REQUEST_NOT_SET = 0,
  };

  void Swap(AnselIPCRequest* other);

  // implements Message ----------------------------------------------

  AnselIPCRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnselIPCRequest& from);
  void MergeFrom(const AnselIPCRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .AnselIpc.SetAnselEnabledRequest setAnselEnabledRequest = 1;
  inline bool has_setanselenabledrequest() const;
  inline void clear_setanselenabledrequest();
  static const int kSetAnselEnabledRequestFieldNumber = 1;
  inline const ::AnselIpc::SetAnselEnabledRequest& setanselenabledrequest() const;
  inline ::AnselIpc::SetAnselEnabledRequest* mutable_setanselenabledrequest();
  inline ::AnselIpc::SetAnselEnabledRequest* release_setanselenabledrequest();
  inline void set_allocated_setanselenabledrequest(::AnselIpc::SetAnselEnabledRequest* setanselenabledrequest);

  // optional .AnselIpc.CaptureShotRequest captureShotRequest = 2;
  inline bool has_captureshotrequest() const;
  inline void clear_captureshotrequest();
  static const int kCaptureShotRequestFieldNumber = 2;
  inline const ::AnselIpc::CaptureShotRequest& captureshotrequest() const;
  inline ::AnselIpc::CaptureShotRequest* mutable_captureshotrequest();
  inline ::AnselIpc::CaptureShotRequest* release_captureshotrequest();
  inline void set_allocated_captureshotrequest(::AnselIpc::CaptureShotRequest* captureshotrequest);

  // optional .AnselIpc.GetFilterListRequest getFilterListRequest = 3;
  inline bool has_getfilterlistrequest() const;
  inline void clear_getfilterlistrequest();
  static const int kGetFilterListRequestFieldNumber = 3;
  inline const ::AnselIpc::GetFilterListRequest& getfilterlistrequest() const;
  inline ::AnselIpc::GetFilterListRequest* mutable_getfilterlistrequest();
  inline ::AnselIpc::GetFilterListRequest* release_getfilterlistrequest();
  inline void set_allocated_getfilterlistrequest(::AnselIpc::GetFilterListRequest* getfilterlistrequest);

  // optional .AnselIpc.GetHighresResolutionListRequest getHighresResolutionListRequest = 4;
  inline bool has_gethighresresolutionlistrequest() const;
  inline void clear_gethighresresolutionlistrequest();
  static const int kGetHighresResolutionListRequestFieldNumber = 4;
  inline const ::AnselIpc::GetHighresResolutionListRequest& gethighresresolutionlistrequest() const;
  inline ::AnselIpc::GetHighresResolutionListRequest* mutable_gethighresresolutionlistrequest();
  inline ::AnselIpc::GetHighresResolutionListRequest* release_gethighresresolutionlistrequest();
  inline void set_allocated_gethighresresolutionlistrequest(::AnselIpc::GetHighresResolutionListRequest* gethighresresolutionlistrequest);

  // optional .AnselIpc.AbortCaptureRequest abortCaptureRequest = 5;
  inline bool has_abortcapturerequest() const;
  inline void clear_abortcapturerequest();
  static const int kAbortCaptureRequestFieldNumber = 5;
  inline const ::AnselIpc::AbortCaptureRequest& abortcapturerequest() const;
  inline ::AnselIpc::AbortCaptureRequest* mutable_abortcapturerequest();
  inline ::AnselIpc::AbortCaptureRequest* release_abortcapturerequest();
  inline void set_allocated_abortcapturerequest(::AnselIpc::AbortCaptureRequest* abortcapturerequest);

  // optional .AnselIpc.Get360ResolutionRangeRequest get360ResolutionRangeRequest = 6;
  inline bool has_get360resolutionrangerequest() const;
  inline void clear_get360resolutionrangerequest();
  static const int kGet360ResolutionRangeRequestFieldNumber = 6;
  inline const ::AnselIpc::Get360ResolutionRangeRequest& get360resolutionrangerequest() const;
  inline ::AnselIpc::Get360ResolutionRangeRequest* mutable_get360resolutionrangerequest();
  inline ::AnselIpc::Get360ResolutionRangeRequest* release_get360resolutionrangerequest();
  inline void set_allocated_get360resolutionrangerequest(::AnselIpc::Get360ResolutionRangeRequest* get360resolutionrangerequest);

  // optional .AnselIpc.GetFOVRangeRequest getFOVRangeRequest = 7;
  inline bool has_getfovrangerequest() const;
  inline void clear_getfovrangerequest();
  static const int kGetFOVRangeRequestFieldNumber = 7;
  inline const ::AnselIpc::GetFOVRangeRequest& getfovrangerequest() const;
  inline ::AnselIpc::GetFOVRangeRequest* mutable_getfovrangerequest();
  inline ::AnselIpc::GetFOVRangeRequest* release_getfovrangerequest();
  inline void set_allocated_getfovrangerequest(::AnselIpc::GetFOVRangeRequest* getfovrangerequest);

  // optional .AnselIpc.SetFOVRequest setFOVRequest = 8;
  inline bool has_setfovrequest() const;
  inline void clear_setfovrequest();
  static const int kSetFOVRequestFieldNumber = 8;
  inline const ::AnselIpc::SetFOVRequest& setfovrequest() const;
  inline ::AnselIpc::SetFOVRequest* mutable_setfovrequest();
  inline ::AnselIpc::SetFOVRequest* release_setfovrequest();
  inline void set_allocated_setfovrequest(::AnselIpc::SetFOVRequest* setfovrequest);

  // optional .AnselIpc.GetRollRangeRequest getRollRangeRequest = 9;
  inline bool has_getrollrangerequest() const;
  inline void clear_getrollrangerequest();
  static const int kGetRollRangeRequestFieldNumber = 9;
  inline const ::AnselIpc::GetRollRangeRequest& getrollrangerequest() const;
  inline ::AnselIpc::GetRollRangeRequest* mutable_getrollrangerequest();
  inline ::AnselIpc::GetRollRangeRequest* release_getrollrangerequest();
  inline void set_allocated_getrollrangerequest(::AnselIpc::GetRollRangeRequest* getrollrangerequest);

  // optional .AnselIpc.SetRollRequest setRollRequest = 10;
  inline bool has_setrollrequest() const;
  inline void clear_setrollrequest();
  static const int kSetRollRequestFieldNumber = 10;
  inline const ::AnselIpc::SetRollRequest& setrollrequest() const;
  inline ::AnselIpc::SetRollRequest* mutable_setrollrequest();
  inline ::AnselIpc::SetRollRequest* release_setrollrequest();
  inline void set_allocated_setrollrequest(::AnselIpc::SetRollRequest* setrollrequest);

  // optional .AnselIpc.GetAnselEnabledRequest getAnselEnabledRequest = 11;
  inline bool has_getanselenabledrequest() const;
  inline void clear_getanselenabledrequest();
  static const int kGetAnselEnabledRequestFieldNumber = 11;
  inline const ::AnselIpc::GetAnselEnabledRequest& getanselenabledrequest() const;
  inline ::AnselIpc::GetAnselEnabledRequest* mutable_getanselenabledrequest();
  inline ::AnselIpc::GetAnselEnabledRequest* release_getanselenabledrequest();
  inline void set_allocated_getanselenabledrequest(::AnselIpc::GetAnselEnabledRequest* getanselenabledrequest);

  // optional .AnselIpc.GetLwrrentFOVRequest getLwrrentFOVRequest = 12;
  inline bool has_getlwrrentfovrequest() const;
  inline void clear_getlwrrentfovrequest();
  static const int kGetLwrrentFOVRequestFieldNumber = 12;
  inline const ::AnselIpc::GetLwrrentFOVRequest& getlwrrentfovrequest() const;
  inline ::AnselIpc::GetLwrrentFOVRequest* mutable_getlwrrentfovrequest();
  inline ::AnselIpc::GetLwrrentFOVRequest* release_getlwrrentfovrequest();
  inline void set_allocated_getlwrrentfovrequest(::AnselIpc::GetLwrrentFOVRequest* getlwrrentfovrequest);

  // optional .AnselIpc.SetFilterRequest setFilterRequest = 13;
  inline bool has_setfilterrequest() const;
  inline void clear_setfilterrequest();
  static const int kSetFilterRequestFieldNumber = 13;
  inline const ::AnselIpc::SetFilterRequest& setfilterrequest() const;
  inline ::AnselIpc::SetFilterRequest* mutable_setfilterrequest();
  inline ::AnselIpc::SetFilterRequest* release_setfilterrequest();
  inline void set_allocated_setfilterrequest(::AnselIpc::SetFilterRequest* setfilterrequest);

  // optional .AnselIpc.SetFilterAttributeRequest setFilterAttributeRequest = 14;
  inline bool has_setfilterattributerequest() const;
  inline void clear_setfilterattributerequest();
  static const int kSetFilterAttributeRequestFieldNumber = 14;
  inline const ::AnselIpc::SetFilterAttributeRequest& setfilterattributerequest() const;
  inline ::AnselIpc::SetFilterAttributeRequest* mutable_setfilterattributerequest();
  inline ::AnselIpc::SetFilterAttributeRequest* release_setfilterattributerequest();
  inline void set_allocated_setfilterattributerequest(::AnselIpc::SetFilterAttributeRequest* setfilterattributerequest);

  // optional .AnselIpc.IsAnselAvailableRequest isAnselAvailableRequest = 17;
  inline bool has_isanselavailablerequest() const;
  inline void clear_isanselavailablerequest();
  static const int kIsAnselAvailableRequestFieldNumber = 17;
  inline const ::AnselIpc::IsAnselAvailableRequest& isanselavailablerequest() const;
  inline ::AnselIpc::IsAnselAvailableRequest* mutable_isanselavailablerequest();
  inline ::AnselIpc::IsAnselAvailableRequest* release_isanselavailablerequest();
  inline void set_allocated_isanselavailablerequest(::AnselIpc::IsAnselAvailableRequest* isanselavailablerequest);

  // optional .AnselIpc.ScreenResolutionChangedRequest screenResolutionChangedRequest = 18;
  inline bool has_screenresolutionchangedrequest() const;
  inline void clear_screenresolutionchangedrequest();
  static const int kScreenResolutionChangedRequestFieldNumber = 18;
  inline const ::AnselIpc::ScreenResolutionChangedRequest& screenresolutionchangedrequest() const;
  inline ::AnselIpc::ScreenResolutionChangedRequest* mutable_screenresolutionchangedrequest();
  inline ::AnselIpc::ScreenResolutionChangedRequest* release_screenresolutionchangedrequest();
  inline void set_allocated_screenresolutionchangedrequest(::AnselIpc::ScreenResolutionChangedRequest* screenresolutionchangedrequest);

  // optional .AnselIpc.GetAnselShotPermissionsRequest getAnselShotPermissionsRequest = 19;
  inline bool has_getanselshotpermissionsrequest() const;
  inline void clear_getanselshotpermissionsrequest();
  static const int kGetAnselShotPermissionsRequestFieldNumber = 19;
  inline const ::AnselIpc::GetAnselShotPermissionsRequest& getanselshotpermissionsrequest() const;
  inline ::AnselIpc::GetAnselShotPermissionsRequest* mutable_getanselshotpermissionsrequest();
  inline ::AnselIpc::GetAnselShotPermissionsRequest* release_getanselshotpermissionsrequest();
  inline void set_allocated_getanselshotpermissionsrequest(::AnselIpc::GetAnselShotPermissionsRequest* getanselshotpermissionsrequest);

  // optional .AnselIpc.InputEventRequest inputEventRequest = 20;
  inline bool has_inputeventrequest() const;
  inline void clear_inputeventrequest();
  static const int kInputEventRequestFieldNumber = 20;
  inline const ::AnselIpc::InputEventRequest& inputeventrequest() const;
  inline ::AnselIpc::InputEventRequest* mutable_inputeventrequest();
  inline ::AnselIpc::InputEventRequest* release_inputeventrequest();
  inline void set_allocated_inputeventrequest(::AnselIpc::InputEventRequest* inputeventrequest);

  // optional .AnselIpc.SetLangIdRequest setLangIdRequest = 21;
  inline bool has_setlangidrequest() const;
  inline void clear_setlangidrequest();
  static const int kSetLangIdRequestFieldNumber = 21;
  inline const ::AnselIpc::SetLangIdRequest& setlangidrequest() const;
  inline ::AnselIpc::SetLangIdRequest* mutable_setlangidrequest();
  inline ::AnselIpc::SetLangIdRequest* release_setlangidrequest();
  inline void set_allocated_setlangidrequest(::AnselIpc::SetLangIdRequest* setlangidrequest);

  // optional .AnselIpc.GetFilterInfoRequest getFilterInfoRequest = 22;
  inline bool has_getfilterinforequest() const;
  inline void clear_getfilterinforequest();
  static const int kGetFilterInfoRequestFieldNumber = 22;
  inline const ::AnselIpc::GetFilterInfoRequest& getfilterinforequest() const;
  inline ::AnselIpc::GetFilterInfoRequest* mutable_getfilterinforequest();
  inline ::AnselIpc::GetFilterInfoRequest* release_getfilterinforequest();
  inline void set_allocated_getfilterinforequest(::AnselIpc::GetFilterInfoRequest* getfilterinforequest);

  // optional .AnselIpc.ResetFilterValuesRequest resetFilterValuesRequest = 23;
  inline bool has_resetfiltervaluesrequest() const;
  inline void clear_resetfiltervaluesrequest();
  static const int kResetFilterValuesRequestFieldNumber = 23;
  inline const ::AnselIpc::ResetFilterValuesRequest& resetfiltervaluesrequest() const;
  inline ::AnselIpc::ResetFilterValuesRequest* mutable_resetfiltervaluesrequest();
  inline ::AnselIpc::ResetFilterValuesRequest* release_resetfiltervaluesrequest();
  inline void set_allocated_resetfiltervaluesrequest(::AnselIpc::ResetFilterValuesRequest* resetfiltervaluesrequest);

  // optional .AnselIpc.ResetAllFilterValuesRequest resetAllFilterValuesRequest = 24;
  inline bool has_resetallfiltervaluesrequest() const;
  inline void clear_resetallfiltervaluesrequest();
  static const int kResetAllFilterValuesRequestFieldNumber = 24;
  inline const ::AnselIpc::ResetAllFilterValuesRequest& resetallfiltervaluesrequest() const;
  inline ::AnselIpc::ResetAllFilterValuesRequest* mutable_resetallfiltervaluesrequest();
  inline ::AnselIpc::ResetAllFilterValuesRequest* release_resetallfiltervaluesrequest();
  inline void set_allocated_resetallfiltervaluesrequest(::AnselIpc::ResetAllFilterValuesRequest* resetallfiltervaluesrequest);

  // optional .AnselIpc.IsAnselSDKIntegrationAvailableRequest isAnselSDKIntegrationAvailableRequest = 25;
  inline bool has_isanselsdkintegrationavailablerequest() const;
  inline void clear_isanselsdkintegrationavailablerequest();
  static const int kIsAnselSDKIntegrationAvailableRequestFieldNumber = 25;
  inline const ::AnselIpc::IsAnselSDKIntegrationAvailableRequest& isanselsdkintegrationavailablerequest() const;
  inline ::AnselIpc::IsAnselSDKIntegrationAvailableRequest* mutable_isanselsdkintegrationavailablerequest();
  inline ::AnselIpc::IsAnselSDKIntegrationAvailableRequest* release_isanselsdkintegrationavailablerequest();
  inline void set_allocated_isanselsdkintegrationavailablerequest(::AnselIpc::IsAnselSDKIntegrationAvailableRequest* isanselsdkintegrationavailablerequest);

  // optional .AnselIpc.IpcVersionRequest ipcVersionRequest = 26;
  inline bool has_ipcversionrequest() const;
  inline void clear_ipcversionrequest();
  static const int kIpcVersionRequestFieldNumber = 26;
  inline const ::AnselIpc::IpcVersionRequest& ipcversionrequest() const;
  inline ::AnselIpc::IpcVersionRequest* mutable_ipcversionrequest();
  inline ::AnselIpc::IpcVersionRequest* release_ipcversionrequest();
  inline void set_allocated_ipcversionrequest(::AnselIpc::IpcVersionRequest* ipcversionrequest);

  // optional .AnselIpc.AddUIElementRequest addUIElementRequest = 27;
  inline bool has_adduielementrequest() const;
  inline void clear_adduielementrequest();
  static const int kAddUIElementRequestFieldNumber = 27;
  inline const ::AnselIpc::AddUIElementRequest& adduielementrequest() const;
  inline ::AnselIpc::AddUIElementRequest* mutable_adduielementrequest();
  inline ::AnselIpc::AddUIElementRequest* release_adduielementrequest();
  inline void set_allocated_adduielementrequest(::AnselIpc::AddUIElementRequest* adduielementrequest);

  // optional .AnselIpc.UIReadyRequest uiReadyRequest = 28;
  inline bool has_uireadyrequest() const;
  inline void clear_uireadyrequest();
  static const int kUiReadyRequestFieldNumber = 28;
  inline const ::AnselIpc::UIReadyRequest& uireadyrequest() const;
  inline ::AnselIpc::UIReadyRequest* mutable_uireadyrequest();
  inline ::AnselIpc::UIReadyRequest* release_uireadyrequest();
  inline void set_allocated_uireadyrequest(::AnselIpc::UIReadyRequest* uireadyrequest);

  // optional .AnselIpc.UIControlChangedRequest uiControlChangedRequest = 29;
  inline bool has_uicontrolchangedrequest() const;
  inline void clear_uicontrolchangedrequest();
  static const int kUiControlChangedRequestFieldNumber = 29;
  inline const ::AnselIpc::UIControlChangedRequest& uicontrolchangedrequest() const;
  inline ::AnselIpc::UIControlChangedRequest* mutable_uicontrolchangedrequest();
  inline ::AnselIpc::UIControlChangedRequest* release_uicontrolchangedrequest();
  inline void set_allocated_uicontrolchangedrequest(::AnselIpc::UIControlChangedRequest* uicontrolchangedrequest);

  // optional .AnselIpc.UIControlRemoveRequest uiControlRemoveRequest = 30;
  inline bool has_uicontrolremoverequest() const;
  inline void clear_uicontrolremoverequest();
  static const int kUiControlRemoveRequestFieldNumber = 30;
  inline const ::AnselIpc::UIControlRemoveRequest& uicontrolremoverequest() const;
  inline ::AnselIpc::UIControlRemoveRequest* mutable_uicontrolremoverequest();
  inline ::AnselIpc::UIControlRemoveRequest* release_uicontrolremoverequest();
  inline void set_allocated_uicontrolremoverequest(::AnselIpc::UIControlRemoveRequest* uicontrolremoverequest);

  // optional .AnselIpc.UIControlSetVisibilityRequest uiControlSetVisibilityRequest = 31;
  inline bool has_uicontrolsetvisibilityrequest() const;
  inline void clear_uicontrolsetvisibilityrequest();
  static const int kUiControlSetVisibilityRequestFieldNumber = 31;
  inline const ::AnselIpc::UIControlSetVisibilityRequest& uicontrolsetvisibilityrequest() const;
  inline ::AnselIpc::UIControlSetVisibilityRequest* mutable_uicontrolsetvisibilityrequest();
  inline ::AnselIpc::UIControlSetVisibilityRequest* release_uicontrolsetvisibilityrequest();
  inline void set_allocated_uicontrolsetvisibilityrequest(::AnselIpc::UIControlSetVisibilityRequest* uicontrolsetvisibilityrequest);

  // optional .AnselIpc.UIControlGetVisibilityRequest uiControlGetVisibilityRequest = 32;
  inline bool has_uicontrolgetvisibilityrequest() const;
  inline void clear_uicontrolgetvisibilityrequest();
  static const int kUiControlGetVisibilityRequestFieldNumber = 32;
  inline const ::AnselIpc::UIControlGetVisibilityRequest& uicontrolgetvisibilityrequest() const;
  inline ::AnselIpc::UIControlGetVisibilityRequest* mutable_uicontrolgetvisibilityrequest();
  inline ::AnselIpc::UIControlGetVisibilityRequest* release_uicontrolgetvisibilityrequest();
  inline void set_allocated_uicontrolgetvisibilityrequest(::AnselIpc::UIControlGetVisibilityRequest* uicontrolgetvisibilityrequest);

  // optional .AnselIpc.GetProcessInfoRequest getProcessInfoRequest = 33;
  inline bool has_getprocessinforequest() const;
  inline void clear_getprocessinforequest();
  static const int kGetProcessInfoRequestFieldNumber = 33;
  inline const ::AnselIpc::GetProcessInfoRequest& getprocessinforequest() const;
  inline ::AnselIpc::GetProcessInfoRequest* mutable_getprocessinforequest();
  inline ::AnselIpc::GetProcessInfoRequest* release_getprocessinforequest();
  inline void set_allocated_getprocessinforequest(::AnselIpc::GetProcessInfoRequest* getprocessinforequest);

  // optional .AnselIpc.GetScreenResolutionRequest getScreenResolutionRequest = 34;
  inline bool has_getscreenresolutionrequest() const;
  inline void clear_getscreenresolutionrequest();
  static const int kGetScreenResolutionRequestFieldNumber = 34;
  inline const ::AnselIpc::GetScreenResolutionRequest& getscreenresolutionrequest() const;
  inline ::AnselIpc::GetScreenResolutionRequest* mutable_getscreenresolutionrequest();
  inline ::AnselIpc::GetScreenResolutionRequest* release_getscreenresolutionrequest();
  inline void set_allocated_getscreenresolutionrequest(::AnselIpc::GetScreenResolutionRequest* getscreenresolutionrequest);

  // optional .AnselIpc.IsAnselModdingAvailableRequest isAnselModdingAvailableRequest = 35;
  inline bool has_isanselmoddingavailablerequest() const;
  inline void clear_isanselmoddingavailablerequest();
  static const int kIsAnselModdingAvailableRequestFieldNumber = 35;
  inline const ::AnselIpc::IsAnselModdingAvailableRequest& isanselmoddingavailablerequest() const;
  inline ::AnselIpc::IsAnselModdingAvailableRequest* mutable_isanselmoddingavailablerequest();
  inline ::AnselIpc::IsAnselModdingAvailableRequest* release_isanselmoddingavailablerequest();
  inline void set_allocated_isanselmoddingavailablerequest(::AnselIpc::IsAnselModdingAvailableRequest* isanselmoddingavailablerequest);

  // optional .AnselIpc.SetGridOfThirdsEnabledRequest setGridOfThirdsEnabledRequest = 36;
  inline bool has_setgridofthirdsenabledrequest() const;
  inline void clear_setgridofthirdsenabledrequest();
  static const int kSetGridOfThirdsEnabledRequestFieldNumber = 36;
  inline const ::AnselIpc::SetGridOfThirdsEnabledRequest& setgridofthirdsenabledrequest() const;
  inline ::AnselIpc::SetGridOfThirdsEnabledRequest* mutable_setgridofthirdsenabledrequest();
  inline ::AnselIpc::SetGridOfThirdsEnabledRequest* release_setgridofthirdsenabledrequest();
  inline void set_allocated_setgridofthirdsenabledrequest(::AnselIpc::SetGridOfThirdsEnabledRequest* setgridofthirdsenabledrequest);

  // optional .AnselIpc.ResetEntireStackRequest resetEntireStackRequest = 37;
  inline bool has_resetentirestackrequest() const;
  inline void clear_resetentirestackrequest();
  static const int kResetEntireStackRequestFieldNumber = 37;
  inline const ::AnselIpc::ResetEntireStackRequest& resetentirestackrequest() const;
  inline ::AnselIpc::ResetEntireStackRequest* mutable_resetentirestackrequest();
  inline ::AnselIpc::ResetEntireStackRequest* release_resetentirestackrequest();
  inline void set_allocated_resetentirestackrequest(::AnselIpc::ResetEntireStackRequest* resetentirestackrequest);

  // optional .AnselIpc.GetFeatureSetRequest getFeatureSetRequest = 38;
  inline bool has_getfeaturesetrequest() const;
  inline void clear_getfeaturesetrequest();
  static const int kGetFeatureSetRequestFieldNumber = 38;
  inline const ::AnselIpc::GetFeatureSetRequest& getfeaturesetrequest() const;
  inline ::AnselIpc::GetFeatureSetRequest* mutable_getfeaturesetrequest();
  inline ::AnselIpc::GetFeatureSetRequest* release_getfeaturesetrequest();
  inline void set_allocated_getfeaturesetrequest(::AnselIpc::GetFeatureSetRequest* getfeaturesetrequest);

  // optional .AnselIpc.SetStyleTransferEnabledRequest setStyleTransferEnabledRequest = 39;
  inline bool has_setstyletransferenabledrequest() const;
  inline void clear_setstyletransferenabledrequest();
  static const int kSetStyleTransferEnabledRequestFieldNumber = 39;
  inline const ::AnselIpc::SetStyleTransferEnabledRequest& setstyletransferenabledrequest() const;
  inline ::AnselIpc::SetStyleTransferEnabledRequest* mutable_setstyletransferenabledrequest();
  inline ::AnselIpc::SetStyleTransferEnabledRequest* release_setstyletransferenabledrequest();
  inline void set_allocated_setstyletransferenabledrequest(::AnselIpc::SetStyleTransferEnabledRequest* setstyletransferenabledrequest);

  // optional .AnselIpc.SetStyleTransferStyleRequest setStyleTransferStyleRequest = 40;
  inline bool has_setstyletransferstylerequest() const;
  inline void clear_setstyletransferstylerequest();
  static const int kSetStyleTransferStyleRequestFieldNumber = 40;
  inline const ::AnselIpc::SetStyleTransferStyleRequest& setstyletransferstylerequest() const;
  inline ::AnselIpc::SetStyleTransferStyleRequest* mutable_setstyletransferstylerequest();
  inline ::AnselIpc::SetStyleTransferStyleRequest* release_setstyletransferstylerequest();
  inline void set_allocated_setstyletransferstylerequest(::AnselIpc::SetStyleTransferStyleRequest* setstyletransferstylerequest);

  // optional .AnselIpc.GetStyleTransferModelListRequest getStyleTransferModelListRequest = 41;
  inline bool has_getstyletransfermodellistrequest() const;
  inline void clear_getstyletransfermodellistrequest();
  static const int kGetStyleTransferModelListRequestFieldNumber = 41;
  inline const ::AnselIpc::GetStyleTransferModelListRequest& getstyletransfermodellistrequest() const;
  inline ::AnselIpc::GetStyleTransferModelListRequest* mutable_getstyletransfermodellistrequest();
  inline ::AnselIpc::GetStyleTransferModelListRequest* release_getstyletransfermodellistrequest();
  inline void set_allocated_getstyletransfermodellistrequest(::AnselIpc::GetStyleTransferModelListRequest* getstyletransfermodellistrequest);

  // optional .AnselIpc.SetStyleTransferModelRequest setStyleTransferModelRequest = 42;
  inline bool has_setstyletransfermodelrequest() const;
  inline void clear_setstyletransfermodelrequest();
  static const int kSetStyleTransferModelRequestFieldNumber = 42;
  inline const ::AnselIpc::SetStyleTransferModelRequest& setstyletransfermodelrequest() const;
  inline ::AnselIpc::SetStyleTransferModelRequest* mutable_setstyletransfermodelrequest();
  inline ::AnselIpc::SetStyleTransferModelRequest* release_setstyletransfermodelrequest();
  inline void set_allocated_setstyletransfermodelrequest(::AnselIpc::SetStyleTransferModelRequest* setstyletransfermodelrequest);

  // optional .AnselIpc.StyleTransferStatusRequest styleTransferStatusRequest = 43;
  inline bool has_styletransferstatusrequest() const;
  inline void clear_styletransferstatusrequest();
  static const int kStyleTransferStatusRequestFieldNumber = 43;
  inline const ::AnselIpc::StyleTransferStatusRequest& styletransferstatusrequest() const;
  inline ::AnselIpc::StyleTransferStatusRequest* mutable_styletransferstatusrequest();
  inline ::AnselIpc::StyleTransferStatusRequest* release_styletransferstatusrequest();
  inline void set_allocated_styletransferstatusrequest(::AnselIpc::StyleTransferStatusRequest* styletransferstatusrequest);

  // optional .AnselIpc.InsertFilterRequest insertFilterRequest = 44;
  inline bool has_insertfilterrequest() const;
  inline void clear_insertfilterrequest();
  static const int kInsertFilterRequestFieldNumber = 44;
  inline const ::AnselIpc::InsertFilterRequest& insertfilterrequest() const;
  inline ::AnselIpc::InsertFilterRequest* mutable_insertfilterrequest();
  inline ::AnselIpc::InsertFilterRequest* release_insertfilterrequest();
  inline void set_allocated_insertfilterrequest(::AnselIpc::InsertFilterRequest* insertfilterrequest);

  // optional .AnselIpc.RemoveFilterRequest removeFilterRequest = 45;
  inline bool has_removefilterrequest() const;
  inline void clear_removefilterrequest();
  static const int kRemoveFilterRequestFieldNumber = 45;
  inline const ::AnselIpc::RemoveFilterRequest& removefilterrequest() const;
  inline ::AnselIpc::RemoveFilterRequest* mutable_removefilterrequest();
  inline ::AnselIpc::RemoveFilterRequest* release_removefilterrequest();
  inline void set_allocated_removefilterrequest(::AnselIpc::RemoveFilterRequest* removefilterrequest);

  // optional .AnselIpc.MoveFilterRequest moveFilterRequest = 46;
  inline bool has_movefilterrequest() const;
  inline void clear_movefilterrequest();
  static const int kMoveFilterRequestFieldNumber = 46;
  inline const ::AnselIpc::MoveFilterRequest& movefilterrequest() const;
  inline ::AnselIpc::MoveFilterRequest* mutable_movefilterrequest();
  inline ::AnselIpc::MoveFilterRequest* release_movefilterrequest();
  inline void set_allocated_movefilterrequest(::AnselIpc::MoveFilterRequest* movefilterrequest);

  // optional .AnselIpc.GetStackInfoRequest getStackInfoRequest = 47;
  inline bool has_getstackinforequest() const;
  inline void clear_getstackinforequest();
  static const int kGetStackInfoRequestFieldNumber = 47;
  inline const ::AnselIpc::GetStackInfoRequest& getstackinforequest() const;
  inline ::AnselIpc::GetStackInfoRequest* mutable_getstackinforequest();
  inline ::AnselIpc::GetStackInfoRequest* release_getstackinforequest();
  inline void set_allocated_getstackinforequest(::AnselIpc::GetStackInfoRequest* getstackinforequest);

  // optional .AnselIpc.EstimateCaptureRequest estimateCaptureRequest = 48;
  inline bool has_estimatecapturerequest() const;
  inline void clear_estimatecapturerequest();
  static const int kEstimateCaptureRequestFieldNumber = 48;
  inline const ::AnselIpc::EstimateCaptureRequest& estimatecapturerequest() const;
  inline ::AnselIpc::EstimateCaptureRequest* mutable_estimatecapturerequest();
  inline ::AnselIpc::EstimateCaptureRequest* release_estimatecapturerequest();
  inline void set_allocated_estimatecapturerequest(::AnselIpc::EstimateCaptureRequest* estimatecapturerequest);

  // optional .AnselIpc.UIControlRemoveAllRequest uiControlRemoveAllRequest = 49;
  inline bool has_uicontrolremoveallrequest() const;
  inline void clear_uicontrolremoveallrequest();
  static const int kUiControlRemoveAllRequestFieldNumber = 49;
  inline const ::AnselIpc::UIControlRemoveAllRequest& uicontrolremoveallrequest() const;
  inline ::AnselIpc::UIControlRemoveAllRequest* mutable_uicontrolremoveallrequest();
  inline ::AnselIpc::UIControlRemoveAllRequest* release_uicontrolremoveallrequest();
  inline void set_allocated_uicontrolremoveallrequest(::AnselIpc::UIControlRemoveAllRequest* uicontrolremoveallrequest);

  // optional .AnselIpc.GetSettingsRequest getSettingsRequest = 50;
  inline bool has_getsettingsrequest() const;
  inline void clear_getsettingsrequest();
  static const int kGetSettingsRequestFieldNumber = 50;
  inline const ::AnselIpc::GetSettingsRequest& getsettingsrequest() const;
  inline ::AnselIpc::GetSettingsRequest* mutable_getsettingsrequest();
  inline ::AnselIpc::GetSettingsRequest* release_getsettingsrequest();
  inline void set_allocated_getsettingsrequest(::AnselIpc::GetSettingsRequest* getsettingsrequest);

  // optional .AnselIpc.AnselStatusReportRequest anselStatusReportRequest = 51;
  inline bool has_anselstatusreportrequest() const;
  inline void clear_anselstatusreportrequest();
  static const int kAnselStatusReportRequestFieldNumber = 51;
  inline const ::AnselIpc::AnselStatusReportRequest& anselstatusreportrequest() const;
  inline ::AnselIpc::AnselStatusReportRequest* mutable_anselstatusreportrequest();
  inline ::AnselIpc::AnselStatusReportRequest* release_anselstatusreportrequest();
  inline void set_allocated_anselstatusreportrequest(::AnselIpc::AnselStatusReportRequest* anselstatusreportrequest);

  // optional .AnselIpc.StyleTransferSideloadChoiceRequest styleTransferSideloadChoiceRequest = 52;
  inline bool has_styletransfersideloadchoicerequest() const;
  inline void clear_styletransfersideloadchoicerequest();
  static const int kStyleTransferSideloadChoiceRequestFieldNumber = 52;
  inline const ::AnselIpc::StyleTransferSideloadChoiceRequest& styletransfersideloadchoicerequest() const;
  inline ::AnselIpc::StyleTransferSideloadChoiceRequest* mutable_styletransfersideloadchoicerequest();
  inline ::AnselIpc::StyleTransferSideloadChoiceRequest* release_styletransfersideloadchoicerequest();
  inline void set_allocated_styletransfersideloadchoicerequest(::AnselIpc::StyleTransferSideloadChoiceRequest* styletransfersideloadchoicerequest);

  // optional .AnselIpc.StyleTransferSideloadProgressRequest styleTransferSideloadProgressRequest = 53;
  inline bool has_styletransfersideloadprogressrequest() const;
  inline void clear_styletransfersideloadprogressrequest();
  static const int kStyleTransferSideloadProgressRequestFieldNumber = 53;
  inline const ::AnselIpc::StyleTransferSideloadProgressRequest& styletransfersideloadprogressrequest() const;
  inline ::AnselIpc::StyleTransferSideloadProgressRequest* mutable_styletransfersideloadprogressrequest();
  inline ::AnselIpc::StyleTransferSideloadProgressRequest* release_styletransfersideloadprogressrequest();
  inline void set_allocated_styletransfersideloadprogressrequest(::AnselIpc::StyleTransferSideloadProgressRequest* styletransfersideloadprogressrequest);

  // optional .AnselIpc.UpdateRollRequest updateRollRequest = 54;
  inline bool has_updaterollrequest() const;
  inline void clear_updaterollrequest();
  static const int kUpdateRollRequestFieldNumber = 54;
  inline const ::AnselIpc::UpdateRollRequest& updaterollrequest() const;
  inline ::AnselIpc::UpdateRollRequest* mutable_updaterollrequest();
  inline ::AnselIpc::UpdateRollRequest* release_updaterollrequest();
  inline void set_allocated_updaterollrequest(::AnselIpc::UpdateRollRequest* updaterollrequest);

  // optional .AnselIpc.GetGameSpecificControlsRequest getGameSpecificControlsRequest = 55;
  inline bool has_getgamespecificcontrolsrequest() const;
  inline void clear_getgamespecificcontrolsrequest();
  static const int kGetGameSpecificControlsRequestFieldNumber = 55;
  inline const ::AnselIpc::GetGameSpecificControlsRequest& getgamespecificcontrolsrequest() const;
  inline ::AnselIpc::GetGameSpecificControlsRequest* mutable_getgamespecificcontrolsrequest();
  inline ::AnselIpc::GetGameSpecificControlsRequest* release_getgamespecificcontrolsrequest();
  inline void set_allocated_getgamespecificcontrolsrequest(::AnselIpc::GetGameSpecificControlsRequest* getgamespecificcontrolsrequest);

  // optional .AnselIpc.GetEnabledFeatureSetRequest getEnabledFeatureSetRequest = 56;
  inline bool has_getenabledfeaturesetrequest() const;
  inline void clear_getenabledfeaturesetrequest();
  static const int kGetEnabledFeatureSetRequestFieldNumber = 56;
  inline const ::AnselIpc::GetEnabledFeatureSetRequest& getenabledfeaturesetrequest() const;
  inline ::AnselIpc::GetEnabledFeatureSetRequest* mutable_getenabledfeaturesetrequest();
  inline ::AnselIpc::GetEnabledFeatureSetRequest* release_getenabledfeaturesetrequest();
  inline void set_allocated_getenabledfeaturesetrequest(::AnselIpc::GetEnabledFeatureSetRequest* getenabledfeaturesetrequest);

  // optional .AnselIpc.UpdateFovRequest updateFovRequest = 57;
  inline bool has_updatefovrequest() const;
  inline void clear_updatefovrequest();
  static const int kUpdateFovRequestFieldNumber = 57;
  inline const ::AnselIpc::UpdateFovRequest& updatefovrequest() const;
  inline ::AnselIpc::UpdateFovRequest* mutable_updatefovrequest();
  inline ::AnselIpc::UpdateFovRequest* release_updatefovrequest();
  inline void set_allocated_updatefovrequest(::AnselIpc::UpdateFovRequest* updatefovrequest);

  // optional .AnselIpc.AnselReadyRequest anselReadyRequest = 58;
  inline bool has_anselreadyrequest() const;
  inline void clear_anselreadyrequest();
  static const int kAnselReadyRequestFieldNumber = 58;
  inline const ::AnselIpc::AnselReadyRequest& anselreadyrequest() const;
  inline ::AnselIpc::AnselReadyRequest* mutable_anselreadyrequest();
  inline ::AnselIpc::AnselReadyRequest* release_anselreadyrequest();
  inline void set_allocated_anselreadyrequest(::AnselIpc::AnselReadyRequest* anselreadyrequest);

  // optional .AnselIpc.SetHighQualityRequest setHighQualityRequest = 59;
  inline bool has_sethighqualityrequest() const;
  inline void clear_sethighqualityrequest();
  static const int kSetHighQualityRequestFieldNumber = 59;
  inline const ::AnselIpc::SetHighQualityRequest& sethighqualityrequest() const;
  inline ::AnselIpc::SetHighQualityRequest* mutable_sethighqualityrequest();
  inline ::AnselIpc::SetHighQualityRequest* release_sethighqualityrequest();
  inline void set_allocated_sethighqualityrequest(::AnselIpc::SetHighQualityRequest* sethighqualityrequest);

  // optional .AnselIpc.SetFilterAndAttributesRequest setFilterAndAttributesRequest = 60;
  inline bool has_setfilterandattributesrequest() const;
  inline void clear_setfilterandattributesrequest();
  static const int kSetFilterAndAttributesRequestFieldNumber = 60;
  inline const ::AnselIpc::SetFilterAndAttributesRequest& setfilterandattributesrequest() const;
  inline ::AnselIpc::SetFilterAndAttributesRequest* mutable_setfilterandattributesrequest();
  inline ::AnselIpc::SetFilterAndAttributesRequest* release_setfilterandattributesrequest();
  inline void set_allocated_setfilterandattributesrequest(::AnselIpc::SetFilterAndAttributesRequest* setfilterandattributesrequest);

  // optional .AnselIpc.SetCMSInfoRequest setCMSInfoRequest = 61;
  inline bool has_setcmsinforequest() const;
  inline void clear_setcmsinforequest();
  static const int kSetCMSInfoRequestFieldNumber = 61;
  inline const ::AnselIpc::SetCMSInfoRequest& setcmsinforequest() const;
  inline ::AnselIpc::SetCMSInfoRequest* mutable_setcmsinforequest();
  inline ::AnselIpc::SetCMSInfoRequest* release_setcmsinforequest();
  inline void set_allocated_setcmsinforequest(::AnselIpc::SetCMSInfoRequest* setcmsinforequest);

  // optional .AnselIpc.MultipleInputEventRequest multipleInputEventRequest = 62;
  inline bool has_multipleinputeventrequest() const;
  inline void clear_multipleinputeventrequest();
  static const int kMultipleInputEventRequestFieldNumber = 62;
  inline const ::AnselIpc::MultipleInputEventRequest& multipleinputeventrequest() const;
  inline ::AnselIpc::MultipleInputEventRequest* mutable_multipleinputeventrequest();
  inline ::AnselIpc::MultipleInputEventRequest* release_multipleinputeventrequest();
  inline void set_allocated_multipleinputeventrequest(::AnselIpc::MultipleInputEventRequest* multipleinputeventrequest);

  inline RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:AnselIpc.AnselIPCRequest)
 private:
  inline void set_has_setanselenabledrequest();
  inline void set_has_captureshotrequest();
  inline void set_has_getfilterlistrequest();
  inline void set_has_gethighresresolutionlistrequest();
  inline void set_has_abortcapturerequest();
  inline void set_has_get360resolutionrangerequest();
  inline void set_has_getfovrangerequest();
  inline void set_has_setfovrequest();
  inline void set_has_getrollrangerequest();
  inline void set_has_setrollrequest();
  inline void set_has_getanselenabledrequest();
  inline void set_has_getlwrrentfovrequest();
  inline void set_has_setfilterrequest();
  inline void set_has_setfilterattributerequest();
  inline void set_has_isanselavailablerequest();
  inline void set_has_screenresolutionchangedrequest();
  inline void set_has_getanselshotpermissionsrequest();
  inline void set_has_inputeventrequest();
  inline void set_has_setlangidrequest();
  inline void set_has_getfilterinforequest();
  inline void set_has_resetfiltervaluesrequest();
  inline void set_has_resetallfiltervaluesrequest();
  inline void set_has_isanselsdkintegrationavailablerequest();
  inline void set_has_ipcversionrequest();
  inline void set_has_adduielementrequest();
  inline void set_has_uireadyrequest();
  inline void set_has_uicontrolchangedrequest();
  inline void set_has_uicontrolremoverequest();
  inline void set_has_uicontrolsetvisibilityrequest();
  inline void set_has_uicontrolgetvisibilityrequest();
  inline void set_has_getprocessinforequest();
  inline void set_has_getscreenresolutionrequest();
  inline void set_has_isanselmoddingavailablerequest();
  inline void set_has_setgridofthirdsenabledrequest();
  inline void set_has_resetentirestackrequest();
  inline void set_has_getfeaturesetrequest();
  inline void set_has_setstyletransferenabledrequest();
  inline void set_has_setstyletransferstylerequest();
  inline void set_has_getstyletransfermodellistrequest();
  inline void set_has_setstyletransfermodelrequest();
  inline void set_has_styletransferstatusrequest();
  inline void set_has_insertfilterrequest();
  inline void set_has_removefilterrequest();
  inline void set_has_movefilterrequest();
  inline void set_has_getstackinforequest();
  inline void set_has_estimatecapturerequest();
  inline void set_has_uicontrolremoveallrequest();
  inline void set_has_getsettingsrequest();
  inline void set_has_anselstatusreportrequest();
  inline void set_has_styletransfersideloadchoicerequest();
  inline void set_has_styletransfersideloadprogressrequest();
  inline void set_has_updaterollrequest();
  inline void set_has_getgamespecificcontrolsrequest();
  inline void set_has_getenabledfeaturesetrequest();
  inline void set_has_updatefovrequest();
  inline void set_has_anselreadyrequest();
  inline void set_has_sethighqualityrequest();
  inline void set_has_setfilterandattributesrequest();
  inline void set_has_setcmsinforequest();
  inline void set_has_multipleinputeventrequest();

  inline bool has_request();
  void clear_request();
  inline void clear_has_request();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[2];
  union RequestUnion {
    ::AnselIpc::SetAnselEnabledRequest* setanselenabledrequest_;
    ::AnselIpc::CaptureShotRequest* captureshotrequest_;
    ::AnselIpc::GetFilterListRequest* getfilterlistrequest_;
    ::AnselIpc::GetHighresResolutionListRequest* gethighresresolutionlistrequest_;
    ::AnselIpc::AbortCaptureRequest* abortcapturerequest_;
    ::AnselIpc::Get360ResolutionRangeRequest* get360resolutionrangerequest_;
    ::AnselIpc::GetFOVRangeRequest* getfovrangerequest_;
    ::AnselIpc::SetFOVRequest* setfovrequest_;
    ::AnselIpc::GetRollRangeRequest* getrollrangerequest_;
    ::AnselIpc::SetRollRequest* setrollrequest_;
    ::AnselIpc::GetAnselEnabledRequest* getanselenabledrequest_;
    ::AnselIpc::GetLwrrentFOVRequest* getlwrrentfovrequest_;
    ::AnselIpc::SetFilterRequest* setfilterrequest_;
    ::AnselIpc::SetFilterAttributeRequest* setfilterattributerequest_;
    ::AnselIpc::IsAnselAvailableRequest* isanselavailablerequest_;
    ::AnselIpc::ScreenResolutionChangedRequest* screenresolutionchangedrequest_;
    ::AnselIpc::GetAnselShotPermissionsRequest* getanselshotpermissionsrequest_;
    ::AnselIpc::InputEventRequest* inputeventrequest_;
    ::AnselIpc::SetLangIdRequest* setlangidrequest_;
    ::AnselIpc::GetFilterInfoRequest* getfilterinforequest_;
    ::AnselIpc::ResetFilterValuesRequest* resetfiltervaluesrequest_;
    ::AnselIpc::ResetAllFilterValuesRequest* resetallfiltervaluesrequest_;
    ::AnselIpc::IsAnselSDKIntegrationAvailableRequest* isanselsdkintegrationavailablerequest_;
    ::AnselIpc::IpcVersionRequest* ipcversionrequest_;
    ::AnselIpc::AddUIElementRequest* adduielementrequest_;
    ::AnselIpc::UIReadyRequest* uireadyrequest_;
    ::AnselIpc::UIControlChangedRequest* uicontrolchangedrequest_;
    ::AnselIpc::UIControlRemoveRequest* uicontrolremoverequest_;
    ::AnselIpc::UIControlSetVisibilityRequest* uicontrolsetvisibilityrequest_;
    ::AnselIpc::UIControlGetVisibilityRequest* uicontrolgetvisibilityrequest_;
    ::AnselIpc::GetProcessInfoRequest* getprocessinforequest_;
    ::AnselIpc::GetScreenResolutionRequest* getscreenresolutionrequest_;
    ::AnselIpc::IsAnselModdingAvailableRequest* isanselmoddingavailablerequest_;
    ::AnselIpc::SetGridOfThirdsEnabledRequest* setgridofthirdsenabledrequest_;
    ::AnselIpc::ResetEntireStackRequest* resetentirestackrequest_;
    ::AnselIpc::GetFeatureSetRequest* getfeaturesetrequest_;
    ::AnselIpc::SetStyleTransferEnabledRequest* setstyletransferenabledrequest_;
    ::AnselIpc::SetStyleTransferStyleRequest* setstyletransferstylerequest_;
    ::AnselIpc::GetStyleTransferModelListRequest* getstyletransfermodellistrequest_;
    ::AnselIpc::SetStyleTransferModelRequest* setstyletransfermodelrequest_;
    ::AnselIpc::StyleTransferStatusRequest* styletransferstatusrequest_;
    ::AnselIpc::InsertFilterRequest* insertfilterrequest_;
    ::AnselIpc::RemoveFilterRequest* removefilterrequest_;
    ::AnselIpc::MoveFilterRequest* movefilterrequest_;
    ::AnselIpc::GetStackInfoRequest* getstackinforequest_;
    ::AnselIpc::EstimateCaptureRequest* estimatecapturerequest_;
    ::AnselIpc::UIControlRemoveAllRequest* uicontrolremoveallrequest_;
    ::AnselIpc::GetSettingsRequest* getsettingsrequest_;
    ::AnselIpc::AnselStatusReportRequest* anselstatusreportrequest_;
    ::AnselIpc::StyleTransferSideloadChoiceRequest* styletransfersideloadchoicerequest_;
    ::AnselIpc::StyleTransferSideloadProgressRequest* styletransfersideloadprogressrequest_;
    ::AnselIpc::UpdateRollRequest* updaterollrequest_;
    ::AnselIpc::GetGameSpecificControlsRequest* getgamespecificcontrolsrequest_;
    ::AnselIpc::GetEnabledFeatureSetRequest* getenabledfeaturesetrequest_;
    ::AnselIpc::UpdateFovRequest* updatefovrequest_;
    ::AnselIpc::AnselReadyRequest* anselreadyrequest_;
    ::AnselIpc::SetHighQualityRequest* sethighqualityrequest_;
    ::AnselIpc::SetFilterAndAttributesRequest* setfilterandattributesrequest_;
    ::AnselIpc::SetCMSInfoRequest* setcmsinforequest_;
    ::AnselIpc::MultipleInputEventRequest* multipleinputeventrequest_;
  } request_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static AnselIPCRequest* default_instance_;
};
// -------------------------------------------------------------------

class AnselIPCResponse : public ::google::protobuf::Message {
 public:
  AnselIPCResponse();
  virtual ~AnselIPCResponse();

  AnselIPCResponse(const AnselIPCResponse& from);

  inline AnselIPCResponse& operator=(const AnselIPCResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnselIPCResponse& default_instance();

  enum ResponseCase {
    kGetFilterListResponse = 1,
    kGetHighresResolutionListResponse = 2,
    kCaptureShotStartedResponse = 3,
    kCaptureShotFinishedResponse = 4,
    kCaptureShotProcessingFinishedResponse = 5,
    kGet360ResolutionRangeResponse = 6,
    kGetFOVRangeResponse = 7,
    kSetFOVResponse = 8,
    kGetRollRangeResponse = 9,
    kSetRollResponse = 10,
    kSetAnselEnabledResponse = 11,
    kAbortCaptureResponse = 12,
    kGetAnselEnabledResponse = 13,
    kGetLwrrentFOVResponse = 14,
    kCaptureShotProgressResponse = 15,
    kLogFilenameResponse = 16,
    kSetFilterResponse = 17,
    kSetFilterAttributeResponse = 18,
    kIsAnselAvailableResponse = 19,
    kScreenResolutionChangedResponse = 20,
    kGetAnselShotPermissionsResponse = 21,
    kInputEventResponse = 22,
    kSetLangIdResponse = 23,
    kGetFilterInfoResponse = 24,
    kResetFilterValuesResponse = 25,
    kIsAnselSDKIntegrationAvailableResponse = 26,
    kIpcVersionResponse = 27,
    kAddUIElementResponse = 28,
    kUiReadyResponse = 29,
    kUiControlChangedResponse = 30,
    kUiControlRemoveResponse = 31,
    kUiControlSetVisibilityResponse = 32,
    kUiControlGetVisibilityResponse = 33,
    kGetProcessInfoResponse = 34,
    kGetScreenResolutionResponse = 35,
    kIsAnselModdingAvailableResponse = 36,
    kSetGridOfThirdsEnabledResponse = 37,
    kResetEntireStackResponse = 38,
    kGetFeatureSetResponse = 39,
    kSetStyleTransferEnabledResponse = 40,
    kSetStyleTransferStyleResponse = 41,
    kGetStyleTransferModelListResponse = 42,
    kSetStyleTransferModelResponse = 43,
    kStyleTransferStatusResponse = 44,
    kMoveFilterResponse = 45,
    kGetStackInfoResponse = 46,
    kInsertFilterResponse = 47,
    kRemoveFilterResponse = 48,
    kReportErrorResponse = 49,
    kEstimateCaptureResponse = 50,
    kUiControlRemoveAllResponse = 51,
    kGetSettingsResponse = 52,
    kAnselStatusReportResponse = 53,
    kStyleTransferSideloadChoiceResponse = 54,
    kStyleTransferSideloadProgressResponse = 55,
    kUpdateRollResponse = 56,
    kGetEnabledFeatureSetResponse = 57,
    kUpdateFovResponse = 58,
    kAnselReadyResponse = 59,
    kSetHighQualityResponse = 60,
    kSetFilterAndAttributesResponse = 61,
    kSetCMSInfoResponse = 62,
    RESPONSE_NOT_SET = 0,
  };

  void Swap(AnselIPCResponse* other);

  // implements Message ----------------------------------------------

  AnselIPCResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnselIPCResponse& from);
  void MergeFrom(const AnselIPCResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .AnselIpc.GetFilterListResponse getFilterListResponse = 1;
  inline bool has_getfilterlistresponse() const;
  inline void clear_getfilterlistresponse();
  static const int kGetFilterListResponseFieldNumber = 1;
  inline const ::AnselIpc::GetFilterListResponse& getfilterlistresponse() const;
  inline ::AnselIpc::GetFilterListResponse* mutable_getfilterlistresponse();
  inline ::AnselIpc::GetFilterListResponse* release_getfilterlistresponse();
  inline void set_allocated_getfilterlistresponse(::AnselIpc::GetFilterListResponse* getfilterlistresponse);

  // optional .AnselIpc.GetHighresResolutionListResponse getHighresResolutionListResponse = 2;
  inline bool has_gethighresresolutionlistresponse() const;
  inline void clear_gethighresresolutionlistresponse();
  static const int kGetHighresResolutionListResponseFieldNumber = 2;
  inline const ::AnselIpc::GetHighresResolutionListResponse& gethighresresolutionlistresponse() const;
  inline ::AnselIpc::GetHighresResolutionListResponse* mutable_gethighresresolutionlistresponse();
  inline ::AnselIpc::GetHighresResolutionListResponse* release_gethighresresolutionlistresponse();
  inline void set_allocated_gethighresresolutionlistresponse(::AnselIpc::GetHighresResolutionListResponse* gethighresresolutionlistresponse);

  // optional .AnselIpc.CaptureShotStartedResponse captureShotStartedResponse = 3;
  inline bool has_captureshotstartedresponse() const;
  inline void clear_captureshotstartedresponse();
  static const int kCaptureShotStartedResponseFieldNumber = 3;
  inline const ::AnselIpc::CaptureShotStartedResponse& captureshotstartedresponse() const;
  inline ::AnselIpc::CaptureShotStartedResponse* mutable_captureshotstartedresponse();
  inline ::AnselIpc::CaptureShotStartedResponse* release_captureshotstartedresponse();
  inline void set_allocated_captureshotstartedresponse(::AnselIpc::CaptureShotStartedResponse* captureshotstartedresponse);

  // optional .AnselIpc.CaptureShotFinishedResponse captureShotFinishedResponse = 4;
  inline bool has_captureshotfinishedresponse() const;
  inline void clear_captureshotfinishedresponse();
  static const int kCaptureShotFinishedResponseFieldNumber = 4;
  inline const ::AnselIpc::CaptureShotFinishedResponse& captureshotfinishedresponse() const;
  inline ::AnselIpc::CaptureShotFinishedResponse* mutable_captureshotfinishedresponse();
  inline ::AnselIpc::CaptureShotFinishedResponse* release_captureshotfinishedresponse();
  inline void set_allocated_captureshotfinishedresponse(::AnselIpc::CaptureShotFinishedResponse* captureshotfinishedresponse);

  // optional .AnselIpc.CaptureShotProcessingFinishedResponse captureShotProcessingFinishedResponse = 5;
  inline bool has_captureshotprocessingfinishedresponse() const;
  inline void clear_captureshotprocessingfinishedresponse();
  static const int kCaptureShotProcessingFinishedResponseFieldNumber = 5;
  inline const ::AnselIpc::CaptureShotProcessingFinishedResponse& captureshotprocessingfinishedresponse() const;
  inline ::AnselIpc::CaptureShotProcessingFinishedResponse* mutable_captureshotprocessingfinishedresponse();
  inline ::AnselIpc::CaptureShotProcessingFinishedResponse* release_captureshotprocessingfinishedresponse();
  inline void set_allocated_captureshotprocessingfinishedresponse(::AnselIpc::CaptureShotProcessingFinishedResponse* captureshotprocessingfinishedresponse);

  // optional .AnselIpc.Get360ResolutionRangeResponse get360ResolutionRangeResponse = 6;
  inline bool has_get360resolutionrangeresponse() const;
  inline void clear_get360resolutionrangeresponse();
  static const int kGet360ResolutionRangeResponseFieldNumber = 6;
  inline const ::AnselIpc::Get360ResolutionRangeResponse& get360resolutionrangeresponse() const;
  inline ::AnselIpc::Get360ResolutionRangeResponse* mutable_get360resolutionrangeresponse();
  inline ::AnselIpc::Get360ResolutionRangeResponse* release_get360resolutionrangeresponse();
  inline void set_allocated_get360resolutionrangeresponse(::AnselIpc::Get360ResolutionRangeResponse* get360resolutionrangeresponse);

  // optional .AnselIpc.GetFOVRangeResponse getFOVRangeResponse = 7;
  inline bool has_getfovrangeresponse() const;
  inline void clear_getfovrangeresponse();
  static const int kGetFOVRangeResponseFieldNumber = 7;
  inline const ::AnselIpc::GetFOVRangeResponse& getfovrangeresponse() const;
  inline ::AnselIpc::GetFOVRangeResponse* mutable_getfovrangeresponse();
  inline ::AnselIpc::GetFOVRangeResponse* release_getfovrangeresponse();
  inline void set_allocated_getfovrangeresponse(::AnselIpc::GetFOVRangeResponse* getfovrangeresponse);

  // optional .AnselIpc.SetFOVResponse setFOVResponse = 8;
  inline bool has_setfovresponse() const;
  inline void clear_setfovresponse();
  static const int kSetFOVResponseFieldNumber = 8;
  inline const ::AnselIpc::SetFOVResponse& setfovresponse() const;
  inline ::AnselIpc::SetFOVResponse* mutable_setfovresponse();
  inline ::AnselIpc::SetFOVResponse* release_setfovresponse();
  inline void set_allocated_setfovresponse(::AnselIpc::SetFOVResponse* setfovresponse);

  // optional .AnselIpc.GetRollRangeResponse getRollRangeResponse = 9;
  inline bool has_getrollrangeresponse() const;
  inline void clear_getrollrangeresponse();
  static const int kGetRollRangeResponseFieldNumber = 9;
  inline const ::AnselIpc::GetRollRangeResponse& getrollrangeresponse() const;
  inline ::AnselIpc::GetRollRangeResponse* mutable_getrollrangeresponse();
  inline ::AnselIpc::GetRollRangeResponse* release_getrollrangeresponse();
  inline void set_allocated_getrollrangeresponse(::AnselIpc::GetRollRangeResponse* getrollrangeresponse);

  // optional .AnselIpc.SetRollResponse setRollResponse = 10;
  inline bool has_setrollresponse() const;
  inline void clear_setrollresponse();
  static const int kSetRollResponseFieldNumber = 10;
  inline const ::AnselIpc::SetRollResponse& setrollresponse() const;
  inline ::AnselIpc::SetRollResponse* mutable_setrollresponse();
  inline ::AnselIpc::SetRollResponse* release_setrollresponse();
  inline void set_allocated_setrollresponse(::AnselIpc::SetRollResponse* setrollresponse);

  // optional .AnselIpc.SetAnselEnabledResponse setAnselEnabledResponse = 11;
  inline bool has_setanselenabledresponse() const;
  inline void clear_setanselenabledresponse();
  static const int kSetAnselEnabledResponseFieldNumber = 11;
  inline const ::AnselIpc::SetAnselEnabledResponse& setanselenabledresponse() const;
  inline ::AnselIpc::SetAnselEnabledResponse* mutable_setanselenabledresponse();
  inline ::AnselIpc::SetAnselEnabledResponse* release_setanselenabledresponse();
  inline void set_allocated_setanselenabledresponse(::AnselIpc::SetAnselEnabledResponse* setanselenabledresponse);

  // optional .AnselIpc.AbortCaptureResponse abortCaptureResponse = 12;
  inline bool has_abortcaptureresponse() const;
  inline void clear_abortcaptureresponse();
  static const int kAbortCaptureResponseFieldNumber = 12;
  inline const ::AnselIpc::AbortCaptureResponse& abortcaptureresponse() const;
  inline ::AnselIpc::AbortCaptureResponse* mutable_abortcaptureresponse();
  inline ::AnselIpc::AbortCaptureResponse* release_abortcaptureresponse();
  inline void set_allocated_abortcaptureresponse(::AnselIpc::AbortCaptureResponse* abortcaptureresponse);

  // optional .AnselIpc.GetAnselEnabledResponse getAnselEnabledResponse = 13;
  inline bool has_getanselenabledresponse() const;
  inline void clear_getanselenabledresponse();
  static const int kGetAnselEnabledResponseFieldNumber = 13;
  inline const ::AnselIpc::GetAnselEnabledResponse& getanselenabledresponse() const;
  inline ::AnselIpc::GetAnselEnabledResponse* mutable_getanselenabledresponse();
  inline ::AnselIpc::GetAnselEnabledResponse* release_getanselenabledresponse();
  inline void set_allocated_getanselenabledresponse(::AnselIpc::GetAnselEnabledResponse* getanselenabledresponse);

  // optional .AnselIpc.GetLwrrentFOVResponse getLwrrentFOVResponse = 14;
  inline bool has_getlwrrentfovresponse() const;
  inline void clear_getlwrrentfovresponse();
  static const int kGetLwrrentFOVResponseFieldNumber = 14;
  inline const ::AnselIpc::GetLwrrentFOVResponse& getlwrrentfovresponse() const;
  inline ::AnselIpc::GetLwrrentFOVResponse* mutable_getlwrrentfovresponse();
  inline ::AnselIpc::GetLwrrentFOVResponse* release_getlwrrentfovresponse();
  inline void set_allocated_getlwrrentfovresponse(::AnselIpc::GetLwrrentFOVResponse* getlwrrentfovresponse);

  // optional .AnselIpc.CaptureShotProgressResponse captureShotProgressResponse = 15;
  inline bool has_captureshotprogressresponse() const;
  inline void clear_captureshotprogressresponse();
  static const int kCaptureShotProgressResponseFieldNumber = 15;
  inline const ::AnselIpc::CaptureShotProgressResponse& captureshotprogressresponse() const;
  inline ::AnselIpc::CaptureShotProgressResponse* mutable_captureshotprogressresponse();
  inline ::AnselIpc::CaptureShotProgressResponse* release_captureshotprogressresponse();
  inline void set_allocated_captureshotprogressresponse(::AnselIpc::CaptureShotProgressResponse* captureshotprogressresponse);

  // optional .AnselIpc.LogFilenameResponse logFilenameResponse = 16;
  inline bool has_logfilenameresponse() const;
  inline void clear_logfilenameresponse();
  static const int kLogFilenameResponseFieldNumber = 16;
  inline const ::AnselIpc::LogFilenameResponse& logfilenameresponse() const;
  inline ::AnselIpc::LogFilenameResponse* mutable_logfilenameresponse();
  inline ::AnselIpc::LogFilenameResponse* release_logfilenameresponse();
  inline void set_allocated_logfilenameresponse(::AnselIpc::LogFilenameResponse* logfilenameresponse);

  // optional .AnselIpc.SetFilterResponse setFilterResponse = 17;
  inline bool has_setfilterresponse() const;
  inline void clear_setfilterresponse();
  static const int kSetFilterResponseFieldNumber = 17;
  inline const ::AnselIpc::SetFilterResponse& setfilterresponse() const;
  inline ::AnselIpc::SetFilterResponse* mutable_setfilterresponse();
  inline ::AnselIpc::SetFilterResponse* release_setfilterresponse();
  inline void set_allocated_setfilterresponse(::AnselIpc::SetFilterResponse* setfilterresponse);

  // optional .AnselIpc.SetFilterAttributeResponse setFilterAttributeResponse = 18;
  inline bool has_setfilterattributeresponse() const;
  inline void clear_setfilterattributeresponse();
  static const int kSetFilterAttributeResponseFieldNumber = 18;
  inline const ::AnselIpc::SetFilterAttributeResponse& setfilterattributeresponse() const;
  inline ::AnselIpc::SetFilterAttributeResponse* mutable_setfilterattributeresponse();
  inline ::AnselIpc::SetFilterAttributeResponse* release_setfilterattributeresponse();
  inline void set_allocated_setfilterattributeresponse(::AnselIpc::SetFilterAttributeResponse* setfilterattributeresponse);

  // optional .AnselIpc.IsAnselAvailableResponse isAnselAvailableResponse = 19;
  inline bool has_isanselavailableresponse() const;
  inline void clear_isanselavailableresponse();
  static const int kIsAnselAvailableResponseFieldNumber = 19;
  inline const ::AnselIpc::IsAnselAvailableResponse& isanselavailableresponse() const;
  inline ::AnselIpc::IsAnselAvailableResponse* mutable_isanselavailableresponse();
  inline ::AnselIpc::IsAnselAvailableResponse* release_isanselavailableresponse();
  inline void set_allocated_isanselavailableresponse(::AnselIpc::IsAnselAvailableResponse* isanselavailableresponse);

  // optional .AnselIpc.ScreenResolutionChangedResponse screenResolutionChangedResponse = 20;
  inline bool has_screenresolutionchangedresponse() const;
  inline void clear_screenresolutionchangedresponse();
  static const int kScreenResolutionChangedResponseFieldNumber = 20;
  inline const ::AnselIpc::ScreenResolutionChangedResponse& screenresolutionchangedresponse() const;
  inline ::AnselIpc::ScreenResolutionChangedResponse* mutable_screenresolutionchangedresponse();
  inline ::AnselIpc::ScreenResolutionChangedResponse* release_screenresolutionchangedresponse();
  inline void set_allocated_screenresolutionchangedresponse(::AnselIpc::ScreenResolutionChangedResponse* screenresolutionchangedresponse);

  // optional .AnselIpc.GetAnselShotPermissionsResponse getAnselShotPermissionsResponse = 21;
  inline bool has_getanselshotpermissionsresponse() const;
  inline void clear_getanselshotpermissionsresponse();
  static const int kGetAnselShotPermissionsResponseFieldNumber = 21;
  inline const ::AnselIpc::GetAnselShotPermissionsResponse& getanselshotpermissionsresponse() const;
  inline ::AnselIpc::GetAnselShotPermissionsResponse* mutable_getanselshotpermissionsresponse();
  inline ::AnselIpc::GetAnselShotPermissionsResponse* release_getanselshotpermissionsresponse();
  inline void set_allocated_getanselshotpermissionsresponse(::AnselIpc::GetAnselShotPermissionsResponse* getanselshotpermissionsresponse);

  // optional .AnselIpc.InputEventResponse inputEventResponse = 22;
  inline bool has_inputeventresponse() const;
  inline void clear_inputeventresponse();
  static const int kInputEventResponseFieldNumber = 22;
  inline const ::AnselIpc::InputEventResponse& inputeventresponse() const;
  inline ::AnselIpc::InputEventResponse* mutable_inputeventresponse();
  inline ::AnselIpc::InputEventResponse* release_inputeventresponse();
  inline void set_allocated_inputeventresponse(::AnselIpc::InputEventResponse* inputeventresponse);

  // optional .AnselIpc.SetLangIdResponse setLangIdResponse = 23;
  inline bool has_setlangidresponse() const;
  inline void clear_setlangidresponse();
  static const int kSetLangIdResponseFieldNumber = 23;
  inline const ::AnselIpc::SetLangIdResponse& setlangidresponse() const;
  inline ::AnselIpc::SetLangIdResponse* mutable_setlangidresponse();
  inline ::AnselIpc::SetLangIdResponse* release_setlangidresponse();
  inline void set_allocated_setlangidresponse(::AnselIpc::SetLangIdResponse* setlangidresponse);

  // optional .AnselIpc.GetFilterInfoResponse getFilterInfoResponse = 24;
  inline bool has_getfilterinforesponse() const;
  inline void clear_getfilterinforesponse();
  static const int kGetFilterInfoResponseFieldNumber = 24;
  inline const ::AnselIpc::GetFilterInfoResponse& getfilterinforesponse() const;
  inline ::AnselIpc::GetFilterInfoResponse* mutable_getfilterinforesponse();
  inline ::AnselIpc::GetFilterInfoResponse* release_getfilterinforesponse();
  inline void set_allocated_getfilterinforesponse(::AnselIpc::GetFilterInfoResponse* getfilterinforesponse);

  // optional .AnselIpc.ResetFilterValuesResponse resetFilterValuesResponse = 25;
  inline bool has_resetfiltervaluesresponse() const;
  inline void clear_resetfiltervaluesresponse();
  static const int kResetFilterValuesResponseFieldNumber = 25;
  inline const ::AnselIpc::ResetFilterValuesResponse& resetfiltervaluesresponse() const;
  inline ::AnselIpc::ResetFilterValuesResponse* mutable_resetfiltervaluesresponse();
  inline ::AnselIpc::ResetFilterValuesResponse* release_resetfiltervaluesresponse();
  inline void set_allocated_resetfiltervaluesresponse(::AnselIpc::ResetFilterValuesResponse* resetfiltervaluesresponse);

  // optional .AnselIpc.IsAnselSDKIntegrationAvailableResponse isAnselSDKIntegrationAvailableResponse = 26;
  inline bool has_isanselsdkintegrationavailableresponse() const;
  inline void clear_isanselsdkintegrationavailableresponse();
  static const int kIsAnselSDKIntegrationAvailableResponseFieldNumber = 26;
  inline const ::AnselIpc::IsAnselSDKIntegrationAvailableResponse& isanselsdkintegrationavailableresponse() const;
  inline ::AnselIpc::IsAnselSDKIntegrationAvailableResponse* mutable_isanselsdkintegrationavailableresponse();
  inline ::AnselIpc::IsAnselSDKIntegrationAvailableResponse* release_isanselsdkintegrationavailableresponse();
  inline void set_allocated_isanselsdkintegrationavailableresponse(::AnselIpc::IsAnselSDKIntegrationAvailableResponse* isanselsdkintegrationavailableresponse);

  // optional .AnselIpc.IpcVersionResponse ipcVersionResponse = 27;
  inline bool has_ipcversionresponse() const;
  inline void clear_ipcversionresponse();
  static const int kIpcVersionResponseFieldNumber = 27;
  inline const ::AnselIpc::IpcVersionResponse& ipcversionresponse() const;
  inline ::AnselIpc::IpcVersionResponse* mutable_ipcversionresponse();
  inline ::AnselIpc::IpcVersionResponse* release_ipcversionresponse();
  inline void set_allocated_ipcversionresponse(::AnselIpc::IpcVersionResponse* ipcversionresponse);

  // optional .AnselIpc.AddUIElementResponse addUIElementResponse = 28;
  inline bool has_adduielementresponse() const;
  inline void clear_adduielementresponse();
  static const int kAddUIElementResponseFieldNumber = 28;
  inline const ::AnselIpc::AddUIElementResponse& adduielementresponse() const;
  inline ::AnselIpc::AddUIElementResponse* mutable_adduielementresponse();
  inline ::AnselIpc::AddUIElementResponse* release_adduielementresponse();
  inline void set_allocated_adduielementresponse(::AnselIpc::AddUIElementResponse* adduielementresponse);

  // optional .AnselIpc.UIReadyResponse uiReadyResponse = 29;
  inline bool has_uireadyresponse() const;
  inline void clear_uireadyresponse();
  static const int kUiReadyResponseFieldNumber = 29;
  inline const ::AnselIpc::UIReadyResponse& uireadyresponse() const;
  inline ::AnselIpc::UIReadyResponse* mutable_uireadyresponse();
  inline ::AnselIpc::UIReadyResponse* release_uireadyresponse();
  inline void set_allocated_uireadyresponse(::AnselIpc::UIReadyResponse* uireadyresponse);

  // optional .AnselIpc.UIControlChangedResponse uiControlChangedResponse = 30;
  inline bool has_uicontrolchangedresponse() const;
  inline void clear_uicontrolchangedresponse();
  static const int kUiControlChangedResponseFieldNumber = 30;
  inline const ::AnselIpc::UIControlChangedResponse& uicontrolchangedresponse() const;
  inline ::AnselIpc::UIControlChangedResponse* mutable_uicontrolchangedresponse();
  inline ::AnselIpc::UIControlChangedResponse* release_uicontrolchangedresponse();
  inline void set_allocated_uicontrolchangedresponse(::AnselIpc::UIControlChangedResponse* uicontrolchangedresponse);

  // optional .AnselIpc.UIControlRemoveResponse uiControlRemoveResponse = 31;
  inline bool has_uicontrolremoveresponse() const;
  inline void clear_uicontrolremoveresponse();
  static const int kUiControlRemoveResponseFieldNumber = 31;
  inline const ::AnselIpc::UIControlRemoveResponse& uicontrolremoveresponse() const;
  inline ::AnselIpc::UIControlRemoveResponse* mutable_uicontrolremoveresponse();
  inline ::AnselIpc::UIControlRemoveResponse* release_uicontrolremoveresponse();
  inline void set_allocated_uicontrolremoveresponse(::AnselIpc::UIControlRemoveResponse* uicontrolremoveresponse);

  // optional .AnselIpc.UIControlSetVisibilityResponse uiControlSetVisibilityResponse = 32;
  inline bool has_uicontrolsetvisibilityresponse() const;
  inline void clear_uicontrolsetvisibilityresponse();
  static const int kUiControlSetVisibilityResponseFieldNumber = 32;
  inline const ::AnselIpc::UIControlSetVisibilityResponse& uicontrolsetvisibilityresponse() const;
  inline ::AnselIpc::UIControlSetVisibilityResponse* mutable_uicontrolsetvisibilityresponse();
  inline ::AnselIpc::UIControlSetVisibilityResponse* release_uicontrolsetvisibilityresponse();
  inline void set_allocated_uicontrolsetvisibilityresponse(::AnselIpc::UIControlSetVisibilityResponse* uicontrolsetvisibilityresponse);

  // optional .AnselIpc.UIControlGetVisibilityResponse uiControlGetVisibilityResponse = 33;
  inline bool has_uicontrolgetvisibilityresponse() const;
  inline void clear_uicontrolgetvisibilityresponse();
  static const int kUiControlGetVisibilityResponseFieldNumber = 33;
  inline const ::AnselIpc::UIControlGetVisibilityResponse& uicontrolgetvisibilityresponse() const;
  inline ::AnselIpc::UIControlGetVisibilityResponse* mutable_uicontrolgetvisibilityresponse();
  inline ::AnselIpc::UIControlGetVisibilityResponse* release_uicontrolgetvisibilityresponse();
  inline void set_allocated_uicontrolgetvisibilityresponse(::AnselIpc::UIControlGetVisibilityResponse* uicontrolgetvisibilityresponse);

  // optional .AnselIpc.GetProcessInfoResponse getProcessInfoResponse = 34;
  inline bool has_getprocessinforesponse() const;
  inline void clear_getprocessinforesponse();
  static const int kGetProcessInfoResponseFieldNumber = 34;
  inline const ::AnselIpc::GetProcessInfoResponse& getprocessinforesponse() const;
  inline ::AnselIpc::GetProcessInfoResponse* mutable_getprocessinforesponse();
  inline ::AnselIpc::GetProcessInfoResponse* release_getprocessinforesponse();
  inline void set_allocated_getprocessinforesponse(::AnselIpc::GetProcessInfoResponse* getprocessinforesponse);

  // optional .AnselIpc.GetScreenResolutionResponse getScreenResolutionResponse = 35;
  inline bool has_getscreenresolutionresponse() const;
  inline void clear_getscreenresolutionresponse();
  static const int kGetScreenResolutionResponseFieldNumber = 35;
  inline const ::AnselIpc::GetScreenResolutionResponse& getscreenresolutionresponse() const;
  inline ::AnselIpc::GetScreenResolutionResponse* mutable_getscreenresolutionresponse();
  inline ::AnselIpc::GetScreenResolutionResponse* release_getscreenresolutionresponse();
  inline void set_allocated_getscreenresolutionresponse(::AnselIpc::GetScreenResolutionResponse* getscreenresolutionresponse);

  // optional .AnselIpc.IsAnselModdingAvailableResponse isAnselModdingAvailableResponse = 36;
  inline bool has_isanselmoddingavailableresponse() const;
  inline void clear_isanselmoddingavailableresponse();
  static const int kIsAnselModdingAvailableResponseFieldNumber = 36;
  inline const ::AnselIpc::IsAnselModdingAvailableResponse& isanselmoddingavailableresponse() const;
  inline ::AnselIpc::IsAnselModdingAvailableResponse* mutable_isanselmoddingavailableresponse();
  inline ::AnselIpc::IsAnselModdingAvailableResponse* release_isanselmoddingavailableresponse();
  inline void set_allocated_isanselmoddingavailableresponse(::AnselIpc::IsAnselModdingAvailableResponse* isanselmoddingavailableresponse);

  // optional .AnselIpc.SetGridOfThirdsEnabledResponse setGridOfThirdsEnabledResponse = 37;
  inline bool has_setgridofthirdsenabledresponse() const;
  inline void clear_setgridofthirdsenabledresponse();
  static const int kSetGridOfThirdsEnabledResponseFieldNumber = 37;
  inline const ::AnselIpc::SetGridOfThirdsEnabledResponse& setgridofthirdsenabledresponse() const;
  inline ::AnselIpc::SetGridOfThirdsEnabledResponse* mutable_setgridofthirdsenabledresponse();
  inline ::AnselIpc::SetGridOfThirdsEnabledResponse* release_setgridofthirdsenabledresponse();
  inline void set_allocated_setgridofthirdsenabledresponse(::AnselIpc::SetGridOfThirdsEnabledResponse* setgridofthirdsenabledresponse);

  // optional .AnselIpc.ResetEntireStackResponse resetEntireStackResponse = 38;
  inline bool has_resetentirestackresponse() const;
  inline void clear_resetentirestackresponse();
  static const int kResetEntireStackResponseFieldNumber = 38;
  inline const ::AnselIpc::ResetEntireStackResponse& resetentirestackresponse() const;
  inline ::AnselIpc::ResetEntireStackResponse* mutable_resetentirestackresponse();
  inline ::AnselIpc::ResetEntireStackResponse* release_resetentirestackresponse();
  inline void set_allocated_resetentirestackresponse(::AnselIpc::ResetEntireStackResponse* resetentirestackresponse);

  // optional .AnselIpc.GetFeatureSetResponse getFeatureSetResponse = 39;
  inline bool has_getfeaturesetresponse() const;
  inline void clear_getfeaturesetresponse();
  static const int kGetFeatureSetResponseFieldNumber = 39;
  inline const ::AnselIpc::GetFeatureSetResponse& getfeaturesetresponse() const;
  inline ::AnselIpc::GetFeatureSetResponse* mutable_getfeaturesetresponse();
  inline ::AnselIpc::GetFeatureSetResponse* release_getfeaturesetresponse();
  inline void set_allocated_getfeaturesetresponse(::AnselIpc::GetFeatureSetResponse* getfeaturesetresponse);

  // optional .AnselIpc.SetStyleTransferEnabledResponse setStyleTransferEnabledResponse = 40;
  inline bool has_setstyletransferenabledresponse() const;
  inline void clear_setstyletransferenabledresponse();
  static const int kSetStyleTransferEnabledResponseFieldNumber = 40;
  inline const ::AnselIpc::SetStyleTransferEnabledResponse& setstyletransferenabledresponse() const;
  inline ::AnselIpc::SetStyleTransferEnabledResponse* mutable_setstyletransferenabledresponse();
  inline ::AnselIpc::SetStyleTransferEnabledResponse* release_setstyletransferenabledresponse();
  inline void set_allocated_setstyletransferenabledresponse(::AnselIpc::SetStyleTransferEnabledResponse* setstyletransferenabledresponse);

  // optional .AnselIpc.SetStyleTransferStyleResponse setStyleTransferStyleResponse = 41;
  inline bool has_setstyletransferstyleresponse() const;
  inline void clear_setstyletransferstyleresponse();
  static const int kSetStyleTransferStyleResponseFieldNumber = 41;
  inline const ::AnselIpc::SetStyleTransferStyleResponse& setstyletransferstyleresponse() const;
  inline ::AnselIpc::SetStyleTransferStyleResponse* mutable_setstyletransferstyleresponse();
  inline ::AnselIpc::SetStyleTransferStyleResponse* release_setstyletransferstyleresponse();
  inline void set_allocated_setstyletransferstyleresponse(::AnselIpc::SetStyleTransferStyleResponse* setstyletransferstyleresponse);

  // optional .AnselIpc.GetStyleTransferModelListResponse getStyleTransferModelListResponse = 42;
  inline bool has_getstyletransfermodellistresponse() const;
  inline void clear_getstyletransfermodellistresponse();
  static const int kGetStyleTransferModelListResponseFieldNumber = 42;
  inline const ::AnselIpc::GetStyleTransferModelListResponse& getstyletransfermodellistresponse() const;
  inline ::AnselIpc::GetStyleTransferModelListResponse* mutable_getstyletransfermodellistresponse();
  inline ::AnselIpc::GetStyleTransferModelListResponse* release_getstyletransfermodellistresponse();
  inline void set_allocated_getstyletransfermodellistresponse(::AnselIpc::GetStyleTransferModelListResponse* getstyletransfermodellistresponse);

  // optional .AnselIpc.SetStyleTransferModelResponse setStyleTransferModelResponse = 43;
  inline bool has_setstyletransfermodelresponse() const;
  inline void clear_setstyletransfermodelresponse();
  static const int kSetStyleTransferModelResponseFieldNumber = 43;
  inline const ::AnselIpc::SetStyleTransferModelResponse& setstyletransfermodelresponse() const;
  inline ::AnselIpc::SetStyleTransferModelResponse* mutable_setstyletransfermodelresponse();
  inline ::AnselIpc::SetStyleTransferModelResponse* release_setstyletransfermodelresponse();
  inline void set_allocated_setstyletransfermodelresponse(::AnselIpc::SetStyleTransferModelResponse* setstyletransfermodelresponse);

  // optional .AnselIpc.StyleTransferStatusResponse styleTransferStatusResponse = 44;
  inline bool has_styletransferstatusresponse() const;
  inline void clear_styletransferstatusresponse();
  static const int kStyleTransferStatusResponseFieldNumber = 44;
  inline const ::AnselIpc::StyleTransferStatusResponse& styletransferstatusresponse() const;
  inline ::AnselIpc::StyleTransferStatusResponse* mutable_styletransferstatusresponse();
  inline ::AnselIpc::StyleTransferStatusResponse* release_styletransferstatusresponse();
  inline void set_allocated_styletransferstatusresponse(::AnselIpc::StyleTransferStatusResponse* styletransferstatusresponse);

  // optional .AnselIpc.MoveFilterResponse moveFilterResponse = 45;
  inline bool has_movefilterresponse() const;
  inline void clear_movefilterresponse();
  static const int kMoveFilterResponseFieldNumber = 45;
  inline const ::AnselIpc::MoveFilterResponse& movefilterresponse() const;
  inline ::AnselIpc::MoveFilterResponse* mutable_movefilterresponse();
  inline ::AnselIpc::MoveFilterResponse* release_movefilterresponse();
  inline void set_allocated_movefilterresponse(::AnselIpc::MoveFilterResponse* movefilterresponse);

  // optional .AnselIpc.GetStackInfoResponse getStackInfoResponse = 46;
  inline bool has_getstackinforesponse() const;
  inline void clear_getstackinforesponse();
  static const int kGetStackInfoResponseFieldNumber = 46;
  inline const ::AnselIpc::GetStackInfoResponse& getstackinforesponse() const;
  inline ::AnselIpc::GetStackInfoResponse* mutable_getstackinforesponse();
  inline ::AnselIpc::GetStackInfoResponse* release_getstackinforesponse();
  inline void set_allocated_getstackinforesponse(::AnselIpc::GetStackInfoResponse* getstackinforesponse);

  // optional .AnselIpc.InsertFilterResponse insertFilterResponse = 47;
  inline bool has_insertfilterresponse() const;
  inline void clear_insertfilterresponse();
  static const int kInsertFilterResponseFieldNumber = 47;
  inline const ::AnselIpc::InsertFilterResponse& insertfilterresponse() const;
  inline ::AnselIpc::InsertFilterResponse* mutable_insertfilterresponse();
  inline ::AnselIpc::InsertFilterResponse* release_insertfilterresponse();
  inline void set_allocated_insertfilterresponse(::AnselIpc::InsertFilterResponse* insertfilterresponse);

  // optional .AnselIpc.RemoveFilterResponse removeFilterResponse = 48;
  inline bool has_removefilterresponse() const;
  inline void clear_removefilterresponse();
  static const int kRemoveFilterResponseFieldNumber = 48;
  inline const ::AnselIpc::RemoveFilterResponse& removefilterresponse() const;
  inline ::AnselIpc::RemoveFilterResponse* mutable_removefilterresponse();
  inline ::AnselIpc::RemoveFilterResponse* release_removefilterresponse();
  inline void set_allocated_removefilterresponse(::AnselIpc::RemoveFilterResponse* removefilterresponse);

  // optional .AnselIpc.ReportErrorResponse reportErrorResponse = 49;
  inline bool has_reporterrorresponse() const;
  inline void clear_reporterrorresponse();
  static const int kReportErrorResponseFieldNumber = 49;
  inline const ::AnselIpc::ReportErrorResponse& reporterrorresponse() const;
  inline ::AnselIpc::ReportErrorResponse* mutable_reporterrorresponse();
  inline ::AnselIpc::ReportErrorResponse* release_reporterrorresponse();
  inline void set_allocated_reporterrorresponse(::AnselIpc::ReportErrorResponse* reporterrorresponse);

  // optional .AnselIpc.EstimateCaptureResponse estimateCaptureResponse = 50;
  inline bool has_estimatecaptureresponse() const;
  inline void clear_estimatecaptureresponse();
  static const int kEstimateCaptureResponseFieldNumber = 50;
  inline const ::AnselIpc::EstimateCaptureResponse& estimatecaptureresponse() const;
  inline ::AnselIpc::EstimateCaptureResponse* mutable_estimatecaptureresponse();
  inline ::AnselIpc::EstimateCaptureResponse* release_estimatecaptureresponse();
  inline void set_allocated_estimatecaptureresponse(::AnselIpc::EstimateCaptureResponse* estimatecaptureresponse);

  // optional .AnselIpc.UIControlRemoveAllResponse uiControlRemoveAllResponse = 51;
  inline bool has_uicontrolremoveallresponse() const;
  inline void clear_uicontrolremoveallresponse();
  static const int kUiControlRemoveAllResponseFieldNumber = 51;
  inline const ::AnselIpc::UIControlRemoveAllResponse& uicontrolremoveallresponse() const;
  inline ::AnselIpc::UIControlRemoveAllResponse* mutable_uicontrolremoveallresponse();
  inline ::AnselIpc::UIControlRemoveAllResponse* release_uicontrolremoveallresponse();
  inline void set_allocated_uicontrolremoveallresponse(::AnselIpc::UIControlRemoveAllResponse* uicontrolremoveallresponse);

  // optional .AnselIpc.GetSettingsResponse getSettingsResponse = 52;
  inline bool has_getsettingsresponse() const;
  inline void clear_getsettingsresponse();
  static const int kGetSettingsResponseFieldNumber = 52;
  inline const ::AnselIpc::GetSettingsResponse& getsettingsresponse() const;
  inline ::AnselIpc::GetSettingsResponse* mutable_getsettingsresponse();
  inline ::AnselIpc::GetSettingsResponse* release_getsettingsresponse();
  inline void set_allocated_getsettingsresponse(::AnselIpc::GetSettingsResponse* getsettingsresponse);

  // optional .AnselIpc.AnselStatusReportResponse anselStatusReportResponse = 53;
  inline bool has_anselstatusreportresponse() const;
  inline void clear_anselstatusreportresponse();
  static const int kAnselStatusReportResponseFieldNumber = 53;
  inline const ::AnselIpc::AnselStatusReportResponse& anselstatusreportresponse() const;
  inline ::AnselIpc::AnselStatusReportResponse* mutable_anselstatusreportresponse();
  inline ::AnselIpc::AnselStatusReportResponse* release_anselstatusreportresponse();
  inline void set_allocated_anselstatusreportresponse(::AnselIpc::AnselStatusReportResponse* anselstatusreportresponse);

  // optional .AnselIpc.StyleTransferSideloadChoiceResponse styleTransferSideloadChoiceResponse = 54;
  inline bool has_styletransfersideloadchoiceresponse() const;
  inline void clear_styletransfersideloadchoiceresponse();
  static const int kStyleTransferSideloadChoiceResponseFieldNumber = 54;
  inline const ::AnselIpc::StyleTransferSideloadChoiceResponse& styletransfersideloadchoiceresponse() const;
  inline ::AnselIpc::StyleTransferSideloadChoiceResponse* mutable_styletransfersideloadchoiceresponse();
  inline ::AnselIpc::StyleTransferSideloadChoiceResponse* release_styletransfersideloadchoiceresponse();
  inline void set_allocated_styletransfersideloadchoiceresponse(::AnselIpc::StyleTransferSideloadChoiceResponse* styletransfersideloadchoiceresponse);

  // optional .AnselIpc.StyleTransferSideloadProgressResponse styleTransferSideloadProgressResponse = 55;
  inline bool has_styletransfersideloadprogressresponse() const;
  inline void clear_styletransfersideloadprogressresponse();
  static const int kStyleTransferSideloadProgressResponseFieldNumber = 55;
  inline const ::AnselIpc::StyleTransferSideloadProgressResponse& styletransfersideloadprogressresponse() const;
  inline ::AnselIpc::StyleTransferSideloadProgressResponse* mutable_styletransfersideloadprogressresponse();
  inline ::AnselIpc::StyleTransferSideloadProgressResponse* release_styletransfersideloadprogressresponse();
  inline void set_allocated_styletransfersideloadprogressresponse(::AnselIpc::StyleTransferSideloadProgressResponse* styletransfersideloadprogressresponse);

  // optional .AnselIpc.UpdateRollResponse updateRollResponse = 56;
  inline bool has_updaterollresponse() const;
  inline void clear_updaterollresponse();
  static const int kUpdateRollResponseFieldNumber = 56;
  inline const ::AnselIpc::UpdateRollResponse& updaterollresponse() const;
  inline ::AnselIpc::UpdateRollResponse* mutable_updaterollresponse();
  inline ::AnselIpc::UpdateRollResponse* release_updaterollresponse();
  inline void set_allocated_updaterollresponse(::AnselIpc::UpdateRollResponse* updaterollresponse);

  // optional .AnselIpc.GetEnabledFeatureSetResponse getEnabledFeatureSetResponse = 57;
  inline bool has_getenabledfeaturesetresponse() const;
  inline void clear_getenabledfeaturesetresponse();
  static const int kGetEnabledFeatureSetResponseFieldNumber = 57;
  inline const ::AnselIpc::GetEnabledFeatureSetResponse& getenabledfeaturesetresponse() const;
  inline ::AnselIpc::GetEnabledFeatureSetResponse* mutable_getenabledfeaturesetresponse();
  inline ::AnselIpc::GetEnabledFeatureSetResponse* release_getenabledfeaturesetresponse();
  inline void set_allocated_getenabledfeaturesetresponse(::AnselIpc::GetEnabledFeatureSetResponse* getenabledfeaturesetresponse);

  // optional .AnselIpc.UpdateFovResponse updateFovResponse = 58;
  inline bool has_updatefovresponse() const;
  inline void clear_updatefovresponse();
  static const int kUpdateFovResponseFieldNumber = 58;
  inline const ::AnselIpc::UpdateFovResponse& updatefovresponse() const;
  inline ::AnselIpc::UpdateFovResponse* mutable_updatefovresponse();
  inline ::AnselIpc::UpdateFovResponse* release_updatefovresponse();
  inline void set_allocated_updatefovresponse(::AnselIpc::UpdateFovResponse* updatefovresponse);

  // optional .AnselIpc.AnselReadyResponse anselReadyResponse = 59;
  inline bool has_anselreadyresponse() const;
  inline void clear_anselreadyresponse();
  static const int kAnselReadyResponseFieldNumber = 59;
  inline const ::AnselIpc::AnselReadyResponse& anselreadyresponse() const;
  inline ::AnselIpc::AnselReadyResponse* mutable_anselreadyresponse();
  inline ::AnselIpc::AnselReadyResponse* release_anselreadyresponse();
  inline void set_allocated_anselreadyresponse(::AnselIpc::AnselReadyResponse* anselreadyresponse);

  // optional .AnselIpc.SetHighQualityResponse setHighQualityResponse = 60;
  inline bool has_sethighqualityresponse() const;
  inline void clear_sethighqualityresponse();
  static const int kSetHighQualityResponseFieldNumber = 60;
  inline const ::AnselIpc::SetHighQualityResponse& sethighqualityresponse() const;
  inline ::AnselIpc::SetHighQualityResponse* mutable_sethighqualityresponse();
  inline ::AnselIpc::SetHighQualityResponse* release_sethighqualityresponse();
  inline void set_allocated_sethighqualityresponse(::AnselIpc::SetHighQualityResponse* sethighqualityresponse);

  // optional .AnselIpc.SetFilterAndAttributesResponse setFilterAndAttributesResponse = 61;
  inline bool has_setfilterandattributesresponse() const;
  inline void clear_setfilterandattributesresponse();
  static const int kSetFilterAndAttributesResponseFieldNumber = 61;
  inline const ::AnselIpc::SetFilterAndAttributesResponse& setfilterandattributesresponse() const;
  inline ::AnselIpc::SetFilterAndAttributesResponse* mutable_setfilterandattributesresponse();
  inline ::AnselIpc::SetFilterAndAttributesResponse* release_setfilterandattributesresponse();
  inline void set_allocated_setfilterandattributesresponse(::AnselIpc::SetFilterAndAttributesResponse* setfilterandattributesresponse);

  // optional .AnselIpc.SetCMSInfoResponse setCMSInfoResponse = 62;
  inline bool has_setcmsinforesponse() const;
  inline void clear_setcmsinforesponse();
  static const int kSetCMSInfoResponseFieldNumber = 62;
  inline const ::AnselIpc::SetCMSInfoResponse& setcmsinforesponse() const;
  inline ::AnselIpc::SetCMSInfoResponse* mutable_setcmsinforesponse();
  inline ::AnselIpc::SetCMSInfoResponse* release_setcmsinforesponse();
  inline void set_allocated_setcmsinforesponse(::AnselIpc::SetCMSInfoResponse* setcmsinforesponse);

  inline ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:AnselIpc.AnselIPCResponse)
 private:
  inline void set_has_getfilterlistresponse();
  inline void set_has_gethighresresolutionlistresponse();
  inline void set_has_captureshotstartedresponse();
  inline void set_has_captureshotfinishedresponse();
  inline void set_has_captureshotprocessingfinishedresponse();
  inline void set_has_get360resolutionrangeresponse();
  inline void set_has_getfovrangeresponse();
  inline void set_has_setfovresponse();
  inline void set_has_getrollrangeresponse();
  inline void set_has_setrollresponse();
  inline void set_has_setanselenabledresponse();
  inline void set_has_abortcaptureresponse();
  inline void set_has_getanselenabledresponse();
  inline void set_has_getlwrrentfovresponse();
  inline void set_has_captureshotprogressresponse();
  inline void set_has_logfilenameresponse();
  inline void set_has_setfilterresponse();
  inline void set_has_setfilterattributeresponse();
  inline void set_has_isanselavailableresponse();
  inline void set_has_screenresolutionchangedresponse();
  inline void set_has_getanselshotpermissionsresponse();
  inline void set_has_inputeventresponse();
  inline void set_has_setlangidresponse();
  inline void set_has_getfilterinforesponse();
  inline void set_has_resetfiltervaluesresponse();
  inline void set_has_isanselsdkintegrationavailableresponse();
  inline void set_has_ipcversionresponse();
  inline void set_has_adduielementresponse();
  inline void set_has_uireadyresponse();
  inline void set_has_uicontrolchangedresponse();
  inline void set_has_uicontrolremoveresponse();
  inline void set_has_uicontrolsetvisibilityresponse();
  inline void set_has_uicontrolgetvisibilityresponse();
  inline void set_has_getprocessinforesponse();
  inline void set_has_getscreenresolutionresponse();
  inline void set_has_isanselmoddingavailableresponse();
  inline void set_has_setgridofthirdsenabledresponse();
  inline void set_has_resetentirestackresponse();
  inline void set_has_getfeaturesetresponse();
  inline void set_has_setstyletransferenabledresponse();
  inline void set_has_setstyletransferstyleresponse();
  inline void set_has_getstyletransfermodellistresponse();
  inline void set_has_setstyletransfermodelresponse();
  inline void set_has_styletransferstatusresponse();
  inline void set_has_movefilterresponse();
  inline void set_has_getstackinforesponse();
  inline void set_has_insertfilterresponse();
  inline void set_has_removefilterresponse();
  inline void set_has_reporterrorresponse();
  inline void set_has_estimatecaptureresponse();
  inline void set_has_uicontrolremoveallresponse();
  inline void set_has_getsettingsresponse();
  inline void set_has_anselstatusreportresponse();
  inline void set_has_styletransfersideloadchoiceresponse();
  inline void set_has_styletransfersideloadprogressresponse();
  inline void set_has_updaterollresponse();
  inline void set_has_getenabledfeaturesetresponse();
  inline void set_has_updatefovresponse();
  inline void set_has_anselreadyresponse();
  inline void set_has_sethighqualityresponse();
  inline void set_has_setfilterandattributesresponse();
  inline void set_has_setcmsinforesponse();

  inline bool has_response();
  void clear_response();
  inline void clear_has_response();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[2];
  union ResponseUnion {
    ::AnselIpc::GetFilterListResponse* getfilterlistresponse_;
    ::AnselIpc::GetHighresResolutionListResponse* gethighresresolutionlistresponse_;
    ::AnselIpc::CaptureShotStartedResponse* captureshotstartedresponse_;
    ::AnselIpc::CaptureShotFinishedResponse* captureshotfinishedresponse_;
    ::AnselIpc::CaptureShotProcessingFinishedResponse* captureshotprocessingfinishedresponse_;
    ::AnselIpc::Get360ResolutionRangeResponse* get360resolutionrangeresponse_;
    ::AnselIpc::GetFOVRangeResponse* getfovrangeresponse_;
    ::AnselIpc::SetFOVResponse* setfovresponse_;
    ::AnselIpc::GetRollRangeResponse* getrollrangeresponse_;
    ::AnselIpc::SetRollResponse* setrollresponse_;
    ::AnselIpc::SetAnselEnabledResponse* setanselenabledresponse_;
    ::AnselIpc::AbortCaptureResponse* abortcaptureresponse_;
    ::AnselIpc::GetAnselEnabledResponse* getanselenabledresponse_;
    ::AnselIpc::GetLwrrentFOVResponse* getlwrrentfovresponse_;
    ::AnselIpc::CaptureShotProgressResponse* captureshotprogressresponse_;
    ::AnselIpc::LogFilenameResponse* logfilenameresponse_;
    ::AnselIpc::SetFilterResponse* setfilterresponse_;
    ::AnselIpc::SetFilterAttributeResponse* setfilterattributeresponse_;
    ::AnselIpc::IsAnselAvailableResponse* isanselavailableresponse_;
    ::AnselIpc::ScreenResolutionChangedResponse* screenresolutionchangedresponse_;
    ::AnselIpc::GetAnselShotPermissionsResponse* getanselshotpermissionsresponse_;
    ::AnselIpc::InputEventResponse* inputeventresponse_;
    ::AnselIpc::SetLangIdResponse* setlangidresponse_;
    ::AnselIpc::GetFilterInfoResponse* getfilterinforesponse_;
    ::AnselIpc::ResetFilterValuesResponse* resetfiltervaluesresponse_;
    ::AnselIpc::IsAnselSDKIntegrationAvailableResponse* isanselsdkintegrationavailableresponse_;
    ::AnselIpc::IpcVersionResponse* ipcversionresponse_;
    ::AnselIpc::AddUIElementResponse* adduielementresponse_;
    ::AnselIpc::UIReadyResponse* uireadyresponse_;
    ::AnselIpc::UIControlChangedResponse* uicontrolchangedresponse_;
    ::AnselIpc::UIControlRemoveResponse* uicontrolremoveresponse_;
    ::AnselIpc::UIControlSetVisibilityResponse* uicontrolsetvisibilityresponse_;
    ::AnselIpc::UIControlGetVisibilityResponse* uicontrolgetvisibilityresponse_;
    ::AnselIpc::GetProcessInfoResponse* getprocessinforesponse_;
    ::AnselIpc::GetScreenResolutionResponse* getscreenresolutionresponse_;
    ::AnselIpc::IsAnselModdingAvailableResponse* isanselmoddingavailableresponse_;
    ::AnselIpc::SetGridOfThirdsEnabledResponse* setgridofthirdsenabledresponse_;
    ::AnselIpc::ResetEntireStackResponse* resetentirestackresponse_;
    ::AnselIpc::GetFeatureSetResponse* getfeaturesetresponse_;
    ::AnselIpc::SetStyleTransferEnabledResponse* setstyletransferenabledresponse_;
    ::AnselIpc::SetStyleTransferStyleResponse* setstyletransferstyleresponse_;
    ::AnselIpc::GetStyleTransferModelListResponse* getstyletransfermodellistresponse_;
    ::AnselIpc::SetStyleTransferModelResponse* setstyletransfermodelresponse_;
    ::AnselIpc::StyleTransferStatusResponse* styletransferstatusresponse_;
    ::AnselIpc::MoveFilterResponse* movefilterresponse_;
    ::AnselIpc::GetStackInfoResponse* getstackinforesponse_;
    ::AnselIpc::InsertFilterResponse* insertfilterresponse_;
    ::AnselIpc::RemoveFilterResponse* removefilterresponse_;
    ::AnselIpc::ReportErrorResponse* reporterrorresponse_;
    ::AnselIpc::EstimateCaptureResponse* estimatecaptureresponse_;
    ::AnselIpc::UIControlRemoveAllResponse* uicontrolremoveallresponse_;
    ::AnselIpc::GetSettingsResponse* getsettingsresponse_;
    ::AnselIpc::AnselStatusReportResponse* anselstatusreportresponse_;
    ::AnselIpc::StyleTransferSideloadChoiceResponse* styletransfersideloadchoiceresponse_;
    ::AnselIpc::StyleTransferSideloadProgressResponse* styletransfersideloadprogressresponse_;
    ::AnselIpc::UpdateRollResponse* updaterollresponse_;
    ::AnselIpc::GetEnabledFeatureSetResponse* getenabledfeaturesetresponse_;
    ::AnselIpc::UpdateFovResponse* updatefovresponse_;
    ::AnselIpc::AnselReadyResponse* anselreadyresponse_;
    ::AnselIpc::SetHighQualityResponse* sethighqualityresponse_;
    ::AnselIpc::SetFilterAndAttributesResponse* setfilterandattributesresponse_;
    ::AnselIpc::SetCMSInfoResponse* setcmsinforesponse_;
  } response_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static AnselIPCResponse* default_instance_;
};
// -------------------------------------------------------------------

class AnselIPCMessage : public ::google::protobuf::Message {
 public:
  AnselIPCMessage();
  virtual ~AnselIPCMessage();

  AnselIPCMessage(const AnselIPCMessage& from);

  inline AnselIPCMessage& operator=(const AnselIPCMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnselIPCMessage& default_instance();

  enum MessageCase {
    kRequest = 1,
    kResponse = 2,
    MESSAGE_NOT_SET = 0,
  };

  void Swap(AnselIPCMessage* other);

  // implements Message ----------------------------------------------

  AnselIPCMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnselIPCMessage& from);
  void MergeFrom(const AnselIPCMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .AnselIpc.AnselIPCRequest request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::AnselIpc::AnselIPCRequest& request() const;
  inline ::AnselIpc::AnselIPCRequest* mutable_request();
  inline ::AnselIpc::AnselIPCRequest* release_request();
  inline void set_allocated_request(::AnselIpc::AnselIPCRequest* request);

  // optional .AnselIpc.AnselIPCResponse response = 2;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 2;
  inline const ::AnselIpc::AnselIPCResponse& response() const;
  inline ::AnselIpc::AnselIPCResponse* mutable_response();
  inline ::AnselIpc::AnselIPCResponse* release_response();
  inline void set_allocated_response(::AnselIpc::AnselIPCResponse* response);

  inline MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:AnselIpc.AnselIPCMessage)
 private:
  inline void set_has_request();
  inline void set_has_response();

  inline bool has_message();
  void clear_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union MessageUnion {
    ::AnselIpc::AnselIPCRequest* request_;
    ::AnselIpc::AnselIPCResponse* response_;
  } message_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();

  void InitAsDefaultInstance();
  static AnselIPCMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// IpcVersionRequest

// -------------------------------------------------------------------

// IpcVersionResponse

// required uint32 major = 1 [default = 7];
inline bool IpcVersionResponse::has_major() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IpcVersionResponse::set_has_major() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IpcVersionResponse::clear_has_major() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IpcVersionResponse::clear_major() {
  major_ = 7u;
  clear_has_major();
}
inline ::google::protobuf::uint32 IpcVersionResponse::major() const {
  // @@protoc_insertion_point(field_get:AnselIpc.IpcVersionResponse.major)
  return major_;
}
inline void IpcVersionResponse::set_major(::google::protobuf::uint32 value) {
  set_has_major();
  major_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.IpcVersionResponse.major)
}

// required uint32 minor = 2 [default = 8];
inline bool IpcVersionResponse::has_minor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IpcVersionResponse::set_has_minor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IpcVersionResponse::clear_has_minor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IpcVersionResponse::clear_minor() {
  minor_ = 8u;
  clear_has_minor();
}
inline ::google::protobuf::uint32 IpcVersionResponse::minor() const {
  // @@protoc_insertion_point(field_get:AnselIpc.IpcVersionResponse.minor)
  return minor_;
}
inline void IpcVersionResponse::set_minor(::google::protobuf::uint32 value) {
  set_has_minor();
  minor_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.IpcVersionResponse.minor)
}

// required uint32 patch = 3 [default = 0];
inline bool IpcVersionResponse::has_patch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IpcVersionResponse::set_has_patch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IpcVersionResponse::clear_has_patch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IpcVersionResponse::clear_patch() {
  patch_ = 0u;
  clear_has_patch();
}
inline ::google::protobuf::uint32 IpcVersionResponse::patch() const {
  // @@protoc_insertion_point(field_get:AnselIpc.IpcVersionResponse.patch)
  return patch_;
}
inline void IpcVersionResponse::set_patch(::google::protobuf::uint32 value) {
  set_has_patch();
  patch_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.IpcVersionResponse.patch)
}

// -------------------------------------------------------------------

// AnselReadyRequest

// required uint32 creationCounter = 1;
inline bool AnselReadyRequest::has_creationcounter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnselReadyRequest::set_has_creationcounter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnselReadyRequest::clear_has_creationcounter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnselReadyRequest::clear_creationcounter() {
  creationcounter_ = 0u;
  clear_has_creationcounter();
}
inline ::google::protobuf::uint32 AnselReadyRequest::creationcounter() const {
  // @@protoc_insertion_point(field_get:AnselIpc.AnselReadyRequest.creationCounter)
  return creationcounter_;
}
inline void AnselReadyRequest::set_creationcounter(::google::protobuf::uint32 value) {
  set_has_creationcounter();
  creationcounter_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.AnselReadyRequest.creationCounter)
}

// -------------------------------------------------------------------

// AnselReadyResponse

// required .AnselIpc.Status status = 1;
inline bool AnselReadyResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnselReadyResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnselReadyResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnselReadyResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status AnselReadyResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.AnselReadyResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void AnselReadyResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.AnselReadyResponse.status)
}

// -------------------------------------------------------------------

// AnselStatusReportRequest_OneofOptionalData

// optional int32 integerValue = 1;
inline bool AnselStatusReportRequest_OneofOptionalData::has_integervalue() const {
  return data_case() == kIntegerValue;
}
inline void AnselStatusReportRequest_OneofOptionalData::set_has_integervalue() {
  _oneof_case_[0] = kIntegerValue;
}
inline void AnselStatusReportRequest_OneofOptionalData::clear_integervalue() {
  if (has_integervalue()) {
    data_.integervalue_ = 0;
    clear_has_data();
  }
}
inline ::google::protobuf::int32 AnselStatusReportRequest_OneofOptionalData::integervalue() const {
  if (has_integervalue()) {
    return data_.integervalue_;
  }
  return 0;
}
inline void AnselStatusReportRequest_OneofOptionalData::set_integervalue(::google::protobuf::int32 value) {
  if (!has_integervalue()) {
    clear_data();
    set_has_integervalue();
  }
  data_.integervalue_ = value;
}

// optional string stringValue = 2;
inline bool AnselStatusReportRequest_OneofOptionalData::has_stringvalue() const {
  return data_case() == kStringValue;
}
inline void AnselStatusReportRequest_OneofOptionalData::set_has_stringvalue() {
  _oneof_case_[0] = kStringValue;
}
inline void AnselStatusReportRequest_OneofOptionalData::clear_stringvalue() {
  if (has_stringvalue()) {
    delete data_.stringvalue_;
    clear_has_data();
  }
}
inline const ::std::string& AnselStatusReportRequest_OneofOptionalData::stringvalue() const {
  if (has_stringvalue()) {
    return *data_.stringvalue_;
  }
  return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void AnselStatusReportRequest_OneofOptionalData::set_stringvalue(const ::std::string& value) {
  if (!has_stringvalue()) {
    clear_data();
    set_has_stringvalue();
    data_.stringvalue_ = new ::std::string;
  }
  data_.stringvalue_->assign(value);
}
inline void AnselStatusReportRequest_OneofOptionalData::set_stringvalue(const char* value) {
  if (!has_stringvalue()) {
    clear_data();
    set_has_stringvalue();
    data_.stringvalue_ = new ::std::string;
  }
  data_.stringvalue_->assign(value);
}
inline void AnselStatusReportRequest_OneofOptionalData::set_stringvalue(const char* value, size_t size) {
  if (!has_stringvalue()) {
    clear_data();
    set_has_stringvalue();
    data_.stringvalue_ = new ::std::string;
  }
  data_.stringvalue_->assign(
      reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AnselStatusReportRequest_OneofOptionalData::mutable_stringvalue() {
  if (!has_stringvalue()) {
    clear_data();
    set_has_stringvalue();
    data_.stringvalue_ = new ::std::string;
  }
  return data_.stringvalue_;
}
inline ::std::string* AnselStatusReportRequest_OneofOptionalData::release_stringvalue() {
  if (has_stringvalue()) {
    clear_has_data();
    ::std::string* temp = data_.stringvalue_;
    data_.stringvalue_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselStatusReportRequest_OneofOptionalData::set_allocated_stringvalue(::std::string* stringvalue) {
  clear_data();
  if (stringvalue) {
    set_has_stringvalue();
    data_.stringvalue_ = stringvalue;
  }
}

// optional float floatValue = 3;
inline bool AnselStatusReportRequest_OneofOptionalData::has_floatvalue() const {
  return data_case() == kFloatValue;
}
inline void AnselStatusReportRequest_OneofOptionalData::set_has_floatvalue() {
  _oneof_case_[0] = kFloatValue;
}
inline void AnselStatusReportRequest_OneofOptionalData::clear_floatvalue() {
  if (has_floatvalue()) {
    data_.floatvalue_ = 0;
    clear_has_data();
  }
}
inline float AnselStatusReportRequest_OneofOptionalData::floatvalue() const {
  if (has_floatvalue()) {
    return data_.floatvalue_;
  }
  return 0;
}
inline void AnselStatusReportRequest_OneofOptionalData::set_floatvalue(float value) {
  if (!has_floatvalue()) {
    clear_data();
    set_has_floatvalue();
  }
  data_.floatvalue_ = value;
}

// optional bool boolValue = 4;
inline bool AnselStatusReportRequest_OneofOptionalData::has_boolvalue() const {
  return data_case() == kBoolValue;
}
inline void AnselStatusReportRequest_OneofOptionalData::set_has_boolvalue() {
  _oneof_case_[0] = kBoolValue;
}
inline void AnselStatusReportRequest_OneofOptionalData::clear_boolvalue() {
  if (has_boolvalue()) {
    data_.boolvalue_ = false;
    clear_has_data();
  }
}
inline bool AnselStatusReportRequest_OneofOptionalData::boolvalue() const {
  if (has_boolvalue()) {
    return data_.boolvalue_;
  }
  return false;
}
inline void AnselStatusReportRequest_OneofOptionalData::set_boolvalue(bool value) {
  if (!has_boolvalue()) {
    clear_data();
    set_has_boolvalue();
  }
  data_.boolvalue_ = value;
}

inline bool AnselStatusReportRequest_OneofOptionalData::has_data() {
  return data_case() != DATA_NOT_SET;
}
inline void AnselStatusReportRequest_OneofOptionalData::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline AnselStatusReportRequest_OneofOptionalData::DataCase AnselStatusReportRequest_OneofOptionalData::data_case() const {
  return AnselStatusReportRequest_OneofOptionalData::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AnselStatusReportRequest

// required .AnselIpc.Status status = 1;
inline bool AnselStatusReportRequest::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnselStatusReportRequest::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnselStatusReportRequest::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnselStatusReportRequest::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status AnselStatusReportRequest::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.AnselStatusReportRequest.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void AnselStatusReportRequest::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.AnselStatusReportRequest.status)
}

// repeated .AnselIpc.AnselStatusReportRequest.OneofOptionalData data = 2;
inline int AnselStatusReportRequest::data_size() const {
  return data_.size();
}
inline void AnselStatusReportRequest::clear_data() {
  data_.Clear();
}
inline const ::AnselIpc::AnselStatusReportRequest_OneofOptionalData& AnselStatusReportRequest::data(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.AnselStatusReportRequest.data)
  return data_.Get(index);
}
inline ::AnselIpc::AnselStatusReportRequest_OneofOptionalData* AnselStatusReportRequest::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:AnselIpc.AnselStatusReportRequest.data)
  return data_.Mutable(index);
}
inline ::AnselIpc::AnselStatusReportRequest_OneofOptionalData* AnselStatusReportRequest::add_data() {
  // @@protoc_insertion_point(field_add:AnselIpc.AnselStatusReportRequest.data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::AnselStatusReportRequest_OneofOptionalData >&
AnselStatusReportRequest::data() const {
  // @@protoc_insertion_point(field_list:AnselIpc.AnselStatusReportRequest.data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::AnselStatusReportRequest_OneofOptionalData >*
AnselStatusReportRequest::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.AnselStatusReportRequest.data)
  return &data_;
}

// -------------------------------------------------------------------

// AnselStatusReportResponse

// required .AnselIpc.Status status = 1;
inline bool AnselStatusReportResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnselStatusReportResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnselStatusReportResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnselStatusReportResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status AnselStatusReportResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.AnselStatusReportResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void AnselStatusReportResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.AnselStatusReportResponse.status)
}

// -------------------------------------------------------------------

// SetStyleTransferEnabledRequest

// required bool enabled = 1;
inline bool SetStyleTransferEnabledRequest::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetStyleTransferEnabledRequest::set_has_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetStyleTransferEnabledRequest::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetStyleTransferEnabledRequest::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool SetStyleTransferEnabledRequest::enabled() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetStyleTransferEnabledRequest.enabled)
  return enabled_;
}
inline void SetStyleTransferEnabledRequest::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetStyleTransferEnabledRequest.enabled)
}

// -------------------------------------------------------------------

// SetStyleTransferEnabledResponse

// required .AnselIpc.Status status = 1;
inline bool SetStyleTransferEnabledResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetStyleTransferEnabledResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetStyleTransferEnabledResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetStyleTransferEnabledResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status SetStyleTransferEnabledResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetStyleTransferEnabledResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void SetStyleTransferEnabledResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetStyleTransferEnabledResponse.status)
}

// -------------------------------------------------------------------

// SetStyleTransferStyleRequest

// required string fullyQualifiedPath = 1;
inline bool SetStyleTransferStyleRequest::has_fullyqualifiedpath() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetStyleTransferStyleRequest::set_has_fullyqualifiedpath() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetStyleTransferStyleRequest::clear_has_fullyqualifiedpath() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetStyleTransferStyleRequest::clear_fullyqualifiedpath() {
  if (fullyqualifiedpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fullyqualifiedpath_->clear();
  }
  clear_has_fullyqualifiedpath();
}
inline const ::std::string& SetStyleTransferStyleRequest::fullyqualifiedpath() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetStyleTransferStyleRequest.fullyQualifiedPath)
  return *fullyqualifiedpath_;
}
inline void SetStyleTransferStyleRequest::set_fullyqualifiedpath(const ::std::string& value) {
  set_has_fullyqualifiedpath();
  if (fullyqualifiedpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fullyqualifiedpath_ = new ::std::string;
  }
  fullyqualifiedpath_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.SetStyleTransferStyleRequest.fullyQualifiedPath)
}
inline void SetStyleTransferStyleRequest::set_fullyqualifiedpath(const char* value) {
  set_has_fullyqualifiedpath();
  if (fullyqualifiedpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fullyqualifiedpath_ = new ::std::string;
  }
  fullyqualifiedpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.SetStyleTransferStyleRequest.fullyQualifiedPath)
}
inline void SetStyleTransferStyleRequest::set_fullyqualifiedpath(const char* value, size_t size) {
  set_has_fullyqualifiedpath();
  if (fullyqualifiedpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fullyqualifiedpath_ = new ::std::string;
  }
  fullyqualifiedpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.SetStyleTransferStyleRequest.fullyQualifiedPath)
}
inline ::std::string* SetStyleTransferStyleRequest::mutable_fullyqualifiedpath() {
  set_has_fullyqualifiedpath();
  if (fullyqualifiedpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fullyqualifiedpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.SetStyleTransferStyleRequest.fullyQualifiedPath)
  return fullyqualifiedpath_;
}
inline ::std::string* SetStyleTransferStyleRequest::release_fullyqualifiedpath() {
  clear_has_fullyqualifiedpath();
  if (fullyqualifiedpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fullyqualifiedpath_;
    fullyqualifiedpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetStyleTransferStyleRequest::set_allocated_fullyqualifiedpath(::std::string* fullyqualifiedpath) {
  if (fullyqualifiedpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fullyqualifiedpath_;
  }
  if (fullyqualifiedpath) {
    set_has_fullyqualifiedpath();
    fullyqualifiedpath_ = fullyqualifiedpath;
  } else {
    clear_has_fullyqualifiedpath();
    fullyqualifiedpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.SetStyleTransferStyleRequest.fullyQualifiedPath)
}

// -------------------------------------------------------------------

// SetStyleTransferStyleResponse

// required .AnselIpc.Status status = 1;
inline bool SetStyleTransferStyleResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetStyleTransferStyleResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetStyleTransferStyleResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetStyleTransferStyleResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status SetStyleTransferStyleResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetStyleTransferStyleResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void SetStyleTransferStyleResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetStyleTransferStyleResponse.status)
}

// -------------------------------------------------------------------

// GetStyleTransferModelListRequest

// -------------------------------------------------------------------

// GetStyleTransferModelListResponse_ModelDescription

// required string id = 1;
inline bool GetStyleTransferModelListResponse_ModelDescription::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetStyleTransferModelListResponse_ModelDescription::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetStyleTransferModelListResponse_ModelDescription::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetStyleTransferModelListResponse_ModelDescription::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& GetStyleTransferModelListResponse_ModelDescription::id() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetStyleTransferModelListResponse.ModelDescription.id)
  return *id_;
}
inline void GetStyleTransferModelListResponse_ModelDescription::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.GetStyleTransferModelListResponse.ModelDescription.id)
}
inline void GetStyleTransferModelListResponse_ModelDescription::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.GetStyleTransferModelListResponse.ModelDescription.id)
}
inline void GetStyleTransferModelListResponse_ModelDescription::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.GetStyleTransferModelListResponse.ModelDescription.id)
}
inline ::std::string* GetStyleTransferModelListResponse_ModelDescription::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.GetStyleTransferModelListResponse.ModelDescription.id)
  return id_;
}
inline ::std::string* GetStyleTransferModelListResponse_ModelDescription::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetStyleTransferModelListResponse_ModelDescription::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.GetStyleTransferModelListResponse.ModelDescription.id)
}

// required string localizedName = 2;
inline bool GetStyleTransferModelListResponse_ModelDescription::has_localizedname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetStyleTransferModelListResponse_ModelDescription::set_has_localizedname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetStyleTransferModelListResponse_ModelDescription::clear_has_localizedname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetStyleTransferModelListResponse_ModelDescription::clear_localizedname() {
  if (localizedname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localizedname_->clear();
  }
  clear_has_localizedname();
}
inline const ::std::string& GetStyleTransferModelListResponse_ModelDescription::localizedname() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetStyleTransferModelListResponse.ModelDescription.localizedName)
  return *localizedname_;
}
inline void GetStyleTransferModelListResponse_ModelDescription::set_localizedname(const ::std::string& value) {
  set_has_localizedname();
  if (localizedname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localizedname_ = new ::std::string;
  }
  localizedname_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.GetStyleTransferModelListResponse.ModelDescription.localizedName)
}
inline void GetStyleTransferModelListResponse_ModelDescription::set_localizedname(const char* value) {
  set_has_localizedname();
  if (localizedname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localizedname_ = new ::std::string;
  }
  localizedname_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.GetStyleTransferModelListResponse.ModelDescription.localizedName)
}
inline void GetStyleTransferModelListResponse_ModelDescription::set_localizedname(const char* value, size_t size) {
  set_has_localizedname();
  if (localizedname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localizedname_ = new ::std::string;
  }
  localizedname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.GetStyleTransferModelListResponse.ModelDescription.localizedName)
}
inline ::std::string* GetStyleTransferModelListResponse_ModelDescription::mutable_localizedname() {
  set_has_localizedname();
  if (localizedname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localizedname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.GetStyleTransferModelListResponse.ModelDescription.localizedName)
  return localizedname_;
}
inline ::std::string* GetStyleTransferModelListResponse_ModelDescription::release_localizedname() {
  clear_has_localizedname();
  if (localizedname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = localizedname_;
    localizedname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetStyleTransferModelListResponse_ModelDescription::set_allocated_localizedname(::std::string* localizedname) {
  if (localizedname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete localizedname_;
  }
  if (localizedname) {
    set_has_localizedname();
    localizedname_ = localizedname;
  } else {
    clear_has_localizedname();
    localizedname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.GetStyleTransferModelListResponse.ModelDescription.localizedName)
}

// -------------------------------------------------------------------

// GetStyleTransferModelListResponse

// repeated .AnselIpc.GetStyleTransferModelListResponse.ModelDescription models = 1;
inline int GetStyleTransferModelListResponse::models_size() const {
  return models_.size();
}
inline void GetStyleTransferModelListResponse::clear_models() {
  models_.Clear();
}
inline const ::AnselIpc::GetStyleTransferModelListResponse_ModelDescription& GetStyleTransferModelListResponse::models(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetStyleTransferModelListResponse.models)
  return models_.Get(index);
}
inline ::AnselIpc::GetStyleTransferModelListResponse_ModelDescription* GetStyleTransferModelListResponse::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:AnselIpc.GetStyleTransferModelListResponse.models)
  return models_.Mutable(index);
}
inline ::AnselIpc::GetStyleTransferModelListResponse_ModelDescription* GetStyleTransferModelListResponse::add_models() {
  // @@protoc_insertion_point(field_add:AnselIpc.GetStyleTransferModelListResponse.models)
  return models_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::GetStyleTransferModelListResponse_ModelDescription >&
GetStyleTransferModelListResponse::models() const {
  // @@protoc_insertion_point(field_list:AnselIpc.GetStyleTransferModelListResponse.models)
  return models_;
}
inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::GetStyleTransferModelListResponse_ModelDescription >*
GetStyleTransferModelListResponse::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.GetStyleTransferModelListResponse.models)
  return &models_;
}

// -------------------------------------------------------------------

// SetStyleTransferModelRequest

// required string modelId = 1;
inline bool SetStyleTransferModelRequest::has_modelid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetStyleTransferModelRequest::set_has_modelid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetStyleTransferModelRequest::clear_has_modelid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetStyleTransferModelRequest::clear_modelid() {
  if (modelid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelid_->clear();
  }
  clear_has_modelid();
}
inline const ::std::string& SetStyleTransferModelRequest::modelid() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetStyleTransferModelRequest.modelId)
  return *modelid_;
}
inline void SetStyleTransferModelRequest::set_modelid(const ::std::string& value) {
  set_has_modelid();
  if (modelid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelid_ = new ::std::string;
  }
  modelid_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.SetStyleTransferModelRequest.modelId)
}
inline void SetStyleTransferModelRequest::set_modelid(const char* value) {
  set_has_modelid();
  if (modelid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelid_ = new ::std::string;
  }
  modelid_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.SetStyleTransferModelRequest.modelId)
}
inline void SetStyleTransferModelRequest::set_modelid(const char* value, size_t size) {
  set_has_modelid();
  if (modelid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelid_ = new ::std::string;
  }
  modelid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.SetStyleTransferModelRequest.modelId)
}
inline ::std::string* SetStyleTransferModelRequest::mutable_modelid() {
  set_has_modelid();
  if (modelid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.SetStyleTransferModelRequest.modelId)
  return modelid_;
}
inline ::std::string* SetStyleTransferModelRequest::release_modelid() {
  clear_has_modelid();
  if (modelid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = modelid_;
    modelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetStyleTransferModelRequest::set_allocated_modelid(::std::string* modelid) {
  if (modelid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete modelid_;
  }
  if (modelid) {
    set_has_modelid();
    modelid_ = modelid;
  } else {
    clear_has_modelid();
    modelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.SetStyleTransferModelRequest.modelId)
}

// -------------------------------------------------------------------

// SetStyleTransferModelResponse

// required .AnselIpc.Status status = 1;
inline bool SetStyleTransferModelResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetStyleTransferModelResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetStyleTransferModelResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetStyleTransferModelResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status SetStyleTransferModelResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetStyleTransferModelResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void SetStyleTransferModelResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetStyleTransferModelResponse.status)
}

// -------------------------------------------------------------------

// StyleTransferStatusRequest

// required .AnselIpc.Status status = 1;
inline bool StyleTransferStatusRequest::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StyleTransferStatusRequest::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StyleTransferStatusRequest::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StyleTransferStatusRequest::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status StyleTransferStatusRequest::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.StyleTransferStatusRequest.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void StyleTransferStatusRequest::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.StyleTransferStatusRequest.status)
}

// -------------------------------------------------------------------

// StyleTransferStatusResponse

// -------------------------------------------------------------------

// StyleTransferSideloadChoiceRequest

// required uint32 packageSizeInBytes = 1;
inline bool StyleTransferSideloadChoiceRequest::has_packagesizeinbytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StyleTransferSideloadChoiceRequest::set_has_packagesizeinbytes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StyleTransferSideloadChoiceRequest::clear_has_packagesizeinbytes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StyleTransferSideloadChoiceRequest::clear_packagesizeinbytes() {
  packagesizeinbytes_ = 0u;
  clear_has_packagesizeinbytes();
}
inline ::google::protobuf::uint32 StyleTransferSideloadChoiceRequest::packagesizeinbytes() const {
  // @@protoc_insertion_point(field_get:AnselIpc.StyleTransferSideloadChoiceRequest.packageSizeInBytes)
  return packagesizeinbytes_;
}
inline void StyleTransferSideloadChoiceRequest::set_packagesizeinbytes(::google::protobuf::uint32 value) {
  set_has_packagesizeinbytes();
  packagesizeinbytes_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.StyleTransferSideloadChoiceRequest.packageSizeInBytes)
}

// -------------------------------------------------------------------

// StyleTransferSideloadChoiceResponse

// required .AnselIpc.SideloadChoice choice = 1;
inline bool StyleTransferSideloadChoiceResponse::has_choice() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StyleTransferSideloadChoiceResponse::set_has_choice() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StyleTransferSideloadChoiceResponse::clear_has_choice() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StyleTransferSideloadChoiceResponse::clear_choice() {
  choice_ = 1;
  clear_has_choice();
}
inline ::AnselIpc::SideloadChoice StyleTransferSideloadChoiceResponse::choice() const {
  // @@protoc_insertion_point(field_get:AnselIpc.StyleTransferSideloadChoiceResponse.choice)
  return static_cast< ::AnselIpc::SideloadChoice >(choice_);
}
inline void StyleTransferSideloadChoiceResponse::set_choice(::AnselIpc::SideloadChoice value) {
  assert(::AnselIpc::SideloadChoice_IsValid(value));
  set_has_choice();
  choice_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.StyleTransferSideloadChoiceResponse.choice)
}

// -------------------------------------------------------------------

// StyleTransferSideloadProgressRequest

// -------------------------------------------------------------------

// StyleTransferSideloadProgressResponse

// required .AnselIpc.SideloadProgress status = 1;
inline bool StyleTransferSideloadProgressResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StyleTransferSideloadProgressResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StyleTransferSideloadProgressResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StyleTransferSideloadProgressResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::SideloadProgress StyleTransferSideloadProgressResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.StyleTransferSideloadProgressResponse.status)
  return static_cast< ::AnselIpc::SideloadProgress >(status_);
}
inline void StyleTransferSideloadProgressResponse::set_status(::AnselIpc::SideloadProgress value) {
  assert(::AnselIpc::SideloadProgress_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.StyleTransferSideloadProgressResponse.status)
}

// optional int32 progress = 2;
inline bool StyleTransferSideloadProgressResponse::has_progress() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StyleTransferSideloadProgressResponse::set_has_progress() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StyleTransferSideloadProgressResponse::clear_has_progress() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StyleTransferSideloadProgressResponse::clear_progress() {
  progress_ = 0;
  clear_has_progress();
}
inline ::google::protobuf::int32 StyleTransferSideloadProgressResponse::progress() const {
  // @@protoc_insertion_point(field_get:AnselIpc.StyleTransferSideloadProgressResponse.progress)
  return progress_;
}
inline void StyleTransferSideloadProgressResponse::set_progress(::google::protobuf::int32 value) {
  set_has_progress();
  progress_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.StyleTransferSideloadProgressResponse.progress)
}

// -------------------------------------------------------------------

// UIReadyRequest

// required .AnselIpc.Status status = 1;
inline bool UIReadyRequest::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIReadyRequest::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIReadyRequest::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIReadyRequest::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status UIReadyRequest::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIReadyRequest.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void UIReadyRequest::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIReadyRequest.status)
}

// -------------------------------------------------------------------

// UIReadyResponse

// -------------------------------------------------------------------

// UIDescButton

// optional int32 id = 1;
inline bool UIDescButton::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIDescButton::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIDescButton::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIDescButton::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 UIDescButton::id() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescButton.id)
  return id_;
}
inline void UIDescButton::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescButton.id)
}

// optional string text = 2;
inline bool UIDescButton::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UIDescButton::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UIDescButton::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UIDescButton::clear_text() {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& UIDescButton::text() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescButton.text)
  return *text_;
}
inline void UIDescButton::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescButton.text)
}
inline void UIDescButton::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.UIDescButton.text)
}
inline void UIDescButton::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.UIDescButton.text)
}
inline ::std::string* UIDescButton::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.UIDescButton.text)
  return text_;
}
inline ::std::string* UIDescButton::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UIDescButton::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.UIDescButton.text)
}

// -------------------------------------------------------------------

// UIDescSlider

// optional int32 id = 1;
inline bool UIDescSlider::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIDescSlider::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIDescSlider::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIDescSlider::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 UIDescSlider::id() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescSlider.id)
  return id_;
}
inline void UIDescSlider::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescSlider.id)
}

// optional string text = 2;
inline bool UIDescSlider::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UIDescSlider::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UIDescSlider::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UIDescSlider::clear_text() {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& UIDescSlider::text() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescSlider.text)
  return *text_;
}
inline void UIDescSlider::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescSlider.text)
}
inline void UIDescSlider::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.UIDescSlider.text)
}
inline void UIDescSlider::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.UIDescSlider.text)
}
inline ::std::string* UIDescSlider::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.UIDescSlider.text)
  return text_;
}
inline ::std::string* UIDescSlider::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UIDescSlider::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.UIDescSlider.text)
}

// optional float milwalue = 3;
inline bool UIDescSlider::has_milwalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UIDescSlider::set_has_milwalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UIDescSlider::clear_has_milwalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UIDescSlider::clear_milwalue() {
  milwalue_ = 0;
  clear_has_milwalue();
}
inline float UIDescSlider::milwalue() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescSlider.milwalue)
  return milwalue_;
}
inline void UIDescSlider::set_milwalue(float value) {
  set_has_milwalue();
  milwalue_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescSlider.milwalue)
}

// optional float maxValue = 4;
inline bool UIDescSlider::has_maxvalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UIDescSlider::set_has_maxvalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UIDescSlider::clear_has_maxvalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UIDescSlider::clear_maxvalue() {
  maxvalue_ = 0;
  clear_has_maxvalue();
}
inline float UIDescSlider::maxvalue() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescSlider.maxValue)
  return maxvalue_;
}
inline void UIDescSlider::set_maxvalue(float value) {
  set_has_maxvalue();
  maxvalue_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescSlider.maxValue)
}

// optional float value = 5;
inline bool UIDescSlider::has_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UIDescSlider::set_has_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UIDescSlider::clear_has_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UIDescSlider::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float UIDescSlider::value() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescSlider.value)
  return value_;
}
inline void UIDescSlider::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescSlider.value)
}

// optional float interval = 6;
inline bool UIDescSlider::has_interval() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UIDescSlider::set_has_interval() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UIDescSlider::clear_has_interval() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UIDescSlider::clear_interval() {
  interval_ = 0;
  clear_has_interval();
}
inline float UIDescSlider::interval() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescSlider.interval)
  return interval_;
}
inline void UIDescSlider::set_interval(float value) {
  set_has_interval();
  interval_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescSlider.interval)
}

// -------------------------------------------------------------------

// UIDescEdit

// optional int32 id = 1;
inline bool UIDescEdit::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIDescEdit::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIDescEdit::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIDescEdit::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 UIDescEdit::id() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescEdit.id)
  return id_;
}
inline void UIDescEdit::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescEdit.id)
}

// optional string text = 2;
inline bool UIDescEdit::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UIDescEdit::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UIDescEdit::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UIDescEdit::clear_text() {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& UIDescEdit::text() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescEdit.text)
  return *text_;
}
inline void UIDescEdit::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescEdit.text)
}
inline void UIDescEdit::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.UIDescEdit.text)
}
inline void UIDescEdit::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.UIDescEdit.text)
}
inline ::std::string* UIDescEdit::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.UIDescEdit.text)
  return text_;
}
inline ::std::string* UIDescEdit::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UIDescEdit::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.UIDescEdit.text)
}

// optional .AnselIpc.EditAllowedType allowedType = 3;
inline bool UIDescEdit::has_allowedtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UIDescEdit::set_has_allowedtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UIDescEdit::clear_has_allowedtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UIDescEdit::clear_allowedtype() {
  allowedtype_ = 0;
  clear_has_allowedtype();
}
inline ::AnselIpc::EditAllowedType UIDescEdit::allowedtype() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescEdit.allowedType)
  return static_cast< ::AnselIpc::EditAllowedType >(allowedtype_);
}
inline void UIDescEdit::set_allowedtype(::AnselIpc::EditAllowedType value) {
  assert(::AnselIpc::EditAllowedType_IsValid(value));
  set_has_allowedtype();
  allowedtype_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescEdit.allowedType)
}

// optional string data = 4;
inline bool UIDescEdit::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UIDescEdit::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UIDescEdit::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UIDescEdit::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& UIDescEdit::data() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescEdit.data)
  return *data_;
}
inline void UIDescEdit::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescEdit.data)
}
inline void UIDescEdit::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.UIDescEdit.data)
}
inline void UIDescEdit::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.UIDescEdit.data)
}
inline ::std::string* UIDescEdit::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.UIDescEdit.data)
  return data_;
}
inline ::std::string* UIDescEdit::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UIDescEdit::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.UIDescEdit.data)
}

// -------------------------------------------------------------------

// UIDescBoolean

// optional int32 id = 1;
inline bool UIDescBoolean::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIDescBoolean::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIDescBoolean::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIDescBoolean::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 UIDescBoolean::id() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescBoolean.id)
  return id_;
}
inline void UIDescBoolean::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescBoolean.id)
}

// optional string text = 2;
inline bool UIDescBoolean::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UIDescBoolean::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UIDescBoolean::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UIDescBoolean::clear_text() {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& UIDescBoolean::text() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescBoolean.text)
  return *text_;
}
inline void UIDescBoolean::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescBoolean.text)
}
inline void UIDescBoolean::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.UIDescBoolean.text)
}
inline void UIDescBoolean::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.UIDescBoolean.text)
}
inline ::std::string* UIDescBoolean::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.UIDescBoolean.text)
  return text_;
}
inline ::std::string* UIDescBoolean::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UIDescBoolean::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.UIDescBoolean.text)
}

// optional bool set = 3;
inline bool UIDescBoolean::has_set() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UIDescBoolean::set_has_set() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UIDescBoolean::clear_has_set() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UIDescBoolean::clear_set() {
  set_ = false;
  clear_has_set();
}
inline bool UIDescBoolean::set() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescBoolean.set)
  return set_;
}
inline void UIDescBoolean::set_set(bool value) {
  set_has_set();
  set_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescBoolean.set)
}

// -------------------------------------------------------------------

// UIDescLabel

// optional int32 id = 1;
inline bool UIDescLabel::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIDescLabel::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIDescLabel::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIDescLabel::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 UIDescLabel::id() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescLabel.id)
  return id_;
}
inline void UIDescLabel::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescLabel.id)
}

// optional string text = 2;
inline bool UIDescLabel::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UIDescLabel::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UIDescLabel::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UIDescLabel::clear_text() {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& UIDescLabel::text() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescLabel.text)
  return *text_;
}
inline void UIDescLabel::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescLabel.text)
}
inline void UIDescLabel::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.UIDescLabel.text)
}
inline void UIDescLabel::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.UIDescLabel.text)
}
inline ::std::string* UIDescLabel::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.UIDescLabel.text)
  return text_;
}
inline ::std::string* UIDescLabel::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UIDescLabel::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.UIDescLabel.text)
}

// -------------------------------------------------------------------

// MapFieldEntry

// required int32 key = 1;
inline bool MapFieldEntry::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapFieldEntry::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapFieldEntry::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapFieldEntry::clear_key() {
  key_ = 0;
  clear_has_key();
}
inline ::google::protobuf::int32 MapFieldEntry::key() const {
  // @@protoc_insertion_point(field_get:AnselIpc.MapFieldEntry.key)
  return key_;
}
inline void MapFieldEntry::set_key(::google::protobuf::int32 value) {
  set_has_key();
  key_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.MapFieldEntry.key)
}

// required string value = 2;
inline bool MapFieldEntry::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapFieldEntry::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapFieldEntry::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapFieldEntry::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& MapFieldEntry::value() const {
  // @@protoc_insertion_point(field_get:AnselIpc.MapFieldEntry.value)
  return *value_;
}
inline void MapFieldEntry::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.MapFieldEntry.value)
}
inline void MapFieldEntry::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.MapFieldEntry.value)
}
inline void MapFieldEntry::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.MapFieldEntry.value)
}
inline ::std::string* MapFieldEntry::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.MapFieldEntry.value)
  return value_;
}
inline ::std::string* MapFieldEntry::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MapFieldEntry::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.MapFieldEntry.value)
}

// -------------------------------------------------------------------

// UIDescList

// optional int32 id = 1;
inline bool UIDescList::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIDescList::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIDescList::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIDescList::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 UIDescList::id() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescList.id)
  return id_;
}
inline void UIDescList::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescList.id)
}

// optional string text = 2;
inline bool UIDescList::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UIDescList::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UIDescList::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UIDescList::clear_text() {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& UIDescList::text() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescList.text)
  return *text_;
}
inline void UIDescList::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescList.text)
}
inline void UIDescList::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.UIDescList.text)
}
inline void UIDescList::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.UIDescList.text)
}
inline ::std::string* UIDescList::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.UIDescList.text)
  return text_;
}
inline ::std::string* UIDescList::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UIDescList::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.UIDescList.text)
}

// repeated .AnselIpc.MapFieldEntry values = 3;
inline int UIDescList::values_size() const {
  return values_.size();
}
inline void UIDescList::clear_values() {
  values_.Clear();
}
inline const ::AnselIpc::MapFieldEntry& UIDescList::values(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescList.values)
  return values_.Get(index);
}
inline ::AnselIpc::MapFieldEntry* UIDescList::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:AnselIpc.UIDescList.values)
  return values_.Mutable(index);
}
inline ::AnselIpc::MapFieldEntry* UIDescList::add_values() {
  // @@protoc_insertion_point(field_add:AnselIpc.UIDescList.values)
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::MapFieldEntry >&
UIDescList::values() const {
  // @@protoc_insertion_point(field_list:AnselIpc.UIDescList.values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::MapFieldEntry >*
UIDescList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.UIDescList.values)
  return &values_;
}

// optional int32 selected = 4;
inline bool UIDescList::has_selected() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UIDescList::set_has_selected() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UIDescList::clear_has_selected() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UIDescList::clear_selected() {
  selected_ = 0;
  clear_has_selected();
}
inline ::google::protobuf::int32 UIDescList::selected() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescList.selected)
  return selected_;
}
inline void UIDescList::set_selected(::google::protobuf::int32 value) {
  set_has_selected();
  selected_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescList.selected)
}

// optional .AnselIpc.ListSelectionType type = 5;
inline bool UIDescList::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UIDescList::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UIDescList::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UIDescList::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::AnselIpc::ListSelectionType UIDescList::type() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescList.type)
  return static_cast< ::AnselIpc::ListSelectionType >(type_);
}
inline void UIDescList::set_type(::AnselIpc::ListSelectionType value) {
  assert(::AnselIpc::ListSelectionType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescList.type)
}

// -------------------------------------------------------------------

// UIDescPulldown

// optional int32 id = 1;
inline bool UIDescPulldown::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIDescPulldown::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIDescPulldown::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIDescPulldown::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 UIDescPulldown::id() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescPulldown.id)
  return id_;
}
inline void UIDescPulldown::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescPulldown.id)
}

// optional string text = 2;
inline bool UIDescPulldown::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UIDescPulldown::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UIDescPulldown::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UIDescPulldown::clear_text() {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& UIDescPulldown::text() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescPulldown.text)
  return *text_;
}
inline void UIDescPulldown::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescPulldown.text)
}
inline void UIDescPulldown::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.UIDescPulldown.text)
}
inline void UIDescPulldown::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.UIDescPulldown.text)
}
inline ::std::string* UIDescPulldown::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.UIDescPulldown.text)
  return text_;
}
inline ::std::string* UIDescPulldown::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UIDescPulldown::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.UIDescPulldown.text)
}

// repeated int32 controlIdList = 3;
inline int UIDescPulldown::controlidlist_size() const {
  return controlidlist_.size();
}
inline void UIDescPulldown::clear_controlidlist() {
  controlidlist_.Clear();
}
inline ::google::protobuf::int32 UIDescPulldown::controlidlist(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIDescPulldown.controlIdList)
  return controlidlist_.Get(index);
}
inline void UIDescPulldown::set_controlidlist(int index, ::google::protobuf::int32 value) {
  controlidlist_.Set(index, value);
  // @@protoc_insertion_point(field_set:AnselIpc.UIDescPulldown.controlIdList)
}
inline void UIDescPulldown::add_controlidlist(::google::protobuf::int32 value) {
  controlidlist_.Add(value);
  // @@protoc_insertion_point(field_add:AnselIpc.UIDescPulldown.controlIdList)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
UIDescPulldown::controlidlist() const {
  // @@protoc_insertion_point(field_list:AnselIpc.UIDescPulldown.controlIdList)
  return controlidlist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
UIDescPulldown::mutable_controlidlist() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.UIDescPulldown.controlIdList)
  return &controlidlist_;
}

// -------------------------------------------------------------------

// AddUIElementRequest

// required int32 requestId = 1;
inline bool AddUIElementRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddUIElementRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddUIElementRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddUIElementRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 AddUIElementRequest::requestid() const {
  // @@protoc_insertion_point(field_get:AnselIpc.AddUIElementRequest.requestId)
  return requestid_;
}
inline void AddUIElementRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.AddUIElementRequest.requestId)
}

// required .AnselIpc.ControlType controlType = 2;
inline bool AddUIElementRequest::has_controltype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddUIElementRequest::set_has_controltype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddUIElementRequest::clear_has_controltype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddUIElementRequest::clear_controltype() {
  controltype_ = 1;
  clear_has_controltype();
}
inline ::AnselIpc::ControlType AddUIElementRequest::controltype() const {
  // @@protoc_insertion_point(field_get:AnselIpc.AddUIElementRequest.controlType)
  return static_cast< ::AnselIpc::ControlType >(controltype_);
}
inline void AddUIElementRequest::set_controltype(::AnselIpc::ControlType value) {
  assert(::AnselIpc::ControlType_IsValid(value));
  set_has_controltype();
  controltype_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.AddUIElementRequest.controlType)
}

// optional bool visible = 3;
inline bool AddUIElementRequest::has_visible() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddUIElementRequest::set_has_visible() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddUIElementRequest::clear_has_visible() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddUIElementRequest::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool AddUIElementRequest::visible() const {
  // @@protoc_insertion_point(field_get:AnselIpc.AddUIElementRequest.visible)
  return visible_;
}
inline void AddUIElementRequest::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.AddUIElementRequest.visible)
}

// optional .AnselIpc.UIDescButton uiDescButton = 4;
inline bool AddUIElementRequest::has_uidescbutton() const {
  return controlDescription_case() == kUiDescButton;
}
inline void AddUIElementRequest::set_has_uidescbutton() {
  _oneof_case_[0] = kUiDescButton;
}
inline void AddUIElementRequest::clear_uidescbutton() {
  if (has_uidescbutton()) {
    delete controlDescription_.uidescbutton_;
    clear_has_controlDescription();
  }
}
inline const ::AnselIpc::UIDescButton& AddUIElementRequest::uidescbutton() const {
  return has_uidescbutton() ? *controlDescription_.uidescbutton_
                      : ::AnselIpc::UIDescButton::default_instance();
}
inline ::AnselIpc::UIDescButton* AddUIElementRequest::mutable_uidescbutton() {
  if (!has_uidescbutton()) {
    clear_controlDescription();
    set_has_uidescbutton();
    controlDescription_.uidescbutton_ = new ::AnselIpc::UIDescButton;
  }
  return controlDescription_.uidescbutton_;
}
inline ::AnselIpc::UIDescButton* AddUIElementRequest::release_uidescbutton() {
  if (has_uidescbutton()) {
    clear_has_controlDescription();
    ::AnselIpc::UIDescButton* temp = controlDescription_.uidescbutton_;
    controlDescription_.uidescbutton_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AddUIElementRequest::set_allocated_uidescbutton(::AnselIpc::UIDescButton* uidescbutton) {
  clear_controlDescription();
  if (uidescbutton) {
    set_has_uidescbutton();
    controlDescription_.uidescbutton_ = uidescbutton;
  }
}

// optional .AnselIpc.UIDescSlider uiDescSlider = 5;
inline bool AddUIElementRequest::has_uidescslider() const {
  return controlDescription_case() == kUiDescSlider;
}
inline void AddUIElementRequest::set_has_uidescslider() {
  _oneof_case_[0] = kUiDescSlider;
}
inline void AddUIElementRequest::clear_uidescslider() {
  if (has_uidescslider()) {
    delete controlDescription_.uidescslider_;
    clear_has_controlDescription();
  }
}
inline const ::AnselIpc::UIDescSlider& AddUIElementRequest::uidescslider() const {
  return has_uidescslider() ? *controlDescription_.uidescslider_
                      : ::AnselIpc::UIDescSlider::default_instance();
}
inline ::AnselIpc::UIDescSlider* AddUIElementRequest::mutable_uidescslider() {
  if (!has_uidescslider()) {
    clear_controlDescription();
    set_has_uidescslider();
    controlDescription_.uidescslider_ = new ::AnselIpc::UIDescSlider;
  }
  return controlDescription_.uidescslider_;
}
inline ::AnselIpc::UIDescSlider* AddUIElementRequest::release_uidescslider() {
  if (has_uidescslider()) {
    clear_has_controlDescription();
    ::AnselIpc::UIDescSlider* temp = controlDescription_.uidescslider_;
    controlDescription_.uidescslider_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AddUIElementRequest::set_allocated_uidescslider(::AnselIpc::UIDescSlider* uidescslider) {
  clear_controlDescription();
  if (uidescslider) {
    set_has_uidescslider();
    controlDescription_.uidescslider_ = uidescslider;
  }
}

// optional .AnselIpc.UIDescEdit uiDescEdit = 6;
inline bool AddUIElementRequest::has_uidescedit() const {
  return controlDescription_case() == kUiDescEdit;
}
inline void AddUIElementRequest::set_has_uidescedit() {
  _oneof_case_[0] = kUiDescEdit;
}
inline void AddUIElementRequest::clear_uidescedit() {
  if (has_uidescedit()) {
    delete controlDescription_.uidescedit_;
    clear_has_controlDescription();
  }
}
inline const ::AnselIpc::UIDescEdit& AddUIElementRequest::uidescedit() const {
  return has_uidescedit() ? *controlDescription_.uidescedit_
                      : ::AnselIpc::UIDescEdit::default_instance();
}
inline ::AnselIpc::UIDescEdit* AddUIElementRequest::mutable_uidescedit() {
  if (!has_uidescedit()) {
    clear_controlDescription();
    set_has_uidescedit();
    controlDescription_.uidescedit_ = new ::AnselIpc::UIDescEdit;
  }
  return controlDescription_.uidescedit_;
}
inline ::AnselIpc::UIDescEdit* AddUIElementRequest::release_uidescedit() {
  if (has_uidescedit()) {
    clear_has_controlDescription();
    ::AnselIpc::UIDescEdit* temp = controlDescription_.uidescedit_;
    controlDescription_.uidescedit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AddUIElementRequest::set_allocated_uidescedit(::AnselIpc::UIDescEdit* uidescedit) {
  clear_controlDescription();
  if (uidescedit) {
    set_has_uidescedit();
    controlDescription_.uidescedit_ = uidescedit;
  }
}

// optional .AnselIpc.UIDescBoolean uiDescBoolean = 7;
inline bool AddUIElementRequest::has_uidescboolean() const {
  return controlDescription_case() == kUiDescBoolean;
}
inline void AddUIElementRequest::set_has_uidescboolean() {
  _oneof_case_[0] = kUiDescBoolean;
}
inline void AddUIElementRequest::clear_uidescboolean() {
  if (has_uidescboolean()) {
    delete controlDescription_.uidescboolean_;
    clear_has_controlDescription();
  }
}
inline const ::AnselIpc::UIDescBoolean& AddUIElementRequest::uidescboolean() const {
  return has_uidescboolean() ? *controlDescription_.uidescboolean_
                      : ::AnselIpc::UIDescBoolean::default_instance();
}
inline ::AnselIpc::UIDescBoolean* AddUIElementRequest::mutable_uidescboolean() {
  if (!has_uidescboolean()) {
    clear_controlDescription();
    set_has_uidescboolean();
    controlDescription_.uidescboolean_ = new ::AnselIpc::UIDescBoolean;
  }
  return controlDescription_.uidescboolean_;
}
inline ::AnselIpc::UIDescBoolean* AddUIElementRequest::release_uidescboolean() {
  if (has_uidescboolean()) {
    clear_has_controlDescription();
    ::AnselIpc::UIDescBoolean* temp = controlDescription_.uidescboolean_;
    controlDescription_.uidescboolean_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AddUIElementRequest::set_allocated_uidescboolean(::AnselIpc::UIDescBoolean* uidescboolean) {
  clear_controlDescription();
  if (uidescboolean) {
    set_has_uidescboolean();
    controlDescription_.uidescboolean_ = uidescboolean;
  }
}

// optional .AnselIpc.UIDescLabel uiDescLabel = 8;
inline bool AddUIElementRequest::has_uidesclabel() const {
  return controlDescription_case() == kUiDescLabel;
}
inline void AddUIElementRequest::set_has_uidesclabel() {
  _oneof_case_[0] = kUiDescLabel;
}
inline void AddUIElementRequest::clear_uidesclabel() {
  if (has_uidesclabel()) {
    delete controlDescription_.uidesclabel_;
    clear_has_controlDescription();
  }
}
inline const ::AnselIpc::UIDescLabel& AddUIElementRequest::uidesclabel() const {
  return has_uidesclabel() ? *controlDescription_.uidesclabel_
                      : ::AnselIpc::UIDescLabel::default_instance();
}
inline ::AnselIpc::UIDescLabel* AddUIElementRequest::mutable_uidesclabel() {
  if (!has_uidesclabel()) {
    clear_controlDescription();
    set_has_uidesclabel();
    controlDescription_.uidesclabel_ = new ::AnselIpc::UIDescLabel;
  }
  return controlDescription_.uidesclabel_;
}
inline ::AnselIpc::UIDescLabel* AddUIElementRequest::release_uidesclabel() {
  if (has_uidesclabel()) {
    clear_has_controlDescription();
    ::AnselIpc::UIDescLabel* temp = controlDescription_.uidesclabel_;
    controlDescription_.uidesclabel_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AddUIElementRequest::set_allocated_uidesclabel(::AnselIpc::UIDescLabel* uidesclabel) {
  clear_controlDescription();
  if (uidesclabel) {
    set_has_uidesclabel();
    controlDescription_.uidesclabel_ = uidesclabel;
  }
}

// optional .AnselIpc.UIDescList uiDescList = 9;
inline bool AddUIElementRequest::has_uidesclist() const {
  return controlDescription_case() == kUiDescList;
}
inline void AddUIElementRequest::set_has_uidesclist() {
  _oneof_case_[0] = kUiDescList;
}
inline void AddUIElementRequest::clear_uidesclist() {
  if (has_uidesclist()) {
    delete controlDescription_.uidesclist_;
    clear_has_controlDescription();
  }
}
inline const ::AnselIpc::UIDescList& AddUIElementRequest::uidesclist() const {
  return has_uidesclist() ? *controlDescription_.uidesclist_
                      : ::AnselIpc::UIDescList::default_instance();
}
inline ::AnselIpc::UIDescList* AddUIElementRequest::mutable_uidesclist() {
  if (!has_uidesclist()) {
    clear_controlDescription();
    set_has_uidesclist();
    controlDescription_.uidesclist_ = new ::AnselIpc::UIDescList;
  }
  return controlDescription_.uidesclist_;
}
inline ::AnselIpc::UIDescList* AddUIElementRequest::release_uidesclist() {
  if (has_uidesclist()) {
    clear_has_controlDescription();
    ::AnselIpc::UIDescList* temp = controlDescription_.uidesclist_;
    controlDescription_.uidesclist_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AddUIElementRequest::set_allocated_uidesclist(::AnselIpc::UIDescList* uidesclist) {
  clear_controlDescription();
  if (uidesclist) {
    set_has_uidesclist();
    controlDescription_.uidesclist_ = uidesclist;
  }
}

// optional .AnselIpc.UIDescPulldown uiDescPulldown = 10;
inline bool AddUIElementRequest::has_uidescpulldown() const {
  return controlDescription_case() == kUiDescPulldown;
}
inline void AddUIElementRequest::set_has_uidescpulldown() {
  _oneof_case_[0] = kUiDescPulldown;
}
inline void AddUIElementRequest::clear_uidescpulldown() {
  if (has_uidescpulldown()) {
    delete controlDescription_.uidescpulldown_;
    clear_has_controlDescription();
  }
}
inline const ::AnselIpc::UIDescPulldown& AddUIElementRequest::uidescpulldown() const {
  return has_uidescpulldown() ? *controlDescription_.uidescpulldown_
                      : ::AnselIpc::UIDescPulldown::default_instance();
}
inline ::AnselIpc::UIDescPulldown* AddUIElementRequest::mutable_uidescpulldown() {
  if (!has_uidescpulldown()) {
    clear_controlDescription();
    set_has_uidescpulldown();
    controlDescription_.uidescpulldown_ = new ::AnselIpc::UIDescPulldown;
  }
  return controlDescription_.uidescpulldown_;
}
inline ::AnselIpc::UIDescPulldown* AddUIElementRequest::release_uidescpulldown() {
  if (has_uidescpulldown()) {
    clear_has_controlDescription();
    ::AnselIpc::UIDescPulldown* temp = controlDescription_.uidescpulldown_;
    controlDescription_.uidescpulldown_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AddUIElementRequest::set_allocated_uidescpulldown(::AnselIpc::UIDescPulldown* uidescpulldown) {
  clear_controlDescription();
  if (uidescpulldown) {
    set_has_uidescpulldown();
    controlDescription_.uidescpulldown_ = uidescpulldown;
  }
}

inline bool AddUIElementRequest::has_controlDescription() {
  return controlDescription_case() != CONTROLDESCRIPTION_NOT_SET;
}
inline void AddUIElementRequest::clear_has_controlDescription() {
  _oneof_case_[0] = CONTROLDESCRIPTION_NOT_SET;
}
inline AddUIElementRequest::ControlDescriptionCase AddUIElementRequest::controlDescription_case() const {
  return AddUIElementRequest::ControlDescriptionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AddUIElementResponse

// required int32 requestId = 1;
inline bool AddUIElementResponse::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddUIElementResponse::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddUIElementResponse::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddUIElementResponse::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 AddUIElementResponse::requestid() const {
  // @@protoc_insertion_point(field_get:AnselIpc.AddUIElementResponse.requestId)
  return requestid_;
}
inline void AddUIElementResponse::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.AddUIElementResponse.requestId)
}

// required .AnselIpc.Status status = 2;
inline bool AddUIElementResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddUIElementResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddUIElementResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddUIElementResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status AddUIElementResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.AddUIElementResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void AddUIElementResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.AddUIElementResponse.status)
}

// optional .AnselIpc.UIDescButton uiDescButton = 3;
inline bool AddUIElementResponse::has_uidescbutton() const {
  return controlDescription_case() == kUiDescButton;
}
inline void AddUIElementResponse::set_has_uidescbutton() {
  _oneof_case_[0] = kUiDescButton;
}
inline void AddUIElementResponse::clear_uidescbutton() {
  if (has_uidescbutton()) {
    delete controlDescription_.uidescbutton_;
    clear_has_controlDescription();
  }
}
inline const ::AnselIpc::UIDescButton& AddUIElementResponse::uidescbutton() const {
  return has_uidescbutton() ? *controlDescription_.uidescbutton_
                      : ::AnselIpc::UIDescButton::default_instance();
}
inline ::AnselIpc::UIDescButton* AddUIElementResponse::mutable_uidescbutton() {
  if (!has_uidescbutton()) {
    clear_controlDescription();
    set_has_uidescbutton();
    controlDescription_.uidescbutton_ = new ::AnselIpc::UIDescButton;
  }
  return controlDescription_.uidescbutton_;
}
inline ::AnselIpc::UIDescButton* AddUIElementResponse::release_uidescbutton() {
  if (has_uidescbutton()) {
    clear_has_controlDescription();
    ::AnselIpc::UIDescButton* temp = controlDescription_.uidescbutton_;
    controlDescription_.uidescbutton_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AddUIElementResponse::set_allocated_uidescbutton(::AnselIpc::UIDescButton* uidescbutton) {
  clear_controlDescription();
  if (uidescbutton) {
    set_has_uidescbutton();
    controlDescription_.uidescbutton_ = uidescbutton;
  }
}

// optional .AnselIpc.UIDescSlider uiDescSlider = 4;
inline bool AddUIElementResponse::has_uidescslider() const {
  return controlDescription_case() == kUiDescSlider;
}
inline void AddUIElementResponse::set_has_uidescslider() {
  _oneof_case_[0] = kUiDescSlider;
}
inline void AddUIElementResponse::clear_uidescslider() {
  if (has_uidescslider()) {
    delete controlDescription_.uidescslider_;
    clear_has_controlDescription();
  }
}
inline const ::AnselIpc::UIDescSlider& AddUIElementResponse::uidescslider() const {
  return has_uidescslider() ? *controlDescription_.uidescslider_
                      : ::AnselIpc::UIDescSlider::default_instance();
}
inline ::AnselIpc::UIDescSlider* AddUIElementResponse::mutable_uidescslider() {
  if (!has_uidescslider()) {
    clear_controlDescription();
    set_has_uidescslider();
    controlDescription_.uidescslider_ = new ::AnselIpc::UIDescSlider;
  }
  return controlDescription_.uidescslider_;
}
inline ::AnselIpc::UIDescSlider* AddUIElementResponse::release_uidescslider() {
  if (has_uidescslider()) {
    clear_has_controlDescription();
    ::AnselIpc::UIDescSlider* temp = controlDescription_.uidescslider_;
    controlDescription_.uidescslider_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AddUIElementResponse::set_allocated_uidescslider(::AnselIpc::UIDescSlider* uidescslider) {
  clear_controlDescription();
  if (uidescslider) {
    set_has_uidescslider();
    controlDescription_.uidescslider_ = uidescslider;
  }
}

// optional .AnselIpc.UIDescEdit uiDescEdit = 5;
inline bool AddUIElementResponse::has_uidescedit() const {
  return controlDescription_case() == kUiDescEdit;
}
inline void AddUIElementResponse::set_has_uidescedit() {
  _oneof_case_[0] = kUiDescEdit;
}
inline void AddUIElementResponse::clear_uidescedit() {
  if (has_uidescedit()) {
    delete controlDescription_.uidescedit_;
    clear_has_controlDescription();
  }
}
inline const ::AnselIpc::UIDescEdit& AddUIElementResponse::uidescedit() const {
  return has_uidescedit() ? *controlDescription_.uidescedit_
                      : ::AnselIpc::UIDescEdit::default_instance();
}
inline ::AnselIpc::UIDescEdit* AddUIElementResponse::mutable_uidescedit() {
  if (!has_uidescedit()) {
    clear_controlDescription();
    set_has_uidescedit();
    controlDescription_.uidescedit_ = new ::AnselIpc::UIDescEdit;
  }
  return controlDescription_.uidescedit_;
}
inline ::AnselIpc::UIDescEdit* AddUIElementResponse::release_uidescedit() {
  if (has_uidescedit()) {
    clear_has_controlDescription();
    ::AnselIpc::UIDescEdit* temp = controlDescription_.uidescedit_;
    controlDescription_.uidescedit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AddUIElementResponse::set_allocated_uidescedit(::AnselIpc::UIDescEdit* uidescedit) {
  clear_controlDescription();
  if (uidescedit) {
    set_has_uidescedit();
    controlDescription_.uidescedit_ = uidescedit;
  }
}

// optional .AnselIpc.UIDescBoolean uiDescBoolean = 6;
inline bool AddUIElementResponse::has_uidescboolean() const {
  return controlDescription_case() == kUiDescBoolean;
}
inline void AddUIElementResponse::set_has_uidescboolean() {
  _oneof_case_[0] = kUiDescBoolean;
}
inline void AddUIElementResponse::clear_uidescboolean() {
  if (has_uidescboolean()) {
    delete controlDescription_.uidescboolean_;
    clear_has_controlDescription();
  }
}
inline const ::AnselIpc::UIDescBoolean& AddUIElementResponse::uidescboolean() const {
  return has_uidescboolean() ? *controlDescription_.uidescboolean_
                      : ::AnselIpc::UIDescBoolean::default_instance();
}
inline ::AnselIpc::UIDescBoolean* AddUIElementResponse::mutable_uidescboolean() {
  if (!has_uidescboolean()) {
    clear_controlDescription();
    set_has_uidescboolean();
    controlDescription_.uidescboolean_ = new ::AnselIpc::UIDescBoolean;
  }
  return controlDescription_.uidescboolean_;
}
inline ::AnselIpc::UIDescBoolean* AddUIElementResponse::release_uidescboolean() {
  if (has_uidescboolean()) {
    clear_has_controlDescription();
    ::AnselIpc::UIDescBoolean* temp = controlDescription_.uidescboolean_;
    controlDescription_.uidescboolean_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AddUIElementResponse::set_allocated_uidescboolean(::AnselIpc::UIDescBoolean* uidescboolean) {
  clear_controlDescription();
  if (uidescboolean) {
    set_has_uidescboolean();
    controlDescription_.uidescboolean_ = uidescboolean;
  }
}

// optional .AnselIpc.UIDescLabel uiDescLabel = 7;
inline bool AddUIElementResponse::has_uidesclabel() const {
  return controlDescription_case() == kUiDescLabel;
}
inline void AddUIElementResponse::set_has_uidesclabel() {
  _oneof_case_[0] = kUiDescLabel;
}
inline void AddUIElementResponse::clear_uidesclabel() {
  if (has_uidesclabel()) {
    delete controlDescription_.uidesclabel_;
    clear_has_controlDescription();
  }
}
inline const ::AnselIpc::UIDescLabel& AddUIElementResponse::uidesclabel() const {
  return has_uidesclabel() ? *controlDescription_.uidesclabel_
                      : ::AnselIpc::UIDescLabel::default_instance();
}
inline ::AnselIpc::UIDescLabel* AddUIElementResponse::mutable_uidesclabel() {
  if (!has_uidesclabel()) {
    clear_controlDescription();
    set_has_uidesclabel();
    controlDescription_.uidesclabel_ = new ::AnselIpc::UIDescLabel;
  }
  return controlDescription_.uidesclabel_;
}
inline ::AnselIpc::UIDescLabel* AddUIElementResponse::release_uidesclabel() {
  if (has_uidesclabel()) {
    clear_has_controlDescription();
    ::AnselIpc::UIDescLabel* temp = controlDescription_.uidesclabel_;
    controlDescription_.uidesclabel_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AddUIElementResponse::set_allocated_uidesclabel(::AnselIpc::UIDescLabel* uidesclabel) {
  clear_controlDescription();
  if (uidesclabel) {
    set_has_uidesclabel();
    controlDescription_.uidesclabel_ = uidesclabel;
  }
}

// optional .AnselIpc.UIDescList uiDescList = 8;
inline bool AddUIElementResponse::has_uidesclist() const {
  return controlDescription_case() == kUiDescList;
}
inline void AddUIElementResponse::set_has_uidesclist() {
  _oneof_case_[0] = kUiDescList;
}
inline void AddUIElementResponse::clear_uidesclist() {
  if (has_uidesclist()) {
    delete controlDescription_.uidesclist_;
    clear_has_controlDescription();
  }
}
inline const ::AnselIpc::UIDescList& AddUIElementResponse::uidesclist() const {
  return has_uidesclist() ? *controlDescription_.uidesclist_
                      : ::AnselIpc::UIDescList::default_instance();
}
inline ::AnselIpc::UIDescList* AddUIElementResponse::mutable_uidesclist() {
  if (!has_uidesclist()) {
    clear_controlDescription();
    set_has_uidesclist();
    controlDescription_.uidesclist_ = new ::AnselIpc::UIDescList;
  }
  return controlDescription_.uidesclist_;
}
inline ::AnselIpc::UIDescList* AddUIElementResponse::release_uidesclist() {
  if (has_uidesclist()) {
    clear_has_controlDescription();
    ::AnselIpc::UIDescList* temp = controlDescription_.uidesclist_;
    controlDescription_.uidesclist_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AddUIElementResponse::set_allocated_uidesclist(::AnselIpc::UIDescList* uidesclist) {
  clear_controlDescription();
  if (uidesclist) {
    set_has_uidesclist();
    controlDescription_.uidesclist_ = uidesclist;
  }
}

// optional .AnselIpc.UIDescPulldown uiDescPulldown = 9;
inline bool AddUIElementResponse::has_uidescpulldown() const {
  return controlDescription_case() == kUiDescPulldown;
}
inline void AddUIElementResponse::set_has_uidescpulldown() {
  _oneof_case_[0] = kUiDescPulldown;
}
inline void AddUIElementResponse::clear_uidescpulldown() {
  if (has_uidescpulldown()) {
    delete controlDescription_.uidescpulldown_;
    clear_has_controlDescription();
  }
}
inline const ::AnselIpc::UIDescPulldown& AddUIElementResponse::uidescpulldown() const {
  return has_uidescpulldown() ? *controlDescription_.uidescpulldown_
                      : ::AnselIpc::UIDescPulldown::default_instance();
}
inline ::AnselIpc::UIDescPulldown* AddUIElementResponse::mutable_uidescpulldown() {
  if (!has_uidescpulldown()) {
    clear_controlDescription();
    set_has_uidescpulldown();
    controlDescription_.uidescpulldown_ = new ::AnselIpc::UIDescPulldown;
  }
  return controlDescription_.uidescpulldown_;
}
inline ::AnselIpc::UIDescPulldown* AddUIElementResponse::release_uidescpulldown() {
  if (has_uidescpulldown()) {
    clear_has_controlDescription();
    ::AnselIpc::UIDescPulldown* temp = controlDescription_.uidescpulldown_;
    controlDescription_.uidescpulldown_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AddUIElementResponse::set_allocated_uidescpulldown(::AnselIpc::UIDescPulldown* uidescpulldown) {
  clear_controlDescription();
  if (uidescpulldown) {
    set_has_uidescpulldown();
    controlDescription_.uidescpulldown_ = uidescpulldown;
  }
}

inline bool AddUIElementResponse::has_controlDescription() {
  return controlDescription_case() != CONTROLDESCRIPTION_NOT_SET;
}
inline void AddUIElementResponse::clear_has_controlDescription() {
  _oneof_case_[0] = CONTROLDESCRIPTION_NOT_SET;
}
inline AddUIElementResponse::ControlDescriptionCase AddUIElementResponse::controlDescription_case() const {
  return AddUIElementResponse::ControlDescriptionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UIControlChangedRequest

// optional .AnselIpc.UIDescButton uiDescButton = 3;
inline bool UIControlChangedRequest::has_uidescbutton() const {
  return controlDescription_case() == kUiDescButton;
}
inline void UIControlChangedRequest::set_has_uidescbutton() {
  _oneof_case_[0] = kUiDescButton;
}
inline void UIControlChangedRequest::clear_uidescbutton() {
  if (has_uidescbutton()) {
    delete controlDescription_.uidescbutton_;
    clear_has_controlDescription();
  }
}
inline const ::AnselIpc::UIDescButton& UIControlChangedRequest::uidescbutton() const {
  return has_uidescbutton() ? *controlDescription_.uidescbutton_
                      : ::AnselIpc::UIDescButton::default_instance();
}
inline ::AnselIpc::UIDescButton* UIControlChangedRequest::mutable_uidescbutton() {
  if (!has_uidescbutton()) {
    clear_controlDescription();
    set_has_uidescbutton();
    controlDescription_.uidescbutton_ = new ::AnselIpc::UIDescButton;
  }
  return controlDescription_.uidescbutton_;
}
inline ::AnselIpc::UIDescButton* UIControlChangedRequest::release_uidescbutton() {
  if (has_uidescbutton()) {
    clear_has_controlDescription();
    ::AnselIpc::UIDescButton* temp = controlDescription_.uidescbutton_;
    controlDescription_.uidescbutton_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void UIControlChangedRequest::set_allocated_uidescbutton(::AnselIpc::UIDescButton* uidescbutton) {
  clear_controlDescription();
  if (uidescbutton) {
    set_has_uidescbutton();
    controlDescription_.uidescbutton_ = uidescbutton;
  }
}

// optional .AnselIpc.UIDescSlider uiDescSlider = 4;
inline bool UIControlChangedRequest::has_uidescslider() const {
  return controlDescription_case() == kUiDescSlider;
}
inline void UIControlChangedRequest::set_has_uidescslider() {
  _oneof_case_[0] = kUiDescSlider;
}
inline void UIControlChangedRequest::clear_uidescslider() {
  if (has_uidescslider()) {
    delete controlDescription_.uidescslider_;
    clear_has_controlDescription();
  }
}
inline const ::AnselIpc::UIDescSlider& UIControlChangedRequest::uidescslider() const {
  return has_uidescslider() ? *controlDescription_.uidescslider_
                      : ::AnselIpc::UIDescSlider::default_instance();
}
inline ::AnselIpc::UIDescSlider* UIControlChangedRequest::mutable_uidescslider() {
  if (!has_uidescslider()) {
    clear_controlDescription();
    set_has_uidescslider();
    controlDescription_.uidescslider_ = new ::AnselIpc::UIDescSlider;
  }
  return controlDescription_.uidescslider_;
}
inline ::AnselIpc::UIDescSlider* UIControlChangedRequest::release_uidescslider() {
  if (has_uidescslider()) {
    clear_has_controlDescription();
    ::AnselIpc::UIDescSlider* temp = controlDescription_.uidescslider_;
    controlDescription_.uidescslider_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void UIControlChangedRequest::set_allocated_uidescslider(::AnselIpc::UIDescSlider* uidescslider) {
  clear_controlDescription();
  if (uidescslider) {
    set_has_uidescslider();
    controlDescription_.uidescslider_ = uidescslider;
  }
}

// optional .AnselIpc.UIDescEdit uiDescEdit = 5;
inline bool UIControlChangedRequest::has_uidescedit() const {
  return controlDescription_case() == kUiDescEdit;
}
inline void UIControlChangedRequest::set_has_uidescedit() {
  _oneof_case_[0] = kUiDescEdit;
}
inline void UIControlChangedRequest::clear_uidescedit() {
  if (has_uidescedit()) {
    delete controlDescription_.uidescedit_;
    clear_has_controlDescription();
  }
}
inline const ::AnselIpc::UIDescEdit& UIControlChangedRequest::uidescedit() const {
  return has_uidescedit() ? *controlDescription_.uidescedit_
                      : ::AnselIpc::UIDescEdit::default_instance();
}
inline ::AnselIpc::UIDescEdit* UIControlChangedRequest::mutable_uidescedit() {
  if (!has_uidescedit()) {
    clear_controlDescription();
    set_has_uidescedit();
    controlDescription_.uidescedit_ = new ::AnselIpc::UIDescEdit;
  }
  return controlDescription_.uidescedit_;
}
inline ::AnselIpc::UIDescEdit* UIControlChangedRequest::release_uidescedit() {
  if (has_uidescedit()) {
    clear_has_controlDescription();
    ::AnselIpc::UIDescEdit* temp = controlDescription_.uidescedit_;
    controlDescription_.uidescedit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void UIControlChangedRequest::set_allocated_uidescedit(::AnselIpc::UIDescEdit* uidescedit) {
  clear_controlDescription();
  if (uidescedit) {
    set_has_uidescedit();
    controlDescription_.uidescedit_ = uidescedit;
  }
}

// optional .AnselIpc.UIDescBoolean uiDescBoolean = 6;
inline bool UIControlChangedRequest::has_uidescboolean() const {
  return controlDescription_case() == kUiDescBoolean;
}
inline void UIControlChangedRequest::set_has_uidescboolean() {
  _oneof_case_[0] = kUiDescBoolean;
}
inline void UIControlChangedRequest::clear_uidescboolean() {
  if (has_uidescboolean()) {
    delete controlDescription_.uidescboolean_;
    clear_has_controlDescription();
  }
}
inline const ::AnselIpc::UIDescBoolean& UIControlChangedRequest::uidescboolean() const {
  return has_uidescboolean() ? *controlDescription_.uidescboolean_
                      : ::AnselIpc::UIDescBoolean::default_instance();
}
inline ::AnselIpc::UIDescBoolean* UIControlChangedRequest::mutable_uidescboolean() {
  if (!has_uidescboolean()) {
    clear_controlDescription();
    set_has_uidescboolean();
    controlDescription_.uidescboolean_ = new ::AnselIpc::UIDescBoolean;
  }
  return controlDescription_.uidescboolean_;
}
inline ::AnselIpc::UIDescBoolean* UIControlChangedRequest::release_uidescboolean() {
  if (has_uidescboolean()) {
    clear_has_controlDescription();
    ::AnselIpc::UIDescBoolean* temp = controlDescription_.uidescboolean_;
    controlDescription_.uidescboolean_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void UIControlChangedRequest::set_allocated_uidescboolean(::AnselIpc::UIDescBoolean* uidescboolean) {
  clear_controlDescription();
  if (uidescboolean) {
    set_has_uidescboolean();
    controlDescription_.uidescboolean_ = uidescboolean;
  }
}

// optional .AnselIpc.UIDescLabel uiDescLabel = 7;
inline bool UIControlChangedRequest::has_uidesclabel() const {
  return controlDescription_case() == kUiDescLabel;
}
inline void UIControlChangedRequest::set_has_uidesclabel() {
  _oneof_case_[0] = kUiDescLabel;
}
inline void UIControlChangedRequest::clear_uidesclabel() {
  if (has_uidesclabel()) {
    delete controlDescription_.uidesclabel_;
    clear_has_controlDescription();
  }
}
inline const ::AnselIpc::UIDescLabel& UIControlChangedRequest::uidesclabel() const {
  return has_uidesclabel() ? *controlDescription_.uidesclabel_
                      : ::AnselIpc::UIDescLabel::default_instance();
}
inline ::AnselIpc::UIDescLabel* UIControlChangedRequest::mutable_uidesclabel() {
  if (!has_uidesclabel()) {
    clear_controlDescription();
    set_has_uidesclabel();
    controlDescription_.uidesclabel_ = new ::AnselIpc::UIDescLabel;
  }
  return controlDescription_.uidesclabel_;
}
inline ::AnselIpc::UIDescLabel* UIControlChangedRequest::release_uidesclabel() {
  if (has_uidesclabel()) {
    clear_has_controlDescription();
    ::AnselIpc::UIDescLabel* temp = controlDescription_.uidesclabel_;
    controlDescription_.uidesclabel_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void UIControlChangedRequest::set_allocated_uidesclabel(::AnselIpc::UIDescLabel* uidesclabel) {
  clear_controlDescription();
  if (uidesclabel) {
    set_has_uidesclabel();
    controlDescription_.uidesclabel_ = uidesclabel;
  }
}

// optional .AnselIpc.UIDescList uiDescList = 8;
inline bool UIControlChangedRequest::has_uidesclist() const {
  return controlDescription_case() == kUiDescList;
}
inline void UIControlChangedRequest::set_has_uidesclist() {
  _oneof_case_[0] = kUiDescList;
}
inline void UIControlChangedRequest::clear_uidesclist() {
  if (has_uidesclist()) {
    delete controlDescription_.uidesclist_;
    clear_has_controlDescription();
  }
}
inline const ::AnselIpc::UIDescList& UIControlChangedRequest::uidesclist() const {
  return has_uidesclist() ? *controlDescription_.uidesclist_
                      : ::AnselIpc::UIDescList::default_instance();
}
inline ::AnselIpc::UIDescList* UIControlChangedRequest::mutable_uidesclist() {
  if (!has_uidesclist()) {
    clear_controlDescription();
    set_has_uidesclist();
    controlDescription_.uidesclist_ = new ::AnselIpc::UIDescList;
  }
  return controlDescription_.uidesclist_;
}
inline ::AnselIpc::UIDescList* UIControlChangedRequest::release_uidesclist() {
  if (has_uidesclist()) {
    clear_has_controlDescription();
    ::AnselIpc::UIDescList* temp = controlDescription_.uidesclist_;
    controlDescription_.uidesclist_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void UIControlChangedRequest::set_allocated_uidesclist(::AnselIpc::UIDescList* uidesclist) {
  clear_controlDescription();
  if (uidesclist) {
    set_has_uidesclist();
    controlDescription_.uidesclist_ = uidesclist;
  }
}

inline bool UIControlChangedRequest::has_controlDescription() {
  return controlDescription_case() != CONTROLDESCRIPTION_NOT_SET;
}
inline void UIControlChangedRequest::clear_has_controlDescription() {
  _oneof_case_[0] = CONTROLDESCRIPTION_NOT_SET;
}
inline UIControlChangedRequest::ControlDescriptionCase UIControlChangedRequest::controlDescription_case() const {
  return UIControlChangedRequest::ControlDescriptionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UIControlChangedResponse

// required .AnselIpc.Status status = 1;
inline bool UIControlChangedResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIControlChangedResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIControlChangedResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIControlChangedResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status UIControlChangedResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIControlChangedResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void UIControlChangedResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIControlChangedResponse.status)
}

// -------------------------------------------------------------------

// UIControlRemoveAllRequest

// -------------------------------------------------------------------

// UIControlRemoveAllResponse

// required .AnselIpc.Status status = 1;
inline bool UIControlRemoveAllResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIControlRemoveAllResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIControlRemoveAllResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIControlRemoveAllResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status UIControlRemoveAllResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIControlRemoveAllResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void UIControlRemoveAllResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIControlRemoveAllResponse.status)
}

// -------------------------------------------------------------------

// UIControlRemoveRequest

// repeated int32 id = 1;
inline int UIControlRemoveRequest::id_size() const {
  return id_.size();
}
inline void UIControlRemoveRequest::clear_id() {
  id_.Clear();
}
inline ::google::protobuf::int32 UIControlRemoveRequest::id(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIControlRemoveRequest.id)
  return id_.Get(index);
}
inline void UIControlRemoveRequest::set_id(int index, ::google::protobuf::int32 value) {
  id_.Set(index, value);
  // @@protoc_insertion_point(field_set:AnselIpc.UIControlRemoveRequest.id)
}
inline void UIControlRemoveRequest::add_id(::google::protobuf::int32 value) {
  id_.Add(value);
  // @@protoc_insertion_point(field_add:AnselIpc.UIControlRemoveRequest.id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
UIControlRemoveRequest::id() const {
  // @@protoc_insertion_point(field_list:AnselIpc.UIControlRemoveRequest.id)
  return id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
UIControlRemoveRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.UIControlRemoveRequest.id)
  return &id_;
}

// -------------------------------------------------------------------

// UIControlRemoveResponse

// required .AnselIpc.Status status = 1;
inline bool UIControlRemoveResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIControlRemoveResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIControlRemoveResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIControlRemoveResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status UIControlRemoveResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIControlRemoveResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void UIControlRemoveResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIControlRemoveResponse.status)
}

// -------------------------------------------------------------------

// UIControlSetVisibilityRequest

// required int32 id = 1;
inline bool UIControlSetVisibilityRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIControlSetVisibilityRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIControlSetVisibilityRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIControlSetVisibilityRequest::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 UIControlSetVisibilityRequest::id() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIControlSetVisibilityRequest.id)
  return id_;
}
inline void UIControlSetVisibilityRequest::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIControlSetVisibilityRequest.id)
}

// required bool visible = 2;
inline bool UIControlSetVisibilityRequest::has_visible() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UIControlSetVisibilityRequest::set_has_visible() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UIControlSetVisibilityRequest::clear_has_visible() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UIControlSetVisibilityRequest::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool UIControlSetVisibilityRequest::visible() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIControlSetVisibilityRequest.visible)
  return visible_;
}
inline void UIControlSetVisibilityRequest::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIControlSetVisibilityRequest.visible)
}

// -------------------------------------------------------------------

// UIControlSetVisibilityResponse

// required .AnselIpc.Status status = 1;
inline bool UIControlSetVisibilityResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIControlSetVisibilityResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIControlSetVisibilityResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIControlSetVisibilityResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status UIControlSetVisibilityResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIControlSetVisibilityResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void UIControlSetVisibilityResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIControlSetVisibilityResponse.status)
}

// -------------------------------------------------------------------

// UIControlGetVisibilityRequest

// required int32 id = 1;
inline bool UIControlGetVisibilityRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIControlGetVisibilityRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIControlGetVisibilityRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIControlGetVisibilityRequest::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 UIControlGetVisibilityRequest::id() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIControlGetVisibilityRequest.id)
  return id_;
}
inline void UIControlGetVisibilityRequest::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIControlGetVisibilityRequest.id)
}

// -------------------------------------------------------------------

// UIControlGetVisibilityResponse

// required bool visible = 1;
inline bool UIControlGetVisibilityResponse::has_visible() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIControlGetVisibilityResponse::set_has_visible() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIControlGetVisibilityResponse::clear_has_visible() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIControlGetVisibilityResponse::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool UIControlGetVisibilityResponse::visible() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UIControlGetVisibilityResponse.visible)
  return visible_;
}
inline void UIControlGetVisibilityResponse::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UIControlGetVisibilityResponse.visible)
}

// -------------------------------------------------------------------

// GetGameSpecificControlsRequest

// -------------------------------------------------------------------

// GetSettingsRequest

// -------------------------------------------------------------------

// GetSettingsResponse_Setting

// required string name = 1;
inline bool GetSettingsResponse_Setting::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSettingsResponse_Setting::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSettingsResponse_Setting::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSettingsResponse_Setting::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GetSettingsResponse_Setting::name() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetSettingsResponse.Setting.name)
  return *name_;
}
inline void GetSettingsResponse_Setting::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.GetSettingsResponse.Setting.name)
}
inline void GetSettingsResponse_Setting::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.GetSettingsResponse.Setting.name)
}
inline void GetSettingsResponse_Setting::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.GetSettingsResponse.Setting.name)
}
inline ::std::string* GetSettingsResponse_Setting::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.GetSettingsResponse.Setting.name)
  return name_;
}
inline ::std::string* GetSettingsResponse_Setting::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetSettingsResponse_Setting::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.GetSettingsResponse.Setting.name)
}

// required string value = 2;
inline bool GetSettingsResponse_Setting::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetSettingsResponse_Setting::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetSettingsResponse_Setting::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetSettingsResponse_Setting::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& GetSettingsResponse_Setting::value() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetSettingsResponse.Setting.value)
  return *value_;
}
inline void GetSettingsResponse_Setting::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.GetSettingsResponse.Setting.value)
}
inline void GetSettingsResponse_Setting::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.GetSettingsResponse.Setting.value)
}
inline void GetSettingsResponse_Setting::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.GetSettingsResponse.Setting.value)
}
inline ::std::string* GetSettingsResponse_Setting::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.GetSettingsResponse.Setting.value)
  return value_;
}
inline ::std::string* GetSettingsResponse_Setting::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetSettingsResponse_Setting::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.GetSettingsResponse.Setting.value)
}

// -------------------------------------------------------------------

// GetSettingsResponse

// repeated .AnselIpc.GetSettingsResponse.Setting settings = 1;
inline int GetSettingsResponse::settings_size() const {
  return settings_.size();
}
inline void GetSettingsResponse::clear_settings() {
  settings_.Clear();
}
inline const ::AnselIpc::GetSettingsResponse_Setting& GetSettingsResponse::settings(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetSettingsResponse.settings)
  return settings_.Get(index);
}
inline ::AnselIpc::GetSettingsResponse_Setting* GetSettingsResponse::mutable_settings(int index) {
  // @@protoc_insertion_point(field_mutable:AnselIpc.GetSettingsResponse.settings)
  return settings_.Mutable(index);
}
inline ::AnselIpc::GetSettingsResponse_Setting* GetSettingsResponse::add_settings() {
  // @@protoc_insertion_point(field_add:AnselIpc.GetSettingsResponse.settings)
  return settings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::GetSettingsResponse_Setting >&
GetSettingsResponse::settings() const {
  // @@protoc_insertion_point(field_list:AnselIpc.GetSettingsResponse.settings)
  return settings_;
}
inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::GetSettingsResponse_Setting >*
GetSettingsResponse::mutable_settings() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.GetSettingsResponse.settings)
  return &settings_;
}

// -------------------------------------------------------------------

// GetFeatureSetRequest

// optional .AnselIpc.IpcVersionResponse requestorsIPCVersion = 1;
inline bool GetFeatureSetRequest::has_requestorsipcversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFeatureSetRequest::set_has_requestorsipcversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFeatureSetRequest::clear_has_requestorsipcversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFeatureSetRequest::clear_requestorsipcversion() {
  if (requestorsipcversion_ != NULL) requestorsipcversion_->::AnselIpc::IpcVersionResponse::Clear();
  clear_has_requestorsipcversion();
}
inline const ::AnselIpc::IpcVersionResponse& GetFeatureSetRequest::requestorsipcversion() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetFeatureSetRequest.requestorsIPCVersion)
  return requestorsipcversion_ != NULL ? *requestorsipcversion_ : *default_instance_->requestorsipcversion_;
}
inline ::AnselIpc::IpcVersionResponse* GetFeatureSetRequest::mutable_requestorsipcversion() {
  set_has_requestorsipcversion();
  if (requestorsipcversion_ == NULL) requestorsipcversion_ = new ::AnselIpc::IpcVersionResponse;
  // @@protoc_insertion_point(field_mutable:AnselIpc.GetFeatureSetRequest.requestorsIPCVersion)
  return requestorsipcversion_;
}
inline ::AnselIpc::IpcVersionResponse* GetFeatureSetRequest::release_requestorsipcversion() {
  clear_has_requestorsipcversion();
  ::AnselIpc::IpcVersionResponse* temp = requestorsipcversion_;
  requestorsipcversion_ = NULL;
  return temp;
}
inline void GetFeatureSetRequest::set_allocated_requestorsipcversion(::AnselIpc::IpcVersionResponse* requestorsipcversion) {
  delete requestorsipcversion_;
  requestorsipcversion_ = requestorsipcversion;
  if (requestorsipcversion) {
    set_has_requestorsipcversion();
  } else {
    clear_has_requestorsipcversion();
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.GetFeatureSetRequest.requestorsIPCVersion)
}

// -------------------------------------------------------------------

// GetFeatureSetResponse

// required bool sdkDetected = 1;
inline bool GetFeatureSetResponse::has_sdkdetected() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFeatureSetResponse::set_has_sdkdetected() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFeatureSetResponse::clear_has_sdkdetected() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFeatureSetResponse::clear_sdkdetected() {
  sdkdetected_ = false;
  clear_has_sdkdetected();
}
inline bool GetFeatureSetResponse::sdkdetected() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetFeatureSetResponse.sdkDetected)
  return sdkdetected_;
}
inline void GetFeatureSetResponse::set_sdkdetected(bool value) {
  set_has_sdkdetected();
  sdkdetected_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetFeatureSetResponse.sdkDetected)
}

// required bool modsAvailable = 2;
inline bool GetFeatureSetResponse::has_modsavailable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetFeatureSetResponse::set_has_modsavailable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetFeatureSetResponse::clear_has_modsavailable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetFeatureSetResponse::clear_modsavailable() {
  modsavailable_ = false;
  clear_has_modsavailable();
}
inline bool GetFeatureSetResponse::modsavailable() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetFeatureSetResponse.modsAvailable)
  return modsavailable_;
}
inline void GetFeatureSetResponse::set_modsavailable(bool value) {
  set_has_modsavailable();
  modsavailable_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetFeatureSetResponse.modsAvailable)
}

// required bool restyleAvailable = 3;
inline bool GetFeatureSetResponse::has_restyleavailable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetFeatureSetResponse::set_has_restyleavailable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetFeatureSetResponse::clear_has_restyleavailable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetFeatureSetResponse::clear_restyleavailable() {
  restyleavailable_ = false;
  clear_has_restyleavailable();
}
inline bool GetFeatureSetResponse::restyleavailable() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetFeatureSetResponse.restyleAvailable)
  return restyleavailable_;
}
inline void GetFeatureSetResponse::set_restyleavailable(bool value) {
  set_has_restyleavailable();
  restyleavailable_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetFeatureSetResponse.restyleAvailable)
}

// optional bool allowOffline = 4;
inline bool GetFeatureSetResponse::has_allowoffline() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetFeatureSetResponse::set_has_allowoffline() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetFeatureSetResponse::clear_has_allowoffline() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetFeatureSetResponse::clear_allowoffline() {
  allowoffline_ = false;
  clear_has_allowoffline();
}
inline bool GetFeatureSetResponse::allowoffline() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetFeatureSetResponse.allowOffline)
  return allowoffline_;
}
inline void GetFeatureSetResponse::set_allowoffline(bool value) {
  set_has_allowoffline();
  allowoffline_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetFeatureSetResponse.allowOffline)
}

// -------------------------------------------------------------------

// SetCMSInfoRequest

// optional string cmsid = 1;
inline bool SetCMSInfoRequest::has_cmsid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetCMSInfoRequest::set_has_cmsid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetCMSInfoRequest::clear_has_cmsid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetCMSInfoRequest::clear_cmsid() {
  if (cmsid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cmsid_->clear();
  }
  clear_has_cmsid();
}
inline const ::std::string& SetCMSInfoRequest::cmsid() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetCMSInfoRequest.cmsid)
  return *cmsid_;
}
inline void SetCMSInfoRequest::set_cmsid(const ::std::string& value) {
  set_has_cmsid();
  if (cmsid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cmsid_ = new ::std::string;
  }
  cmsid_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.SetCMSInfoRequest.cmsid)
}
inline void SetCMSInfoRequest::set_cmsid(const char* value) {
  set_has_cmsid();
  if (cmsid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cmsid_ = new ::std::string;
  }
  cmsid_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.SetCMSInfoRequest.cmsid)
}
inline void SetCMSInfoRequest::set_cmsid(const char* value, size_t size) {
  set_has_cmsid();
  if (cmsid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cmsid_ = new ::std::string;
  }
  cmsid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.SetCMSInfoRequest.cmsid)
}
inline ::std::string* SetCMSInfoRequest::mutable_cmsid() {
  set_has_cmsid();
  if (cmsid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cmsid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.SetCMSInfoRequest.cmsid)
  return cmsid_;
}
inline ::std::string* SetCMSInfoRequest::release_cmsid() {
  clear_has_cmsid();
  if (cmsid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cmsid_;
    cmsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetCMSInfoRequest::set_allocated_cmsid(::std::string* cmsid) {
  if (cmsid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cmsid_;
  }
  if (cmsid) {
    set_has_cmsid();
    cmsid_ = cmsid;
  } else {
    clear_has_cmsid();
    cmsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.SetCMSInfoRequest.cmsid)
}

// optional string shortName = 2;
inline bool SetCMSInfoRequest::has_shortname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetCMSInfoRequest::set_has_shortname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetCMSInfoRequest::clear_has_shortname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetCMSInfoRequest::clear_shortname() {
  if (shortname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shortname_->clear();
  }
  clear_has_shortname();
}
inline const ::std::string& SetCMSInfoRequest::shortname() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetCMSInfoRequest.shortName)
  return *shortname_;
}
inline void SetCMSInfoRequest::set_shortname(const ::std::string& value) {
  set_has_shortname();
  if (shortname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shortname_ = new ::std::string;
  }
  shortname_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.SetCMSInfoRequest.shortName)
}
inline void SetCMSInfoRequest::set_shortname(const char* value) {
  set_has_shortname();
  if (shortname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shortname_ = new ::std::string;
  }
  shortname_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.SetCMSInfoRequest.shortName)
}
inline void SetCMSInfoRequest::set_shortname(const char* value, size_t size) {
  set_has_shortname();
  if (shortname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shortname_ = new ::std::string;
  }
  shortname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.SetCMSInfoRequest.shortName)
}
inline ::std::string* SetCMSInfoRequest::mutable_shortname() {
  set_has_shortname();
  if (shortname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shortname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.SetCMSInfoRequest.shortName)
  return shortname_;
}
inline ::std::string* SetCMSInfoRequest::release_shortname() {
  clear_has_shortname();
  if (shortname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = shortname_;
    shortname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetCMSInfoRequest::set_allocated_shortname(::std::string* shortname) {
  if (shortname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete shortname_;
  }
  if (shortname) {
    set_has_shortname();
    shortname_ = shortname;
  } else {
    clear_has_shortname();
    shortname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.SetCMSInfoRequest.shortName)
}

// -------------------------------------------------------------------

// SetCMSInfoResponse

// required .AnselIpc.Status status = 1;
inline bool SetCMSInfoResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetCMSInfoResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetCMSInfoResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetCMSInfoResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status SetCMSInfoResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetCMSInfoResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void SetCMSInfoResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetCMSInfoResponse.status)
}

// -------------------------------------------------------------------

// GetEnabledFeatureSetRequest

// -------------------------------------------------------------------

// GetEnabledFeatureSetResponse

// required bool modsAvailable = 1;
inline bool GetEnabledFeatureSetResponse::has_modsavailable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEnabledFeatureSetResponse::set_has_modsavailable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEnabledFeatureSetResponse::clear_has_modsavailable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEnabledFeatureSetResponse::clear_modsavailable() {
  modsavailable_ = false;
  clear_has_modsavailable();
}
inline bool GetEnabledFeatureSetResponse::modsavailable() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetEnabledFeatureSetResponse.modsAvailable)
  return modsavailable_;
}
inline void GetEnabledFeatureSetResponse::set_modsavailable(bool value) {
  set_has_modsavailable();
  modsavailable_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetEnabledFeatureSetResponse.modsAvailable)
}

// -------------------------------------------------------------------

// IsAnselModdingAvailableRequest

// -------------------------------------------------------------------

// IsAnselModdingAvailableResponse

// required .AnselIpc.Status status = 1;
inline bool IsAnselModdingAvailableResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IsAnselModdingAvailableResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IsAnselModdingAvailableResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IsAnselModdingAvailableResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status IsAnselModdingAvailableResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.IsAnselModdingAvailableResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void IsAnselModdingAvailableResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.IsAnselModdingAvailableResponse.status)
}

// -------------------------------------------------------------------

// IsAnselSDKIntegrationAvailableRequest

// -------------------------------------------------------------------

// IsAnselSDKIntegrationAvailableResponse

// required .AnselIpc.Status status = 1;
inline bool IsAnselSDKIntegrationAvailableResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IsAnselSDKIntegrationAvailableResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IsAnselSDKIntegrationAvailableResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IsAnselSDKIntegrationAvailableResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status IsAnselSDKIntegrationAvailableResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.IsAnselSDKIntegrationAvailableResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void IsAnselSDKIntegrationAvailableResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.IsAnselSDKIntegrationAvailableResponse.status)
}

// -------------------------------------------------------------------

// ScreenResolutionChangedRequest

// -------------------------------------------------------------------

// ScreenResolutionChangedResponse

// -------------------------------------------------------------------

// SetGridOfThirdsEnabledRequest

// required bool enabled = 1;
inline bool SetGridOfThirdsEnabledRequest::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetGridOfThirdsEnabledRequest::set_has_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetGridOfThirdsEnabledRequest::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetGridOfThirdsEnabledRequest::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool SetGridOfThirdsEnabledRequest::enabled() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetGridOfThirdsEnabledRequest.enabled)
  return enabled_;
}
inline void SetGridOfThirdsEnabledRequest::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetGridOfThirdsEnabledRequest.enabled)
}

// -------------------------------------------------------------------

// SetGridOfThirdsEnabledResponse

// required .AnselIpc.Status status = 1;
inline bool SetGridOfThirdsEnabledResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetGridOfThirdsEnabledResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetGridOfThirdsEnabledResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetGridOfThirdsEnabledResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status SetGridOfThirdsEnabledResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetGridOfThirdsEnabledResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void SetGridOfThirdsEnabledResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetGridOfThirdsEnabledResponse.status)
}

// -------------------------------------------------------------------

// GetProcessInfoRequest

// -------------------------------------------------------------------

// GetProcessInfoResponse

// required .AnselIpc.Status status = 1;
inline bool GetProcessInfoResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetProcessInfoResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetProcessInfoResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetProcessInfoResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status GetProcessInfoResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetProcessInfoResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void GetProcessInfoResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetProcessInfoResponse.status)
}

// required uint32 processId = 2;
inline bool GetProcessInfoResponse::has_processid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetProcessInfoResponse::set_has_processid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetProcessInfoResponse::clear_has_processid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetProcessInfoResponse::clear_processid() {
  processid_ = 0u;
  clear_has_processid();
}
inline ::google::protobuf::uint32 GetProcessInfoResponse::processid() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetProcessInfoResponse.processId)
  return processid_;
}
inline void GetProcessInfoResponse::set_processid(::google::protobuf::uint32 value) {
  set_has_processid();
  processid_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetProcessInfoResponse.processId)
}

// required string processPath = 3;
inline bool GetProcessInfoResponse::has_processpath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetProcessInfoResponse::set_has_processpath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetProcessInfoResponse::clear_has_processpath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetProcessInfoResponse::clear_processpath() {
  if (processpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processpath_->clear();
  }
  clear_has_processpath();
}
inline const ::std::string& GetProcessInfoResponse::processpath() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetProcessInfoResponse.processPath)
  return *processpath_;
}
inline void GetProcessInfoResponse::set_processpath(const ::std::string& value) {
  set_has_processpath();
  if (processpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processpath_ = new ::std::string;
  }
  processpath_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.GetProcessInfoResponse.processPath)
}
inline void GetProcessInfoResponse::set_processpath(const char* value) {
  set_has_processpath();
  if (processpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processpath_ = new ::std::string;
  }
  processpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.GetProcessInfoResponse.processPath)
}
inline void GetProcessInfoResponse::set_processpath(const char* value, size_t size) {
  set_has_processpath();
  if (processpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processpath_ = new ::std::string;
  }
  processpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.GetProcessInfoResponse.processPath)
}
inline ::std::string* GetProcessInfoResponse::mutable_processpath() {
  set_has_processpath();
  if (processpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.GetProcessInfoResponse.processPath)
  return processpath_;
}
inline ::std::string* GetProcessInfoResponse::release_processpath() {
  clear_has_processpath();
  if (processpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = processpath_;
    processpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetProcessInfoResponse::set_allocated_processpath(::std::string* processpath) {
  if (processpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete processpath_;
  }
  if (processpath) {
    set_has_processpath();
    processpath_ = processpath;
  } else {
    clear_has_processpath();
    processpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.GetProcessInfoResponse.processPath)
}

// -------------------------------------------------------------------

// SetAnselEnabledRequest

// required uint32 major = 1;
inline bool SetAnselEnabledRequest::has_major() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetAnselEnabledRequest::set_has_major() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetAnselEnabledRequest::clear_has_major() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetAnselEnabledRequest::clear_major() {
  major_ = 0u;
  clear_has_major();
}
inline ::google::protobuf::uint32 SetAnselEnabledRequest::major() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetAnselEnabledRequest.major)
  return major_;
}
inline void SetAnselEnabledRequest::set_major(::google::protobuf::uint32 value) {
  set_has_major();
  major_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetAnselEnabledRequest.major)
}

// required uint32 minor = 2;
inline bool SetAnselEnabledRequest::has_minor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetAnselEnabledRequest::set_has_minor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetAnselEnabledRequest::clear_has_minor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetAnselEnabledRequest::clear_minor() {
  minor_ = 0u;
  clear_has_minor();
}
inline ::google::protobuf::uint32 SetAnselEnabledRequest::minor() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetAnselEnabledRequest.minor)
  return minor_;
}
inline void SetAnselEnabledRequest::set_minor(::google::protobuf::uint32 value) {
  set_has_minor();
  minor_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetAnselEnabledRequest.minor)
}

// required uint32 patch = 3;
inline bool SetAnselEnabledRequest::has_patch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetAnselEnabledRequest::set_has_patch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetAnselEnabledRequest::clear_has_patch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetAnselEnabledRequest::clear_patch() {
  patch_ = 0u;
  clear_has_patch();
}
inline ::google::protobuf::uint32 SetAnselEnabledRequest::patch() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetAnselEnabledRequest.patch)
  return patch_;
}
inline void SetAnselEnabledRequest::set_patch(::google::protobuf::uint32 value) {
  set_has_patch();
  patch_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetAnselEnabledRequest.patch)
}

// required bool enabled = 4;
inline bool SetAnselEnabledRequest::has_enabled() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetAnselEnabledRequest::set_has_enabled() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetAnselEnabledRequest::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetAnselEnabledRequest::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool SetAnselEnabledRequest::enabled() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetAnselEnabledRequest.enabled)
  return enabled_;
}
inline void SetAnselEnabledRequest::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetAnselEnabledRequest.enabled)
}

// optional bool leaveFiltersEnabled = 5;
inline bool SetAnselEnabledRequest::has_leavefiltersenabled() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SetAnselEnabledRequest::set_has_leavefiltersenabled() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SetAnselEnabledRequest::clear_has_leavefiltersenabled() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SetAnselEnabledRequest::clear_leavefiltersenabled() {
  leavefiltersenabled_ = false;
  clear_has_leavefiltersenabled();
}
inline bool SetAnselEnabledRequest::leavefiltersenabled() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetAnselEnabledRequest.leaveFiltersEnabled)
  return leavefiltersenabled_;
}
inline void SetAnselEnabledRequest::set_leavefiltersenabled(bool value) {
  set_has_leavefiltersenabled();
  leavefiltersenabled_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetAnselEnabledRequest.leaveFiltersEnabled)
}

// optional bool pauseApplication = 6;
inline bool SetAnselEnabledRequest::has_pauseapplication() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SetAnselEnabledRequest::set_has_pauseapplication() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SetAnselEnabledRequest::clear_has_pauseapplication() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SetAnselEnabledRequest::clear_pauseapplication() {
  pauseapplication_ = false;
  clear_has_pauseapplication();
}
inline bool SetAnselEnabledRequest::pauseapplication() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetAnselEnabledRequest.pauseApplication)
  return pauseapplication_;
}
inline void SetAnselEnabledRequest::set_pauseapplication(bool value) {
  set_has_pauseapplication();
  pauseapplication_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetAnselEnabledRequest.pauseApplication)
}

// -------------------------------------------------------------------

// SetAnselEnabledResponse

// required .AnselIpc.Status status = 1;
inline bool SetAnselEnabledResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetAnselEnabledResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetAnselEnabledResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetAnselEnabledResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status SetAnselEnabledResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetAnselEnabledResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void SetAnselEnabledResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetAnselEnabledResponse.status)
}

// -------------------------------------------------------------------

// GetAnselEnabledRequest

// -------------------------------------------------------------------

// GetAnselEnabledResponse

// required bool enabled = 1;
inline bool GetAnselEnabledResponse::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAnselEnabledResponse::set_has_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAnselEnabledResponse::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAnselEnabledResponse::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool GetAnselEnabledResponse::enabled() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetAnselEnabledResponse.enabled)
  return enabled_;
}
inline void GetAnselEnabledResponse::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetAnselEnabledResponse.enabled)
}

// -------------------------------------------------------------------

// GetAnselShotPermissionsRequest

// -------------------------------------------------------------------

// GetAnselShotPermissionsResponse

// required bool isIntegrationDetected = 1;
inline bool GetAnselShotPermissionsResponse::has_isintegrationdetected() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAnselShotPermissionsResponse::set_has_isintegrationdetected() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAnselShotPermissionsResponse::clear_has_isintegrationdetected() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAnselShotPermissionsResponse::clear_isintegrationdetected() {
  isintegrationdetected_ = false;
  clear_has_isintegrationdetected();
}
inline bool GetAnselShotPermissionsResponse::isintegrationdetected() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetAnselShotPermissionsResponse.isIntegrationDetected)
  return isintegrationdetected_;
}
inline void GetAnselShotPermissionsResponse::set_isintegrationdetected(bool value) {
  set_has_isintegrationdetected();
  isintegrationdetected_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetAnselShotPermissionsResponse.isIntegrationDetected)
}

// required bool isHDRAllowed = 2;
inline bool GetAnselShotPermissionsResponse::has_ishdrallowed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAnselShotPermissionsResponse::set_has_ishdrallowed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAnselShotPermissionsResponse::clear_has_ishdrallowed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAnselShotPermissionsResponse::clear_ishdrallowed() {
  ishdrallowed_ = false;
  clear_has_ishdrallowed();
}
inline bool GetAnselShotPermissionsResponse::ishdrallowed() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetAnselShotPermissionsResponse.isHDRAllowed)
  return ishdrallowed_;
}
inline void GetAnselShotPermissionsResponse::set_ishdrallowed(bool value) {
  set_has_ishdrallowed();
  ishdrallowed_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetAnselShotPermissionsResponse.isHDRAllowed)
}

// repeated bool isShotAllowed = 3;
inline int GetAnselShotPermissionsResponse::isshotallowed_size() const {
  return isshotallowed_.size();
}
inline void GetAnselShotPermissionsResponse::clear_isshotallowed() {
  isshotallowed_.Clear();
}
inline bool GetAnselShotPermissionsResponse::isshotallowed(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetAnselShotPermissionsResponse.isShotAllowed)
  return isshotallowed_.Get(index);
}
inline void GetAnselShotPermissionsResponse::set_isshotallowed(int index, bool value) {
  isshotallowed_.Set(index, value);
  // @@protoc_insertion_point(field_set:AnselIpc.GetAnselShotPermissionsResponse.isShotAllowed)
}
inline void GetAnselShotPermissionsResponse::add_isshotallowed(bool value) {
  isshotallowed_.Add(value);
  // @@protoc_insertion_point(field_add:AnselIpc.GetAnselShotPermissionsResponse.isShotAllowed)
}
inline const ::google::protobuf::RepeatedField< bool >&
GetAnselShotPermissionsResponse::isshotallowed() const {
  // @@protoc_insertion_point(field_list:AnselIpc.GetAnselShotPermissionsResponse.isShotAllowed)
  return isshotallowed_;
}
inline ::google::protobuf::RepeatedField< bool >*
GetAnselShotPermissionsResponse::mutable_isshotallowed() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.GetAnselShotPermissionsResponse.isShotAllowed)
  return &isshotallowed_;
}

// -------------------------------------------------------------------

// SetLangIdRequest

// required int32 lang = 1;
inline bool SetLangIdRequest::has_lang() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetLangIdRequest::set_has_lang() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetLangIdRequest::clear_has_lang() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetLangIdRequest::clear_lang() {
  lang_ = 0;
  clear_has_lang();
}
inline ::google::protobuf::int32 SetLangIdRequest::lang() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetLangIdRequest.lang)
  return lang_;
}
inline void SetLangIdRequest::set_lang(::google::protobuf::int32 value) {
  set_has_lang();
  lang_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetLangIdRequest.lang)
}

// required int32 subLang = 2;
inline bool SetLangIdRequest::has_sublang() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetLangIdRequest::set_has_sublang() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetLangIdRequest::clear_has_sublang() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetLangIdRequest::clear_sublang() {
  sublang_ = 0;
  clear_has_sublang();
}
inline ::google::protobuf::int32 SetLangIdRequest::sublang() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetLangIdRequest.subLang)
  return sublang_;
}
inline void SetLangIdRequest::set_sublang(::google::protobuf::int32 value) {
  set_has_sublang();
  sublang_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetLangIdRequest.subLang)
}

// -------------------------------------------------------------------

// SetLangIdResponse

// required .AnselIpc.Status status = 1;
inline bool SetLangIdResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetLangIdResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetLangIdResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetLangIdResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status SetLangIdResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetLangIdResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void SetLangIdResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetLangIdResponse.status)
}

// -------------------------------------------------------------------

// GetFOVRangeRequest

// -------------------------------------------------------------------

// GetFOVRangeResponse

// required float minFov = 1;
inline bool GetFOVRangeResponse::has_minfov() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFOVRangeResponse::set_has_minfov() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFOVRangeResponse::clear_has_minfov() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFOVRangeResponse::clear_minfov() {
  minfov_ = 0;
  clear_has_minfov();
}
inline float GetFOVRangeResponse::minfov() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetFOVRangeResponse.minFov)
  return minfov_;
}
inline void GetFOVRangeResponse::set_minfov(float value) {
  set_has_minfov();
  minfov_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetFOVRangeResponse.minFov)
}

// required float maxFov = 2;
inline bool GetFOVRangeResponse::has_maxfov() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetFOVRangeResponse::set_has_maxfov() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetFOVRangeResponse::clear_has_maxfov() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetFOVRangeResponse::clear_maxfov() {
  maxfov_ = 0;
  clear_has_maxfov();
}
inline float GetFOVRangeResponse::maxfov() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetFOVRangeResponse.maxFov)
  return maxfov_;
}
inline void GetFOVRangeResponse::set_maxfov(float value) {
  set_has_maxfov();
  maxfov_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetFOVRangeResponse.maxFov)
}

// -------------------------------------------------------------------

// SetFOVRequest

// required float fov = 1;
inline bool SetFOVRequest::has_fov() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetFOVRequest::set_has_fov() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetFOVRequest::clear_has_fov() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetFOVRequest::clear_fov() {
  fov_ = 0;
  clear_has_fov();
}
inline float SetFOVRequest::fov() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFOVRequest.fov)
  return fov_;
}
inline void SetFOVRequest::set_fov(float value) {
  set_has_fov();
  fov_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetFOVRequest.fov)
}

// -------------------------------------------------------------------

// SetFOVResponse

// required .AnselIpc.Status status = 1;
inline bool SetFOVResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetFOVResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetFOVResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetFOVResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status SetFOVResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFOVResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void SetFOVResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetFOVResponse.status)
}

// -------------------------------------------------------------------

// GetLwrrentFOVRequest

// -------------------------------------------------------------------

// GetLwrrentFOVResponse

// required float fov = 1;
inline bool GetLwrrentFOVResponse::has_fov() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLwrrentFOVResponse::set_has_fov() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLwrrentFOVResponse::clear_has_fov() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLwrrentFOVResponse::clear_fov() {
  fov_ = 0;
  clear_has_fov();
}
inline float GetLwrrentFOVResponse::fov() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetLwrrentFOVResponse.fov)
  return fov_;
}
inline void GetLwrrentFOVResponse::set_fov(float value) {
  set_has_fov();
  fov_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetLwrrentFOVResponse.fov)
}

// -------------------------------------------------------------------

// GetRollRangeRequest

// -------------------------------------------------------------------

// GetRollRangeResponse

// required float minRoll = 1;
inline bool GetRollRangeResponse::has_minroll() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetRollRangeResponse::set_has_minroll() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetRollRangeResponse::clear_has_minroll() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetRollRangeResponse::clear_minroll() {
  minroll_ = 0;
  clear_has_minroll();
}
inline float GetRollRangeResponse::minroll() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetRollRangeResponse.minRoll)
  return minroll_;
}
inline void GetRollRangeResponse::set_minroll(float value) {
  set_has_minroll();
  minroll_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetRollRangeResponse.minRoll)
}

// required float maxRoll = 2;
inline bool GetRollRangeResponse::has_maxroll() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetRollRangeResponse::set_has_maxroll() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetRollRangeResponse::clear_has_maxroll() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetRollRangeResponse::clear_maxroll() {
  maxroll_ = 0;
  clear_has_maxroll();
}
inline float GetRollRangeResponse::maxroll() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetRollRangeResponse.maxRoll)
  return maxroll_;
}
inline void GetRollRangeResponse::set_maxroll(float value) {
  set_has_maxroll();
  maxroll_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetRollRangeResponse.maxRoll)
}

// -------------------------------------------------------------------

// SetRollRequest

// required float roll = 1;
inline bool SetRollRequest::has_roll() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetRollRequest::set_has_roll() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetRollRequest::clear_has_roll() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetRollRequest::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float SetRollRequest::roll() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetRollRequest.roll)
  return roll_;
}
inline void SetRollRequest::set_roll(float value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetRollRequest.roll)
}

// -------------------------------------------------------------------

// SetRollResponse

// required .AnselIpc.Status status = 1;
inline bool SetRollResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetRollResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetRollResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetRollResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status SetRollResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetRollResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void SetRollResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetRollResponse.status)
}

// -------------------------------------------------------------------

// UpdateRollRequest

// required float roll = 1;
inline bool UpdateRollRequest::has_roll() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateRollRequest::set_has_roll() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateRollRequest::clear_has_roll() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateRollRequest::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float UpdateRollRequest::roll() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UpdateRollRequest.roll)
  return roll_;
}
inline void UpdateRollRequest::set_roll(float value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UpdateRollRequest.roll)
}

// -------------------------------------------------------------------

// UpdateRollResponse

// required .AnselIpc.Status status = 1;
inline bool UpdateRollResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateRollResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateRollResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateRollResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status UpdateRollResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UpdateRollResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void UpdateRollResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UpdateRollResponse.status)
}

// -------------------------------------------------------------------

// UpdateFovRequest

// required float fov = 1;
inline bool UpdateFovRequest::has_fov() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateFovRequest::set_has_fov() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateFovRequest::clear_has_fov() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateFovRequest::clear_fov() {
  fov_ = 0;
  clear_has_fov();
}
inline float UpdateFovRequest::fov() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UpdateFovRequest.fov)
  return fov_;
}
inline void UpdateFovRequest::set_fov(float value) {
  set_has_fov();
  fov_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UpdateFovRequest.fov)
}

// -------------------------------------------------------------------

// UpdateFovResponse

// required .AnselIpc.Status status = 1;
inline bool UpdateFovResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateFovResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateFovResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateFovResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status UpdateFovResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.UpdateFovResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void UpdateFovResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.UpdateFovResponse.status)
}

// -------------------------------------------------------------------

// GetScreenResolutionRequest

// -------------------------------------------------------------------

// GetScreenResolutionResponse

// required .AnselIpc.Status status = 1;
inline bool GetScreenResolutionResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetScreenResolutionResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetScreenResolutionResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetScreenResolutionResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status GetScreenResolutionResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetScreenResolutionResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void GetScreenResolutionResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetScreenResolutionResponse.status)
}

// required int32 xResolution = 2;
inline bool GetScreenResolutionResponse::has_xresolution() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetScreenResolutionResponse::set_has_xresolution() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetScreenResolutionResponse::clear_has_xresolution() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetScreenResolutionResponse::clear_xresolution() {
  xresolution_ = 0;
  clear_has_xresolution();
}
inline ::google::protobuf::int32 GetScreenResolutionResponse::xresolution() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetScreenResolutionResponse.xResolution)
  return xresolution_;
}
inline void GetScreenResolutionResponse::set_xresolution(::google::protobuf::int32 value) {
  set_has_xresolution();
  xresolution_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetScreenResolutionResponse.xResolution)
}

// required int32 yResolution = 3;
inline bool GetScreenResolutionResponse::has_yresolution() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetScreenResolutionResponse::set_has_yresolution() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetScreenResolutionResponse::clear_has_yresolution() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetScreenResolutionResponse::clear_yresolution() {
  yresolution_ = 0;
  clear_has_yresolution();
}
inline ::google::protobuf::int32 GetScreenResolutionResponse::yresolution() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetScreenResolutionResponse.yResolution)
  return yresolution_;
}
inline void GetScreenResolutionResponse::set_yresolution(::google::protobuf::int32 value) {
  set_has_yresolution();
  yresolution_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetScreenResolutionResponse.yResolution)
}

// -------------------------------------------------------------------

// CaptureShotRequest

// required .AnselIpc.ShotTypeIPC type = 1;
inline bool CaptureShotRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CaptureShotRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CaptureShotRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CaptureShotRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::AnselIpc::ShotTypeIPC CaptureShotRequest::type() const {
  // @@protoc_insertion_point(field_get:AnselIpc.CaptureShotRequest.type)
  return static_cast< ::AnselIpc::ShotTypeIPC >(type_);
}
inline void CaptureShotRequest::set_type(::AnselIpc::ShotTypeIPC value) {
  assert(::AnselIpc::ShotTypeIPC_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.CaptureShotRequest.type)
}

// optional int32 highresMultiplier = 2;
inline bool CaptureShotRequest::has_highresmultiplier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CaptureShotRequest::set_has_highresmultiplier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CaptureShotRequest::clear_has_highresmultiplier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CaptureShotRequest::clear_highresmultiplier() {
  highresmultiplier_ = 0;
  clear_has_highresmultiplier();
}
inline ::google::protobuf::int32 CaptureShotRequest::highresmultiplier() const {
  // @@protoc_insertion_point(field_get:AnselIpc.CaptureShotRequest.highresMultiplier)
  return highresmultiplier_;
}
inline void CaptureShotRequest::set_highresmultiplier(::google::protobuf::int32 value) {
  set_has_highresmultiplier();
  highresmultiplier_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.CaptureShotRequest.highresMultiplier)
}

// optional int32 horizontal360Resolution = 3;
inline bool CaptureShotRequest::has_horizontal360resolution() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CaptureShotRequest::set_has_horizontal360resolution() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CaptureShotRequest::clear_has_horizontal360resolution() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CaptureShotRequest::clear_horizontal360resolution() {
  horizontal360resolution_ = 0;
  clear_has_horizontal360resolution();
}
inline ::google::protobuf::int32 CaptureShotRequest::horizontal360resolution() const {
  // @@protoc_insertion_point(field_get:AnselIpc.CaptureShotRequest.horizontal360Resolution)
  return horizontal360resolution_;
}
inline void CaptureShotRequest::set_horizontal360resolution(::google::protobuf::int32 value) {
  set_has_horizontal360resolution();
  horizontal360resolution_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.CaptureShotRequest.horizontal360Resolution)
}

// optional bool generateThumbnail = 4;
inline bool CaptureShotRequest::has_generatethumbnail() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CaptureShotRequest::set_has_generatethumbnail() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CaptureShotRequest::clear_has_generatethumbnail() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CaptureShotRequest::clear_generatethumbnail() {
  generatethumbnail_ = false;
  clear_has_generatethumbnail();
}
inline bool CaptureShotRequest::generatethumbnail() const {
  // @@protoc_insertion_point(field_get:AnselIpc.CaptureShotRequest.generateThumbnail)
  return generatethumbnail_;
}
inline void CaptureShotRequest::set_generatethumbnail(bool value) {
  set_has_generatethumbnail();
  generatethumbnail_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.CaptureShotRequest.generateThumbnail)
}

// optional bool isExr = 5;
inline bool CaptureShotRequest::has_isexr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CaptureShotRequest::set_has_isexr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CaptureShotRequest::clear_has_isexr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CaptureShotRequest::clear_isexr() {
  isexr_ = false;
  clear_has_isexr();
}
inline bool CaptureShotRequest::isexr() const {
  // @@protoc_insertion_point(field_get:AnselIpc.CaptureShotRequest.isExr)
  return isexr_;
}
inline void CaptureShotRequest::set_isexr(bool value) {
  set_has_isexr();
  isexr_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.CaptureShotRequest.isExr)
}

// optional bool highresEnhance = 6;
inline bool CaptureShotRequest::has_highresenhance() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CaptureShotRequest::set_has_highresenhance() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CaptureShotRequest::clear_has_highresenhance() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CaptureShotRequest::clear_highresenhance() {
  highresenhance_ = false;
  clear_has_highresenhance();
}
inline bool CaptureShotRequest::highresenhance() const {
  // @@protoc_insertion_point(field_get:AnselIpc.CaptureShotRequest.highresEnhance)
  return highresenhance_;
}
inline void CaptureShotRequest::set_highresenhance(bool value) {
  set_has_highresenhance();
  highresenhance_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.CaptureShotRequest.highresEnhance)
}

// optional bool isJxr = 7;
inline bool CaptureShotRequest::has_isjxr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CaptureShotRequest::set_has_isjxr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CaptureShotRequest::clear_has_isjxr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CaptureShotRequest::clear_isjxr() {
  isjxr_ = false;
  clear_has_isjxr();
}
inline bool CaptureShotRequest::isjxr() const {
  // @@protoc_insertion_point(field_get:AnselIpc.CaptureShotRequest.isJxr)
  return isjxr_;
}
inline void CaptureShotRequest::set_isjxr(bool value) {
  set_has_isjxr();
  isjxr_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.CaptureShotRequest.isJxr)
}

// -------------------------------------------------------------------

// CaptureShotStartedResponse

// required .AnselIpc.Status status = 1;
inline bool CaptureShotStartedResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CaptureShotStartedResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CaptureShotStartedResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CaptureShotStartedResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status CaptureShotStartedResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.CaptureShotStartedResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void CaptureShotStartedResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.CaptureShotStartedResponse.status)
}

// optional int32 totalShotCount = 3;
inline bool CaptureShotStartedResponse::has_totalshotcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CaptureShotStartedResponse::set_has_totalshotcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CaptureShotStartedResponse::clear_has_totalshotcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CaptureShotStartedResponse::clear_totalshotcount() {
  totalshotcount_ = 0;
  clear_has_totalshotcount();
}
inline ::google::protobuf::int32 CaptureShotStartedResponse::totalshotcount() const {
  // @@protoc_insertion_point(field_get:AnselIpc.CaptureShotStartedResponse.totalShotCount)
  return totalshotcount_;
}
inline void CaptureShotStartedResponse::set_totalshotcount(::google::protobuf::int32 value) {
  set_has_totalshotcount();
  totalshotcount_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.CaptureShotStartedResponse.totalShotCount)
}

// -------------------------------------------------------------------

// CaptureShotProgressResponse

// required int32 lwrrentShot = 1;
inline bool CaptureShotProgressResponse::has_lwrrentshot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CaptureShotProgressResponse::set_has_lwrrentshot() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CaptureShotProgressResponse::clear_has_lwrrentshot() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CaptureShotProgressResponse::clear_lwrrentshot() {
  lwrrentshot_ = 0;
  clear_has_lwrrentshot();
}
inline ::google::protobuf::int32 CaptureShotProgressResponse::lwrrentshot() const {
  // @@protoc_insertion_point(field_get:AnselIpc.CaptureShotProgressResponse.lwrrentShot)
  return lwrrentshot_;
}
inline void CaptureShotProgressResponse::set_lwrrentshot(::google::protobuf::int32 value) {
  set_has_lwrrentshot();
  lwrrentshot_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.CaptureShotProgressResponse.lwrrentShot)
}

// -------------------------------------------------------------------

// CaptureShotFinishedResponse

// required .AnselIpc.Status status = 1;
inline bool CaptureShotFinishedResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CaptureShotFinishedResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CaptureShotFinishedResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CaptureShotFinishedResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status CaptureShotFinishedResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.CaptureShotFinishedResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void CaptureShotFinishedResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.CaptureShotFinishedResponse.status)
}

// -------------------------------------------------------------------

// CaptureShotProcessingFinishedResponse

// required .AnselIpc.Status status = 1;
inline bool CaptureShotProcessingFinishedResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CaptureShotProcessingFinishedResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CaptureShotProcessingFinishedResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CaptureShotProcessingFinishedResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status CaptureShotProcessingFinishedResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.CaptureShotProcessingFinishedResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void CaptureShotProcessingFinishedResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.CaptureShotProcessingFinishedResponse.status)
}

// optional string absoluteFilePath = 2;
inline bool CaptureShotProcessingFinishedResponse::has_absolutefilepath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CaptureShotProcessingFinishedResponse::set_has_absolutefilepath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CaptureShotProcessingFinishedResponse::clear_has_absolutefilepath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CaptureShotProcessingFinishedResponse::clear_absolutefilepath() {
  if (absolutefilepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    absolutefilepath_->clear();
  }
  clear_has_absolutefilepath();
}
inline const ::std::string& CaptureShotProcessingFinishedResponse::absolutefilepath() const {
  // @@protoc_insertion_point(field_get:AnselIpc.CaptureShotProcessingFinishedResponse.absoluteFilePath)
  return *absolutefilepath_;
}
inline void CaptureShotProcessingFinishedResponse::set_absolutefilepath(const ::std::string& value) {
  set_has_absolutefilepath();
  if (absolutefilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    absolutefilepath_ = new ::std::string;
  }
  absolutefilepath_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.CaptureShotProcessingFinishedResponse.absoluteFilePath)
}
inline void CaptureShotProcessingFinishedResponse::set_absolutefilepath(const char* value) {
  set_has_absolutefilepath();
  if (absolutefilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    absolutefilepath_ = new ::std::string;
  }
  absolutefilepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.CaptureShotProcessingFinishedResponse.absoluteFilePath)
}
inline void CaptureShotProcessingFinishedResponse::set_absolutefilepath(const char* value, size_t size) {
  set_has_absolutefilepath();
  if (absolutefilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    absolutefilepath_ = new ::std::string;
  }
  absolutefilepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.CaptureShotProcessingFinishedResponse.absoluteFilePath)
}
inline ::std::string* CaptureShotProcessingFinishedResponse::mutable_absolutefilepath() {
  set_has_absolutefilepath();
  if (absolutefilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    absolutefilepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.CaptureShotProcessingFinishedResponse.absoluteFilePath)
  return absolutefilepath_;
}
inline ::std::string* CaptureShotProcessingFinishedResponse::release_absolutefilepath() {
  clear_has_absolutefilepath();
  if (absolutefilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = absolutefilepath_;
    absolutefilepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CaptureShotProcessingFinishedResponse::set_allocated_absolutefilepath(::std::string* absolutefilepath) {
  if (absolutefilepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete absolutefilepath_;
  }
  if (absolutefilepath) {
    set_has_absolutefilepath();
    absolutefilepath_ = absolutefilepath;
  } else {
    clear_has_absolutefilepath();
    absolutefilepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.CaptureShotProcessingFinishedResponse.absoluteFilePath)
}

// -------------------------------------------------------------------

// EstimateCaptureRequest

// required .AnselIpc.ShotTypeIPC type = 1;
inline bool EstimateCaptureRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EstimateCaptureRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EstimateCaptureRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EstimateCaptureRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::AnselIpc::ShotTypeIPC EstimateCaptureRequest::type() const {
  // @@protoc_insertion_point(field_get:AnselIpc.EstimateCaptureRequest.type)
  return static_cast< ::AnselIpc::ShotTypeIPC >(type_);
}
inline void EstimateCaptureRequest::set_type(::AnselIpc::ShotTypeIPC value) {
  assert(::AnselIpc::ShotTypeIPC_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.EstimateCaptureRequest.type)
}

// optional int32 highresMultiplier = 2;
inline bool EstimateCaptureRequest::has_highresmultiplier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EstimateCaptureRequest::set_has_highresmultiplier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EstimateCaptureRequest::clear_has_highresmultiplier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EstimateCaptureRequest::clear_highresmultiplier() {
  highresmultiplier_ = 0;
  clear_has_highresmultiplier();
}
inline ::google::protobuf::int32 EstimateCaptureRequest::highresmultiplier() const {
  // @@protoc_insertion_point(field_get:AnselIpc.EstimateCaptureRequest.highresMultiplier)
  return highresmultiplier_;
}
inline void EstimateCaptureRequest::set_highresmultiplier(::google::protobuf::int32 value) {
  set_has_highresmultiplier();
  highresmultiplier_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.EstimateCaptureRequest.highresMultiplier)
}

// optional int32 horizontal360Resolution = 3;
inline bool EstimateCaptureRequest::has_horizontal360resolution() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EstimateCaptureRequest::set_has_horizontal360resolution() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EstimateCaptureRequest::clear_has_horizontal360resolution() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EstimateCaptureRequest::clear_horizontal360resolution() {
  horizontal360resolution_ = 0;
  clear_has_horizontal360resolution();
}
inline ::google::protobuf::int32 EstimateCaptureRequest::horizontal360resolution() const {
  // @@protoc_insertion_point(field_get:AnselIpc.EstimateCaptureRequest.horizontal360Resolution)
  return horizontal360resolution_;
}
inline void EstimateCaptureRequest::set_horizontal360resolution(::google::protobuf::int32 value) {
  set_has_horizontal360resolution();
  horizontal360resolution_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.EstimateCaptureRequest.horizontal360Resolution)
}

// optional bool generateThumbnail = 4;
inline bool EstimateCaptureRequest::has_generatethumbnail() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EstimateCaptureRequest::set_has_generatethumbnail() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EstimateCaptureRequest::clear_has_generatethumbnail() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EstimateCaptureRequest::clear_generatethumbnail() {
  generatethumbnail_ = false;
  clear_has_generatethumbnail();
}
inline bool EstimateCaptureRequest::generatethumbnail() const {
  // @@protoc_insertion_point(field_get:AnselIpc.EstimateCaptureRequest.generateThumbnail)
  return generatethumbnail_;
}
inline void EstimateCaptureRequest::set_generatethumbnail(bool value) {
  set_has_generatethumbnail();
  generatethumbnail_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.EstimateCaptureRequest.generateThumbnail)
}

// optional bool isExr = 5;
inline bool EstimateCaptureRequest::has_isexr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EstimateCaptureRequest::set_has_isexr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EstimateCaptureRequest::clear_has_isexr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EstimateCaptureRequest::clear_isexr() {
  isexr_ = false;
  clear_has_isexr();
}
inline bool EstimateCaptureRequest::isexr() const {
  // @@protoc_insertion_point(field_get:AnselIpc.EstimateCaptureRequest.isExr)
  return isexr_;
}
inline void EstimateCaptureRequest::set_isexr(bool value) {
  set_has_isexr();
  isexr_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.EstimateCaptureRequest.isExr)
}

// optional bool highresEnhance = 6;
inline bool EstimateCaptureRequest::has_highresenhance() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EstimateCaptureRequest::set_has_highresenhance() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EstimateCaptureRequest::clear_has_highresenhance() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EstimateCaptureRequest::clear_highresenhance() {
  highresenhance_ = false;
  clear_has_highresenhance();
}
inline bool EstimateCaptureRequest::highresenhance() const {
  // @@protoc_insertion_point(field_get:AnselIpc.EstimateCaptureRequest.highresEnhance)
  return highresenhance_;
}
inline void EstimateCaptureRequest::set_highresenhance(bool value) {
  set_has_highresenhance();
  highresenhance_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.EstimateCaptureRequest.highresEnhance)
}

// -------------------------------------------------------------------

// EstimateCaptureResponse

// required uint64 inputDatasetSizeTotalInBytes = 1;
inline bool EstimateCaptureResponse::has_inputdatasetsizetotalinbytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EstimateCaptureResponse::set_has_inputdatasetsizetotalinbytes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EstimateCaptureResponse::clear_has_inputdatasetsizetotalinbytes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EstimateCaptureResponse::clear_inputdatasetsizetotalinbytes() {
  inputdatasetsizetotalinbytes_ = GOOGLE_ULONGLONG(0);
  clear_has_inputdatasetsizetotalinbytes();
}
inline ::google::protobuf::uint64 EstimateCaptureResponse::inputdatasetsizetotalinbytes() const {
  // @@protoc_insertion_point(field_get:AnselIpc.EstimateCaptureResponse.inputDatasetSizeTotalInBytes)
  return inputdatasetsizetotalinbytes_;
}
inline void EstimateCaptureResponse::set_inputdatasetsizetotalinbytes(::google::protobuf::uint64 value) {
  set_has_inputdatasetsizetotalinbytes();
  inputdatasetsizetotalinbytes_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.EstimateCaptureResponse.inputDatasetSizeTotalInBytes)
}

// required uint64 inputDatasetFrameCount = 2;
inline bool EstimateCaptureResponse::has_inputdatasetframecount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EstimateCaptureResponse::set_has_inputdatasetframecount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EstimateCaptureResponse::clear_has_inputdatasetframecount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EstimateCaptureResponse::clear_inputdatasetframecount() {
  inputdatasetframecount_ = GOOGLE_ULONGLONG(0);
  clear_has_inputdatasetframecount();
}
inline ::google::protobuf::uint64 EstimateCaptureResponse::inputdatasetframecount() const {
  // @@protoc_insertion_point(field_get:AnselIpc.EstimateCaptureResponse.inputDatasetFrameCount)
  return inputdatasetframecount_;
}
inline void EstimateCaptureResponse::set_inputdatasetframecount(::google::protobuf::uint64 value) {
  set_has_inputdatasetframecount();
  inputdatasetframecount_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.EstimateCaptureResponse.inputDatasetFrameCount)
}

// required uint64 inputDatasetFrameSizeInBytes = 3;
inline bool EstimateCaptureResponse::has_inputdatasetframesizeinbytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EstimateCaptureResponse::set_has_inputdatasetframesizeinbytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EstimateCaptureResponse::clear_has_inputdatasetframesizeinbytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EstimateCaptureResponse::clear_inputdatasetframesizeinbytes() {
  inputdatasetframesizeinbytes_ = GOOGLE_ULONGLONG(0);
  clear_has_inputdatasetframesizeinbytes();
}
inline ::google::protobuf::uint64 EstimateCaptureResponse::inputdatasetframesizeinbytes() const {
  // @@protoc_insertion_point(field_get:AnselIpc.EstimateCaptureResponse.inputDatasetFrameSizeInBytes)
  return inputdatasetframesizeinbytes_;
}
inline void EstimateCaptureResponse::set_inputdatasetframesizeinbytes(::google::protobuf::uint64 value) {
  set_has_inputdatasetframesizeinbytes();
  inputdatasetframesizeinbytes_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.EstimateCaptureResponse.inputDatasetFrameSizeInBytes)
}

// required uint64 stitcherMemoryRequirementsInBytes = 4;
inline bool EstimateCaptureResponse::has_stitchermemoryrequirementsinbytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EstimateCaptureResponse::set_has_stitchermemoryrequirementsinbytes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EstimateCaptureResponse::clear_has_stitchermemoryrequirementsinbytes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EstimateCaptureResponse::clear_stitchermemoryrequirementsinbytes() {
  stitchermemoryrequirementsinbytes_ = GOOGLE_ULONGLONG(0);
  clear_has_stitchermemoryrequirementsinbytes();
}
inline ::google::protobuf::uint64 EstimateCaptureResponse::stitchermemoryrequirementsinbytes() const {
  // @@protoc_insertion_point(field_get:AnselIpc.EstimateCaptureResponse.stitcherMemoryRequirementsInBytes)
  return stitchermemoryrequirementsinbytes_;
}
inline void EstimateCaptureResponse::set_stitchermemoryrequirementsinbytes(::google::protobuf::uint64 value) {
  set_has_stitchermemoryrequirementsinbytes();
  stitchermemoryrequirementsinbytes_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.EstimateCaptureResponse.stitcherMemoryRequirementsInBytes)
}

// required uint64 outputResolutionX = 5;
inline bool EstimateCaptureResponse::has_outputresolutionx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EstimateCaptureResponse::set_has_outputresolutionx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EstimateCaptureResponse::clear_has_outputresolutionx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EstimateCaptureResponse::clear_outputresolutionx() {
  outputresolutionx_ = GOOGLE_ULONGLONG(0);
  clear_has_outputresolutionx();
}
inline ::google::protobuf::uint64 EstimateCaptureResponse::outputresolutionx() const {
  // @@protoc_insertion_point(field_get:AnselIpc.EstimateCaptureResponse.outputResolutionX)
  return outputresolutionx_;
}
inline void EstimateCaptureResponse::set_outputresolutionx(::google::protobuf::uint64 value) {
  set_has_outputresolutionx();
  outputresolutionx_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.EstimateCaptureResponse.outputResolutionX)
}

// required uint64 outputResolutionY = 6;
inline bool EstimateCaptureResponse::has_outputresolutiony() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EstimateCaptureResponse::set_has_outputresolutiony() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EstimateCaptureResponse::clear_has_outputresolutiony() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EstimateCaptureResponse::clear_outputresolutiony() {
  outputresolutiony_ = GOOGLE_ULONGLONG(0);
  clear_has_outputresolutiony();
}
inline ::google::protobuf::uint64 EstimateCaptureResponse::outputresolutiony() const {
  // @@protoc_insertion_point(field_get:AnselIpc.EstimateCaptureResponse.outputResolutionY)
  return outputresolutiony_;
}
inline void EstimateCaptureResponse::set_outputresolutiony(::google::protobuf::uint64 value) {
  set_has_outputresolutiony();
  outputresolutiony_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.EstimateCaptureResponse.outputResolutionY)
}

// required uint64 outputMPixels = 7;
inline bool EstimateCaptureResponse::has_outputmpixels() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EstimateCaptureResponse::set_has_outputmpixels() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EstimateCaptureResponse::clear_has_outputmpixels() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EstimateCaptureResponse::clear_outputmpixels() {
  outputmpixels_ = GOOGLE_ULONGLONG(0);
  clear_has_outputmpixels();
}
inline ::google::protobuf::uint64 EstimateCaptureResponse::outputmpixels() const {
  // @@protoc_insertion_point(field_get:AnselIpc.EstimateCaptureResponse.outputMPixels)
  return outputmpixels_;
}
inline void EstimateCaptureResponse::set_outputmpixels(::google::protobuf::uint64 value) {
  set_has_outputmpixels();
  outputmpixels_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.EstimateCaptureResponse.outputMPixels)
}

// required uint64 outputSizeInBytes = 8;
inline bool EstimateCaptureResponse::has_outputsizeinbytes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EstimateCaptureResponse::set_has_outputsizeinbytes() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EstimateCaptureResponse::clear_has_outputsizeinbytes() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EstimateCaptureResponse::clear_outputsizeinbytes() {
  outputsizeinbytes_ = GOOGLE_ULONGLONG(0);
  clear_has_outputsizeinbytes();
}
inline ::google::protobuf::uint64 EstimateCaptureResponse::outputsizeinbytes() const {
  // @@protoc_insertion_point(field_get:AnselIpc.EstimateCaptureResponse.outputSizeInBytes)
  return outputsizeinbytes_;
}
inline void EstimateCaptureResponse::set_outputsizeinbytes(::google::protobuf::uint64 value) {
  set_has_outputsizeinbytes();
  outputsizeinbytes_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.EstimateCaptureResponse.outputSizeInBytes)
}

// -------------------------------------------------------------------

// AbortCaptureRequest

// -------------------------------------------------------------------

// AbortCaptureResponse

// required .AnselIpc.Status status = 1;
inline bool AbortCaptureResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AbortCaptureResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AbortCaptureResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AbortCaptureResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status AbortCaptureResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.AbortCaptureResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void AbortCaptureResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.AbortCaptureResponse.status)
}

// -------------------------------------------------------------------

// GetHighresResolutionListRequest

// -------------------------------------------------------------------

// GetHighresResolutionListResponse_HighresResolution

// required int32 multiplier = 1;
inline bool GetHighresResolutionListResponse_HighresResolution::has_multiplier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetHighresResolutionListResponse_HighresResolution::set_has_multiplier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetHighresResolutionListResponse_HighresResolution::clear_has_multiplier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetHighresResolutionListResponse_HighresResolution::clear_multiplier() {
  multiplier_ = 0;
  clear_has_multiplier();
}
inline ::google::protobuf::int32 GetHighresResolutionListResponse_HighresResolution::multiplier() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetHighresResolutionListResponse.HighresResolution.multiplier)
  return multiplier_;
}
inline void GetHighresResolutionListResponse_HighresResolution::set_multiplier(::google::protobuf::int32 value) {
  set_has_multiplier();
  multiplier_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetHighresResolutionListResponse.HighresResolution.multiplier)
}

// required int32 xResolution = 2;
inline bool GetHighresResolutionListResponse_HighresResolution::has_xresolution() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetHighresResolutionListResponse_HighresResolution::set_has_xresolution() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetHighresResolutionListResponse_HighresResolution::clear_has_xresolution() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetHighresResolutionListResponse_HighresResolution::clear_xresolution() {
  xresolution_ = 0;
  clear_has_xresolution();
}
inline ::google::protobuf::int32 GetHighresResolutionListResponse_HighresResolution::xresolution() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetHighresResolutionListResponse.HighresResolution.xResolution)
  return xresolution_;
}
inline void GetHighresResolutionListResponse_HighresResolution::set_xresolution(::google::protobuf::int32 value) {
  set_has_xresolution();
  xresolution_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetHighresResolutionListResponse.HighresResolution.xResolution)
}

// required int32 yResolution = 3;
inline bool GetHighresResolutionListResponse_HighresResolution::has_yresolution() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetHighresResolutionListResponse_HighresResolution::set_has_yresolution() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetHighresResolutionListResponse_HighresResolution::clear_has_yresolution() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetHighresResolutionListResponse_HighresResolution::clear_yresolution() {
  yresolution_ = 0;
  clear_has_yresolution();
}
inline ::google::protobuf::int32 GetHighresResolutionListResponse_HighresResolution::yresolution() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetHighresResolutionListResponse.HighresResolution.yResolution)
  return yresolution_;
}
inline void GetHighresResolutionListResponse_HighresResolution::set_yresolution(::google::protobuf::int32 value) {
  set_has_yresolution();
  yresolution_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetHighresResolutionListResponse.HighresResolution.yResolution)
}

// -------------------------------------------------------------------

// GetHighresResolutionListResponse

// repeated .AnselIpc.GetHighresResolutionListResponse.HighresResolution resolutions = 1;
inline int GetHighresResolutionListResponse::resolutions_size() const {
  return resolutions_.size();
}
inline void GetHighresResolutionListResponse::clear_resolutions() {
  resolutions_.Clear();
}
inline const ::AnselIpc::GetHighresResolutionListResponse_HighresResolution& GetHighresResolutionListResponse::resolutions(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetHighresResolutionListResponse.resolutions)
  return resolutions_.Get(index);
}
inline ::AnselIpc::GetHighresResolutionListResponse_HighresResolution* GetHighresResolutionListResponse::mutable_resolutions(int index) {
  // @@protoc_insertion_point(field_mutable:AnselIpc.GetHighresResolutionListResponse.resolutions)
  return resolutions_.Mutable(index);
}
inline ::AnselIpc::GetHighresResolutionListResponse_HighresResolution* GetHighresResolutionListResponse::add_resolutions() {
  // @@protoc_insertion_point(field_add:AnselIpc.GetHighresResolutionListResponse.resolutions)
  return resolutions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::GetHighresResolutionListResponse_HighresResolution >&
GetHighresResolutionListResponse::resolutions() const {
  // @@protoc_insertion_point(field_list:AnselIpc.GetHighresResolutionListResponse.resolutions)
  return resolutions_;
}
inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::GetHighresResolutionListResponse_HighresResolution >*
GetHighresResolutionListResponse::mutable_resolutions() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.GetHighresResolutionListResponse.resolutions)
  return &resolutions_;
}

// -------------------------------------------------------------------

// Get360ResolutionRangeRequest

// -------------------------------------------------------------------

// Get360ResolutionRangeResponse

// required int32 minimumXResolution = 3;
inline bool Get360ResolutionRangeResponse::has_minimumxresolution() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Get360ResolutionRangeResponse::set_has_minimumxresolution() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Get360ResolutionRangeResponse::clear_has_minimumxresolution() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Get360ResolutionRangeResponse::clear_minimumxresolution() {
  minimumxresolution_ = 0;
  clear_has_minimumxresolution();
}
inline ::google::protobuf::int32 Get360ResolutionRangeResponse::minimumxresolution() const {
  // @@protoc_insertion_point(field_get:AnselIpc.Get360ResolutionRangeResponse.minimumXResolution)
  return minimumxresolution_;
}
inline void Get360ResolutionRangeResponse::set_minimumxresolution(::google::protobuf::int32 value) {
  set_has_minimumxresolution();
  minimumxresolution_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.Get360ResolutionRangeResponse.minimumXResolution)
}

// required int32 maximumXResolution = 4;
inline bool Get360ResolutionRangeResponse::has_maximumxresolution() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Get360ResolutionRangeResponse::set_has_maximumxresolution() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Get360ResolutionRangeResponse::clear_has_maximumxresolution() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Get360ResolutionRangeResponse::clear_maximumxresolution() {
  maximumxresolution_ = 0;
  clear_has_maximumxresolution();
}
inline ::google::protobuf::int32 Get360ResolutionRangeResponse::maximumxresolution() const {
  // @@protoc_insertion_point(field_get:AnselIpc.Get360ResolutionRangeResponse.maximumXResolution)
  return maximumxresolution_;
}
inline void Get360ResolutionRangeResponse::set_maximumxresolution(::google::protobuf::int32 value) {
  set_has_maximumxresolution();
  maximumxresolution_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.Get360ResolutionRangeResponse.maximumXResolution)
}

// -------------------------------------------------------------------

// GetFilterListRequest

// -------------------------------------------------------------------

// GetFilterListResponse

// repeated string filterIdList = 1;
inline int GetFilterListResponse::filteridlist_size() const {
  return filteridlist_.size();
}
inline void GetFilterListResponse::clear_filteridlist() {
  filteridlist_.Clear();
}
inline const ::std::string& GetFilterListResponse::filteridlist(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetFilterListResponse.filterIdList)
  return filteridlist_.Get(index);
}
inline ::std::string* GetFilterListResponse::mutable_filteridlist(int index) {
  // @@protoc_insertion_point(field_mutable:AnselIpc.GetFilterListResponse.filterIdList)
  return filteridlist_.Mutable(index);
}
inline void GetFilterListResponse::set_filteridlist(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:AnselIpc.GetFilterListResponse.filterIdList)
  filteridlist_.Mutable(index)->assign(value);
}
inline void GetFilterListResponse::set_filteridlist(int index, const char* value) {
  filteridlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.GetFilterListResponse.filterIdList)
}
inline void GetFilterListResponse::set_filteridlist(int index, const char* value, size_t size) {
  filteridlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.GetFilterListResponse.filterIdList)
}
inline ::std::string* GetFilterListResponse::add_filteridlist() {
  return filteridlist_.Add();
}
inline void GetFilterListResponse::add_filteridlist(const ::std::string& value) {
  filteridlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:AnselIpc.GetFilterListResponse.filterIdList)
}
inline void GetFilterListResponse::add_filteridlist(const char* value) {
  filteridlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:AnselIpc.GetFilterListResponse.filterIdList)
}
inline void GetFilterListResponse::add_filteridlist(const char* value, size_t size) {
  filteridlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:AnselIpc.GetFilterListResponse.filterIdList)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetFilterListResponse::filteridlist() const {
  // @@protoc_insertion_point(field_list:AnselIpc.GetFilterListResponse.filterIdList)
  return filteridlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetFilterListResponse::mutable_filteridlist() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.GetFilterListResponse.filterIdList)
  return &filteridlist_;
}

// repeated string filterNameList = 2;
inline int GetFilterListResponse::filternamelist_size() const {
  return filternamelist_.size();
}
inline void GetFilterListResponse::clear_filternamelist() {
  filternamelist_.Clear();
}
inline const ::std::string& GetFilterListResponse::filternamelist(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetFilterListResponse.filterNameList)
  return filternamelist_.Get(index);
}
inline ::std::string* GetFilterListResponse::mutable_filternamelist(int index) {
  // @@protoc_insertion_point(field_mutable:AnselIpc.GetFilterListResponse.filterNameList)
  return filternamelist_.Mutable(index);
}
inline void GetFilterListResponse::set_filternamelist(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:AnselIpc.GetFilterListResponse.filterNameList)
  filternamelist_.Mutable(index)->assign(value);
}
inline void GetFilterListResponse::set_filternamelist(int index, const char* value) {
  filternamelist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.GetFilterListResponse.filterNameList)
}
inline void GetFilterListResponse::set_filternamelist(int index, const char* value, size_t size) {
  filternamelist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.GetFilterListResponse.filterNameList)
}
inline ::std::string* GetFilterListResponse::add_filternamelist() {
  return filternamelist_.Add();
}
inline void GetFilterListResponse::add_filternamelist(const ::std::string& value) {
  filternamelist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:AnselIpc.GetFilterListResponse.filterNameList)
}
inline void GetFilterListResponse::add_filternamelist(const char* value) {
  filternamelist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:AnselIpc.GetFilterListResponse.filterNameList)
}
inline void GetFilterListResponse::add_filternamelist(const char* value, size_t size) {
  filternamelist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:AnselIpc.GetFilterListResponse.filterNameList)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetFilterListResponse::filternamelist() const {
  // @@protoc_insertion_point(field_list:AnselIpc.GetFilterListResponse.filterNameList)
  return filternamelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetFilterListResponse::mutable_filternamelist() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.GetFilterListResponse.filterNameList)
  return &filternamelist_;
}

// -------------------------------------------------------------------

// ResetEntireStackRequest

// -------------------------------------------------------------------

// ResetEntireStackResponse

// required .AnselIpc.Status status = 1;
inline bool ResetEntireStackResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResetEntireStackResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResetEntireStackResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResetEntireStackResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status ResetEntireStackResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.ResetEntireStackResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void ResetEntireStackResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.ResetEntireStackResponse.status)
}

// -------------------------------------------------------------------

// ResetFilterValuesRequest

// required int32 stackIdx = 1;
inline bool ResetFilterValuesRequest::has_stackidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResetFilterValuesRequest::set_has_stackidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResetFilterValuesRequest::clear_has_stackidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResetFilterValuesRequest::clear_stackidx() {
  stackidx_ = 0;
  clear_has_stackidx();
}
inline ::google::protobuf::int32 ResetFilterValuesRequest::stackidx() const {
  // @@protoc_insertion_point(field_get:AnselIpc.ResetFilterValuesRequest.stackIdx)
  return stackidx_;
}
inline void ResetFilterValuesRequest::set_stackidx(::google::protobuf::int32 value) {
  set_has_stackidx();
  stackidx_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.ResetFilterValuesRequest.stackIdx)
}

// -------------------------------------------------------------------

// ResetFilterValuesResponse

// required int32 stackIdx = 1;
inline bool ResetFilterValuesResponse::has_stackidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResetFilterValuesResponse::set_has_stackidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResetFilterValuesResponse::clear_has_stackidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResetFilterValuesResponse::clear_stackidx() {
  stackidx_ = 0;
  clear_has_stackidx();
}
inline ::google::protobuf::int32 ResetFilterValuesResponse::stackidx() const {
  // @@protoc_insertion_point(field_get:AnselIpc.ResetFilterValuesResponse.stackIdx)
  return stackidx_;
}
inline void ResetFilterValuesResponse::set_stackidx(::google::protobuf::int32 value) {
  set_has_stackidx();
  stackidx_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.ResetFilterValuesResponse.stackIdx)
}

// required .AnselIpc.Status status = 2;
inline bool ResetFilterValuesResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResetFilterValuesResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResetFilterValuesResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResetFilterValuesResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status ResetFilterValuesResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.ResetFilterValuesResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void ResetFilterValuesResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.ResetFilterValuesResponse.status)
}

// -------------------------------------------------------------------

// ResetAllFilterValuesRequest

// -------------------------------------------------------------------

// SetFilterRequest

// required string filterId = 1;
inline bool SetFilterRequest::has_filterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetFilterRequest::set_has_filterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetFilterRequest::clear_has_filterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetFilterRequest::clear_filterid() {
  if (filterid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_->clear();
  }
  clear_has_filterid();
}
inline const ::std::string& SetFilterRequest::filterid() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterRequest.filterId)
  return *filterid_;
}
inline void SetFilterRequest::set_filterid(const ::std::string& value) {
  set_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_ = new ::std::string;
  }
  filterid_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterRequest.filterId)
}
inline void SetFilterRequest::set_filterid(const char* value) {
  set_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_ = new ::std::string;
  }
  filterid_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.SetFilterRequest.filterId)
}
inline void SetFilterRequest::set_filterid(const char* value, size_t size) {
  set_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_ = new ::std::string;
  }
  filterid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.SetFilterRequest.filterId)
}
inline ::std::string* SetFilterRequest::mutable_filterid() {
  set_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.SetFilterRequest.filterId)
  return filterid_;
}
inline ::std::string* SetFilterRequest::release_filterid() {
  clear_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filterid_;
    filterid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetFilterRequest::set_allocated_filterid(::std::string* filterid) {
  if (filterid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filterid_;
  }
  if (filterid) {
    set_has_filterid();
    filterid_ = filterid;
  } else {
    clear_has_filterid();
    filterid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.SetFilterRequest.filterId)
}

// required int32 stackIdx = 2;
inline bool SetFilterRequest::has_stackidx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetFilterRequest::set_has_stackidx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetFilterRequest::clear_has_stackidx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetFilterRequest::clear_stackidx() {
  stackidx_ = 0;
  clear_has_stackidx();
}
inline ::google::protobuf::int32 SetFilterRequest::stackidx() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterRequest.stackIdx)
  return stackidx_;
}
inline void SetFilterRequest::set_stackidx(::google::protobuf::int32 value) {
  set_has_stackidx();
  stackidx_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterRequest.stackIdx)
}

// -------------------------------------------------------------------

// SetFilterResponse

// required .AnselIpc.Status status = 1;
inline bool SetFilterResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetFilterResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetFilterResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetFilterResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status SetFilterResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void SetFilterResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterResponse.status)
}

// required int32 stackIdx = 2;
inline bool SetFilterResponse::has_stackidx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetFilterResponse::set_has_stackidx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetFilterResponse::clear_has_stackidx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetFilterResponse::clear_stackidx() {
  stackidx_ = 0;
  clear_has_stackidx();
}
inline ::google::protobuf::int32 SetFilterResponse::stackidx() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterResponse.stackIdx)
  return stackidx_;
}
inline void SetFilterResponse::set_stackidx(::google::protobuf::int32 value) {
  set_has_stackidx();
  stackidx_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterResponse.stackIdx)
}

// optional .AnselIpc.FilterProperties filterProperties = 3;
inline bool SetFilterResponse::has_filterproperties() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetFilterResponse::set_has_filterproperties() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetFilterResponse::clear_has_filterproperties() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetFilterResponse::clear_filterproperties() {
  if (filterproperties_ != NULL) filterproperties_->::AnselIpc::FilterProperties::Clear();
  clear_has_filterproperties();
}
inline const ::AnselIpc::FilterProperties& SetFilterResponse::filterproperties() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterResponse.filterProperties)
  return filterproperties_ != NULL ? *filterproperties_ : *default_instance_->filterproperties_;
}
inline ::AnselIpc::FilterProperties* SetFilterResponse::mutable_filterproperties() {
  set_has_filterproperties();
  if (filterproperties_ == NULL) filterproperties_ = new ::AnselIpc::FilterProperties;
  // @@protoc_insertion_point(field_mutable:AnselIpc.SetFilterResponse.filterProperties)
  return filterproperties_;
}
inline ::AnselIpc::FilterProperties* SetFilterResponse::release_filterproperties() {
  clear_has_filterproperties();
  ::AnselIpc::FilterProperties* temp = filterproperties_;
  filterproperties_ = NULL;
  return temp;
}
inline void SetFilterResponse::set_allocated_filterproperties(::AnselIpc::FilterProperties* filterproperties) {
  delete filterproperties_;
  filterproperties_ = filterproperties;
  if (filterproperties) {
    set_has_filterproperties();
  } else {
    clear_has_filterproperties();
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.SetFilterResponse.filterProperties)
}

// -------------------------------------------------------------------

// SetFilterAndAttributesRequest

// required string filterId = 1;
inline bool SetFilterAndAttributesRequest::has_filterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetFilterAndAttributesRequest::set_has_filterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetFilterAndAttributesRequest::clear_has_filterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetFilterAndAttributesRequest::clear_filterid() {
  if (filterid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_->clear();
  }
  clear_has_filterid();
}
inline const ::std::string& SetFilterAndAttributesRequest::filterid() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterAndAttributesRequest.filterId)
  return *filterid_;
}
inline void SetFilterAndAttributesRequest::set_filterid(const ::std::string& value) {
  set_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_ = new ::std::string;
  }
  filterid_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterAndAttributesRequest.filterId)
}
inline void SetFilterAndAttributesRequest::set_filterid(const char* value) {
  set_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_ = new ::std::string;
  }
  filterid_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.SetFilterAndAttributesRequest.filterId)
}
inline void SetFilterAndAttributesRequest::set_filterid(const char* value, size_t size) {
  set_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_ = new ::std::string;
  }
  filterid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.SetFilterAndAttributesRequest.filterId)
}
inline ::std::string* SetFilterAndAttributesRequest::mutable_filterid() {
  set_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.SetFilterAndAttributesRequest.filterId)
  return filterid_;
}
inline ::std::string* SetFilterAndAttributesRequest::release_filterid() {
  clear_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filterid_;
    filterid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetFilterAndAttributesRequest::set_allocated_filterid(::std::string* filterid) {
  if (filterid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filterid_;
  }
  if (filterid) {
    set_has_filterid();
    filterid_ = filterid;
  } else {
    clear_has_filterid();
    filterid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.SetFilterAndAttributesRequest.filterId)
}

// required int32 stackIdx = 2;
inline bool SetFilterAndAttributesRequest::has_stackidx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetFilterAndAttributesRequest::set_has_stackidx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetFilterAndAttributesRequest::clear_has_stackidx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetFilterAndAttributesRequest::clear_stackidx() {
  stackidx_ = 0;
  clear_has_stackidx();
}
inline ::google::protobuf::int32 SetFilterAndAttributesRequest::stackidx() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterAndAttributesRequest.stackIdx)
  return stackidx_;
}
inline void SetFilterAndAttributesRequest::set_stackidx(::google::protobuf::int32 value) {
  set_has_stackidx();
  stackidx_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterAndAttributesRequest.stackIdx)
}

// repeated int32 intControlIds = 3;
inline int SetFilterAndAttributesRequest::intcontrolids_size() const {
  return intcontrolids_.size();
}
inline void SetFilterAndAttributesRequest::clear_intcontrolids() {
  intcontrolids_.Clear();
}
inline ::google::protobuf::int32 SetFilterAndAttributesRequest::intcontrolids(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterAndAttributesRequest.intControlIds)
  return intcontrolids_.Get(index);
}
inline void SetFilterAndAttributesRequest::set_intcontrolids(int index, ::google::protobuf::int32 value) {
  intcontrolids_.Set(index, value);
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterAndAttributesRequest.intControlIds)
}
inline void SetFilterAndAttributesRequest::add_intcontrolids(::google::protobuf::int32 value) {
  intcontrolids_.Add(value);
  // @@protoc_insertion_point(field_add:AnselIpc.SetFilterAndAttributesRequest.intControlIds)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SetFilterAndAttributesRequest::intcontrolids() const {
  // @@protoc_insertion_point(field_list:AnselIpc.SetFilterAndAttributesRequest.intControlIds)
  return intcontrolids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SetFilterAndAttributesRequest::mutable_intcontrolids() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.SetFilterAndAttributesRequest.intControlIds)
  return &intcontrolids_;
}

// repeated int32 intValues = 4;
inline int SetFilterAndAttributesRequest::intvalues_size() const {
  return intvalues_.size();
}
inline void SetFilterAndAttributesRequest::clear_intvalues() {
  intvalues_.Clear();
}
inline ::google::protobuf::int32 SetFilterAndAttributesRequest::intvalues(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterAndAttributesRequest.intValues)
  return intvalues_.Get(index);
}
inline void SetFilterAndAttributesRequest::set_intvalues(int index, ::google::protobuf::int32 value) {
  intvalues_.Set(index, value);
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterAndAttributesRequest.intValues)
}
inline void SetFilterAndAttributesRequest::add_intvalues(::google::protobuf::int32 value) {
  intvalues_.Add(value);
  // @@protoc_insertion_point(field_add:AnselIpc.SetFilterAndAttributesRequest.intValues)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SetFilterAndAttributesRequest::intvalues() const {
  // @@protoc_insertion_point(field_list:AnselIpc.SetFilterAndAttributesRequest.intValues)
  return intvalues_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SetFilterAndAttributesRequest::mutable_intvalues() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.SetFilterAndAttributesRequest.intValues)
  return &intvalues_;
}

// repeated int32 uintControlIds = 5;
inline int SetFilterAndAttributesRequest::uintcontrolids_size() const {
  return uintcontrolids_.size();
}
inline void SetFilterAndAttributesRequest::clear_uintcontrolids() {
  uintcontrolids_.Clear();
}
inline ::google::protobuf::int32 SetFilterAndAttributesRequest::uintcontrolids(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterAndAttributesRequest.uintControlIds)
  return uintcontrolids_.Get(index);
}
inline void SetFilterAndAttributesRequest::set_uintcontrolids(int index, ::google::protobuf::int32 value) {
  uintcontrolids_.Set(index, value);
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterAndAttributesRequest.uintControlIds)
}
inline void SetFilterAndAttributesRequest::add_uintcontrolids(::google::protobuf::int32 value) {
  uintcontrolids_.Add(value);
  // @@protoc_insertion_point(field_add:AnselIpc.SetFilterAndAttributesRequest.uintControlIds)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SetFilterAndAttributesRequest::uintcontrolids() const {
  // @@protoc_insertion_point(field_list:AnselIpc.SetFilterAndAttributesRequest.uintControlIds)
  return uintcontrolids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SetFilterAndAttributesRequest::mutable_uintcontrolids() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.SetFilterAndAttributesRequest.uintControlIds)
  return &uintcontrolids_;
}

// repeated uint32 uintValues = 6;
inline int SetFilterAndAttributesRequest::uintvalues_size() const {
  return uintvalues_.size();
}
inline void SetFilterAndAttributesRequest::clear_uintvalues() {
  uintvalues_.Clear();
}
inline ::google::protobuf::uint32 SetFilterAndAttributesRequest::uintvalues(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterAndAttributesRequest.uintValues)
  return uintvalues_.Get(index);
}
inline void SetFilterAndAttributesRequest::set_uintvalues(int index, ::google::protobuf::uint32 value) {
  uintvalues_.Set(index, value);
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterAndAttributesRequest.uintValues)
}
inline void SetFilterAndAttributesRequest::add_uintvalues(::google::protobuf::uint32 value) {
  uintvalues_.Add(value);
  // @@protoc_insertion_point(field_add:AnselIpc.SetFilterAndAttributesRequest.uintValues)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SetFilterAndAttributesRequest::uintvalues() const {
  // @@protoc_insertion_point(field_list:AnselIpc.SetFilterAndAttributesRequest.uintValues)
  return uintvalues_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SetFilterAndAttributesRequest::mutable_uintvalues() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.SetFilterAndAttributesRequest.uintValues)
  return &uintvalues_;
}

// repeated int32 floatControlIds = 7;
inline int SetFilterAndAttributesRequest::floatcontrolids_size() const {
  return floatcontrolids_.size();
}
inline void SetFilterAndAttributesRequest::clear_floatcontrolids() {
  floatcontrolids_.Clear();
}
inline ::google::protobuf::int32 SetFilterAndAttributesRequest::floatcontrolids(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterAndAttributesRequest.floatControlIds)
  return floatcontrolids_.Get(index);
}
inline void SetFilterAndAttributesRequest::set_floatcontrolids(int index, ::google::protobuf::int32 value) {
  floatcontrolids_.Set(index, value);
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterAndAttributesRequest.floatControlIds)
}
inline void SetFilterAndAttributesRequest::add_floatcontrolids(::google::protobuf::int32 value) {
  floatcontrolids_.Add(value);
  // @@protoc_insertion_point(field_add:AnselIpc.SetFilterAndAttributesRequest.floatControlIds)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SetFilterAndAttributesRequest::floatcontrolids() const {
  // @@protoc_insertion_point(field_list:AnselIpc.SetFilterAndAttributesRequest.floatControlIds)
  return floatcontrolids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SetFilterAndAttributesRequest::mutable_floatcontrolids() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.SetFilterAndAttributesRequest.floatControlIds)
  return &floatcontrolids_;
}

// repeated float floatValues = 8;
inline int SetFilterAndAttributesRequest::floatvalues_size() const {
  return floatvalues_.size();
}
inline void SetFilterAndAttributesRequest::clear_floatvalues() {
  floatvalues_.Clear();
}
inline float SetFilterAndAttributesRequest::floatvalues(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterAndAttributesRequest.floatValues)
  return floatvalues_.Get(index);
}
inline void SetFilterAndAttributesRequest::set_floatvalues(int index, float value) {
  floatvalues_.Set(index, value);
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterAndAttributesRequest.floatValues)
}
inline void SetFilterAndAttributesRequest::add_floatvalues(float value) {
  floatvalues_.Add(value);
  // @@protoc_insertion_point(field_add:AnselIpc.SetFilterAndAttributesRequest.floatValues)
}
inline const ::google::protobuf::RepeatedField< float >&
SetFilterAndAttributesRequest::floatvalues() const {
  // @@protoc_insertion_point(field_list:AnselIpc.SetFilterAndAttributesRequest.floatValues)
  return floatvalues_;
}
inline ::google::protobuf::RepeatedField< float >*
SetFilterAndAttributesRequest::mutable_floatvalues() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.SetFilterAndAttributesRequest.floatValues)
  return &floatvalues_;
}

// repeated int32 boolControlIds = 9;
inline int SetFilterAndAttributesRequest::boolcontrolids_size() const {
  return boolcontrolids_.size();
}
inline void SetFilterAndAttributesRequest::clear_boolcontrolids() {
  boolcontrolids_.Clear();
}
inline ::google::protobuf::int32 SetFilterAndAttributesRequest::boolcontrolids(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterAndAttributesRequest.boolControlIds)
  return boolcontrolids_.Get(index);
}
inline void SetFilterAndAttributesRequest::set_boolcontrolids(int index, ::google::protobuf::int32 value) {
  boolcontrolids_.Set(index, value);
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterAndAttributesRequest.boolControlIds)
}
inline void SetFilterAndAttributesRequest::add_boolcontrolids(::google::protobuf::int32 value) {
  boolcontrolids_.Add(value);
  // @@protoc_insertion_point(field_add:AnselIpc.SetFilterAndAttributesRequest.boolControlIds)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SetFilterAndAttributesRequest::boolcontrolids() const {
  // @@protoc_insertion_point(field_list:AnselIpc.SetFilterAndAttributesRequest.boolControlIds)
  return boolcontrolids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SetFilterAndAttributesRequest::mutable_boolcontrolids() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.SetFilterAndAttributesRequest.boolControlIds)
  return &boolcontrolids_;
}

// repeated bool boolValues = 10;
inline int SetFilterAndAttributesRequest::boolvalues_size() const {
  return boolvalues_.size();
}
inline void SetFilterAndAttributesRequest::clear_boolvalues() {
  boolvalues_.Clear();
}
inline bool SetFilterAndAttributesRequest::boolvalues(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterAndAttributesRequest.boolValues)
  return boolvalues_.Get(index);
}
inline void SetFilterAndAttributesRequest::set_boolvalues(int index, bool value) {
  boolvalues_.Set(index, value);
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterAndAttributesRequest.boolValues)
}
inline void SetFilterAndAttributesRequest::add_boolvalues(bool value) {
  boolvalues_.Add(value);
  // @@protoc_insertion_point(field_add:AnselIpc.SetFilterAndAttributesRequest.boolValues)
}
inline const ::google::protobuf::RepeatedField< bool >&
SetFilterAndAttributesRequest::boolvalues() const {
  // @@protoc_insertion_point(field_list:AnselIpc.SetFilterAndAttributesRequest.boolValues)
  return boolvalues_;
}
inline ::google::protobuf::RepeatedField< bool >*
SetFilterAndAttributesRequest::mutable_boolvalues() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.SetFilterAndAttributesRequest.boolValues)
  return &boolvalues_;
}

// -------------------------------------------------------------------

// SetFilterAndAttributesResponse

// required .AnselIpc.SetFilterResponse setFilterResponse = 1;
inline bool SetFilterAndAttributesResponse::has_setfilterresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetFilterAndAttributesResponse::set_has_setfilterresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetFilterAndAttributesResponse::clear_has_setfilterresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetFilterAndAttributesResponse::clear_setfilterresponse() {
  if (setfilterresponse_ != NULL) setfilterresponse_->::AnselIpc::SetFilterResponse::Clear();
  clear_has_setfilterresponse();
}
inline const ::AnselIpc::SetFilterResponse& SetFilterAndAttributesResponse::setfilterresponse() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterAndAttributesResponse.setFilterResponse)
  return setfilterresponse_ != NULL ? *setfilterresponse_ : *default_instance_->setfilterresponse_;
}
inline ::AnselIpc::SetFilterResponse* SetFilterAndAttributesResponse::mutable_setfilterresponse() {
  set_has_setfilterresponse();
  if (setfilterresponse_ == NULL) setfilterresponse_ = new ::AnselIpc::SetFilterResponse;
  // @@protoc_insertion_point(field_mutable:AnselIpc.SetFilterAndAttributesResponse.setFilterResponse)
  return setfilterresponse_;
}
inline ::AnselIpc::SetFilterResponse* SetFilterAndAttributesResponse::release_setfilterresponse() {
  clear_has_setfilterresponse();
  ::AnselIpc::SetFilterResponse* temp = setfilterresponse_;
  setfilterresponse_ = NULL;
  return temp;
}
inline void SetFilterAndAttributesResponse::set_allocated_setfilterresponse(::AnselIpc::SetFilterResponse* setfilterresponse) {
  delete setfilterresponse_;
  setfilterresponse_ = setfilterresponse;
  if (setfilterresponse) {
    set_has_setfilterresponse();
  } else {
    clear_has_setfilterresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.SetFilterAndAttributesResponse.setFilterResponse)
}

// repeated int32 attributeControlIds = 2;
inline int SetFilterAndAttributesResponse::attributecontrolids_size() const {
  return attributecontrolids_.size();
}
inline void SetFilterAndAttributesResponse::clear_attributecontrolids() {
  attributecontrolids_.Clear();
}
inline ::google::protobuf::int32 SetFilterAndAttributesResponse::attributecontrolids(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterAndAttributesResponse.attributeControlIds)
  return attributecontrolids_.Get(index);
}
inline void SetFilterAndAttributesResponse::set_attributecontrolids(int index, ::google::protobuf::int32 value) {
  attributecontrolids_.Set(index, value);
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterAndAttributesResponse.attributeControlIds)
}
inline void SetFilterAndAttributesResponse::add_attributecontrolids(::google::protobuf::int32 value) {
  attributecontrolids_.Add(value);
  // @@protoc_insertion_point(field_add:AnselIpc.SetFilterAndAttributesResponse.attributeControlIds)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SetFilterAndAttributesResponse::attributecontrolids() const {
  // @@protoc_insertion_point(field_list:AnselIpc.SetFilterAndAttributesResponse.attributeControlIds)
  return attributecontrolids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SetFilterAndAttributesResponse::mutable_attributecontrolids() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.SetFilterAndAttributesResponse.attributeControlIds)
  return &attributecontrolids_;
}

// repeated .AnselIpc.SetFilterAttributeResponse setFilterAttributeResponses = 3;
inline int SetFilterAndAttributesResponse::setfilterattributeresponses_size() const {
  return setfilterattributeresponses_.size();
}
inline void SetFilterAndAttributesResponse::clear_setfilterattributeresponses() {
  setfilterattributeresponses_.Clear();
}
inline const ::AnselIpc::SetFilterAttributeResponse& SetFilterAndAttributesResponse::setfilterattributeresponses(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterAndAttributesResponse.setFilterAttributeResponses)
  return setfilterattributeresponses_.Get(index);
}
inline ::AnselIpc::SetFilterAttributeResponse* SetFilterAndAttributesResponse::mutable_setfilterattributeresponses(int index) {
  // @@protoc_insertion_point(field_mutable:AnselIpc.SetFilterAndAttributesResponse.setFilterAttributeResponses)
  return setfilterattributeresponses_.Mutable(index);
}
inline ::AnselIpc::SetFilterAttributeResponse* SetFilterAndAttributesResponse::add_setfilterattributeresponses() {
  // @@protoc_insertion_point(field_add:AnselIpc.SetFilterAndAttributesResponse.setFilterAttributeResponses)
  return setfilterattributeresponses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::SetFilterAttributeResponse >&
SetFilterAndAttributesResponse::setfilterattributeresponses() const {
  // @@protoc_insertion_point(field_list:AnselIpc.SetFilterAndAttributesResponse.setFilterAttributeResponses)
  return setfilterattributeresponses_;
}
inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::SetFilterAttributeResponse >*
SetFilterAndAttributesResponse::mutable_setfilterattributeresponses() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.SetFilterAndAttributesResponse.setFilterAttributeResponses)
  return &setfilterattributeresponses_;
}

// -------------------------------------------------------------------

// InsertFilterRequest

// required string filterId = 1;
inline bool InsertFilterRequest::has_filterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InsertFilterRequest::set_has_filterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InsertFilterRequest::clear_has_filterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InsertFilterRequest::clear_filterid() {
  if (filterid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_->clear();
  }
  clear_has_filterid();
}
inline const ::std::string& InsertFilterRequest::filterid() const {
  // @@protoc_insertion_point(field_get:AnselIpc.InsertFilterRequest.filterId)
  return *filterid_;
}
inline void InsertFilterRequest::set_filterid(const ::std::string& value) {
  set_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_ = new ::std::string;
  }
  filterid_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.InsertFilterRequest.filterId)
}
inline void InsertFilterRequest::set_filterid(const char* value) {
  set_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_ = new ::std::string;
  }
  filterid_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.InsertFilterRequest.filterId)
}
inline void InsertFilterRequest::set_filterid(const char* value, size_t size) {
  set_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_ = new ::std::string;
  }
  filterid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.InsertFilterRequest.filterId)
}
inline ::std::string* InsertFilterRequest::mutable_filterid() {
  set_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.InsertFilterRequest.filterId)
  return filterid_;
}
inline ::std::string* InsertFilterRequest::release_filterid() {
  clear_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filterid_;
    filterid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InsertFilterRequest::set_allocated_filterid(::std::string* filterid) {
  if (filterid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filterid_;
  }
  if (filterid) {
    set_has_filterid();
    filterid_ = filterid;
  } else {
    clear_has_filterid();
    filterid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.InsertFilterRequest.filterId)
}

// required int32 stackIdx = 2;
inline bool InsertFilterRequest::has_stackidx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InsertFilterRequest::set_has_stackidx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InsertFilterRequest::clear_has_stackidx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InsertFilterRequest::clear_stackidx() {
  stackidx_ = 0;
  clear_has_stackidx();
}
inline ::google::protobuf::int32 InsertFilterRequest::stackidx() const {
  // @@protoc_insertion_point(field_get:AnselIpc.InsertFilterRequest.stackIdx)
  return stackidx_;
}
inline void InsertFilterRequest::set_stackidx(::google::protobuf::int32 value) {
  set_has_stackidx();
  stackidx_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.InsertFilterRequest.stackIdx)
}

// -------------------------------------------------------------------

// InsertFilterResponse

// required .AnselIpc.Status status = 1;
inline bool InsertFilterResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InsertFilterResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InsertFilterResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InsertFilterResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status InsertFilterResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.InsertFilterResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void InsertFilterResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.InsertFilterResponse.status)
}

// required int32 stackIdx = 2;
inline bool InsertFilterResponse::has_stackidx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InsertFilterResponse::set_has_stackidx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InsertFilterResponse::clear_has_stackidx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InsertFilterResponse::clear_stackidx() {
  stackidx_ = 0;
  clear_has_stackidx();
}
inline ::google::protobuf::int32 InsertFilterResponse::stackidx() const {
  // @@protoc_insertion_point(field_get:AnselIpc.InsertFilterResponse.stackIdx)
  return stackidx_;
}
inline void InsertFilterResponse::set_stackidx(::google::protobuf::int32 value) {
  set_has_stackidx();
  stackidx_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.InsertFilterResponse.stackIdx)
}

// optional .AnselIpc.FilterProperties filterProperties = 3;
inline bool InsertFilterResponse::has_filterproperties() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InsertFilterResponse::set_has_filterproperties() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InsertFilterResponse::clear_has_filterproperties() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InsertFilterResponse::clear_filterproperties() {
  if (filterproperties_ != NULL) filterproperties_->::AnselIpc::FilterProperties::Clear();
  clear_has_filterproperties();
}
inline const ::AnselIpc::FilterProperties& InsertFilterResponse::filterproperties() const {
  // @@protoc_insertion_point(field_get:AnselIpc.InsertFilterResponse.filterProperties)
  return filterproperties_ != NULL ? *filterproperties_ : *default_instance_->filterproperties_;
}
inline ::AnselIpc::FilterProperties* InsertFilterResponse::mutable_filterproperties() {
  set_has_filterproperties();
  if (filterproperties_ == NULL) filterproperties_ = new ::AnselIpc::FilterProperties;
  // @@protoc_insertion_point(field_mutable:AnselIpc.InsertFilterResponse.filterProperties)
  return filterproperties_;
}
inline ::AnselIpc::FilterProperties* InsertFilterResponse::release_filterproperties() {
  clear_has_filterproperties();
  ::AnselIpc::FilterProperties* temp = filterproperties_;
  filterproperties_ = NULL;
  return temp;
}
inline void InsertFilterResponse::set_allocated_filterproperties(::AnselIpc::FilterProperties* filterproperties) {
  delete filterproperties_;
  filterproperties_ = filterproperties;
  if (filterproperties) {
    set_has_filterproperties();
  } else {
    clear_has_filterproperties();
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.InsertFilterResponse.filterProperties)
}

// -------------------------------------------------------------------

// RemoveFilterRequest

// required int32 stackIdx = 1;
inline bool RemoveFilterRequest::has_stackidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveFilterRequest::set_has_stackidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveFilterRequest::clear_has_stackidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveFilterRequest::clear_stackidx() {
  stackidx_ = 0;
  clear_has_stackidx();
}
inline ::google::protobuf::int32 RemoveFilterRequest::stackidx() const {
  // @@protoc_insertion_point(field_get:AnselIpc.RemoveFilterRequest.stackIdx)
  return stackidx_;
}
inline void RemoveFilterRequest::set_stackidx(::google::protobuf::int32 value) {
  set_has_stackidx();
  stackidx_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.RemoveFilterRequest.stackIdx)
}

// -------------------------------------------------------------------

// RemoveFilterResponse

// required .AnselIpc.Status status = 1;
inline bool RemoveFilterResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveFilterResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveFilterResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveFilterResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status RemoveFilterResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.RemoveFilterResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void RemoveFilterResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.RemoveFilterResponse.status)
}

// -------------------------------------------------------------------

// MoveFilterRequest

// repeated uint32 desiredStackIndices = 1;
inline int MoveFilterRequest::desiredstackindices_size() const {
  return desiredstackindices_.size();
}
inline void MoveFilterRequest::clear_desiredstackindices() {
  desiredstackindices_.Clear();
}
inline ::google::protobuf::uint32 MoveFilterRequest::desiredstackindices(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.MoveFilterRequest.desiredStackIndices)
  return desiredstackindices_.Get(index);
}
inline void MoveFilterRequest::set_desiredstackindices(int index, ::google::protobuf::uint32 value) {
  desiredstackindices_.Set(index, value);
  // @@protoc_insertion_point(field_set:AnselIpc.MoveFilterRequest.desiredStackIndices)
}
inline void MoveFilterRequest::add_desiredstackindices(::google::protobuf::uint32 value) {
  desiredstackindices_.Add(value);
  // @@protoc_insertion_point(field_add:AnselIpc.MoveFilterRequest.desiredStackIndices)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MoveFilterRequest::desiredstackindices() const {
  // @@protoc_insertion_point(field_list:AnselIpc.MoveFilterRequest.desiredStackIndices)
  return desiredstackindices_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MoveFilterRequest::mutable_desiredstackindices() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.MoveFilterRequest.desiredStackIndices)
  return &desiredstackindices_;
}

// -------------------------------------------------------------------

// MoveFilterResponse

// required .AnselIpc.Status status = 1;
inline bool MoveFilterResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveFilterResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveFilterResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveFilterResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status MoveFilterResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.MoveFilterResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void MoveFilterResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.MoveFilterResponse.status)
}

// -------------------------------------------------------------------

// GetStackInfoRequest

// -------------------------------------------------------------------

// GetStackInfoResponse

// repeated string filterIds = 1;
inline int GetStackInfoResponse::filterids_size() const {
  return filterids_.size();
}
inline void GetStackInfoResponse::clear_filterids() {
  filterids_.Clear();
}
inline const ::std::string& GetStackInfoResponse::filterids(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetStackInfoResponse.filterIds)
  return filterids_.Get(index);
}
inline ::std::string* GetStackInfoResponse::mutable_filterids(int index) {
  // @@protoc_insertion_point(field_mutable:AnselIpc.GetStackInfoResponse.filterIds)
  return filterids_.Mutable(index);
}
inline void GetStackInfoResponse::set_filterids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:AnselIpc.GetStackInfoResponse.filterIds)
  filterids_.Mutable(index)->assign(value);
}
inline void GetStackInfoResponse::set_filterids(int index, const char* value) {
  filterids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.GetStackInfoResponse.filterIds)
}
inline void GetStackInfoResponse::set_filterids(int index, const char* value, size_t size) {
  filterids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.GetStackInfoResponse.filterIds)
}
inline ::std::string* GetStackInfoResponse::add_filterids() {
  return filterids_.Add();
}
inline void GetStackInfoResponse::add_filterids(const ::std::string& value) {
  filterids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:AnselIpc.GetStackInfoResponse.filterIds)
}
inline void GetStackInfoResponse::add_filterids(const char* value) {
  filterids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:AnselIpc.GetStackInfoResponse.filterIds)
}
inline void GetStackInfoResponse::add_filterids(const char* value, size_t size) {
  filterids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:AnselIpc.GetStackInfoResponse.filterIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetStackInfoResponse::filterids() const {
  // @@protoc_insertion_point(field_list:AnselIpc.GetStackInfoResponse.filterIds)
  return filterids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetStackInfoResponse::mutable_filterids() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.GetStackInfoResponse.filterIds)
  return &filterids_;
}

// -------------------------------------------------------------------

// FilterProperties_ValuesFloat

// required float current = 1;
inline bool FilterProperties_ValuesFloat::has_lwrrent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterProperties_ValuesFloat::set_has_lwrrent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterProperties_ValuesFloat::clear_has_lwrrent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterProperties_ValuesFloat::clear_lwrrent() {
  lwrrent_ = 0;
  clear_has_lwrrent();
}
inline float FilterProperties_ValuesFloat::current() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesFloat.current)
  return lwrrent_;
}
inline void FilterProperties_ValuesFloat::set_lwrrent(float value) {
  set_has_lwrrent();
  lwrrent_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesFloat.current)
}

// required float default = 2;
inline bool FilterProperties_ValuesFloat::has_default_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FilterProperties_ValuesFloat::set_has_default_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FilterProperties_ValuesFloat::clear_has_default_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FilterProperties_ValuesFloat::clear_default_() {
  default__ = 0;
  clear_has_default_();
}
inline float FilterProperties_ValuesFloat::default_() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesFloat.default)
  return default__;
}
inline void FilterProperties_ValuesFloat::set_default_(float value) {
  set_has_default_();
  default__ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesFloat.default)
}

// required float minimum = 3;
inline bool FilterProperties_ValuesFloat::has_minimum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FilterProperties_ValuesFloat::set_has_minimum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FilterProperties_ValuesFloat::clear_has_minimum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FilterProperties_ValuesFloat::clear_minimum() {
  minimum_ = 0;
  clear_has_minimum();
}
inline float FilterProperties_ValuesFloat::minimum() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesFloat.minimum)
  return minimum_;
}
inline void FilterProperties_ValuesFloat::set_minimum(float value) {
  set_has_minimum();
  minimum_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesFloat.minimum)
}

// required float maximum = 4;
inline bool FilterProperties_ValuesFloat::has_maximum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FilterProperties_ValuesFloat::set_has_maximum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FilterProperties_ValuesFloat::clear_has_maximum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FilterProperties_ValuesFloat::clear_maximum() {
  maximum_ = 0;
  clear_has_maximum();
}
inline float FilterProperties_ValuesFloat::maximum() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesFloat.maximum)
  return maximum_;
}
inline void FilterProperties_ValuesFloat::set_maximum(float value) {
  set_has_maximum();
  maximum_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesFloat.maximum)
}

// required float stepSize = 5;
inline bool FilterProperties_ValuesFloat::has_stepsize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FilterProperties_ValuesFloat::set_has_stepsize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FilterProperties_ValuesFloat::clear_has_stepsize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FilterProperties_ValuesFloat::clear_stepsize() {
  stepsize_ = 0;
  clear_has_stepsize();
}
inline float FilterProperties_ValuesFloat::stepsize() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesFloat.stepSize)
  return stepsize_;
}
inline void FilterProperties_ValuesFloat::set_stepsize(float value) {
  set_has_stepsize();
  stepsize_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesFloat.stepSize)
}

// optional float stepSizeUi = 6;
inline bool FilterProperties_ValuesFloat::has_stepsizeui() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FilterProperties_ValuesFloat::set_has_stepsizeui() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FilterProperties_ValuesFloat::clear_has_stepsizeui() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FilterProperties_ValuesFloat::clear_stepsizeui() {
  stepsizeui_ = 0;
  clear_has_stepsizeui();
}
inline float FilterProperties_ValuesFloat::stepsizeui() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesFloat.stepSizeUi)
  return stepsizeui_;
}
inline void FilterProperties_ValuesFloat::set_stepsizeui(float value) {
  set_has_stepsizeui();
  stepsizeui_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesFloat.stepSizeUi)
}

// optional float milwalueUi = 7;
inline bool FilterProperties_ValuesFloat::has_milwalueui() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FilterProperties_ValuesFloat::set_has_milwalueui() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FilterProperties_ValuesFloat::clear_has_milwalueui() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FilterProperties_ValuesFloat::clear_milwalueui() {
  milwalueui_ = 0;
  clear_has_milwalueui();
}
inline float FilterProperties_ValuesFloat::milwalueui() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesFloat.milwalueUi)
  return milwalueui_;
}
inline void FilterProperties_ValuesFloat::set_milwalueui(float value) {
  set_has_milwalueui();
  milwalueui_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesFloat.milwalueUi)
}

// optional float maxValueUi = 8;
inline bool FilterProperties_ValuesFloat::has_maxvalueui() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FilterProperties_ValuesFloat::set_has_maxvalueui() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FilterProperties_ValuesFloat::clear_has_maxvalueui() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FilterProperties_ValuesFloat::clear_maxvalueui() {
  maxvalueui_ = 0;
  clear_has_maxvalueui();
}
inline float FilterProperties_ValuesFloat::maxvalueui() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesFloat.maxValueUi)
  return maxvalueui_;
}
inline void FilterProperties_ValuesFloat::set_maxvalueui(float value) {
  set_has_maxvalueui();
  maxvalueui_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesFloat.maxValueUi)
}

// optional string displayName = 9;
inline bool FilterProperties_ValuesFloat::has_displayname() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FilterProperties_ValuesFloat::set_has_displayname() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FilterProperties_ValuesFloat::clear_has_displayname() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FilterProperties_ValuesFloat::clear_displayname() {
  if (displayname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_->clear();
  }
  clear_has_displayname();
}
inline const ::std::string& FilterProperties_ValuesFloat::displayname() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesFloat.displayName)
  return *displayname_;
}
inline void FilterProperties_ValuesFloat::set_displayname(const ::std::string& value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesFloat.displayName)
}
inline void FilterProperties_ValuesFloat::set_displayname(const char* value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.FilterProperties.ValuesFloat.displayName)
}
inline void FilterProperties_ValuesFloat::set_displayname(const char* value, size_t size) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.FilterProperties.ValuesFloat.displayName)
}
inline ::std::string* FilterProperties_ValuesFloat::mutable_displayname() {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.FilterProperties.ValuesFloat.displayName)
  return displayname_;
}
inline ::std::string* FilterProperties_ValuesFloat::release_displayname() {
  clear_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = displayname_;
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FilterProperties_ValuesFloat::set_allocated_displayname(::std::string* displayname) {
  if (displayname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete displayname_;
  }
  if (displayname) {
    set_has_displayname();
    displayname_ = displayname;
  } else {
    clear_has_displayname();
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.FilterProperties.ValuesFloat.displayName)
}

// -------------------------------------------------------------------

// FilterProperties_ValuesInt

// required int32 current = 1;
inline bool FilterProperties_ValuesInt::has_lwrrent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterProperties_ValuesInt::set_has_lwrrent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterProperties_ValuesInt::clear_has_lwrrent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterProperties_ValuesInt::clear_lwrrent() {
  lwrrent_ = 0;
  clear_has_lwrrent();
}
inline ::google::protobuf::int32 FilterProperties_ValuesInt::current() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesInt.current)
  return lwrrent_;
}
inline void FilterProperties_ValuesInt::set_lwrrent(::google::protobuf::int32 value) {
  set_has_lwrrent();
  lwrrent_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesInt.current)
}

// required int32 default = 2;
inline bool FilterProperties_ValuesInt::has_default_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FilterProperties_ValuesInt::set_has_default_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FilterProperties_ValuesInt::clear_has_default_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FilterProperties_ValuesInt::clear_default_() {
  default__ = 0;
  clear_has_default_();
}
inline ::google::protobuf::int32 FilterProperties_ValuesInt::default_() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesInt.default)
  return default__;
}
inline void FilterProperties_ValuesInt::set_default_(::google::protobuf::int32 value) {
  set_has_default_();
  default__ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesInt.default)
}

// required int32 minimum = 3;
inline bool FilterProperties_ValuesInt::has_minimum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FilterProperties_ValuesInt::set_has_minimum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FilterProperties_ValuesInt::clear_has_minimum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FilterProperties_ValuesInt::clear_minimum() {
  minimum_ = 0;
  clear_has_minimum();
}
inline ::google::protobuf::int32 FilterProperties_ValuesInt::minimum() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesInt.minimum)
  return minimum_;
}
inline void FilterProperties_ValuesInt::set_minimum(::google::protobuf::int32 value) {
  set_has_minimum();
  minimum_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesInt.minimum)
}

// required int32 maximum = 4;
inline bool FilterProperties_ValuesInt::has_maximum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FilterProperties_ValuesInt::set_has_maximum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FilterProperties_ValuesInt::clear_has_maximum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FilterProperties_ValuesInt::clear_maximum() {
  maximum_ = 0;
  clear_has_maximum();
}
inline ::google::protobuf::int32 FilterProperties_ValuesInt::maximum() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesInt.maximum)
  return maximum_;
}
inline void FilterProperties_ValuesInt::set_maximum(::google::protobuf::int32 value) {
  set_has_maximum();
  maximum_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesInt.maximum)
}

// required uint32 stepSize = 5;
inline bool FilterProperties_ValuesInt::has_stepsize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FilterProperties_ValuesInt::set_has_stepsize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FilterProperties_ValuesInt::clear_has_stepsize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FilterProperties_ValuesInt::clear_stepsize() {
  stepsize_ = 0u;
  clear_has_stepsize();
}
inline ::google::protobuf::uint32 FilterProperties_ValuesInt::stepsize() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesInt.stepSize)
  return stepsize_;
}
inline void FilterProperties_ValuesInt::set_stepsize(::google::protobuf::uint32 value) {
  set_has_stepsize();
  stepsize_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesInt.stepSize)
}

// optional uint32 stepSizeUi = 6;
inline bool FilterProperties_ValuesInt::has_stepsizeui() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FilterProperties_ValuesInt::set_has_stepsizeui() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FilterProperties_ValuesInt::clear_has_stepsizeui() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FilterProperties_ValuesInt::clear_stepsizeui() {
  stepsizeui_ = 0u;
  clear_has_stepsizeui();
}
inline ::google::protobuf::uint32 FilterProperties_ValuesInt::stepsizeui() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesInt.stepSizeUi)
  return stepsizeui_;
}
inline void FilterProperties_ValuesInt::set_stepsizeui(::google::protobuf::uint32 value) {
  set_has_stepsizeui();
  stepsizeui_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesInt.stepSizeUi)
}

// optional int32 milwalueUi = 7;
inline bool FilterProperties_ValuesInt::has_milwalueui() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FilterProperties_ValuesInt::set_has_milwalueui() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FilterProperties_ValuesInt::clear_has_milwalueui() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FilterProperties_ValuesInt::clear_milwalueui() {
  milwalueui_ = 0;
  clear_has_milwalueui();
}
inline ::google::protobuf::int32 FilterProperties_ValuesInt::milwalueui() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesInt.milwalueUi)
  return milwalueui_;
}
inline void FilterProperties_ValuesInt::set_milwalueui(::google::protobuf::int32 value) {
  set_has_milwalueui();
  milwalueui_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesInt.milwalueUi)
}

// optional int32 maxValueUi = 8;
inline bool FilterProperties_ValuesInt::has_maxvalueui() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FilterProperties_ValuesInt::set_has_maxvalueui() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FilterProperties_ValuesInt::clear_has_maxvalueui() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FilterProperties_ValuesInt::clear_maxvalueui() {
  maxvalueui_ = 0;
  clear_has_maxvalueui();
}
inline ::google::protobuf::int32 FilterProperties_ValuesInt::maxvalueui() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesInt.maxValueUi)
  return maxvalueui_;
}
inline void FilterProperties_ValuesInt::set_maxvalueui(::google::protobuf::int32 value) {
  set_has_maxvalueui();
  maxvalueui_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesInt.maxValueUi)
}

// optional string displayName = 9;
inline bool FilterProperties_ValuesInt::has_displayname() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FilterProperties_ValuesInt::set_has_displayname() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FilterProperties_ValuesInt::clear_has_displayname() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FilterProperties_ValuesInt::clear_displayname() {
  if (displayname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_->clear();
  }
  clear_has_displayname();
}
inline const ::std::string& FilterProperties_ValuesInt::displayname() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesInt.displayName)
  return *displayname_;
}
inline void FilterProperties_ValuesInt::set_displayname(const ::std::string& value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesInt.displayName)
}
inline void FilterProperties_ValuesInt::set_displayname(const char* value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.FilterProperties.ValuesInt.displayName)
}
inline void FilterProperties_ValuesInt::set_displayname(const char* value, size_t size) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.FilterProperties.ValuesInt.displayName)
}
inline ::std::string* FilterProperties_ValuesInt::mutable_displayname() {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.FilterProperties.ValuesInt.displayName)
  return displayname_;
}
inline ::std::string* FilterProperties_ValuesInt::release_displayname() {
  clear_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = displayname_;
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FilterProperties_ValuesInt::set_allocated_displayname(::std::string* displayname) {
  if (displayname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete displayname_;
  }
  if (displayname) {
    set_has_displayname();
    displayname_ = displayname;
  } else {
    clear_has_displayname();
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.FilterProperties.ValuesInt.displayName)
}

// -------------------------------------------------------------------

// FilterProperties_ValuesUInt

// required uint32 current = 1;
inline bool FilterProperties_ValuesUInt::has_lwrrent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterProperties_ValuesUInt::set_has_lwrrent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterProperties_ValuesUInt::clear_has_lwrrent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterProperties_ValuesUInt::clear_lwrrent() {
  lwrrent_ = 0u;
  clear_has_lwrrent();
}
inline ::google::protobuf::uint32 FilterProperties_ValuesUInt::current() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesUInt.current)
  return lwrrent_;
}
inline void FilterProperties_ValuesUInt::set_lwrrent(::google::protobuf::uint32 value) {
  set_has_lwrrent();
  lwrrent_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesUInt.current)
}

// required uint32 default = 2;
inline bool FilterProperties_ValuesUInt::has_default_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FilterProperties_ValuesUInt::set_has_default_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FilterProperties_ValuesUInt::clear_has_default_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FilterProperties_ValuesUInt::clear_default_() {
  default__ = 0u;
  clear_has_default_();
}
inline ::google::protobuf::uint32 FilterProperties_ValuesUInt::default_() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesUInt.default)
  return default__;
}
inline void FilterProperties_ValuesUInt::set_default_(::google::protobuf::uint32 value) {
  set_has_default_();
  default__ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesUInt.default)
}

// required uint32 minimum = 3;
inline bool FilterProperties_ValuesUInt::has_minimum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FilterProperties_ValuesUInt::set_has_minimum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FilterProperties_ValuesUInt::clear_has_minimum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FilterProperties_ValuesUInt::clear_minimum() {
  minimum_ = 0u;
  clear_has_minimum();
}
inline ::google::protobuf::uint32 FilterProperties_ValuesUInt::minimum() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesUInt.minimum)
  return minimum_;
}
inline void FilterProperties_ValuesUInt::set_minimum(::google::protobuf::uint32 value) {
  set_has_minimum();
  minimum_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesUInt.minimum)
}

// required uint32 maximum = 4;
inline bool FilterProperties_ValuesUInt::has_maximum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FilterProperties_ValuesUInt::set_has_maximum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FilterProperties_ValuesUInt::clear_has_maximum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FilterProperties_ValuesUInt::clear_maximum() {
  maximum_ = 0u;
  clear_has_maximum();
}
inline ::google::protobuf::uint32 FilterProperties_ValuesUInt::maximum() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesUInt.maximum)
  return maximum_;
}
inline void FilterProperties_ValuesUInt::set_maximum(::google::protobuf::uint32 value) {
  set_has_maximum();
  maximum_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesUInt.maximum)
}

// required uint32 stepSize = 5;
inline bool FilterProperties_ValuesUInt::has_stepsize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FilterProperties_ValuesUInt::set_has_stepsize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FilterProperties_ValuesUInt::clear_has_stepsize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FilterProperties_ValuesUInt::clear_stepsize() {
  stepsize_ = 0u;
  clear_has_stepsize();
}
inline ::google::protobuf::uint32 FilterProperties_ValuesUInt::stepsize() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesUInt.stepSize)
  return stepsize_;
}
inline void FilterProperties_ValuesUInt::set_stepsize(::google::protobuf::uint32 value) {
  set_has_stepsize();
  stepsize_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesUInt.stepSize)
}

// optional uint32 stepSizeUi = 6;
inline bool FilterProperties_ValuesUInt::has_stepsizeui() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FilterProperties_ValuesUInt::set_has_stepsizeui() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FilterProperties_ValuesUInt::clear_has_stepsizeui() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FilterProperties_ValuesUInt::clear_stepsizeui() {
  stepsizeui_ = 0u;
  clear_has_stepsizeui();
}
inline ::google::protobuf::uint32 FilterProperties_ValuesUInt::stepsizeui() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesUInt.stepSizeUi)
  return stepsizeui_;
}
inline void FilterProperties_ValuesUInt::set_stepsizeui(::google::protobuf::uint32 value) {
  set_has_stepsizeui();
  stepsizeui_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesUInt.stepSizeUi)
}

// optional uint32 milwalueUi = 7;
inline bool FilterProperties_ValuesUInt::has_milwalueui() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FilterProperties_ValuesUInt::set_has_milwalueui() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FilterProperties_ValuesUInt::clear_has_milwalueui() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FilterProperties_ValuesUInt::clear_milwalueui() {
  milwalueui_ = 0u;
  clear_has_milwalueui();
}
inline ::google::protobuf::uint32 FilterProperties_ValuesUInt::milwalueui() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesUInt.milwalueUi)
  return milwalueui_;
}
inline void FilterProperties_ValuesUInt::set_milwalueui(::google::protobuf::uint32 value) {
  set_has_milwalueui();
  milwalueui_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesUInt.milwalueUi)
}

// optional uint32 maxValueUi = 8;
inline bool FilterProperties_ValuesUInt::has_maxvalueui() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FilterProperties_ValuesUInt::set_has_maxvalueui() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FilterProperties_ValuesUInt::clear_has_maxvalueui() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FilterProperties_ValuesUInt::clear_maxvalueui() {
  maxvalueui_ = 0u;
  clear_has_maxvalueui();
}
inline ::google::protobuf::uint32 FilterProperties_ValuesUInt::maxvalueui() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesUInt.maxValueUi)
  return maxvalueui_;
}
inline void FilterProperties_ValuesUInt::set_maxvalueui(::google::protobuf::uint32 value) {
  set_has_maxvalueui();
  maxvalueui_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesUInt.maxValueUi)
}

// optional string displayName = 9;
inline bool FilterProperties_ValuesUInt::has_displayname() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FilterProperties_ValuesUInt::set_has_displayname() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FilterProperties_ValuesUInt::clear_has_displayname() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FilterProperties_ValuesUInt::clear_displayname() {
  if (displayname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_->clear();
  }
  clear_has_displayname();
}
inline const ::std::string& FilterProperties_ValuesUInt::displayname() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesUInt.displayName)
  return *displayname_;
}
inline void FilterProperties_ValuesUInt::set_displayname(const ::std::string& value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesUInt.displayName)
}
inline void FilterProperties_ValuesUInt::set_displayname(const char* value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.FilterProperties.ValuesUInt.displayName)
}
inline void FilterProperties_ValuesUInt::set_displayname(const char* value, size_t size) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.FilterProperties.ValuesUInt.displayName)
}
inline ::std::string* FilterProperties_ValuesUInt::mutable_displayname() {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.FilterProperties.ValuesUInt.displayName)
  return displayname_;
}
inline ::std::string* FilterProperties_ValuesUInt::release_displayname() {
  clear_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = displayname_;
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FilterProperties_ValuesUInt::set_allocated_displayname(::std::string* displayname) {
  if (displayname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete displayname_;
  }
  if (displayname) {
    set_has_displayname();
    displayname_ = displayname;
  } else {
    clear_has_displayname();
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.FilterProperties.ValuesUInt.displayName)
}

// -------------------------------------------------------------------

// FilterProperties_ValuesBool

// required bool current = 1;
inline bool FilterProperties_ValuesBool::has_lwrrent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterProperties_ValuesBool::set_has_lwrrent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterProperties_ValuesBool::clear_has_lwrrent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterProperties_ValuesBool::clear_lwrrent() {
  lwrrent_ = false;
  clear_has_lwrrent();
}
inline bool FilterProperties_ValuesBool::current() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesBool.current)
  return lwrrent_;
}
inline void FilterProperties_ValuesBool::set_lwrrent(bool value) {
  set_has_lwrrent();
  lwrrent_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesBool.current)
}

// required bool default = 2;
inline bool FilterProperties_ValuesBool::has_default_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FilterProperties_ValuesBool::set_has_default_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FilterProperties_ValuesBool::clear_has_default_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FilterProperties_ValuesBool::clear_default_() {
  default__ = false;
  clear_has_default_();
}
inline bool FilterProperties_ValuesBool::default_() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesBool.default)
  return default__;
}
inline void FilterProperties_ValuesBool::set_default_(bool value) {
  set_has_default_();
  default__ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesBool.default)
}

// required bool minimum = 3;
inline bool FilterProperties_ValuesBool::has_minimum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FilterProperties_ValuesBool::set_has_minimum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FilterProperties_ValuesBool::clear_has_minimum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FilterProperties_ValuesBool::clear_minimum() {
  minimum_ = false;
  clear_has_minimum();
}
inline bool FilterProperties_ValuesBool::minimum() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesBool.minimum)
  return minimum_;
}
inline void FilterProperties_ValuesBool::set_minimum(bool value) {
  set_has_minimum();
  minimum_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesBool.minimum)
}

// required bool maximum = 4;
inline bool FilterProperties_ValuesBool::has_maximum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FilterProperties_ValuesBool::set_has_maximum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FilterProperties_ValuesBool::clear_has_maximum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FilterProperties_ValuesBool::clear_maximum() {
  maximum_ = false;
  clear_has_maximum();
}
inline bool FilterProperties_ValuesBool::maximum() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesBool.maximum)
  return maximum_;
}
inline void FilterProperties_ValuesBool::set_maximum(bool value) {
  set_has_maximum();
  maximum_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesBool.maximum)
}

// optional string displayName = 5;
inline bool FilterProperties_ValuesBool::has_displayname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FilterProperties_ValuesBool::set_has_displayname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FilterProperties_ValuesBool::clear_has_displayname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FilterProperties_ValuesBool::clear_displayname() {
  if (displayname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_->clear();
  }
  clear_has_displayname();
}
inline const ::std::string& FilterProperties_ValuesBool::displayname() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ValuesBool.displayName)
  return *displayname_;
}
inline void FilterProperties_ValuesBool::set_displayname(const ::std::string& value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ValuesBool.displayName)
}
inline void FilterProperties_ValuesBool::set_displayname(const char* value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.FilterProperties.ValuesBool.displayName)
}
inline void FilterProperties_ValuesBool::set_displayname(const char* value, size_t size) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.FilterProperties.ValuesBool.displayName)
}
inline ::std::string* FilterProperties_ValuesBool::mutable_displayname() {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.FilterProperties.ValuesBool.displayName)
  return displayname_;
}
inline ::std::string* FilterProperties_ValuesBool::release_displayname() {
  clear_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = displayname_;
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FilterProperties_ValuesBool::set_allocated_displayname(::std::string* displayname) {
  if (displayname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete displayname_;
  }
  if (displayname) {
    set_has_displayname();
    displayname_ = displayname;
  } else {
    clear_has_displayname();
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.FilterProperties.ValuesBool.displayName)
}

// -------------------------------------------------------------------

// FilterProperties_ControlDescription

// required int32 controlId = 1;
inline bool FilterProperties_ControlDescription::has_controlid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterProperties_ControlDescription::set_has_controlid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterProperties_ControlDescription::clear_has_controlid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterProperties_ControlDescription::clear_controlid() {
  controlid_ = 0;
  clear_has_controlid();
}
inline ::google::protobuf::int32 FilterProperties_ControlDescription::controlid() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ControlDescription.controlId)
  return controlid_;
}
inline void FilterProperties_ControlDescription::set_controlid(::google::protobuf::int32 value) {
  set_has_controlid();
  controlid_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ControlDescription.controlId)
}

// required string displayName = 2;
inline bool FilterProperties_ControlDescription::has_displayname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FilterProperties_ControlDescription::set_has_displayname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FilterProperties_ControlDescription::clear_has_displayname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FilterProperties_ControlDescription::clear_displayname() {
  if (displayname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_->clear();
  }
  clear_has_displayname();
}
inline const ::std::string& FilterProperties_ControlDescription::displayname() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ControlDescription.displayName)
  return *displayname_;
}
inline void FilterProperties_ControlDescription::set_displayname(const ::std::string& value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ControlDescription.displayName)
}
inline void FilterProperties_ControlDescription::set_displayname(const char* value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.FilterProperties.ControlDescription.displayName)
}
inline void FilterProperties_ControlDescription::set_displayname(const char* value, size_t size) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.FilterProperties.ControlDescription.displayName)
}
inline ::std::string* FilterProperties_ControlDescription::mutable_displayname() {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displayname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.FilterProperties.ControlDescription.displayName)
  return displayname_;
}
inline ::std::string* FilterProperties_ControlDescription::release_displayname() {
  clear_has_displayname();
  if (displayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = displayname_;
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FilterProperties_ControlDescription::set_allocated_displayname(::std::string* displayname) {
  if (displayname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete displayname_;
  }
  if (displayname) {
    set_has_displayname();
    displayname_ = displayname;
  } else {
    clear_has_displayname();
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.FilterProperties.ControlDescription.displayName)
}

// required float milwalueUi = 3;
inline bool FilterProperties_ControlDescription::has_milwalueui() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FilterProperties_ControlDescription::set_has_milwalueui() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FilterProperties_ControlDescription::clear_has_milwalueui() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FilterProperties_ControlDescription::clear_milwalueui() {
  milwalueui_ = 0;
  clear_has_milwalueui();
}
inline float FilterProperties_ControlDescription::milwalueui() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ControlDescription.milwalueUi)
  return milwalueui_;
}
inline void FilterProperties_ControlDescription::set_milwalueui(float value) {
  set_has_milwalueui();
  milwalueui_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ControlDescription.milwalueUi)
}

// required float maxValueUi = 4;
inline bool FilterProperties_ControlDescription::has_maxvalueui() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FilterProperties_ControlDescription::set_has_maxvalueui() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FilterProperties_ControlDescription::clear_has_maxvalueui() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FilterProperties_ControlDescription::clear_maxvalueui() {
  maxvalueui_ = 0;
  clear_has_maxvalueui();
}
inline float FilterProperties_ControlDescription::maxvalueui() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ControlDescription.maxValueUi)
  return maxvalueui_;
}
inline void FilterProperties_ControlDescription::set_maxvalueui(float value) {
  set_has_maxvalueui();
  maxvalueui_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ControlDescription.maxValueUi)
}

// required .AnselIpc.ControlType type = 5;
inline bool FilterProperties_ControlDescription::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FilterProperties_ControlDescription::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FilterProperties_ControlDescription::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FilterProperties_ControlDescription::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::AnselIpc::ControlType FilterProperties_ControlDescription::type() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ControlDescription.type)
  return static_cast< ::AnselIpc::ControlType >(type_);
}
inline void FilterProperties_ControlDescription::set_type(::AnselIpc::ControlType value) {
  assert(::AnselIpc::ControlType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ControlDescription.type)
}

// repeated .AnselIpc.FilterProperties.ValuesFloat valuesFloat = 6;
inline int FilterProperties_ControlDescription::valuesfloat_size() const {
  return valuesfloat_.size();
}
inline void FilterProperties_ControlDescription::clear_valuesfloat() {
  valuesfloat_.Clear();
}
inline const ::AnselIpc::FilterProperties_ValuesFloat& FilterProperties_ControlDescription::valuesfloat(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ControlDescription.valuesFloat)
  return valuesfloat_.Get(index);
}
inline ::AnselIpc::FilterProperties_ValuesFloat* FilterProperties_ControlDescription::mutable_valuesfloat(int index) {
  // @@protoc_insertion_point(field_mutable:AnselIpc.FilterProperties.ControlDescription.valuesFloat)
  return valuesfloat_.Mutable(index);
}
inline ::AnselIpc::FilterProperties_ValuesFloat* FilterProperties_ControlDescription::add_valuesfloat() {
  // @@protoc_insertion_point(field_add:AnselIpc.FilterProperties.ControlDescription.valuesFloat)
  return valuesfloat_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ValuesFloat >&
FilterProperties_ControlDescription::valuesfloat() const {
  // @@protoc_insertion_point(field_list:AnselIpc.FilterProperties.ControlDescription.valuesFloat)
  return valuesfloat_;
}
inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ValuesFloat >*
FilterProperties_ControlDescription::mutable_valuesfloat() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.FilterProperties.ControlDescription.valuesFloat)
  return &valuesfloat_;
}

// repeated .AnselIpc.FilterProperties.ValuesBool valuesBool = 7;
inline int FilterProperties_ControlDescription::valuesbool_size() const {
  return valuesbool_.size();
}
inline void FilterProperties_ControlDescription::clear_valuesbool() {
  valuesbool_.Clear();
}
inline const ::AnselIpc::FilterProperties_ValuesBool& FilterProperties_ControlDescription::valuesbool(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ControlDescription.valuesBool)
  return valuesbool_.Get(index);
}
inline ::AnselIpc::FilterProperties_ValuesBool* FilterProperties_ControlDescription::mutable_valuesbool(int index) {
  // @@protoc_insertion_point(field_mutable:AnselIpc.FilterProperties.ControlDescription.valuesBool)
  return valuesbool_.Mutable(index);
}
inline ::AnselIpc::FilterProperties_ValuesBool* FilterProperties_ControlDescription::add_valuesbool() {
  // @@protoc_insertion_point(field_add:AnselIpc.FilterProperties.ControlDescription.valuesBool)
  return valuesbool_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ValuesBool >&
FilterProperties_ControlDescription::valuesbool() const {
  // @@protoc_insertion_point(field_list:AnselIpc.FilterProperties.ControlDescription.valuesBool)
  return valuesbool_;
}
inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ValuesBool >*
FilterProperties_ControlDescription::mutable_valuesbool() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.FilterProperties.ControlDescription.valuesBool)
  return &valuesbool_;
}

// repeated .AnselIpc.FilterProperties.ValuesInt valuesInt = 8;
inline int FilterProperties_ControlDescription::valuesint_size() const {
  return valuesint_.size();
}
inline void FilterProperties_ControlDescription::clear_valuesint() {
  valuesint_.Clear();
}
inline const ::AnselIpc::FilterProperties_ValuesInt& FilterProperties_ControlDescription::valuesint(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ControlDescription.valuesInt)
  return valuesint_.Get(index);
}
inline ::AnselIpc::FilterProperties_ValuesInt* FilterProperties_ControlDescription::mutable_valuesint(int index) {
  // @@protoc_insertion_point(field_mutable:AnselIpc.FilterProperties.ControlDescription.valuesInt)
  return valuesint_.Mutable(index);
}
inline ::AnselIpc::FilterProperties_ValuesInt* FilterProperties_ControlDescription::add_valuesint() {
  // @@protoc_insertion_point(field_add:AnselIpc.FilterProperties.ControlDescription.valuesInt)
  return valuesint_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ValuesInt >&
FilterProperties_ControlDescription::valuesint() const {
  // @@protoc_insertion_point(field_list:AnselIpc.FilterProperties.ControlDescription.valuesInt)
  return valuesint_;
}
inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ValuesInt >*
FilterProperties_ControlDescription::mutable_valuesint() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.FilterProperties.ControlDescription.valuesInt)
  return &valuesint_;
}

// repeated .AnselIpc.FilterProperties.ValuesUInt valuesUInt = 9;
inline int FilterProperties_ControlDescription::valuesuint_size() const {
  return valuesuint_.size();
}
inline void FilterProperties_ControlDescription::clear_valuesuint() {
  valuesuint_.Clear();
}
inline const ::AnselIpc::FilterProperties_ValuesUInt& FilterProperties_ControlDescription::valuesuint(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ControlDescription.valuesUInt)
  return valuesuint_.Get(index);
}
inline ::AnselIpc::FilterProperties_ValuesUInt* FilterProperties_ControlDescription::mutable_valuesuint(int index) {
  // @@protoc_insertion_point(field_mutable:AnselIpc.FilterProperties.ControlDescription.valuesUInt)
  return valuesuint_.Mutable(index);
}
inline ::AnselIpc::FilterProperties_ValuesUInt* FilterProperties_ControlDescription::add_valuesuint() {
  // @@protoc_insertion_point(field_add:AnselIpc.FilterProperties.ControlDescription.valuesUInt)
  return valuesuint_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ValuesUInt >&
FilterProperties_ControlDescription::valuesuint() const {
  // @@protoc_insertion_point(field_list:AnselIpc.FilterProperties.ControlDescription.valuesUInt)
  return valuesuint_;
}
inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ValuesUInt >*
FilterProperties_ControlDescription::mutable_valuesuint() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.FilterProperties.ControlDescription.valuesUInt)
  return &valuesuint_;
}

// required int32 uiPrecision = 10;
inline bool FilterProperties_ControlDescription::has_uiprecision() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FilterProperties_ControlDescription::set_has_uiprecision() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FilterProperties_ControlDescription::clear_has_uiprecision() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FilterProperties_ControlDescription::clear_uiprecision() {
  uiprecision_ = 0;
  clear_has_uiprecision();
}
inline ::google::protobuf::int32 FilterProperties_ControlDescription::uiprecision() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ControlDescription.uiPrecision)
  return uiprecision_;
}
inline void FilterProperties_ControlDescription::set_uiprecision(::google::protobuf::int32 value) {
  set_has_uiprecision();
  uiprecision_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ControlDescription.uiPrecision)
}

// optional string uiMeasurementUnit = 11;
inline bool FilterProperties_ControlDescription::has_uimeasurementunit() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FilterProperties_ControlDescription::set_has_uimeasurementunit() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FilterProperties_ControlDescription::clear_has_uimeasurementunit() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FilterProperties_ControlDescription::clear_uimeasurementunit() {
  if (uimeasurementunit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uimeasurementunit_->clear();
  }
  clear_has_uimeasurementunit();
}
inline const ::std::string& FilterProperties_ControlDescription::uimeasurementunit() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ControlDescription.uiMeasurementUnit)
  return *uimeasurementunit_;
}
inline void FilterProperties_ControlDescription::set_uimeasurementunit(const ::std::string& value) {
  set_has_uimeasurementunit();
  if (uimeasurementunit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uimeasurementunit_ = new ::std::string;
  }
  uimeasurementunit_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ControlDescription.uiMeasurementUnit)
}
inline void FilterProperties_ControlDescription::set_uimeasurementunit(const char* value) {
  set_has_uimeasurementunit();
  if (uimeasurementunit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uimeasurementunit_ = new ::std::string;
  }
  uimeasurementunit_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.FilterProperties.ControlDescription.uiMeasurementUnit)
}
inline void FilterProperties_ControlDescription::set_uimeasurementunit(const char* value, size_t size) {
  set_has_uimeasurementunit();
  if (uimeasurementunit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uimeasurementunit_ = new ::std::string;
  }
  uimeasurementunit_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.FilterProperties.ControlDescription.uiMeasurementUnit)
}
inline ::std::string* FilterProperties_ControlDescription::mutable_uimeasurementunit() {
  set_has_uimeasurementunit();
  if (uimeasurementunit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uimeasurementunit_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.FilterProperties.ControlDescription.uiMeasurementUnit)
  return uimeasurementunit_;
}
inline ::std::string* FilterProperties_ControlDescription::release_uimeasurementunit() {
  clear_has_uimeasurementunit();
  if (uimeasurementunit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = uimeasurementunit_;
    uimeasurementunit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FilterProperties_ControlDescription::set_allocated_uimeasurementunit(::std::string* uimeasurementunit) {
  if (uimeasurementunit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uimeasurementunit_;
  }
  if (uimeasurementunit) {
    set_has_uimeasurementunit();
    uimeasurementunit_ = uimeasurementunit;
  } else {
    clear_has_uimeasurementunit();
    uimeasurementunit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.FilterProperties.ControlDescription.uiMeasurementUnit)
}

// repeated string labelsUi = 12;
inline int FilterProperties_ControlDescription::labelsui_size() const {
  return labelsui_.size();
}
inline void FilterProperties_ControlDescription::clear_labelsui() {
  labelsui_.Clear();
}
inline const ::std::string& FilterProperties_ControlDescription::labelsui(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ControlDescription.labelsUi)
  return labelsui_.Get(index);
}
inline ::std::string* FilterProperties_ControlDescription::mutable_labelsui(int index) {
  // @@protoc_insertion_point(field_mutable:AnselIpc.FilterProperties.ControlDescription.labelsUi)
  return labelsui_.Mutable(index);
}
inline void FilterProperties_ControlDescription::set_labelsui(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ControlDescription.labelsUi)
  labelsui_.Mutable(index)->assign(value);
}
inline void FilterProperties_ControlDescription::set_labelsui(int index, const char* value) {
  labelsui_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.FilterProperties.ControlDescription.labelsUi)
}
inline void FilterProperties_ControlDescription::set_labelsui(int index, const char* value, size_t size) {
  labelsui_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.FilterProperties.ControlDescription.labelsUi)
}
inline ::std::string* FilterProperties_ControlDescription::add_labelsui() {
  return labelsui_.Add();
}
inline void FilterProperties_ControlDescription::add_labelsui(const ::std::string& value) {
  labelsui_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:AnselIpc.FilterProperties.ControlDescription.labelsUi)
}
inline void FilterProperties_ControlDescription::add_labelsui(const char* value) {
  labelsui_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:AnselIpc.FilterProperties.ControlDescription.labelsUi)
}
inline void FilterProperties_ControlDescription::add_labelsui(const char* value, size_t size) {
  labelsui_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:AnselIpc.FilterProperties.ControlDescription.labelsUi)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FilterProperties_ControlDescription::labelsui() const {
  // @@protoc_insertion_point(field_list:AnselIpc.FilterProperties.ControlDescription.labelsUi)
  return labelsui_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FilterProperties_ControlDescription::mutable_labelsui() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.FilterProperties.ControlDescription.labelsUi)
  return &labelsui_;
}

// optional string tooltip = 13;
inline bool FilterProperties_ControlDescription::has_tooltip() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void FilterProperties_ControlDescription::set_has_tooltip() {
  _has_bits_[0] |= 0x00001000u;
}
inline void FilterProperties_ControlDescription::clear_has_tooltip() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void FilterProperties_ControlDescription::clear_tooltip() {
  if (tooltip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tooltip_->clear();
  }
  clear_has_tooltip();
}
inline const ::std::string& FilterProperties_ControlDescription::tooltip() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ControlDescription.tooltip)
  return *tooltip_;
}
inline void FilterProperties_ControlDescription::set_tooltip(const ::std::string& value) {
  set_has_tooltip();
  if (tooltip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tooltip_ = new ::std::string;
  }
  tooltip_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ControlDescription.tooltip)
}
inline void FilterProperties_ControlDescription::set_tooltip(const char* value) {
  set_has_tooltip();
  if (tooltip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tooltip_ = new ::std::string;
  }
  tooltip_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.FilterProperties.ControlDescription.tooltip)
}
inline void FilterProperties_ControlDescription::set_tooltip(const char* value, size_t size) {
  set_has_tooltip();
  if (tooltip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tooltip_ = new ::std::string;
  }
  tooltip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.FilterProperties.ControlDescription.tooltip)
}
inline ::std::string* FilterProperties_ControlDescription::mutable_tooltip() {
  set_has_tooltip();
  if (tooltip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tooltip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.FilterProperties.ControlDescription.tooltip)
  return tooltip_;
}
inline ::std::string* FilterProperties_ControlDescription::release_tooltip() {
  clear_has_tooltip();
  if (tooltip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tooltip_;
    tooltip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FilterProperties_ControlDescription::set_allocated_tooltip(::std::string* tooltip) {
  if (tooltip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tooltip_;
  }
  if (tooltip) {
    set_has_tooltip();
    tooltip_ = tooltip;
  } else {
    clear_has_tooltip();
    tooltip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.FilterProperties.ControlDescription.tooltip)
}

// optional string displayNameEnglish = 14;
inline bool FilterProperties_ControlDescription::has_displaynameenglish() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void FilterProperties_ControlDescription::set_has_displaynameenglish() {
  _has_bits_[0] |= 0x00002000u;
}
inline void FilterProperties_ControlDescription::clear_has_displaynameenglish() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void FilterProperties_ControlDescription::clear_displaynameenglish() {
  if (displaynameenglish_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displaynameenglish_->clear();
  }
  clear_has_displaynameenglish();
}
inline const ::std::string& FilterProperties_ControlDescription::displaynameenglish() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.ControlDescription.displayNameEnglish)
  return *displaynameenglish_;
}
inline void FilterProperties_ControlDescription::set_displaynameenglish(const ::std::string& value) {
  set_has_displaynameenglish();
  if (displaynameenglish_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displaynameenglish_ = new ::std::string;
  }
  displaynameenglish_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.ControlDescription.displayNameEnglish)
}
inline void FilterProperties_ControlDescription::set_displaynameenglish(const char* value) {
  set_has_displaynameenglish();
  if (displaynameenglish_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displaynameenglish_ = new ::std::string;
  }
  displaynameenglish_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.FilterProperties.ControlDescription.displayNameEnglish)
}
inline void FilterProperties_ControlDescription::set_displaynameenglish(const char* value, size_t size) {
  set_has_displaynameenglish();
  if (displaynameenglish_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displaynameenglish_ = new ::std::string;
  }
  displaynameenglish_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.FilterProperties.ControlDescription.displayNameEnglish)
}
inline ::std::string* FilterProperties_ControlDescription::mutable_displaynameenglish() {
  set_has_displaynameenglish();
  if (displaynameenglish_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    displaynameenglish_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.FilterProperties.ControlDescription.displayNameEnglish)
  return displaynameenglish_;
}
inline ::std::string* FilterProperties_ControlDescription::release_displaynameenglish() {
  clear_has_displaynameenglish();
  if (displaynameenglish_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = displaynameenglish_;
    displaynameenglish_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FilterProperties_ControlDescription::set_allocated_displaynameenglish(::std::string* displaynameenglish) {
  if (displaynameenglish_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete displaynameenglish_;
  }
  if (displaynameenglish) {
    set_has_displaynameenglish();
    displaynameenglish_ = displaynameenglish;
  } else {
    clear_has_displaynameenglish();
    displaynameenglish_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.FilterProperties.ControlDescription.displayNameEnglish)
}

// -------------------------------------------------------------------

// FilterProperties

// required string filterId = 1;
inline bool FilterProperties::has_filterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterProperties::set_has_filterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterProperties::clear_has_filterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterProperties::clear_filterid() {
  if (filterid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_->clear();
  }
  clear_has_filterid();
}
inline const ::std::string& FilterProperties::filterid() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.filterId)
  return *filterid_;
}
inline void FilterProperties::set_filterid(const ::std::string& value) {
  set_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_ = new ::std::string;
  }
  filterid_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.filterId)
}
inline void FilterProperties::set_filterid(const char* value) {
  set_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_ = new ::std::string;
  }
  filterid_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.FilterProperties.filterId)
}
inline void FilterProperties::set_filterid(const char* value, size_t size) {
  set_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_ = new ::std::string;
  }
  filterid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.FilterProperties.filterId)
}
inline ::std::string* FilterProperties::mutable_filterid() {
  set_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.FilterProperties.filterId)
  return filterid_;
}
inline ::std::string* FilterProperties::release_filterid() {
  clear_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filterid_;
    filterid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FilterProperties::set_allocated_filterid(::std::string* filterid) {
  if (filterid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filterid_;
  }
  if (filterid) {
    set_has_filterid();
    filterid_ = filterid;
  } else {
    clear_has_filterid();
    filterid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.FilterProperties.filterId)
}

// required string filterDisplayName = 2;
inline bool FilterProperties::has_filterdisplayname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FilterProperties::set_has_filterdisplayname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FilterProperties::clear_has_filterdisplayname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FilterProperties::clear_filterdisplayname() {
  if (filterdisplayname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterdisplayname_->clear();
  }
  clear_has_filterdisplayname();
}
inline const ::std::string& FilterProperties::filterdisplayname() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.filterDisplayName)
  return *filterdisplayname_;
}
inline void FilterProperties::set_filterdisplayname(const ::std::string& value) {
  set_has_filterdisplayname();
  if (filterdisplayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterdisplayname_ = new ::std::string;
  }
  filterdisplayname_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.filterDisplayName)
}
inline void FilterProperties::set_filterdisplayname(const char* value) {
  set_has_filterdisplayname();
  if (filterdisplayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterdisplayname_ = new ::std::string;
  }
  filterdisplayname_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.FilterProperties.filterDisplayName)
}
inline void FilterProperties::set_filterdisplayname(const char* value, size_t size) {
  set_has_filterdisplayname();
  if (filterdisplayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterdisplayname_ = new ::std::string;
  }
  filterdisplayname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.FilterProperties.filterDisplayName)
}
inline ::std::string* FilterProperties::mutable_filterdisplayname() {
  set_has_filterdisplayname();
  if (filterdisplayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterdisplayname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.FilterProperties.filterDisplayName)
  return filterdisplayname_;
}
inline ::std::string* FilterProperties::release_filterdisplayname() {
  clear_has_filterdisplayname();
  if (filterdisplayname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filterdisplayname_;
    filterdisplayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FilterProperties::set_allocated_filterdisplayname(::std::string* filterdisplayname) {
  if (filterdisplayname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filterdisplayname_;
  }
  if (filterdisplayname) {
    set_has_filterdisplayname();
    filterdisplayname_ = filterdisplayname;
  } else {
    clear_has_filterdisplayname();
    filterdisplayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.FilterProperties.filterDisplayName)
}

// repeated .AnselIpc.FilterProperties.ControlDescription controls = 3;
inline int FilterProperties::controls_size() const {
  return controls_.size();
}
inline void FilterProperties::clear_controls() {
  controls_.Clear();
}
inline const ::AnselIpc::FilterProperties_ControlDescription& FilterProperties::controls(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.controls)
  return controls_.Get(index);
}
inline ::AnselIpc::FilterProperties_ControlDescription* FilterProperties::mutable_controls(int index) {
  // @@protoc_insertion_point(field_mutable:AnselIpc.FilterProperties.controls)
  return controls_.Mutable(index);
}
inline ::AnselIpc::FilterProperties_ControlDescription* FilterProperties::add_controls() {
  // @@protoc_insertion_point(field_add:AnselIpc.FilterProperties.controls)
  return controls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ControlDescription >&
FilterProperties::controls() const {
  // @@protoc_insertion_point(field_list:AnselIpc.FilterProperties.controls)
  return controls_;
}
inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::FilterProperties_ControlDescription >*
FilterProperties::mutable_controls() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.FilterProperties.controls)
  return &controls_;
}

// optional string filterDisplayNameEnglish = 4;
inline bool FilterProperties::has_filterdisplaynameenglish() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FilterProperties::set_has_filterdisplaynameenglish() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FilterProperties::clear_has_filterdisplaynameenglish() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FilterProperties::clear_filterdisplaynameenglish() {
  if (filterdisplaynameenglish_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterdisplaynameenglish_->clear();
  }
  clear_has_filterdisplaynameenglish();
}
inline const ::std::string& FilterProperties::filterdisplaynameenglish() const {
  // @@protoc_insertion_point(field_get:AnselIpc.FilterProperties.filterDisplayNameEnglish)
  return *filterdisplaynameenglish_;
}
inline void FilterProperties::set_filterdisplaynameenglish(const ::std::string& value) {
  set_has_filterdisplaynameenglish();
  if (filterdisplaynameenglish_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterdisplaynameenglish_ = new ::std::string;
  }
  filterdisplaynameenglish_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.FilterProperties.filterDisplayNameEnglish)
}
inline void FilterProperties::set_filterdisplaynameenglish(const char* value) {
  set_has_filterdisplaynameenglish();
  if (filterdisplaynameenglish_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterdisplaynameenglish_ = new ::std::string;
  }
  filterdisplaynameenglish_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.FilterProperties.filterDisplayNameEnglish)
}
inline void FilterProperties::set_filterdisplaynameenglish(const char* value, size_t size) {
  set_has_filterdisplaynameenglish();
  if (filterdisplaynameenglish_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterdisplaynameenglish_ = new ::std::string;
  }
  filterdisplaynameenglish_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.FilterProperties.filterDisplayNameEnglish)
}
inline ::std::string* FilterProperties::mutable_filterdisplaynameenglish() {
  set_has_filterdisplaynameenglish();
  if (filterdisplaynameenglish_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterdisplaynameenglish_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.FilterProperties.filterDisplayNameEnglish)
  return filterdisplaynameenglish_;
}
inline ::std::string* FilterProperties::release_filterdisplaynameenglish() {
  clear_has_filterdisplaynameenglish();
  if (filterdisplaynameenglish_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filterdisplaynameenglish_;
    filterdisplaynameenglish_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FilterProperties::set_allocated_filterdisplaynameenglish(::std::string* filterdisplaynameenglish) {
  if (filterdisplaynameenglish_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filterdisplaynameenglish_;
  }
  if (filterdisplaynameenglish) {
    set_has_filterdisplaynameenglish();
    filterdisplaynameenglish_ = filterdisplaynameenglish;
  } else {
    clear_has_filterdisplaynameenglish();
    filterdisplaynameenglish_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.FilterProperties.filterDisplayNameEnglish)
}

// -------------------------------------------------------------------

// GetFilterInfoRequest

// required int32 stackIdx = 1;
inline bool GetFilterInfoRequest::has_stackidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFilterInfoRequest::set_has_stackidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFilterInfoRequest::clear_has_stackidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFilterInfoRequest::clear_stackidx() {
  stackidx_ = 0;
  clear_has_stackidx();
}
inline ::google::protobuf::int32 GetFilterInfoRequest::stackidx() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetFilterInfoRequest.stackIdx)
  return stackidx_;
}
inline void GetFilterInfoRequest::set_stackidx(::google::protobuf::int32 value) {
  set_has_stackidx();
  stackidx_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetFilterInfoRequest.stackIdx)
}

// -------------------------------------------------------------------

// GetFilterInfoResponse

// required .AnselIpc.Status status = 1;
inline bool GetFilterInfoResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFilterInfoResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFilterInfoResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFilterInfoResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status GetFilterInfoResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetFilterInfoResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void GetFilterInfoResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetFilterInfoResponse.status)
}

// required int32 stackIdx = 2;
inline bool GetFilterInfoResponse::has_stackidx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetFilterInfoResponse::set_has_stackidx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetFilterInfoResponse::clear_has_stackidx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetFilterInfoResponse::clear_stackidx() {
  stackidx_ = 0;
  clear_has_stackidx();
}
inline ::google::protobuf::int32 GetFilterInfoResponse::stackidx() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetFilterInfoResponse.stackIdx)
  return stackidx_;
}
inline void GetFilterInfoResponse::set_stackidx(::google::protobuf::int32 value) {
  set_has_stackidx();
  stackidx_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.GetFilterInfoResponse.stackIdx)
}

// optional .AnselIpc.FilterProperties filterProperties = 3;
inline bool GetFilterInfoResponse::has_filterproperties() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetFilterInfoResponse::set_has_filterproperties() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetFilterInfoResponse::clear_has_filterproperties() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetFilterInfoResponse::clear_filterproperties() {
  if (filterproperties_ != NULL) filterproperties_->::AnselIpc::FilterProperties::Clear();
  clear_has_filterproperties();
}
inline const ::AnselIpc::FilterProperties& GetFilterInfoResponse::filterproperties() const {
  // @@protoc_insertion_point(field_get:AnselIpc.GetFilterInfoResponse.filterProperties)
  return filterproperties_ != NULL ? *filterproperties_ : *default_instance_->filterproperties_;
}
inline ::AnselIpc::FilterProperties* GetFilterInfoResponse::mutable_filterproperties() {
  set_has_filterproperties();
  if (filterproperties_ == NULL) filterproperties_ = new ::AnselIpc::FilterProperties;
  // @@protoc_insertion_point(field_mutable:AnselIpc.GetFilterInfoResponse.filterProperties)
  return filterproperties_;
}
inline ::AnselIpc::FilterProperties* GetFilterInfoResponse::release_filterproperties() {
  clear_has_filterproperties();
  ::AnselIpc::FilterProperties* temp = filterproperties_;
  filterproperties_ = NULL;
  return temp;
}
inline void GetFilterInfoResponse::set_allocated_filterproperties(::AnselIpc::FilterProperties* filterproperties) {
  delete filterproperties_;
  filterproperties_ = filterproperties;
  if (filterproperties) {
    set_has_filterproperties();
  } else {
    clear_has_filterproperties();
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.GetFilterInfoResponse.filterProperties)
}

// -------------------------------------------------------------------

// IsAnselAvailableRequest

// -------------------------------------------------------------------

// IsAnselAvailableResponse

// required bool available = 1;
inline bool IsAnselAvailableResponse::has_available() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IsAnselAvailableResponse::set_has_available() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IsAnselAvailableResponse::clear_has_available() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IsAnselAvailableResponse::clear_available() {
  available_ = false;
  clear_has_available();
}
inline bool IsAnselAvailableResponse::available() const {
  // @@protoc_insertion_point(field_get:AnselIpc.IsAnselAvailableResponse.available)
  return available_;
}
inline void IsAnselAvailableResponse::set_available(bool value) {
  set_has_available();
  available_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.IsAnselAvailableResponse.available)
}

// -------------------------------------------------------------------

// SetFilterAttributeRequest

// required string filterId = 1;
inline bool SetFilterAttributeRequest::has_filterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetFilterAttributeRequest::set_has_filterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetFilterAttributeRequest::clear_has_filterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetFilterAttributeRequest::clear_filterid() {
  if (filterid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_->clear();
  }
  clear_has_filterid();
}
inline const ::std::string& SetFilterAttributeRequest::filterid() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterAttributeRequest.filterId)
  return *filterid_;
}
inline void SetFilterAttributeRequest::set_filterid(const ::std::string& value) {
  set_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_ = new ::std::string;
  }
  filterid_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterAttributeRequest.filterId)
}
inline void SetFilterAttributeRequest::set_filterid(const char* value) {
  set_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_ = new ::std::string;
  }
  filterid_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.SetFilterAttributeRequest.filterId)
}
inline void SetFilterAttributeRequest::set_filterid(const char* value, size_t size) {
  set_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_ = new ::std::string;
  }
  filterid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.SetFilterAttributeRequest.filterId)
}
inline ::std::string* SetFilterAttributeRequest::mutable_filterid() {
  set_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filterid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.SetFilterAttributeRequest.filterId)
  return filterid_;
}
inline ::std::string* SetFilterAttributeRequest::release_filterid() {
  clear_has_filterid();
  if (filterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filterid_;
    filterid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetFilterAttributeRequest::set_allocated_filterid(::std::string* filterid) {
  if (filterid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filterid_;
  }
  if (filterid) {
    set_has_filterid();
    filterid_ = filterid;
  } else {
    clear_has_filterid();
    filterid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.SetFilterAttributeRequest.filterId)
}

// required int32 stackIdx = 2;
inline bool SetFilterAttributeRequest::has_stackidx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetFilterAttributeRequest::set_has_stackidx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetFilterAttributeRequest::clear_has_stackidx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetFilterAttributeRequest::clear_stackidx() {
  stackidx_ = 0;
  clear_has_stackidx();
}
inline ::google::protobuf::int32 SetFilterAttributeRequest::stackidx() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterAttributeRequest.stackIdx)
  return stackidx_;
}
inline void SetFilterAttributeRequest::set_stackidx(::google::protobuf::int32 value) {
  set_has_stackidx();
  stackidx_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterAttributeRequest.stackIdx)
}

// required int32 controlId = 3;
inline bool SetFilterAttributeRequest::has_controlid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetFilterAttributeRequest::set_has_controlid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetFilterAttributeRequest::clear_has_controlid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetFilterAttributeRequest::clear_controlid() {
  controlid_ = 0;
  clear_has_controlid();
}
inline ::google::protobuf::int32 SetFilterAttributeRequest::controlid() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterAttributeRequest.controlId)
  return controlid_;
}
inline void SetFilterAttributeRequest::set_controlid(::google::protobuf::int32 value) {
  set_has_controlid();
  controlid_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterAttributeRequest.controlId)
}

// repeated float floatValue = 4;
inline int SetFilterAttributeRequest::floatvalue_size() const {
  return floatvalue_.size();
}
inline void SetFilterAttributeRequest::clear_floatvalue() {
  floatvalue_.Clear();
}
inline float SetFilterAttributeRequest::floatvalue(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterAttributeRequest.floatValue)
  return floatvalue_.Get(index);
}
inline void SetFilterAttributeRequest::set_floatvalue(int index, float value) {
  floatvalue_.Set(index, value);
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterAttributeRequest.floatValue)
}
inline void SetFilterAttributeRequest::add_floatvalue(float value) {
  floatvalue_.Add(value);
  // @@protoc_insertion_point(field_add:AnselIpc.SetFilterAttributeRequest.floatValue)
}
inline const ::google::protobuf::RepeatedField< float >&
SetFilterAttributeRequest::floatvalue() const {
  // @@protoc_insertion_point(field_list:AnselIpc.SetFilterAttributeRequest.floatValue)
  return floatvalue_;
}
inline ::google::protobuf::RepeatedField< float >*
SetFilterAttributeRequest::mutable_floatvalue() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.SetFilterAttributeRequest.floatValue)
  return &floatvalue_;
}

// repeated bool boolValue = 5;
inline int SetFilterAttributeRequest::boolvalue_size() const {
  return boolvalue_.size();
}
inline void SetFilterAttributeRequest::clear_boolvalue() {
  boolvalue_.Clear();
}
inline bool SetFilterAttributeRequest::boolvalue(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterAttributeRequest.boolValue)
  return boolvalue_.Get(index);
}
inline void SetFilterAttributeRequest::set_boolvalue(int index, bool value) {
  boolvalue_.Set(index, value);
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterAttributeRequest.boolValue)
}
inline void SetFilterAttributeRequest::add_boolvalue(bool value) {
  boolvalue_.Add(value);
  // @@protoc_insertion_point(field_add:AnselIpc.SetFilterAttributeRequest.boolValue)
}
inline const ::google::protobuf::RepeatedField< bool >&
SetFilterAttributeRequest::boolvalue() const {
  // @@protoc_insertion_point(field_list:AnselIpc.SetFilterAttributeRequest.boolValue)
  return boolvalue_;
}
inline ::google::protobuf::RepeatedField< bool >*
SetFilterAttributeRequest::mutable_boolvalue() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.SetFilterAttributeRequest.boolValue)
  return &boolvalue_;
}

// repeated uint32 uintValue = 6;
inline int SetFilterAttributeRequest::uintvalue_size() const {
  return uintvalue_.size();
}
inline void SetFilterAttributeRequest::clear_uintvalue() {
  uintvalue_.Clear();
}
inline ::google::protobuf::uint32 SetFilterAttributeRequest::uintvalue(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterAttributeRequest.uintValue)
  return uintvalue_.Get(index);
}
inline void SetFilterAttributeRequest::set_uintvalue(int index, ::google::protobuf::uint32 value) {
  uintvalue_.Set(index, value);
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterAttributeRequest.uintValue)
}
inline void SetFilterAttributeRequest::add_uintvalue(::google::protobuf::uint32 value) {
  uintvalue_.Add(value);
  // @@protoc_insertion_point(field_add:AnselIpc.SetFilterAttributeRequest.uintValue)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SetFilterAttributeRequest::uintvalue() const {
  // @@protoc_insertion_point(field_list:AnselIpc.SetFilterAttributeRequest.uintValue)
  return uintvalue_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SetFilterAttributeRequest::mutable_uintvalue() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.SetFilterAttributeRequest.uintValue)
  return &uintvalue_;
}

// repeated int32 intValue = 7;
inline int SetFilterAttributeRequest::intvalue_size() const {
  return intvalue_.size();
}
inline void SetFilterAttributeRequest::clear_intvalue() {
  intvalue_.Clear();
}
inline ::google::protobuf::int32 SetFilterAttributeRequest::intvalue(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterAttributeRequest.intValue)
  return intvalue_.Get(index);
}
inline void SetFilterAttributeRequest::set_intvalue(int index, ::google::protobuf::int32 value) {
  intvalue_.Set(index, value);
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterAttributeRequest.intValue)
}
inline void SetFilterAttributeRequest::add_intvalue(::google::protobuf::int32 value) {
  intvalue_.Add(value);
  // @@protoc_insertion_point(field_add:AnselIpc.SetFilterAttributeRequest.intValue)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SetFilterAttributeRequest::intvalue() const {
  // @@protoc_insertion_point(field_list:AnselIpc.SetFilterAttributeRequest.intValue)
  return intvalue_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SetFilterAttributeRequest::mutable_intvalue() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.SetFilterAttributeRequest.intValue)
  return &intvalue_;
}

// -------------------------------------------------------------------

// SetFilterAttributeResponse

// required .AnselIpc.Status status = 1;
inline bool SetFilterAttributeResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetFilterAttributeResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetFilterAttributeResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetFilterAttributeResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status SetFilterAttributeResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetFilterAttributeResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void SetFilterAttributeResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetFilterAttributeResponse.status)
}

// -------------------------------------------------------------------

// MouseEventRequest

// optional float absoluteX = 1;
inline bool MouseEventRequest::has_absolutex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MouseEventRequest::set_has_absolutex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MouseEventRequest::clear_has_absolutex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MouseEventRequest::clear_absolutex() {
  absolutex_ = 0;
  clear_has_absolutex();
}
inline float MouseEventRequest::absolutex() const {
  // @@protoc_insertion_point(field_get:AnselIpc.MouseEventRequest.absoluteX)
  return absolutex_;
}
inline void MouseEventRequest::set_absolutex(float value) {
  set_has_absolutex();
  absolutex_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.MouseEventRequest.absoluteX)
}

// optional float absoluteY = 2;
inline bool MouseEventRequest::has_absolutey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MouseEventRequest::set_has_absolutey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MouseEventRequest::clear_has_absolutey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MouseEventRequest::clear_absolutey() {
  absolutey_ = 0;
  clear_has_absolutey();
}
inline float MouseEventRequest::absolutey() const {
  // @@protoc_insertion_point(field_get:AnselIpc.MouseEventRequest.absoluteY)
  return absolutey_;
}
inline void MouseEventRequest::set_absolutey(float value) {
  set_has_absolutey();
  absolutey_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.MouseEventRequest.absoluteY)
}

// optional float deltaX = 3;
inline bool MouseEventRequest::has_deltax() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MouseEventRequest::set_has_deltax() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MouseEventRequest::clear_has_deltax() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MouseEventRequest::clear_deltax() {
  deltax_ = 0;
  clear_has_deltax();
}
inline float MouseEventRequest::deltax() const {
  // @@protoc_insertion_point(field_get:AnselIpc.MouseEventRequest.deltaX)
  return deltax_;
}
inline void MouseEventRequest::set_deltax(float value) {
  set_has_deltax();
  deltax_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.MouseEventRequest.deltaX)
}

// optional float deltaY = 4;
inline bool MouseEventRequest::has_deltay() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MouseEventRequest::set_has_deltay() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MouseEventRequest::clear_has_deltay() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MouseEventRequest::clear_deltay() {
  deltay_ = 0;
  clear_has_deltay();
}
inline float MouseEventRequest::deltay() const {
  // @@protoc_insertion_point(field_get:AnselIpc.MouseEventRequest.deltaY)
  return deltay_;
}
inline void MouseEventRequest::set_deltay(float value) {
  set_has_deltay();
  deltay_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.MouseEventRequest.deltaY)
}

// required int32 keyState = 5;
inline bool MouseEventRequest::has_keystate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MouseEventRequest::set_has_keystate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MouseEventRequest::clear_has_keystate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MouseEventRequest::clear_keystate() {
  keystate_ = 0;
  clear_has_keystate();
}
inline ::google::protobuf::int32 MouseEventRequest::keystate() const {
  // @@protoc_insertion_point(field_get:AnselIpc.MouseEventRequest.keyState)
  return keystate_;
}
inline void MouseEventRequest::set_keystate(::google::protobuf::int32 value) {
  set_has_keystate();
  keystate_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.MouseEventRequest.keyState)
}

// -------------------------------------------------------------------

// KeyboardEventRequest

// required int32 key = 1;
inline bool KeyboardEventRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyboardEventRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyboardEventRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyboardEventRequest::clear_key() {
  key_ = 0;
  clear_has_key();
}
inline ::google::protobuf::int32 KeyboardEventRequest::key() const {
  // @@protoc_insertion_point(field_get:AnselIpc.KeyboardEventRequest.key)
  return key_;
}
inline void KeyboardEventRequest::set_key(::google::protobuf::int32 value) {
  set_has_key();
  key_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.KeyboardEventRequest.key)
}

// required .AnselIpc.State state = 2;
inline bool KeyboardEventRequest::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyboardEventRequest::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyboardEventRequest::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyboardEventRequest::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::AnselIpc::State KeyboardEventRequest::state() const {
  // @@protoc_insertion_point(field_get:AnselIpc.KeyboardEventRequest.state)
  return static_cast< ::AnselIpc::State >(state_);
}
inline void KeyboardEventRequest::set_state(::AnselIpc::State value) {
  assert(::AnselIpc::State_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.KeyboardEventRequest.state)
}

// -------------------------------------------------------------------

// InputEventRequest

// required int32 message = 1;
inline bool InputEventRequest::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InputEventRequest::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InputEventRequest::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InputEventRequest::clear_message() {
  message_ = 0;
  clear_has_message();
}
inline ::google::protobuf::int32 InputEventRequest::message() const {
  // @@protoc_insertion_point(field_get:AnselIpc.InputEventRequest.message)
  return message_;
}
inline void InputEventRequest::set_message(::google::protobuf::int32 value) {
  set_has_message();
  message_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.InputEventRequest.message)
}

// required int32 wParam = 2;
inline bool InputEventRequest::has_wparam() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InputEventRequest::set_has_wparam() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InputEventRequest::clear_has_wparam() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InputEventRequest::clear_wparam() {
  wparam_ = 0;
  clear_has_wparam();
}
inline ::google::protobuf::int32 InputEventRequest::wparam() const {
  // @@protoc_insertion_point(field_get:AnselIpc.InputEventRequest.wParam)
  return wparam_;
}
inline void InputEventRequest::set_wparam(::google::protobuf::int32 value) {
  set_has_wparam();
  wparam_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.InputEventRequest.wParam)
}

// required int32 lParam = 3;
inline bool InputEventRequest::has_lparam() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InputEventRequest::set_has_lparam() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InputEventRequest::clear_has_lparam() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InputEventRequest::clear_lparam() {
  lparam_ = 0;
  clear_has_lparam();
}
inline ::google::protobuf::int32 InputEventRequest::lparam() const {
  // @@protoc_insertion_point(field_get:AnselIpc.InputEventRequest.lParam)
  return lparam_;
}
inline void InputEventRequest::set_lparam(::google::protobuf::int32 value) {
  set_has_lparam();
  lparam_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.InputEventRequest.lParam)
}

// optional bool isDeltaCoords = 4;
inline bool InputEventRequest::has_isdeltacoords() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InputEventRequest::set_has_isdeltacoords() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InputEventRequest::clear_has_isdeltacoords() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InputEventRequest::clear_isdeltacoords() {
  isdeltacoords_ = false;
  clear_has_isdeltacoords();
}
inline bool InputEventRequest::isdeltacoords() const {
  // @@protoc_insertion_point(field_get:AnselIpc.InputEventRequest.isDeltaCoords)
  return isdeltacoords_;
}
inline void InputEventRequest::set_isdeltacoords(bool value) {
  set_has_isdeltacoords();
  isdeltacoords_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.InputEventRequest.isDeltaCoords)
}

// optional float leftStickXValue = 5;
inline bool InputEventRequest::has_leftstickxvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InputEventRequest::set_has_leftstickxvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InputEventRequest::clear_has_leftstickxvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InputEventRequest::clear_leftstickxvalue() {
  leftstickxvalue_ = 0;
  clear_has_leftstickxvalue();
}
inline float InputEventRequest::leftstickxvalue() const {
  // @@protoc_insertion_point(field_get:AnselIpc.InputEventRequest.leftStickXValue)
  return leftstickxvalue_;
}
inline void InputEventRequest::set_leftstickxvalue(float value) {
  set_has_leftstickxvalue();
  leftstickxvalue_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.InputEventRequest.leftStickXValue)
}

// optional float leftStickYValue = 6;
inline bool InputEventRequest::has_leftstickyvalue() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InputEventRequest::set_has_leftstickyvalue() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InputEventRequest::clear_has_leftstickyvalue() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InputEventRequest::clear_leftstickyvalue() {
  leftstickyvalue_ = 0;
  clear_has_leftstickyvalue();
}
inline float InputEventRequest::leftstickyvalue() const {
  // @@protoc_insertion_point(field_get:AnselIpc.InputEventRequest.leftStickYValue)
  return leftstickyvalue_;
}
inline void InputEventRequest::set_leftstickyvalue(float value) {
  set_has_leftstickyvalue();
  leftstickyvalue_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.InputEventRequest.leftStickYValue)
}

// optional float rightStickXValue = 7;
inline bool InputEventRequest::has_rightstickxvalue() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InputEventRequest::set_has_rightstickxvalue() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InputEventRequest::clear_has_rightstickxvalue() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InputEventRequest::clear_rightstickxvalue() {
  rightstickxvalue_ = 0;
  clear_has_rightstickxvalue();
}
inline float InputEventRequest::rightstickxvalue() const {
  // @@protoc_insertion_point(field_get:AnselIpc.InputEventRequest.rightStickXValue)
  return rightstickxvalue_;
}
inline void InputEventRequest::set_rightstickxvalue(float value) {
  set_has_rightstickxvalue();
  rightstickxvalue_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.InputEventRequest.rightStickXValue)
}

// optional float rightStickYValue = 8;
inline bool InputEventRequest::has_rightstickyvalue() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InputEventRequest::set_has_rightstickyvalue() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InputEventRequest::clear_has_rightstickyvalue() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InputEventRequest::clear_rightstickyvalue() {
  rightstickyvalue_ = 0;
  clear_has_rightstickyvalue();
}
inline float InputEventRequest::rightstickyvalue() const {
  // @@protoc_insertion_point(field_get:AnselIpc.InputEventRequest.rightStickYValue)
  return rightstickyvalue_;
}
inline void InputEventRequest::set_rightstickyvalue(float value) {
  set_has_rightstickyvalue();
  rightstickyvalue_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.InputEventRequest.rightStickYValue)
}

// optional float leftTriggerValue = 9;
inline bool InputEventRequest::has_lefttriggervalue() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InputEventRequest::set_has_lefttriggervalue() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InputEventRequest::clear_has_lefttriggervalue() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InputEventRequest::clear_lefttriggervalue() {
  lefttriggervalue_ = 0;
  clear_has_lefttriggervalue();
}
inline float InputEventRequest::lefttriggervalue() const {
  // @@protoc_insertion_point(field_get:AnselIpc.InputEventRequest.leftTriggerValue)
  return lefttriggervalue_;
}
inline void InputEventRequest::set_lefttriggervalue(float value) {
  set_has_lefttriggervalue();
  lefttriggervalue_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.InputEventRequest.leftTriggerValue)
}

// optional float rightTriggerValue = 10;
inline bool InputEventRequest::has_righttriggervalue() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void InputEventRequest::set_has_righttriggervalue() {
  _has_bits_[0] |= 0x00000200u;
}
inline void InputEventRequest::clear_has_righttriggervalue() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void InputEventRequest::clear_righttriggervalue() {
  righttriggervalue_ = 0;
  clear_has_righttriggervalue();
}
inline float InputEventRequest::righttriggervalue() const {
  // @@protoc_insertion_point(field_get:AnselIpc.InputEventRequest.rightTriggerValue)
  return righttriggervalue_;
}
inline void InputEventRequest::set_righttriggervalue(float value) {
  set_has_righttriggervalue();
  righttriggervalue_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.InputEventRequest.rightTriggerValue)
}

// -------------------------------------------------------------------

// InputEventResponse

// required .AnselIpc.Status status = 1;
inline bool InputEventResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InputEventResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InputEventResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InputEventResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status InputEventResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.InputEventResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void InputEventResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.InputEventResponse.status)
}

// -------------------------------------------------------------------

// MultipleInputEventRequest

// repeated .AnselIpc.InputEventRequest inputEvents = 1;
inline int MultipleInputEventRequest::inputevents_size() const {
  return inputevents_.size();
}
inline void MultipleInputEventRequest::clear_inputevents() {
  inputevents_.Clear();
}
inline const ::AnselIpc::InputEventRequest& MultipleInputEventRequest::inputevents(int index) const {
  // @@protoc_insertion_point(field_get:AnselIpc.MultipleInputEventRequest.inputEvents)
  return inputevents_.Get(index);
}
inline ::AnselIpc::InputEventRequest* MultipleInputEventRequest::mutable_inputevents(int index) {
  // @@protoc_insertion_point(field_mutable:AnselIpc.MultipleInputEventRequest.inputEvents)
  return inputevents_.Mutable(index);
}
inline ::AnselIpc::InputEventRequest* MultipleInputEventRequest::add_inputevents() {
  // @@protoc_insertion_point(field_add:AnselIpc.MultipleInputEventRequest.inputEvents)
  return inputevents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AnselIpc::InputEventRequest >&
MultipleInputEventRequest::inputevents() const {
  // @@protoc_insertion_point(field_list:AnselIpc.MultipleInputEventRequest.inputEvents)
  return inputevents_;
}
inline ::google::protobuf::RepeatedPtrField< ::AnselIpc::InputEventRequest >*
MultipleInputEventRequest::mutable_inputevents() {
  // @@protoc_insertion_point(field_mutable_list:AnselIpc.MultipleInputEventRequest.inputEvents)
  return &inputevents_;
}

// -------------------------------------------------------------------

// LogFilenameResponse

// required string filename = 1;
inline bool LogFilenameResponse::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogFilenameResponse::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogFilenameResponse::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogFilenameResponse::clear_filename() {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& LogFilenameResponse::filename() const {
  // @@protoc_insertion_point(field_get:AnselIpc.LogFilenameResponse.filename)
  return *filename_;
}
inline void LogFilenameResponse::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.LogFilenameResponse.filename)
}
inline void LogFilenameResponse::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.LogFilenameResponse.filename)
}
inline void LogFilenameResponse::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.LogFilenameResponse.filename)
}
inline ::std::string* LogFilenameResponse::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.LogFilenameResponse.filename)
  return filename_;
}
inline ::std::string* LogFilenameResponse::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LogFilenameResponse::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.LogFilenameResponse.filename)
}

// -------------------------------------------------------------------

// ReportErrorResponse

// required .AnselIpc.ErrorType type = 1;
inline bool ReportErrorResponse::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReportErrorResponse::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReportErrorResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReportErrorResponse::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::AnselIpc::ErrorType ReportErrorResponse::type() const {
  // @@protoc_insertion_point(field_get:AnselIpc.ReportErrorResponse.type)
  return static_cast< ::AnselIpc::ErrorType >(type_);
}
inline void ReportErrorResponse::set_type(::AnselIpc::ErrorType value) {
  assert(::AnselIpc::ErrorType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.ReportErrorResponse.type)
}

// required uint32 code = 2;
inline bool ReportErrorResponse::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReportErrorResponse::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReportErrorResponse::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReportErrorResponse::clear_code() {
  code_ = 0u;
  clear_has_code();
}
inline ::google::protobuf::uint32 ReportErrorResponse::code() const {
  // @@protoc_insertion_point(field_get:AnselIpc.ReportErrorResponse.code)
  return code_;
}
inline void ReportErrorResponse::set_code(::google::protobuf::uint32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.ReportErrorResponse.code)
}

// required string filename = 3;
inline bool ReportErrorResponse::has_filename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReportErrorResponse::set_has_filename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReportErrorResponse::clear_has_filename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReportErrorResponse::clear_filename() {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& ReportErrorResponse::filename() const {
  // @@protoc_insertion_point(field_get:AnselIpc.ReportErrorResponse.filename)
  return *filename_;
}
inline void ReportErrorResponse::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.ReportErrorResponse.filename)
}
inline void ReportErrorResponse::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.ReportErrorResponse.filename)
}
inline void ReportErrorResponse::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.ReportErrorResponse.filename)
}
inline ::std::string* ReportErrorResponse::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.ReportErrorResponse.filename)
  return filename_;
}
inline ::std::string* ReportErrorResponse::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReportErrorResponse::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.ReportErrorResponse.filename)
}

// required uint32 line = 4;
inline bool ReportErrorResponse::has_line() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReportErrorResponse::set_has_line() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReportErrorResponse::clear_has_line() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReportErrorResponse::clear_line() {
  line_ = 0u;
  clear_has_line();
}
inline ::google::protobuf::uint32 ReportErrorResponse::line() const {
  // @@protoc_insertion_point(field_get:AnselIpc.ReportErrorResponse.line)
  return line_;
}
inline void ReportErrorResponse::set_line(::google::protobuf::uint32 value) {
  set_has_line();
  line_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.ReportErrorResponse.line)
}

// required string reason = 5;
inline bool ReportErrorResponse::has_reason() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReportErrorResponse::set_has_reason() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReportErrorResponse::clear_has_reason() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReportErrorResponse::clear_reason() {
  if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_->clear();
  }
  clear_has_reason();
}
inline const ::std::string& ReportErrorResponse::reason() const {
  // @@protoc_insertion_point(field_get:AnselIpc.ReportErrorResponse.reason)
  return *reason_;
}
inline void ReportErrorResponse::set_reason(const ::std::string& value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
  // @@protoc_insertion_point(field_set:AnselIpc.ReportErrorResponse.reason)
}
inline void ReportErrorResponse::set_reason(const char* value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
  // @@protoc_insertion_point(field_set_char:AnselIpc.ReportErrorResponse.reason)
}
inline void ReportErrorResponse::set_reason(const char* value, size_t size) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AnselIpc.ReportErrorResponse.reason)
}
inline ::std::string* ReportErrorResponse::mutable_reason() {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AnselIpc.ReportErrorResponse.reason)
  return reason_;
}
inline ::std::string* ReportErrorResponse::release_reason() {
  clear_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = reason_;
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReportErrorResponse::set_allocated_reason(::std::string* reason) {
  if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete reason_;
  }
  if (reason) {
    set_has_reason();
    reason_ = reason;
  } else {
    clear_has_reason();
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AnselIpc.ReportErrorResponse.reason)
}

// -------------------------------------------------------------------

// SetHighQualityRequest

// required bool setting = 1;
inline bool SetHighQualityRequest::has_setting() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetHighQualityRequest::set_has_setting() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetHighQualityRequest::clear_has_setting() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetHighQualityRequest::clear_setting() {
  setting_ = false;
  clear_has_setting();
}
inline bool SetHighQualityRequest::setting() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetHighQualityRequest.setting)
  return setting_;
}
inline void SetHighQualityRequest::set_setting(bool value) {
  set_has_setting();
  setting_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetHighQualityRequest.setting)
}

// -------------------------------------------------------------------

// SetHighQualityResponse

// required .AnselIpc.Status status = 1;
inline bool SetHighQualityResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetHighQualityResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetHighQualityResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetHighQualityResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::AnselIpc::Status SetHighQualityResponse::status() const {
  // @@protoc_insertion_point(field_get:AnselIpc.SetHighQualityResponse.status)
  return static_cast< ::AnselIpc::Status >(status_);
}
inline void SetHighQualityResponse::set_status(::AnselIpc::Status value) {
  assert(::AnselIpc::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AnselIpc.SetHighQualityResponse.status)
}

// -------------------------------------------------------------------

// AnselIPCRequest

// optional .AnselIpc.SetAnselEnabledRequest setAnselEnabledRequest = 1;
inline bool AnselIPCRequest::has_setanselenabledrequest() const {
  return request_case() == kSetAnselEnabledRequest;
}
inline void AnselIPCRequest::set_has_setanselenabledrequest() {
  _oneof_case_[0] = kSetAnselEnabledRequest;
}
inline void AnselIPCRequest::clear_setanselenabledrequest() {
  if (has_setanselenabledrequest()) {
    delete request_.setanselenabledrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::SetAnselEnabledRequest& AnselIPCRequest::setanselenabledrequest() const {
  return has_setanselenabledrequest() ? *request_.setanselenabledrequest_
                      : ::AnselIpc::SetAnselEnabledRequest::default_instance();
}
inline ::AnselIpc::SetAnselEnabledRequest* AnselIPCRequest::mutable_setanselenabledrequest() {
  if (!has_setanselenabledrequest()) {
    clear_request();
    set_has_setanselenabledrequest();
    request_.setanselenabledrequest_ = new ::AnselIpc::SetAnselEnabledRequest;
  }
  return request_.setanselenabledrequest_;
}
inline ::AnselIpc::SetAnselEnabledRequest* AnselIPCRequest::release_setanselenabledrequest() {
  if (has_setanselenabledrequest()) {
    clear_has_request();
    ::AnselIpc::SetAnselEnabledRequest* temp = request_.setanselenabledrequest_;
    request_.setanselenabledrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_setanselenabledrequest(::AnselIpc::SetAnselEnabledRequest* setanselenabledrequest) {
  clear_request();
  if (setanselenabledrequest) {
    set_has_setanselenabledrequest();
    request_.setanselenabledrequest_ = setanselenabledrequest;
  }
}

// optional .AnselIpc.CaptureShotRequest captureShotRequest = 2;
inline bool AnselIPCRequest::has_captureshotrequest() const {
  return request_case() == kCaptureShotRequest;
}
inline void AnselIPCRequest::set_has_captureshotrequest() {
  _oneof_case_[0] = kCaptureShotRequest;
}
inline void AnselIPCRequest::clear_captureshotrequest() {
  if (has_captureshotrequest()) {
    delete request_.captureshotrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::CaptureShotRequest& AnselIPCRequest::captureshotrequest() const {
  return has_captureshotrequest() ? *request_.captureshotrequest_
                      : ::AnselIpc::CaptureShotRequest::default_instance();
}
inline ::AnselIpc::CaptureShotRequest* AnselIPCRequest::mutable_captureshotrequest() {
  if (!has_captureshotrequest()) {
    clear_request();
    set_has_captureshotrequest();
    request_.captureshotrequest_ = new ::AnselIpc::CaptureShotRequest;
  }
  return request_.captureshotrequest_;
}
inline ::AnselIpc::CaptureShotRequest* AnselIPCRequest::release_captureshotrequest() {
  if (has_captureshotrequest()) {
    clear_has_request();
    ::AnselIpc::CaptureShotRequest* temp = request_.captureshotrequest_;
    request_.captureshotrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_captureshotrequest(::AnselIpc::CaptureShotRequest* captureshotrequest) {
  clear_request();
  if (captureshotrequest) {
    set_has_captureshotrequest();
    request_.captureshotrequest_ = captureshotrequest;
  }
}

// optional .AnselIpc.GetFilterListRequest getFilterListRequest = 3;
inline bool AnselIPCRequest::has_getfilterlistrequest() const {
  return request_case() == kGetFilterListRequest;
}
inline void AnselIPCRequest::set_has_getfilterlistrequest() {
  _oneof_case_[0] = kGetFilterListRequest;
}
inline void AnselIPCRequest::clear_getfilterlistrequest() {
  if (has_getfilterlistrequest()) {
    delete request_.getfilterlistrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::GetFilterListRequest& AnselIPCRequest::getfilterlistrequest() const {
  return has_getfilterlistrequest() ? *request_.getfilterlistrequest_
                      : ::AnselIpc::GetFilterListRequest::default_instance();
}
inline ::AnselIpc::GetFilterListRequest* AnselIPCRequest::mutable_getfilterlistrequest() {
  if (!has_getfilterlistrequest()) {
    clear_request();
    set_has_getfilterlistrequest();
    request_.getfilterlistrequest_ = new ::AnselIpc::GetFilterListRequest;
  }
  return request_.getfilterlistrequest_;
}
inline ::AnselIpc::GetFilterListRequest* AnselIPCRequest::release_getfilterlistrequest() {
  if (has_getfilterlistrequest()) {
    clear_has_request();
    ::AnselIpc::GetFilterListRequest* temp = request_.getfilterlistrequest_;
    request_.getfilterlistrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_getfilterlistrequest(::AnselIpc::GetFilterListRequest* getfilterlistrequest) {
  clear_request();
  if (getfilterlistrequest) {
    set_has_getfilterlistrequest();
    request_.getfilterlistrequest_ = getfilterlistrequest;
  }
}

// optional .AnselIpc.GetHighresResolutionListRequest getHighresResolutionListRequest = 4;
inline bool AnselIPCRequest::has_gethighresresolutionlistrequest() const {
  return request_case() == kGetHighresResolutionListRequest;
}
inline void AnselIPCRequest::set_has_gethighresresolutionlistrequest() {
  _oneof_case_[0] = kGetHighresResolutionListRequest;
}
inline void AnselIPCRequest::clear_gethighresresolutionlistrequest() {
  if (has_gethighresresolutionlistrequest()) {
    delete request_.gethighresresolutionlistrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::GetHighresResolutionListRequest& AnselIPCRequest::gethighresresolutionlistrequest() const {
  return has_gethighresresolutionlistrequest() ? *request_.gethighresresolutionlistrequest_
                      : ::AnselIpc::GetHighresResolutionListRequest::default_instance();
}
inline ::AnselIpc::GetHighresResolutionListRequest* AnselIPCRequest::mutable_gethighresresolutionlistrequest() {
  if (!has_gethighresresolutionlistrequest()) {
    clear_request();
    set_has_gethighresresolutionlistrequest();
    request_.gethighresresolutionlistrequest_ = new ::AnselIpc::GetHighresResolutionListRequest;
  }
  return request_.gethighresresolutionlistrequest_;
}
inline ::AnselIpc::GetHighresResolutionListRequest* AnselIPCRequest::release_gethighresresolutionlistrequest() {
  if (has_gethighresresolutionlistrequest()) {
    clear_has_request();
    ::AnselIpc::GetHighresResolutionListRequest* temp = request_.gethighresresolutionlistrequest_;
    request_.gethighresresolutionlistrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_gethighresresolutionlistrequest(::AnselIpc::GetHighresResolutionListRequest* gethighresresolutionlistrequest) {
  clear_request();
  if (gethighresresolutionlistrequest) {
    set_has_gethighresresolutionlistrequest();
    request_.gethighresresolutionlistrequest_ = gethighresresolutionlistrequest;
  }
}

// optional .AnselIpc.AbortCaptureRequest abortCaptureRequest = 5;
inline bool AnselIPCRequest::has_abortcapturerequest() const {
  return request_case() == kAbortCaptureRequest;
}
inline void AnselIPCRequest::set_has_abortcapturerequest() {
  _oneof_case_[0] = kAbortCaptureRequest;
}
inline void AnselIPCRequest::clear_abortcapturerequest() {
  if (has_abortcapturerequest()) {
    delete request_.abortcapturerequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::AbortCaptureRequest& AnselIPCRequest::abortcapturerequest() const {
  return has_abortcapturerequest() ? *request_.abortcapturerequest_
                      : ::AnselIpc::AbortCaptureRequest::default_instance();
}
inline ::AnselIpc::AbortCaptureRequest* AnselIPCRequest::mutable_abortcapturerequest() {
  if (!has_abortcapturerequest()) {
    clear_request();
    set_has_abortcapturerequest();
    request_.abortcapturerequest_ = new ::AnselIpc::AbortCaptureRequest;
  }
  return request_.abortcapturerequest_;
}
inline ::AnselIpc::AbortCaptureRequest* AnselIPCRequest::release_abortcapturerequest() {
  if (has_abortcapturerequest()) {
    clear_has_request();
    ::AnselIpc::AbortCaptureRequest* temp = request_.abortcapturerequest_;
    request_.abortcapturerequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_abortcapturerequest(::AnselIpc::AbortCaptureRequest* abortcapturerequest) {
  clear_request();
  if (abortcapturerequest) {
    set_has_abortcapturerequest();
    request_.abortcapturerequest_ = abortcapturerequest;
  }
}

// optional .AnselIpc.Get360ResolutionRangeRequest get360ResolutionRangeRequest = 6;
inline bool AnselIPCRequest::has_get360resolutionrangerequest() const {
  return request_case() == kGet360ResolutionRangeRequest;
}
inline void AnselIPCRequest::set_has_get360resolutionrangerequest() {
  _oneof_case_[0] = kGet360ResolutionRangeRequest;
}
inline void AnselIPCRequest::clear_get360resolutionrangerequest() {
  if (has_get360resolutionrangerequest()) {
    delete request_.get360resolutionrangerequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::Get360ResolutionRangeRequest& AnselIPCRequest::get360resolutionrangerequest() const {
  return has_get360resolutionrangerequest() ? *request_.get360resolutionrangerequest_
                      : ::AnselIpc::Get360ResolutionRangeRequest::default_instance();
}
inline ::AnselIpc::Get360ResolutionRangeRequest* AnselIPCRequest::mutable_get360resolutionrangerequest() {
  if (!has_get360resolutionrangerequest()) {
    clear_request();
    set_has_get360resolutionrangerequest();
    request_.get360resolutionrangerequest_ = new ::AnselIpc::Get360ResolutionRangeRequest;
  }
  return request_.get360resolutionrangerequest_;
}
inline ::AnselIpc::Get360ResolutionRangeRequest* AnselIPCRequest::release_get360resolutionrangerequest() {
  if (has_get360resolutionrangerequest()) {
    clear_has_request();
    ::AnselIpc::Get360ResolutionRangeRequest* temp = request_.get360resolutionrangerequest_;
    request_.get360resolutionrangerequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_get360resolutionrangerequest(::AnselIpc::Get360ResolutionRangeRequest* get360resolutionrangerequest) {
  clear_request();
  if (get360resolutionrangerequest) {
    set_has_get360resolutionrangerequest();
    request_.get360resolutionrangerequest_ = get360resolutionrangerequest;
  }
}

// optional .AnselIpc.GetFOVRangeRequest getFOVRangeRequest = 7;
inline bool AnselIPCRequest::has_getfovrangerequest() const {
  return request_case() == kGetFOVRangeRequest;
}
inline void AnselIPCRequest::set_has_getfovrangerequest() {
  _oneof_case_[0] = kGetFOVRangeRequest;
}
inline void AnselIPCRequest::clear_getfovrangerequest() {
  if (has_getfovrangerequest()) {
    delete request_.getfovrangerequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::GetFOVRangeRequest& AnselIPCRequest::getfovrangerequest() const {
  return has_getfovrangerequest() ? *request_.getfovrangerequest_
                      : ::AnselIpc::GetFOVRangeRequest::default_instance();
}
inline ::AnselIpc::GetFOVRangeRequest* AnselIPCRequest::mutable_getfovrangerequest() {
  if (!has_getfovrangerequest()) {
    clear_request();
    set_has_getfovrangerequest();
    request_.getfovrangerequest_ = new ::AnselIpc::GetFOVRangeRequest;
  }
  return request_.getfovrangerequest_;
}
inline ::AnselIpc::GetFOVRangeRequest* AnselIPCRequest::release_getfovrangerequest() {
  if (has_getfovrangerequest()) {
    clear_has_request();
    ::AnselIpc::GetFOVRangeRequest* temp = request_.getfovrangerequest_;
    request_.getfovrangerequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_getfovrangerequest(::AnselIpc::GetFOVRangeRequest* getfovrangerequest) {
  clear_request();
  if (getfovrangerequest) {
    set_has_getfovrangerequest();
    request_.getfovrangerequest_ = getfovrangerequest;
  }
}

// optional .AnselIpc.SetFOVRequest setFOVRequest = 8;
inline bool AnselIPCRequest::has_setfovrequest() const {
  return request_case() == kSetFOVRequest;
}
inline void AnselIPCRequest::set_has_setfovrequest() {
  _oneof_case_[0] = kSetFOVRequest;
}
inline void AnselIPCRequest::clear_setfovrequest() {
  if (has_setfovrequest()) {
    delete request_.setfovrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::SetFOVRequest& AnselIPCRequest::setfovrequest() const {
  return has_setfovrequest() ? *request_.setfovrequest_
                      : ::AnselIpc::SetFOVRequest::default_instance();
}
inline ::AnselIpc::SetFOVRequest* AnselIPCRequest::mutable_setfovrequest() {
  if (!has_setfovrequest()) {
    clear_request();
    set_has_setfovrequest();
    request_.setfovrequest_ = new ::AnselIpc::SetFOVRequest;
  }
  return request_.setfovrequest_;
}
inline ::AnselIpc::SetFOVRequest* AnselIPCRequest::release_setfovrequest() {
  if (has_setfovrequest()) {
    clear_has_request();
    ::AnselIpc::SetFOVRequest* temp = request_.setfovrequest_;
    request_.setfovrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_setfovrequest(::AnselIpc::SetFOVRequest* setfovrequest) {
  clear_request();
  if (setfovrequest) {
    set_has_setfovrequest();
    request_.setfovrequest_ = setfovrequest;
  }
}

// optional .AnselIpc.GetRollRangeRequest getRollRangeRequest = 9;
inline bool AnselIPCRequest::has_getrollrangerequest() const {
  return request_case() == kGetRollRangeRequest;
}
inline void AnselIPCRequest::set_has_getrollrangerequest() {
  _oneof_case_[0] = kGetRollRangeRequest;
}
inline void AnselIPCRequest::clear_getrollrangerequest() {
  if (has_getrollrangerequest()) {
    delete request_.getrollrangerequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::GetRollRangeRequest& AnselIPCRequest::getrollrangerequest() const {
  return has_getrollrangerequest() ? *request_.getrollrangerequest_
                      : ::AnselIpc::GetRollRangeRequest::default_instance();
}
inline ::AnselIpc::GetRollRangeRequest* AnselIPCRequest::mutable_getrollrangerequest() {
  if (!has_getrollrangerequest()) {
    clear_request();
    set_has_getrollrangerequest();
    request_.getrollrangerequest_ = new ::AnselIpc::GetRollRangeRequest;
  }
  return request_.getrollrangerequest_;
}
inline ::AnselIpc::GetRollRangeRequest* AnselIPCRequest::release_getrollrangerequest() {
  if (has_getrollrangerequest()) {
    clear_has_request();
    ::AnselIpc::GetRollRangeRequest* temp = request_.getrollrangerequest_;
    request_.getrollrangerequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_getrollrangerequest(::AnselIpc::GetRollRangeRequest* getrollrangerequest) {
  clear_request();
  if (getrollrangerequest) {
    set_has_getrollrangerequest();
    request_.getrollrangerequest_ = getrollrangerequest;
  }
}

// optional .AnselIpc.SetRollRequest setRollRequest = 10;
inline bool AnselIPCRequest::has_setrollrequest() const {
  return request_case() == kSetRollRequest;
}
inline void AnselIPCRequest::set_has_setrollrequest() {
  _oneof_case_[0] = kSetRollRequest;
}
inline void AnselIPCRequest::clear_setrollrequest() {
  if (has_setrollrequest()) {
    delete request_.setrollrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::SetRollRequest& AnselIPCRequest::setrollrequest() const {
  return has_setrollrequest() ? *request_.setrollrequest_
                      : ::AnselIpc::SetRollRequest::default_instance();
}
inline ::AnselIpc::SetRollRequest* AnselIPCRequest::mutable_setrollrequest() {
  if (!has_setrollrequest()) {
    clear_request();
    set_has_setrollrequest();
    request_.setrollrequest_ = new ::AnselIpc::SetRollRequest;
  }
  return request_.setrollrequest_;
}
inline ::AnselIpc::SetRollRequest* AnselIPCRequest::release_setrollrequest() {
  if (has_setrollrequest()) {
    clear_has_request();
    ::AnselIpc::SetRollRequest* temp = request_.setrollrequest_;
    request_.setrollrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_setrollrequest(::AnselIpc::SetRollRequest* setrollrequest) {
  clear_request();
  if (setrollrequest) {
    set_has_setrollrequest();
    request_.setrollrequest_ = setrollrequest;
  }
}

// optional .AnselIpc.GetAnselEnabledRequest getAnselEnabledRequest = 11;
inline bool AnselIPCRequest::has_getanselenabledrequest() const {
  return request_case() == kGetAnselEnabledRequest;
}
inline void AnselIPCRequest::set_has_getanselenabledrequest() {
  _oneof_case_[0] = kGetAnselEnabledRequest;
}
inline void AnselIPCRequest::clear_getanselenabledrequest() {
  if (has_getanselenabledrequest()) {
    delete request_.getanselenabledrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::GetAnselEnabledRequest& AnselIPCRequest::getanselenabledrequest() const {
  return has_getanselenabledrequest() ? *request_.getanselenabledrequest_
                      : ::AnselIpc::GetAnselEnabledRequest::default_instance();
}
inline ::AnselIpc::GetAnselEnabledRequest* AnselIPCRequest::mutable_getanselenabledrequest() {
  if (!has_getanselenabledrequest()) {
    clear_request();
    set_has_getanselenabledrequest();
    request_.getanselenabledrequest_ = new ::AnselIpc::GetAnselEnabledRequest;
  }
  return request_.getanselenabledrequest_;
}
inline ::AnselIpc::GetAnselEnabledRequest* AnselIPCRequest::release_getanselenabledrequest() {
  if (has_getanselenabledrequest()) {
    clear_has_request();
    ::AnselIpc::GetAnselEnabledRequest* temp = request_.getanselenabledrequest_;
    request_.getanselenabledrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_getanselenabledrequest(::AnselIpc::GetAnselEnabledRequest* getanselenabledrequest) {
  clear_request();
  if (getanselenabledrequest) {
    set_has_getanselenabledrequest();
    request_.getanselenabledrequest_ = getanselenabledrequest;
  }
}

// optional .AnselIpc.GetLwrrentFOVRequest getLwrrentFOVRequest = 12;
inline bool AnselIPCRequest::has_getlwrrentfovrequest() const {
  return request_case() == kGetLwrrentFOVRequest;
}
inline void AnselIPCRequest::set_has_getlwrrentfovrequest() {
  _oneof_case_[0] = kGetLwrrentFOVRequest;
}
inline void AnselIPCRequest::clear_getlwrrentfovrequest() {
  if (has_getlwrrentfovrequest()) {
    delete request_.getlwrrentfovrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::GetLwrrentFOVRequest& AnselIPCRequest::getlwrrentfovrequest() const {
  return has_getlwrrentfovrequest() ? *request_.getlwrrentfovrequest_
                      : ::AnselIpc::GetLwrrentFOVRequest::default_instance();
}
inline ::AnselIpc::GetLwrrentFOVRequest* AnselIPCRequest::mutable_getlwrrentfovrequest() {
  if (!has_getlwrrentfovrequest()) {
    clear_request();
    set_has_getlwrrentfovrequest();
    request_.getlwrrentfovrequest_ = new ::AnselIpc::GetLwrrentFOVRequest;
  }
  return request_.getlwrrentfovrequest_;
}
inline ::AnselIpc::GetLwrrentFOVRequest* AnselIPCRequest::release_getlwrrentfovrequest() {
  if (has_getlwrrentfovrequest()) {
    clear_has_request();
    ::AnselIpc::GetLwrrentFOVRequest* temp = request_.getlwrrentfovrequest_;
    request_.getlwrrentfovrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_getlwrrentfovrequest(::AnselIpc::GetLwrrentFOVRequest* getlwrrentfovrequest) {
  clear_request();
  if (getlwrrentfovrequest) {
    set_has_getlwrrentfovrequest();
    request_.getlwrrentfovrequest_ = getlwrrentfovrequest;
  }
}

// optional .AnselIpc.SetFilterRequest setFilterRequest = 13;
inline bool AnselIPCRequest::has_setfilterrequest() const {
  return request_case() == kSetFilterRequest;
}
inline void AnselIPCRequest::set_has_setfilterrequest() {
  _oneof_case_[0] = kSetFilterRequest;
}
inline void AnselIPCRequest::clear_setfilterrequest() {
  if (has_setfilterrequest()) {
    delete request_.setfilterrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::SetFilterRequest& AnselIPCRequest::setfilterrequest() const {
  return has_setfilterrequest() ? *request_.setfilterrequest_
                      : ::AnselIpc::SetFilterRequest::default_instance();
}
inline ::AnselIpc::SetFilterRequest* AnselIPCRequest::mutable_setfilterrequest() {
  if (!has_setfilterrequest()) {
    clear_request();
    set_has_setfilterrequest();
    request_.setfilterrequest_ = new ::AnselIpc::SetFilterRequest;
  }
  return request_.setfilterrequest_;
}
inline ::AnselIpc::SetFilterRequest* AnselIPCRequest::release_setfilterrequest() {
  if (has_setfilterrequest()) {
    clear_has_request();
    ::AnselIpc::SetFilterRequest* temp = request_.setfilterrequest_;
    request_.setfilterrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_setfilterrequest(::AnselIpc::SetFilterRequest* setfilterrequest) {
  clear_request();
  if (setfilterrequest) {
    set_has_setfilterrequest();
    request_.setfilterrequest_ = setfilterrequest;
  }
}

// optional .AnselIpc.SetFilterAttributeRequest setFilterAttributeRequest = 14;
inline bool AnselIPCRequest::has_setfilterattributerequest() const {
  return request_case() == kSetFilterAttributeRequest;
}
inline void AnselIPCRequest::set_has_setfilterattributerequest() {
  _oneof_case_[0] = kSetFilterAttributeRequest;
}
inline void AnselIPCRequest::clear_setfilterattributerequest() {
  if (has_setfilterattributerequest()) {
    delete request_.setfilterattributerequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::SetFilterAttributeRequest& AnselIPCRequest::setfilterattributerequest() const {
  return has_setfilterattributerequest() ? *request_.setfilterattributerequest_
                      : ::AnselIpc::SetFilterAttributeRequest::default_instance();
}
inline ::AnselIpc::SetFilterAttributeRequest* AnselIPCRequest::mutable_setfilterattributerequest() {
  if (!has_setfilterattributerequest()) {
    clear_request();
    set_has_setfilterattributerequest();
    request_.setfilterattributerequest_ = new ::AnselIpc::SetFilterAttributeRequest;
  }
  return request_.setfilterattributerequest_;
}
inline ::AnselIpc::SetFilterAttributeRequest* AnselIPCRequest::release_setfilterattributerequest() {
  if (has_setfilterattributerequest()) {
    clear_has_request();
    ::AnselIpc::SetFilterAttributeRequest* temp = request_.setfilterattributerequest_;
    request_.setfilterattributerequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_setfilterattributerequest(::AnselIpc::SetFilterAttributeRequest* setfilterattributerequest) {
  clear_request();
  if (setfilterattributerequest) {
    set_has_setfilterattributerequest();
    request_.setfilterattributerequest_ = setfilterattributerequest;
  }
}

// optional .AnselIpc.IsAnselAvailableRequest isAnselAvailableRequest = 17;
inline bool AnselIPCRequest::has_isanselavailablerequest() const {
  return request_case() == kIsAnselAvailableRequest;
}
inline void AnselIPCRequest::set_has_isanselavailablerequest() {
  _oneof_case_[0] = kIsAnselAvailableRequest;
}
inline void AnselIPCRequest::clear_isanselavailablerequest() {
  if (has_isanselavailablerequest()) {
    delete request_.isanselavailablerequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::IsAnselAvailableRequest& AnselIPCRequest::isanselavailablerequest() const {
  return has_isanselavailablerequest() ? *request_.isanselavailablerequest_
                      : ::AnselIpc::IsAnselAvailableRequest::default_instance();
}
inline ::AnselIpc::IsAnselAvailableRequest* AnselIPCRequest::mutable_isanselavailablerequest() {
  if (!has_isanselavailablerequest()) {
    clear_request();
    set_has_isanselavailablerequest();
    request_.isanselavailablerequest_ = new ::AnselIpc::IsAnselAvailableRequest;
  }
  return request_.isanselavailablerequest_;
}
inline ::AnselIpc::IsAnselAvailableRequest* AnselIPCRequest::release_isanselavailablerequest() {
  if (has_isanselavailablerequest()) {
    clear_has_request();
    ::AnselIpc::IsAnselAvailableRequest* temp = request_.isanselavailablerequest_;
    request_.isanselavailablerequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_isanselavailablerequest(::AnselIpc::IsAnselAvailableRequest* isanselavailablerequest) {
  clear_request();
  if (isanselavailablerequest) {
    set_has_isanselavailablerequest();
    request_.isanselavailablerequest_ = isanselavailablerequest;
  }
}

// optional .AnselIpc.ScreenResolutionChangedRequest screenResolutionChangedRequest = 18;
inline bool AnselIPCRequest::has_screenresolutionchangedrequest() const {
  return request_case() == kScreenResolutionChangedRequest;
}
inline void AnselIPCRequest::set_has_screenresolutionchangedrequest() {
  _oneof_case_[0] = kScreenResolutionChangedRequest;
}
inline void AnselIPCRequest::clear_screenresolutionchangedrequest() {
  if (has_screenresolutionchangedrequest()) {
    delete request_.screenresolutionchangedrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::ScreenResolutionChangedRequest& AnselIPCRequest::screenresolutionchangedrequest() const {
  return has_screenresolutionchangedrequest() ? *request_.screenresolutionchangedrequest_
                      : ::AnselIpc::ScreenResolutionChangedRequest::default_instance();
}
inline ::AnselIpc::ScreenResolutionChangedRequest* AnselIPCRequest::mutable_screenresolutionchangedrequest() {
  if (!has_screenresolutionchangedrequest()) {
    clear_request();
    set_has_screenresolutionchangedrequest();
    request_.screenresolutionchangedrequest_ = new ::AnselIpc::ScreenResolutionChangedRequest;
  }
  return request_.screenresolutionchangedrequest_;
}
inline ::AnselIpc::ScreenResolutionChangedRequest* AnselIPCRequest::release_screenresolutionchangedrequest() {
  if (has_screenresolutionchangedrequest()) {
    clear_has_request();
    ::AnselIpc::ScreenResolutionChangedRequest* temp = request_.screenresolutionchangedrequest_;
    request_.screenresolutionchangedrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_screenresolutionchangedrequest(::AnselIpc::ScreenResolutionChangedRequest* screenresolutionchangedrequest) {
  clear_request();
  if (screenresolutionchangedrequest) {
    set_has_screenresolutionchangedrequest();
    request_.screenresolutionchangedrequest_ = screenresolutionchangedrequest;
  }
}

// optional .AnselIpc.GetAnselShotPermissionsRequest getAnselShotPermissionsRequest = 19;
inline bool AnselIPCRequest::has_getanselshotpermissionsrequest() const {
  return request_case() == kGetAnselShotPermissionsRequest;
}
inline void AnselIPCRequest::set_has_getanselshotpermissionsrequest() {
  _oneof_case_[0] = kGetAnselShotPermissionsRequest;
}
inline void AnselIPCRequest::clear_getanselshotpermissionsrequest() {
  if (has_getanselshotpermissionsrequest()) {
    delete request_.getanselshotpermissionsrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::GetAnselShotPermissionsRequest& AnselIPCRequest::getanselshotpermissionsrequest() const {
  return has_getanselshotpermissionsrequest() ? *request_.getanselshotpermissionsrequest_
                      : ::AnselIpc::GetAnselShotPermissionsRequest::default_instance();
}
inline ::AnselIpc::GetAnselShotPermissionsRequest* AnselIPCRequest::mutable_getanselshotpermissionsrequest() {
  if (!has_getanselshotpermissionsrequest()) {
    clear_request();
    set_has_getanselshotpermissionsrequest();
    request_.getanselshotpermissionsrequest_ = new ::AnselIpc::GetAnselShotPermissionsRequest;
  }
  return request_.getanselshotpermissionsrequest_;
}
inline ::AnselIpc::GetAnselShotPermissionsRequest* AnselIPCRequest::release_getanselshotpermissionsrequest() {
  if (has_getanselshotpermissionsrequest()) {
    clear_has_request();
    ::AnselIpc::GetAnselShotPermissionsRequest* temp = request_.getanselshotpermissionsrequest_;
    request_.getanselshotpermissionsrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_getanselshotpermissionsrequest(::AnselIpc::GetAnselShotPermissionsRequest* getanselshotpermissionsrequest) {
  clear_request();
  if (getanselshotpermissionsrequest) {
    set_has_getanselshotpermissionsrequest();
    request_.getanselshotpermissionsrequest_ = getanselshotpermissionsrequest;
  }
}

// optional .AnselIpc.InputEventRequest inputEventRequest = 20;
inline bool AnselIPCRequest::has_inputeventrequest() const {
  return request_case() == kInputEventRequest;
}
inline void AnselIPCRequest::set_has_inputeventrequest() {
  _oneof_case_[0] = kInputEventRequest;
}
inline void AnselIPCRequest::clear_inputeventrequest() {
  if (has_inputeventrequest()) {
    delete request_.inputeventrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::InputEventRequest& AnselIPCRequest::inputeventrequest() const {
  return has_inputeventrequest() ? *request_.inputeventrequest_
                      : ::AnselIpc::InputEventRequest::default_instance();
}
inline ::AnselIpc::InputEventRequest* AnselIPCRequest::mutable_inputeventrequest() {
  if (!has_inputeventrequest()) {
    clear_request();
    set_has_inputeventrequest();
    request_.inputeventrequest_ = new ::AnselIpc::InputEventRequest;
  }
  return request_.inputeventrequest_;
}
inline ::AnselIpc::InputEventRequest* AnselIPCRequest::release_inputeventrequest() {
  if (has_inputeventrequest()) {
    clear_has_request();
    ::AnselIpc::InputEventRequest* temp = request_.inputeventrequest_;
    request_.inputeventrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_inputeventrequest(::AnselIpc::InputEventRequest* inputeventrequest) {
  clear_request();
  if (inputeventrequest) {
    set_has_inputeventrequest();
    request_.inputeventrequest_ = inputeventrequest;
  }
}

// optional .AnselIpc.SetLangIdRequest setLangIdRequest = 21;
inline bool AnselIPCRequest::has_setlangidrequest() const {
  return request_case() == kSetLangIdRequest;
}
inline void AnselIPCRequest::set_has_setlangidrequest() {
  _oneof_case_[0] = kSetLangIdRequest;
}
inline void AnselIPCRequest::clear_setlangidrequest() {
  if (has_setlangidrequest()) {
    delete request_.setlangidrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::SetLangIdRequest& AnselIPCRequest::setlangidrequest() const {
  return has_setlangidrequest() ? *request_.setlangidrequest_
                      : ::AnselIpc::SetLangIdRequest::default_instance();
}
inline ::AnselIpc::SetLangIdRequest* AnselIPCRequest::mutable_setlangidrequest() {
  if (!has_setlangidrequest()) {
    clear_request();
    set_has_setlangidrequest();
    request_.setlangidrequest_ = new ::AnselIpc::SetLangIdRequest;
  }
  return request_.setlangidrequest_;
}
inline ::AnselIpc::SetLangIdRequest* AnselIPCRequest::release_setlangidrequest() {
  if (has_setlangidrequest()) {
    clear_has_request();
    ::AnselIpc::SetLangIdRequest* temp = request_.setlangidrequest_;
    request_.setlangidrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_setlangidrequest(::AnselIpc::SetLangIdRequest* setlangidrequest) {
  clear_request();
  if (setlangidrequest) {
    set_has_setlangidrequest();
    request_.setlangidrequest_ = setlangidrequest;
  }
}

// optional .AnselIpc.GetFilterInfoRequest getFilterInfoRequest = 22;
inline bool AnselIPCRequest::has_getfilterinforequest() const {
  return request_case() == kGetFilterInfoRequest;
}
inline void AnselIPCRequest::set_has_getfilterinforequest() {
  _oneof_case_[0] = kGetFilterInfoRequest;
}
inline void AnselIPCRequest::clear_getfilterinforequest() {
  if (has_getfilterinforequest()) {
    delete request_.getfilterinforequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::GetFilterInfoRequest& AnselIPCRequest::getfilterinforequest() const {
  return has_getfilterinforequest() ? *request_.getfilterinforequest_
                      : ::AnselIpc::GetFilterInfoRequest::default_instance();
}
inline ::AnselIpc::GetFilterInfoRequest* AnselIPCRequest::mutable_getfilterinforequest() {
  if (!has_getfilterinforequest()) {
    clear_request();
    set_has_getfilterinforequest();
    request_.getfilterinforequest_ = new ::AnselIpc::GetFilterInfoRequest;
  }
  return request_.getfilterinforequest_;
}
inline ::AnselIpc::GetFilterInfoRequest* AnselIPCRequest::release_getfilterinforequest() {
  if (has_getfilterinforequest()) {
    clear_has_request();
    ::AnselIpc::GetFilterInfoRequest* temp = request_.getfilterinforequest_;
    request_.getfilterinforequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_getfilterinforequest(::AnselIpc::GetFilterInfoRequest* getfilterinforequest) {
  clear_request();
  if (getfilterinforequest) {
    set_has_getfilterinforequest();
    request_.getfilterinforequest_ = getfilterinforequest;
  }
}

// optional .AnselIpc.ResetFilterValuesRequest resetFilterValuesRequest = 23;
inline bool AnselIPCRequest::has_resetfiltervaluesrequest() const {
  return request_case() == kResetFilterValuesRequest;
}
inline void AnselIPCRequest::set_has_resetfiltervaluesrequest() {
  _oneof_case_[0] = kResetFilterValuesRequest;
}
inline void AnselIPCRequest::clear_resetfiltervaluesrequest() {
  if (has_resetfiltervaluesrequest()) {
    delete request_.resetfiltervaluesrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::ResetFilterValuesRequest& AnselIPCRequest::resetfiltervaluesrequest() const {
  return has_resetfiltervaluesrequest() ? *request_.resetfiltervaluesrequest_
                      : ::AnselIpc::ResetFilterValuesRequest::default_instance();
}
inline ::AnselIpc::ResetFilterValuesRequest* AnselIPCRequest::mutable_resetfiltervaluesrequest() {
  if (!has_resetfiltervaluesrequest()) {
    clear_request();
    set_has_resetfiltervaluesrequest();
    request_.resetfiltervaluesrequest_ = new ::AnselIpc::ResetFilterValuesRequest;
  }
  return request_.resetfiltervaluesrequest_;
}
inline ::AnselIpc::ResetFilterValuesRequest* AnselIPCRequest::release_resetfiltervaluesrequest() {
  if (has_resetfiltervaluesrequest()) {
    clear_has_request();
    ::AnselIpc::ResetFilterValuesRequest* temp = request_.resetfiltervaluesrequest_;
    request_.resetfiltervaluesrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_resetfiltervaluesrequest(::AnselIpc::ResetFilterValuesRequest* resetfiltervaluesrequest) {
  clear_request();
  if (resetfiltervaluesrequest) {
    set_has_resetfiltervaluesrequest();
    request_.resetfiltervaluesrequest_ = resetfiltervaluesrequest;
  }
}

// optional .AnselIpc.ResetAllFilterValuesRequest resetAllFilterValuesRequest = 24;
inline bool AnselIPCRequest::has_resetallfiltervaluesrequest() const {
  return request_case() == kResetAllFilterValuesRequest;
}
inline void AnselIPCRequest::set_has_resetallfiltervaluesrequest() {
  _oneof_case_[0] = kResetAllFilterValuesRequest;
}
inline void AnselIPCRequest::clear_resetallfiltervaluesrequest() {
  if (has_resetallfiltervaluesrequest()) {
    delete request_.resetallfiltervaluesrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::ResetAllFilterValuesRequest& AnselIPCRequest::resetallfiltervaluesrequest() const {
  return has_resetallfiltervaluesrequest() ? *request_.resetallfiltervaluesrequest_
                      : ::AnselIpc::ResetAllFilterValuesRequest::default_instance();
}
inline ::AnselIpc::ResetAllFilterValuesRequest* AnselIPCRequest::mutable_resetallfiltervaluesrequest() {
  if (!has_resetallfiltervaluesrequest()) {
    clear_request();
    set_has_resetallfiltervaluesrequest();
    request_.resetallfiltervaluesrequest_ = new ::AnselIpc::ResetAllFilterValuesRequest;
  }
  return request_.resetallfiltervaluesrequest_;
}
inline ::AnselIpc::ResetAllFilterValuesRequest* AnselIPCRequest::release_resetallfiltervaluesrequest() {
  if (has_resetallfiltervaluesrequest()) {
    clear_has_request();
    ::AnselIpc::ResetAllFilterValuesRequest* temp = request_.resetallfiltervaluesrequest_;
    request_.resetallfiltervaluesrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_resetallfiltervaluesrequest(::AnselIpc::ResetAllFilterValuesRequest* resetallfiltervaluesrequest) {
  clear_request();
  if (resetallfiltervaluesrequest) {
    set_has_resetallfiltervaluesrequest();
    request_.resetallfiltervaluesrequest_ = resetallfiltervaluesrequest;
  }
}

// optional .AnselIpc.IsAnselSDKIntegrationAvailableRequest isAnselSDKIntegrationAvailableRequest = 25;
inline bool AnselIPCRequest::has_isanselsdkintegrationavailablerequest() const {
  return request_case() == kIsAnselSDKIntegrationAvailableRequest;
}
inline void AnselIPCRequest::set_has_isanselsdkintegrationavailablerequest() {
  _oneof_case_[0] = kIsAnselSDKIntegrationAvailableRequest;
}
inline void AnselIPCRequest::clear_isanselsdkintegrationavailablerequest() {
  if (has_isanselsdkintegrationavailablerequest()) {
    delete request_.isanselsdkintegrationavailablerequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::IsAnselSDKIntegrationAvailableRequest& AnselIPCRequest::isanselsdkintegrationavailablerequest() const {
  return has_isanselsdkintegrationavailablerequest() ? *request_.isanselsdkintegrationavailablerequest_
                      : ::AnselIpc::IsAnselSDKIntegrationAvailableRequest::default_instance();
}
inline ::AnselIpc::IsAnselSDKIntegrationAvailableRequest* AnselIPCRequest::mutable_isanselsdkintegrationavailablerequest() {
  if (!has_isanselsdkintegrationavailablerequest()) {
    clear_request();
    set_has_isanselsdkintegrationavailablerequest();
    request_.isanselsdkintegrationavailablerequest_ = new ::AnselIpc::IsAnselSDKIntegrationAvailableRequest;
  }
  return request_.isanselsdkintegrationavailablerequest_;
}
inline ::AnselIpc::IsAnselSDKIntegrationAvailableRequest* AnselIPCRequest::release_isanselsdkintegrationavailablerequest() {
  if (has_isanselsdkintegrationavailablerequest()) {
    clear_has_request();
    ::AnselIpc::IsAnselSDKIntegrationAvailableRequest* temp = request_.isanselsdkintegrationavailablerequest_;
    request_.isanselsdkintegrationavailablerequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_isanselsdkintegrationavailablerequest(::AnselIpc::IsAnselSDKIntegrationAvailableRequest* isanselsdkintegrationavailablerequest) {
  clear_request();
  if (isanselsdkintegrationavailablerequest) {
    set_has_isanselsdkintegrationavailablerequest();
    request_.isanselsdkintegrationavailablerequest_ = isanselsdkintegrationavailablerequest;
  }
}

// optional .AnselIpc.IpcVersionRequest ipcVersionRequest = 26;
inline bool AnselIPCRequest::has_ipcversionrequest() const {
  return request_case() == kIpcVersionRequest;
}
inline void AnselIPCRequest::set_has_ipcversionrequest() {
  _oneof_case_[0] = kIpcVersionRequest;
}
inline void AnselIPCRequest::clear_ipcversionrequest() {
  if (has_ipcversionrequest()) {
    delete request_.ipcversionrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::IpcVersionRequest& AnselIPCRequest::ipcversionrequest() const {
  return has_ipcversionrequest() ? *request_.ipcversionrequest_
                      : ::AnselIpc::IpcVersionRequest::default_instance();
}
inline ::AnselIpc::IpcVersionRequest* AnselIPCRequest::mutable_ipcversionrequest() {
  if (!has_ipcversionrequest()) {
    clear_request();
    set_has_ipcversionrequest();
    request_.ipcversionrequest_ = new ::AnselIpc::IpcVersionRequest;
  }
  return request_.ipcversionrequest_;
}
inline ::AnselIpc::IpcVersionRequest* AnselIPCRequest::release_ipcversionrequest() {
  if (has_ipcversionrequest()) {
    clear_has_request();
    ::AnselIpc::IpcVersionRequest* temp = request_.ipcversionrequest_;
    request_.ipcversionrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_ipcversionrequest(::AnselIpc::IpcVersionRequest* ipcversionrequest) {
  clear_request();
  if (ipcversionrequest) {
    set_has_ipcversionrequest();
    request_.ipcversionrequest_ = ipcversionrequest;
  }
}

// optional .AnselIpc.AddUIElementRequest addUIElementRequest = 27;
inline bool AnselIPCRequest::has_adduielementrequest() const {
  return request_case() == kAddUIElementRequest;
}
inline void AnselIPCRequest::set_has_adduielementrequest() {
  _oneof_case_[0] = kAddUIElementRequest;
}
inline void AnselIPCRequest::clear_adduielementrequest() {
  if (has_adduielementrequest()) {
    delete request_.adduielementrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::AddUIElementRequest& AnselIPCRequest::adduielementrequest() const {
  return has_adduielementrequest() ? *request_.adduielementrequest_
                      : ::AnselIpc::AddUIElementRequest::default_instance();
}
inline ::AnselIpc::AddUIElementRequest* AnselIPCRequest::mutable_adduielementrequest() {
  if (!has_adduielementrequest()) {
    clear_request();
    set_has_adduielementrequest();
    request_.adduielementrequest_ = new ::AnselIpc::AddUIElementRequest;
  }
  return request_.adduielementrequest_;
}
inline ::AnselIpc::AddUIElementRequest* AnselIPCRequest::release_adduielementrequest() {
  if (has_adduielementrequest()) {
    clear_has_request();
    ::AnselIpc::AddUIElementRequest* temp = request_.adduielementrequest_;
    request_.adduielementrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_adduielementrequest(::AnselIpc::AddUIElementRequest* adduielementrequest) {
  clear_request();
  if (adduielementrequest) {
    set_has_adduielementrequest();
    request_.adduielementrequest_ = adduielementrequest;
  }
}

// optional .AnselIpc.UIReadyRequest uiReadyRequest = 28;
inline bool AnselIPCRequest::has_uireadyrequest() const {
  return request_case() == kUiReadyRequest;
}
inline void AnselIPCRequest::set_has_uireadyrequest() {
  _oneof_case_[0] = kUiReadyRequest;
}
inline void AnselIPCRequest::clear_uireadyrequest() {
  if (has_uireadyrequest()) {
    delete request_.uireadyrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::UIReadyRequest& AnselIPCRequest::uireadyrequest() const {
  return has_uireadyrequest() ? *request_.uireadyrequest_
                      : ::AnselIpc::UIReadyRequest::default_instance();
}
inline ::AnselIpc::UIReadyRequest* AnselIPCRequest::mutable_uireadyrequest() {
  if (!has_uireadyrequest()) {
    clear_request();
    set_has_uireadyrequest();
    request_.uireadyrequest_ = new ::AnselIpc::UIReadyRequest;
  }
  return request_.uireadyrequest_;
}
inline ::AnselIpc::UIReadyRequest* AnselIPCRequest::release_uireadyrequest() {
  if (has_uireadyrequest()) {
    clear_has_request();
    ::AnselIpc::UIReadyRequest* temp = request_.uireadyrequest_;
    request_.uireadyrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_uireadyrequest(::AnselIpc::UIReadyRequest* uireadyrequest) {
  clear_request();
  if (uireadyrequest) {
    set_has_uireadyrequest();
    request_.uireadyrequest_ = uireadyrequest;
  }
}

// optional .AnselIpc.UIControlChangedRequest uiControlChangedRequest = 29;
inline bool AnselIPCRequest::has_uicontrolchangedrequest() const {
  return request_case() == kUiControlChangedRequest;
}
inline void AnselIPCRequest::set_has_uicontrolchangedrequest() {
  _oneof_case_[0] = kUiControlChangedRequest;
}
inline void AnselIPCRequest::clear_uicontrolchangedrequest() {
  if (has_uicontrolchangedrequest()) {
    delete request_.uicontrolchangedrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::UIControlChangedRequest& AnselIPCRequest::uicontrolchangedrequest() const {
  return has_uicontrolchangedrequest() ? *request_.uicontrolchangedrequest_
                      : ::AnselIpc::UIControlChangedRequest::default_instance();
}
inline ::AnselIpc::UIControlChangedRequest* AnselIPCRequest::mutable_uicontrolchangedrequest() {
  if (!has_uicontrolchangedrequest()) {
    clear_request();
    set_has_uicontrolchangedrequest();
    request_.uicontrolchangedrequest_ = new ::AnselIpc::UIControlChangedRequest;
  }
  return request_.uicontrolchangedrequest_;
}
inline ::AnselIpc::UIControlChangedRequest* AnselIPCRequest::release_uicontrolchangedrequest() {
  if (has_uicontrolchangedrequest()) {
    clear_has_request();
    ::AnselIpc::UIControlChangedRequest* temp = request_.uicontrolchangedrequest_;
    request_.uicontrolchangedrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_uicontrolchangedrequest(::AnselIpc::UIControlChangedRequest* uicontrolchangedrequest) {
  clear_request();
  if (uicontrolchangedrequest) {
    set_has_uicontrolchangedrequest();
    request_.uicontrolchangedrequest_ = uicontrolchangedrequest;
  }
}

// optional .AnselIpc.UIControlRemoveRequest uiControlRemoveRequest = 30;
inline bool AnselIPCRequest::has_uicontrolremoverequest() const {
  return request_case() == kUiControlRemoveRequest;
}
inline void AnselIPCRequest::set_has_uicontrolremoverequest() {
  _oneof_case_[0] = kUiControlRemoveRequest;
}
inline void AnselIPCRequest::clear_uicontrolremoverequest() {
  if (has_uicontrolremoverequest()) {
    delete request_.uicontrolremoverequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::UIControlRemoveRequest& AnselIPCRequest::uicontrolremoverequest() const {
  return has_uicontrolremoverequest() ? *request_.uicontrolremoverequest_
                      : ::AnselIpc::UIControlRemoveRequest::default_instance();
}
inline ::AnselIpc::UIControlRemoveRequest* AnselIPCRequest::mutable_uicontrolremoverequest() {
  if (!has_uicontrolremoverequest()) {
    clear_request();
    set_has_uicontrolremoverequest();
    request_.uicontrolremoverequest_ = new ::AnselIpc::UIControlRemoveRequest;
  }
  return request_.uicontrolremoverequest_;
}
inline ::AnselIpc::UIControlRemoveRequest* AnselIPCRequest::release_uicontrolremoverequest() {
  if (has_uicontrolremoverequest()) {
    clear_has_request();
    ::AnselIpc::UIControlRemoveRequest* temp = request_.uicontrolremoverequest_;
    request_.uicontrolremoverequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_uicontrolremoverequest(::AnselIpc::UIControlRemoveRequest* uicontrolremoverequest) {
  clear_request();
  if (uicontrolremoverequest) {
    set_has_uicontrolremoverequest();
    request_.uicontrolremoverequest_ = uicontrolremoverequest;
  }
}

// optional .AnselIpc.UIControlSetVisibilityRequest uiControlSetVisibilityRequest = 31;
inline bool AnselIPCRequest::has_uicontrolsetvisibilityrequest() const {
  return request_case() == kUiControlSetVisibilityRequest;
}
inline void AnselIPCRequest::set_has_uicontrolsetvisibilityrequest() {
  _oneof_case_[0] = kUiControlSetVisibilityRequest;
}
inline void AnselIPCRequest::clear_uicontrolsetvisibilityrequest() {
  if (has_uicontrolsetvisibilityrequest()) {
    delete request_.uicontrolsetvisibilityrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::UIControlSetVisibilityRequest& AnselIPCRequest::uicontrolsetvisibilityrequest() const {
  return has_uicontrolsetvisibilityrequest() ? *request_.uicontrolsetvisibilityrequest_
                      : ::AnselIpc::UIControlSetVisibilityRequest::default_instance();
}
inline ::AnselIpc::UIControlSetVisibilityRequest* AnselIPCRequest::mutable_uicontrolsetvisibilityrequest() {
  if (!has_uicontrolsetvisibilityrequest()) {
    clear_request();
    set_has_uicontrolsetvisibilityrequest();
    request_.uicontrolsetvisibilityrequest_ = new ::AnselIpc::UIControlSetVisibilityRequest;
  }
  return request_.uicontrolsetvisibilityrequest_;
}
inline ::AnselIpc::UIControlSetVisibilityRequest* AnselIPCRequest::release_uicontrolsetvisibilityrequest() {
  if (has_uicontrolsetvisibilityrequest()) {
    clear_has_request();
    ::AnselIpc::UIControlSetVisibilityRequest* temp = request_.uicontrolsetvisibilityrequest_;
    request_.uicontrolsetvisibilityrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_uicontrolsetvisibilityrequest(::AnselIpc::UIControlSetVisibilityRequest* uicontrolsetvisibilityrequest) {
  clear_request();
  if (uicontrolsetvisibilityrequest) {
    set_has_uicontrolsetvisibilityrequest();
    request_.uicontrolsetvisibilityrequest_ = uicontrolsetvisibilityrequest;
  }
}

// optional .AnselIpc.UIControlGetVisibilityRequest uiControlGetVisibilityRequest = 32;
inline bool AnselIPCRequest::has_uicontrolgetvisibilityrequest() const {
  return request_case() == kUiControlGetVisibilityRequest;
}
inline void AnselIPCRequest::set_has_uicontrolgetvisibilityrequest() {
  _oneof_case_[0] = kUiControlGetVisibilityRequest;
}
inline void AnselIPCRequest::clear_uicontrolgetvisibilityrequest() {
  if (has_uicontrolgetvisibilityrequest()) {
    delete request_.uicontrolgetvisibilityrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::UIControlGetVisibilityRequest& AnselIPCRequest::uicontrolgetvisibilityrequest() const {
  return has_uicontrolgetvisibilityrequest() ? *request_.uicontrolgetvisibilityrequest_
                      : ::AnselIpc::UIControlGetVisibilityRequest::default_instance();
}
inline ::AnselIpc::UIControlGetVisibilityRequest* AnselIPCRequest::mutable_uicontrolgetvisibilityrequest() {
  if (!has_uicontrolgetvisibilityrequest()) {
    clear_request();
    set_has_uicontrolgetvisibilityrequest();
    request_.uicontrolgetvisibilityrequest_ = new ::AnselIpc::UIControlGetVisibilityRequest;
  }
  return request_.uicontrolgetvisibilityrequest_;
}
inline ::AnselIpc::UIControlGetVisibilityRequest* AnselIPCRequest::release_uicontrolgetvisibilityrequest() {
  if (has_uicontrolgetvisibilityrequest()) {
    clear_has_request();
    ::AnselIpc::UIControlGetVisibilityRequest* temp = request_.uicontrolgetvisibilityrequest_;
    request_.uicontrolgetvisibilityrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_uicontrolgetvisibilityrequest(::AnselIpc::UIControlGetVisibilityRequest* uicontrolgetvisibilityrequest) {
  clear_request();
  if (uicontrolgetvisibilityrequest) {
    set_has_uicontrolgetvisibilityrequest();
    request_.uicontrolgetvisibilityrequest_ = uicontrolgetvisibilityrequest;
  }
}

// optional .AnselIpc.GetProcessInfoRequest getProcessInfoRequest = 33;
inline bool AnselIPCRequest::has_getprocessinforequest() const {
  return request_case() == kGetProcessInfoRequest;
}
inline void AnselIPCRequest::set_has_getprocessinforequest() {
  _oneof_case_[0] = kGetProcessInfoRequest;
}
inline void AnselIPCRequest::clear_getprocessinforequest() {
  if (has_getprocessinforequest()) {
    delete request_.getprocessinforequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::GetProcessInfoRequest& AnselIPCRequest::getprocessinforequest() const {
  return has_getprocessinforequest() ? *request_.getprocessinforequest_
                      : ::AnselIpc::GetProcessInfoRequest::default_instance();
}
inline ::AnselIpc::GetProcessInfoRequest* AnselIPCRequest::mutable_getprocessinforequest() {
  if (!has_getprocessinforequest()) {
    clear_request();
    set_has_getprocessinforequest();
    request_.getprocessinforequest_ = new ::AnselIpc::GetProcessInfoRequest;
  }
  return request_.getprocessinforequest_;
}
inline ::AnselIpc::GetProcessInfoRequest* AnselIPCRequest::release_getprocessinforequest() {
  if (has_getprocessinforequest()) {
    clear_has_request();
    ::AnselIpc::GetProcessInfoRequest* temp = request_.getprocessinforequest_;
    request_.getprocessinforequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_getprocessinforequest(::AnselIpc::GetProcessInfoRequest* getprocessinforequest) {
  clear_request();
  if (getprocessinforequest) {
    set_has_getprocessinforequest();
    request_.getprocessinforequest_ = getprocessinforequest;
  }
}

// optional .AnselIpc.GetScreenResolutionRequest getScreenResolutionRequest = 34;
inline bool AnselIPCRequest::has_getscreenresolutionrequest() const {
  return request_case() == kGetScreenResolutionRequest;
}
inline void AnselIPCRequest::set_has_getscreenresolutionrequest() {
  _oneof_case_[0] = kGetScreenResolutionRequest;
}
inline void AnselIPCRequest::clear_getscreenresolutionrequest() {
  if (has_getscreenresolutionrequest()) {
    delete request_.getscreenresolutionrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::GetScreenResolutionRequest& AnselIPCRequest::getscreenresolutionrequest() const {
  return has_getscreenresolutionrequest() ? *request_.getscreenresolutionrequest_
                      : ::AnselIpc::GetScreenResolutionRequest::default_instance();
}
inline ::AnselIpc::GetScreenResolutionRequest* AnselIPCRequest::mutable_getscreenresolutionrequest() {
  if (!has_getscreenresolutionrequest()) {
    clear_request();
    set_has_getscreenresolutionrequest();
    request_.getscreenresolutionrequest_ = new ::AnselIpc::GetScreenResolutionRequest;
  }
  return request_.getscreenresolutionrequest_;
}
inline ::AnselIpc::GetScreenResolutionRequest* AnselIPCRequest::release_getscreenresolutionrequest() {
  if (has_getscreenresolutionrequest()) {
    clear_has_request();
    ::AnselIpc::GetScreenResolutionRequest* temp = request_.getscreenresolutionrequest_;
    request_.getscreenresolutionrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_getscreenresolutionrequest(::AnselIpc::GetScreenResolutionRequest* getscreenresolutionrequest) {
  clear_request();
  if (getscreenresolutionrequest) {
    set_has_getscreenresolutionrequest();
    request_.getscreenresolutionrequest_ = getscreenresolutionrequest;
  }
}

// optional .AnselIpc.IsAnselModdingAvailableRequest isAnselModdingAvailableRequest = 35;
inline bool AnselIPCRequest::has_isanselmoddingavailablerequest() const {
  return request_case() == kIsAnselModdingAvailableRequest;
}
inline void AnselIPCRequest::set_has_isanselmoddingavailablerequest() {
  _oneof_case_[0] = kIsAnselModdingAvailableRequest;
}
inline void AnselIPCRequest::clear_isanselmoddingavailablerequest() {
  if (has_isanselmoddingavailablerequest()) {
    delete request_.isanselmoddingavailablerequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::IsAnselModdingAvailableRequest& AnselIPCRequest::isanselmoddingavailablerequest() const {
  return has_isanselmoddingavailablerequest() ? *request_.isanselmoddingavailablerequest_
                      : ::AnselIpc::IsAnselModdingAvailableRequest::default_instance();
}
inline ::AnselIpc::IsAnselModdingAvailableRequest* AnselIPCRequest::mutable_isanselmoddingavailablerequest() {
  if (!has_isanselmoddingavailablerequest()) {
    clear_request();
    set_has_isanselmoddingavailablerequest();
    request_.isanselmoddingavailablerequest_ = new ::AnselIpc::IsAnselModdingAvailableRequest;
  }
  return request_.isanselmoddingavailablerequest_;
}
inline ::AnselIpc::IsAnselModdingAvailableRequest* AnselIPCRequest::release_isanselmoddingavailablerequest() {
  if (has_isanselmoddingavailablerequest()) {
    clear_has_request();
    ::AnselIpc::IsAnselModdingAvailableRequest* temp = request_.isanselmoddingavailablerequest_;
    request_.isanselmoddingavailablerequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_isanselmoddingavailablerequest(::AnselIpc::IsAnselModdingAvailableRequest* isanselmoddingavailablerequest) {
  clear_request();
  if (isanselmoddingavailablerequest) {
    set_has_isanselmoddingavailablerequest();
    request_.isanselmoddingavailablerequest_ = isanselmoddingavailablerequest;
  }
}

// optional .AnselIpc.SetGridOfThirdsEnabledRequest setGridOfThirdsEnabledRequest = 36;
inline bool AnselIPCRequest::has_setgridofthirdsenabledrequest() const {
  return request_case() == kSetGridOfThirdsEnabledRequest;
}
inline void AnselIPCRequest::set_has_setgridofthirdsenabledrequest() {
  _oneof_case_[0] = kSetGridOfThirdsEnabledRequest;
}
inline void AnselIPCRequest::clear_setgridofthirdsenabledrequest() {
  if (has_setgridofthirdsenabledrequest()) {
    delete request_.setgridofthirdsenabledrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::SetGridOfThirdsEnabledRequest& AnselIPCRequest::setgridofthirdsenabledrequest() const {
  return has_setgridofthirdsenabledrequest() ? *request_.setgridofthirdsenabledrequest_
                      : ::AnselIpc::SetGridOfThirdsEnabledRequest::default_instance();
}
inline ::AnselIpc::SetGridOfThirdsEnabledRequest* AnselIPCRequest::mutable_setgridofthirdsenabledrequest() {
  if (!has_setgridofthirdsenabledrequest()) {
    clear_request();
    set_has_setgridofthirdsenabledrequest();
    request_.setgridofthirdsenabledrequest_ = new ::AnselIpc::SetGridOfThirdsEnabledRequest;
  }
  return request_.setgridofthirdsenabledrequest_;
}
inline ::AnselIpc::SetGridOfThirdsEnabledRequest* AnselIPCRequest::release_setgridofthirdsenabledrequest() {
  if (has_setgridofthirdsenabledrequest()) {
    clear_has_request();
    ::AnselIpc::SetGridOfThirdsEnabledRequest* temp = request_.setgridofthirdsenabledrequest_;
    request_.setgridofthirdsenabledrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_setgridofthirdsenabledrequest(::AnselIpc::SetGridOfThirdsEnabledRequest* setgridofthirdsenabledrequest) {
  clear_request();
  if (setgridofthirdsenabledrequest) {
    set_has_setgridofthirdsenabledrequest();
    request_.setgridofthirdsenabledrequest_ = setgridofthirdsenabledrequest;
  }
}

// optional .AnselIpc.ResetEntireStackRequest resetEntireStackRequest = 37;
inline bool AnselIPCRequest::has_resetentirestackrequest() const {
  return request_case() == kResetEntireStackRequest;
}
inline void AnselIPCRequest::set_has_resetentirestackrequest() {
  _oneof_case_[0] = kResetEntireStackRequest;
}
inline void AnselIPCRequest::clear_resetentirestackrequest() {
  if (has_resetentirestackrequest()) {
    delete request_.resetentirestackrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::ResetEntireStackRequest& AnselIPCRequest::resetentirestackrequest() const {
  return has_resetentirestackrequest() ? *request_.resetentirestackrequest_
                      : ::AnselIpc::ResetEntireStackRequest::default_instance();
}
inline ::AnselIpc::ResetEntireStackRequest* AnselIPCRequest::mutable_resetentirestackrequest() {
  if (!has_resetentirestackrequest()) {
    clear_request();
    set_has_resetentirestackrequest();
    request_.resetentirestackrequest_ = new ::AnselIpc::ResetEntireStackRequest;
  }
  return request_.resetentirestackrequest_;
}
inline ::AnselIpc::ResetEntireStackRequest* AnselIPCRequest::release_resetentirestackrequest() {
  if (has_resetentirestackrequest()) {
    clear_has_request();
    ::AnselIpc::ResetEntireStackRequest* temp = request_.resetentirestackrequest_;
    request_.resetentirestackrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_resetentirestackrequest(::AnselIpc::ResetEntireStackRequest* resetentirestackrequest) {
  clear_request();
  if (resetentirestackrequest) {
    set_has_resetentirestackrequest();
    request_.resetentirestackrequest_ = resetentirestackrequest;
  }
}

// optional .AnselIpc.GetFeatureSetRequest getFeatureSetRequest = 38;
inline bool AnselIPCRequest::has_getfeaturesetrequest() const {
  return request_case() == kGetFeatureSetRequest;
}
inline void AnselIPCRequest::set_has_getfeaturesetrequest() {
  _oneof_case_[0] = kGetFeatureSetRequest;
}
inline void AnselIPCRequest::clear_getfeaturesetrequest() {
  if (has_getfeaturesetrequest()) {
    delete request_.getfeaturesetrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::GetFeatureSetRequest& AnselIPCRequest::getfeaturesetrequest() const {
  return has_getfeaturesetrequest() ? *request_.getfeaturesetrequest_
                      : ::AnselIpc::GetFeatureSetRequest::default_instance();
}
inline ::AnselIpc::GetFeatureSetRequest* AnselIPCRequest::mutable_getfeaturesetrequest() {
  if (!has_getfeaturesetrequest()) {
    clear_request();
    set_has_getfeaturesetrequest();
    request_.getfeaturesetrequest_ = new ::AnselIpc::GetFeatureSetRequest;
  }
  return request_.getfeaturesetrequest_;
}
inline ::AnselIpc::GetFeatureSetRequest* AnselIPCRequest::release_getfeaturesetrequest() {
  if (has_getfeaturesetrequest()) {
    clear_has_request();
    ::AnselIpc::GetFeatureSetRequest* temp = request_.getfeaturesetrequest_;
    request_.getfeaturesetrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_getfeaturesetrequest(::AnselIpc::GetFeatureSetRequest* getfeaturesetrequest) {
  clear_request();
  if (getfeaturesetrequest) {
    set_has_getfeaturesetrequest();
    request_.getfeaturesetrequest_ = getfeaturesetrequest;
  }
}

// optional .AnselIpc.SetStyleTransferEnabledRequest setStyleTransferEnabledRequest = 39;
inline bool AnselIPCRequest::has_setstyletransferenabledrequest() const {
  return request_case() == kSetStyleTransferEnabledRequest;
}
inline void AnselIPCRequest::set_has_setstyletransferenabledrequest() {
  _oneof_case_[0] = kSetStyleTransferEnabledRequest;
}
inline void AnselIPCRequest::clear_setstyletransferenabledrequest() {
  if (has_setstyletransferenabledrequest()) {
    delete request_.setstyletransferenabledrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::SetStyleTransferEnabledRequest& AnselIPCRequest::setstyletransferenabledrequest() const {
  return has_setstyletransferenabledrequest() ? *request_.setstyletransferenabledrequest_
                      : ::AnselIpc::SetStyleTransferEnabledRequest::default_instance();
}
inline ::AnselIpc::SetStyleTransferEnabledRequest* AnselIPCRequest::mutable_setstyletransferenabledrequest() {
  if (!has_setstyletransferenabledrequest()) {
    clear_request();
    set_has_setstyletransferenabledrequest();
    request_.setstyletransferenabledrequest_ = new ::AnselIpc::SetStyleTransferEnabledRequest;
  }
  return request_.setstyletransferenabledrequest_;
}
inline ::AnselIpc::SetStyleTransferEnabledRequest* AnselIPCRequest::release_setstyletransferenabledrequest() {
  if (has_setstyletransferenabledrequest()) {
    clear_has_request();
    ::AnselIpc::SetStyleTransferEnabledRequest* temp = request_.setstyletransferenabledrequest_;
    request_.setstyletransferenabledrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_setstyletransferenabledrequest(::AnselIpc::SetStyleTransferEnabledRequest* setstyletransferenabledrequest) {
  clear_request();
  if (setstyletransferenabledrequest) {
    set_has_setstyletransferenabledrequest();
    request_.setstyletransferenabledrequest_ = setstyletransferenabledrequest;
  }
}

// optional .AnselIpc.SetStyleTransferStyleRequest setStyleTransferStyleRequest = 40;
inline bool AnselIPCRequest::has_setstyletransferstylerequest() const {
  return request_case() == kSetStyleTransferStyleRequest;
}
inline void AnselIPCRequest::set_has_setstyletransferstylerequest() {
  _oneof_case_[0] = kSetStyleTransferStyleRequest;
}
inline void AnselIPCRequest::clear_setstyletransferstylerequest() {
  if (has_setstyletransferstylerequest()) {
    delete request_.setstyletransferstylerequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::SetStyleTransferStyleRequest& AnselIPCRequest::setstyletransferstylerequest() const {
  return has_setstyletransferstylerequest() ? *request_.setstyletransferstylerequest_
                      : ::AnselIpc::SetStyleTransferStyleRequest::default_instance();
}
inline ::AnselIpc::SetStyleTransferStyleRequest* AnselIPCRequest::mutable_setstyletransferstylerequest() {
  if (!has_setstyletransferstylerequest()) {
    clear_request();
    set_has_setstyletransferstylerequest();
    request_.setstyletransferstylerequest_ = new ::AnselIpc::SetStyleTransferStyleRequest;
  }
  return request_.setstyletransferstylerequest_;
}
inline ::AnselIpc::SetStyleTransferStyleRequest* AnselIPCRequest::release_setstyletransferstylerequest() {
  if (has_setstyletransferstylerequest()) {
    clear_has_request();
    ::AnselIpc::SetStyleTransferStyleRequest* temp = request_.setstyletransferstylerequest_;
    request_.setstyletransferstylerequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_setstyletransferstylerequest(::AnselIpc::SetStyleTransferStyleRequest* setstyletransferstylerequest) {
  clear_request();
  if (setstyletransferstylerequest) {
    set_has_setstyletransferstylerequest();
    request_.setstyletransferstylerequest_ = setstyletransferstylerequest;
  }
}

// optional .AnselIpc.GetStyleTransferModelListRequest getStyleTransferModelListRequest = 41;
inline bool AnselIPCRequest::has_getstyletransfermodellistrequest() const {
  return request_case() == kGetStyleTransferModelListRequest;
}
inline void AnselIPCRequest::set_has_getstyletransfermodellistrequest() {
  _oneof_case_[0] = kGetStyleTransferModelListRequest;
}
inline void AnselIPCRequest::clear_getstyletransfermodellistrequest() {
  if (has_getstyletransfermodellistrequest()) {
    delete request_.getstyletransfermodellistrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::GetStyleTransferModelListRequest& AnselIPCRequest::getstyletransfermodellistrequest() const {
  return has_getstyletransfermodellistrequest() ? *request_.getstyletransfermodellistrequest_
                      : ::AnselIpc::GetStyleTransferModelListRequest::default_instance();
}
inline ::AnselIpc::GetStyleTransferModelListRequest* AnselIPCRequest::mutable_getstyletransfermodellistrequest() {
  if (!has_getstyletransfermodellistrequest()) {
    clear_request();
    set_has_getstyletransfermodellistrequest();
    request_.getstyletransfermodellistrequest_ = new ::AnselIpc::GetStyleTransferModelListRequest;
  }
  return request_.getstyletransfermodellistrequest_;
}
inline ::AnselIpc::GetStyleTransferModelListRequest* AnselIPCRequest::release_getstyletransfermodellistrequest() {
  if (has_getstyletransfermodellistrequest()) {
    clear_has_request();
    ::AnselIpc::GetStyleTransferModelListRequest* temp = request_.getstyletransfermodellistrequest_;
    request_.getstyletransfermodellistrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_getstyletransfermodellistrequest(::AnselIpc::GetStyleTransferModelListRequest* getstyletransfermodellistrequest) {
  clear_request();
  if (getstyletransfermodellistrequest) {
    set_has_getstyletransfermodellistrequest();
    request_.getstyletransfermodellistrequest_ = getstyletransfermodellistrequest;
  }
}

// optional .AnselIpc.SetStyleTransferModelRequest setStyleTransferModelRequest = 42;
inline bool AnselIPCRequest::has_setstyletransfermodelrequest() const {
  return request_case() == kSetStyleTransferModelRequest;
}
inline void AnselIPCRequest::set_has_setstyletransfermodelrequest() {
  _oneof_case_[0] = kSetStyleTransferModelRequest;
}
inline void AnselIPCRequest::clear_setstyletransfermodelrequest() {
  if (has_setstyletransfermodelrequest()) {
    delete request_.setstyletransfermodelrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::SetStyleTransferModelRequest& AnselIPCRequest::setstyletransfermodelrequest() const {
  return has_setstyletransfermodelrequest() ? *request_.setstyletransfermodelrequest_
                      : ::AnselIpc::SetStyleTransferModelRequest::default_instance();
}
inline ::AnselIpc::SetStyleTransferModelRequest* AnselIPCRequest::mutable_setstyletransfermodelrequest() {
  if (!has_setstyletransfermodelrequest()) {
    clear_request();
    set_has_setstyletransfermodelrequest();
    request_.setstyletransfermodelrequest_ = new ::AnselIpc::SetStyleTransferModelRequest;
  }
  return request_.setstyletransfermodelrequest_;
}
inline ::AnselIpc::SetStyleTransferModelRequest* AnselIPCRequest::release_setstyletransfermodelrequest() {
  if (has_setstyletransfermodelrequest()) {
    clear_has_request();
    ::AnselIpc::SetStyleTransferModelRequest* temp = request_.setstyletransfermodelrequest_;
    request_.setstyletransfermodelrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_setstyletransfermodelrequest(::AnselIpc::SetStyleTransferModelRequest* setstyletransfermodelrequest) {
  clear_request();
  if (setstyletransfermodelrequest) {
    set_has_setstyletransfermodelrequest();
    request_.setstyletransfermodelrequest_ = setstyletransfermodelrequest;
  }
}

// optional .AnselIpc.StyleTransferStatusRequest styleTransferStatusRequest = 43;
inline bool AnselIPCRequest::has_styletransferstatusrequest() const {
  return request_case() == kStyleTransferStatusRequest;
}
inline void AnselIPCRequest::set_has_styletransferstatusrequest() {
  _oneof_case_[0] = kStyleTransferStatusRequest;
}
inline void AnselIPCRequest::clear_styletransferstatusrequest() {
  if (has_styletransferstatusrequest()) {
    delete request_.styletransferstatusrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::StyleTransferStatusRequest& AnselIPCRequest::styletransferstatusrequest() const {
  return has_styletransferstatusrequest() ? *request_.styletransferstatusrequest_
                      : ::AnselIpc::StyleTransferStatusRequest::default_instance();
}
inline ::AnselIpc::StyleTransferStatusRequest* AnselIPCRequest::mutable_styletransferstatusrequest() {
  if (!has_styletransferstatusrequest()) {
    clear_request();
    set_has_styletransferstatusrequest();
    request_.styletransferstatusrequest_ = new ::AnselIpc::StyleTransferStatusRequest;
  }
  return request_.styletransferstatusrequest_;
}
inline ::AnselIpc::StyleTransferStatusRequest* AnselIPCRequest::release_styletransferstatusrequest() {
  if (has_styletransferstatusrequest()) {
    clear_has_request();
    ::AnselIpc::StyleTransferStatusRequest* temp = request_.styletransferstatusrequest_;
    request_.styletransferstatusrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_styletransferstatusrequest(::AnselIpc::StyleTransferStatusRequest* styletransferstatusrequest) {
  clear_request();
  if (styletransferstatusrequest) {
    set_has_styletransferstatusrequest();
    request_.styletransferstatusrequest_ = styletransferstatusrequest;
  }
}

// optional .AnselIpc.InsertFilterRequest insertFilterRequest = 44;
inline bool AnselIPCRequest::has_insertfilterrequest() const {
  return request_case() == kInsertFilterRequest;
}
inline void AnselIPCRequest::set_has_insertfilterrequest() {
  _oneof_case_[0] = kInsertFilterRequest;
}
inline void AnselIPCRequest::clear_insertfilterrequest() {
  if (has_insertfilterrequest()) {
    delete request_.insertfilterrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::InsertFilterRequest& AnselIPCRequest::insertfilterrequest() const {
  return has_insertfilterrequest() ? *request_.insertfilterrequest_
                      : ::AnselIpc::InsertFilterRequest::default_instance();
}
inline ::AnselIpc::InsertFilterRequest* AnselIPCRequest::mutable_insertfilterrequest() {
  if (!has_insertfilterrequest()) {
    clear_request();
    set_has_insertfilterrequest();
    request_.insertfilterrequest_ = new ::AnselIpc::InsertFilterRequest;
  }
  return request_.insertfilterrequest_;
}
inline ::AnselIpc::InsertFilterRequest* AnselIPCRequest::release_insertfilterrequest() {
  if (has_insertfilterrequest()) {
    clear_has_request();
    ::AnselIpc::InsertFilterRequest* temp = request_.insertfilterrequest_;
    request_.insertfilterrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_insertfilterrequest(::AnselIpc::InsertFilterRequest* insertfilterrequest) {
  clear_request();
  if (insertfilterrequest) {
    set_has_insertfilterrequest();
    request_.insertfilterrequest_ = insertfilterrequest;
  }
}

// optional .AnselIpc.RemoveFilterRequest removeFilterRequest = 45;
inline bool AnselIPCRequest::has_removefilterrequest() const {
  return request_case() == kRemoveFilterRequest;
}
inline void AnselIPCRequest::set_has_removefilterrequest() {
  _oneof_case_[0] = kRemoveFilterRequest;
}
inline void AnselIPCRequest::clear_removefilterrequest() {
  if (has_removefilterrequest()) {
    delete request_.removefilterrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::RemoveFilterRequest& AnselIPCRequest::removefilterrequest() const {
  return has_removefilterrequest() ? *request_.removefilterrequest_
                      : ::AnselIpc::RemoveFilterRequest::default_instance();
}
inline ::AnselIpc::RemoveFilterRequest* AnselIPCRequest::mutable_removefilterrequest() {
  if (!has_removefilterrequest()) {
    clear_request();
    set_has_removefilterrequest();
    request_.removefilterrequest_ = new ::AnselIpc::RemoveFilterRequest;
  }
  return request_.removefilterrequest_;
}
inline ::AnselIpc::RemoveFilterRequest* AnselIPCRequest::release_removefilterrequest() {
  if (has_removefilterrequest()) {
    clear_has_request();
    ::AnselIpc::RemoveFilterRequest* temp = request_.removefilterrequest_;
    request_.removefilterrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_removefilterrequest(::AnselIpc::RemoveFilterRequest* removefilterrequest) {
  clear_request();
  if (removefilterrequest) {
    set_has_removefilterrequest();
    request_.removefilterrequest_ = removefilterrequest;
  }
}

// optional .AnselIpc.MoveFilterRequest moveFilterRequest = 46;
inline bool AnselIPCRequest::has_movefilterrequest() const {
  return request_case() == kMoveFilterRequest;
}
inline void AnselIPCRequest::set_has_movefilterrequest() {
  _oneof_case_[0] = kMoveFilterRequest;
}
inline void AnselIPCRequest::clear_movefilterrequest() {
  if (has_movefilterrequest()) {
    delete request_.movefilterrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::MoveFilterRequest& AnselIPCRequest::movefilterrequest() const {
  return has_movefilterrequest() ? *request_.movefilterrequest_
                      : ::AnselIpc::MoveFilterRequest::default_instance();
}
inline ::AnselIpc::MoveFilterRequest* AnselIPCRequest::mutable_movefilterrequest() {
  if (!has_movefilterrequest()) {
    clear_request();
    set_has_movefilterrequest();
    request_.movefilterrequest_ = new ::AnselIpc::MoveFilterRequest;
  }
  return request_.movefilterrequest_;
}
inline ::AnselIpc::MoveFilterRequest* AnselIPCRequest::release_movefilterrequest() {
  if (has_movefilterrequest()) {
    clear_has_request();
    ::AnselIpc::MoveFilterRequest* temp = request_.movefilterrequest_;
    request_.movefilterrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_movefilterrequest(::AnselIpc::MoveFilterRequest* movefilterrequest) {
  clear_request();
  if (movefilterrequest) {
    set_has_movefilterrequest();
    request_.movefilterrequest_ = movefilterrequest;
  }
}

// optional .AnselIpc.GetStackInfoRequest getStackInfoRequest = 47;
inline bool AnselIPCRequest::has_getstackinforequest() const {
  return request_case() == kGetStackInfoRequest;
}
inline void AnselIPCRequest::set_has_getstackinforequest() {
  _oneof_case_[0] = kGetStackInfoRequest;
}
inline void AnselIPCRequest::clear_getstackinforequest() {
  if (has_getstackinforequest()) {
    delete request_.getstackinforequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::GetStackInfoRequest& AnselIPCRequest::getstackinforequest() const {
  return has_getstackinforequest() ? *request_.getstackinforequest_
                      : ::AnselIpc::GetStackInfoRequest::default_instance();
}
inline ::AnselIpc::GetStackInfoRequest* AnselIPCRequest::mutable_getstackinforequest() {
  if (!has_getstackinforequest()) {
    clear_request();
    set_has_getstackinforequest();
    request_.getstackinforequest_ = new ::AnselIpc::GetStackInfoRequest;
  }
  return request_.getstackinforequest_;
}
inline ::AnselIpc::GetStackInfoRequest* AnselIPCRequest::release_getstackinforequest() {
  if (has_getstackinforequest()) {
    clear_has_request();
    ::AnselIpc::GetStackInfoRequest* temp = request_.getstackinforequest_;
    request_.getstackinforequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_getstackinforequest(::AnselIpc::GetStackInfoRequest* getstackinforequest) {
  clear_request();
  if (getstackinforequest) {
    set_has_getstackinforequest();
    request_.getstackinforequest_ = getstackinforequest;
  }
}

// optional .AnselIpc.EstimateCaptureRequest estimateCaptureRequest = 48;
inline bool AnselIPCRequest::has_estimatecapturerequest() const {
  return request_case() == kEstimateCaptureRequest;
}
inline void AnselIPCRequest::set_has_estimatecapturerequest() {
  _oneof_case_[0] = kEstimateCaptureRequest;
}
inline void AnselIPCRequest::clear_estimatecapturerequest() {
  if (has_estimatecapturerequest()) {
    delete request_.estimatecapturerequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::EstimateCaptureRequest& AnselIPCRequest::estimatecapturerequest() const {
  return has_estimatecapturerequest() ? *request_.estimatecapturerequest_
                      : ::AnselIpc::EstimateCaptureRequest::default_instance();
}
inline ::AnselIpc::EstimateCaptureRequest* AnselIPCRequest::mutable_estimatecapturerequest() {
  if (!has_estimatecapturerequest()) {
    clear_request();
    set_has_estimatecapturerequest();
    request_.estimatecapturerequest_ = new ::AnselIpc::EstimateCaptureRequest;
  }
  return request_.estimatecapturerequest_;
}
inline ::AnselIpc::EstimateCaptureRequest* AnselIPCRequest::release_estimatecapturerequest() {
  if (has_estimatecapturerequest()) {
    clear_has_request();
    ::AnselIpc::EstimateCaptureRequest* temp = request_.estimatecapturerequest_;
    request_.estimatecapturerequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_estimatecapturerequest(::AnselIpc::EstimateCaptureRequest* estimatecapturerequest) {
  clear_request();
  if (estimatecapturerequest) {
    set_has_estimatecapturerequest();
    request_.estimatecapturerequest_ = estimatecapturerequest;
  }
}

// optional .AnselIpc.UIControlRemoveAllRequest uiControlRemoveAllRequest = 49;
inline bool AnselIPCRequest::has_uicontrolremoveallrequest() const {
  return request_case() == kUiControlRemoveAllRequest;
}
inline void AnselIPCRequest::set_has_uicontrolremoveallrequest() {
  _oneof_case_[0] = kUiControlRemoveAllRequest;
}
inline void AnselIPCRequest::clear_uicontrolremoveallrequest() {
  if (has_uicontrolremoveallrequest()) {
    delete request_.uicontrolremoveallrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::UIControlRemoveAllRequest& AnselIPCRequest::uicontrolremoveallrequest() const {
  return has_uicontrolremoveallrequest() ? *request_.uicontrolremoveallrequest_
                      : ::AnselIpc::UIControlRemoveAllRequest::default_instance();
}
inline ::AnselIpc::UIControlRemoveAllRequest* AnselIPCRequest::mutable_uicontrolremoveallrequest() {
  if (!has_uicontrolremoveallrequest()) {
    clear_request();
    set_has_uicontrolremoveallrequest();
    request_.uicontrolremoveallrequest_ = new ::AnselIpc::UIControlRemoveAllRequest;
  }
  return request_.uicontrolremoveallrequest_;
}
inline ::AnselIpc::UIControlRemoveAllRequest* AnselIPCRequest::release_uicontrolremoveallrequest() {
  if (has_uicontrolremoveallrequest()) {
    clear_has_request();
    ::AnselIpc::UIControlRemoveAllRequest* temp = request_.uicontrolremoveallrequest_;
    request_.uicontrolremoveallrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_uicontrolremoveallrequest(::AnselIpc::UIControlRemoveAllRequest* uicontrolremoveallrequest) {
  clear_request();
  if (uicontrolremoveallrequest) {
    set_has_uicontrolremoveallrequest();
    request_.uicontrolremoveallrequest_ = uicontrolremoveallrequest;
  }
}

// optional .AnselIpc.GetSettingsRequest getSettingsRequest = 50;
inline bool AnselIPCRequest::has_getsettingsrequest() const {
  return request_case() == kGetSettingsRequest;
}
inline void AnselIPCRequest::set_has_getsettingsrequest() {
  _oneof_case_[0] = kGetSettingsRequest;
}
inline void AnselIPCRequest::clear_getsettingsrequest() {
  if (has_getsettingsrequest()) {
    delete request_.getsettingsrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::GetSettingsRequest& AnselIPCRequest::getsettingsrequest() const {
  return has_getsettingsrequest() ? *request_.getsettingsrequest_
                      : ::AnselIpc::GetSettingsRequest::default_instance();
}
inline ::AnselIpc::GetSettingsRequest* AnselIPCRequest::mutable_getsettingsrequest() {
  if (!has_getsettingsrequest()) {
    clear_request();
    set_has_getsettingsrequest();
    request_.getsettingsrequest_ = new ::AnselIpc::GetSettingsRequest;
  }
  return request_.getsettingsrequest_;
}
inline ::AnselIpc::GetSettingsRequest* AnselIPCRequest::release_getsettingsrequest() {
  if (has_getsettingsrequest()) {
    clear_has_request();
    ::AnselIpc::GetSettingsRequest* temp = request_.getsettingsrequest_;
    request_.getsettingsrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_getsettingsrequest(::AnselIpc::GetSettingsRequest* getsettingsrequest) {
  clear_request();
  if (getsettingsrequest) {
    set_has_getsettingsrequest();
    request_.getsettingsrequest_ = getsettingsrequest;
  }
}

// optional .AnselIpc.AnselStatusReportRequest anselStatusReportRequest = 51;
inline bool AnselIPCRequest::has_anselstatusreportrequest() const {
  return request_case() == kAnselStatusReportRequest;
}
inline void AnselIPCRequest::set_has_anselstatusreportrequest() {
  _oneof_case_[0] = kAnselStatusReportRequest;
}
inline void AnselIPCRequest::clear_anselstatusreportrequest() {
  if (has_anselstatusreportrequest()) {
    delete request_.anselstatusreportrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::AnselStatusReportRequest& AnselIPCRequest::anselstatusreportrequest() const {
  return has_anselstatusreportrequest() ? *request_.anselstatusreportrequest_
                      : ::AnselIpc::AnselStatusReportRequest::default_instance();
}
inline ::AnselIpc::AnselStatusReportRequest* AnselIPCRequest::mutable_anselstatusreportrequest() {
  if (!has_anselstatusreportrequest()) {
    clear_request();
    set_has_anselstatusreportrequest();
    request_.anselstatusreportrequest_ = new ::AnselIpc::AnselStatusReportRequest;
  }
  return request_.anselstatusreportrequest_;
}
inline ::AnselIpc::AnselStatusReportRequest* AnselIPCRequest::release_anselstatusreportrequest() {
  if (has_anselstatusreportrequest()) {
    clear_has_request();
    ::AnselIpc::AnselStatusReportRequest* temp = request_.anselstatusreportrequest_;
    request_.anselstatusreportrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_anselstatusreportrequest(::AnselIpc::AnselStatusReportRequest* anselstatusreportrequest) {
  clear_request();
  if (anselstatusreportrequest) {
    set_has_anselstatusreportrequest();
    request_.anselstatusreportrequest_ = anselstatusreportrequest;
  }
}

// optional .AnselIpc.StyleTransferSideloadChoiceRequest styleTransferSideloadChoiceRequest = 52;
inline bool AnselIPCRequest::has_styletransfersideloadchoicerequest() const {
  return request_case() == kStyleTransferSideloadChoiceRequest;
}
inline void AnselIPCRequest::set_has_styletransfersideloadchoicerequest() {
  _oneof_case_[0] = kStyleTransferSideloadChoiceRequest;
}
inline void AnselIPCRequest::clear_styletransfersideloadchoicerequest() {
  if (has_styletransfersideloadchoicerequest()) {
    delete request_.styletransfersideloadchoicerequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::StyleTransferSideloadChoiceRequest& AnselIPCRequest::styletransfersideloadchoicerequest() const {
  return has_styletransfersideloadchoicerequest() ? *request_.styletransfersideloadchoicerequest_
                      : ::AnselIpc::StyleTransferSideloadChoiceRequest::default_instance();
}
inline ::AnselIpc::StyleTransferSideloadChoiceRequest* AnselIPCRequest::mutable_styletransfersideloadchoicerequest() {
  if (!has_styletransfersideloadchoicerequest()) {
    clear_request();
    set_has_styletransfersideloadchoicerequest();
    request_.styletransfersideloadchoicerequest_ = new ::AnselIpc::StyleTransferSideloadChoiceRequest;
  }
  return request_.styletransfersideloadchoicerequest_;
}
inline ::AnselIpc::StyleTransferSideloadChoiceRequest* AnselIPCRequest::release_styletransfersideloadchoicerequest() {
  if (has_styletransfersideloadchoicerequest()) {
    clear_has_request();
    ::AnselIpc::StyleTransferSideloadChoiceRequest* temp = request_.styletransfersideloadchoicerequest_;
    request_.styletransfersideloadchoicerequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_styletransfersideloadchoicerequest(::AnselIpc::StyleTransferSideloadChoiceRequest* styletransfersideloadchoicerequest) {
  clear_request();
  if (styletransfersideloadchoicerequest) {
    set_has_styletransfersideloadchoicerequest();
    request_.styletransfersideloadchoicerequest_ = styletransfersideloadchoicerequest;
  }
}

// optional .AnselIpc.StyleTransferSideloadProgressRequest styleTransferSideloadProgressRequest = 53;
inline bool AnselIPCRequest::has_styletransfersideloadprogressrequest() const {
  return request_case() == kStyleTransferSideloadProgressRequest;
}
inline void AnselIPCRequest::set_has_styletransfersideloadprogressrequest() {
  _oneof_case_[0] = kStyleTransferSideloadProgressRequest;
}
inline void AnselIPCRequest::clear_styletransfersideloadprogressrequest() {
  if (has_styletransfersideloadprogressrequest()) {
    delete request_.styletransfersideloadprogressrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::StyleTransferSideloadProgressRequest& AnselIPCRequest::styletransfersideloadprogressrequest() const {
  return has_styletransfersideloadprogressrequest() ? *request_.styletransfersideloadprogressrequest_
                      : ::AnselIpc::StyleTransferSideloadProgressRequest::default_instance();
}
inline ::AnselIpc::StyleTransferSideloadProgressRequest* AnselIPCRequest::mutable_styletransfersideloadprogressrequest() {
  if (!has_styletransfersideloadprogressrequest()) {
    clear_request();
    set_has_styletransfersideloadprogressrequest();
    request_.styletransfersideloadprogressrequest_ = new ::AnselIpc::StyleTransferSideloadProgressRequest;
  }
  return request_.styletransfersideloadprogressrequest_;
}
inline ::AnselIpc::StyleTransferSideloadProgressRequest* AnselIPCRequest::release_styletransfersideloadprogressrequest() {
  if (has_styletransfersideloadprogressrequest()) {
    clear_has_request();
    ::AnselIpc::StyleTransferSideloadProgressRequest* temp = request_.styletransfersideloadprogressrequest_;
    request_.styletransfersideloadprogressrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_styletransfersideloadprogressrequest(::AnselIpc::StyleTransferSideloadProgressRequest* styletransfersideloadprogressrequest) {
  clear_request();
  if (styletransfersideloadprogressrequest) {
    set_has_styletransfersideloadprogressrequest();
    request_.styletransfersideloadprogressrequest_ = styletransfersideloadprogressrequest;
  }
}

// optional .AnselIpc.UpdateRollRequest updateRollRequest = 54;
inline bool AnselIPCRequest::has_updaterollrequest() const {
  return request_case() == kUpdateRollRequest;
}
inline void AnselIPCRequest::set_has_updaterollrequest() {
  _oneof_case_[0] = kUpdateRollRequest;
}
inline void AnselIPCRequest::clear_updaterollrequest() {
  if (has_updaterollrequest()) {
    delete request_.updaterollrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::UpdateRollRequest& AnselIPCRequest::updaterollrequest() const {
  return has_updaterollrequest() ? *request_.updaterollrequest_
                      : ::AnselIpc::UpdateRollRequest::default_instance();
}
inline ::AnselIpc::UpdateRollRequest* AnselIPCRequest::mutable_updaterollrequest() {
  if (!has_updaterollrequest()) {
    clear_request();
    set_has_updaterollrequest();
    request_.updaterollrequest_ = new ::AnselIpc::UpdateRollRequest;
  }
  return request_.updaterollrequest_;
}
inline ::AnselIpc::UpdateRollRequest* AnselIPCRequest::release_updaterollrequest() {
  if (has_updaterollrequest()) {
    clear_has_request();
    ::AnselIpc::UpdateRollRequest* temp = request_.updaterollrequest_;
    request_.updaterollrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_updaterollrequest(::AnselIpc::UpdateRollRequest* updaterollrequest) {
  clear_request();
  if (updaterollrequest) {
    set_has_updaterollrequest();
    request_.updaterollrequest_ = updaterollrequest;
  }
}

// optional .AnselIpc.GetGameSpecificControlsRequest getGameSpecificControlsRequest = 55;
inline bool AnselIPCRequest::has_getgamespecificcontrolsrequest() const {
  return request_case() == kGetGameSpecificControlsRequest;
}
inline void AnselIPCRequest::set_has_getgamespecificcontrolsrequest() {
  _oneof_case_[0] = kGetGameSpecificControlsRequest;
}
inline void AnselIPCRequest::clear_getgamespecificcontrolsrequest() {
  if (has_getgamespecificcontrolsrequest()) {
    delete request_.getgamespecificcontrolsrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::GetGameSpecificControlsRequest& AnselIPCRequest::getgamespecificcontrolsrequest() const {
  return has_getgamespecificcontrolsrequest() ? *request_.getgamespecificcontrolsrequest_
                      : ::AnselIpc::GetGameSpecificControlsRequest::default_instance();
}
inline ::AnselIpc::GetGameSpecificControlsRequest* AnselIPCRequest::mutable_getgamespecificcontrolsrequest() {
  if (!has_getgamespecificcontrolsrequest()) {
    clear_request();
    set_has_getgamespecificcontrolsrequest();
    request_.getgamespecificcontrolsrequest_ = new ::AnselIpc::GetGameSpecificControlsRequest;
  }
  return request_.getgamespecificcontrolsrequest_;
}
inline ::AnselIpc::GetGameSpecificControlsRequest* AnselIPCRequest::release_getgamespecificcontrolsrequest() {
  if (has_getgamespecificcontrolsrequest()) {
    clear_has_request();
    ::AnselIpc::GetGameSpecificControlsRequest* temp = request_.getgamespecificcontrolsrequest_;
    request_.getgamespecificcontrolsrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_getgamespecificcontrolsrequest(::AnselIpc::GetGameSpecificControlsRequest* getgamespecificcontrolsrequest) {
  clear_request();
  if (getgamespecificcontrolsrequest) {
    set_has_getgamespecificcontrolsrequest();
    request_.getgamespecificcontrolsrequest_ = getgamespecificcontrolsrequest;
  }
}

// optional .AnselIpc.GetEnabledFeatureSetRequest getEnabledFeatureSetRequest = 56;
inline bool AnselIPCRequest::has_getenabledfeaturesetrequest() const {
  return request_case() == kGetEnabledFeatureSetRequest;
}
inline void AnselIPCRequest::set_has_getenabledfeaturesetrequest() {
  _oneof_case_[0] = kGetEnabledFeatureSetRequest;
}
inline void AnselIPCRequest::clear_getenabledfeaturesetrequest() {
  if (has_getenabledfeaturesetrequest()) {
    delete request_.getenabledfeaturesetrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::GetEnabledFeatureSetRequest& AnselIPCRequest::getenabledfeaturesetrequest() const {
  return has_getenabledfeaturesetrequest() ? *request_.getenabledfeaturesetrequest_
                      : ::AnselIpc::GetEnabledFeatureSetRequest::default_instance();
}
inline ::AnselIpc::GetEnabledFeatureSetRequest* AnselIPCRequest::mutable_getenabledfeaturesetrequest() {
  if (!has_getenabledfeaturesetrequest()) {
    clear_request();
    set_has_getenabledfeaturesetrequest();
    request_.getenabledfeaturesetrequest_ = new ::AnselIpc::GetEnabledFeatureSetRequest;
  }
  return request_.getenabledfeaturesetrequest_;
}
inline ::AnselIpc::GetEnabledFeatureSetRequest* AnselIPCRequest::release_getenabledfeaturesetrequest() {
  if (has_getenabledfeaturesetrequest()) {
    clear_has_request();
    ::AnselIpc::GetEnabledFeatureSetRequest* temp = request_.getenabledfeaturesetrequest_;
    request_.getenabledfeaturesetrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_getenabledfeaturesetrequest(::AnselIpc::GetEnabledFeatureSetRequest* getenabledfeaturesetrequest) {
  clear_request();
  if (getenabledfeaturesetrequest) {
    set_has_getenabledfeaturesetrequest();
    request_.getenabledfeaturesetrequest_ = getenabledfeaturesetrequest;
  }
}

// optional .AnselIpc.UpdateFovRequest updateFovRequest = 57;
inline bool AnselIPCRequest::has_updatefovrequest() const {
  return request_case() == kUpdateFovRequest;
}
inline void AnselIPCRequest::set_has_updatefovrequest() {
  _oneof_case_[0] = kUpdateFovRequest;
}
inline void AnselIPCRequest::clear_updatefovrequest() {
  if (has_updatefovrequest()) {
    delete request_.updatefovrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::UpdateFovRequest& AnselIPCRequest::updatefovrequest() const {
  return has_updatefovrequest() ? *request_.updatefovrequest_
                      : ::AnselIpc::UpdateFovRequest::default_instance();
}
inline ::AnselIpc::UpdateFovRequest* AnselIPCRequest::mutable_updatefovrequest() {
  if (!has_updatefovrequest()) {
    clear_request();
    set_has_updatefovrequest();
    request_.updatefovrequest_ = new ::AnselIpc::UpdateFovRequest;
  }
  return request_.updatefovrequest_;
}
inline ::AnselIpc::UpdateFovRequest* AnselIPCRequest::release_updatefovrequest() {
  if (has_updatefovrequest()) {
    clear_has_request();
    ::AnselIpc::UpdateFovRequest* temp = request_.updatefovrequest_;
    request_.updatefovrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_updatefovrequest(::AnselIpc::UpdateFovRequest* updatefovrequest) {
  clear_request();
  if (updatefovrequest) {
    set_has_updatefovrequest();
    request_.updatefovrequest_ = updatefovrequest;
  }
}

// optional .AnselIpc.AnselReadyRequest anselReadyRequest = 58;
inline bool AnselIPCRequest::has_anselreadyrequest() const {
  return request_case() == kAnselReadyRequest;
}
inline void AnselIPCRequest::set_has_anselreadyrequest() {
  _oneof_case_[0] = kAnselReadyRequest;
}
inline void AnselIPCRequest::clear_anselreadyrequest() {
  if (has_anselreadyrequest()) {
    delete request_.anselreadyrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::AnselReadyRequest& AnselIPCRequest::anselreadyrequest() const {
  return has_anselreadyrequest() ? *request_.anselreadyrequest_
                      : ::AnselIpc::AnselReadyRequest::default_instance();
}
inline ::AnselIpc::AnselReadyRequest* AnselIPCRequest::mutable_anselreadyrequest() {
  if (!has_anselreadyrequest()) {
    clear_request();
    set_has_anselreadyrequest();
    request_.anselreadyrequest_ = new ::AnselIpc::AnselReadyRequest;
  }
  return request_.anselreadyrequest_;
}
inline ::AnselIpc::AnselReadyRequest* AnselIPCRequest::release_anselreadyrequest() {
  if (has_anselreadyrequest()) {
    clear_has_request();
    ::AnselIpc::AnselReadyRequest* temp = request_.anselreadyrequest_;
    request_.anselreadyrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_anselreadyrequest(::AnselIpc::AnselReadyRequest* anselreadyrequest) {
  clear_request();
  if (anselreadyrequest) {
    set_has_anselreadyrequest();
    request_.anselreadyrequest_ = anselreadyrequest;
  }
}

// optional .AnselIpc.SetHighQualityRequest setHighQualityRequest = 59;
inline bool AnselIPCRequest::has_sethighqualityrequest() const {
  return request_case() == kSetHighQualityRequest;
}
inline void AnselIPCRequest::set_has_sethighqualityrequest() {
  _oneof_case_[0] = kSetHighQualityRequest;
}
inline void AnselIPCRequest::clear_sethighqualityrequest() {
  if (has_sethighqualityrequest()) {
    delete request_.sethighqualityrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::SetHighQualityRequest& AnselIPCRequest::sethighqualityrequest() const {
  return has_sethighqualityrequest() ? *request_.sethighqualityrequest_
                      : ::AnselIpc::SetHighQualityRequest::default_instance();
}
inline ::AnselIpc::SetHighQualityRequest* AnselIPCRequest::mutable_sethighqualityrequest() {
  if (!has_sethighqualityrequest()) {
    clear_request();
    set_has_sethighqualityrequest();
    request_.sethighqualityrequest_ = new ::AnselIpc::SetHighQualityRequest;
  }
  return request_.sethighqualityrequest_;
}
inline ::AnselIpc::SetHighQualityRequest* AnselIPCRequest::release_sethighqualityrequest() {
  if (has_sethighqualityrequest()) {
    clear_has_request();
    ::AnselIpc::SetHighQualityRequest* temp = request_.sethighqualityrequest_;
    request_.sethighqualityrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_sethighqualityrequest(::AnselIpc::SetHighQualityRequest* sethighqualityrequest) {
  clear_request();
  if (sethighqualityrequest) {
    set_has_sethighqualityrequest();
    request_.sethighqualityrequest_ = sethighqualityrequest;
  }
}

// optional .AnselIpc.SetFilterAndAttributesRequest setFilterAndAttributesRequest = 60;
inline bool AnselIPCRequest::has_setfilterandattributesrequest() const {
  return request_case() == kSetFilterAndAttributesRequest;
}
inline void AnselIPCRequest::set_has_setfilterandattributesrequest() {
  _oneof_case_[0] = kSetFilterAndAttributesRequest;
}
inline void AnselIPCRequest::clear_setfilterandattributesrequest() {
  if (has_setfilterandattributesrequest()) {
    delete request_.setfilterandattributesrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::SetFilterAndAttributesRequest& AnselIPCRequest::setfilterandattributesrequest() const {
  return has_setfilterandattributesrequest() ? *request_.setfilterandattributesrequest_
                      : ::AnselIpc::SetFilterAndAttributesRequest::default_instance();
}
inline ::AnselIpc::SetFilterAndAttributesRequest* AnselIPCRequest::mutable_setfilterandattributesrequest() {
  if (!has_setfilterandattributesrequest()) {
    clear_request();
    set_has_setfilterandattributesrequest();
    request_.setfilterandattributesrequest_ = new ::AnselIpc::SetFilterAndAttributesRequest;
  }
  return request_.setfilterandattributesrequest_;
}
inline ::AnselIpc::SetFilterAndAttributesRequest* AnselIPCRequest::release_setfilterandattributesrequest() {
  if (has_setfilterandattributesrequest()) {
    clear_has_request();
    ::AnselIpc::SetFilterAndAttributesRequest* temp = request_.setfilterandattributesrequest_;
    request_.setfilterandattributesrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_setfilterandattributesrequest(::AnselIpc::SetFilterAndAttributesRequest* setfilterandattributesrequest) {
  clear_request();
  if (setfilterandattributesrequest) {
    set_has_setfilterandattributesrequest();
    request_.setfilterandattributesrequest_ = setfilterandattributesrequest;
  }
}

// optional .AnselIpc.SetCMSInfoRequest setCMSInfoRequest = 61;
inline bool AnselIPCRequest::has_setcmsinforequest() const {
  return request_case() == kSetCMSInfoRequest;
}
inline void AnselIPCRequest::set_has_setcmsinforequest() {
  _oneof_case_[0] = kSetCMSInfoRequest;
}
inline void AnselIPCRequest::clear_setcmsinforequest() {
  if (has_setcmsinforequest()) {
    delete request_.setcmsinforequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::SetCMSInfoRequest& AnselIPCRequest::setcmsinforequest() const {
  return has_setcmsinforequest() ? *request_.setcmsinforequest_
                      : ::AnselIpc::SetCMSInfoRequest::default_instance();
}
inline ::AnselIpc::SetCMSInfoRequest* AnselIPCRequest::mutable_setcmsinforequest() {
  if (!has_setcmsinforequest()) {
    clear_request();
    set_has_setcmsinforequest();
    request_.setcmsinforequest_ = new ::AnselIpc::SetCMSInfoRequest;
  }
  return request_.setcmsinforequest_;
}
inline ::AnselIpc::SetCMSInfoRequest* AnselIPCRequest::release_setcmsinforequest() {
  if (has_setcmsinforequest()) {
    clear_has_request();
    ::AnselIpc::SetCMSInfoRequest* temp = request_.setcmsinforequest_;
    request_.setcmsinforequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_setcmsinforequest(::AnselIpc::SetCMSInfoRequest* setcmsinforequest) {
  clear_request();
  if (setcmsinforequest) {
    set_has_setcmsinforequest();
    request_.setcmsinforequest_ = setcmsinforequest;
  }
}

// optional .AnselIpc.MultipleInputEventRequest multipleInputEventRequest = 62;
inline bool AnselIPCRequest::has_multipleinputeventrequest() const {
  return request_case() == kMultipleInputEventRequest;
}
inline void AnselIPCRequest::set_has_multipleinputeventrequest() {
  _oneof_case_[0] = kMultipleInputEventRequest;
}
inline void AnselIPCRequest::clear_multipleinputeventrequest() {
  if (has_multipleinputeventrequest()) {
    delete request_.multipleinputeventrequest_;
    clear_has_request();
  }
}
inline const ::AnselIpc::MultipleInputEventRequest& AnselIPCRequest::multipleinputeventrequest() const {
  return has_multipleinputeventrequest() ? *request_.multipleinputeventrequest_
                      : ::AnselIpc::MultipleInputEventRequest::default_instance();
}
inline ::AnselIpc::MultipleInputEventRequest* AnselIPCRequest::mutable_multipleinputeventrequest() {
  if (!has_multipleinputeventrequest()) {
    clear_request();
    set_has_multipleinputeventrequest();
    request_.multipleinputeventrequest_ = new ::AnselIpc::MultipleInputEventRequest;
  }
  return request_.multipleinputeventrequest_;
}
inline ::AnselIpc::MultipleInputEventRequest* AnselIPCRequest::release_multipleinputeventrequest() {
  if (has_multipleinputeventrequest()) {
    clear_has_request();
    ::AnselIpc::MultipleInputEventRequest* temp = request_.multipleinputeventrequest_;
    request_.multipleinputeventrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCRequest::set_allocated_multipleinputeventrequest(::AnselIpc::MultipleInputEventRequest* multipleinputeventrequest) {
  clear_request();
  if (multipleinputeventrequest) {
    set_has_multipleinputeventrequest();
    request_.multipleinputeventrequest_ = multipleinputeventrequest;
  }
}

inline bool AnselIPCRequest::has_request() {
  return request_case() != REQUEST_NOT_SET;
}
inline void AnselIPCRequest::clear_has_request() {
  _oneof_case_[0] = REQUEST_NOT_SET;
}
inline AnselIPCRequest::RequestCase AnselIPCRequest::request_case() const {
  return AnselIPCRequest::RequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AnselIPCResponse

// optional .AnselIpc.GetFilterListResponse getFilterListResponse = 1;
inline bool AnselIPCResponse::has_getfilterlistresponse() const {
  return response_case() == kGetFilterListResponse;
}
inline void AnselIPCResponse::set_has_getfilterlistresponse() {
  _oneof_case_[0] = kGetFilterListResponse;
}
inline void AnselIPCResponse::clear_getfilterlistresponse() {
  if (has_getfilterlistresponse()) {
    delete response_.getfilterlistresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::GetFilterListResponse& AnselIPCResponse::getfilterlistresponse() const {
  return has_getfilterlistresponse() ? *response_.getfilterlistresponse_
                      : ::AnselIpc::GetFilterListResponse::default_instance();
}
inline ::AnselIpc::GetFilterListResponse* AnselIPCResponse::mutable_getfilterlistresponse() {
  if (!has_getfilterlistresponse()) {
    clear_response();
    set_has_getfilterlistresponse();
    response_.getfilterlistresponse_ = new ::AnselIpc::GetFilterListResponse;
  }
  return response_.getfilterlistresponse_;
}
inline ::AnselIpc::GetFilterListResponse* AnselIPCResponse::release_getfilterlistresponse() {
  if (has_getfilterlistresponse()) {
    clear_has_response();
    ::AnselIpc::GetFilterListResponse* temp = response_.getfilterlistresponse_;
    response_.getfilterlistresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_getfilterlistresponse(::AnselIpc::GetFilterListResponse* getfilterlistresponse) {
  clear_response();
  if (getfilterlistresponse) {
    set_has_getfilterlistresponse();
    response_.getfilterlistresponse_ = getfilterlistresponse;
  }
}

// optional .AnselIpc.GetHighresResolutionListResponse getHighresResolutionListResponse = 2;
inline bool AnselIPCResponse::has_gethighresresolutionlistresponse() const {
  return response_case() == kGetHighresResolutionListResponse;
}
inline void AnselIPCResponse::set_has_gethighresresolutionlistresponse() {
  _oneof_case_[0] = kGetHighresResolutionListResponse;
}
inline void AnselIPCResponse::clear_gethighresresolutionlistresponse() {
  if (has_gethighresresolutionlistresponse()) {
    delete response_.gethighresresolutionlistresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::GetHighresResolutionListResponse& AnselIPCResponse::gethighresresolutionlistresponse() const {
  return has_gethighresresolutionlistresponse() ? *response_.gethighresresolutionlistresponse_
                      : ::AnselIpc::GetHighresResolutionListResponse::default_instance();
}
inline ::AnselIpc::GetHighresResolutionListResponse* AnselIPCResponse::mutable_gethighresresolutionlistresponse() {
  if (!has_gethighresresolutionlistresponse()) {
    clear_response();
    set_has_gethighresresolutionlistresponse();
    response_.gethighresresolutionlistresponse_ = new ::AnselIpc::GetHighresResolutionListResponse;
  }
  return response_.gethighresresolutionlistresponse_;
}
inline ::AnselIpc::GetHighresResolutionListResponse* AnselIPCResponse::release_gethighresresolutionlistresponse() {
  if (has_gethighresresolutionlistresponse()) {
    clear_has_response();
    ::AnselIpc::GetHighresResolutionListResponse* temp = response_.gethighresresolutionlistresponse_;
    response_.gethighresresolutionlistresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_gethighresresolutionlistresponse(::AnselIpc::GetHighresResolutionListResponse* gethighresresolutionlistresponse) {
  clear_response();
  if (gethighresresolutionlistresponse) {
    set_has_gethighresresolutionlistresponse();
    response_.gethighresresolutionlistresponse_ = gethighresresolutionlistresponse;
  }
}

// optional .AnselIpc.CaptureShotStartedResponse captureShotStartedResponse = 3;
inline bool AnselIPCResponse::has_captureshotstartedresponse() const {
  return response_case() == kCaptureShotStartedResponse;
}
inline void AnselIPCResponse::set_has_captureshotstartedresponse() {
  _oneof_case_[0] = kCaptureShotStartedResponse;
}
inline void AnselIPCResponse::clear_captureshotstartedresponse() {
  if (has_captureshotstartedresponse()) {
    delete response_.captureshotstartedresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::CaptureShotStartedResponse& AnselIPCResponse::captureshotstartedresponse() const {
  return has_captureshotstartedresponse() ? *response_.captureshotstartedresponse_
                      : ::AnselIpc::CaptureShotStartedResponse::default_instance();
}
inline ::AnselIpc::CaptureShotStartedResponse* AnselIPCResponse::mutable_captureshotstartedresponse() {
  if (!has_captureshotstartedresponse()) {
    clear_response();
    set_has_captureshotstartedresponse();
    response_.captureshotstartedresponse_ = new ::AnselIpc::CaptureShotStartedResponse;
  }
  return response_.captureshotstartedresponse_;
}
inline ::AnselIpc::CaptureShotStartedResponse* AnselIPCResponse::release_captureshotstartedresponse() {
  if (has_captureshotstartedresponse()) {
    clear_has_response();
    ::AnselIpc::CaptureShotStartedResponse* temp = response_.captureshotstartedresponse_;
    response_.captureshotstartedresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_captureshotstartedresponse(::AnselIpc::CaptureShotStartedResponse* captureshotstartedresponse) {
  clear_response();
  if (captureshotstartedresponse) {
    set_has_captureshotstartedresponse();
    response_.captureshotstartedresponse_ = captureshotstartedresponse;
  }
}

// optional .AnselIpc.CaptureShotFinishedResponse captureShotFinishedResponse = 4;
inline bool AnselIPCResponse::has_captureshotfinishedresponse() const {
  return response_case() == kCaptureShotFinishedResponse;
}
inline void AnselIPCResponse::set_has_captureshotfinishedresponse() {
  _oneof_case_[0] = kCaptureShotFinishedResponse;
}
inline void AnselIPCResponse::clear_captureshotfinishedresponse() {
  if (has_captureshotfinishedresponse()) {
    delete response_.captureshotfinishedresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::CaptureShotFinishedResponse& AnselIPCResponse::captureshotfinishedresponse() const {
  return has_captureshotfinishedresponse() ? *response_.captureshotfinishedresponse_
                      : ::AnselIpc::CaptureShotFinishedResponse::default_instance();
}
inline ::AnselIpc::CaptureShotFinishedResponse* AnselIPCResponse::mutable_captureshotfinishedresponse() {
  if (!has_captureshotfinishedresponse()) {
    clear_response();
    set_has_captureshotfinishedresponse();
    response_.captureshotfinishedresponse_ = new ::AnselIpc::CaptureShotFinishedResponse;
  }
  return response_.captureshotfinishedresponse_;
}
inline ::AnselIpc::CaptureShotFinishedResponse* AnselIPCResponse::release_captureshotfinishedresponse() {
  if (has_captureshotfinishedresponse()) {
    clear_has_response();
    ::AnselIpc::CaptureShotFinishedResponse* temp = response_.captureshotfinishedresponse_;
    response_.captureshotfinishedresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_captureshotfinishedresponse(::AnselIpc::CaptureShotFinishedResponse* captureshotfinishedresponse) {
  clear_response();
  if (captureshotfinishedresponse) {
    set_has_captureshotfinishedresponse();
    response_.captureshotfinishedresponse_ = captureshotfinishedresponse;
  }
}

// optional .AnselIpc.CaptureShotProcessingFinishedResponse captureShotProcessingFinishedResponse = 5;
inline bool AnselIPCResponse::has_captureshotprocessingfinishedresponse() const {
  return response_case() == kCaptureShotProcessingFinishedResponse;
}
inline void AnselIPCResponse::set_has_captureshotprocessingfinishedresponse() {
  _oneof_case_[0] = kCaptureShotProcessingFinishedResponse;
}
inline void AnselIPCResponse::clear_captureshotprocessingfinishedresponse() {
  if (has_captureshotprocessingfinishedresponse()) {
    delete response_.captureshotprocessingfinishedresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::CaptureShotProcessingFinishedResponse& AnselIPCResponse::captureshotprocessingfinishedresponse() const {
  return has_captureshotprocessingfinishedresponse() ? *response_.captureshotprocessingfinishedresponse_
                      : ::AnselIpc::CaptureShotProcessingFinishedResponse::default_instance();
}
inline ::AnselIpc::CaptureShotProcessingFinishedResponse* AnselIPCResponse::mutable_captureshotprocessingfinishedresponse() {
  if (!has_captureshotprocessingfinishedresponse()) {
    clear_response();
    set_has_captureshotprocessingfinishedresponse();
    response_.captureshotprocessingfinishedresponse_ = new ::AnselIpc::CaptureShotProcessingFinishedResponse;
  }
  return response_.captureshotprocessingfinishedresponse_;
}
inline ::AnselIpc::CaptureShotProcessingFinishedResponse* AnselIPCResponse::release_captureshotprocessingfinishedresponse() {
  if (has_captureshotprocessingfinishedresponse()) {
    clear_has_response();
    ::AnselIpc::CaptureShotProcessingFinishedResponse* temp = response_.captureshotprocessingfinishedresponse_;
    response_.captureshotprocessingfinishedresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_captureshotprocessingfinishedresponse(::AnselIpc::CaptureShotProcessingFinishedResponse* captureshotprocessingfinishedresponse) {
  clear_response();
  if (captureshotprocessingfinishedresponse) {
    set_has_captureshotprocessingfinishedresponse();
    response_.captureshotprocessingfinishedresponse_ = captureshotprocessingfinishedresponse;
  }
}

// optional .AnselIpc.Get360ResolutionRangeResponse get360ResolutionRangeResponse = 6;
inline bool AnselIPCResponse::has_get360resolutionrangeresponse() const {
  return response_case() == kGet360ResolutionRangeResponse;
}
inline void AnselIPCResponse::set_has_get360resolutionrangeresponse() {
  _oneof_case_[0] = kGet360ResolutionRangeResponse;
}
inline void AnselIPCResponse::clear_get360resolutionrangeresponse() {
  if (has_get360resolutionrangeresponse()) {
    delete response_.get360resolutionrangeresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::Get360ResolutionRangeResponse& AnselIPCResponse::get360resolutionrangeresponse() const {
  return has_get360resolutionrangeresponse() ? *response_.get360resolutionrangeresponse_
                      : ::AnselIpc::Get360ResolutionRangeResponse::default_instance();
}
inline ::AnselIpc::Get360ResolutionRangeResponse* AnselIPCResponse::mutable_get360resolutionrangeresponse() {
  if (!has_get360resolutionrangeresponse()) {
    clear_response();
    set_has_get360resolutionrangeresponse();
    response_.get360resolutionrangeresponse_ = new ::AnselIpc::Get360ResolutionRangeResponse;
  }
  return response_.get360resolutionrangeresponse_;
}
inline ::AnselIpc::Get360ResolutionRangeResponse* AnselIPCResponse::release_get360resolutionrangeresponse() {
  if (has_get360resolutionrangeresponse()) {
    clear_has_response();
    ::AnselIpc::Get360ResolutionRangeResponse* temp = response_.get360resolutionrangeresponse_;
    response_.get360resolutionrangeresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_get360resolutionrangeresponse(::AnselIpc::Get360ResolutionRangeResponse* get360resolutionrangeresponse) {
  clear_response();
  if (get360resolutionrangeresponse) {
    set_has_get360resolutionrangeresponse();
    response_.get360resolutionrangeresponse_ = get360resolutionrangeresponse;
  }
}

// optional .AnselIpc.GetFOVRangeResponse getFOVRangeResponse = 7;
inline bool AnselIPCResponse::has_getfovrangeresponse() const {
  return response_case() == kGetFOVRangeResponse;
}
inline void AnselIPCResponse::set_has_getfovrangeresponse() {
  _oneof_case_[0] = kGetFOVRangeResponse;
}
inline void AnselIPCResponse::clear_getfovrangeresponse() {
  if (has_getfovrangeresponse()) {
    delete response_.getfovrangeresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::GetFOVRangeResponse& AnselIPCResponse::getfovrangeresponse() const {
  return has_getfovrangeresponse() ? *response_.getfovrangeresponse_
                      : ::AnselIpc::GetFOVRangeResponse::default_instance();
}
inline ::AnselIpc::GetFOVRangeResponse* AnselIPCResponse::mutable_getfovrangeresponse() {
  if (!has_getfovrangeresponse()) {
    clear_response();
    set_has_getfovrangeresponse();
    response_.getfovrangeresponse_ = new ::AnselIpc::GetFOVRangeResponse;
  }
  return response_.getfovrangeresponse_;
}
inline ::AnselIpc::GetFOVRangeResponse* AnselIPCResponse::release_getfovrangeresponse() {
  if (has_getfovrangeresponse()) {
    clear_has_response();
    ::AnselIpc::GetFOVRangeResponse* temp = response_.getfovrangeresponse_;
    response_.getfovrangeresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_getfovrangeresponse(::AnselIpc::GetFOVRangeResponse* getfovrangeresponse) {
  clear_response();
  if (getfovrangeresponse) {
    set_has_getfovrangeresponse();
    response_.getfovrangeresponse_ = getfovrangeresponse;
  }
}

// optional .AnselIpc.SetFOVResponse setFOVResponse = 8;
inline bool AnselIPCResponse::has_setfovresponse() const {
  return response_case() == kSetFOVResponse;
}
inline void AnselIPCResponse::set_has_setfovresponse() {
  _oneof_case_[0] = kSetFOVResponse;
}
inline void AnselIPCResponse::clear_setfovresponse() {
  if (has_setfovresponse()) {
    delete response_.setfovresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::SetFOVResponse& AnselIPCResponse::setfovresponse() const {
  return has_setfovresponse() ? *response_.setfovresponse_
                      : ::AnselIpc::SetFOVResponse::default_instance();
}
inline ::AnselIpc::SetFOVResponse* AnselIPCResponse::mutable_setfovresponse() {
  if (!has_setfovresponse()) {
    clear_response();
    set_has_setfovresponse();
    response_.setfovresponse_ = new ::AnselIpc::SetFOVResponse;
  }
  return response_.setfovresponse_;
}
inline ::AnselIpc::SetFOVResponse* AnselIPCResponse::release_setfovresponse() {
  if (has_setfovresponse()) {
    clear_has_response();
    ::AnselIpc::SetFOVResponse* temp = response_.setfovresponse_;
    response_.setfovresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_setfovresponse(::AnselIpc::SetFOVResponse* setfovresponse) {
  clear_response();
  if (setfovresponse) {
    set_has_setfovresponse();
    response_.setfovresponse_ = setfovresponse;
  }
}

// optional .AnselIpc.GetRollRangeResponse getRollRangeResponse = 9;
inline bool AnselIPCResponse::has_getrollrangeresponse() const {
  return response_case() == kGetRollRangeResponse;
}
inline void AnselIPCResponse::set_has_getrollrangeresponse() {
  _oneof_case_[0] = kGetRollRangeResponse;
}
inline void AnselIPCResponse::clear_getrollrangeresponse() {
  if (has_getrollrangeresponse()) {
    delete response_.getrollrangeresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::GetRollRangeResponse& AnselIPCResponse::getrollrangeresponse() const {
  return has_getrollrangeresponse() ? *response_.getrollrangeresponse_
                      : ::AnselIpc::GetRollRangeResponse::default_instance();
}
inline ::AnselIpc::GetRollRangeResponse* AnselIPCResponse::mutable_getrollrangeresponse() {
  if (!has_getrollrangeresponse()) {
    clear_response();
    set_has_getrollrangeresponse();
    response_.getrollrangeresponse_ = new ::AnselIpc::GetRollRangeResponse;
  }
  return response_.getrollrangeresponse_;
}
inline ::AnselIpc::GetRollRangeResponse* AnselIPCResponse::release_getrollrangeresponse() {
  if (has_getrollrangeresponse()) {
    clear_has_response();
    ::AnselIpc::GetRollRangeResponse* temp = response_.getrollrangeresponse_;
    response_.getrollrangeresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_getrollrangeresponse(::AnselIpc::GetRollRangeResponse* getrollrangeresponse) {
  clear_response();
  if (getrollrangeresponse) {
    set_has_getrollrangeresponse();
    response_.getrollrangeresponse_ = getrollrangeresponse;
  }
}

// optional .AnselIpc.SetRollResponse setRollResponse = 10;
inline bool AnselIPCResponse::has_setrollresponse() const {
  return response_case() == kSetRollResponse;
}
inline void AnselIPCResponse::set_has_setrollresponse() {
  _oneof_case_[0] = kSetRollResponse;
}
inline void AnselIPCResponse::clear_setrollresponse() {
  if (has_setrollresponse()) {
    delete response_.setrollresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::SetRollResponse& AnselIPCResponse::setrollresponse() const {
  return has_setrollresponse() ? *response_.setrollresponse_
                      : ::AnselIpc::SetRollResponse::default_instance();
}
inline ::AnselIpc::SetRollResponse* AnselIPCResponse::mutable_setrollresponse() {
  if (!has_setrollresponse()) {
    clear_response();
    set_has_setrollresponse();
    response_.setrollresponse_ = new ::AnselIpc::SetRollResponse;
  }
  return response_.setrollresponse_;
}
inline ::AnselIpc::SetRollResponse* AnselIPCResponse::release_setrollresponse() {
  if (has_setrollresponse()) {
    clear_has_response();
    ::AnselIpc::SetRollResponse* temp = response_.setrollresponse_;
    response_.setrollresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_setrollresponse(::AnselIpc::SetRollResponse* setrollresponse) {
  clear_response();
  if (setrollresponse) {
    set_has_setrollresponse();
    response_.setrollresponse_ = setrollresponse;
  }
}

// optional .AnselIpc.SetAnselEnabledResponse setAnselEnabledResponse = 11;
inline bool AnselIPCResponse::has_setanselenabledresponse() const {
  return response_case() == kSetAnselEnabledResponse;
}
inline void AnselIPCResponse::set_has_setanselenabledresponse() {
  _oneof_case_[0] = kSetAnselEnabledResponse;
}
inline void AnselIPCResponse::clear_setanselenabledresponse() {
  if (has_setanselenabledresponse()) {
    delete response_.setanselenabledresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::SetAnselEnabledResponse& AnselIPCResponse::setanselenabledresponse() const {
  return has_setanselenabledresponse() ? *response_.setanselenabledresponse_
                      : ::AnselIpc::SetAnselEnabledResponse::default_instance();
}
inline ::AnselIpc::SetAnselEnabledResponse* AnselIPCResponse::mutable_setanselenabledresponse() {
  if (!has_setanselenabledresponse()) {
    clear_response();
    set_has_setanselenabledresponse();
    response_.setanselenabledresponse_ = new ::AnselIpc::SetAnselEnabledResponse;
  }
  return response_.setanselenabledresponse_;
}
inline ::AnselIpc::SetAnselEnabledResponse* AnselIPCResponse::release_setanselenabledresponse() {
  if (has_setanselenabledresponse()) {
    clear_has_response();
    ::AnselIpc::SetAnselEnabledResponse* temp = response_.setanselenabledresponse_;
    response_.setanselenabledresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_setanselenabledresponse(::AnselIpc::SetAnselEnabledResponse* setanselenabledresponse) {
  clear_response();
  if (setanselenabledresponse) {
    set_has_setanselenabledresponse();
    response_.setanselenabledresponse_ = setanselenabledresponse;
  }
}

// optional .AnselIpc.AbortCaptureResponse abortCaptureResponse = 12;
inline bool AnselIPCResponse::has_abortcaptureresponse() const {
  return response_case() == kAbortCaptureResponse;
}
inline void AnselIPCResponse::set_has_abortcaptureresponse() {
  _oneof_case_[0] = kAbortCaptureResponse;
}
inline void AnselIPCResponse::clear_abortcaptureresponse() {
  if (has_abortcaptureresponse()) {
    delete response_.abortcaptureresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::AbortCaptureResponse& AnselIPCResponse::abortcaptureresponse() const {
  return has_abortcaptureresponse() ? *response_.abortcaptureresponse_
                      : ::AnselIpc::AbortCaptureResponse::default_instance();
}
inline ::AnselIpc::AbortCaptureResponse* AnselIPCResponse::mutable_abortcaptureresponse() {
  if (!has_abortcaptureresponse()) {
    clear_response();
    set_has_abortcaptureresponse();
    response_.abortcaptureresponse_ = new ::AnselIpc::AbortCaptureResponse;
  }
  return response_.abortcaptureresponse_;
}
inline ::AnselIpc::AbortCaptureResponse* AnselIPCResponse::release_abortcaptureresponse() {
  if (has_abortcaptureresponse()) {
    clear_has_response();
    ::AnselIpc::AbortCaptureResponse* temp = response_.abortcaptureresponse_;
    response_.abortcaptureresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_abortcaptureresponse(::AnselIpc::AbortCaptureResponse* abortcaptureresponse) {
  clear_response();
  if (abortcaptureresponse) {
    set_has_abortcaptureresponse();
    response_.abortcaptureresponse_ = abortcaptureresponse;
  }
}

// optional .AnselIpc.GetAnselEnabledResponse getAnselEnabledResponse = 13;
inline bool AnselIPCResponse::has_getanselenabledresponse() const {
  return response_case() == kGetAnselEnabledResponse;
}
inline void AnselIPCResponse::set_has_getanselenabledresponse() {
  _oneof_case_[0] = kGetAnselEnabledResponse;
}
inline void AnselIPCResponse::clear_getanselenabledresponse() {
  if (has_getanselenabledresponse()) {
    delete response_.getanselenabledresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::GetAnselEnabledResponse& AnselIPCResponse::getanselenabledresponse() const {
  return has_getanselenabledresponse() ? *response_.getanselenabledresponse_
                      : ::AnselIpc::GetAnselEnabledResponse::default_instance();
}
inline ::AnselIpc::GetAnselEnabledResponse* AnselIPCResponse::mutable_getanselenabledresponse() {
  if (!has_getanselenabledresponse()) {
    clear_response();
    set_has_getanselenabledresponse();
    response_.getanselenabledresponse_ = new ::AnselIpc::GetAnselEnabledResponse;
  }
  return response_.getanselenabledresponse_;
}
inline ::AnselIpc::GetAnselEnabledResponse* AnselIPCResponse::release_getanselenabledresponse() {
  if (has_getanselenabledresponse()) {
    clear_has_response();
    ::AnselIpc::GetAnselEnabledResponse* temp = response_.getanselenabledresponse_;
    response_.getanselenabledresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_getanselenabledresponse(::AnselIpc::GetAnselEnabledResponse* getanselenabledresponse) {
  clear_response();
  if (getanselenabledresponse) {
    set_has_getanselenabledresponse();
    response_.getanselenabledresponse_ = getanselenabledresponse;
  }
}

// optional .AnselIpc.GetLwrrentFOVResponse getLwrrentFOVResponse = 14;
inline bool AnselIPCResponse::has_getlwrrentfovresponse() const {
  return response_case() == kGetLwrrentFOVResponse;
}
inline void AnselIPCResponse::set_has_getlwrrentfovresponse() {
  _oneof_case_[0] = kGetLwrrentFOVResponse;
}
inline void AnselIPCResponse::clear_getlwrrentfovresponse() {
  if (has_getlwrrentfovresponse()) {
    delete response_.getlwrrentfovresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::GetLwrrentFOVResponse& AnselIPCResponse::getlwrrentfovresponse() const {
  return has_getlwrrentfovresponse() ? *response_.getlwrrentfovresponse_
                      : ::AnselIpc::GetLwrrentFOVResponse::default_instance();
}
inline ::AnselIpc::GetLwrrentFOVResponse* AnselIPCResponse::mutable_getlwrrentfovresponse() {
  if (!has_getlwrrentfovresponse()) {
    clear_response();
    set_has_getlwrrentfovresponse();
    response_.getlwrrentfovresponse_ = new ::AnselIpc::GetLwrrentFOVResponse;
  }
  return response_.getlwrrentfovresponse_;
}
inline ::AnselIpc::GetLwrrentFOVResponse* AnselIPCResponse::release_getlwrrentfovresponse() {
  if (has_getlwrrentfovresponse()) {
    clear_has_response();
    ::AnselIpc::GetLwrrentFOVResponse* temp = response_.getlwrrentfovresponse_;
    response_.getlwrrentfovresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_getlwrrentfovresponse(::AnselIpc::GetLwrrentFOVResponse* getlwrrentfovresponse) {
  clear_response();
  if (getlwrrentfovresponse) {
    set_has_getlwrrentfovresponse();
    response_.getlwrrentfovresponse_ = getlwrrentfovresponse;
  }
}

// optional .AnselIpc.CaptureShotProgressResponse captureShotProgressResponse = 15;
inline bool AnselIPCResponse::has_captureshotprogressresponse() const {
  return response_case() == kCaptureShotProgressResponse;
}
inline void AnselIPCResponse::set_has_captureshotprogressresponse() {
  _oneof_case_[0] = kCaptureShotProgressResponse;
}
inline void AnselIPCResponse::clear_captureshotprogressresponse() {
  if (has_captureshotprogressresponse()) {
    delete response_.captureshotprogressresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::CaptureShotProgressResponse& AnselIPCResponse::captureshotprogressresponse() const {
  return has_captureshotprogressresponse() ? *response_.captureshotprogressresponse_
                      : ::AnselIpc::CaptureShotProgressResponse::default_instance();
}
inline ::AnselIpc::CaptureShotProgressResponse* AnselIPCResponse::mutable_captureshotprogressresponse() {
  if (!has_captureshotprogressresponse()) {
    clear_response();
    set_has_captureshotprogressresponse();
    response_.captureshotprogressresponse_ = new ::AnselIpc::CaptureShotProgressResponse;
  }
  return response_.captureshotprogressresponse_;
}
inline ::AnselIpc::CaptureShotProgressResponse* AnselIPCResponse::release_captureshotprogressresponse() {
  if (has_captureshotprogressresponse()) {
    clear_has_response();
    ::AnselIpc::CaptureShotProgressResponse* temp = response_.captureshotprogressresponse_;
    response_.captureshotprogressresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_captureshotprogressresponse(::AnselIpc::CaptureShotProgressResponse* captureshotprogressresponse) {
  clear_response();
  if (captureshotprogressresponse) {
    set_has_captureshotprogressresponse();
    response_.captureshotprogressresponse_ = captureshotprogressresponse;
  }
}

// optional .AnselIpc.LogFilenameResponse logFilenameResponse = 16;
inline bool AnselIPCResponse::has_logfilenameresponse() const {
  return response_case() == kLogFilenameResponse;
}
inline void AnselIPCResponse::set_has_logfilenameresponse() {
  _oneof_case_[0] = kLogFilenameResponse;
}
inline void AnselIPCResponse::clear_logfilenameresponse() {
  if (has_logfilenameresponse()) {
    delete response_.logfilenameresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::LogFilenameResponse& AnselIPCResponse::logfilenameresponse() const {
  return has_logfilenameresponse() ? *response_.logfilenameresponse_
                      : ::AnselIpc::LogFilenameResponse::default_instance();
}
inline ::AnselIpc::LogFilenameResponse* AnselIPCResponse::mutable_logfilenameresponse() {
  if (!has_logfilenameresponse()) {
    clear_response();
    set_has_logfilenameresponse();
    response_.logfilenameresponse_ = new ::AnselIpc::LogFilenameResponse;
  }
  return response_.logfilenameresponse_;
}
inline ::AnselIpc::LogFilenameResponse* AnselIPCResponse::release_logfilenameresponse() {
  if (has_logfilenameresponse()) {
    clear_has_response();
    ::AnselIpc::LogFilenameResponse* temp = response_.logfilenameresponse_;
    response_.logfilenameresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_logfilenameresponse(::AnselIpc::LogFilenameResponse* logfilenameresponse) {
  clear_response();
  if (logfilenameresponse) {
    set_has_logfilenameresponse();
    response_.logfilenameresponse_ = logfilenameresponse;
  }
}

// optional .AnselIpc.SetFilterResponse setFilterResponse = 17;
inline bool AnselIPCResponse::has_setfilterresponse() const {
  return response_case() == kSetFilterResponse;
}
inline void AnselIPCResponse::set_has_setfilterresponse() {
  _oneof_case_[0] = kSetFilterResponse;
}
inline void AnselIPCResponse::clear_setfilterresponse() {
  if (has_setfilterresponse()) {
    delete response_.setfilterresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::SetFilterResponse& AnselIPCResponse::setfilterresponse() const {
  return has_setfilterresponse() ? *response_.setfilterresponse_
                      : ::AnselIpc::SetFilterResponse::default_instance();
}
inline ::AnselIpc::SetFilterResponse* AnselIPCResponse::mutable_setfilterresponse() {
  if (!has_setfilterresponse()) {
    clear_response();
    set_has_setfilterresponse();
    response_.setfilterresponse_ = new ::AnselIpc::SetFilterResponse;
  }
  return response_.setfilterresponse_;
}
inline ::AnselIpc::SetFilterResponse* AnselIPCResponse::release_setfilterresponse() {
  if (has_setfilterresponse()) {
    clear_has_response();
    ::AnselIpc::SetFilterResponse* temp = response_.setfilterresponse_;
    response_.setfilterresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_setfilterresponse(::AnselIpc::SetFilterResponse* setfilterresponse) {
  clear_response();
  if (setfilterresponse) {
    set_has_setfilterresponse();
    response_.setfilterresponse_ = setfilterresponse;
  }
}

// optional .AnselIpc.SetFilterAttributeResponse setFilterAttributeResponse = 18;
inline bool AnselIPCResponse::has_setfilterattributeresponse() const {
  return response_case() == kSetFilterAttributeResponse;
}
inline void AnselIPCResponse::set_has_setfilterattributeresponse() {
  _oneof_case_[0] = kSetFilterAttributeResponse;
}
inline void AnselIPCResponse::clear_setfilterattributeresponse() {
  if (has_setfilterattributeresponse()) {
    delete response_.setfilterattributeresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::SetFilterAttributeResponse& AnselIPCResponse::setfilterattributeresponse() const {
  return has_setfilterattributeresponse() ? *response_.setfilterattributeresponse_
                      : ::AnselIpc::SetFilterAttributeResponse::default_instance();
}
inline ::AnselIpc::SetFilterAttributeResponse* AnselIPCResponse::mutable_setfilterattributeresponse() {
  if (!has_setfilterattributeresponse()) {
    clear_response();
    set_has_setfilterattributeresponse();
    response_.setfilterattributeresponse_ = new ::AnselIpc::SetFilterAttributeResponse;
  }
  return response_.setfilterattributeresponse_;
}
inline ::AnselIpc::SetFilterAttributeResponse* AnselIPCResponse::release_setfilterattributeresponse() {
  if (has_setfilterattributeresponse()) {
    clear_has_response();
    ::AnselIpc::SetFilterAttributeResponse* temp = response_.setfilterattributeresponse_;
    response_.setfilterattributeresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_setfilterattributeresponse(::AnselIpc::SetFilterAttributeResponse* setfilterattributeresponse) {
  clear_response();
  if (setfilterattributeresponse) {
    set_has_setfilterattributeresponse();
    response_.setfilterattributeresponse_ = setfilterattributeresponse;
  }
}

// optional .AnselIpc.IsAnselAvailableResponse isAnselAvailableResponse = 19;
inline bool AnselIPCResponse::has_isanselavailableresponse() const {
  return response_case() == kIsAnselAvailableResponse;
}
inline void AnselIPCResponse::set_has_isanselavailableresponse() {
  _oneof_case_[0] = kIsAnselAvailableResponse;
}
inline void AnselIPCResponse::clear_isanselavailableresponse() {
  if (has_isanselavailableresponse()) {
    delete response_.isanselavailableresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::IsAnselAvailableResponse& AnselIPCResponse::isanselavailableresponse() const {
  return has_isanselavailableresponse() ? *response_.isanselavailableresponse_
                      : ::AnselIpc::IsAnselAvailableResponse::default_instance();
}
inline ::AnselIpc::IsAnselAvailableResponse* AnselIPCResponse::mutable_isanselavailableresponse() {
  if (!has_isanselavailableresponse()) {
    clear_response();
    set_has_isanselavailableresponse();
    response_.isanselavailableresponse_ = new ::AnselIpc::IsAnselAvailableResponse;
  }
  return response_.isanselavailableresponse_;
}
inline ::AnselIpc::IsAnselAvailableResponse* AnselIPCResponse::release_isanselavailableresponse() {
  if (has_isanselavailableresponse()) {
    clear_has_response();
    ::AnselIpc::IsAnselAvailableResponse* temp = response_.isanselavailableresponse_;
    response_.isanselavailableresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_isanselavailableresponse(::AnselIpc::IsAnselAvailableResponse* isanselavailableresponse) {
  clear_response();
  if (isanselavailableresponse) {
    set_has_isanselavailableresponse();
    response_.isanselavailableresponse_ = isanselavailableresponse;
  }
}

// optional .AnselIpc.ScreenResolutionChangedResponse screenResolutionChangedResponse = 20;
inline bool AnselIPCResponse::has_screenresolutionchangedresponse() const {
  return response_case() == kScreenResolutionChangedResponse;
}
inline void AnselIPCResponse::set_has_screenresolutionchangedresponse() {
  _oneof_case_[0] = kScreenResolutionChangedResponse;
}
inline void AnselIPCResponse::clear_screenresolutionchangedresponse() {
  if (has_screenresolutionchangedresponse()) {
    delete response_.screenresolutionchangedresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::ScreenResolutionChangedResponse& AnselIPCResponse::screenresolutionchangedresponse() const {
  return has_screenresolutionchangedresponse() ? *response_.screenresolutionchangedresponse_
                      : ::AnselIpc::ScreenResolutionChangedResponse::default_instance();
}
inline ::AnselIpc::ScreenResolutionChangedResponse* AnselIPCResponse::mutable_screenresolutionchangedresponse() {
  if (!has_screenresolutionchangedresponse()) {
    clear_response();
    set_has_screenresolutionchangedresponse();
    response_.screenresolutionchangedresponse_ = new ::AnselIpc::ScreenResolutionChangedResponse;
  }
  return response_.screenresolutionchangedresponse_;
}
inline ::AnselIpc::ScreenResolutionChangedResponse* AnselIPCResponse::release_screenresolutionchangedresponse() {
  if (has_screenresolutionchangedresponse()) {
    clear_has_response();
    ::AnselIpc::ScreenResolutionChangedResponse* temp = response_.screenresolutionchangedresponse_;
    response_.screenresolutionchangedresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_screenresolutionchangedresponse(::AnselIpc::ScreenResolutionChangedResponse* screenresolutionchangedresponse) {
  clear_response();
  if (screenresolutionchangedresponse) {
    set_has_screenresolutionchangedresponse();
    response_.screenresolutionchangedresponse_ = screenresolutionchangedresponse;
  }
}

// optional .AnselIpc.GetAnselShotPermissionsResponse getAnselShotPermissionsResponse = 21;
inline bool AnselIPCResponse::has_getanselshotpermissionsresponse() const {
  return response_case() == kGetAnselShotPermissionsResponse;
}
inline void AnselIPCResponse::set_has_getanselshotpermissionsresponse() {
  _oneof_case_[0] = kGetAnselShotPermissionsResponse;
}
inline void AnselIPCResponse::clear_getanselshotpermissionsresponse() {
  if (has_getanselshotpermissionsresponse()) {
    delete response_.getanselshotpermissionsresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::GetAnselShotPermissionsResponse& AnselIPCResponse::getanselshotpermissionsresponse() const {
  return has_getanselshotpermissionsresponse() ? *response_.getanselshotpermissionsresponse_
                      : ::AnselIpc::GetAnselShotPermissionsResponse::default_instance();
}
inline ::AnselIpc::GetAnselShotPermissionsResponse* AnselIPCResponse::mutable_getanselshotpermissionsresponse() {
  if (!has_getanselshotpermissionsresponse()) {
    clear_response();
    set_has_getanselshotpermissionsresponse();
    response_.getanselshotpermissionsresponse_ = new ::AnselIpc::GetAnselShotPermissionsResponse;
  }
  return response_.getanselshotpermissionsresponse_;
}
inline ::AnselIpc::GetAnselShotPermissionsResponse* AnselIPCResponse::release_getanselshotpermissionsresponse() {
  if (has_getanselshotpermissionsresponse()) {
    clear_has_response();
    ::AnselIpc::GetAnselShotPermissionsResponse* temp = response_.getanselshotpermissionsresponse_;
    response_.getanselshotpermissionsresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_getanselshotpermissionsresponse(::AnselIpc::GetAnselShotPermissionsResponse* getanselshotpermissionsresponse) {
  clear_response();
  if (getanselshotpermissionsresponse) {
    set_has_getanselshotpermissionsresponse();
    response_.getanselshotpermissionsresponse_ = getanselshotpermissionsresponse;
  }
}

// optional .AnselIpc.InputEventResponse inputEventResponse = 22;
inline bool AnselIPCResponse::has_inputeventresponse() const {
  return response_case() == kInputEventResponse;
}
inline void AnselIPCResponse::set_has_inputeventresponse() {
  _oneof_case_[0] = kInputEventResponse;
}
inline void AnselIPCResponse::clear_inputeventresponse() {
  if (has_inputeventresponse()) {
    delete response_.inputeventresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::InputEventResponse& AnselIPCResponse::inputeventresponse() const {
  return has_inputeventresponse() ? *response_.inputeventresponse_
                      : ::AnselIpc::InputEventResponse::default_instance();
}
inline ::AnselIpc::InputEventResponse* AnselIPCResponse::mutable_inputeventresponse() {
  if (!has_inputeventresponse()) {
    clear_response();
    set_has_inputeventresponse();
    response_.inputeventresponse_ = new ::AnselIpc::InputEventResponse;
  }
  return response_.inputeventresponse_;
}
inline ::AnselIpc::InputEventResponse* AnselIPCResponse::release_inputeventresponse() {
  if (has_inputeventresponse()) {
    clear_has_response();
    ::AnselIpc::InputEventResponse* temp = response_.inputeventresponse_;
    response_.inputeventresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_inputeventresponse(::AnselIpc::InputEventResponse* inputeventresponse) {
  clear_response();
  if (inputeventresponse) {
    set_has_inputeventresponse();
    response_.inputeventresponse_ = inputeventresponse;
  }
}

// optional .AnselIpc.SetLangIdResponse setLangIdResponse = 23;
inline bool AnselIPCResponse::has_setlangidresponse() const {
  return response_case() == kSetLangIdResponse;
}
inline void AnselIPCResponse::set_has_setlangidresponse() {
  _oneof_case_[0] = kSetLangIdResponse;
}
inline void AnselIPCResponse::clear_setlangidresponse() {
  if (has_setlangidresponse()) {
    delete response_.setlangidresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::SetLangIdResponse& AnselIPCResponse::setlangidresponse() const {
  return has_setlangidresponse() ? *response_.setlangidresponse_
                      : ::AnselIpc::SetLangIdResponse::default_instance();
}
inline ::AnselIpc::SetLangIdResponse* AnselIPCResponse::mutable_setlangidresponse() {
  if (!has_setlangidresponse()) {
    clear_response();
    set_has_setlangidresponse();
    response_.setlangidresponse_ = new ::AnselIpc::SetLangIdResponse;
  }
  return response_.setlangidresponse_;
}
inline ::AnselIpc::SetLangIdResponse* AnselIPCResponse::release_setlangidresponse() {
  if (has_setlangidresponse()) {
    clear_has_response();
    ::AnselIpc::SetLangIdResponse* temp = response_.setlangidresponse_;
    response_.setlangidresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_setlangidresponse(::AnselIpc::SetLangIdResponse* setlangidresponse) {
  clear_response();
  if (setlangidresponse) {
    set_has_setlangidresponse();
    response_.setlangidresponse_ = setlangidresponse;
  }
}

// optional .AnselIpc.GetFilterInfoResponse getFilterInfoResponse = 24;
inline bool AnselIPCResponse::has_getfilterinforesponse() const {
  return response_case() == kGetFilterInfoResponse;
}
inline void AnselIPCResponse::set_has_getfilterinforesponse() {
  _oneof_case_[0] = kGetFilterInfoResponse;
}
inline void AnselIPCResponse::clear_getfilterinforesponse() {
  if (has_getfilterinforesponse()) {
    delete response_.getfilterinforesponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::GetFilterInfoResponse& AnselIPCResponse::getfilterinforesponse() const {
  return has_getfilterinforesponse() ? *response_.getfilterinforesponse_
                      : ::AnselIpc::GetFilterInfoResponse::default_instance();
}
inline ::AnselIpc::GetFilterInfoResponse* AnselIPCResponse::mutable_getfilterinforesponse() {
  if (!has_getfilterinforesponse()) {
    clear_response();
    set_has_getfilterinforesponse();
    response_.getfilterinforesponse_ = new ::AnselIpc::GetFilterInfoResponse;
  }
  return response_.getfilterinforesponse_;
}
inline ::AnselIpc::GetFilterInfoResponse* AnselIPCResponse::release_getfilterinforesponse() {
  if (has_getfilterinforesponse()) {
    clear_has_response();
    ::AnselIpc::GetFilterInfoResponse* temp = response_.getfilterinforesponse_;
    response_.getfilterinforesponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_getfilterinforesponse(::AnselIpc::GetFilterInfoResponse* getfilterinforesponse) {
  clear_response();
  if (getfilterinforesponse) {
    set_has_getfilterinforesponse();
    response_.getfilterinforesponse_ = getfilterinforesponse;
  }
}

// optional .AnselIpc.ResetFilterValuesResponse resetFilterValuesResponse = 25;
inline bool AnselIPCResponse::has_resetfiltervaluesresponse() const {
  return response_case() == kResetFilterValuesResponse;
}
inline void AnselIPCResponse::set_has_resetfiltervaluesresponse() {
  _oneof_case_[0] = kResetFilterValuesResponse;
}
inline void AnselIPCResponse::clear_resetfiltervaluesresponse() {
  if (has_resetfiltervaluesresponse()) {
    delete response_.resetfiltervaluesresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::ResetFilterValuesResponse& AnselIPCResponse::resetfiltervaluesresponse() const {
  return has_resetfiltervaluesresponse() ? *response_.resetfiltervaluesresponse_
                      : ::AnselIpc::ResetFilterValuesResponse::default_instance();
}
inline ::AnselIpc::ResetFilterValuesResponse* AnselIPCResponse::mutable_resetfiltervaluesresponse() {
  if (!has_resetfiltervaluesresponse()) {
    clear_response();
    set_has_resetfiltervaluesresponse();
    response_.resetfiltervaluesresponse_ = new ::AnselIpc::ResetFilterValuesResponse;
  }
  return response_.resetfiltervaluesresponse_;
}
inline ::AnselIpc::ResetFilterValuesResponse* AnselIPCResponse::release_resetfiltervaluesresponse() {
  if (has_resetfiltervaluesresponse()) {
    clear_has_response();
    ::AnselIpc::ResetFilterValuesResponse* temp = response_.resetfiltervaluesresponse_;
    response_.resetfiltervaluesresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_resetfiltervaluesresponse(::AnselIpc::ResetFilterValuesResponse* resetfiltervaluesresponse) {
  clear_response();
  if (resetfiltervaluesresponse) {
    set_has_resetfiltervaluesresponse();
    response_.resetfiltervaluesresponse_ = resetfiltervaluesresponse;
  }
}

// optional .AnselIpc.IsAnselSDKIntegrationAvailableResponse isAnselSDKIntegrationAvailableResponse = 26;
inline bool AnselIPCResponse::has_isanselsdkintegrationavailableresponse() const {
  return response_case() == kIsAnselSDKIntegrationAvailableResponse;
}
inline void AnselIPCResponse::set_has_isanselsdkintegrationavailableresponse() {
  _oneof_case_[0] = kIsAnselSDKIntegrationAvailableResponse;
}
inline void AnselIPCResponse::clear_isanselsdkintegrationavailableresponse() {
  if (has_isanselsdkintegrationavailableresponse()) {
    delete response_.isanselsdkintegrationavailableresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::IsAnselSDKIntegrationAvailableResponse& AnselIPCResponse::isanselsdkintegrationavailableresponse() const {
  return has_isanselsdkintegrationavailableresponse() ? *response_.isanselsdkintegrationavailableresponse_
                      : ::AnselIpc::IsAnselSDKIntegrationAvailableResponse::default_instance();
}
inline ::AnselIpc::IsAnselSDKIntegrationAvailableResponse* AnselIPCResponse::mutable_isanselsdkintegrationavailableresponse() {
  if (!has_isanselsdkintegrationavailableresponse()) {
    clear_response();
    set_has_isanselsdkintegrationavailableresponse();
    response_.isanselsdkintegrationavailableresponse_ = new ::AnselIpc::IsAnselSDKIntegrationAvailableResponse;
  }
  return response_.isanselsdkintegrationavailableresponse_;
}
inline ::AnselIpc::IsAnselSDKIntegrationAvailableResponse* AnselIPCResponse::release_isanselsdkintegrationavailableresponse() {
  if (has_isanselsdkintegrationavailableresponse()) {
    clear_has_response();
    ::AnselIpc::IsAnselSDKIntegrationAvailableResponse* temp = response_.isanselsdkintegrationavailableresponse_;
    response_.isanselsdkintegrationavailableresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_isanselsdkintegrationavailableresponse(::AnselIpc::IsAnselSDKIntegrationAvailableResponse* isanselsdkintegrationavailableresponse) {
  clear_response();
  if (isanselsdkintegrationavailableresponse) {
    set_has_isanselsdkintegrationavailableresponse();
    response_.isanselsdkintegrationavailableresponse_ = isanselsdkintegrationavailableresponse;
  }
}

// optional .AnselIpc.IpcVersionResponse ipcVersionResponse = 27;
inline bool AnselIPCResponse::has_ipcversionresponse() const {
  return response_case() == kIpcVersionResponse;
}
inline void AnselIPCResponse::set_has_ipcversionresponse() {
  _oneof_case_[0] = kIpcVersionResponse;
}
inline void AnselIPCResponse::clear_ipcversionresponse() {
  if (has_ipcversionresponse()) {
    delete response_.ipcversionresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::IpcVersionResponse& AnselIPCResponse::ipcversionresponse() const {
  return has_ipcversionresponse() ? *response_.ipcversionresponse_
                      : ::AnselIpc::IpcVersionResponse::default_instance();
}
inline ::AnselIpc::IpcVersionResponse* AnselIPCResponse::mutable_ipcversionresponse() {
  if (!has_ipcversionresponse()) {
    clear_response();
    set_has_ipcversionresponse();
    response_.ipcversionresponse_ = new ::AnselIpc::IpcVersionResponse;
  }
  return response_.ipcversionresponse_;
}
inline ::AnselIpc::IpcVersionResponse* AnselIPCResponse::release_ipcversionresponse() {
  if (has_ipcversionresponse()) {
    clear_has_response();
    ::AnselIpc::IpcVersionResponse* temp = response_.ipcversionresponse_;
    response_.ipcversionresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_ipcversionresponse(::AnselIpc::IpcVersionResponse* ipcversionresponse) {
  clear_response();
  if (ipcversionresponse) {
    set_has_ipcversionresponse();
    response_.ipcversionresponse_ = ipcversionresponse;
  }
}

// optional .AnselIpc.AddUIElementResponse addUIElementResponse = 28;
inline bool AnselIPCResponse::has_adduielementresponse() const {
  return response_case() == kAddUIElementResponse;
}
inline void AnselIPCResponse::set_has_adduielementresponse() {
  _oneof_case_[0] = kAddUIElementResponse;
}
inline void AnselIPCResponse::clear_adduielementresponse() {
  if (has_adduielementresponse()) {
    delete response_.adduielementresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::AddUIElementResponse& AnselIPCResponse::adduielementresponse() const {
  return has_adduielementresponse() ? *response_.adduielementresponse_
                      : ::AnselIpc::AddUIElementResponse::default_instance();
}
inline ::AnselIpc::AddUIElementResponse* AnselIPCResponse::mutable_adduielementresponse() {
  if (!has_adduielementresponse()) {
    clear_response();
    set_has_adduielementresponse();
    response_.adduielementresponse_ = new ::AnselIpc::AddUIElementResponse;
  }
  return response_.adduielementresponse_;
}
inline ::AnselIpc::AddUIElementResponse* AnselIPCResponse::release_adduielementresponse() {
  if (has_adduielementresponse()) {
    clear_has_response();
    ::AnselIpc::AddUIElementResponse* temp = response_.adduielementresponse_;
    response_.adduielementresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_adduielementresponse(::AnselIpc::AddUIElementResponse* adduielementresponse) {
  clear_response();
  if (adduielementresponse) {
    set_has_adduielementresponse();
    response_.adduielementresponse_ = adduielementresponse;
  }
}

// optional .AnselIpc.UIReadyResponse uiReadyResponse = 29;
inline bool AnselIPCResponse::has_uireadyresponse() const {
  return response_case() == kUiReadyResponse;
}
inline void AnselIPCResponse::set_has_uireadyresponse() {
  _oneof_case_[0] = kUiReadyResponse;
}
inline void AnselIPCResponse::clear_uireadyresponse() {
  if (has_uireadyresponse()) {
    delete response_.uireadyresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::UIReadyResponse& AnselIPCResponse::uireadyresponse() const {
  return has_uireadyresponse() ? *response_.uireadyresponse_
                      : ::AnselIpc::UIReadyResponse::default_instance();
}
inline ::AnselIpc::UIReadyResponse* AnselIPCResponse::mutable_uireadyresponse() {
  if (!has_uireadyresponse()) {
    clear_response();
    set_has_uireadyresponse();
    response_.uireadyresponse_ = new ::AnselIpc::UIReadyResponse;
  }
  return response_.uireadyresponse_;
}
inline ::AnselIpc::UIReadyResponse* AnselIPCResponse::release_uireadyresponse() {
  if (has_uireadyresponse()) {
    clear_has_response();
    ::AnselIpc::UIReadyResponse* temp = response_.uireadyresponse_;
    response_.uireadyresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_uireadyresponse(::AnselIpc::UIReadyResponse* uireadyresponse) {
  clear_response();
  if (uireadyresponse) {
    set_has_uireadyresponse();
    response_.uireadyresponse_ = uireadyresponse;
  }
}

// optional .AnselIpc.UIControlChangedResponse uiControlChangedResponse = 30;
inline bool AnselIPCResponse::has_uicontrolchangedresponse() const {
  return response_case() == kUiControlChangedResponse;
}
inline void AnselIPCResponse::set_has_uicontrolchangedresponse() {
  _oneof_case_[0] = kUiControlChangedResponse;
}
inline void AnselIPCResponse::clear_uicontrolchangedresponse() {
  if (has_uicontrolchangedresponse()) {
    delete response_.uicontrolchangedresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::UIControlChangedResponse& AnselIPCResponse::uicontrolchangedresponse() const {
  return has_uicontrolchangedresponse() ? *response_.uicontrolchangedresponse_
                      : ::AnselIpc::UIControlChangedResponse::default_instance();
}
inline ::AnselIpc::UIControlChangedResponse* AnselIPCResponse::mutable_uicontrolchangedresponse() {
  if (!has_uicontrolchangedresponse()) {
    clear_response();
    set_has_uicontrolchangedresponse();
    response_.uicontrolchangedresponse_ = new ::AnselIpc::UIControlChangedResponse;
  }
  return response_.uicontrolchangedresponse_;
}
inline ::AnselIpc::UIControlChangedResponse* AnselIPCResponse::release_uicontrolchangedresponse() {
  if (has_uicontrolchangedresponse()) {
    clear_has_response();
    ::AnselIpc::UIControlChangedResponse* temp = response_.uicontrolchangedresponse_;
    response_.uicontrolchangedresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_uicontrolchangedresponse(::AnselIpc::UIControlChangedResponse* uicontrolchangedresponse) {
  clear_response();
  if (uicontrolchangedresponse) {
    set_has_uicontrolchangedresponse();
    response_.uicontrolchangedresponse_ = uicontrolchangedresponse;
  }
}

// optional .AnselIpc.UIControlRemoveResponse uiControlRemoveResponse = 31;
inline bool AnselIPCResponse::has_uicontrolremoveresponse() const {
  return response_case() == kUiControlRemoveResponse;
}
inline void AnselIPCResponse::set_has_uicontrolremoveresponse() {
  _oneof_case_[0] = kUiControlRemoveResponse;
}
inline void AnselIPCResponse::clear_uicontrolremoveresponse() {
  if (has_uicontrolremoveresponse()) {
    delete response_.uicontrolremoveresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::UIControlRemoveResponse& AnselIPCResponse::uicontrolremoveresponse() const {
  return has_uicontrolremoveresponse() ? *response_.uicontrolremoveresponse_
                      : ::AnselIpc::UIControlRemoveResponse::default_instance();
}
inline ::AnselIpc::UIControlRemoveResponse* AnselIPCResponse::mutable_uicontrolremoveresponse() {
  if (!has_uicontrolremoveresponse()) {
    clear_response();
    set_has_uicontrolremoveresponse();
    response_.uicontrolremoveresponse_ = new ::AnselIpc::UIControlRemoveResponse;
  }
  return response_.uicontrolremoveresponse_;
}
inline ::AnselIpc::UIControlRemoveResponse* AnselIPCResponse::release_uicontrolremoveresponse() {
  if (has_uicontrolremoveresponse()) {
    clear_has_response();
    ::AnselIpc::UIControlRemoveResponse* temp = response_.uicontrolremoveresponse_;
    response_.uicontrolremoveresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_uicontrolremoveresponse(::AnselIpc::UIControlRemoveResponse* uicontrolremoveresponse) {
  clear_response();
  if (uicontrolremoveresponse) {
    set_has_uicontrolremoveresponse();
    response_.uicontrolremoveresponse_ = uicontrolremoveresponse;
  }
}

// optional .AnselIpc.UIControlSetVisibilityResponse uiControlSetVisibilityResponse = 32;
inline bool AnselIPCResponse::has_uicontrolsetvisibilityresponse() const {
  return response_case() == kUiControlSetVisibilityResponse;
}
inline void AnselIPCResponse::set_has_uicontrolsetvisibilityresponse() {
  _oneof_case_[0] = kUiControlSetVisibilityResponse;
}
inline void AnselIPCResponse::clear_uicontrolsetvisibilityresponse() {
  if (has_uicontrolsetvisibilityresponse()) {
    delete response_.uicontrolsetvisibilityresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::UIControlSetVisibilityResponse& AnselIPCResponse::uicontrolsetvisibilityresponse() const {
  return has_uicontrolsetvisibilityresponse() ? *response_.uicontrolsetvisibilityresponse_
                      : ::AnselIpc::UIControlSetVisibilityResponse::default_instance();
}
inline ::AnselIpc::UIControlSetVisibilityResponse* AnselIPCResponse::mutable_uicontrolsetvisibilityresponse() {
  if (!has_uicontrolsetvisibilityresponse()) {
    clear_response();
    set_has_uicontrolsetvisibilityresponse();
    response_.uicontrolsetvisibilityresponse_ = new ::AnselIpc::UIControlSetVisibilityResponse;
  }
  return response_.uicontrolsetvisibilityresponse_;
}
inline ::AnselIpc::UIControlSetVisibilityResponse* AnselIPCResponse::release_uicontrolsetvisibilityresponse() {
  if (has_uicontrolsetvisibilityresponse()) {
    clear_has_response();
    ::AnselIpc::UIControlSetVisibilityResponse* temp = response_.uicontrolsetvisibilityresponse_;
    response_.uicontrolsetvisibilityresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_uicontrolsetvisibilityresponse(::AnselIpc::UIControlSetVisibilityResponse* uicontrolsetvisibilityresponse) {
  clear_response();
  if (uicontrolsetvisibilityresponse) {
    set_has_uicontrolsetvisibilityresponse();
    response_.uicontrolsetvisibilityresponse_ = uicontrolsetvisibilityresponse;
  }
}

// optional .AnselIpc.UIControlGetVisibilityResponse uiControlGetVisibilityResponse = 33;
inline bool AnselIPCResponse::has_uicontrolgetvisibilityresponse() const {
  return response_case() == kUiControlGetVisibilityResponse;
}
inline void AnselIPCResponse::set_has_uicontrolgetvisibilityresponse() {
  _oneof_case_[0] = kUiControlGetVisibilityResponse;
}
inline void AnselIPCResponse::clear_uicontrolgetvisibilityresponse() {
  if (has_uicontrolgetvisibilityresponse()) {
    delete response_.uicontrolgetvisibilityresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::UIControlGetVisibilityResponse& AnselIPCResponse::uicontrolgetvisibilityresponse() const {
  return has_uicontrolgetvisibilityresponse() ? *response_.uicontrolgetvisibilityresponse_
                      : ::AnselIpc::UIControlGetVisibilityResponse::default_instance();
}
inline ::AnselIpc::UIControlGetVisibilityResponse* AnselIPCResponse::mutable_uicontrolgetvisibilityresponse() {
  if (!has_uicontrolgetvisibilityresponse()) {
    clear_response();
    set_has_uicontrolgetvisibilityresponse();
    response_.uicontrolgetvisibilityresponse_ = new ::AnselIpc::UIControlGetVisibilityResponse;
  }
  return response_.uicontrolgetvisibilityresponse_;
}
inline ::AnselIpc::UIControlGetVisibilityResponse* AnselIPCResponse::release_uicontrolgetvisibilityresponse() {
  if (has_uicontrolgetvisibilityresponse()) {
    clear_has_response();
    ::AnselIpc::UIControlGetVisibilityResponse* temp = response_.uicontrolgetvisibilityresponse_;
    response_.uicontrolgetvisibilityresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_uicontrolgetvisibilityresponse(::AnselIpc::UIControlGetVisibilityResponse* uicontrolgetvisibilityresponse) {
  clear_response();
  if (uicontrolgetvisibilityresponse) {
    set_has_uicontrolgetvisibilityresponse();
    response_.uicontrolgetvisibilityresponse_ = uicontrolgetvisibilityresponse;
  }
}

// optional .AnselIpc.GetProcessInfoResponse getProcessInfoResponse = 34;
inline bool AnselIPCResponse::has_getprocessinforesponse() const {
  return response_case() == kGetProcessInfoResponse;
}
inline void AnselIPCResponse::set_has_getprocessinforesponse() {
  _oneof_case_[0] = kGetProcessInfoResponse;
}
inline void AnselIPCResponse::clear_getprocessinforesponse() {
  if (has_getprocessinforesponse()) {
    delete response_.getprocessinforesponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::GetProcessInfoResponse& AnselIPCResponse::getprocessinforesponse() const {
  return has_getprocessinforesponse() ? *response_.getprocessinforesponse_
                      : ::AnselIpc::GetProcessInfoResponse::default_instance();
}
inline ::AnselIpc::GetProcessInfoResponse* AnselIPCResponse::mutable_getprocessinforesponse() {
  if (!has_getprocessinforesponse()) {
    clear_response();
    set_has_getprocessinforesponse();
    response_.getprocessinforesponse_ = new ::AnselIpc::GetProcessInfoResponse;
  }
  return response_.getprocessinforesponse_;
}
inline ::AnselIpc::GetProcessInfoResponse* AnselIPCResponse::release_getprocessinforesponse() {
  if (has_getprocessinforesponse()) {
    clear_has_response();
    ::AnselIpc::GetProcessInfoResponse* temp = response_.getprocessinforesponse_;
    response_.getprocessinforesponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_getprocessinforesponse(::AnselIpc::GetProcessInfoResponse* getprocessinforesponse) {
  clear_response();
  if (getprocessinforesponse) {
    set_has_getprocessinforesponse();
    response_.getprocessinforesponse_ = getprocessinforesponse;
  }
}

// optional .AnselIpc.GetScreenResolutionResponse getScreenResolutionResponse = 35;
inline bool AnselIPCResponse::has_getscreenresolutionresponse() const {
  return response_case() == kGetScreenResolutionResponse;
}
inline void AnselIPCResponse::set_has_getscreenresolutionresponse() {
  _oneof_case_[0] = kGetScreenResolutionResponse;
}
inline void AnselIPCResponse::clear_getscreenresolutionresponse() {
  if (has_getscreenresolutionresponse()) {
    delete response_.getscreenresolutionresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::GetScreenResolutionResponse& AnselIPCResponse::getscreenresolutionresponse() const {
  return has_getscreenresolutionresponse() ? *response_.getscreenresolutionresponse_
                      : ::AnselIpc::GetScreenResolutionResponse::default_instance();
}
inline ::AnselIpc::GetScreenResolutionResponse* AnselIPCResponse::mutable_getscreenresolutionresponse() {
  if (!has_getscreenresolutionresponse()) {
    clear_response();
    set_has_getscreenresolutionresponse();
    response_.getscreenresolutionresponse_ = new ::AnselIpc::GetScreenResolutionResponse;
  }
  return response_.getscreenresolutionresponse_;
}
inline ::AnselIpc::GetScreenResolutionResponse* AnselIPCResponse::release_getscreenresolutionresponse() {
  if (has_getscreenresolutionresponse()) {
    clear_has_response();
    ::AnselIpc::GetScreenResolutionResponse* temp = response_.getscreenresolutionresponse_;
    response_.getscreenresolutionresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_getscreenresolutionresponse(::AnselIpc::GetScreenResolutionResponse* getscreenresolutionresponse) {
  clear_response();
  if (getscreenresolutionresponse) {
    set_has_getscreenresolutionresponse();
    response_.getscreenresolutionresponse_ = getscreenresolutionresponse;
  }
}

// optional .AnselIpc.IsAnselModdingAvailableResponse isAnselModdingAvailableResponse = 36;
inline bool AnselIPCResponse::has_isanselmoddingavailableresponse() const {
  return response_case() == kIsAnselModdingAvailableResponse;
}
inline void AnselIPCResponse::set_has_isanselmoddingavailableresponse() {
  _oneof_case_[0] = kIsAnselModdingAvailableResponse;
}
inline void AnselIPCResponse::clear_isanselmoddingavailableresponse() {
  if (has_isanselmoddingavailableresponse()) {
    delete response_.isanselmoddingavailableresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::IsAnselModdingAvailableResponse& AnselIPCResponse::isanselmoddingavailableresponse() const {
  return has_isanselmoddingavailableresponse() ? *response_.isanselmoddingavailableresponse_
                      : ::AnselIpc::IsAnselModdingAvailableResponse::default_instance();
}
inline ::AnselIpc::IsAnselModdingAvailableResponse* AnselIPCResponse::mutable_isanselmoddingavailableresponse() {
  if (!has_isanselmoddingavailableresponse()) {
    clear_response();
    set_has_isanselmoddingavailableresponse();
    response_.isanselmoddingavailableresponse_ = new ::AnselIpc::IsAnselModdingAvailableResponse;
  }
  return response_.isanselmoddingavailableresponse_;
}
inline ::AnselIpc::IsAnselModdingAvailableResponse* AnselIPCResponse::release_isanselmoddingavailableresponse() {
  if (has_isanselmoddingavailableresponse()) {
    clear_has_response();
    ::AnselIpc::IsAnselModdingAvailableResponse* temp = response_.isanselmoddingavailableresponse_;
    response_.isanselmoddingavailableresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_isanselmoddingavailableresponse(::AnselIpc::IsAnselModdingAvailableResponse* isanselmoddingavailableresponse) {
  clear_response();
  if (isanselmoddingavailableresponse) {
    set_has_isanselmoddingavailableresponse();
    response_.isanselmoddingavailableresponse_ = isanselmoddingavailableresponse;
  }
}

// optional .AnselIpc.SetGridOfThirdsEnabledResponse setGridOfThirdsEnabledResponse = 37;
inline bool AnselIPCResponse::has_setgridofthirdsenabledresponse() const {
  return response_case() == kSetGridOfThirdsEnabledResponse;
}
inline void AnselIPCResponse::set_has_setgridofthirdsenabledresponse() {
  _oneof_case_[0] = kSetGridOfThirdsEnabledResponse;
}
inline void AnselIPCResponse::clear_setgridofthirdsenabledresponse() {
  if (has_setgridofthirdsenabledresponse()) {
    delete response_.setgridofthirdsenabledresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::SetGridOfThirdsEnabledResponse& AnselIPCResponse::setgridofthirdsenabledresponse() const {
  return has_setgridofthirdsenabledresponse() ? *response_.setgridofthirdsenabledresponse_
                      : ::AnselIpc::SetGridOfThirdsEnabledResponse::default_instance();
}
inline ::AnselIpc::SetGridOfThirdsEnabledResponse* AnselIPCResponse::mutable_setgridofthirdsenabledresponse() {
  if (!has_setgridofthirdsenabledresponse()) {
    clear_response();
    set_has_setgridofthirdsenabledresponse();
    response_.setgridofthirdsenabledresponse_ = new ::AnselIpc::SetGridOfThirdsEnabledResponse;
  }
  return response_.setgridofthirdsenabledresponse_;
}
inline ::AnselIpc::SetGridOfThirdsEnabledResponse* AnselIPCResponse::release_setgridofthirdsenabledresponse() {
  if (has_setgridofthirdsenabledresponse()) {
    clear_has_response();
    ::AnselIpc::SetGridOfThirdsEnabledResponse* temp = response_.setgridofthirdsenabledresponse_;
    response_.setgridofthirdsenabledresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_setgridofthirdsenabledresponse(::AnselIpc::SetGridOfThirdsEnabledResponse* setgridofthirdsenabledresponse) {
  clear_response();
  if (setgridofthirdsenabledresponse) {
    set_has_setgridofthirdsenabledresponse();
    response_.setgridofthirdsenabledresponse_ = setgridofthirdsenabledresponse;
  }
}

// optional .AnselIpc.ResetEntireStackResponse resetEntireStackResponse = 38;
inline bool AnselIPCResponse::has_resetentirestackresponse() const {
  return response_case() == kResetEntireStackResponse;
}
inline void AnselIPCResponse::set_has_resetentirestackresponse() {
  _oneof_case_[0] = kResetEntireStackResponse;
}
inline void AnselIPCResponse::clear_resetentirestackresponse() {
  if (has_resetentirestackresponse()) {
    delete response_.resetentirestackresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::ResetEntireStackResponse& AnselIPCResponse::resetentirestackresponse() const {
  return has_resetentirestackresponse() ? *response_.resetentirestackresponse_
                      : ::AnselIpc::ResetEntireStackResponse::default_instance();
}
inline ::AnselIpc::ResetEntireStackResponse* AnselIPCResponse::mutable_resetentirestackresponse() {
  if (!has_resetentirestackresponse()) {
    clear_response();
    set_has_resetentirestackresponse();
    response_.resetentirestackresponse_ = new ::AnselIpc::ResetEntireStackResponse;
  }
  return response_.resetentirestackresponse_;
}
inline ::AnselIpc::ResetEntireStackResponse* AnselIPCResponse::release_resetentirestackresponse() {
  if (has_resetentirestackresponse()) {
    clear_has_response();
    ::AnselIpc::ResetEntireStackResponse* temp = response_.resetentirestackresponse_;
    response_.resetentirestackresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_resetentirestackresponse(::AnselIpc::ResetEntireStackResponse* resetentirestackresponse) {
  clear_response();
  if (resetentirestackresponse) {
    set_has_resetentirestackresponse();
    response_.resetentirestackresponse_ = resetentirestackresponse;
  }
}

// optional .AnselIpc.GetFeatureSetResponse getFeatureSetResponse = 39;
inline bool AnselIPCResponse::has_getfeaturesetresponse() const {
  return response_case() == kGetFeatureSetResponse;
}
inline void AnselIPCResponse::set_has_getfeaturesetresponse() {
  _oneof_case_[0] = kGetFeatureSetResponse;
}
inline void AnselIPCResponse::clear_getfeaturesetresponse() {
  if (has_getfeaturesetresponse()) {
    delete response_.getfeaturesetresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::GetFeatureSetResponse& AnselIPCResponse::getfeaturesetresponse() const {
  return has_getfeaturesetresponse() ? *response_.getfeaturesetresponse_
                      : ::AnselIpc::GetFeatureSetResponse::default_instance();
}
inline ::AnselIpc::GetFeatureSetResponse* AnselIPCResponse::mutable_getfeaturesetresponse() {
  if (!has_getfeaturesetresponse()) {
    clear_response();
    set_has_getfeaturesetresponse();
    response_.getfeaturesetresponse_ = new ::AnselIpc::GetFeatureSetResponse;
  }
  return response_.getfeaturesetresponse_;
}
inline ::AnselIpc::GetFeatureSetResponse* AnselIPCResponse::release_getfeaturesetresponse() {
  if (has_getfeaturesetresponse()) {
    clear_has_response();
    ::AnselIpc::GetFeatureSetResponse* temp = response_.getfeaturesetresponse_;
    response_.getfeaturesetresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_getfeaturesetresponse(::AnselIpc::GetFeatureSetResponse* getfeaturesetresponse) {
  clear_response();
  if (getfeaturesetresponse) {
    set_has_getfeaturesetresponse();
    response_.getfeaturesetresponse_ = getfeaturesetresponse;
  }
}

// optional .AnselIpc.SetStyleTransferEnabledResponse setStyleTransferEnabledResponse = 40;
inline bool AnselIPCResponse::has_setstyletransferenabledresponse() const {
  return response_case() == kSetStyleTransferEnabledResponse;
}
inline void AnselIPCResponse::set_has_setstyletransferenabledresponse() {
  _oneof_case_[0] = kSetStyleTransferEnabledResponse;
}
inline void AnselIPCResponse::clear_setstyletransferenabledresponse() {
  if (has_setstyletransferenabledresponse()) {
    delete response_.setstyletransferenabledresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::SetStyleTransferEnabledResponse& AnselIPCResponse::setstyletransferenabledresponse() const {
  return has_setstyletransferenabledresponse() ? *response_.setstyletransferenabledresponse_
                      : ::AnselIpc::SetStyleTransferEnabledResponse::default_instance();
}
inline ::AnselIpc::SetStyleTransferEnabledResponse* AnselIPCResponse::mutable_setstyletransferenabledresponse() {
  if (!has_setstyletransferenabledresponse()) {
    clear_response();
    set_has_setstyletransferenabledresponse();
    response_.setstyletransferenabledresponse_ = new ::AnselIpc::SetStyleTransferEnabledResponse;
  }
  return response_.setstyletransferenabledresponse_;
}
inline ::AnselIpc::SetStyleTransferEnabledResponse* AnselIPCResponse::release_setstyletransferenabledresponse() {
  if (has_setstyletransferenabledresponse()) {
    clear_has_response();
    ::AnselIpc::SetStyleTransferEnabledResponse* temp = response_.setstyletransferenabledresponse_;
    response_.setstyletransferenabledresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_setstyletransferenabledresponse(::AnselIpc::SetStyleTransferEnabledResponse* setstyletransferenabledresponse) {
  clear_response();
  if (setstyletransferenabledresponse) {
    set_has_setstyletransferenabledresponse();
    response_.setstyletransferenabledresponse_ = setstyletransferenabledresponse;
  }
}

// optional .AnselIpc.SetStyleTransferStyleResponse setStyleTransferStyleResponse = 41;
inline bool AnselIPCResponse::has_setstyletransferstyleresponse() const {
  return response_case() == kSetStyleTransferStyleResponse;
}
inline void AnselIPCResponse::set_has_setstyletransferstyleresponse() {
  _oneof_case_[0] = kSetStyleTransferStyleResponse;
}
inline void AnselIPCResponse::clear_setstyletransferstyleresponse() {
  if (has_setstyletransferstyleresponse()) {
    delete response_.setstyletransferstyleresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::SetStyleTransferStyleResponse& AnselIPCResponse::setstyletransferstyleresponse() const {
  return has_setstyletransferstyleresponse() ? *response_.setstyletransferstyleresponse_
                      : ::AnselIpc::SetStyleTransferStyleResponse::default_instance();
}
inline ::AnselIpc::SetStyleTransferStyleResponse* AnselIPCResponse::mutable_setstyletransferstyleresponse() {
  if (!has_setstyletransferstyleresponse()) {
    clear_response();
    set_has_setstyletransferstyleresponse();
    response_.setstyletransferstyleresponse_ = new ::AnselIpc::SetStyleTransferStyleResponse;
  }
  return response_.setstyletransferstyleresponse_;
}
inline ::AnselIpc::SetStyleTransferStyleResponse* AnselIPCResponse::release_setstyletransferstyleresponse() {
  if (has_setstyletransferstyleresponse()) {
    clear_has_response();
    ::AnselIpc::SetStyleTransferStyleResponse* temp = response_.setstyletransferstyleresponse_;
    response_.setstyletransferstyleresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_setstyletransferstyleresponse(::AnselIpc::SetStyleTransferStyleResponse* setstyletransferstyleresponse) {
  clear_response();
  if (setstyletransferstyleresponse) {
    set_has_setstyletransferstyleresponse();
    response_.setstyletransferstyleresponse_ = setstyletransferstyleresponse;
  }
}

// optional .AnselIpc.GetStyleTransferModelListResponse getStyleTransferModelListResponse = 42;
inline bool AnselIPCResponse::has_getstyletransfermodellistresponse() const {
  return response_case() == kGetStyleTransferModelListResponse;
}
inline void AnselIPCResponse::set_has_getstyletransfermodellistresponse() {
  _oneof_case_[0] = kGetStyleTransferModelListResponse;
}
inline void AnselIPCResponse::clear_getstyletransfermodellistresponse() {
  if (has_getstyletransfermodellistresponse()) {
    delete response_.getstyletransfermodellistresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::GetStyleTransferModelListResponse& AnselIPCResponse::getstyletransfermodellistresponse() const {
  return has_getstyletransfermodellistresponse() ? *response_.getstyletransfermodellistresponse_
                      : ::AnselIpc::GetStyleTransferModelListResponse::default_instance();
}
inline ::AnselIpc::GetStyleTransferModelListResponse* AnselIPCResponse::mutable_getstyletransfermodellistresponse() {
  if (!has_getstyletransfermodellistresponse()) {
    clear_response();
    set_has_getstyletransfermodellistresponse();
    response_.getstyletransfermodellistresponse_ = new ::AnselIpc::GetStyleTransferModelListResponse;
  }
  return response_.getstyletransfermodellistresponse_;
}
inline ::AnselIpc::GetStyleTransferModelListResponse* AnselIPCResponse::release_getstyletransfermodellistresponse() {
  if (has_getstyletransfermodellistresponse()) {
    clear_has_response();
    ::AnselIpc::GetStyleTransferModelListResponse* temp = response_.getstyletransfermodellistresponse_;
    response_.getstyletransfermodellistresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_getstyletransfermodellistresponse(::AnselIpc::GetStyleTransferModelListResponse* getstyletransfermodellistresponse) {
  clear_response();
  if (getstyletransfermodellistresponse) {
    set_has_getstyletransfermodellistresponse();
    response_.getstyletransfermodellistresponse_ = getstyletransfermodellistresponse;
  }
}

// optional .AnselIpc.SetStyleTransferModelResponse setStyleTransferModelResponse = 43;
inline bool AnselIPCResponse::has_setstyletransfermodelresponse() const {
  return response_case() == kSetStyleTransferModelResponse;
}
inline void AnselIPCResponse::set_has_setstyletransfermodelresponse() {
  _oneof_case_[0] = kSetStyleTransferModelResponse;
}
inline void AnselIPCResponse::clear_setstyletransfermodelresponse() {
  if (has_setstyletransfermodelresponse()) {
    delete response_.setstyletransfermodelresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::SetStyleTransferModelResponse& AnselIPCResponse::setstyletransfermodelresponse() const {
  return has_setstyletransfermodelresponse() ? *response_.setstyletransfermodelresponse_
                      : ::AnselIpc::SetStyleTransferModelResponse::default_instance();
}
inline ::AnselIpc::SetStyleTransferModelResponse* AnselIPCResponse::mutable_setstyletransfermodelresponse() {
  if (!has_setstyletransfermodelresponse()) {
    clear_response();
    set_has_setstyletransfermodelresponse();
    response_.setstyletransfermodelresponse_ = new ::AnselIpc::SetStyleTransferModelResponse;
  }
  return response_.setstyletransfermodelresponse_;
}
inline ::AnselIpc::SetStyleTransferModelResponse* AnselIPCResponse::release_setstyletransfermodelresponse() {
  if (has_setstyletransfermodelresponse()) {
    clear_has_response();
    ::AnselIpc::SetStyleTransferModelResponse* temp = response_.setstyletransfermodelresponse_;
    response_.setstyletransfermodelresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_setstyletransfermodelresponse(::AnselIpc::SetStyleTransferModelResponse* setstyletransfermodelresponse) {
  clear_response();
  if (setstyletransfermodelresponse) {
    set_has_setstyletransfermodelresponse();
    response_.setstyletransfermodelresponse_ = setstyletransfermodelresponse;
  }
}

// optional .AnselIpc.StyleTransferStatusResponse styleTransferStatusResponse = 44;
inline bool AnselIPCResponse::has_styletransferstatusresponse() const {
  return response_case() == kStyleTransferStatusResponse;
}
inline void AnselIPCResponse::set_has_styletransferstatusresponse() {
  _oneof_case_[0] = kStyleTransferStatusResponse;
}
inline void AnselIPCResponse::clear_styletransferstatusresponse() {
  if (has_styletransferstatusresponse()) {
    delete response_.styletransferstatusresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::StyleTransferStatusResponse& AnselIPCResponse::styletransferstatusresponse() const {
  return has_styletransferstatusresponse() ? *response_.styletransferstatusresponse_
                      : ::AnselIpc::StyleTransferStatusResponse::default_instance();
}
inline ::AnselIpc::StyleTransferStatusResponse* AnselIPCResponse::mutable_styletransferstatusresponse() {
  if (!has_styletransferstatusresponse()) {
    clear_response();
    set_has_styletransferstatusresponse();
    response_.styletransferstatusresponse_ = new ::AnselIpc::StyleTransferStatusResponse;
  }
  return response_.styletransferstatusresponse_;
}
inline ::AnselIpc::StyleTransferStatusResponse* AnselIPCResponse::release_styletransferstatusresponse() {
  if (has_styletransferstatusresponse()) {
    clear_has_response();
    ::AnselIpc::StyleTransferStatusResponse* temp = response_.styletransferstatusresponse_;
    response_.styletransferstatusresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_styletransferstatusresponse(::AnselIpc::StyleTransferStatusResponse* styletransferstatusresponse) {
  clear_response();
  if (styletransferstatusresponse) {
    set_has_styletransferstatusresponse();
    response_.styletransferstatusresponse_ = styletransferstatusresponse;
  }
}

// optional .AnselIpc.MoveFilterResponse moveFilterResponse = 45;
inline bool AnselIPCResponse::has_movefilterresponse() const {
  return response_case() == kMoveFilterResponse;
}
inline void AnselIPCResponse::set_has_movefilterresponse() {
  _oneof_case_[0] = kMoveFilterResponse;
}
inline void AnselIPCResponse::clear_movefilterresponse() {
  if (has_movefilterresponse()) {
    delete response_.movefilterresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::MoveFilterResponse& AnselIPCResponse::movefilterresponse() const {
  return has_movefilterresponse() ? *response_.movefilterresponse_
                      : ::AnselIpc::MoveFilterResponse::default_instance();
}
inline ::AnselIpc::MoveFilterResponse* AnselIPCResponse::mutable_movefilterresponse() {
  if (!has_movefilterresponse()) {
    clear_response();
    set_has_movefilterresponse();
    response_.movefilterresponse_ = new ::AnselIpc::MoveFilterResponse;
  }
  return response_.movefilterresponse_;
}
inline ::AnselIpc::MoveFilterResponse* AnselIPCResponse::release_movefilterresponse() {
  if (has_movefilterresponse()) {
    clear_has_response();
    ::AnselIpc::MoveFilterResponse* temp = response_.movefilterresponse_;
    response_.movefilterresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_movefilterresponse(::AnselIpc::MoveFilterResponse* movefilterresponse) {
  clear_response();
  if (movefilterresponse) {
    set_has_movefilterresponse();
    response_.movefilterresponse_ = movefilterresponse;
  }
}

// optional .AnselIpc.GetStackInfoResponse getStackInfoResponse = 46;
inline bool AnselIPCResponse::has_getstackinforesponse() const {
  return response_case() == kGetStackInfoResponse;
}
inline void AnselIPCResponse::set_has_getstackinforesponse() {
  _oneof_case_[0] = kGetStackInfoResponse;
}
inline void AnselIPCResponse::clear_getstackinforesponse() {
  if (has_getstackinforesponse()) {
    delete response_.getstackinforesponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::GetStackInfoResponse& AnselIPCResponse::getstackinforesponse() const {
  return has_getstackinforesponse() ? *response_.getstackinforesponse_
                      : ::AnselIpc::GetStackInfoResponse::default_instance();
}
inline ::AnselIpc::GetStackInfoResponse* AnselIPCResponse::mutable_getstackinforesponse() {
  if (!has_getstackinforesponse()) {
    clear_response();
    set_has_getstackinforesponse();
    response_.getstackinforesponse_ = new ::AnselIpc::GetStackInfoResponse;
  }
  return response_.getstackinforesponse_;
}
inline ::AnselIpc::GetStackInfoResponse* AnselIPCResponse::release_getstackinforesponse() {
  if (has_getstackinforesponse()) {
    clear_has_response();
    ::AnselIpc::GetStackInfoResponse* temp = response_.getstackinforesponse_;
    response_.getstackinforesponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_getstackinforesponse(::AnselIpc::GetStackInfoResponse* getstackinforesponse) {
  clear_response();
  if (getstackinforesponse) {
    set_has_getstackinforesponse();
    response_.getstackinforesponse_ = getstackinforesponse;
  }
}

// optional .AnselIpc.InsertFilterResponse insertFilterResponse = 47;
inline bool AnselIPCResponse::has_insertfilterresponse() const {
  return response_case() == kInsertFilterResponse;
}
inline void AnselIPCResponse::set_has_insertfilterresponse() {
  _oneof_case_[0] = kInsertFilterResponse;
}
inline void AnselIPCResponse::clear_insertfilterresponse() {
  if (has_insertfilterresponse()) {
    delete response_.insertfilterresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::InsertFilterResponse& AnselIPCResponse::insertfilterresponse() const {
  return has_insertfilterresponse() ? *response_.insertfilterresponse_
                      : ::AnselIpc::InsertFilterResponse::default_instance();
}
inline ::AnselIpc::InsertFilterResponse* AnselIPCResponse::mutable_insertfilterresponse() {
  if (!has_insertfilterresponse()) {
    clear_response();
    set_has_insertfilterresponse();
    response_.insertfilterresponse_ = new ::AnselIpc::InsertFilterResponse;
  }
  return response_.insertfilterresponse_;
}
inline ::AnselIpc::InsertFilterResponse* AnselIPCResponse::release_insertfilterresponse() {
  if (has_insertfilterresponse()) {
    clear_has_response();
    ::AnselIpc::InsertFilterResponse* temp = response_.insertfilterresponse_;
    response_.insertfilterresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_insertfilterresponse(::AnselIpc::InsertFilterResponse* insertfilterresponse) {
  clear_response();
  if (insertfilterresponse) {
    set_has_insertfilterresponse();
    response_.insertfilterresponse_ = insertfilterresponse;
  }
}

// optional .AnselIpc.RemoveFilterResponse removeFilterResponse = 48;
inline bool AnselIPCResponse::has_removefilterresponse() const {
  return response_case() == kRemoveFilterResponse;
}
inline void AnselIPCResponse::set_has_removefilterresponse() {
  _oneof_case_[0] = kRemoveFilterResponse;
}
inline void AnselIPCResponse::clear_removefilterresponse() {
  if (has_removefilterresponse()) {
    delete response_.removefilterresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::RemoveFilterResponse& AnselIPCResponse::removefilterresponse() const {
  return has_removefilterresponse() ? *response_.removefilterresponse_
                      : ::AnselIpc::RemoveFilterResponse::default_instance();
}
inline ::AnselIpc::RemoveFilterResponse* AnselIPCResponse::mutable_removefilterresponse() {
  if (!has_removefilterresponse()) {
    clear_response();
    set_has_removefilterresponse();
    response_.removefilterresponse_ = new ::AnselIpc::RemoveFilterResponse;
  }
  return response_.removefilterresponse_;
}
inline ::AnselIpc::RemoveFilterResponse* AnselIPCResponse::release_removefilterresponse() {
  if (has_removefilterresponse()) {
    clear_has_response();
    ::AnselIpc::RemoveFilterResponse* temp = response_.removefilterresponse_;
    response_.removefilterresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_removefilterresponse(::AnselIpc::RemoveFilterResponse* removefilterresponse) {
  clear_response();
  if (removefilterresponse) {
    set_has_removefilterresponse();
    response_.removefilterresponse_ = removefilterresponse;
  }
}

// optional .AnselIpc.ReportErrorResponse reportErrorResponse = 49;
inline bool AnselIPCResponse::has_reporterrorresponse() const {
  return response_case() == kReportErrorResponse;
}
inline void AnselIPCResponse::set_has_reporterrorresponse() {
  _oneof_case_[0] = kReportErrorResponse;
}
inline void AnselIPCResponse::clear_reporterrorresponse() {
  if (has_reporterrorresponse()) {
    delete response_.reporterrorresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::ReportErrorResponse& AnselIPCResponse::reporterrorresponse() const {
  return has_reporterrorresponse() ? *response_.reporterrorresponse_
                      : ::AnselIpc::ReportErrorResponse::default_instance();
}
inline ::AnselIpc::ReportErrorResponse* AnselIPCResponse::mutable_reporterrorresponse() {
  if (!has_reporterrorresponse()) {
    clear_response();
    set_has_reporterrorresponse();
    response_.reporterrorresponse_ = new ::AnselIpc::ReportErrorResponse;
  }
  return response_.reporterrorresponse_;
}
inline ::AnselIpc::ReportErrorResponse* AnselIPCResponse::release_reporterrorresponse() {
  if (has_reporterrorresponse()) {
    clear_has_response();
    ::AnselIpc::ReportErrorResponse* temp = response_.reporterrorresponse_;
    response_.reporterrorresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_reporterrorresponse(::AnselIpc::ReportErrorResponse* reporterrorresponse) {
  clear_response();
  if (reporterrorresponse) {
    set_has_reporterrorresponse();
    response_.reporterrorresponse_ = reporterrorresponse;
  }
}

// optional .AnselIpc.EstimateCaptureResponse estimateCaptureResponse = 50;
inline bool AnselIPCResponse::has_estimatecaptureresponse() const {
  return response_case() == kEstimateCaptureResponse;
}
inline void AnselIPCResponse::set_has_estimatecaptureresponse() {
  _oneof_case_[0] = kEstimateCaptureResponse;
}
inline void AnselIPCResponse::clear_estimatecaptureresponse() {
  if (has_estimatecaptureresponse()) {
    delete response_.estimatecaptureresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::EstimateCaptureResponse& AnselIPCResponse::estimatecaptureresponse() const {
  return has_estimatecaptureresponse() ? *response_.estimatecaptureresponse_
                      : ::AnselIpc::EstimateCaptureResponse::default_instance();
}
inline ::AnselIpc::EstimateCaptureResponse* AnselIPCResponse::mutable_estimatecaptureresponse() {
  if (!has_estimatecaptureresponse()) {
    clear_response();
    set_has_estimatecaptureresponse();
    response_.estimatecaptureresponse_ = new ::AnselIpc::EstimateCaptureResponse;
  }
  return response_.estimatecaptureresponse_;
}
inline ::AnselIpc::EstimateCaptureResponse* AnselIPCResponse::release_estimatecaptureresponse() {
  if (has_estimatecaptureresponse()) {
    clear_has_response();
    ::AnselIpc::EstimateCaptureResponse* temp = response_.estimatecaptureresponse_;
    response_.estimatecaptureresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_estimatecaptureresponse(::AnselIpc::EstimateCaptureResponse* estimatecaptureresponse) {
  clear_response();
  if (estimatecaptureresponse) {
    set_has_estimatecaptureresponse();
    response_.estimatecaptureresponse_ = estimatecaptureresponse;
  }
}

// optional .AnselIpc.UIControlRemoveAllResponse uiControlRemoveAllResponse = 51;
inline bool AnselIPCResponse::has_uicontrolremoveallresponse() const {
  return response_case() == kUiControlRemoveAllResponse;
}
inline void AnselIPCResponse::set_has_uicontrolremoveallresponse() {
  _oneof_case_[0] = kUiControlRemoveAllResponse;
}
inline void AnselIPCResponse::clear_uicontrolremoveallresponse() {
  if (has_uicontrolremoveallresponse()) {
    delete response_.uicontrolremoveallresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::UIControlRemoveAllResponse& AnselIPCResponse::uicontrolremoveallresponse() const {
  return has_uicontrolremoveallresponse() ? *response_.uicontrolremoveallresponse_
                      : ::AnselIpc::UIControlRemoveAllResponse::default_instance();
}
inline ::AnselIpc::UIControlRemoveAllResponse* AnselIPCResponse::mutable_uicontrolremoveallresponse() {
  if (!has_uicontrolremoveallresponse()) {
    clear_response();
    set_has_uicontrolremoveallresponse();
    response_.uicontrolremoveallresponse_ = new ::AnselIpc::UIControlRemoveAllResponse;
  }
  return response_.uicontrolremoveallresponse_;
}
inline ::AnselIpc::UIControlRemoveAllResponse* AnselIPCResponse::release_uicontrolremoveallresponse() {
  if (has_uicontrolremoveallresponse()) {
    clear_has_response();
    ::AnselIpc::UIControlRemoveAllResponse* temp = response_.uicontrolremoveallresponse_;
    response_.uicontrolremoveallresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_uicontrolremoveallresponse(::AnselIpc::UIControlRemoveAllResponse* uicontrolremoveallresponse) {
  clear_response();
  if (uicontrolremoveallresponse) {
    set_has_uicontrolremoveallresponse();
    response_.uicontrolremoveallresponse_ = uicontrolremoveallresponse;
  }
}

// optional .AnselIpc.GetSettingsResponse getSettingsResponse = 52;
inline bool AnselIPCResponse::has_getsettingsresponse() const {
  return response_case() == kGetSettingsResponse;
}
inline void AnselIPCResponse::set_has_getsettingsresponse() {
  _oneof_case_[0] = kGetSettingsResponse;
}
inline void AnselIPCResponse::clear_getsettingsresponse() {
  if (has_getsettingsresponse()) {
    delete response_.getsettingsresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::GetSettingsResponse& AnselIPCResponse::getsettingsresponse() const {
  return has_getsettingsresponse() ? *response_.getsettingsresponse_
                      : ::AnselIpc::GetSettingsResponse::default_instance();
}
inline ::AnselIpc::GetSettingsResponse* AnselIPCResponse::mutable_getsettingsresponse() {
  if (!has_getsettingsresponse()) {
    clear_response();
    set_has_getsettingsresponse();
    response_.getsettingsresponse_ = new ::AnselIpc::GetSettingsResponse;
  }
  return response_.getsettingsresponse_;
}
inline ::AnselIpc::GetSettingsResponse* AnselIPCResponse::release_getsettingsresponse() {
  if (has_getsettingsresponse()) {
    clear_has_response();
    ::AnselIpc::GetSettingsResponse* temp = response_.getsettingsresponse_;
    response_.getsettingsresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_getsettingsresponse(::AnselIpc::GetSettingsResponse* getsettingsresponse) {
  clear_response();
  if (getsettingsresponse) {
    set_has_getsettingsresponse();
    response_.getsettingsresponse_ = getsettingsresponse;
  }
}

// optional .AnselIpc.AnselStatusReportResponse anselStatusReportResponse = 53;
inline bool AnselIPCResponse::has_anselstatusreportresponse() const {
  return response_case() == kAnselStatusReportResponse;
}
inline void AnselIPCResponse::set_has_anselstatusreportresponse() {
  _oneof_case_[0] = kAnselStatusReportResponse;
}
inline void AnselIPCResponse::clear_anselstatusreportresponse() {
  if (has_anselstatusreportresponse()) {
    delete response_.anselstatusreportresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::AnselStatusReportResponse& AnselIPCResponse::anselstatusreportresponse() const {
  return has_anselstatusreportresponse() ? *response_.anselstatusreportresponse_
                      : ::AnselIpc::AnselStatusReportResponse::default_instance();
}
inline ::AnselIpc::AnselStatusReportResponse* AnselIPCResponse::mutable_anselstatusreportresponse() {
  if (!has_anselstatusreportresponse()) {
    clear_response();
    set_has_anselstatusreportresponse();
    response_.anselstatusreportresponse_ = new ::AnselIpc::AnselStatusReportResponse;
  }
  return response_.anselstatusreportresponse_;
}
inline ::AnselIpc::AnselStatusReportResponse* AnselIPCResponse::release_anselstatusreportresponse() {
  if (has_anselstatusreportresponse()) {
    clear_has_response();
    ::AnselIpc::AnselStatusReportResponse* temp = response_.anselstatusreportresponse_;
    response_.anselstatusreportresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_anselstatusreportresponse(::AnselIpc::AnselStatusReportResponse* anselstatusreportresponse) {
  clear_response();
  if (anselstatusreportresponse) {
    set_has_anselstatusreportresponse();
    response_.anselstatusreportresponse_ = anselstatusreportresponse;
  }
}

// optional .AnselIpc.StyleTransferSideloadChoiceResponse styleTransferSideloadChoiceResponse = 54;
inline bool AnselIPCResponse::has_styletransfersideloadchoiceresponse() const {
  return response_case() == kStyleTransferSideloadChoiceResponse;
}
inline void AnselIPCResponse::set_has_styletransfersideloadchoiceresponse() {
  _oneof_case_[0] = kStyleTransferSideloadChoiceResponse;
}
inline void AnselIPCResponse::clear_styletransfersideloadchoiceresponse() {
  if (has_styletransfersideloadchoiceresponse()) {
    delete response_.styletransfersideloadchoiceresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::StyleTransferSideloadChoiceResponse& AnselIPCResponse::styletransfersideloadchoiceresponse() const {
  return has_styletransfersideloadchoiceresponse() ? *response_.styletransfersideloadchoiceresponse_
                      : ::AnselIpc::StyleTransferSideloadChoiceResponse::default_instance();
}
inline ::AnselIpc::StyleTransferSideloadChoiceResponse* AnselIPCResponse::mutable_styletransfersideloadchoiceresponse() {
  if (!has_styletransfersideloadchoiceresponse()) {
    clear_response();
    set_has_styletransfersideloadchoiceresponse();
    response_.styletransfersideloadchoiceresponse_ = new ::AnselIpc::StyleTransferSideloadChoiceResponse;
  }
  return response_.styletransfersideloadchoiceresponse_;
}
inline ::AnselIpc::StyleTransferSideloadChoiceResponse* AnselIPCResponse::release_styletransfersideloadchoiceresponse() {
  if (has_styletransfersideloadchoiceresponse()) {
    clear_has_response();
    ::AnselIpc::StyleTransferSideloadChoiceResponse* temp = response_.styletransfersideloadchoiceresponse_;
    response_.styletransfersideloadchoiceresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_styletransfersideloadchoiceresponse(::AnselIpc::StyleTransferSideloadChoiceResponse* styletransfersideloadchoiceresponse) {
  clear_response();
  if (styletransfersideloadchoiceresponse) {
    set_has_styletransfersideloadchoiceresponse();
    response_.styletransfersideloadchoiceresponse_ = styletransfersideloadchoiceresponse;
  }
}

// optional .AnselIpc.StyleTransferSideloadProgressResponse styleTransferSideloadProgressResponse = 55;
inline bool AnselIPCResponse::has_styletransfersideloadprogressresponse() const {
  return response_case() == kStyleTransferSideloadProgressResponse;
}
inline void AnselIPCResponse::set_has_styletransfersideloadprogressresponse() {
  _oneof_case_[0] = kStyleTransferSideloadProgressResponse;
}
inline void AnselIPCResponse::clear_styletransfersideloadprogressresponse() {
  if (has_styletransfersideloadprogressresponse()) {
    delete response_.styletransfersideloadprogressresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::StyleTransferSideloadProgressResponse& AnselIPCResponse::styletransfersideloadprogressresponse() const {
  return has_styletransfersideloadprogressresponse() ? *response_.styletransfersideloadprogressresponse_
                      : ::AnselIpc::StyleTransferSideloadProgressResponse::default_instance();
}
inline ::AnselIpc::StyleTransferSideloadProgressResponse* AnselIPCResponse::mutable_styletransfersideloadprogressresponse() {
  if (!has_styletransfersideloadprogressresponse()) {
    clear_response();
    set_has_styletransfersideloadprogressresponse();
    response_.styletransfersideloadprogressresponse_ = new ::AnselIpc::StyleTransferSideloadProgressResponse;
  }
  return response_.styletransfersideloadprogressresponse_;
}
inline ::AnselIpc::StyleTransferSideloadProgressResponse* AnselIPCResponse::release_styletransfersideloadprogressresponse() {
  if (has_styletransfersideloadprogressresponse()) {
    clear_has_response();
    ::AnselIpc::StyleTransferSideloadProgressResponse* temp = response_.styletransfersideloadprogressresponse_;
    response_.styletransfersideloadprogressresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_styletransfersideloadprogressresponse(::AnselIpc::StyleTransferSideloadProgressResponse* styletransfersideloadprogressresponse) {
  clear_response();
  if (styletransfersideloadprogressresponse) {
    set_has_styletransfersideloadprogressresponse();
    response_.styletransfersideloadprogressresponse_ = styletransfersideloadprogressresponse;
  }
}

// optional .AnselIpc.UpdateRollResponse updateRollResponse = 56;
inline bool AnselIPCResponse::has_updaterollresponse() const {
  return response_case() == kUpdateRollResponse;
}
inline void AnselIPCResponse::set_has_updaterollresponse() {
  _oneof_case_[0] = kUpdateRollResponse;
}
inline void AnselIPCResponse::clear_updaterollresponse() {
  if (has_updaterollresponse()) {
    delete response_.updaterollresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::UpdateRollResponse& AnselIPCResponse::updaterollresponse() const {
  return has_updaterollresponse() ? *response_.updaterollresponse_
                      : ::AnselIpc::UpdateRollResponse::default_instance();
}
inline ::AnselIpc::UpdateRollResponse* AnselIPCResponse::mutable_updaterollresponse() {
  if (!has_updaterollresponse()) {
    clear_response();
    set_has_updaterollresponse();
    response_.updaterollresponse_ = new ::AnselIpc::UpdateRollResponse;
  }
  return response_.updaterollresponse_;
}
inline ::AnselIpc::UpdateRollResponse* AnselIPCResponse::release_updaterollresponse() {
  if (has_updaterollresponse()) {
    clear_has_response();
    ::AnselIpc::UpdateRollResponse* temp = response_.updaterollresponse_;
    response_.updaterollresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_updaterollresponse(::AnselIpc::UpdateRollResponse* updaterollresponse) {
  clear_response();
  if (updaterollresponse) {
    set_has_updaterollresponse();
    response_.updaterollresponse_ = updaterollresponse;
  }
}

// optional .AnselIpc.GetEnabledFeatureSetResponse getEnabledFeatureSetResponse = 57;
inline bool AnselIPCResponse::has_getenabledfeaturesetresponse() const {
  return response_case() == kGetEnabledFeatureSetResponse;
}
inline void AnselIPCResponse::set_has_getenabledfeaturesetresponse() {
  _oneof_case_[0] = kGetEnabledFeatureSetResponse;
}
inline void AnselIPCResponse::clear_getenabledfeaturesetresponse() {
  if (has_getenabledfeaturesetresponse()) {
    delete response_.getenabledfeaturesetresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::GetEnabledFeatureSetResponse& AnselIPCResponse::getenabledfeaturesetresponse() const {
  return has_getenabledfeaturesetresponse() ? *response_.getenabledfeaturesetresponse_
                      : ::AnselIpc::GetEnabledFeatureSetResponse::default_instance();
}
inline ::AnselIpc::GetEnabledFeatureSetResponse* AnselIPCResponse::mutable_getenabledfeaturesetresponse() {
  if (!has_getenabledfeaturesetresponse()) {
    clear_response();
    set_has_getenabledfeaturesetresponse();
    response_.getenabledfeaturesetresponse_ = new ::AnselIpc::GetEnabledFeatureSetResponse;
  }
  return response_.getenabledfeaturesetresponse_;
}
inline ::AnselIpc::GetEnabledFeatureSetResponse* AnselIPCResponse::release_getenabledfeaturesetresponse() {
  if (has_getenabledfeaturesetresponse()) {
    clear_has_response();
    ::AnselIpc::GetEnabledFeatureSetResponse* temp = response_.getenabledfeaturesetresponse_;
    response_.getenabledfeaturesetresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_getenabledfeaturesetresponse(::AnselIpc::GetEnabledFeatureSetResponse* getenabledfeaturesetresponse) {
  clear_response();
  if (getenabledfeaturesetresponse) {
    set_has_getenabledfeaturesetresponse();
    response_.getenabledfeaturesetresponse_ = getenabledfeaturesetresponse;
  }
}

// optional .AnselIpc.UpdateFovResponse updateFovResponse = 58;
inline bool AnselIPCResponse::has_updatefovresponse() const {
  return response_case() == kUpdateFovResponse;
}
inline void AnselIPCResponse::set_has_updatefovresponse() {
  _oneof_case_[0] = kUpdateFovResponse;
}
inline void AnselIPCResponse::clear_updatefovresponse() {
  if (has_updatefovresponse()) {
    delete response_.updatefovresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::UpdateFovResponse& AnselIPCResponse::updatefovresponse() const {
  return has_updatefovresponse() ? *response_.updatefovresponse_
                      : ::AnselIpc::UpdateFovResponse::default_instance();
}
inline ::AnselIpc::UpdateFovResponse* AnselIPCResponse::mutable_updatefovresponse() {
  if (!has_updatefovresponse()) {
    clear_response();
    set_has_updatefovresponse();
    response_.updatefovresponse_ = new ::AnselIpc::UpdateFovResponse;
  }
  return response_.updatefovresponse_;
}
inline ::AnselIpc::UpdateFovResponse* AnselIPCResponse::release_updatefovresponse() {
  if (has_updatefovresponse()) {
    clear_has_response();
    ::AnselIpc::UpdateFovResponse* temp = response_.updatefovresponse_;
    response_.updatefovresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_updatefovresponse(::AnselIpc::UpdateFovResponse* updatefovresponse) {
  clear_response();
  if (updatefovresponse) {
    set_has_updatefovresponse();
    response_.updatefovresponse_ = updatefovresponse;
  }
}

// optional .AnselIpc.AnselReadyResponse anselReadyResponse = 59;
inline bool AnselIPCResponse::has_anselreadyresponse() const {
  return response_case() == kAnselReadyResponse;
}
inline void AnselIPCResponse::set_has_anselreadyresponse() {
  _oneof_case_[0] = kAnselReadyResponse;
}
inline void AnselIPCResponse::clear_anselreadyresponse() {
  if (has_anselreadyresponse()) {
    delete response_.anselreadyresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::AnselReadyResponse& AnselIPCResponse::anselreadyresponse() const {
  return has_anselreadyresponse() ? *response_.anselreadyresponse_
                      : ::AnselIpc::AnselReadyResponse::default_instance();
}
inline ::AnselIpc::AnselReadyResponse* AnselIPCResponse::mutable_anselreadyresponse() {
  if (!has_anselreadyresponse()) {
    clear_response();
    set_has_anselreadyresponse();
    response_.anselreadyresponse_ = new ::AnselIpc::AnselReadyResponse;
  }
  return response_.anselreadyresponse_;
}
inline ::AnselIpc::AnselReadyResponse* AnselIPCResponse::release_anselreadyresponse() {
  if (has_anselreadyresponse()) {
    clear_has_response();
    ::AnselIpc::AnselReadyResponse* temp = response_.anselreadyresponse_;
    response_.anselreadyresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_anselreadyresponse(::AnselIpc::AnselReadyResponse* anselreadyresponse) {
  clear_response();
  if (anselreadyresponse) {
    set_has_anselreadyresponse();
    response_.anselreadyresponse_ = anselreadyresponse;
  }
}

// optional .AnselIpc.SetHighQualityResponse setHighQualityResponse = 60;
inline bool AnselIPCResponse::has_sethighqualityresponse() const {
  return response_case() == kSetHighQualityResponse;
}
inline void AnselIPCResponse::set_has_sethighqualityresponse() {
  _oneof_case_[0] = kSetHighQualityResponse;
}
inline void AnselIPCResponse::clear_sethighqualityresponse() {
  if (has_sethighqualityresponse()) {
    delete response_.sethighqualityresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::SetHighQualityResponse& AnselIPCResponse::sethighqualityresponse() const {
  return has_sethighqualityresponse() ? *response_.sethighqualityresponse_
                      : ::AnselIpc::SetHighQualityResponse::default_instance();
}
inline ::AnselIpc::SetHighQualityResponse* AnselIPCResponse::mutable_sethighqualityresponse() {
  if (!has_sethighqualityresponse()) {
    clear_response();
    set_has_sethighqualityresponse();
    response_.sethighqualityresponse_ = new ::AnselIpc::SetHighQualityResponse;
  }
  return response_.sethighqualityresponse_;
}
inline ::AnselIpc::SetHighQualityResponse* AnselIPCResponse::release_sethighqualityresponse() {
  if (has_sethighqualityresponse()) {
    clear_has_response();
    ::AnselIpc::SetHighQualityResponse* temp = response_.sethighqualityresponse_;
    response_.sethighqualityresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_sethighqualityresponse(::AnselIpc::SetHighQualityResponse* sethighqualityresponse) {
  clear_response();
  if (sethighqualityresponse) {
    set_has_sethighqualityresponse();
    response_.sethighqualityresponse_ = sethighqualityresponse;
  }
}

// optional .AnselIpc.SetFilterAndAttributesResponse setFilterAndAttributesResponse = 61;
inline bool AnselIPCResponse::has_setfilterandattributesresponse() const {
  return response_case() == kSetFilterAndAttributesResponse;
}
inline void AnselIPCResponse::set_has_setfilterandattributesresponse() {
  _oneof_case_[0] = kSetFilterAndAttributesResponse;
}
inline void AnselIPCResponse::clear_setfilterandattributesresponse() {
  if (has_setfilterandattributesresponse()) {
    delete response_.setfilterandattributesresponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::SetFilterAndAttributesResponse& AnselIPCResponse::setfilterandattributesresponse() const {
  return has_setfilterandattributesresponse() ? *response_.setfilterandattributesresponse_
                      : ::AnselIpc::SetFilterAndAttributesResponse::default_instance();
}
inline ::AnselIpc::SetFilterAndAttributesResponse* AnselIPCResponse::mutable_setfilterandattributesresponse() {
  if (!has_setfilterandattributesresponse()) {
    clear_response();
    set_has_setfilterandattributesresponse();
    response_.setfilterandattributesresponse_ = new ::AnselIpc::SetFilterAndAttributesResponse;
  }
  return response_.setfilterandattributesresponse_;
}
inline ::AnselIpc::SetFilterAndAttributesResponse* AnselIPCResponse::release_setfilterandattributesresponse() {
  if (has_setfilterandattributesresponse()) {
    clear_has_response();
    ::AnselIpc::SetFilterAndAttributesResponse* temp = response_.setfilterandattributesresponse_;
    response_.setfilterandattributesresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_setfilterandattributesresponse(::AnselIpc::SetFilterAndAttributesResponse* setfilterandattributesresponse) {
  clear_response();
  if (setfilterandattributesresponse) {
    set_has_setfilterandattributesresponse();
    response_.setfilterandattributesresponse_ = setfilterandattributesresponse;
  }
}

// optional .AnselIpc.SetCMSInfoResponse setCMSInfoResponse = 62;
inline bool AnselIPCResponse::has_setcmsinforesponse() const {
  return response_case() == kSetCMSInfoResponse;
}
inline void AnselIPCResponse::set_has_setcmsinforesponse() {
  _oneof_case_[0] = kSetCMSInfoResponse;
}
inline void AnselIPCResponse::clear_setcmsinforesponse() {
  if (has_setcmsinforesponse()) {
    delete response_.setcmsinforesponse_;
    clear_has_response();
  }
}
inline const ::AnselIpc::SetCMSInfoResponse& AnselIPCResponse::setcmsinforesponse() const {
  return has_setcmsinforesponse() ? *response_.setcmsinforesponse_
                      : ::AnselIpc::SetCMSInfoResponse::default_instance();
}
inline ::AnselIpc::SetCMSInfoResponse* AnselIPCResponse::mutable_setcmsinforesponse() {
  if (!has_setcmsinforesponse()) {
    clear_response();
    set_has_setcmsinforesponse();
    response_.setcmsinforesponse_ = new ::AnselIpc::SetCMSInfoResponse;
  }
  return response_.setcmsinforesponse_;
}
inline ::AnselIpc::SetCMSInfoResponse* AnselIPCResponse::release_setcmsinforesponse() {
  if (has_setcmsinforesponse()) {
    clear_has_response();
    ::AnselIpc::SetCMSInfoResponse* temp = response_.setcmsinforesponse_;
    response_.setcmsinforesponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCResponse::set_allocated_setcmsinforesponse(::AnselIpc::SetCMSInfoResponse* setcmsinforesponse) {
  clear_response();
  if (setcmsinforesponse) {
    set_has_setcmsinforesponse();
    response_.setcmsinforesponse_ = setcmsinforesponse;
  }
}

inline bool AnselIPCResponse::has_response() {
  return response_case() != RESPONSE_NOT_SET;
}
inline void AnselIPCResponse::clear_has_response() {
  _oneof_case_[0] = RESPONSE_NOT_SET;
}
inline AnselIPCResponse::ResponseCase AnselIPCResponse::response_case() const {
  return AnselIPCResponse::ResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AnselIPCMessage

// optional .AnselIpc.AnselIPCRequest request = 1;
inline bool AnselIPCMessage::has_request() const {
  return message_case() == kRequest;
}
inline void AnselIPCMessage::set_has_request() {
  _oneof_case_[0] = kRequest;
}
inline void AnselIPCMessage::clear_request() {
  if (has_request()) {
    delete message_.request_;
    clear_has_message();
  }
}
inline const ::AnselIpc::AnselIPCRequest& AnselIPCMessage::request() const {
  return has_request() ? *message_.request_
                      : ::AnselIpc::AnselIPCRequest::default_instance();
}
inline ::AnselIpc::AnselIPCRequest* AnselIPCMessage::mutable_request() {
  if (!has_request()) {
    clear_message();
    set_has_request();
    message_.request_ = new ::AnselIpc::AnselIPCRequest;
  }
  return message_.request_;
}
inline ::AnselIpc::AnselIPCRequest* AnselIPCMessage::release_request() {
  if (has_request()) {
    clear_has_message();
    ::AnselIpc::AnselIPCRequest* temp = message_.request_;
    message_.request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCMessage::set_allocated_request(::AnselIpc::AnselIPCRequest* request) {
  clear_message();
  if (request) {
    set_has_request();
    message_.request_ = request;
  }
}

// optional .AnselIpc.AnselIPCResponse response = 2;
inline bool AnselIPCMessage::has_response() const {
  return message_case() == kResponse;
}
inline void AnselIPCMessage::set_has_response() {
  _oneof_case_[0] = kResponse;
}
inline void AnselIPCMessage::clear_response() {
  if (has_response()) {
    delete message_.response_;
    clear_has_message();
  }
}
inline const ::AnselIpc::AnselIPCResponse& AnselIPCMessage::response() const {
  return has_response() ? *message_.response_
                      : ::AnselIpc::AnselIPCResponse::default_instance();
}
inline ::AnselIpc::AnselIPCResponse* AnselIPCMessage::mutable_response() {
  if (!has_response()) {
    clear_message();
    set_has_response();
    message_.response_ = new ::AnselIpc::AnselIPCResponse;
  }
  return message_.response_;
}
inline ::AnselIpc::AnselIPCResponse* AnselIPCMessage::release_response() {
  if (has_response()) {
    clear_has_message();
    ::AnselIpc::AnselIPCResponse* temp = message_.response_;
    message_.response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnselIPCMessage::set_allocated_response(::AnselIpc::AnselIPCResponse* response) {
  clear_message();
  if (response) {
    set_has_response();
    message_.response_ = response;
  }
}

inline bool AnselIPCMessage::has_message() {
  return message_case() != MESSAGE_NOT_SET;
}
inline void AnselIPCMessage::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline AnselIPCMessage::MessageCase AnselIPCMessage::message_case() const {
  return AnselIPCMessage::MessageCase(_oneof_case_[0]);
}

// @@protoc_insertion_point(namespace_scope)

}  // namespace AnselIpc

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::AnselIpc::ErrorType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AnselIpc::ErrorType>() {
  return ::AnselIpc::ErrorType_descriptor();
}
template <> struct is_proto_enum< ::AnselIpc::Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AnselIpc::Status>() {
  return ::AnselIpc::Status_descriptor();
}
template <> struct is_proto_enum< ::AnselIpc::ControlType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AnselIpc::ControlType>() {
  return ::AnselIpc::ControlType_descriptor();
}
template <> struct is_proto_enum< ::AnselIpc::SideloadChoice> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AnselIpc::SideloadChoice>() {
  return ::AnselIpc::SideloadChoice_descriptor();
}
template <> struct is_proto_enum< ::AnselIpc::SideloadProgress> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AnselIpc::SideloadProgress>() {
  return ::AnselIpc::SideloadProgress_descriptor();
}
template <> struct is_proto_enum< ::AnselIpc::State> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AnselIpc::State>() {
  return ::AnselIpc::State_descriptor();
}
template <> struct is_proto_enum< ::AnselIpc::ShotTypeIPC> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AnselIpc::ShotTypeIPC>() {
  return ::AnselIpc::ShotTypeIPC_descriptor();
}
template <> struct is_proto_enum< ::AnselIpc::EditAllowedType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AnselIpc::EditAllowedType>() {
  return ::AnselIpc::EditAllowedType_descriptor();
}
template <> struct is_proto_enum< ::AnselIpc::ListSelectionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AnselIpc::ListSelectionType>() {
  return ::AnselIpc::ListSelectionType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ipc_2eproto__INCLUDED
