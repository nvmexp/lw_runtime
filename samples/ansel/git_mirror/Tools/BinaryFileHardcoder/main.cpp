#include <iostream>
#include <conio.h>
#include <vector>
#include <fstream>

// <filesystem> is only used to get the file's size, and this library requires ISO C++ 17 Standard
#include <filesystem>

bool SplitPathIntoDirectoryAndFileName(const std::string& fullFilePath, std::string& directory_out, std::string& fileName_out)
{
    directory_out = "";
    size_t posOfLastSlash = fullFilePath.find_last_of('\\');
    if (posOfLastSlash == std::string::npos)
    {
        fileName_out = fullFilePath;
        return false;
    }
    directory_out = fullFilePath.substr(0, posOfLastSlash + 1);
    fileName_out = fullFilePath.substr(posOfLastSlash + 1);
    return true;
}

int main(int argc, char *argv[])
{
    if (argc == 1)
    {
        printf("\n");
        printf("  Usage:\n");
        printf("      1) Gather together all filter files and associated binary files needed for a filter effect.\n");
        printf("             -This includes any acef, cso, yaml, fx, yfx and extensionless files.\n");
        printf("      2) Drag and drop all of these files onto this exe at the same time.\n");
        printf("      3) This will create a new file, \"HardcodedFX_<FXName>.cpp\" in the folder the dragged files came from.\n");
        printf("      4) Copy the contents of this file into the end of the CheckForFilesOrWriteFiles() function in HardcodedFiles.h\n");
        printf("      5) Then LwCamera will be able to load this filter effect even when the corresponding .yaml, .yfx or .fx files\n");
        printf("         do not exist.\n");
        printf("\n");
        printf("  Press any key to exit...\n");
        _getch();
        return 1;
    }

    // Turn them all into strings
    std::vector<std::string> filePaths;
    std::string fxNameNoExt = "";
    std::string fxNameExt = "";
    for (int i = 1; i < argc; ++i)
    {
        std::string lwrPath = std::string(argv[i]);

        // Check for the fxName
        size_t lastDotPos = lwrPath.find_last_of('.');
        std::string lwrExtension = (lastDotPos != std::string::npos) ? lwrPath.substr(lastDotPos+1) : "";
        if (lwrExtension == "acef" || lwrExtension == "")
        {
            std::string directory, fileName;
            SplitPathIntoDirectoryAndFileName(lwrPath, directory, fileName);
            fxNameNoExt = fileName.substr(0, fileName.find_last_of('.'));
        }
        if (lwrExtension == "yaml" || lwrExtension == "fx")
        {
            // Track the type of effect that this came from (Yaml or ReShade)
            fxNameExt = lwrExtension;
        }
        else if (lwrExtension != "yaml" && lwrExtension != "fx" && lwrExtension != "cpp" && lwrExtension != "")
        {
            // Do not hardcode the source file ("yaml"||"fx")
            // Do not hardcode generated files ("cpp")
            // Do not hardcode the strange extensionless files generated by the ReShade Compiler since these are not actually used... ("") TODO: Make the ReShade Compiler not generate these
            filePaths.push_back(lwrPath);
        }
    }

    // Open the output file for writing.
    std::ofstream hardcodedFX;
    std::string hardcodedFXFileName = "HardcodedFX_" + fxNameNoExt + ".cpp";
    hardcodedFX.open(hardcodedFXFileName, std::ios::out | std::ios::binary);
    if (hardcodedFX.is_open())
    {
        hardcodedFX << "\tProcessEffectName(L\"";
        if (fxNameExt == "")
        {
            // WAR for strange quark of loading reshade sub-effects
            hardcodedFX << "\\\\"; // 2 backslashes
        }
        hardcodedFX << fxNameNoExt << "\", L\"" << fxNameExt << "\", pHardcodedFXFiles)\n";
        hardcodedFX << "\t{\n";

        // Process each of the binary file inputs
        for (size_t i = 0; i < filePaths.size(); i++)
        {
            std::ifstream binaryIn(filePaths[i], std::ios::in | std::ios::binary);
            if (binaryIn.is_open())
            {
                std::string directory, fileName;
                SplitPathIntoDirectoryAndFileName(filePaths[i], directory, fileName);
                hardcodedFX << "\t\tif (L\"" << fileName << "\" == fileName)\n";
                hardcodedFX << "\t\t{\n";

                // filesystem is only used to get the file's size, and this library requires ISO C++ 17 Standard
                uintmax_t fileSize = std::filesystem::file_size(filePaths[i]);
                hardcodedFX << "\t\t\tchar fileContents[" << fileSize << "] = { ";

                // Write the binary file contents as char values
                {
                    char* fileContents = new char[fileSize];
                    binaryIn.read(fileContents, fileSize);
                    for (uintmax_t i = 0; i < fileSize; i++)
                    {
                        hardcodedFX << static_cast<int>(fileContents[i]);
                        if (i < fileSize - 1) hardcodedFX << ',';
                    }
                    delete fileContents;
                }

                hardcodedFX << " };\n";
                hardcodedFX << "\t\t\tWriteFileContentsToFile(" << fileSize << ", directory, fullFilePath, fileContents);\n";
                hardcodedFX << "\t\t}\n";

                binaryIn.close();
            }
            else
            {
                printf("Error: Failed to open the following file for reading:");
                printf("\t\"%s\"", filePaths[i].c_str());
                _getch();
                continue;
            }
        }

        hardcodedFX << "\t\treturn S_OK;\n";
        hardcodedFX << "\t}\n";

        hardcodedFX.close();
    }
    else
    {
        printf("Error: Failed to open the following file for writing:");
        printf("\t\"%s\"", hardcodedFXFileName.c_str());
        _getch();
        return 1;
    }

    return 0;
}
