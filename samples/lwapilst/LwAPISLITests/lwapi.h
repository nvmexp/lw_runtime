 /***************************************************************************\
|*                                                                           *|
|*      Copyright 2005-2010 LWPU Corporation.  All rights reserved.        *|
|*                                                                           *|     
|*   THE SOFTWARE AND INFORMATION CONTAINED HEREIN IS PROPRIETARY AND        *|
|*   CONFIDENTIAL TO LWPU CORPORATION. THIS SOFTWARE IS FOR INTERNAL USE   *|
|*   ONLY AND ANY REPRODUCTION OR DISCLOSURE TO ANY PARTY OUTSIDE OF LWPU  *|
|*   IS STRICTLY PROHIBITED.                                                 *|
|*                                                                           *|
 \***************************************************************************/
///////////////////////////////////////////////////////////////////////////////
//
// Date: Apr 30, 2014 
// File: lwapi.h
//
// LwAPI provides an interface to LWPU devices. This file contains the 
// interface constants, structure definitions and function prototypes.
//
//   Target Profile: lwsdk
//  Target Platform: windows
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _LWAPI_H
#define _LWAPI_H

#pragma pack(push,8) // Make sure we have consistent structure packings

#ifdef __cplusplus
extern "C" {
#endif

// ====================================================
// Universal LwAPI Definitions
// ====================================================
#ifndef _WIN32
#define __cdecl
#endif

// ====================================================
// SAL related support
// ====================================================

#ifndef __ecount
    #define __lwapi_undef__ecount
    #define __ecount(size)
#endif
#ifndef __bcount
    #define __lwapi_undef__bcount
    #define __bcount(size)
#endif
#ifndef __in
    #define __lwapi_undef__in
    #define __in
#endif
#ifndef __in_ecount
    #define __lwapi_undef__in_ecount
    #define __in_ecount(size)
#endif
#ifndef __in_bcount
    #define __lwapi_undef__in_bcount
    #define __in_bcount(size)
#endif
#ifndef __in_z
    #define __lwapi_undef__in_z
    #define __in_z
#endif
#ifndef __in_ecount_z
    #define __lwapi_undef__in_ecount_z
    #define __in_ecount_z(size)
#endif
#ifndef __in_bcount_z
    #define __lwapi_undef__in_bcount_z
    #define __in_bcount_z(size)
#endif
#ifndef __in_nz
    #define __lwapi_undef__in_nz
    #define __in_nz
#endif
#ifndef __in_ecount_nz
    #define __lwapi_undef__in_ecount_nz
    #define __in_ecount_nz(size)
#endif
#ifndef __in_bcount_nz
    #define __lwapi_undef__in_bcount_nz
    #define __in_bcount_nz(size)
#endif
#ifndef __out
    #define __lwapi_undef__out
    #define __out
#endif
#ifndef __out_ecount
    #define __lwapi_undef__out_ecount
    #define __out_ecount(size)
#endif
#ifndef __out_bcount
    #define __lwapi_undef__out_bcount
    #define __out_bcount(size)
#endif
#ifndef __out_ecount_part
    #define __lwapi_undef__out_ecount_part
    #define __out_ecount_part(size,length)
#endif
#ifndef __out_bcount_part
    #define __lwapi_undef__out_bcount_part
    #define __out_bcount_part(size,length)
#endif
#ifndef __out_ecount_full
    #define __lwapi_undef__out_ecount_full
    #define __out_ecount_full(size)
#endif
#ifndef __out_bcount_full
    #define __lwapi_undef__out_bcount_full
    #define __out_bcount_full(size)
#endif
#ifndef __out_z
    #define __lwapi_undef__out_z
    #define __out_z
#endif
#ifndef __out_z_opt
    #define __lwapi_undef__out_z_opt
    #define __out_z_opt
#endif
#ifndef __out_ecount_z
    #define __lwapi_undef__out_ecount_z
    #define __out_ecount_z(size)
#endif
#ifndef __out_bcount_z
    #define __lwapi_undef__out_bcount_z
    #define __out_bcount_z(size)
#endif
#ifndef __out_ecount_part_z
    #define __lwapi_undef__out_ecount_part_z
    #define __out_ecount_part_z(size,length)
#endif
#ifndef __out_bcount_part_z
    #define __lwapi_undef__out_bcount_part_z
    #define __out_bcount_part_z(size,length)
#endif
#ifndef __out_ecount_full_z
    #define __lwapi_undef__out_ecount_full_z
    #define __out_ecount_full_z(size)
#endif
#ifndef __out_bcount_full_z
    #define __lwapi_undef__out_bcount_full_z
    #define __out_bcount_full_z(size)
#endif
#ifndef __out_nz
    #define __lwapi_undef__out_nz
    #define __out_nz
#endif
#ifndef __out_nz_opt
    #define __lwapi_undef__out_nz_opt
    #define __out_nz_opt
#endif
#ifndef __out_ecount_nz
    #define __lwapi_undef__out_ecount_nz
    #define __out_ecount_nz(size)
#endif
#ifndef __out_bcount_nz
    #define __lwapi_undef__out_bcount_nz
    #define __out_bcount_nz(size)
#endif
#ifndef __inout
    #define __lwapi_undef__inout
    #define __inout
#endif
#ifndef __inout_ecount
    #define __lwapi_undef__inout_ecount
    #define __inout_ecount(size)
#endif
#ifndef __inout_bcount
    #define __lwapi_undef__inout_bcount
    #define __inout_bcount(size)
#endif
#ifndef __inout_ecount_part
    #define __lwapi_undef__inout_ecount_part
    #define __inout_ecount_part(size,length)
#endif
#ifndef __inout_bcount_part
    #define __lwapi_undef__inout_bcount_part
    #define __inout_bcount_part(size,length)
#endif
#ifndef __inout_ecount_full
    #define __lwapi_undef__inout_ecount_full
    #define __inout_ecount_full(size)
#endif
#ifndef __inout_bcount_full
    #define __lwapi_undef__inout_bcount_full
    #define __inout_bcount_full(size)
#endif
#ifndef __inout_z
    #define __lwapi_undef__inout_z
    #define __inout_z
#endif
#ifndef __inout_ecount_z
    #define __lwapi_undef__inout_ecount_z
    #define __inout_ecount_z(size)
#endif
#ifndef __inout_bcount_z
    #define __lwapi_undef__inout_bcount_z
    #define __inout_bcount_z(size)
#endif
#ifndef __inout_nz
    #define __lwapi_undef__inout_nz
    #define __inout_nz
#endif
#ifndef __inout_ecount_nz
    #define __lwapi_undef__inout_ecount_nz
    #define __inout_ecount_nz(size)
#endif
#ifndef __inout_bcount_nz
    #define __lwapi_undef__inout_bcount_nz
    #define __inout_bcount_nz(size)
#endif
#ifndef __ecount_opt
    #define __lwapi_undef__ecount_opt
    #define __ecount_opt(size)
#endif
#ifndef __bcount_opt
    #define __lwapi_undef__bcount_opt
    #define __bcount_opt(size)
#endif
#ifndef __in_opt
    #define __lwapi_undef__in_opt
    #define __in_opt
#endif
#ifndef __in_ecount_opt
    #define __lwapi_undef__in_ecount_opt
    #define __in_ecount_opt(size)
#endif
#ifndef __in_bcount_opt
    #define __lwapi_undef__in_bcount_opt
    #define __in_bcount_opt(size)
#endif
#ifndef __in_z_opt
    #define __lwapi_undef__in_z_opt
    #define __in_z_opt
#endif
#ifndef __in_ecount_z_opt
    #define __lwapi_undef__in_ecount_z_opt
    #define __in_ecount_z_opt(size)
#endif
#ifndef __in_bcount_z_opt
    #define __lwapi_undef__in_bcount_z_opt
    #define __in_bcount_z_opt(size)
#endif
#ifndef __in_nz_opt
    #define __lwapi_undef__in_nz_opt
    #define __in_nz_opt
#endif
#ifndef __in_ecount_nz_opt
    #define __lwapi_undef__in_ecount_nz_opt
    #define __in_ecount_nz_opt(size)
#endif
#ifndef __in_bcount_nz_opt
    #define __lwapi_undef__in_bcount_nz_opt
    #define __in_bcount_nz_opt(size)
#endif
#ifndef __out_opt
    #define __lwapi_undef__out_opt
    #define __out_opt
#endif
#ifndef __out_ecount_opt
    #define __lwapi_undef__out_ecount_opt
    #define __out_ecount_opt(size)
#endif
#ifndef __out_bcount_opt
    #define __lwapi_undef__out_bcount_opt
    #define __out_bcount_opt(size)
#endif
#ifndef __out_ecount_part_opt
    #define __lwapi_undef__out_ecount_part_opt
    #define __out_ecount_part_opt(size,length)
#endif
#ifndef __out_bcount_part_opt
    #define __lwapi_undef__out_bcount_part_opt
    #define __out_bcount_part_opt(size,length)
#endif
#ifndef __out_ecount_full_opt
    #define __lwapi_undef__out_ecount_full_opt
    #define __out_ecount_full_opt(size)
#endif
#ifndef __out_bcount_full_opt
    #define __lwapi_undef__out_bcount_full_opt
    #define __out_bcount_full_opt(size)
#endif
#ifndef __out_ecount_z_opt
    #define __lwapi_undef__out_ecount_z_opt
    #define __out_ecount_z_opt(size)
#endif
#ifndef __out_bcount_z_opt
    #define __lwapi_undef__out_bcount_z_opt
    #define __out_bcount_z_opt(size)
#endif
#ifndef __out_ecount_part_z_opt
    #define __lwapi_undef__out_ecount_part_z_opt
    #define __out_ecount_part_z_opt(size,length)
#endif
#ifndef __out_bcount_part_z_opt
    #define __lwapi_undef__out_bcount_part_z_opt
    #define __out_bcount_part_z_opt(size,length)
#endif
#ifndef __out_ecount_full_z_opt
    #define __lwapi_undef__out_ecount_full_z_opt
    #define __out_ecount_full_z_opt(size)
#endif
#ifndef __out_bcount_full_z_opt
    #define __lwapi_undef__out_bcount_full_z_opt
    #define __out_bcount_full_z_opt(size)
#endif
#ifndef __out_ecount_nz_opt
    #define __lwapi_undef__out_ecount_nz_opt
    #define __out_ecount_nz_opt(size)
#endif
#ifndef __out_bcount_nz_opt
    #define __lwapi_undef__out_bcount_nz_opt
    #define __out_bcount_nz_opt(size)
#endif
#ifndef __inout_opt
    #define __lwapi_undef__inout_opt
    #define __inout_opt
#endif
#ifndef __inout_ecount_opt
    #define __lwapi_undef__inout_ecount_opt
    #define __inout_ecount_opt(size)
#endif
#ifndef __inout_bcount_opt
    #define __lwapi_undef__inout_bcount_opt
    #define __inout_bcount_opt(size)
#endif
#ifndef __inout_ecount_part_opt
    #define __lwapi_undef__inout_ecount_part_opt
    #define __inout_ecount_part_opt(size,length)
#endif
#ifndef __inout_bcount_part_opt
    #define __lwapi_undef__inout_bcount_part_opt
    #define __inout_bcount_part_opt(size,length)
#endif
#ifndef __inout_ecount_full_opt
    #define __lwapi_undef__inout_ecount_full_opt
    #define __inout_ecount_full_opt(size)
#endif
#ifndef __inout_bcount_full_opt
    #define __lwapi_undef__inout_bcount_full_opt
    #define __inout_bcount_full_opt(size)
#endif
#ifndef __inout_z_opt
    #define __lwapi_undef__inout_z_opt
    #define __inout_z_opt
#endif
#ifndef __inout_ecount_z_opt
    #define __lwapi_undef__inout_ecount_z_opt
    #define __inout_ecount_z_opt(size)
#endif
#ifndef __inout_ecount_z_opt
    #define __lwapi_undef__inout_ecount_z_opt
    #define __inout_ecount_z_opt(size)
#endif
#ifndef __inout_bcount_z_opt
    #define __lwapi_undef__inout_bcount_z_opt
    #define __inout_bcount_z_opt(size)
#endif
#ifndef __inout_nz_opt
    #define __lwapi_undef__inout_nz_opt
    #define __inout_nz_opt
#endif
#ifndef __inout_ecount_nz_opt
    #define __lwapi_undef__inout_ecount_nz_opt
    #define __inout_ecount_nz_opt(size)
#endif
#ifndef __inout_bcount_nz_opt
    #define __lwapi_undef__inout_bcount_nz_opt
    #define __inout_bcount_nz_opt(size)
#endif
#ifndef __deref_ecount
    #define __lwapi_undef__deref_ecount
    #define __deref_ecount(size)
#endif
#ifndef __deref_bcount
    #define __lwapi_undef__deref_bcount
    #define __deref_bcount(size)
#endif
#ifndef __deref_out
    #define __lwapi_undef__deref_out
    #define __deref_out
#endif
#ifndef __deref_out_ecount
    #define __lwapi_undef__deref_out_ecount
    #define __deref_out_ecount(size)
#endif
#ifndef __deref_out_bcount
    #define __lwapi_undef__deref_out_bcount
    #define __deref_out_bcount(size)
#endif
#ifndef __deref_out_ecount_part
    #define __lwapi_undef__deref_out_ecount_part
    #define __deref_out_ecount_part(size,length)
#endif
#ifndef __deref_out_bcount_part
    #define __lwapi_undef__deref_out_bcount_part
    #define __deref_out_bcount_part(size,length)
#endif
#ifndef __deref_out_ecount_full
    #define __lwapi_undef__deref_out_ecount_full
    #define __deref_out_ecount_full(size)
#endif
#ifndef __deref_out_bcount_full
    #define __lwapi_undef__deref_out_bcount_full
    #define __deref_out_bcount_full(size)
#endif
#ifndef __deref_out_z
    #define __lwapi_undef__deref_out_z
    #define __deref_out_z
#endif
#ifndef __deref_out_ecount_z
    #define __lwapi_undef__deref_out_ecount_z
    #define __deref_out_ecount_z(size)
#endif
#ifndef __deref_out_bcount_z
    #define __lwapi_undef__deref_out_bcount_z
    #define __deref_out_bcount_z(size)
#endif
#ifndef __deref_out_nz
    #define __lwapi_undef__deref_out_nz
    #define __deref_out_nz
#endif
#ifndef __deref_out_ecount_nz
    #define __lwapi_undef__deref_out_ecount_nz
    #define __deref_out_ecount_nz(size)
#endif
#ifndef __deref_out_bcount_nz
    #define __lwapi_undef__deref_out_bcount_nz
    #define __deref_out_bcount_nz(size)
#endif
#ifndef __deref_inout
    #define __lwapi_undef__deref_inout
    #define __deref_inout
#endif
#ifndef __deref_inout_z
    #define __lwapi_undef__deref_inout_z
    #define __deref_inout_z
#endif
#ifndef __deref_inout_ecount
    #define __lwapi_undef__deref_inout_ecount
    #define __deref_inout_ecount(size)
#endif
#ifndef __deref_inout_bcount
    #define __lwapi_undef__deref_inout_bcount
    #define __deref_inout_bcount(size)
#endif
#ifndef __deref_inout_ecount_part
    #define __lwapi_undef__deref_inout_ecount_part
    #define __deref_inout_ecount_part(size,length)
#endif
#ifndef __deref_inout_bcount_part
    #define __lwapi_undef__deref_inout_bcount_part
    #define __deref_inout_bcount_part(size,length)
#endif
#ifndef __deref_inout_ecount_full
    #define __lwapi_undef__deref_inout_ecount_full
    #define __deref_inout_ecount_full(size)
#endif
#ifndef __deref_inout_bcount_full
    #define __lwapi_undef__deref_inout_bcount_full
    #define __deref_inout_bcount_full(size)
#endif
#ifndef __deref_inout_z
    #define __lwapi_undef__deref_inout_z
    #define __deref_inout_z
#endif
#ifndef __deref_inout_ecount_z
    #define __lwapi_undef__deref_inout_ecount_z
    #define __deref_inout_ecount_z(size)
#endif
#ifndef __deref_inout_bcount_z
    #define __lwapi_undef__deref_inout_bcount_z
    #define __deref_inout_bcount_z(size)
#endif
#ifndef __deref_inout_nz
    #define __lwapi_undef__deref_inout_nz
    #define __deref_inout_nz
#endif
#ifndef __deref_inout_ecount_nz
    #define __lwapi_undef__deref_inout_ecount_nz
    #define __deref_inout_ecount_nz(size)
#endif
#ifndef __deref_inout_bcount_nz
    #define __lwapi_undef__deref_inout_bcount_nz
    #define __deref_inout_bcount_nz(size)
#endif
#ifndef __deref_ecount_opt
    #define __lwapi_undef__deref_ecount_opt
    #define __deref_ecount_opt(size)
#endif
#ifndef __deref_bcount_opt
    #define __lwapi_undef__deref_bcount_opt
    #define __deref_bcount_opt(size)
#endif
#ifndef __deref_out_opt
    #define __lwapi_undef__deref_out_opt
    #define __deref_out_opt
#endif
#ifndef __deref_out_ecount_opt
    #define __lwapi_undef__deref_out_ecount_opt
    #define __deref_out_ecount_opt(size)
#endif
#ifndef __deref_out_bcount_opt
    #define __lwapi_undef__deref_out_bcount_opt
    #define __deref_out_bcount_opt(size)
#endif
#ifndef __deref_out_ecount_part_opt
    #define __lwapi_undef__deref_out_ecount_part_opt
    #define __deref_out_ecount_part_opt(size,length)
#endif
#ifndef __deref_out_bcount_part_opt
    #define __lwapi_undef__deref_out_bcount_part_opt
    #define __deref_out_bcount_part_opt(size,length)
#endif
#ifndef __deref_out_ecount_full_opt
    #define __lwapi_undef__deref_out_ecount_full_opt
    #define __deref_out_ecount_full_opt(size)
#endif
#ifndef __deref_out_bcount_full_opt
    #define __lwapi_undef__deref_out_bcount_full_opt
    #define __deref_out_bcount_full_opt(size)
#endif
#ifndef __deref_out_z_opt
    #define __lwapi_undef__deref_out_z_opt
    #define __deref_out_z_opt
#endif
#ifndef __deref_out_ecount_z_opt
    #define __lwapi_undef__deref_out_ecount_z_opt
    #define __deref_out_ecount_z_opt(size)
#endif
#ifndef __deref_out_bcount_z_opt
    #define __lwapi_undef__deref_out_bcount_z_opt
    #define __deref_out_bcount_z_opt(size)
#endif
#ifndef __deref_out_nz_opt
    #define __lwapi_undef__deref_out_nz_opt
    #define __deref_out_nz_opt
#endif
#ifndef __deref_out_ecount_nz_opt
    #define __lwapi_undef__deref_out_ecount_nz_opt
    #define __deref_out_ecount_nz_opt(size)
#endif
#ifndef __deref_out_bcount_nz_opt
    #define __lwapi_undef__deref_out_bcount_nz_opt
    #define __deref_out_bcount_nz_opt(size)
#endif
#ifndef __deref_inout_opt
    #define __lwapi_undef__deref_inout_opt
    #define __deref_inout_opt
#endif
#ifndef __deref_inout_ecount_opt
    #define __lwapi_undef__deref_inout_ecount_opt
    #define __deref_inout_ecount_opt(size)
#endif
#ifndef __deref_inout_bcount_opt
    #define __lwapi_undef__deref_inout_bcount_opt
    #define __deref_inout_bcount_opt(size)
#endif
#ifndef __deref_inout_ecount_part_opt
    #define __lwapi_undef__deref_inout_ecount_part_opt
    #define __deref_inout_ecount_part_opt(size,length)
#endif
#ifndef __deref_inout_bcount_part_opt
    #define __lwapi_undef__deref_inout_bcount_part_opt
    #define __deref_inout_bcount_part_opt(size,length)
#endif
#ifndef __deref_inout_ecount_full_opt
    #define __lwapi_undef__deref_inout_ecount_full_opt
    #define __deref_inout_ecount_full_opt(size)
#endif
#ifndef __deref_inout_bcount_full_opt
    #define __lwapi_undef__deref_inout_bcount_full_opt
    #define __deref_inout_bcount_full_opt(size)
#endif
#ifndef __deref_inout_z_opt
    #define __lwapi_undef__deref_inout_z_opt
    #define __deref_inout_z_opt
#endif
#ifndef __deref_inout_ecount_z_opt
    #define __lwapi_undef__deref_inout_ecount_z_opt
    #define __deref_inout_ecount_z_opt(size)
#endif
#ifndef __deref_inout_bcount_z_opt
    #define __lwapi_undef__deref_inout_bcount_z_opt
    #define __deref_inout_bcount_z_opt(size)
#endif
#ifndef __deref_inout_nz_opt
    #define __lwapi_undef__deref_inout_nz_opt
    #define __deref_inout_nz_opt
#endif
#ifndef __deref_inout_ecount_nz_opt
    #define __lwapi_undef__deref_inout_ecount_nz_opt
    #define __deref_inout_ecount_nz_opt(size)
#endif
#ifndef __deref_inout_bcount_nz_opt
    #define __lwapi_undef__deref_inout_bcount_nz_opt
    #define __deref_inout_bcount_nz_opt(size)
#endif
#ifndef __deref_opt_ecount
    #define __lwapi_undef__deref_opt_ecount
    #define __deref_opt_ecount(size)
#endif
#ifndef __deref_opt_bcount
    #define __lwapi_undef__deref_opt_bcount
    #define __deref_opt_bcount(size)
#endif
#ifndef __deref_opt_out
    #define __lwapi_undef__deref_opt_out
    #define __deref_opt_out
#endif
#ifndef __deref_opt_out_z
    #define __lwapi_undef__deref_opt_out_z
    #define __deref_opt_out_z
#endif
#ifndef __deref_opt_out_ecount
    #define __lwapi_undef__deref_opt_out_ecount
    #define __deref_opt_out_ecount(size)
#endif
#ifndef __deref_opt_out_bcount
    #define __lwapi_undef__deref_opt_out_bcount
    #define __deref_opt_out_bcount(size)
#endif
#ifndef __deref_opt_out_ecount_part
    #define __lwapi_undef__deref_opt_out_ecount_part
    #define __deref_opt_out_ecount_part(size,length)
#endif
#ifndef __deref_opt_out_bcount_part
    #define __lwapi_undef__deref_opt_out_bcount_part
    #define __deref_opt_out_bcount_part(size,length)
#endif
#ifndef __deref_opt_out_ecount_full
    #define __lwapi_undef__deref_opt_out_ecount_full
    #define __deref_opt_out_ecount_full(size)
#endif
#ifndef __deref_opt_out_bcount_full
    #define __lwapi_undef__deref_opt_out_bcount_full
    #define __deref_opt_out_bcount_full(size)
#endif
#ifndef __deref_opt_inout
    #define __lwapi_undef__deref_opt_inout
    #define __deref_opt_inout
#endif
#ifndef __deref_opt_inout_ecount
    #define __lwapi_undef__deref_opt_inout_ecount
    #define __deref_opt_inout_ecount(size)
#endif
#ifndef __deref_opt_inout_bcount
    #define __lwapi_undef__deref_opt_inout_bcount
    #define __deref_opt_inout_bcount(size)
#endif
#ifndef __deref_opt_inout_ecount_part
    #define __lwapi_undef__deref_opt_inout_ecount_part
    #define __deref_opt_inout_ecount_part(size,length)
#endif
#ifndef __deref_opt_inout_bcount_part
    #define __lwapi_undef__deref_opt_inout_bcount_part
    #define __deref_opt_inout_bcount_part(size,length)
#endif
#ifndef __deref_opt_inout_ecount_full
    #define __lwapi_undef__deref_opt_inout_ecount_full
    #define __deref_opt_inout_ecount_full(size)
#endif
#ifndef __deref_opt_inout_bcount_full
    #define __lwapi_undef__deref_opt_inout_bcount_full
    #define __deref_opt_inout_bcount_full(size)
#endif
#ifndef __deref_opt_inout_z
    #define __lwapi_undef__deref_opt_inout_z
    #define __deref_opt_inout_z
#endif
#ifndef __deref_opt_inout_ecount_z
    #define __lwapi_undef__deref_opt_inout_ecount_z
    #define __deref_opt_inout_ecount_z(size)
#endif
#ifndef __deref_opt_inout_bcount_z
    #define __lwapi_undef__deref_opt_inout_bcount_z
    #define __deref_opt_inout_bcount_z(size)
#endif
#ifndef __deref_opt_inout_nz
    #define __lwapi_undef__deref_opt_inout_nz
    #define __deref_opt_inout_nz
#endif
#ifndef __deref_opt_inout_ecount_nz
    #define __lwapi_undef__deref_opt_inout_ecount_nz
    #define __deref_opt_inout_ecount_nz(size)
#endif
#ifndef __deref_opt_inout_bcount_nz
    #define __lwapi_undef__deref_opt_inout_bcount_nz
    #define __deref_opt_inout_bcount_nz(size)
#endif
#ifndef __deref_opt_ecount_opt
    #define __lwapi_undef__deref_opt_ecount_opt
    #define __deref_opt_ecount_opt(size)
#endif
#ifndef __deref_opt_bcount_opt
    #define __lwapi_undef__deref_opt_bcount_opt
    #define __deref_opt_bcount_opt(size)
#endif
#ifndef __deref_opt_out_opt
    #define __lwapi_undef__deref_opt_out_opt
    #define __deref_opt_out_opt
#endif
#ifndef __deref_opt_out_ecount_opt
    #define __lwapi_undef__deref_opt_out_ecount_opt
    #define __deref_opt_out_ecount_opt(size)
#endif
#ifndef __deref_opt_out_bcount_opt
    #define __lwapi_undef__deref_opt_out_bcount_opt
    #define __deref_opt_out_bcount_opt(size)
#endif
#ifndef __deref_opt_out_ecount_part_opt
    #define __lwapi_undef__deref_opt_out_ecount_part_opt
    #define __deref_opt_out_ecount_part_opt(size,length)
#endif
#ifndef __deref_opt_out_bcount_part_opt
    #define __lwapi_undef__deref_opt_out_bcount_part_opt
    #define __deref_opt_out_bcount_part_opt(size,length)
#endif
#ifndef __deref_opt_out_ecount_full_opt
    #define __lwapi_undef__deref_opt_out_ecount_full_opt
    #define __deref_opt_out_ecount_full_opt(size)
#endif
#ifndef __deref_opt_out_bcount_full_opt
    #define __lwapi_undef__deref_opt_out_bcount_full_opt
    #define __deref_opt_out_bcount_full_opt(size)
#endif
#ifndef __deref_opt_out_z_opt
    #define __lwapi_undef__deref_opt_out_z_opt
    #define __deref_opt_out_z_opt
#endif
#ifndef __deref_opt_out_ecount_z_opt
    #define __lwapi_undef__deref_opt_out_ecount_z_opt
    #define __deref_opt_out_ecount_z_opt(size)
#endif
#ifndef __deref_opt_out_bcount_z_opt
    #define __lwapi_undef__deref_opt_out_bcount_z_opt
    #define __deref_opt_out_bcount_z_opt(size)
#endif
#ifndef __deref_opt_out_nz_opt
    #define __lwapi_undef__deref_opt_out_nz_opt
    #define __deref_opt_out_nz_opt
#endif
#ifndef __deref_opt_out_ecount_nz_opt
    #define __lwapi_undef__deref_opt_out_ecount_nz_opt
    #define __deref_opt_out_ecount_nz_opt(size)
#endif
#ifndef __deref_opt_out_bcount_nz_opt
    #define __lwapi_undef__deref_opt_out_bcount_nz_opt
    #define __deref_opt_out_bcount_nz_opt(size)
#endif
#ifndef __deref_opt_inout_opt
    #define __lwapi_undef__deref_opt_inout_opt
    #define __deref_opt_inout_opt
#endif
#ifndef __deref_opt_inout_ecount_opt
    #define __lwapi_undef__deref_opt_inout_ecount_opt
    #define __deref_opt_inout_ecount_opt(size)
#endif
#ifndef __deref_opt_inout_bcount_opt
    #define __lwapi_undef__deref_opt_inout_bcount_opt
    #define __deref_opt_inout_bcount_opt(size)
#endif
#ifndef __deref_opt_inout_ecount_part_opt
    #define __lwapi_undef__deref_opt_inout_ecount_part_opt
    #define __deref_opt_inout_ecount_part_opt(size,length)
#endif
#ifndef __deref_opt_inout_bcount_part_opt
    #define __lwapi_undef__deref_opt_inout_bcount_part_opt
    #define __deref_opt_inout_bcount_part_opt(size,length)
#endif
#ifndef __deref_opt_inout_ecount_full_opt
    #define __lwapi_undef__deref_opt_inout_ecount_full_opt
    #define __deref_opt_inout_ecount_full_opt(size)
#endif
#ifndef __deref_opt_inout_bcount_full_opt
    #define __lwapi_undef__deref_opt_inout_bcount_full_opt
    #define __deref_opt_inout_bcount_full_opt(size)
#endif
#ifndef __deref_opt_inout_z_opt
    #define __lwapi_undef__deref_opt_inout_z_opt
    #define __deref_opt_inout_z_opt
#endif
#ifndef __deref_opt_inout_ecount_z_opt
    #define __lwapi_undef__deref_opt_inout_ecount_z_opt
    #define __deref_opt_inout_ecount_z_opt(size)
#endif
#ifndef __deref_opt_inout_bcount_z_opt
    #define __lwapi_undef__deref_opt_inout_bcount_z_opt
    #define __deref_opt_inout_bcount_z_opt(size)
#endif
#ifndef __deref_opt_inout_nz_opt
    #define __lwapi_undef__deref_opt_inout_nz_opt
    #define __deref_opt_inout_nz_opt
#endif
#ifndef __deref_opt_inout_ecount_nz_opt
    #define __lwapi_undef__deref_opt_inout_ecount_nz_opt
    #define __deref_opt_inout_ecount_nz_opt(size)
#endif
#ifndef __deref_opt_inout_bcount_nz_opt
    #define __lwapi_undef__deref_opt_inout_bcount_nz_opt
    #define __deref_opt_inout_bcount_nz_opt(size)
#endif
#ifndef __success
    #define __lwapi_success
    #define __success(epxr)
#endif
#ifndef _Ret_notnull_
    #define __lwapi__Ret_notnull_
    #define _Ret_notnull_
#endif
#ifndef _Post_writable_byte_size_
    #define __lwapi__Post_writable_byte_size_
    #define _Post_writable_byte_size_(n)
#endif
#ifndef _Outptr_ 
    #define __lwapi_Outptr_ 
    #define _Outptr_ 
#endif


#define LWAPI_INTERFACE extern __success(return == LWAPI_OK) LwAPI_Status __cdecl

#if (defined(WIN32) || defined(_WIN32)) && defined(_MSC_VER) && (_MSC_VER > 1399) && !defined(LWAPI_INTERNAL) && !defined(LWAPI_DEPRECATED_OLD)
#ifndef __lwapi_deprecated_function
#define __lwapi_deprecated_function(message) __declspec(deprecated(message))
#endif
#ifndef __lwapi_deprecated_datatype
#define __lwapi_deprecated_datatype(FirstRelease) __declspec(deprecated("Do not use this data type - it is deprecated in release " #FirstRelease "."))
#endif
#else
#ifndef __lwapi_deprecated_function
#define __lwapi_deprecated_function(message)
#endif
#ifndef __lwapi_deprecated_datatype
#define __lwapi_deprecated_datatype(FirstRelease)
#endif
#endif

/* 64-bit types for compilers that support them, plus some obsolete variants */
#if defined(__GNUC__) || defined(__arm) || defined(__IAR_SYSTEMS_ICC__) || defined(__ghs__) || defined(_WIN64)
typedef unsigned long long LwU64; /* 0 to 18446744073709551615  */
typedef long long          LwS64; /* -9223372036854775808 to 9223372036854775807  */
#else
typedef unsigned __int64   LwU64; /* 0 to 18446744073709551615  */
typedef __int64            LwS64; /* -9223372036854775808 to 9223372036854775807  */
#endif

// mac os 32-bit still needs this
#if (defined(macintosh) || defined(__APPLE__)) && !defined(__LP64__)
typedef signed long        LwS32; /* -2147483648 to 2147483647  */   
#else
typedef signed int         LwS32; /* -2147483648 to 2147483647 */  
#endif

// mac os 32-bit still needs this
#if ( (defined(macintosh) && defined(__LP64__) && (__LWAPI_RESERVED0__)) || \
      (!defined(macintosh) && defined(__LWAPI_RESERVED0__)) ) 
typedef unsigned int       LwU32; /* 0 to 4294967295                         */
#else
typedef unsigned long      LwU32; /* 0 to 4294967295                         */
#endif

typedef signed   short   LwS16;
typedef unsigned short   LwU16;
typedef unsigned char    LwU8;
typedef signed   char    LwS8;

typedef struct _LW_RECT
{
    LwU32    left;
    LwU32    top;
    LwU32    right;
    LwU32    bottom;
} LW_RECT;



#define LW_DECLARE_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name

//! \addtogroup lwapihandles
//! LWAPI Handles - These handles are retrieved from various calls and passed in to others in LwAPI
//!                 These are meant to be opaque types.  Do not assume they correspond to indices, HDCs,
//!                 display indexes or anything else.
//!
//!                 Most handles remain valid until a display re-configuration (display mode set) or GPU
//!                 reconfiguration (going into or out of SLI modes) oclwrs.  If LWAPI_HANDLE_ILWALIDATED
//!                 is received by an app, it should discard all handles, and re-enumerate them.
//! @{  
LW_DECLARE_HANDLE(LwDisplayHandle);                //!< Display Device driven by LWPU GPU(s) (an attached display)
LW_DECLARE_HANDLE(LwMonitorHandle);                //!< Monitor handle
LW_DECLARE_HANDLE(LwUnAttachedDisplayHandle);      //!< Unattached Display Device driven by LWPU GPU(s)
LW_DECLARE_HANDLE(LwLogicalGpuHandle);             //!< One or more physical GPUs acting in concert (SLI)
LW_DECLARE_HANDLE(LwPhysicalGpuHandle);            //!< A single physical GPU
LW_DECLARE_HANDLE(LwEventHandle);                  //!< A handle to an event registration instance
LW_DECLARE_HANDLE(LwVisualComputingDeviceHandle);  //!< A handle to a Visual Computing Device
LW_DECLARE_HANDLE(LwHICHandle);                    //!< A handle to a Host Interface Card
LW_DECLARE_HANDLE(LwGSyncDeviceHandle);            //!< A handle to a Sync device
LW_DECLARE_HANDLE(LwVioHandle);                    //!< A handle to an SDI device
LW_DECLARE_HANDLE(LwTransitionHandle);             //!< A handle to address a single transition request
LW_DECLARE_HANDLE(LwAudioHandle);                  //!< LWPU HD Audio Device
LW_DECLARE_HANDLE(Lw3DVPContextHandle);            //!< A handle for a 3D Vision Pro (3DVP) context
LW_DECLARE_HANDLE(Lw3DVPTransceiverHandle);        //!< A handle for a 3DVP RF transceiver
LW_DECLARE_HANDLE(Lw3DVPGlassesHandle);            //!< A handle for a pair of 3DVP RF shutter glasses

typedef void* StereoHandle;                        //!< A stereo handle, that corresponds to the device interface

LW_DECLARE_HANDLE(LwSourceHandle);                 //!< Unique source handle on the system
LW_DECLARE_HANDLE(LwTargetHandle);                 //!< Unique target handle on the system
LW_DECLARE_HANDLE(LWDX_SwapChainHandle);           //!< DirectX SwapChain objects
static const LWDX_SwapChainHandle LWDX_SWAPCHAIN_NONE = 0;
//! @}

//! \ingroup lwapihandles
//! @{
#define LWAPI_DEFAULT_HANDLE        0
#define LW_BIT(x)    (1 << (x)) 
//! @}


//! \ingroup lwapihandles
#define LWAPI_COPROC_DISPLAY_HANDLE  ((LwDisplayHandle) 0xde800001)       //!< Display handle + special handle (0x00800000) + index 1




//! \addtogroup lwapitypes
//! @{
#define LWAPI_GENERIC_STRING_MAX    4096
#define LWAPI_LONG_STRING_MAX       256
#define LWAPI_SHORT_STRING_MAX      64


typedef struct 
{
    LwS32   sX;
    LwS32   sY;
    LwS32   sWidth;
    LwS32   sHeight;
} LwSBox;

#ifndef LwGUID_Defined
#define LwGUID_Defined

typedef struct
{
    LwU32 data1;
    LwU16 data2;
    LwU16 data3;
    LwU8  data4[8];
} LwGUID, LwLUID;

#endif //#ifndef LwGUID_Defined


#define LWAPI_MAX_PHYSICAL_GPUS             64
#define LWAPI_MAX_PHYSICAL_BRIDGES          100
#define LWAPI_PHYSICAL_GPUS                 32
#define LWAPI_MAX_LOGICAL_GPUS              64
#define LWAPI_MAX_AVAILABLE_GPU_TOPOLOGIES  256
#define LWAPI_MAX_AVAILABLE_SLI_GROUPS      256
#define LWAPI_MAX_GPU_TOPOLOGIES            LWAPI_MAX_PHYSICAL_GPUS
#define LWAPI_MAX_GPU_PER_TOPOLOGY          8
#define LWAPI_MAX_DISPLAY_HEADS             2
#define LWAPI_ADVANCED_DISPLAY_HEADS        4
#define LWAPI_MAX_DISPLAYS                  LWAPI_PHYSICAL_GPUS * LWAPI_ADVANCED_DISPLAY_HEADS
#define LWAPI_MAX_ACPI_IDS                  16
#define LWAPI_MAX_VIEW_MODES                8
#define LW_MAX_HEADS                        4   //!< Maximum heads, each with LWAPI_DESKTOP_RES resolution
#define LWAPI_MAX_HEADS_PER_GPU             32

#define LW_MAX_HEADS        4   //!< Maximum number of heads, each with #LWAPI_DESKTOP_RES resolution
#define LW_MAX_VID_STREAMS  4   //!< Maximum number of input video streams, each with a #LWAPI_VIDEO_SRC_INFO
#define LW_MAX_VID_PROFILES 4   //!< Maximum number of output video profiles supported

#define LWAPI_SYSTEM_MAX_DISPLAYS           LWAPI_MAX_PHYSICAL_GPUS * LW_MAX_HEADS

#define LWAPI_SYSTEM_MAX_HWBCS              128
#define LWAPI_SYSTEM_HWBC_ILWALID_ID        0xffffffff
#define LWAPI_MAX_AUDIO_DEVICES             16


typedef char LwAPI_String[LWAPI_GENERIC_STRING_MAX];
typedef char LwAPI_LongString[LWAPI_LONG_STRING_MAX];
typedef char LwAPI_ShortString[LWAPI_SHORT_STRING_MAX];
//! @}


// =========================================================================================
//!  LwAPI Version Definition \n
//!  Maintain per structure specific version define using the MAKE_LWAPI_VERSION macro. \n
//!  Usage: #define LW_GENLOCK_STATUS_VER  MAKE_LWAPI_VERSION(LW_GENLOCK_STATUS, 1)
//!  \ingroup lwapitypes
// =========================================================================================
#define MAKE_LWAPI_VERSION(typeName,ver) (LwU32)(sizeof(typeName) | ((ver)<<16))

//!  \ingroup lwapitypes
#define GET_LWAPI_VERSION(ver) (LwU32)((ver)>>16)

//!  \ingroup lwapitypes
#define GET_LWAPI_SIZE(ver) (LwU32)((ver) & 0xffff)


// ====================================================
//! LwAPI Status Values
//!   All LwAPI functions return one of these codes.
//!   \ingroup lwapistatus 
// ====================================================


typedef enum _LwAPI_Status
{
    LWAPI_OK                                    =  0,      //!< Success. Request is completed.
    LWAPI_ERROR                                 = -1,      //!< Generic error
    LWAPI_LIBRARY_NOT_FOUND                     = -2,      //!< LWAPI support library cannot be loaded.
    LWAPI_NO_IMPLEMENTATION                     = -3,      //!< not implemented in current driver installation
    LWAPI_API_NOT_INITIALIZED                   = -4,      //!< LwAPI_Initialize has not been called (successfully)
    LWAPI_ILWALID_ARGUMENT                      = -5,      //!< The argument/parameter value is not valid or NULL.
    LWAPI_LWIDIA_DEVICE_NOT_FOUND               = -6,      //!< No LWPU display driver, or LWPU GPU driving a display, was found.
    LWAPI_END_ENUMERATION                       = -7,      //!< No more items to enumerate
    LWAPI_ILWALID_HANDLE                        = -8,      //!< Invalid handle
    LWAPI_INCOMPATIBLE_STRUCT_VERSION           = -9,      //!< An argument's structure version is not supported
    LWAPI_HANDLE_ILWALIDATED                    = -10,     //!< The handle is no longer valid (likely due to GPU or display re-configuration)
    LWAPI_OPENGL_CONTEXT_NOT_LWRRENT            = -11,     //!< No LWPU OpenGL context is current (but needs to be)
    LWAPI_ILWALID_POINTER                       = -14,     //!< An invalid pointer, usually NULL, was passed as a parameter
    LWAPI_NO_GL_EXPERT                          = -12,     //!< OpenGL Expert is not supported by the current drivers
    LWAPI_INSTRUMENTATION_DISABLED              = -13,     //!< OpenGL Expert is supported, but driver instrumentation is lwrrently disabled
    LWAPI_NO_GL_NSIGHT                          = -15,     //!< OpenGL does not support Nsight

    LWAPI_EXPECTED_LOGICAL_GPU_HANDLE           = -100,    //!< Expected a logical GPU handle for one or more parameters
    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE          = -101,    //!< Expected a physical GPU handle for one or more parameters
    LWAPI_EXPECTED_DISPLAY_HANDLE               = -102,    //!< Expected an LW display handle for one or more parameters
    LWAPI_ILWALID_COMBINATION                   = -103,    //!< The combination of parameters is not valid. 
    LWAPI_NOT_SUPPORTED                         = -104,    //!< Requested feature is not supported in the selected GPU
    LWAPI_PORTID_NOT_FOUND                      = -105,    //!< No port ID was found for the I2C transaction
    LWAPI_EXPECTED_UNATTACHED_DISPLAY_HANDLE    = -106,    //!< Expected an unattached display handle as one of the input parameters.
    LWAPI_ILWALID_PERF_LEVEL                    = -107,    //!< Invalid perf level 
    LWAPI_DEVICE_BUSY                           = -108,    //!< Device is busy; request not fulfilled
    LWAPI_LW_PERSIST_FILE_NOT_FOUND             = -109,    //!< LW persist file is not found
    LWAPI_PERSIST_DATA_NOT_FOUND                = -110,    //!< LW persist data is not found
    LWAPI_EXPECTED_TV_DISPLAY                   = -111,    //!< Expected a TV output display
    LWAPI_EXPECTED_TV_DISPLAY_ON_DCONNECTOR     = -112,    //!< Expected a TV output on the D Connector - HDTV_EIAJ4120.
    LWAPI_NO_ACTIVE_SLI_TOPOLOGY                = -113,    //!< SLI is not active on this device.
    LWAPI_SLI_RENDERING_MODE_NOTALLOWED         = -114,    //!< Setup of SLI rendering mode is not possible right now.
    LWAPI_EXPECTED_DIGITAL_FLAT_PANEL           = -115,    //!< Expected a digital flat panel.
    LWAPI_ARGUMENT_EXCEED_MAX_SIZE              = -116,    //!< Argument exceeds the expected size.
    LWAPI_DEVICE_SWITCHING_NOT_ALLOWED          = -117,    //!< Inhibit is ON due to one of the flags in LW_GPU_DISPLAY_CHANGE_INHIBIT or SLI active.
    LWAPI_TESTING_CLOCKS_NOT_SUPPORTED          = -118,    //!< Testing of clocks is not supported.
    LWAPI_UNKNOWN_UNDERSCAN_CONFIG              = -119,    //!< The specified underscan config is from an unknown source (e.g. INF)
    LWAPI_TIMEOUT_RECONFIGURING_GPU_TOPO        = -120,    //!< Timeout while reconfiguring GPUs
    LWAPI_DATA_NOT_FOUND                        = -121,    //!< Requested data was not found
    LWAPI_EXPECTED_ANALOG_DISPLAY               = -122,    //!< Expected an analog display
    LWAPI_NO_VIDLINK                            = -123,    //!< No SLI video bridge is present
    LWAPI_REQUIRES_REBOOT                       = -124,    //!< LWAPI requires a reboot for the settings to take effect
    LWAPI_ILWALID_HYBRID_MODE                   = -125,    //!< The function is not supported with the current Hybrid mode.
    LWAPI_MIXED_TARGET_TYPES                    = -126,    //!< The target types are not all the same
    LWAPI_SYSWOW64_NOT_SUPPORTED                = -127,    //!< The function is not supported from 32-bit on a 64-bit system.
    LWAPI_IMPLICIT_SET_GPU_TOPOLOGY_CHANGE_NOT_ALLOWED = -128,    //!< There is no implicit GPU topology active. Use LWAPI_SetHybridMode to change topology.
    LWAPI_REQUEST_USER_TO_CLOSE_NON_MIGRATABLE_APPS = -129,      //!< Prompt the user to close all non-migratable applications.    
    LWAPI_OUT_OF_MEMORY                         = -130,    //!< Could not allocate sufficient memory to complete the call.
    LWAPI_WAS_STILL_DRAWING                     = -131,    //!< The previous operation that is transferring information to or from this surface is incomplete.
    LWAPI_FILE_NOT_FOUND                        = -132,    //!< The file was not found.
    LWAPI_TOO_MANY_UNIQUE_STATE_OBJECTS         = -133,    //!< There are too many unique instances of a particular type of state object.
    LWAPI_ILWALID_CALL                          = -134,    //!< The method call is invalid. For example, a method's parameter may not be a valid pointer.
    LWAPI_D3D10_1_LIBRARY_NOT_FOUND             = -135,    //!< d3d10_1.dll cannot be loaded.
    LWAPI_FUNCTION_NOT_FOUND                    = -136,    //!< Couldn't find the function in the loaded DLL.
    LWAPI_ILWALID_USER_PRIVILEGE                = -137,    //!< Current User is not Admin.
    LWAPI_EXPECTED_NON_PRIMARY_DISPLAY_HANDLE   = -138,    //!< The handle corresponds to GDIPrimary.
    LWAPI_EXPECTED_COMPUTE_GPU_HANDLE           = -139,    //!< Setting Physx GPU requires that the GPU is compute-capable.
    LWAPI_STEREO_NOT_INITIALIZED                = -140,    //!< The Stereo part of LWAPI failed to initialize completely. Check if the stereo driver is installed.
    LWAPI_STEREO_REGISTRY_ACCESS_FAILED         = -141,    //!< Access to stereo-related registry keys or values has failed.
    LWAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED = -142, //!< The given registry profile type is not supported.
    LWAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED   = -143,    //!< The given registry value is not supported.
    LWAPI_STEREO_NOT_ENABLED                    = -144,    //!< Stereo is not enabled and the function needed it to execute completely.
    LWAPI_STEREO_NOT_TURNED_ON                  = -145,    //!< Stereo is not turned on and the function needed it to execute completely.
    LWAPI_STEREO_ILWALID_DEVICE_INTERFACE       = -146,    //!< Invalid device interface.
    LWAPI_STEREO_PARAMETER_OUT_OF_RANGE         = -147,    //!< Separation percentage or JPEG image capture quality is out of [0-100] range.
    LWAPI_STEREO_FRUSTUM_ADJUST_MODE_NOT_SUPPORTED = -148, //!< The given frustum adjust mode is not supported.
    LWAPI_TOPO_NOT_POSSIBLE                     = -149,    //!< The mosaic topology is not possible given the current state of the hardware.
    LWAPI_MODE_CHANGE_FAILED                    = -150,    //!< An attempt to do a display resolution mode change has failed.        
    LWAPI_D3D11_LIBRARY_NOT_FOUND               = -151,    //!< d3d11.dll/d3d11_beta.dll cannot be loaded.
    LWAPI_ILWALID_ADDRESS                       = -152,    //!< Address is outside of valid range.
    LWAPI_STRING_TOO_SMALL                      = -153,    //!< The pre-allocated string is too small to hold the result.
    LWAPI_MATCHING_DEVICE_NOT_FOUND             = -154,    //!< The input does not match any of the available devices.
    LWAPI_DRIVER_RUNNING                        = -155,    //!< Driver is running.
    LWAPI_DRIVER_NOTRUNNING                     = -156,    //!< Driver is not running.
    LWAPI_ERROR_DRIVER_RELOAD_REQUIRED          = -157,    //!< A driver reload is required to apply these settings.
    LWAPI_SET_NOT_ALLOWED                       = -158,    //!< Intended setting is not allowed.
    LWAPI_ADVANCED_DISPLAY_TOPOLOGY_REQUIRED    = -159,    //!< Information can't be returned due to "advanced display topology".
    LWAPI_SETTING_NOT_FOUND                     = -160,    //!< Setting is not found.
    LWAPI_SETTING_SIZE_TOO_LARGE                = -161,    //!< Setting size is too large.
    LWAPI_TOO_MANY_SETTINGS_IN_PROFILE          = -162,    //!< There are too many settings for a profile. 
    LWAPI_PROFILE_NOT_FOUND                     = -163,    //!< Profile is not found.
    LWAPI_PROFILE_NAME_IN_USE                   = -164,    //!< Profile name is duplicated.
    LWAPI_PROFILE_NAME_EMPTY                    = -165,    //!< Profile name is empty.
    LWAPI_EXELWTABLE_NOT_FOUND                  = -166,    //!< Application not found in the Profile.
    LWAPI_EXELWTABLE_ALREADY_IN_USE             = -167,    //!< Application already exists in the other profile.
    LWAPI_DATATYPE_MISMATCH                     = -168,    //!< Data Type mismatch 
    LWAPI_PROFILE_REMOVED                       = -169,    //!< The profile passed as parameter has been removed and is no longer valid.
    LWAPI_UNREGISTERED_RESOURCE                 = -170,    //!< An unregistered resource was passed as a parameter. 
    LWAPI_ID_OUT_OF_RANGE                       = -171,    //!< The DisplayId corresponds to a display which is not within the normal outputId range.
    LWAPI_DISPLAYCONFIG_VALIDATION_FAILED       = -172,    //!< Display topology is not valid so the driver cannot do a mode set on this configuration.
    LWAPI_DPMST_CHANGED                         = -173,    //!< Display Port Multi-Stream topology has been changed.
    LWAPI_INSUFFICIENT_BUFFER                   = -174,    //!< Input buffer is insufficient to hold the contents.    
    LWAPI_ACCESS_DENIED                         = -175,    //!< No access to the caller.
    LWAPI_MOSAIC_NOT_ACTIVE                     = -176,    //!< The requested action cannot be performed without Mosaic being enabled.
    LWAPI_SHARE_RESOURCE_RELOCATED              = -177,    //!< The surface is relocated away from video memory.
    LWAPI_REQUEST_USER_TO_DISABLE_DWM           = -178,    //!< The user should disable DWM before calling LwAPI.
    LWAPI_D3D_DEVICE_LOST                       = -179,    //!< D3D device status is D3DERR_DEVICELOST or D3DERR_DEVICENOTRESET - the user has to reset the device.
    LWAPI_ILWALID_CONFIGURATION                 = -180,    //!< The requested action cannot be performed in the current state.
    LWAPI_STEREO_HANDSHAKE_NOT_DONE             = -181,    //!< Call failed as stereo handshake not completed.
    LWAPI_EXELWTABLE_PATH_IS_AMBIGUOUS          = -182,    //!< The path provided was too short to determine the correct LWDRS_APPLICATION
    LWAPI_DEFAULT_STEREO_PROFILE_IS_NOT_DEFINED = -183,    //!< Default stereo profile is not lwrrently defined
    LWAPI_DEFAULT_STEREO_PROFILE_DOES_NOT_EXIST = -184,    //!< Default stereo profile does not exist
    LWAPI_CLUSTER_ALREADY_EXISTS                = -185,    //!< A cluster is already defined with the given configuration.
    LWAPI_DPMST_DISPLAY_ID_EXPECTED             = -186,    //!< The input display id is not that of a multi stream enabled connector or a display device in a multi stream topology 
    LWAPI_ILWALID_DISPLAY_ID                    = -187,    //!< The input display id is not valid or the monitor associated to it does not support the current operation
    LWAPI_STREAM_IS_OUT_OF_SYNC                 = -188,    //!< While playing secure audio stream, stream goes out of sync
    LWAPI_INCOMPATIBLE_AUDIO_DRIVER             = -189,    //!< Older audio driver version than required
    LWAPI_VALUE_ALREADY_SET                     = -190,    //!< Value already set, setting again not allowed.
    LWAPI_TIMEOUT                               = -191,    //!< Requested operation timed out 
    LWAPI_GPU_WORKSTATION_FEATURE_INCOMPLETE    = -192,    //!< The requested workstation feature set has incomplete driver internal allocation resources
    LWAPI_STEREO_INIT_ACTIVATION_NOT_DONE       = -193,    //!< Call failed because InitActivation was not called.
    LWAPI_SYNC_NOT_ACTIVE                       = -194,    //!< The requested action cannot be performed without Sync being enabled.
    LWAPI_SYNC_MASTER_NOT_FOUND                 = -195,    //!< The requested action cannot be performed without Sync Master being enabled.
    LWAPI_ILWALID_SYNC_TOPOLOGY                 = -196,    //!< Invalid displays passed in the LW_GSYNC_DISPLAY pointer.
} LwAPI_Status;


//! @}

//!   \ingroup lwapistatus 
#define LWAPI_API_NOT_INTIALIZED        LWAPI_API_NOT_INITIALIZED       //!< Fix typo in error code

//!   \ingroup lwapistatus 
#define LWAPI_ILWALID_USER_PRIVILEDGE   LWAPI_ILWALID_USER_PRIVILEGE    //!< Fix typo in error code


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Initialize
//
//! This function initializes the LwAPI library. 
//! This must be called before calling other LwAPI_ functions. 
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 80
//!
//! \retval  LWAPI_ERROR            An error oclwrred during the initialization process (generic error)
//! \retval  LWAPI_LIBRARYNOTFOUND  Failed to load the LWAPI support library
//! \retval  LWAPI_OK               Initialized
//! \sa lwapistatus
//! \ingroup lwapifunctions
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Initialize();


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Unload
//
//!   DESCRIPTION: Unloads LWAPI library. This must be the last function called. 
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//!  !! This is not thread safe. In a multithreaded environment, calling LwAPI_Unload       !! \n
//!  !! while another thread is exelwting another LwAPI_XXX function, results in           !!  \n
//!  !! undefined behaviour and might even cause the application to crash. Developers       !! \n
//!  !! must make sure that they are not in any other function before calling LwAPI_Unload. !! \n
//!
//!
//!  Unloading LwAPI library is not supported when the library is in a resource locked state.
//!  Some functions in the LwAPI library initiates an operation or allocates certain resources
//!  and there are corresponding functions available, to complete the operation or free the
//!  allocated resources. All such function pairs are designed to prevent unloading LwAPI library.
//!
//!  For example, if LwAPI_Unload is called after LwAPI_XXX which locks a resource, it fails with
//!  LWAPI_ERROR. Developers need to call the corresponding LwAPI_YYY to unlock the resources, 
//!  before calling LwAPI_Unload again.
//!
//! \retval ::LWAPI_ERROR            One or more resources are locked and hence cannot unload LWAPI library
//! \retval ::LWAPI_OK               LWAPI library unloaded
//!
//! \ingroup lwapifunctions
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Unload();

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetErrorMessage
//
//! This function colwerts an LwAPI error code into a null terminated string.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 80
//!
//! \param nr      The error code to colwert
//! \param szDesc  The string corresponding to the error code
//!
//! \return NULL terminated string (always, never NULL)
//! \ingroup lwapifunctions
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetErrorMessage(LwAPI_Status nr,LwAPI_ShortString szDesc);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetInterfaceVersionString
//
//! This function returns a string describing the version of the LwAPI library.
//!               The contents of the string are human readable.  Do not assume a fixed
//!                format.
//!
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 80
//!
//! \param  szDesc User readable string giving LwAPI version information
//!
//! \return See \ref lwapistatus for the list of possible return values.
//! \ingroup lwapifunctions
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetInterfaceVersionString(LwAPI_ShortString szDesc);


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//              All display port related data types definition starts
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// This category is intentionally added before the #ifdef. The #endif should also be in the same scope
#ifndef DISPLAYPORT_STRUCTS_DEFINED
#define DISPLAYPORT_STRUCTS_DEFINED

//! \ingroup dispcontrol
//! Used in LW_DISPLAY_PORT_INFO.
typedef enum _LW_DP_LINK_RATE
{
    LW_DP_1_62GBPS            = 6,
    LW_DP_2_70GBPS            = 0xA,
    LW_DP_5_40GBPS            = 0x14
} LW_DP_LINK_RATE;


//! \ingroup dispcontrol
//! Used in LW_DISPLAY_PORT_INFO.
typedef enum _LW_DP_LANE_COUNT
{
    LW_DP_1_LANE              = 1,
    LW_DP_2_LANE              = 2,
    LW_DP_4_LANE              = 4,
} LW_DP_LANE_COUNT;


//! \ingroup dispcontrol
//! Used in LW_DISPLAY_PORT_INFO.
typedef enum _LW_DP_COLOR_FORMAT
{
    LW_DP_COLOR_FORMAT_RGB     = 0,
    LW_DP_COLOR_FORMAT_YCbCr422,
    LW_DP_COLOR_FORMAT_YCbCr444,
} LW_DP_COLOR_FORMAT;


//! \ingroup dispcontrol
//! Used in LW_DISPLAY_PORT_INFO.
typedef enum _LW_DP_COLORIMETRY
{
    LW_DP_COLORIMETRY_RGB     = 0,
    LW_DP_COLORIMETRY_YCbCr_ITU601,
    LW_DP_COLORIMETRY_YCbCr_ITU709,
} LW_DP_COLORIMETRY;


//! \ingroup dispcontrol
//! Used in LW_DISPLAY_PORT_INFO.
typedef enum _LW_DP_DYNAMIC_RANGE
{
    LW_DP_DYNAMIC_RANGE_VESA  = 0,
    LW_DP_DYNAMIC_RANGE_CEA,
} LW_DP_DYNAMIC_RANGE;


//! \ingroup dispcontrol
//! Used in LW_DISPLAY_PORT_INFO.
typedef enum _LW_DP_BPC
{
    LW_DP_BPC_DEFAULT         = 0,
    LW_DP_BPC_6,
    LW_DP_BPC_8,
    LW_DP_BPC_10,
    LW_DP_BPC_12,
    LW_DP_BPC_16,
} LW_DP_BPC;


//! Do not use the following two constants directly in the code. These will be removed.
#define LW_DP_MAX_TOPOLOGY_NODES       128
#define LW_DP_MAX_HDCP_ADDRESS_HOPS    7

#define LW_DP_MAX_ADDRESS_HOPS         15

typedef struct _LW_DP_ADDRESS
{
    LwU32 hopCount;
    LwU32 hop[LW_DP_MAX_ADDRESS_HOPS];
} LW_DP_ADDRESS;

typedef enum _LW_DP_NODE_TYPE
{
    LW_DP_NODE_TYPE_UNKNOWN                  = -1,//!< Unknown type indicates an error condition, like unable to read the monitor type 
    LW_DP_NODE_TYPE_DP                       = 0, //!< Root DP to DP
    LW_DP_NODE_TYPE_HDMI                     = 1, //!< Root DP to HDMI
    LW_DP_NODE_TYPE_DVI                      = 2, //!< Root DP to DVI
    LW_DP_NODE_TYPE_VGA                      = 3, //!< Root DP to VGA
} LW_DP_NODE_TYPE;


typedef struct
{
    LwU64  isOsVisible          : 1;    //!< this node is exposed to OS (a connected device may not be exposed to OS)
    LwU64  isStreamCloned       : 1;    //!< this node is one of the stream cloned device
    // Add DD flags here
    LwU64  reservedDD           : 30;   //!< must be 0

    LwU64  isMultistream        : 1;    //!< is set if sink supports multistream
    LwU64  isVideoSink          : 1;    //!< is set if the address represents a video sink
    LwU64  isAudioSink          : 1;    //!< is set if the address represents an audio sink
    LwU64  isLoop               : 1;    //!< is set if the last hop causes a loop. Recommendation
                                        //!< is to ask the user to remove the cable represented by the last hop.
    LwU64  isRedundant          : 1;    //!< similar to isLoop except the connection causes redundant pathways
                                        //!< to other devices. Last hop represents the connection to cut.
    LwU64  isMustDisconnect     : 1;    //!< is set if DD disconnected device and requires lwsvc to do a modeset
    LwU64  isZombie             : 1;    //!< is set if DD disconnected device
    LwU64  isCableOk            : 1;    //!< is set if something wrong with cable
    LwU64  isPowerSuspended     : 1;    //!< is set if DPCD 0x600 is suspend state
    LwU64  isActive             : 1;    //!< is set if the device has a head attached to it
    LwU64  isHdcpCapable        : 1;    //!< is set if the device is HDCP capable
    LwU64  isPathHdcpCapable    : 1;    //!< is set if the path leading to this device is HDCP capable
    LwU64  isHdcpActive         : 1;    //!< is set if HDCP is active on the device
    LwU64  isRevoked            : 1;    //!< is set if the device is revoked

    // Add DP Library flags here
    LwU64  reservedLibrary      : 18; //!< must be 0
} LW_DP_NODE_FLAGS;

//! Used in LwAPI_GPU_QueryDpTopology
//!
//! Interpreting LW_DP_BRANCH_DEVICE_PORTS_INFO
//!
//! If the bit corresponding to the port number in the aux address is high in the internalPortsMask, then the current device is internally connected to the branch device. 
//! For example, if you had an address 0.8 for a sink A with a branch B preceding it, and B's inputPortsMask has the 8th bit set, 
//! then A is connected to the internal port of B since 8 is the number of the output port of B to which A is connected.
typedef struct _LW_DP_BRANCH_DEVICE_PORTS_INFO
{
    LwU16                   validPortsMask;       //!< port i is valid, when bit i in this mask is high 
    LwU16                   inputPortsMask;       //!< port i is an input port, when bit i is high && validPortsMask bit i is high 
    LwU16                   internalPortsMask;    //!< port i is an internal port, when bit i is high && validPortsMask bit i is high
} LW_DP_BRANCH_DEVICE_PORTS_INFO;

typedef struct _LW_DP_NODE_INFO
{
     LwU32                              version;                //!< Only element 0 must be properly set
     LwU32                              displayId;              //!< Valid for sinks only, this is a unique identifier for each sink device
     LW_DP_BRANCH_DEVICE_PORTS_INFO     branchDevicePortsInfo;  //!< The information about the ports on the branch device
     LW_DP_ADDRESS                      auxAddress;             //!< The aux address of the given node.
     LwGUID                             guid;                   //!< This GUID is populated for all devices.
                                                                //!< For sinks, it is the GUID of the previous branch device
                                                                //!< For branch devices, it is the GUID of the branch device.
     LW_DP_NODE_FLAGS                   flags;                  //!< One or more flag values from LW_DP_NODE_FLAGS.
     LW_DP_NODE_TYPE                    nodeType;               //!< Node type from LW_DP_NODE_TYPE
} LW_DP_NODE_INFO;

#define LW_DP_NODE_INFO_VER          MAKE_LWAPI_VERSION(LW_DP_NODE_INFO,1)

// This category tag is intentionally added before the #endif. The corresponding #ifdef above should also be in the same scope
#endif  //#ifndef DISPLAYPORT_STRUCTS_DEFINED

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//              All display port related data types definitions end
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetEDID
//
//! \fn LwAPI_GPU_GetEDID(LwPhysicalGpuHandle hPhysicalGpu, LwU32 displayOutputId, LW_EDID *pEDID)
//!  This function returns the EDID data for the specified GPU handle and connection bit mask.
//!  displayOutputId should have exactly 1 bit set to indicate a single display. See \ref handles.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 85
//!
//! \retval    LWAPI_ILWALID_ARGUMENT              pEDID is NULL; displayOutputId has 0 or > 1 bits set
//! \retval    LWAPI_OK                           *pEDID contains valid data.
//! \retval    LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//! \retval    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \retval    LWAPI_DATA_NOT_FOUND                The requested display does not contain an EDID.
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup gpu
//! @{

#define LW_EDID_V1_DATA_SIZE   256

#define LW_EDID_DATA_SIZE      LW_EDID_V1_DATA_SIZE

typedef struct
{
    LwU32   version;        //structure version
    LwU8    EDID_Data[LW_EDID_DATA_SIZE];
} LW_EDID_V1;

//! Used in LwAPI_GPU_GetEDID()
typedef struct
{
    LwU32   version;        //!< Structure version
    LwU8    EDID_Data[LW_EDID_DATA_SIZE];
    LwU32   sizeofEDID;
} LW_EDID_V2;

//! Used in LwAPI_GPU_GetEDID()
typedef struct
{
    LwU32   version;        //!< Structure version
    LwU8    EDID_Data[LW_EDID_DATA_SIZE];
    LwU32   sizeofEDID;
    LwU32   edidId;     //!< ID which always returned in a monotonically increasing counter.
                       //!< Across a split-EDID read we need to verify that all calls returned the same edidId.
                       //!< This counter is incremented if we get the updated EDID. 
    LwU32   offset;    //!< Which 256-byte page of the EDID we want to read. Start at 0.
                       //!< If the read succeeds with edidSize > LW_EDID_DATA_SIZE,
                       //!< call back again with offset+256 until we have read the entire buffer
} LW_EDID_V3;

typedef LW_EDID_V3    LW_EDID;

#define LW_EDID_VER1    MAKE_LWAPI_VERSION(LW_EDID_V1,1)
#define LW_EDID_VER2    MAKE_LWAPI_VERSION(LW_EDID_V2,2)
#define LW_EDID_VER3    MAKE_LWAPI_VERSION(LW_EDID_V3,3)
#define LW_EDID_VER   LW_EDID_VER3

//! @}

//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_GetEDID(LwPhysicalGpuHandle hPhysicalGpu, LwU32 displayOutputId, LW_EDID *pEDID);

//! \ingroup gpu
//! Used in LW_GPU_CONNECTOR_DATA
typedef enum _LW_GPU_CONNECTOR_TYPE
{
    LWAPI_GPU_CONNECTOR_VGA_15_PIN                      = 0x00000000,
    LWAPI_GPU_CONNECTOR_TV_COMPOSITE                    = 0x00000010,
    LWAPI_GPU_CONNECTOR_TV_SVIDEO                       = 0x00000011,
    LWAPI_GPU_CONNECTOR_TV_HDTV_COMPONENT               = 0x00000013,
    LWAPI_GPU_CONNECTOR_TV_SCART                        = 0x00000014,
    LWAPI_GPU_CONNECTOR_TV_COMPOSITE_SCART_ON_EIAJ4120  = 0x00000016,
    LWAPI_GPU_CONNECTOR_TV_HDTV_EIAJ4120                = 0x00000017,
    LWAPI_GPU_CONNECTOR_PC_POD_HDTV_YPRPB               = 0x00000018,
    LWAPI_GPU_CONNECTOR_PC_POD_SVIDEO                   = 0x00000019,
    LWAPI_GPU_CONNECTOR_PC_POD_COMPOSITE                = 0x0000001A,
    LWAPI_GPU_CONNECTOR_DVI_I_TV_SVIDEO                 = 0x00000020,
    LWAPI_GPU_CONNECTOR_DVI_I_TV_COMPOSITE              = 0x00000021,
    LWAPI_GPU_CONNECTOR_DVI_I                           = 0x00000030,
    LWAPI_GPU_CONNECTOR_DVI_D                           = 0x00000031,
    LWAPI_GPU_CONNECTOR_ADC                             = 0x00000032,
    LWAPI_GPU_CONNECTOR_LFH_DVI_I_1                     = 0x00000038,
    LWAPI_GPU_CONNECTOR_LFH_DVI_I_2                     = 0x00000039,
    LWAPI_GPU_CONNECTOR_SPWG                            = 0x00000040,
    LWAPI_GPU_CONNECTOR_OEM                             = 0x00000041,
    LWAPI_GPU_CONNECTOR_DISPLAYPORT_EXTERNAL            = 0x00000046,
    LWAPI_GPU_CONNECTOR_DISPLAYPORT_INTERNAL            = 0x00000047,
    LWAPI_GPU_CONNECTOR_DISPLAYPORT_MINI_EXT            = 0x00000048,
    LWAPI_GPU_CONNECTOR_HDMI_A                          = 0x00000061,
    LWAPI_GPU_CONNECTOR_HDMI_C_MINI                     = 0x00000063,
    LWAPI_GPU_CONNECTOR_LFH_DISPLAYPORT_1               = 0x00000064,
    LWAPI_GPU_CONNECTOR_LFH_DISPLAYPORT_2               = 0x00000065,
    LWAPI_GPU_CONNECTOR_VIRTUAL_WFD                     = 0x00000070,    
    LWAPI_GPU_CONNECTOR_UNKNOWN                         = 0xFFFFFFFF,
} LW_GPU_CONNECTOR_TYPE;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetConnectorInfo
//
//! \fn LwAPI_GPU_GetConnectorInfo(LwPhysicalGpuHandle hPhysicalGpu, LwU32 outputId, LW_GPU_CONNECTOR_INFO *pConnectorInfo)
//!   Given a physical GPU handle and a single outputId (exactly 1 bit set - see \ref handles),
//!   this API fills the LW_GPU_CONNECTOR_INFO with connector specific data. 
//!   \note If outputId is connected or active then the current attached connector information is returned.
//!         If there is no connector attached for the outputId then all possible connections on the board are returned.
//!         Some TV outputs may have multiple connectors attached or could have an ambiguous connector layout on the board.
//!         In that case the connector[] array will list all connectors without indicating 
//!         which one is 'active'. To get the active TV connector use LwAPI_GetTVOutputInfo.
//!         This API is compliant with displayId sent as input instead of outputId.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \retval  LWAPI_ILWALID_ARGUMENT              hPhysicalGpu, outputId or pOutputsMask is NULL; or outputId has > 1 bit set
//! \retval  LWAPI_OK                           *pConnectorInfo contains valid LW_GPU_CONNECTOR_INFO data
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//! \retval  LWAPI_INCOMPATIBLE_STRUCT_VERSION   LW_GPU_CONNECTOR_INFO version not compatible with driver
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! Used in LW_GPU_CONNECTOR_INFO
typedef enum _LW_GPU_CONNECTOR_PLATFORM
{
    LWAPI_GPU_CONNECTOR_PLATFORM_DEFAULT_ADD_IN_CARD   = 0x00000000,
    LWAPI_GPU_CONNECTOR_PLATFORM_TWO_PLATE_ADD_IN_CARD = 0x00000001,
    LWAPI_GPU_CONNECTOR_PLATFORM_MOBILE_ADD_IN_CARD    = 0x00000008,
    LWAPI_GPU_CONNECTOR_PLATFORM_MOBILE_BACK           = 0x00000010,
    LWAPI_GPU_CONNECTOR_PLATFORM_MOBILE_BACK_LEFT      = 0x00000011,
    LWAPI_GPU_CONNECTOR_PLATFORM_MOBILE_BACK_DOCK      = 0x00000018,
    LWAPI_GPU_CONNECTOR_PLATFORM_MAINBOARD_DEFAULT     = 0x00000020,
    LWAPI_GPU_CONNECTOR_PLATFORM_UNKNOWN               = 0xFFFFFFFF,
} LW_GPU_CONNECTOR_PLATFORM;

//! \ingroup gpu
//! Used in LW_GPU_CONNECTOR_INFO
typedef struct
{
    LW_GPU_CONNECTOR_TYPE   type;           //!< Connector type
    LwU32                   locationIndex;  //!< Connector location
} LW_GPU_CONNECTOR_DATA;

//! \ingroup gpu
#define LW_API_MAX_CONNECTOR_PER_OUTPUT     4

//! \ingroup gpu
//! Used in LwAPI_GPU_GetConnectorInfo()
typedef struct
{
    LwU32                       version;            //!<  Structure version
    LW_GPU_CONNECTOR_PLATFORM   connectorPlatform;  //!<  Connector platform
    LwU32                       connectorCount;     //!<  Number of valid entries in connector[]
    LW_GPU_CONNECTOR_DATA       connector[LW_API_MAX_CONNECTOR_PER_OUTPUT];
} LW_GPU_CONNECTOR_INFO;


//! \ingroup gpu
#define LW_GPU_CONNECTOR_INFO_VER  MAKE_LWAPI_VERSION(LW_GPU_CONNECTOR_INFO,1)


//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_GetConnectorInfo(LwPhysicalGpuHandle hPhysicalGpu, LwU32 outputId, LW_GPU_CONNECTOR_INFO *pConnectorInfo);



//! \ingroup gpu
//! Used in LwAPI_GPU_GetConnectorInfoEx()
typedef struct _LW_CONNECTOR_CAPS
{
    LwU32       maxDisplaysVisibleToOS;                 //!< The maximum number of displays that can be exposed to the OS
    LwU32       maxNodesInMultiStreamTopology;          //!< The maximum number of displays that can be connected in a MST behind a single connector
    LwU32       maxAddressHopsInMultiStreamTopology;    //!< The maximum number of levels that the displays can be connected in a multi stream topology (MST)
    LwU32       maxHdcpHopsSupported;                   //!< The maximum number of levels beyond which HDCP will not be supported

    LwU64       isMultiStreamCapable    : 1;            //!< Specifies if this is a multi stream capable connector
    LwU64       isStreamCloneCapable    : 1;            //!< Specifies if this is a stream clone capable connector
    LwU64       reserved                : 62;           //!< Reserved. Must be set to ZERO.
} LW_CONNECTOR_CAPS;

//! \ingroup gpu
//! Used in LwAPI_GPU_GetConnectorInfoEx()
typedef struct
{
    LwU32                       version;            //!<  Structure version
    LW_GPU_CONNECTOR_PLATFORM   connectorPlatform;  //!<  Connector platform
    LwU32                       connectorDataCount; //!<  IN: Number of entries allocated for connectorData array
                                                    //!<  OUT: The actual number of valid entries in connectorData array.
    LW_GPU_CONNECTOR_DATA*      connectorData;      //!<  IN: Pointer to an array of LW_GPU_CONNECTOR_DATA structures
                                                    //!<  OUT: The connector data is filled in by the API
    LW_CONNECTOR_CAPS           connectorCaps;      //!<  Connector capabilities

} LW_GPU_CONNECTOR_INFO_EX_V1;

typedef enum _LW_GPU_CONNECTOR_DONGLE_TYPE
{
    LW_GPU_CONNECTOR_DONGLE_TYPE_OTHER             = 0,
    LW_GPU_CONNECTOR_DONGLE_TYPE_DP2DVI            = 1,
    LW_GPU_CONNECTOR_DONGLE_TYPE_DP2HDMI           = 2,
    LW_GPU_CONNECTOR_DONGLE_TYPE_DMS592DVI         = 3,
    LW_GPU_CONNECTOR_DONGLE_TYPE_DMS592VGA         = 4,
    LW_GPU_CONNECTOR_DONGLE_TYPE_DP2VGA            = 5,
    LW_GPU_CONNECTOR_DONGLE_TYPE_ACTIVE_DP2DVI     = 6,
    LW_GPU_CONNECTOR_DONGLE_TYPE_ACTIVE_DP2HDMI    = 7,
//! keeping some reserved
    LW_GPU_CONNECTOR_DONGLE_TYPE_WFD2VGA           = 20,
    LW_GPU_CONNECTOR_DONGLE_TYPE_WFD2SVIDEO        = 21,
    LW_GPU_CONNECTOR_DONGLE_TYPE_WFD2COMPOSITE     = 22,
    LW_GPU_CONNECTOR_DONGLE_TYPE_WFD2COMPONENT     = 23,
    LW_GPU_CONNECTOR_DONGLE_TYPE_WFD2DVI           = 24,
    LW_GPU_CONNECTOR_DONGLE_TYPE_WFD2HDMI          = 25,
    LW_GPU_CONNECTOR_DONGLE_TYPE_WFD2WFD           = 26,
    LW_GPU_CONNECTOR_DONGLE_TYPE_WFD2EIAJRC5237    = 27,
    LW_GPU_CONNECTOR_DONGLE_TYPE_WFD2SDI           = 28,
    LW_GPU_CONNECTOR_DONGLE_TYPE_WFD2DP            = 29, 
    LW_GPU_CONNECTOR_DONGLE_TYPE_WFD2UDI           = 30,
} LW_GPU_CONNECTOR_DONGLE_TYPE;

typedef struct
{
    LwU32                       version;            //!<  Structure version
    LW_GPU_CONNECTOR_PLATFORM   connectorPlatform;  //!<  Connector platform
    LwU32                       connectorDataCount; //!<  IN: Number of entries allocated for connectorData array
                                                    //!<  OUT: The actual number of valid entries in connectorData array.
    LW_GPU_CONNECTOR_DATA*      connectorData;      //!<  IN: Pointer to an array of LW_GPU_CONNECTOR_DATA structures
                                                    //!<  OUT: The connector data is filled in by the API
    LW_CONNECTOR_CAPS           connectorCaps;      //!<  Connector capabilities
    LW_GPU_CONNECTOR_DONGLE_TYPE    dongleType;         //!<  dongle type. Valid for DP & WFD connector only.

} LW_GPU_CONNECTOR_INFO_EX_V2;

//! \ingroup gpu
typedef LW_GPU_CONNECTOR_INFO_EX_V2 LW_GPU_CONNECTOR_INFO_EX;

#define LW_GPU_CONNECTOR_INFO_EX_VER1  MAKE_LWAPI_VERSION(LW_GPU_CONNECTOR_INFO_EX_V1, 1)
#define LW_GPU_CONNECTOR_INFO_EX_VER2  MAKE_LWAPI_VERSION(LW_GPU_CONNECTOR_INFO_EX_V2, 2)
#define LW_GPU_CONNECTOR_INFO_EX_VER   LW_GPU_CONNECTOR_INFO_EX_VER2

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetConnectorInfoEx
//
//! \fn LwAPI_GPU_GetConnectorInfoEx(LwU32 displayId, LW_GPU_CONNECTOR_INFO_EX *pConnectorInfo)
//!
//!   Description: This API returns the connector information for a given connector identified by the input
//!                displayId parameter. For vista and above, when the display id represents a device in a multi stream topology,
//!                the information of the physical connector to which the display is rooted to, will be returned. If the 
//!                display is rooted to multiple physical connectors (when connected via a concentrator), the 
//!                output can be of either of the connectors. In such cases, the user should pass the display id
//!                of the connector specifically.
//!
//! \note The connectorData count usually is 1 unless the connector type is an analog TV. Lwrrently the maximum number of connectors per output is defined by 
//!       LW_API_MAX_CONNECTOR_PER_OUTPUT. It is advisable the client (in order to avoid multiple calls) allocate LW_API_MAX_CONNECTOR_PER_OUTPUT elements for 
//!       the connectorData member and set connectorDataCount to LW_API_MAX_CONNECTOR_PER_OUTPUT.
//! 
//! \note If a monitor is connected or active on the given connector, then the current attached connector information is returned.
//!       If there is no monitor attached then all possible connections on the board are returned.
//!       Some TV outputs may have multiple connectors attached or could have an ambiguous connector layout on the board.
//!       In that case the connectorData array will list all connectors without indicating which one is 'active'. 
//!       To get the active TV connector use LwAPI_GetTVOutputInfo.
//!
//! \param[in]     displayId       The displayId of a device connected to the required connector
//! \param[in/out] pConnectorInfo  Pointer to LW_GPU_CONNECTOR_INFO_EX structure that will receive the data
//!
//! SUPPORTED OS:  Windows XP,  Windows Vista
//!
//!
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!              specific meaning for this API, they are listed below.
//!
//! \retval  LWAPI_INSUFFICIENT_BUFFER      There exists more connector data than what was allocated for the connectorData array.
//!                                         In this case the connectorDataCount will have the actual number of connector data available
//!                                         for the input connector.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetConnectorInfoEx(__in LwU32 displayId, __inout LW_GPU_CONNECTOR_INFO_EX *pConnectorInfo);



//! \ingroup tvapi
//! Used in LwAPI_GPU_GetTvEncoderType()
typedef enum _LW_TV_ENCODER_TYPE
{ 
    LW_ENCODER_TYPE_UNKNOWN         = 0, 
           
    LW_ENCODER_TYPE_BROOKTREE_868   = 1,
    LW_ENCODER_TYPE_BROOKTREE_869   = 2,
    LW_ENCODER_TYPE_BROOKTREE_871   = 3,
    LW_ENCODER_TYPE_BROOKTREE_870   = 4,
    LW_ENCODER_TYPE_BROOKTREE_872   = 5,
    LW_ENCODER_TYPE_BROOKTREE_873   = 6,
    LW_ENCODER_TYPE_BROOKTREE_874   = 7,
    LW_ENCODER_TYPE_BROOKTREE_875   = 8,
    LW_ENCODER_TYPE_BROOKTREE_890   = 9,
    LW_ENCODER_TYPE_BROOKTREE_891   = 10,
    LW_ENCODER_TYPE_BROOKTREE_892   = 11,

    LW_ENCODER_TYPE_CHRONTEL_7003   = 12,
    LW_ENCODER_TYPE_CHRONTEL_7004   = 13,
    LW_ENCODER_TYPE_CHRONTEL_7005   = 14,
    LW_ENCODER_TYPE_CHRONTEL_7006   = 15,
    LW_ENCODER_TYPE_CHRONTEL_7007   = 16,
    LW_ENCODER_TYPE_CHRONTEL_7008   = 17,
    LW_ENCODER_TYPE_CHRONTEL_7009   = 18,
    LW_ENCODER_TYPE_CHRONTEL_7010   = 19,
    LW_ENCODER_TYPE_CHRONTEL_7011   = 20,
    LW_ENCODER_TYPE_CHRONTEL_7012   = 21,
    LW_ENCODER_TYPE_CHRONTEL_7019   = 22,
    LW_ENCODER_TYPE_CHRONTEL_7021   = 23,
    LW_ENCODER_TYPE_CHRONTEL_7301   = 24,

    LW_ENCODER_TYPE_PHILIPS_7102    = 25,
    LW_ENCODER_TYPE_PHILIPS_7103    = 26,
    LW_ENCODER_TYPE_PHILIPS_7108    = 27,
    LW_ENCODER_TYPE_PHILIPS_7109    = 28,
    LW_ENCODER_TYPE_PHILIPS_7108B   = 29,
    LW_ENCODER_TYPE_PHILIPS_7108A   = 30,
    LW_ENCODER_TYPE_PHILIPS_7109A   = 31,
    LW_ENCODER_TYPE_PHILIPS_7104    = 32,
    LW_ENCODER_TYPE_PHILIPS_7105    = 33,

    LW_ENCODER_TYPE_LWIDIA_TV17     = 34,
    LW_ENCODER_TYPE_LWIDIA_MV17     = 35,
    LW_ENCODER_TYPE_LWIDIA_MV36     = 36,
    LW_ENCODER_TYPE_LWIDIA_G80      = 37,

} LW_TV_ENCODER_TYPE;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetTvEncoderType
//
//!  This function retrieves the TV encoder type associated with the specified GPU handle.
//!  - The output ID can be the outputId of type LWAPI_GPU_OUTPUT_TV if the query is for a specific encoder in the case of a 
//!  multi-encoder board. See \ref handles.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 85
//!              
//! \retval  LWAPI_OK                            Call successful.
//! \retval  LWAPI_HANDLE_ILWALIDATED            Handle passed has been ilwalidated (see user guide).
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//! \retval  LWAPI_ILWALID_ARGUMENT              pEncoderType is NULL or outputId is 0.
//! \retval  LWAPI_EXPECTED_TV_DISPLAY           Expected TV output display in outputId.
//! \ingroup tvapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetTvEncoderType(LwPhysicalGpuHandle hPhysicalGpu, LwU32 outputId, LW_TV_ENCODER_TYPE *pEncoderType); 


////////////////////////////////////////////////////////////////////////////////
//
// LwAPI_TVOutput Information
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup tvapi
//! Used in LW_DISPLAY_TV_OUTPUT_INFO
typedef enum _LW_DISPLAY_TV_FORMAT
{
    LW_DISPLAY_TV_FORMAT_NONE               = 0,
    LW_DISPLAY_TV_FORMAT_SD_NTSCM           = 0x00000001,
    LW_DISPLAY_TV_FORMAT_SD_NTSCJ           = 0x00000002,
    LW_DISPLAY_TV_FORMAT_SD_PALM            = 0x00000004,
    LW_DISPLAY_TV_FORMAT_SD_PALBDGH         = 0x00000008,
    LW_DISPLAY_TV_FORMAT_SD_PALN            = 0x00000010,
    LW_DISPLAY_TV_FORMAT_SD_PALNC           = 0x00000020,
    LW_DISPLAY_TV_FORMAT_SD_576i            = 0x00000100,
    LW_DISPLAY_TV_FORMAT_SD_480i            = 0x00000200,
    LW_DISPLAY_TV_FORMAT_ED_480p            = 0x00000400,
    LW_DISPLAY_TV_FORMAT_ED_576p            = 0x00000800,
    LW_DISPLAY_TV_FORMAT_HD_720p            = 0x00001000,
    LW_DISPLAY_TV_FORMAT_HD_1080i           = 0x00002000,
    LW_DISPLAY_TV_FORMAT_HD_1080p           = 0x00004000,
    LW_DISPLAY_TV_FORMAT_HD_720p50          = 0x00008000,
    LW_DISPLAY_TV_FORMAT_HD_1080p24         = 0x00010000,
    LW_DISPLAY_TV_FORMAT_HD_1080i50         = 0x00020000,
    LW_DISPLAY_TV_FORMAT_HD_1080p50         = 0x00040000,
    LW_DISPLAY_TV_FORMAT_UHD_4Kp30          = 0x00080000,
    LW_DISPLAY_TV_FORMAT_UHD_4Kp25          = 0x00100000,
    LW_DISPLAY_TV_FORMAT_UHD_4Kp24          = 0x00200000,
    LW_DISPLAY_TV_FORMAT_UHD_4Kp24_SMPTE    = 0x00400000,

    LW_DISPLAY_TV_FORMAT_SD_OTHER           = 0x01000000,
    LW_DISPLAY_TV_FORMAT_ED_OTHER           = 0x02000000,
    LW_DISPLAY_TV_FORMAT_HD_OTHER           = 0x04000000,

    LW_DISPLAY_TV_FORMAT_ANY                = 0x80000000,

} LW_DISPLAY_TV_FORMAT;


//! \ingroup tvapi
//! Used in LwAPI_SetGpuTopologies() and LwAPI_GetGpuTopologies()
typedef struct
{
    LwU32                   version;                            //!< [IN]       Structure version.
    LwU32                   supportedFormats;                   //!< [OUT only] One or more TV formats defined in LW_DISPLAY_TV_FORMAT matching, encoder supported formats for analog TVs or EDID exposed modes for digital TVs.
    LW_DISPLAY_TV_FORMAT    lwrrentFormat;                      //!< [IN/OUT]   One of the selected TV output format from supportedFormats defined in LW_DISPLAY_TV_FORMAT.
    LW_GPU_CONNECTOR_TYPE   lwrrentConnector;                   //!< [IN/OUT]   For Analog TV, valid TV output connector is one of the LWAPI_GPU_CONNECTOR_TV types.
                                                                //!<            For Digital TV, valid TV output connector is one of the LWAPI_GPU_CONNECTOR_DVI types.
} LW_DISPLAY_TV_OUTPUT_INFO;    

//! \ingroup tvapi
#define LW_DISPLAY_TV_OUTPUT_INFO_VER MAKE_LWAPI_VERSION(LW_DISPLAY_TV_OUTPUT_INFO, 1)

 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetTVOutputInfo
//
//!  This function retrieves the TV display output information of the selected display.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 95
//!
//! \param [in]  hLwDisplay         LWPU Display selection. It can be #LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]  outputId           One of the selected outputId retrieved from LwAPI_GPU_GetActiveOutputs or LwAPI_GetView, to identify the targeted TV. See \ref handles.
//!                                 Can be NULL to auto pick the TV output associated with hLwDisplay.
//!                                 The outputId must be of type #LWAPI_GPU_OUTPUT_TV or #LWAPI_GPU_OUTPUT_DFP in case of a digital HDTV.
//! \param [out] pTVOutInfo         The returned TV output information.
//!                                 With digital HDTV, the supportedFormats are limited to the available EIA-861B modes in the EDID 
//!                                 or the custom 861B modes if added by the user.
//!                                 
//!
//! \retval   LWAPI_OK                           Call successful.
//! \retval   LWAPI_LWIDIA_DEVICE_NOT_FOUND      No LWPU GPU driving a display was found.
//! \retval   LWAPI_EXPECTED_DISPLAY_HANDLE      hLwDisplay is not a valid display handle.
//! \retval   LWAPI_ILWALID_ARGUMENT             pTVOutInfo is NULL.
//! \retval   LWAPI_INCOMPATIBLE_STRUCT_VERSION  The version of the LW_DISPLAY_TV_OUTPUT_INFO_VER struct is not supported.
//! \retval   LWAPI_EXPECTED_TV_DISPLAY          Expected TV output display in outputId.
//! \ingroup tvapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetTVOutputInfo(LwDisplayHandle hLwDisplay, LwU32 outputId, LW_DISPLAY_TV_OUTPUT_INFO *pTVOutInfo);


//! \ingroup dispcontrol
//! @{
#define LWAPI_MAX_VIEW_TARGET  2
#define LWAPI_ADVANCED_MAX_VIEW_TARGET 4

#ifndef _LW_TARGET_VIEW_MODE_
#define _LW_TARGET_VIEW_MODE_

//! Used in LwAPI_SetView().
typedef enum _LW_TARGET_VIEW_MODE
{
    LW_VIEW_MODE_STANDARD  = 0,
    LW_VIEW_MODE_CLONE     = 1,
    LW_VIEW_MODE_HSPAN     = 2,
    LW_VIEW_MODE_VSPAN     = 3,
    LW_VIEW_MODE_DUALVIEW  = 4,
    LW_VIEW_MODE_MULTIVIEW = 5,
} LW_TARGET_VIEW_MODE;
#endif

//! @}


// Following definitions are used in LwAPI_SetViewEx.

//! Scaling modes - used in LwAPI_SetViewEx().
//! \ingroup dispcontrol
typedef enum _LW_SCALING
{
    LW_SCALING_DEFAULT          = 0,        //!< No change

    // New Scaling Declarations
    LW_SCALING_GPU_SCALING_TO_CLOSEST                   = 1,  //!< Balanced  - Full Screen
    LW_SCALING_GPU_SCALING_TO_NATIVE                    = 2,  //!< Force GPU - Full Screen
    LW_SCALING_GPU_SCANOUT_TO_NATIVE                    = 3,  //!< Force GPU - Centered\No Scaling
    LW_SCALING_GPU_SCALING_TO_ASPECT_SCANOUT_TO_NATIVE  = 5,  //!< Force GPU - Aspect Ratio
    LW_SCALING_GPU_SCALING_TO_ASPECT_SCANOUT_TO_CLOSEST = 6,  //!< Balanced  - Aspect Ratio
    LW_SCALING_GPU_SCANOUT_TO_CLOSEST                   = 7,  //!< Balanced  - Centered\No Scaling
    
    // Legacy Declarations
    LW_SCALING_MONITOR_SCALING                          = LW_SCALING_GPU_SCALING_TO_CLOSEST,
    LW_SCALING_ADAPTER_SCALING                          = LW_SCALING_GPU_SCALING_TO_NATIVE,
    LW_SCALING_CENTERED                                 = LW_SCALING_GPU_SCANOUT_TO_NATIVE,
    LW_SCALING_ASPECT_SCALING                           = LW_SCALING_GPU_SCALING_TO_ASPECT_SCANOUT_TO_NATIVE,

    LW_SCALING_LWSTOMIZED       = 255       //!< For future use
} LW_SCALING;

//! Rotate modes- used in LwAPI_SetViewEx().
//! \ingroup dispcontrol
typedef enum _LW_ROTATE
{
    LW_ROTATE_0           = 0,
    LW_ROTATE_90          = 1,
    LW_ROTATE_180         = 2,
    LW_ROTATE_270         = 3,
    LW_ROTATE_IGNORED     = 4,
} LW_ROTATE;

//! Color formats- used in LwAPI_SetViewEx().
//! \ingroup dispcontrol
#define LWFORMAT_MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                         ((LwU32)(LwU8)(ch0) | ((LwU32)(LwU8)(ch1) << 8) |   \
                     ((LwU32)(LwU8)(ch2) << 16) | ((LwU32)(LwU8)(ch3) << 24 ))



//! Color formats- used in LwAPI_SetViewEx().
//! \ingroup dispcontrol
typedef enum _LW_FORMAT
{
    LW_FORMAT_UNKNOWN           =  0,       //!< unknown. Driver will choose one as following value.
    LW_FORMAT_P8                = 41,       //!< for 8bpp mode
    LW_FORMAT_R5G6B5            = 23,       //!< for 16bpp mode
    LW_FORMAT_A8R8G8B8          = 21,       //!< for 32bpp mode
    LW_FORMAT_A16B16G16R16F     = 113,      //!< for 64bpp(floating point) mode.
    LW_FORMAT_R8G8B8            = 20,
    LW_FORMAT_X8R8G8B8          = 22,
    LW_FORMAT_X1R5G5B5          = 24,
    LW_FORMAT_A1R5G5B5          = 25,
    LW_FORMAT_A4R4G4B4          = 26,
    LW_FORMAT_R3G3B2            = 27,
    LW_FORMAT_A8                = 28,
    LW_FORMAT_A8R3G3B2          = 29,
    LW_FORMAT_X4R4G4B4          = 30,
    LW_FORMAT_A2B10G10R10       = 31,
    LW_FORMAT_A8B8G8R8          = 32,
    LW_FORMAT_X8B8G8R8          = 33,
    LW_FORMAT_G16R16            = 34,
    LW_FORMAT_A2R10G10B10       = 35,
    LW_FORMAT_A16B16G16R16      = 36,
    LW_FORMAT_A8P8              = 40,
    LW_FORMAT_L8                = 50,
    LW_FORMAT_A8L8              = 51,
    LW_FORMAT_A4L4              = 52,
    LW_FORMAT_V8U8              = 60,
    LW_FORMAT_L6V5U5            = 61,
    LW_FORMAT_X8L8V8U8          = 62,
    LW_FORMAT_Q8W8V8U8          = 63,
    LW_FORMAT_V16U16            = 64,
    LW_FORMAT_W11V11U10         = 65, 
    LW_FORMAT_A2W10V10U10       = 67,
    LW_FORMAT_UYVY              = LWFORMAT_MAKEFOURCC('U', 'Y', 'V', 'Y'),
    LW_FORMAT_R8G8_B8G8         = LWFORMAT_MAKEFOURCC('R', 'G', 'B', 'G'),
    LW_FORMAT_YUY2              = LWFORMAT_MAKEFOURCC('Y', 'U', 'Y', '2'),
    LW_FORMAT_G8R8_G8B8         = LWFORMAT_MAKEFOURCC('G', 'R', 'G', 'B'),
    LW_FORMAT_DXT1              = LWFORMAT_MAKEFOURCC('D', 'X', 'T', '1'),
    LW_FORMAT_DXT2              = LWFORMAT_MAKEFOURCC('D', 'X', 'T', '2'),
    LW_FORMAT_DXT3              = LWFORMAT_MAKEFOURCC('D', 'X', 'T', '3'),
    LW_FORMAT_DXT4              = LWFORMAT_MAKEFOURCC('D', 'X', 'T', '4'),
    LW_FORMAT_DXT5              = LWFORMAT_MAKEFOURCC('D', 'X', 'T', '5'),
    LW_FORMAT_D16_LOCKABLE      = 70,
    LW_FORMAT_D32               = 71,
    LW_FORMAT_D15S1             = 73,
    LW_FORMAT_D24S8             = 75,
    LW_FORMAT_D24X8             = 77,
    LW_FORMAT_D24X4S4           = 79,
    LW_FORMAT_D16               = 80,
    LW_FORMAT_D32F_LOCKABLE     = 82,
    LW_FORMAT_D24FS8            = 83,
    LW_FORMAT_D32_LOCKABLE      = 84,
    LW_FORMAT_S8_LOCKABLE       = 85,
    LW_FORMAT_S1D15             = 72,
    LW_FORMAT_S8D24             = 74,
    LW_FORMAT_X8D24             = 76,
    LW_FORMAT_X4S4D24           = 78,
    LW_FORMAT_L16               = 81,
    LW_FORMAT_VERTEXDATA        =100,
    LW_FORMAT_INDEX16           =101,
    LW_FORMAT_INDEX32           =102,
    LW_FORMAT_Q16W16V16U16      =110,
    LW_FORMAT_R16F              =111,
    LW_FORMAT_G16R16F           =112,
    LW_FORMAT_R32F              =114,
    LW_FORMAT_G32R32F           =115,
    LW_FORMAT_A32B32G32R32F     =116,
    LW_FORMAT_CxV8U8            =117,
    LW_FORMAT_A1                =118,

} LW_FORMAT;

// TV standard


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SetDisplaySettings
///////////////////////////////////////////////////////////////////////////////


//! \ingroup dispcontrol
//! The connector is not supported yet; must be set to _AUTO
typedef enum _LW_CONNECTOR
{
    LW_CONN_AUTO = 0,
}LW_CONNECTOR;

typedef struct 
{
    float x;    //!<  x-coordinate of the viewport top-left point
    float y;    //!<  y-coordinate of the viewport top-left point
    float w;    //!<  Width of the viewport
    float h;    //!<  Height of the viewport
} LW_VIEWPORTF;



//! \ingroup dispcontrol
//! The timing override is not supported yet; must be set to _AUTO. \n


typedef enum _LW_TIMING_OVERRIDE
{
    LW_TIMING_OVERRIDE_LWRRENT = 0,          //!< get the current timing
    LW_TIMING_OVERRIDE_AUTO,                 //!< the timing the driver will use based the current policy
    LW_TIMING_OVERRIDE_EDID,                 //!< EDID timing
    LW_TIMING_OVERRIDE_DMT,                  //!< VESA DMT timing
    LW_TIMING_OVERRIDE_DMT_RB,               //!< VESA DMT timing with reduced blanking
    LW_TIMING_OVERRIDE_CVT,                  //!< VESA CVT timing
    LW_TIMING_OVERRIDE_CVT_RB,               //!< VESA CVT timing with reduced blanking
    LW_TIMING_OVERRIDE_GTF,                  //!< VESA GTF timing
    LW_TIMING_OVERRIDE_EIA861,               //!< EIA 861x pre-defined timing
    LW_TIMING_OVERRIDE_ANALOG_TV,            //!< analog SD/HDTV timing
    LW_TIMING_OVERRIDE_LWST,                 //!< LW custom timings
    LW_TIMING_OVERRIDE_LW_PREDEFINED,        //!< LW pre-defined timing (basically the PsF timings)
    LW_TIMING_OVERRIDE_LW_PSF                = LW_TIMING_OVERRIDE_LW_PREDEFINED,
    LW_TIMING_OVERRIDE_LW_ASPR,
    LW_TIMING_OVERRIDE_SDI,                  //!< Override for SDI timing

    LW_TIMING_OVRRIDE_MAX,                   
}LW_TIMING_OVERRIDE;


#ifndef LW_TIMING_STRUCTS_DEFINED
#define LW_TIMING_STRUCTS_DEFINED

//***********************
// The Timing Structure
//***********************
//
//! \ingroup dispcontrol
//!  LWPU-specific timing extras \n
//! Used in LW_TIMING.
typedef struct tagLW_TIMINGEXT
{
    LwU32   flag;          //!< Reserved for LWPU hardware-based enhancement, such as double-scan.
    LwU16   rr;            //!< Logical refresh rate to present
    LwU32   rrx1k;         //!< Physical vertical refresh rate in 0.001Hz
    LwU32   aspect;        //!< Display aspect ratio Hi(aspect):horizontal-aspect, Low(aspect):vertical-aspect
    LwU16   rep;           //!< Bit-wise pixel repetition factor: 0x1:no pixel repetition; 0x2:each pixel repeats twice horizontally,..
    LwU32   status;        //!< Timing standard 
    LwU8    name[40];      //!< Timing name
}LW_TIMINGEXT;



//! \ingroup dispcontrol
//!The very basic timing structure based on the VESA standard:
//! \code
//!            |<----------------------------htotal--------------------------->| 
//!             ---------"active" video-------->|<-------blanking------>|<-----  
//!            |<-------hvisible-------->|<-hb->|<-hfp->|<-hsw->|<-hbp->|<-hb->| 
//! --------- -+-------------------------+      |       |       |       |      | 
//!   A      A |                         |      |       |       |       |      | 
//!   :      : |                         |      |       |       |       |      | 
//!   :      : |                         |      |       |       |       |      | 
//!   :vertical|    addressable video    |      |       |       |       |      | 
//!   : visible|                         |      |       |       |       |      | 
//!   :      : |                         |      |       |       |       |      | 
//!   :      : |                         |      |       |       |       |      | 
//! vertical V |                         |      |       |       |       |      | 
//!  total   --+-------------------------+      |       |       |       |      | 
//!   :      vb         border                  |       |       |       |      | 
//!   :      -----------------------------------+       |       |       |      |  
//!   :      vfp        front porch                     |       |       |      |  
//!   :      -------------------------------------------+       |       |      | 
//!   :      vsw        sync width                              |       |      | 
//!   :      ---------------------------------------------------+       |      | 
//!   :      vbp        back porch                                      |      | 
//!   :      -----------------------------------------------------------+      | 
//!   V      vb         border                                                 | 
//! ---------------------------------------------------------------------------+ 
//! \endcode
typedef struct _LW_TIMING
{
    // VESA scan out timing parameters:
    LwU16 HVisible;         //!< horizontal visible 
    LwU16 HBorder;          //!< horizontal border 
    LwU16 HFrontPorch;      //!< horizontal front porch
    LwU16 HSyncWidth;       //!< horizontal sync width
    LwU16 HTotal;           //!< horizontal total
    LwU8  HSyncPol;         //!< horizontal sync polarity: 1-negative, 0-positive

    LwU16 VVisible;         //!< vertical visible
    LwU16 VBorder;          //!< vertical border
    LwU16 VFrontPorch;      //!< vertical front porch
    LwU16 VSyncWidth;       //!< vertical sync width
    LwU16 VTotal;           //!< vertical total
    LwU8  VSyncPol;         //!< vertical sync polarity: 1-negative, 0-positive
    
    LwU16 interlaced;       //!< 1-interlaced, 0-progressive
    LwU32 pclk;             //!< pixel clock in 10 kHz

    //other timing related extras
    LW_TIMINGEXT etc;          
}LW_TIMING;
#endif //LW_TIMING_STRUCTS_DEFINED


//! \addtogroup dispcontrol
//! Timing-related constants
//! @{
#define LW_TIMING_H_SYNC_POSITIVE                             0
#define LW_TIMING_H_SYNC_NEGATIVE                             1
#define LW_TIMING_H_SYNC_DEFAULT                              LW_TIMING_H_SYNC_NEGATIVE
//
#define LW_TIMING_V_SYNC_POSITIVE                             0
#define LW_TIMING_V_SYNC_NEGATIVE                             1
#define LW_TIMING_V_SYNC_DEFAULT                              LW_TIMING_V_SYNC_POSITIVE
//
#define LW_TIMING_PROGRESSIVE                                 0
#define LW_TIMING_INTERLACED                                  1
#define LW_TIMING_INTERLACED_EXTRA_VBLANK_ON_FIELD2           1
#define LW_TIMING_INTERLACED_NO_EXTRA_VBLANK_ON_FIELD2        2
//! @}

//! \ingroup dispcontrol
typedef enum _LWAPI_TIMING_TYPE
{
    LW_TIMING_TYPE_DMT = 1,                                 //!< DMT 
    LW_TIMING_TYPE_GTF,                                     //!< GTF
    LW_TIMING_TYPE_ASPR,                                    //!< wide aspect ratio timing, for legacy support only
    LW_TIMING_TYPE_NTSC_TV,                                 //!< NTSC TV timing. for legacy support only
    LW_TIMING_TYPE_PAL_TV,                                  //!< PAL TV timing, legacy support only
    LW_TIMING_TYPE_CVT,                                     //!< CVT timing
    LW_TIMING_TYPE_CVT_RB,                                  //!< CVT timing with reduced blanking
    LW_TIMING_TYPE_LWST,                                    //!< Lwstomized timing
    LW_TIMING_TYPE_EDID_DTD,                                //!< EDID detailed timing
    LW_TIMING_TYPE_EDID_STD,                                //!< EDID standard timing
    LW_TIMING_TYPE_EDID_EST,                                //!< EDID established timing
    LW_TIMING_TYPE_EDID_CVT,                                //!< EDID defined CVT timing (EDID 1.4)
    LW_TIMING_TYPE_EDID_861ST,                              //!< EDID defined CEA/EIA 861 timing (in the EDID 861 extension)
    LW_TIMING_TYPE_LW_PREDEFINED,                           //!< LW pre-defined timings (PsF timings)
    LW_TIMING_TYPE_DMT_RB,                                  //!< DMT timing with reduced blanking
    LW_TIMING_TYPE_EDID_EXT_DTD,                            //!< EDID detailed timing in the extension
    LW_TIMING_TYPE_SDTV,                                    //!< SDTV timing (including NTSC, PAL etc)
    LW_TIMING_TYPE_HDTV,                                    //!< HDTV timing (480p,480i,720p, 1080i etc)
}LWAPI_TIMING_TYPE;



//! \ingroup dispcontrol
//! Config on the specified display is not supported yet.
#define LW_DISP_INDEX_AUTO 0



//! \ingroup dispcontrol
//! The generic display target configuration info, independent of any specific mode. \n
//! Used in LwAPI_SetDisplaySettings() and LwAPI_GetDisplaySettings()
typedef struct 
{
    LwU32                   version;    //!<  Structure version

    LwU32                   device;     //!<  Target display ID or target device mask 
    LW_GPU_CONNECTOR_TYPE   connector;

    LwU32                   srcID;        //!<  The source display index

    LwU32                   srcImportance;   //!< (OUT) Indicates if this is the GPU's primary view target. This is not the desktop GDI primary.
                                             //!< LwAPI_SetDisplaySettings automatically selects the first target in LW_DISP_PATH index 0 as the GPU's primary view.
    
    // the source mode information
    LwU32                   width;      
    LwU32                   height;
    LwU32                   depth;
    LW_ROTATE               rotation;
    LW_FORMAT               colorFormat;       //!< Color format. Not used now.
  
    // the section of the source surface for scan out, defined in normalized desktop coordinates
    LW_VIEWPORTF            srcPartition;      // not used now

    // the scan out viewport in (at the front end, i.e. the compositor/CRTC).
    // defined in the normalized desktop coordinates
    LW_VIEWPORTF            viewportIn ;       // not used now

    // the scaling mode
    LW_SCALING              scaling;
    
    // the scan out viewport out (at the front end, i.e. the compositor/CRTC). 
    // this is for the future arbitrary scaling support (not supported by any the current GPUs)
    // defined in the normalized raster/backend timing coordinates
    // viewportOut is not supported yet, must be set to {0.0, 0.0, 0.0, 0.0}
    LW_VIEWPORTF            viewportOut;       // not used now

    // the backend (raster) timing standard
    LW_TIMING_OVERRIDE      timingOverride; 

    LwU32                   refreshRate;        //!< only used for backward compatible when LW_DISP_PATH_VER1 is specified
    LwU32                   interlaced    :1;   //!< only used for backward compatible when LW_DISP_PATH_VER1 is specified
    LwU32                   hwModeSetOnly :1;   //!< if this flag is set, the modeset is a pure h/w modeset without OS update. Only used with LW_DISP_PATH_VER;
    LwU32                   SelectLwstomTiming:1;    //!< For HD modes over DVI to select custom timings
    LwU32                   needNullModeset   :1;    //!< Read only - indicating a NULL modeset is needed on this monitor (for internal DP link training)
    LwU32                   need6x4Modeset    :1;    //!< Read only - indicating a 640x480x32 at 60Hz modeset is needed (for bad EDID on DP fallback)
    LwU32                   forceModeSet      :1;    //!< Used only on Win7 and higher during a call to LwAPI_SetDisplaySettings(). Turns off optimization & forces OS to set supplied mode.
    LwU32                   gpuId             :24;   //!< The display/target physical Gpu ID which is the owner of the scan out (for SLI multimon, display from the slave Gpu)
    LwU32                   isSliFolwsDisplay :1;    //!< this display path is the sli focus (so far it's read only)
    LwU32                   forceModeEnum     :1;    //!< Used only on Windows7 and higher during a call to LwAPI_SetDisplaySettings(). Requests a modeset after forced mode enumeration.

    LW_DISPLAY_TV_FORMAT    tvFormat;           //!<  Valid only on TV device. Set to 0 for other devices.
    LW_TIMING               timing;             //!<  The scan out timing, LW_DISP_PATH_VER2 only, ignored it's on analog TV.
} LW_DISP_PATH_V1;

//! \ingroup dispcontrol
typedef struct
{
    LwU32                   version;    //!< Structure version

    LwU32                   device;     //!< target display ids or target device mask
    LW_GPU_CONNECTOR_TYPE   connector;

    // the source display index
    LwU32                   srcID;

    // the source importance
    LwU32                   srcImportance; //!<(OUT) Indicates if this is the GPU's primary view target. This is not the desktop GDI primary.
                                           //!<LwAPI_SetDisplaySettings automatically selects the first target in LW_DISP_PATH index 0 as the GPU's primary view.
    // the source mode information
    LwU32                   width;
    LwU32                   height;
    LwU32                   depth;
    LW_ROTATE               rotation;
    LW_FORMAT               colorFormat;       //!< Color format. Not used now.

    // the section of the source surface for scan out, defined in normalized desktop coordinates
    LW_VIEWPORTF            srcPartition;      //!< Not used now.

    // the scan out viewport in (at the front end, i.e. the compositor/CRTC).
    // defined in the normalized desktop coordinates
    LW_VIEWPORTF            viewportIn ;       //!< Not used now.


    // the scaling mode
    LW_SCALING              scaling;

    // the scan out viewport out (at the front end, i.e. the compositor/CRTC).
    // this is for the future arbitrary scaling support (not supported by any the current GPUs)
    // defined in the normalized raster/backend timing coordinates
    // viewportOut is not supported yet, must be set to {0.0, 0.0, 0.0, 0.0}
    LW_VIEWPORTF            viewportOut;       // not used now

    // the backend (raster) timing standard
    LW_TIMING_OVERRIDE      timingOverride;

    LwU32                   refreshRate;        //!< Only used for backward compatible when LW_DISP_PATH_VER1 is specified.
    LwU32                   interlaced    :1;   //!< Only used for backward compatible when LW_DISP_PATH_VER1 is specified.
    LwU32                   hwModeSetOnly :1;   //!< If this flag is set, the modeset is a pure h/w modeset without OS update. Only used with LW_DISP_PATH_VER.
    LwU32                   SelectLwstomTiming:1;    //!< For HD modes over DVI to select custom timings.
    LwU32                   needNullModeset   :1;    //!< For read only - indicating a NULL modeset is needed on this monitor (for internal DP link training)
    LwU32                   need6x4Modeset    :1;    //!< For read only - indicating a 640x480x32bppx60Hz modeset is needed (for DP bad EDID fallback)
    LwU32                   forceModeSet      :1;    //!< Used only on Win7 and higher during a call to LwAPI_SetDisplaySettings. Turns off optimization & forces the OS to set supplied mode.
    LwU32                   gpuId             :24;   //!< The display/target physical GPU id which is the owner of the scan out (for SLI multimon, display from the slave GPU)
    LwU32                   isSliFolwsDisplay :1;    //!< This display path is the SLI focus (so far it's read only).
    LwU32                   forceModeEnum     :1;    //!< Used only on Win7 and higher during a call to LwAPI_SetDisplaySettings. Requests a modeset after forced mode enumeration.

    LW_DISPLAY_TV_FORMAT    tvFormat;           //!< Valid only on TV device. set to 0 for other devices.

    LW_TIMING               timing;             //!< The scan out timing, LW_DISP_PATH_VER2 only, ignored if it's on analog TV.
    
    LwU32                   refreshRate1K;      //!< Refresh rate reported to the OS.
} LW_DISP_PATH_V2;


//! \ingroup dispcontrol
typedef LW_DISP_PATH_V2 LW_DISP_PATH;


//! \addtogroup dispcontrol
//! Macros for constructing the version field of LW_DISP_PATH
//! @{
#define LW_DISP_PATH_VER3 MAKE_LWAPI_VERSION(LW_DISP_PATH_V1, 3)
#define LW_DISP_PATH_VER2 MAKE_LWAPI_VERSION(LW_DISP_PATH_V1, 2)
#define LW_DISP_PATH_VER1 MAKE_LWAPI_VERSION(LW_DISP_PATH_V1, 1)
#define LW_DISP_PATH_VER4 MAKE_LWAPI_VERSION(LW_DISP_PATH_V2, 4)

#define LW_DISP_PATH_VER  LW_DISP_PATH_VER4

//! @}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SetDisplaySettings
//
//!  This function sets the display settings for the selected display sources.
//!   \note Display PATH with this API is limited to a single GPU. DualView across GPUs cannot be enabled with this API. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 100
//!
//! \param [in]  hLwDisplay      LWPU Display selection \n
//!                              #LWAPI_DEFAULT_HANDLE is not allowed, it must be a handle enumerated with LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]  paths          Detailed target display arrangement for clone, span and edge blending display modes.
//! \param [in]  pathCount       Count of targets for the selected display source.
//!
//! \retval  LWAPI_OK                Completed request
//! \retval  LWAPI_ERROR             Miscellaneous error oclwrred.
//! \retval  LWAPI_ILWALID_ARGUMENT  Invalid input parameter
//! \retval  LWAPI_INCOMPATIBLE_STRUCT_VERSION  Incorrect struct version specified.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetDisplaySettings(LwDisplayHandle hLwDisplay, LW_DISP_PATH *paths, LwU32 pathCount);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_SetView
//
//! \fn LwAPI_SetView(LwDisplayHandle hLwDisplay, LW_VIEW_TARGET_INFO *pTargetInfo, LW_TARGET_VIEW_MODE targetView)
//!  This function lets the caller modify the target display arrangement of the selected source display handle in any lwiew mode.
//!  It can also modify or extend the source display in Dualview mode.
//!  \note Maps the selected source to the associated target Ids.
//!  \note Display PATH with this API is limited to single GPU. DUALVIEW across GPUs cannot be enabled with this API. 
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use LwAPI_DISP_SetDisplayConfig.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 90
//!
//! \param [in]  hLwDisplay       LWPU Display selection. #LWAPI_DEFAULT_HANDLE is not allowed, it has to be a handle enumerated with LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]  pTargetInfo      Pointer to array of LW_VIEW_TARGET_INFO, specifying device properties in this view.
//!                               The first device entry in the array is the physical primary.
//!                               The device entry with the lowest source id is the desktop primary.
//! \param [in]  targetCount      Count of target devices specified in pTargetInfo.
//! \param [in]  targetView       Target view selected from LW_TARGET_VIEW_MODE.
//!
//! \retval  LWAPI_OK               Completed request
//! \retval  LWAPI_ERROR            Miscellaneous error oclwrred
//! \retval  LWAPI_ILWALID_ARGUMENT Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dispcontrol
//! Used in LwAPI_SetView() and LwAPI_GetView()
typedef struct
{
    LwU32 version;     //!< (IN) structure version
    LwU32 count;       //!< (IN) target count
    struct 
    {
        LwU32 deviceMask;    //!< (IN/OUT) Device mask
        LwU32 sourceId;      //!< (IN/OUT) Source ID - values will be based on the number of heads exposed per GPU.
        LwU32 bPrimary:1;    //!< (OUT) Indicates if this is the GPU's primary view target. This is not the desktop GDI primary.
                             //!< LwAPI_SetView automatically selects the first target in LW_VIEW_TARGET_INFO index 0 as the GPU's primary view.
        LwU32 bInterlaced:1; //!< (IN/OUT) Indicates if the timing being used on this monitor is interlaced.
        LwU32 bGDIPrimary:1; //!< (IN/OUT) Indicates if this is the desktop GDI primary.
        LwU32 bForceModeSet:1;//!< (IN) Used only on Win7 and higher during a call to LwAPI_SetView(). Turns off optimization & forces OS to set supplied mode.
    } target[LWAPI_MAX_VIEW_TARGET];
} LW_VIEW_TARGET_INFO; 

//! \ingroup dispcontrol
#define LW_VIEW_TARGET_INFO_VER  MAKE_LWAPI_VERSION(LW_VIEW_TARGET_INFO,2)


//! \ingroup dispcontrol
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use LwAPI_DISP_SetDisplayConfig.")
LWAPI_INTERFACE LwAPI_SetView(LwDisplayHandle hLwDisplay, LW_VIEW_TARGET_INFO *pTargetInfo, LW_TARGET_VIEW_MODE targetView);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_SetViewEx
//
//!  \fn LwAPI_SetViewEx(LwDisplayHandle hLwDisplay, LW_DISPLAY_PATH_INFO *pPathInfo, LW_TARGET_VIEW_MODE displayView)
//!  This function lets caller to modify the display arrangement for selected source display handle in any of the lwiew modes.
//!  It also allows to modify or extend the source display in dualview mode.
//!   \note Maps the selected source to the associated target Ids.
//!   \note Display PATH with this API is limited to single GPU. DUALVIEW across GPUs cannot be enabled with this API. 
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use LwAPI_DISP_SetDisplayConfig.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 95
//!
//! \param [in]  hLwDisplay   LWPU Display selection. #LWAPI_DEFAULT_HANDLE is not allowed, it has to be a handle enumerated with 
//!                           LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]  pPathInfo    Pointer to array of LW_VIEW_PATH_INFO, specifying device properties in this view.
//!                           The first device entry in the array is the physical primary.
//!                           The device entry with the lowest source id is the desktop primary.
//! \param [in]  pathCount    Count of paths specified in pPathInfo.
//! \param [in]  displayView  Display view selected from LW_TARGET_VIEW_MODE.
//!
//! \retval  LWAPI_OK                Completed request
//! \retval  LWAPI_ERROR             Miscellaneous error oclwrred
//! \retval  LWAPI_ILWALID_ARGUMENT  Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dispcontrol
#define LWAPI_MAX_DISPLAY_PATH  LWAPI_MAX_VIEW_TARGET

//! \ingroup dispcontrol
#define LWAPI_ADVANCED_MAX_DISPLAY_PATH  LWAPI_ADVANCED_MAX_VIEW_TARGET



//! \ingroup dispcontrol
//! Used in LW_DISPLAY_PATH_INFO.
typedef struct
{
    LwU32                   deviceMask;     //!< (IN) Device mask
    LwU32                   sourceId;       //!< (IN) Values will be based on the number of heads exposed per GPU(0, 1?)
    LwU32                   bPrimary:1;     //!< (IN/OUT) Indicates if this is the GPU's primary view target. This is not the desktop GDI primary.
                                            //!< LwAPI_SetViewEx() automatically selects the first target in LW_DISPLAY_PATH_INFO index 0 as the GPU's primary view.
    LW_GPU_CONNECTOR_TYPE   connector;      //!< (IN) Specify connector type. For TV only.

    // source mode information
    LwU32                   width;          //!< (IN) Width of the mode
    LwU32                   height;         //!< (IN) Height of the mode
    LwU32                   depth;          //!< (IN) Depth of the mode
    LW_FORMAT               colorFormat;    //!<      Color format if it needs to be specified. Not used now.

    //rotation setting of the mode
    LW_ROTATE               rotation;       //!< (IN) Rotation setting.

    // the scaling mode
    LW_SCALING              scaling;        //!< (IN) Scaling setting

    // Timing info
    LwU32                   refreshRate;    //!< (IN) Refresh rate of the mode
    LwU32                   interlaced:1;   //!< (IN) Interlaced mode flag

    LW_DISPLAY_TV_FORMAT    tvFormat;       //!< (IN) To choose the last TV format set this value to LW_DISPLAY_TV_FORMAT_NONE

    // Windows desktop position
    LwU32                   posx;           //!< (IN/OUT) X-offset of this display on the Windows desktop
    LwU32                   posy;           //!< (IN/OUT) Y-offset of this display on the Windows desktop
    LwU32                   bGDIPrimary:1;  //!< (IN/OUT) Indicates if this is the desktop GDI primary.

    LwU32                   bForceModeSet:1;//!< (IN) Used only on Win7 and higher during a call to LwAPI_SetViewEx(). Turns off optimization & forces OS to set supplied mode.
    LwU32                   bFolwsDisplay:1;//!< (IN) If set, this display path should have the focus after the GPU topology change
    LwU32                   gpuId:24;       //!< (IN) the physical display/target Gpu id which is the owner of the scan out (for SLI multimon, display from the slave Gpu)

} LW_DISPLAY_PATH;

//! \ingroup dispcontrol
//! Used in LwAPI_SetViewEx() and LwAPI_GetViewEx().
typedef struct
{
    LwU32 version;     //!< (IN) Structure version
    LwU32 count;       //!< (IN) Path count
    LW_DISPLAY_PATH path[LWAPI_MAX_DISPLAY_PATH];
} LW_DISPLAY_PATH_INFO_V3; 

//! \ingroup dispcontrol
//! Used in LwAPI_SetViewEx() and LwAPI_GetViewEx().
typedef struct
{
    LwU32 version;     //!< (IN) Structure version
    LwU32 count;       //!< (IN) Path count
    LW_DISPLAY_PATH path[LWAPI_ADVANCED_MAX_DISPLAY_PATH];
} LW_DISPLAY_PATH_INFO; 

//! \addtogroup dispcontrol
//! Macro for constructing the version fields of LW_DISPLAY_PATH_INFO
//! @{
#define LW_DISPLAY_PATH_INFO_VER  LW_DISPLAY_PATH_INFO_VER4
#define LW_DISPLAY_PATH_INFO_VER4 MAKE_LWAPI_VERSION(LW_DISPLAY_PATH_INFO,4)
#define LW_DISPLAY_PATH_INFO_VER3 MAKE_LWAPI_VERSION(LW_DISPLAY_PATH_INFO,3)
#define LW_DISPLAY_PATH_INFO_VER2 MAKE_LWAPI_VERSION(LW_DISPLAY_PATH_INFO,2)
#define LW_DISPLAY_PATH_INFO_VER1 MAKE_LWAPI_VERSION(LW_DISPLAY_PATH_INFO,1)
//! @}


//! \ingroup dispcontrol
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use LwAPI_DISP_SetDisplayConfig.")
LWAPI_INTERFACE LwAPI_SetViewEx(LwDisplayHandle hLwDisplay, LW_DISPLAY_PATH_INFO *pPathInfo, LW_TARGET_VIEW_MODE displayView);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GetHDCPLinkParameters
//
//!    \fn LwAPI_GetHDCPLinkParameters(LwDisplayHandle hLwDisplay, LW_HDCP_INFO *pLwHdcpInfo
//!    This function enumerate fields within the LW_HDCP_INFO.
//!
//!    The API provides support for the HDCP Upstream Protocol. The caller is responsible to fill the input fields 
//!    within LW_HDCP_PACKET to ensure that the specified HDCP_COMMANDS can be fulfilled. Different HDCP_COMMANDS will 
//!    enumerate different fields inside LW_HDCP_INFO. The following are the HDCP_COMMANDS supported   
//!
//!    - (A) HDCP_CMD_QUERY_HEAD_CONFIG  : Enumerates ports attached to a head. 
//!    - (B) HDCP_CMD_READ_LINK_STATUS   : Reads the Status of the cipher returning a signed status and connection state. 
//!    - (C) HDCP_CMD_VALIDATE_LINK      : Returns the parameters necessary to validate the links for the specified attach-point.
//!    - (D) HDCP_CMD_RENEGOTIATE        : Forced renegotiation of the link.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [in]     hLwDisplay        LWPU Display selection. It should be a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]     pLwHdcpInfo       Pointer to LW_HDCP_INFO that contains the requested command and input parameters.
//!
//! \retval         LWAPI_OK                           Completed request
//! \retval         LWAPI_ERROR                        Miscellaneous error oclwrred.
//! \retval         LWAPI_ILWALID_ARGUMENT             pLwHdcpPacket is NULL.
//! \retval         LWAPI_INCOMPATIBLE_STRUCT_VERSION  The version of LW_HDCP_INFO struct is not supported.
//
///////////////////////////////////////////////////////////////////////////////


//! \addtogroup dispcontrol
//! @{

#define LWAPI_MAX_NUM_AP        16      //!< Max number of ports / attach points supported in HDCP Connection State
#define LWAPI_MAX_DEVICES       127     //!< Max number of Receiver & Repeater devices



//! Used in LW_HDCP_PACKET
typedef struct 
{
    union 
    {
        LwU32  data1;
        struct 
        {
            LwU8    revMin;
            LwU8    revMaj;
            LwU8    verMin;
            LwU8    verMaj;
        } ver;
    };
    LwU16 data2;
    LwU16 data3;
    LwU8  data4[8];
} LW_UID;


//! Used in LW_HDCP_PACKET
typedef struct 
{
#pragma pack(1)
    LwU64 uSessionID    : 37;   //!< [36:0] Random number
    LwU64 uDisplay      : 3;    //!< [39:37] O/S level display device
    LwU64 uReserved     : 24;   //!< [63:40] Reserved
#pragma pack()
} LW_HDCP_CN;


//! Used in LW_HDCP_PACKET
typedef struct 
{
    union 
    {
        LwU64   quadWord;
        struct 
        {
            LwU64 hugePart      : 40; // lower 40 in little endian
            LwU64 unusedPart    : 24;
        } parts;
    };
} LW_U40;


//! Used in LW_HDCP_PACKET
typedef struct
{
    union 
    {
        LwU64   quadWord;
        struct 
        {
            LwU64 hugePart      : 56; // lower 56 in little endian
            LwU64 unusedPart    : 8;
        } parts;
    };
} LW_U56;


//! Structure of data returned from monitor - as defined in HDCP Spec \n
//! Used in LW_HDCP_PACKET
typedef struct 
{
#pragma pack(1)
    LwU32 ucDeviceCount         : 7;    //!< [6:0] Total Receivers (except rep)
    LwU32 bMaxDevicesExceeded   : 1;    //!< [7] Topology Error > 127 devices 
    LwU32 bRepeaterDepth        : 3;    //!< [10:8] Repeater depth 
    LwU32 bMaxCascadeExceeded   : 1;    //!< [11] Topology Error > 7 levels repeater 
    LwU32 bHDMImode             : 1;    //!< [12] HDCP Receiver in HDMI mode
    LwU32 bReserved             : 19;   //!< [31:13] Reserved for future expansion
#pragma pack()
} LW_HDCP_BSTATUS;

//! The Connection State \n
//! Used in LW_HDCP_PACKET
typedef struct 
{
#pragma pack(1)
    LwU64 uAttachPoints         : 16;       //!< [15:0] Transmitting Attach Point    
    LwU64 bNonHDCP              : 1;        //!< [16] Transmitting Attach Point 
    LwU64 uHeadIndex            : 4;        //!< [20:17] Index of Head
    LwU64 uRFUPlanes            : 8;        //!< [28:21] *NOT* yet supported
    LwU64 uNumberOfActiveHeads  : 2;        //!< [30:29] Number of Heads - 1 
    LwU64 uReserved2            : 9;        //!< [39:31] Reserved for future use
    LwU64 uAttachedPlanes       : 8;        //!< [47:40] Will be moved to 28:21 in future chips
    LwU64 bCloneMode            : 1;        //!< [48] Dual-Display Clone Mode *NOT* yet supported
    LwU64 bSpanMode             : 1;        //!< [49] Dual-Display Span Mode *NOT* yet supported
    LwU64 reserved              : 14;       //!< [63:50] To fill up qword
#pragma pack()
} LW_HDCP_CS;

//! The Status of the Attach-Point (HDCP-capable or other) \n
//! Used in LW_HDCP_PACKET
typedef struct
{
#pragma pack(1)
    LwU64 bEncrypting           : 1;        //!<  [0] This Attach Point is Transmitting and has Output Encryption Enabled
    LwU64 bRepeater             : 1;        //!<  [1] This Attach Point is Transmitting to a Repeater 
    LwU64 bUserAccessible       : 1;        //!<  [2] This Attach Point is Transmitting on a user-accessible external digital port
    LwU64 bExtUnprotected       : 1;        //!<  [3] This Attach-point is Transmitting externally and is unprotected
    LwU64 uPortIndex            : 4;        //!<  [7:4] Port/Attach-point index
    LwU64 uNumPorts             : 4;        //!<  [11:8] Number of Connectable
    LwU64 bInternalPanel        : 1;        //!<  [12] Compliant Internal / Non-User accessible Port Panel without HDCP Encryption
    LwU64 bWideScope            : 1;        //!<  [13] Cs:16 is not enough to determine presence of non-compliant outputs+    (always '1')
    LwU64 bHasCs                : 1;        //!<  [14] Supports Connection State (always '1')
    LwU64 bReadZ                : 1;        //!<  [15] Supports ReadZ (always '0')
    LwU64 uReserved             : 24;       //!<  [39:16] Reserved for Future Expansion
    LwU64 bDualLinkEven         : 1;        //!<  [40] The Even half of a Dual-Link (0x74)
    LwU64 bDualLinkOdd          : 1;        //!<  [41] The Odd half of a Dual-Link (0x76)
    LwU64 bDualLinkCapable      : 1;        //!<  [42] This Attach Point has Dual-Link capability
    LwU64 reserved              : 21;       //!<  [63:43] To fill up qword
    LwU32 DisplayId;                        //!<  ID of the Display on this attach point
#pragma pack()
} LW_HDCP_STATUS; 

//! Flags used for indicating active member elements \n
//! Used in LW_HDCP_PACKET
typedef enum 
{
    LW_HDCP_FLAGS_NULL          = 0x00000000, //!< Get AP Status
    LW_HDCP_FLAGS_APINDEX       = 0x00000001, //!< Index of Attach Point
    LW_HDCP_FLAGS_AN            = 0x00000010, //!< Downstream Session ID
    LW_HDCP_FLAGS_AKSV          = 0x00000020, //!< Downstream/Xmtr KSV
    LW_HDCP_FLAGS_BKSV          = 0x00000040, //!< Downstream/Rcvr KSV
    LW_HDCP_FLAGS_BSTATUS       = 0x00000080, //!< Link/Repeater Status
    LW_HDCP_FLAGS_CN            = 0x00000100, //!< Upstream Session ID
    LW_HDCP_FLAGS_CKSV          = 0x00000200, //!< Upstream ClientApp KSV
    LW_HDCP_FLAGS_DKSV          = 0x00000400, //!< Upstream/Xmtr KSV
    LW_HDCP_FLAGS_KP            = 0x00001000, //!< Signature
    LW_HDCP_FLAGS_S             = 0x00002000, //!< Status 
    LW_HDCP_FLAGS_CS            = 0x00004000, //!< Connection State
    LW_HDCP_FLAGS_V             = 0x00010000, //!< V of the KSVList
    LW_HDCP_FLAGS_MP            = 0x00020000, //!< Encrypted initializer for KSV List
    LW_HDCP_FLAGS_BKSVLIST      = 0x00040000, //!< NumKsvs & BksvList[NumKsvs]
    LW_HDCP_FLAGS_DUAL_LINK     = 0x00100000, //!< Two sets of An, Aksv, Kp, Bksv, Dksv
    LW_HDCP_FLAGS_ALWAYS_AUTH   = 0x00200000, //!< Always authenticate
    LW_HDCP_FLAGS_ON_BY_DEMAND  = 0x00000000, //!< Authenticate on demand
    LW_HDCP_FLAGS_ABORT_UNTRUST = 0x00400000, //!< Abort, Kp didn't match
    LW_HDCP_FLAGS_ABORT_UNRELBL = 0x00800000, //!< Abort, Repeated Link Failures
    LW_HDCP_FLAGS_ABORT_KSV_LEN = 0x01000000, //!< Abort, incorrect KSV Length
    LW_HDCP_FLAGS_ABORT_KSV_SIG = 0x02000000, //!< Abort, bad KSV Signature
    LW_HDCP_FLAGS_ABORT_SRM_SIG = 0x04000000, //!< Abort, bad SRM Signature
    LW_HDCP_FLAGS_ABORT_SRM_REV = 0x08000000, //!< Abort due to SRM Revocation
    LW_HDCP_FLAGS_ABORT_NORDY   = 0x10000000, //!< Abort, Repeater Not Ready
    LW_HDCP_FLAGS_ABORT_KSVTOP  = 0x20000000, //!< Abort, KSV Topology Error
    LW_HDCP_FLAGS_ABORT_BADBKSV = 0x40000000, //!< Abort due to invalid Bksv
} LW_HDCP_FLAGS;

//! HDCP Commands \n
//! Used in LW_HDCP_PACKET
typedef enum 
{
    LW_HDCP_CMD_NULL               = 0x00, //!< Null command
    LW_HDCP_CMD_QUERY_HEAD_CONFIG  = 0x01, //!< Status of the head attach-points
    LW_HDCP_CMD_READ_LINK_STATUS   = 0x02, //!< Get the Status 
    LW_HDCP_CMD_VALIDATE_LINK      = 0x03, //!< Gets M & V 
    LW_HDCP_CMD_RENEGOTIATE        = 0x04, //!< Forced renegotiation of the link
    LW_HDCP_CMD_ABORTAUTHENTICATION= 0x05, //!< Abort authentication protocol
    LW_HDCP_CMD_SETLINKPOLICY      = 0x06, //!< Set the link policy  
} LW_HDCP_COMMANDS;


//! HDCP Return Status \n
//! Used in LW_HDCP_PACKET 
typedef enum 
{
    LW_HDCP_STATUS_SUCCESS                 = (0x00000000L), //!< Function completed successfully
    LW_HDCP_STATUS_UNSUCCESSFUL            = (0xC0000001L), //!< Function failed
    LW_HDCP_STATUS_PENDING                 = (0x00000103L), //!< Renegotiation is not complete, check status later
    LW_HDCP_STATUS_LINK_FAILED             = (0xC000013EL), //!< Renegotiation could not complete
    LW_HDCP_STATUS_ILWALID_PARAMETER       = (0xC000000DL), //!< One or more of the calling parameters was invalid
    LW_HDCP_STATUS_ILWALID_PARAMETER_MIX   = (0xC0000030L), //!< The combination of flFlags was invalid
    LW_HDCP_STATUS_NO_MEMORY               = (0xC0000017L), //!< Insufficient buffer space was allocated. Re-allocate using the size returned in the dwSize member
    LW_HDCP_STATUS_BAD_TOKEN_TYPE          = (0xC00000A8L), //!< The Session ID &/or KSV supplied were rejected
} LW_HDCP_RET_STATUS;


//! HDCP Packet \n
//! Used in LW_HDCP_INFO
typedef struct 
{
#pragma pack(4)
    LW_UID              uidHDCP;                        //!<  (IN) 
    LwU32               packetSize;                     //!<  (IN/OUT)
    LwU32               hDisplayContext;                //!<  (IN/OUT) 
    LW_HDCP_COMMANDS    cmdCommand;                     //!<  (IN)
    LW_HDCP_FLAGS       flFlags;                        //!<  (IN/OUT) 
    LW_HDCP_RET_STATUS  hdcpPacketStatus;               //!<  (OUT)

    LwU32               apIndex;                        //!<  (IN) Attach point index
    LW_HDCP_CN          cN;                             //!<  (IN) Client Session ID
    LW_U40              cKsv;                           //!<  (IN)

    LW_HDCP_BSTATUS     bStatus[LWAPI_MAX_NUM_AP];      //!<  (OUT) 
    LW_HDCP_STATUS      hdcpStatus[LWAPI_MAX_NUM_AP];   //!<  (OUT)
    LW_HDCP_CS          cS;                             //!<  (OUT) Connection State
         
    LW_U56              kP[2];                          //!<  (OUT) KPRIME value
    LW_U40              aN[2];                          //!<  (OUT)
    LW_U40              aKsv[2];                        //!<  (OUT)
    LW_U40              dKsv[2];                        //!<  (OUT) 
    LwU8                vP[20];                         //!<  (OUT) VPRIME value
    LwU64               mP;                             //!<  (OUT) MPRIME value
    LwU32               numBKSVs;                       //!<  (OUT) Valid KSVs in the bKsvList. Maximum is 127 devices 
    LW_U40              bKsvList[LWAPI_MAX_DEVICES];    //!<  (OUT) Up to 127 receivers & repeaters
#pragma pack()
} LW_HDCP_PACKET;

//! Used in LwAPI_GetHDCPLinkParameters()
typedef struct
{
    LwU32 version;
    LW_HDCP_PACKET lwHdcpPacket;
} LW_HDCP_INFO;

#define LW_HDCP_INFO_VER  MAKE_LWAPI_VERSION(LW_HDCP_INFO,1)

//! @}


//! \ingroup dispcontrol
LWAPI_INTERFACE LwAPI_GetHDCPLinkParameters(LwDisplayHandle hLwDisplay, LW_HDCP_INFO *pLwHdcpInfo);





//! \ingroup hybridapi
#define LWAPI_MAX_3D_Apps 128

//! \ingroup hybridapi
//! Structure to get application processIds and processNames. \n
//! Used in LwAPI_QueryNonMigratableApps(). 
typedef struct
{
  LwU32 version;    //!< Structure version
  LwU32 processId;
  LwAPI_ShortString   processName;
}LW_3D_APP_INFO_V1;

typedef struct
{
  LwU32 version;    // Structure version
  LwU32 processId;
  LwAPI_LongString   processName;
} LW_3D_APP_INFO_V2;

typedef LW_3D_APP_INFO_V2     LW_3D_APP_INFO;



//! \ingroup hybridapi
//! Used in LW_3D_APP_INFO.
//! Macro for constructing the version field of LW_3D_APP_INFO
//! @{
#define LW_3D_APP_INFO_VER_1  MAKE_LWAPI_VERSION(LW_3D_APP_INFO_V1,1)
#define LW_3D_APP_INFO_VER_2  MAKE_LWAPI_VERSION(LW_3D_APP_INFO_V2,2)
#define LW_3D_APP_INFO_VER    LW_3D_APP_INFO_VER_2
//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_QueryNonMigratableApps
//
//!  This function queries all non-migratable applications which block successful driver reload such 
//!  as for SLI or Hybrid transitions.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 173
//!
//! \param [in,out]  apps       Empty structure passed as an input and upon successful exit, 
//!                             contains a list of non-migratable applications and processIDs.
//! \param [in,out]  total      Total number of non-migratable applications lwrrently running in the system.
//! 
//! \retval          LWAPI_OK                 Completed request
//! \retval          LWAPI_ERROR              Miscellaneous error oclwrred
//! \retval          LWAPI_ILWALID_ARGUMENT   Invalid input parameter
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_QueryNonMigratableApps(LW_3D_APP_INFO apps[LWAPI_MAX_3D_Apps], LwU32 *total);




#ifndef LW_PAN_AND_SCAN_DEFINED
#define LW_PAN_AND_SCAN_DEFINED
#endif


///////////////////////////////////////////////////////////////////////////////
// SetDisplayConfig/GetDisplayConfig
///////////////////////////////////////////////////////////////////////////////
//! \ingroup dispcontrol

typedef struct _LW_POSITION
{
    LwS32   x;
    LwS32   y;
} LW_POSITION;

//! \ingroup dispcontrol
typedef struct _LW_RESOLUTION
{
    LwU32   width;
    LwU32   height;
    LwU32   colorDepth;
} LW_RESOLUTION;

//! \ingroup dispcontrol
typedef struct _LW_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1
{
    LwU32                   version;

    // Rotation and Scaling
    LW_ROTATE               rotation;       //!< (IN) rotation setting.
    LW_SCALING              scaling;        //!< (IN) scaling setting.

    // Refresh Rate
    LwU32                   refreshRate1K;  //!< (IN) Non-interlaced Refresh Rate of the mode, multiplied by 1000, 0 = ignored
                                            //!< This is the value which driver reports to the OS.
    // Flags
    LwU32                   interlaced:1;   //!< (IN) Interlaced mode flag, ignored if refreshRate == 0
    LwU32                   primary:1;      //!< (IN) Declares primary display in clone configuration. This is *NOT* GDI Primary.
                                            //!< Only one target can be primary per source. If no primary is specified, the first 
                                            //!< target will automatically be primary.
#ifdef LW_PAN_AND_SCAN_DEFINED 
    LwU32                   isPanAndScanTarget:1; //!< Whether on this target Pan and Scan is enabled or has to be enabled. Valid only 
                                                  //!< when the target is part of clone topology.
    LwU32                   reserved:29;  
#else
    LwU32                   reserved:30;  
#endif
    // TV format information
    LW_GPU_CONNECTOR_TYPE   connector;      //!< Specify connector type. For TV only, ignored if tvFormat == LW_DISPLAY_TV_FORMAT_NONE
    LW_DISPLAY_TV_FORMAT    tvFormat;       //!< (IN) to choose the last TV format set this value to LW_DISPLAY_TV_FORMAT_NONE
                                            //!< In case of LwAPI_DISP_GetDisplayConfig(), this field will indicate the lwrrently applied TV format;
                                            //!< if no TV format is applied, this field will have LW_DISPLAY_TV_FORMAT_NONE value.
                                            //!< In case of LwAPI_DISP_SetDisplayConfig(), this field should only be set in case of TVs; 
                                            //!< for other displays this field will be ignored and resolution & refresh rate specified in input will be used to apply the TV format.

    // Backend (raster) timing standard
    LW_TIMING_OVERRIDE      timingOverride;     //!< Ignored if timingOverride == LW_TIMING_OVERRIDE_LWRRENT
    LW_TIMING               timing;             //!< Scan out timing, valid only if timingOverride == LW_TIMING_OVERRIDE_LWST
                                                //!< The value LW_TIMING::LW_TIMINGEXT::rrx1k is obtained from the EDID. The driver may 
                                                //!< tweak this value for HDTV, stereo, etc., before reporting it to the OS. 
} LW_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1;

//! \ingroup dispcontrol
typedef LW_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1 LW_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO;

//! \ingroup dispcontrol
#define LW_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_VER1     MAKE_LWAPI_VERSION(LW_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1,1)

//! \ingroup dispcontrol
#define LW_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_VER      LW_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_VER1

//! \ingroup dispcontrol
typedef struct _LW_DISPLAYCONFIG_PATH_TARGET_INFO_V1
{
    LwU32                                           displayId;  //!< Display ID
    LW_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO*     details;    //!< May be NULL if no advanced settings are required. NULL for Non-LWPU Display.
} LW_DISPLAYCONFIG_PATH_TARGET_INFO_V1;

//! \ingroup dispcontrol
typedef struct _LW_DISPLAYCONFIG_PATH_TARGET_INFO_V2
{
    LwU32                                           displayId;  //!< Display ID
    LW_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO*     details;    //!< May be NULL if no advanced settings are required
    LwU32                                           targetId;   //!< Windows CCD target ID. Must be present only for non-LWPU adapter, for LWPU adapter this parameter is ignored.
} LW_DISPLAYCONFIG_PATH_TARGET_INFO_V2;


//! \ingroup dispcontrol
//! As version is not defined for this structure, we will be using version of LW_DISPLAYCONFIG_PATH_INFO
typedef LW_DISPLAYCONFIG_PATH_TARGET_INFO_V2 LW_DISPLAYCONFIG_PATH_TARGET_INFO; 


//! \ingroup dispcontrol
typedef enum _LW_DISPLAYCONFIG_SPANNING_ORIENTATION
{
    LW_DISPLAYCONFIG_SPAN_NONE          = 0,
    LW_DISPLAYCONFIG_SPAN_HORIZONTAL    = 1,
    LW_DISPLAYCONFIG_SPAN_VERTICAL      = 2,
} LW_DISPLAYCONFIG_SPANNING_ORIENTATION;

//! \ingroup dispcontrol
typedef struct _LW_DISPLAYCONFIG_SOURCE_MODE_INFO_V1
{
    LW_RESOLUTION                           resolution;
    LW_FORMAT                               colorFormat;                //!< Ignored at present, must be LW_FORMAT_UNKNOWN (0)
    LW_POSITION                             position;                   //!< Is all positions are 0 or invalid, displays will be automatically
                                                                        //!< positioned from left to right with GDI Primary at 0,0, and all
                                                                        //!< other displays in the order of the path array.
    LW_DISPLAYCONFIG_SPANNING_ORIENTATION   spanningOrientation;        //!< Spanning is only supported on XP
    LwU32                                   bGDIPrimary : 1;
    LwU32                                   bSLIFolws : 1;
    LwU32                                   reserved : 30;              //!< Must be 0
} LW_DISPLAYCONFIG_SOURCE_MODE_INFO_V1;

//! \ingroup dispcontrol
//! As version is not defined for this structure we will be using version of LW_DISPLAYCONFIG_PATH_INFO
typedef LW_DISPLAYCONFIG_SOURCE_MODE_INFO_V1 LW_DISPLAYCONFIG_SOURCE_MODE_INFO; 

//! \ingroup dispcontrol
typedef struct _LW_DISPLAYCONFIG_PATH_INFO_V1
{
    LwU32                                   version;
    LwU32                                   reserved_sourceId;          //!< This field is reserved. There is ongoing debate if we need this field.
                                                                        //!< Identifies sourceIds used by Windows. If all sourceIds are 0, 
                                                                        //!< these will be computed automatically.
    LwU32                                   targetInfoCount;            //!< Number of elements in targetInfo array
    LW_DISPLAYCONFIG_PATH_TARGET_INFO_V1*   targetInfo;
    LW_DISPLAYCONFIG_SOURCE_MODE_INFO*      sourceModeInfo;             //!< May be NULL if mode info is not important
} LW_DISPLAYCONFIG_PATH_INFO_V1;

//! \ingroup dispcontrol
//! This define is temporary and must be removed once DVS failure is fixed.
#define _LW_DISPLAYCONFIG_PATH_INFO_V2 _LW_DISPLAYCONFIG_PATH_INFO

//! \ingroup dispcontrol
typedef struct _LW_DISPLAYCONFIG_PATH_INFO_V2
{
    LwU32                                   version;
    union {
        LwU32                                   sourceId;               //!< Identifies sourceId used by Windows CCD. This can be optionally set.
        LwU32                                   reserved_sourceId;      //!< Only for compatibility
    };

    LwU32                                   targetInfoCount;            //!< Number of elements in targetInfo array
    LW_DISPLAYCONFIG_PATH_TARGET_INFO*      targetInfo;
    LW_DISPLAYCONFIG_SOURCE_MODE_INFO*      sourceModeInfo;             //!< May be NULL if mode info is not important
    LwU32                                   IsNonLWIDIAAdapter : 1;     //!< True for non-LWPU adapter.
    LwU32                                   reserved : 31;              //!< Must be 0
    void                                    *pOSAdapterID;              //!< Used by Non-LWPU adapter for pointer to OS Adapter of LUID 
                                                                        //!< type, type casted to void *.
} LW_DISPLAYCONFIG_PATH_INFO_V2;

//! \ingroup dispcontrol
typedef LW_DISPLAYCONFIG_PATH_INFO_V2 LW_DISPLAYCONFIG_PATH_INFO;

//! \ingroup dispcontrol
#define LW_DISPLAYCONFIG_PATH_INFO_VER1                 MAKE_LWAPI_VERSION(LW_DISPLAYCONFIG_PATH_INFO_V1,1)

//! \ingroup dispcontrol
#define LW_DISPLAYCONFIG_PATH_INFO_VER2                 MAKE_LWAPI_VERSION(LW_DISPLAYCONFIG_PATH_INFO_V2,2)

//! \ingroup dispcontrol
#define LW_DISPLAYCONFIG_PATH_INFO_VER                  LW_DISPLAYCONFIG_PATH_INFO_VER2

//! \ingroup dispcontrol
typedef enum _LW_DISPLAYCONFIG_FLAGS
{
    LW_DISPLAYCONFIG_VALIDATE_ONLY          = 0x00000001,
    LW_DISPLAYCONFIG_SAVE_TO_PERSISTENCE    = 0x00000002, 
    LW_DISPLAYCONFIG_DRIVER_RELOAD_ALLOWED  = 0x00000004,               //!< Driver reload is permitted if necessary
    LW_DISPLAYCONFIG_FORCE_MODE_ENUMERATION = 0x00000008,               //!< Refresh OS mode list.
} LW_DISPLAYCONFIG_FLAGS;


#define LWAPI_UNICODE_STRING_MAX                             2048
#define LWAPI_BINARY_DATA_MAX                                4096

typedef LwU16 LwAPI_UnicodeString[LWAPI_UNICODE_STRING_MAX];
typedef const LwU16 *LwAPI_LPCWSTR;

//! \addtogroup sysevent
//! @{

//! Event IDs. Used in \ref LW_EVENT.
typedef enum
{
    LW_EVENT_ID_DIAG, 
    LW_EVENT_ID_ACPI_HOTKEY, 
    LW_EVENT_ID_POWER_CONNECTOR, 
    LW_EVENT_ID_THERMAL,
    LW_EVENT_ID_DRIVER_RECONNECTED,
    LW_EVENT_ID_HYBRID_DUALVIEW_FAIL_ATTACH,
    LW_EVENT_ID_HYBRID_CHANGE_STATE, 
    LW_EVENT_ID_HYBRID_NOTIFY_TRIGGER_RECOMMANDVIDPN, 
    LW_EVENT_ID_HYBRID_NOTIFY_TRIGGER_POLL_CHILD_CONNECT,
    LW_EVENT_ID_HYBRID_NEXTDISPLAY_STATE,
    LW_EVENT_ID_HYBRID_NOTIFY_TRIGGER_GET_DGPU_EDIDS,
    LW_EVENT_ID_HYBRID_NOTIFY_LIGHTWEIGHT_STATE,
    LW_EVENT_ID_HYBRID_NOTIFY_HIDE_HEADS,
    LW_EVENT_ID_HYBRID_MUX_DEVICE_HOTPLUG,
    LW_EVENT_ID_NULL_MODESET,
    LW_EVENT_ID_BAD_EDID_MODESET,
    LW_EVENT_ID_SLI_SWAP_MASTER_GPU,
    LW_EVENT_ID_PSTATE_CHANGE,
    LW_EVENT_ID_HYBRID_WIN7_HOTPLUG_POWERUP_DGPU,           //!< Win7 hotplug of dgpu monitor on montevina hybrid when no other external monitor is connected.
                                                            //! CCD always lights up the hotplugged monitor. Hence always transition to perf mode in this
                                                            //! scenario. No topology or resolution is specified.
    LW_EVENT_ID_HYBRID_WIN7_HOTKEY_TOPOLOGY_POWERUP_DGPU,   //!< Win7 hotkey switches on montevina hybrid. Power up dgpu if needed and switch to specifed topology.
    LW_EVENT_ID_OVERLAY_FAILURE,
    LW_EVENT_ID_GSYNC,
    LW_EVENT_ID_HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU,     //!< Win7 MSPanel switches with DGPU monitors. Also used for CCD induced modesets for hotplug
                                                            //! when there is at least one other external monitor already connected. The topology and 
                                                            //! resolution + depth + refresh rate is specified.
    LW_EVENT_ID_PINNED_SURFACE_ALLOC,                       //!< Requests lwsvc to create or free an allocation on behalf of KMD        
    LW_EVENT_ID_PINNED_SURFACE_FREE,
    LW_EVENT_ID_COPROC_POWER_REF_COUNT,                     //!< For Coproc/Gplex/Carlsbad - broadcast when safe/unsafe to power down this adapter.
    LW_EVENT_ID_HYBRID_DGPU_EVENT,                          //!< GPIO event when DeepIdle cannot occur because PMU state stays high.
    LW_EVENT_ID_RESUME_FROM_HIBERNATION_COMMIT_VIDPN_DONE,  //!< Deprecated - Use LW_EVENT_ID_COMMIT_VIDPN_DONE. 
                                                            //! Was used to notify lwsvc for LDDM_CommitVidPn done when resume from hibernation (bug 579496)
    LW_EVENT_ID_RESUME_FROM_STANDBY_COMMIT_VIDPN_DONE,      //!< Deprecated - Use LW_EVENT_ID_COMMIT_VIDPN_DONE. 
                                                            //! Was used to notify lwsvc for LDDM_CommitVidPn done when resume from standby (bug 606410)
    LW_EVENT_ID_VMODE,                                      //!< Sent when entering/leaving virtual mode.  See NEC LUI project
    LW_EVENT_ID_COPROC_RESOLUTION_LIMIT_CHANGED,            //!< For Coproc - broadcast when desktop resolution size limit changed.
    LW_EVENT_ID_COPROC_HOTKEY_NEXT_MDTL_INDEX_TO_LWSVC,     //!< notify lwsvc that Hotkey event has oclwred and send the next mdtl index.
    LW_EVENT_ID_DEPRECATED_01,                              //!< Deprecated - was used to notify lwsvc that a commit oclwred on IDM head.
    LW_EVENT_ID_PHYSX_ILWALID_CONFIG,                       //!< Notify PhysX of invalid config
    LW_EVENT_ID_FAN_SPEED_CHANGE,                           //!< Notify for fanSpeed change
    LW_EVENT_ID_THERMAL_CHANGE,                             //!< Notify for Thermal change
    LW_EVENT_ID_HCLONE_SET_SURFACE_INFO_AND_MODESET,        //!< Notify when DD is waiting for LWL_ESC_ID_COMMON_HCLONE_SET_SURFACE_INFO_AND_MODESET escape to 
                                                            //!< be called after capture surface setup. This event will be fired by DD when client sets HCLONE
                                                            //!< topology using LWL_ESC_ID_COMMON_HCLONE_SET_TOPOLOGY.
    LW_EVENT_ID_COLOR_PROFILE_CHANGE,                       //!< Notify for Colorspace Profile updates
    LW_EVENT_ID_COPROC_FORCE_GPU_SWITCH,                    //!< Notify for IGPU or DGPU hw switch setting
    LW_EVENT_ID_DISPLAYPORT_TOPOLOGY_CHANGED,               //!< Notify something has changed in the displayport topology
    LW_EVENT_ID_COPROC_POWER_STATE_CHANGE,                  //!< Notify coproc power state change
    LW_EVENT_ID_HOTKEY_TOPOLOGY_CHANGE,                     //!< Notify ACPI Hotkey topology change event.
    LW_EVENT_ID_MONITOR_CONNECTION_STATUS_CHANGE,           //!< Lwrrently used to notify lwsvc in case when SLIMM2.0 is not supported and device is hotplugged/unplugged on slave GPU.
    LW_EVENT_ID_GC5_STATE_CHANGE,                           //!< Broadcast GC5 state change (GC5 armed or disarmed)
    LW_EVENT_ID_COMMIT_VIDPN_DONE,                          //!< notify lwsvc for LDDM_CommitVidPn done (bug 1254137)
    LW_EVENT_ID_GC6_NOTIFY_STATE_CHANGE,                    //!< GC6 State Change Event for GPU logging feature during GC6 state change
    LW_EVENT_ID_LWRSOR_SHAPE_CHANGE,                        //!< Cursor shape change event.
    LW_EVENT_ID_DESKTOP_REDRAW_REQUEST,                     //!< notify lwsvc for LDDM_CommitVidPn done (bug 1254137)
    LW_EVENT_ID_REQUEST_FORCED_TDR,                         //!< Event specifying that the GPU is in bad state & need to be TDRed to be able to function properly.
} LW_EVENT_ID;


//! Additional Information Block IDs used in \ref LW_EVENT.
typedef enum 
{
    LW_EVENT_BLOCK_ID_NONE,                                         //!< No associated data block for this event
    LW_EVENT_BLOCK_ID_ACPI,                                         //!< ACPI hotkey display change event block
    LW_EVENT_BLOCK_ID_HYBRID_CHANGE_STATE,                          //!< ACPI hybrid transition
    LW_EVENT_BLOCK_ID_HYBRID_NEXTDISPLAY_STATE,                     //!< Hot-key toggle sequence
    LW_EVENT_BLOCK_ID_HYBRID_NOTIFY_LIGHTWEIGHT_STATE,              //!< Notify state of lightweight startup
    LW_EVENT_BLOCK_ID_HYBRID_DIAG_NOTIFY,                           //!< ACPI DIAG notification
    LW_EVENT_BLOCK_ID_HYBRID_CHANGE_STATE_V2,                       //!< ACPI hybrid transition
    LW_EVENT_BLOCK_ID_HYBRID_MUX_DEVICE_HOTPLUG_NOTIFY,             //!< Device hotplug notifications
    LW_EVENT_BLOCK_ID_PSTATE_CHANGE,                                //!< P-state change event block
    LW_EVENT_BLOCK_ID_HYBRID_WIN7_HOTKEY_TOPOLOGY_POWERUP_DGPU,
    LW_EVENT_BLOCK_ID_OVERLAY_FAILURE,                              //!< KMD overlay creation failure due to IMP etc.
    LW_EVENT_BLOCK_ID_GSYNC,                                        //!< G-Sync notifications  
    LW_EVENT_BLOCK_ID_HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU,
    LW_EVENT_BLOCK_ID_PINNED_SURFACE_ALLOC,                         //!< Request for a pinned surface from KMD
    LW_EVENT_BLOCK_ID_PINNED_SURFACE_FREE,    
    LW_EVENT_BLOCK_ID_COPROC_POWER_REF_COUNT,
    LW_EVENT_BLOCK_ID_HYBRID_DGPU_EVENT,                            //!< See ::LW_EVENT_ID_HYBRID_DGPU_EVENT
    LW_EVENT_BLOCK_ID_VMODE,                                        //!< See ::LW_EVENT_ID_VMODE
    LW_EVENT_BLOCK_ID_COPROC_RESOLUTION_LIMIT_CHANGED,              //!< See ::LW_EVENT_ID_COPROC_RESOLUTION_LIMIT_CHANGED
    LW_EVENT_BLOCK_ID_COPROC_HOTKEY_NEXT_MDTL_INDEX_TO_LWSVC,       //!< See ::LW_EVENT_ID_COPROC_HOTKEY_MDTL_NEXT_INDEX_TO_LWSVC
    LW_EVENT_BLOCK_ID_PHYSX_ILWALID_CONFIG,                         //!< See ::LW_EVENT_ID_PHYSX_ILWALID_CONFIG
    LW_EVENT_BLOCK_ID_FAN_SPEED_CHANGE,                             //!< See ::LW_EVENT_ID_FAN_SPEED_CHANGE
    LW_EVENT_BLOCK_ID_THERMAL_CHANGE,                               //!< See ::LW_EVENT_ID_THERMAL_CHANGE
    LW_EVENT_BLOCK_ID_COLOR_PROFILE_CHANGE,                         //!< See ::LW_EVENT_ID_COLOR_PROFILE_CHANGE
    LW_EVENT_BLOCK_ID_COPROC_FORCE_GPU_SWITCH,                      //!< Force IGPU or DGPU hardware switch notification
    LW_EVENT_BLOCK_ID_DISPLAYPORT_TOPOLOGY_CHANGED,                 //!< See ::LW_EVENT_ID_DISPLAYPORT_TOPOLOGY_CHANGED
    LW_EVENT_BLOCK_ID_SET_SURFACE_INFO_AND_MODESET,                 //!< See ::LW_EVENT_ID_SET_SURFACE_INFO_AND_MODESET
    LW_EVENT_BLOCK_ID_COPROC_POWER_STATE_CHANGE,                    //!< See ::LW_EVENT_ID_COPROC_POWER_STATE_CHANGE
    LW_EVENT_BLOCK_ID_HOTKEY_TOPOLOGY_CHANGE,                       //!< Will come under LW_EVENT_ID_HOTKEY_TOPOLOGY_CHANGE, see LW_EVENT_BLOCK_HOTKEY_TOPOLOGY_DATA structre.
    LW_EVENT_BLOCK_ID_MONITOR_CONNECTION_STATUS_CHANGE,             //!< Block data used for event LW_EVENT_MONITOR_CONNECTION_STATUS_CHANGE
    LW_EVENT_BLOCK_ID_GC5_STATE_CHANGE,                             //!< see LW_EVENT_ID_COPROC_EXIT_GC5
    LW_EVENT_BLOCK_ID_COMMIT_VIDPN_DONE,                            //!< see ::LW_EVENT_ID_COMMIT_VIDPN_DONE
    LW_EVENT_BLOCK_ID_GC6_NOTIFY_STATE_CHANGE,                      //!< see LW_EVENT_ID_GC6_NOTIFY_STATE_CHANGE
    LW_EVENT_BLOCK_ID_DESKTOP_REDRAW_REQUEST,                       //!< see ::LW_EVENT_ID_DESKTOP_REDRAW_REQUEST
    LW_EVENT_BLOCK_ID_REQUEST_FORCED_TDR,                           //!< see ::LW_EVENT_ID_REQUEST_FORCED_TDR
} LW_EVENT_BLOCK_ID;



//! Core LW_EVENT structure declaration: Used \ref LW_EVENT_CALLBACK. 
typedef struct
{
    LwU32 cbSize;                 //!< Size of the buffer, include both header and extra data
    LwU32 version;                //!< Version field to ensure minimum version compatibility
    LwU32 cbBlockOffset;          //!< Offset from the beginning of LW_EVENT to LW_EVENT_BLOCK, in bytes
    LW_EVENT_ID EventId;          //!< ID of the event being sent
    LW_EVENT_BLOCK_ID BlockId;    //!< Type ID for LW_EVENT_BLOCK structure
    union
    {
        LwPhysicalGpuHandle PhysicalGpu;  //!< This field will become Physical GPU handle during the PopEvent
                                          //!< by LwApiEscape.cpp
        LwU32 Reserved32;         //!< This field is to ensure proper sizing with the driver.
        LwU64 Reserved64;         //!< This field is to ensure proper sizing with the driver.
    };
} LW_EVENT, *PLW_EVENT;



#define LW_EVENT_VERSION        MAKE_LWAPI_VERSION(LW_EVENT,1)



//! ACPI hotkey LW_EVENT structure declaration: Used in \ref LW_EVENT_BLOCK_ID.
typedef struct
{
    LwU32                  ulIlwalidatedDeviceMask;  //!< The display devices to switch to after the event 
    LwU32                  ulConnectedDeviceMask;    //!< The display devices that are lwrrently connected
    LW_TARGET_VIEW_MODE    config;                   //!< The expected configuration for the new set of devices
} LW_EVENT_BLOCK_ACPI, *PLW_EVENT_BLOCK_ACPI;


//---------------------------------------------------------------------------------
//! Structures for LW_EVENT_BLOCK_ID_HOTKEY_TOPOLOGY.

typedef struct 
{
    LwU32   srcID;                 //!< A number that will help to decide the view with multiple paths/targets. 
                                   //!< This srcID will use just to figure the topology it is not actual sourceID used in driver. 
    union 
    {
        LwU32 targetID;            //!< Target id of the display attached to non-Lwpu GPU.
        LwU32 displayID;           //!< Display Id of the display attached to Lwpu GPU.
    };
    LwU32     isNonLWPath : 1;     //!< If 1 then it is Non-Lwpu path else it is Lwpu path.
    LwU32     reserved    : 31;    //!< Reserved.
}PATH_INFO, *PPATH_INFO;

typedef struct
{
    LwU32        pathCount;        //!< Number of elements in the pathInfo array.
    PATH_INFO    pathInfo[LWAPI_MAX_DISPLAYS]; //!< Array of PATH_INFO structure of length LWAPI_MAX_DISPLAYS.
}LW_EVENT_BLOCK_HOTKEY_TOPOLOGY_DATA, *PLW_EVENT_BLOCK_HOTKEY_TOPOLOGY_DATA;

#define LW_ILWALID_SRC_ID    -1    //!< Invalid source ID.

//---------------------------------------------------------------------------------

//! Used in (TBD).
typedef struct _LW_EVENT_BLOCK_HYBRID_CHANGE_STATE
{
    LwU32    hybridState;     //!< Hybrid Transition state requested from the system BIOS 
                              //!   - 1 means iGPU mode
                              //!   - 2 means dGPU mode
} LW_EVENT_BLOCK_HYBRID_CHANGE_STATE, *PLW_EVENT_BLOCK_HYBRID_CHANGE_STATE;




typedef struct _LW_EVENT_BLOCK_HYBRID_CHANGE_STATE_V2
{
    LwU32    hybridState;     //!< Hybrid Transition state requested from SBios
                              //!  - 0 means adaptive (Follow Power Policy, if available)
                              //!  - 1 means iGPU mode
                              //!  - 2 means dGPU mode
                              //!  - 3 means Multi-Adapter
    LwU32    flags;           //!< Request Flags Bits, starting with LSB (0)
                              //!  - bit 0: Prevent Vista Power Policy Override
                              //!  - bit 1: Override non-migratable
} LW_EVENT_BLOCK_HYBRID_CHANGE_STATE_V2, *PLW_EVENT_BLOCK_HYBRID_CHANGE_STATE_V2;




typedef struct _LW_EVENT_BLOCK_HYBRID_NEXT_DISPLAY
{
    LwU8  transitionRequest;        //!< Indicates if there is need for policy transition 
                                    //! - bit 0 for transition
                                    //! - bit 1 for passing DeviceMask instead of ACPIId.
    union {
        LwU32 ulACPIId1;                 //!< ACPI ID of Display 1
        LwU32 ulDeviceMask;              //!< or device mask for all the devices
    };

    LwU32 ulACPIId2;                 //!< ACPI ID of Display 2
} LW_EVENT_HYBRID_NEXT_DISPLAY, *PLW_EVENT_HYBRID_NEXT_DISPLAY;



typedef struct _LW_EVENT_BLOCK_PINNED_SURFACE_ALLOC
{
    LwU64 hKmHandle;                //!< adapter identifier
    LwU32 dwPinnedMemId;            //!< unique identifier for this allocation request
    LwU32 size;                     //!< size in bytes
}LW_EVENT_BLOCK_PINNED_SURFACE_ALLOC, *PLW_EVENT_BLOCK_PINNED_SURFACE_ALLOC;


typedef struct _LW_EVENT_BLOCK_PINNED_SURFACE_FREE
{
    LwU64 hKmHandle;                //!< adapter identifier
    LwU32 hMem;                     //!< memory handle of the allocation to free
}LW_EVENT_BLOCK_PINNED_SURFACE_FREE, *PLW_EVENT_BLOCK_PINNED_SURFACE_FREE;






//! Used in _LW_EVENT_BLOCK_HYBRID_NOTIFY_LIGHTWEIGHT_STATE.
typedef enum
{
    LW_STATE_UNDEFINED = 0,
    LW_STATE_EDID_REQUESTED = 1,
} LwEventLightweightState;




typedef struct _LW_EVENT_BLOCK_HYBRID_NOTIFY_LIGHTWEIGHT_STATE
{
    LwEventLightweightState state;   //!< Lightweight Start State
} LW_EVENT_BLOCK_HYBRID_NOTIFY_LIGHTWEIGHT_STATE, *PLW_EVENT_BLOCK_HYBRID_NOTIFY_LIGHTWEIGHT_STATE;





//! ACPI diag notifications
typedef struct _LW_EVENT_BLOCK_HYBRID_DIAG_NOTIFY
{
    LwU32    ulACPINotification;
} LW_EVENT_BLOCK_HYBRID_DIAG_NOTIFY, *PLW_EVENT_BLOCK_HYBRID_DIAG_NOTIFY;



//! Hybrid mux device hotplug
typedef struct _LW_EVENT_BLOCK_HYBRID_MUX_DEVICE_HOTPLUG_NOTIFY
{
    LwU32    ulACPIId;          
} LW_EVENT_BLOCK_HYBRID_MUX_DEVICE_HOTPLUG_NOTIFY, *PLW_EVENT_BLOCK_HYBRID_MUX_DEVICE_HOTPLUG_NOTIFY;


typedef struct _LW_EVENT_BLOCK_PSTATE_CHANGE
{
    LwU32 Pstate;
} LW_EVENT_BLOCK_PSTATE_CHANGE, *PLW_EVENT_BLOCK_PSTATE_CHANGE;


typedef struct _LW_EVENT_BLOCK_HYBRID_WIN7_HOTKEY_TOPOLOGY_POWERUP_DGPU
{
    LwU32 ulACPIId1;  //!< For clone/dualview mode, this device will be the primary device.
    LwU32 ulChildId1; //!< To be used to program CCD.    
    LwU32 ulACPIId2;  //!< Will be zero for standard mode. Will be non-zero for clone or dualview mode.
    LwU32 ulChildId2; //!< To be used to program CCD.
    LwU32 ulReserved; //!< May be used for the third head support in fermi
    LW_TARGET_VIEW_MODE ViewMode; //!< LW_VIEW_MODE_STANDARD/CLONE/DUALVIEW
    LwU32 ulPowerUpDgpu; //!< - 1: At least one of the indicated devices is a dgpu-only device and dgpu is lwrrently powered off, 
                         //!   hence lwsvc should first power up the dgpu
                         //!  - 0: No need to power up the dgpu
} LW_EVENT_BLOCK_HYBRID_WIN7_HOTKEY_TOPOLOGY_POWERUP_DGPU, *PLW_EVENT_BLOCK_HYBRID_WIN7_HOTKEY_TOPOLOGY_POWERUP_DGPU;


typedef enum _LW_OVERLAY_FAILURE_TYPE
{
    LW_OVERLAY_FAILURE_GENERAL  = 0,
    LW_OVERLAY_FAILURE_IMP  = 1,
} LW_OVERLAY_FAILURE_TYPE;



typedef struct _LW_EVENT_BLOCK_OVERLAY_FAILURE
{
    LW_OVERLAY_FAILURE_TYPE type;
    LwU32 ulProcessId;
    LwU32 ulPathCount;

} LW_EVENT_BLOCK_OVERLAY_FAILURE, *PLW_EVENT_BLOCK_OVERLAY_FAILURE;


typedef enum 
{
    LW_GSYNC_EVENT_NONE                          =  (0x00000000),
    LW_GSYNC_EVENT_SMART_SYNC_LOSS               =  (0x00000001),
    LW_GSYNC_EVENT_SMART_SYNC_GAIN               =  (0x00000002),
    LW_GSYNC_EVENT_SMART_STEREO_LOSS             =  (0x00000004),
    LW_GSYNC_EVENT_SMART_STEREO_GAIN             =  (0x00000008),
    LW_GSYNC_EVENT_SMART_HOUSESYNC_GAIN          =  (0x00000010),
    LW_GSYNC_EVENT_SMART_HOUSESYNC_LOSS          =  (0x00000020),
    LW_GSYNC_EVENT_SMART_RJ45_GAIN               =  (0x00000040),
    LW_GSYNC_EVENT_SMART_RJ45_LOSS               =  (0x00000080),
    LW_GSYNC_EVENT_SMART_SYNC_STATE_CHANGE       =  (0x00010000)  // DD Event starts with this enum value, keeping buffer for future RM events

} LW_GSYNC_EVENT;

typedef struct _LW_EVENT_BLOCK_GSYNC
{
    LwU32 ulData;  //!< see LW_GSYNC_EVENT
} LW_EVENT_BLOCK_GSYNC, *PLW_EVENT_BLOCK_GSYNC;

typedef struct _LW_EVENT_BLOCK_MONITOR_CONNECTION_STATUS_CHANGE
{
    LwU32 targetId;
    LwU32 ulFlags; // MONITOR_FLAGS_HOTPLUGIN 1
                   // MONITOR_FLAGS_HOTUNPLUG 2

} LW_EVENT_BLOCK_MONITOR_CONNECTION_STATUS_CHANGE, *PLW_EVENT_BLOCK_MONITOR_CONNECTION_STATUS_CHANGE;




#define FULL_TOPOLOGY_POWERUP_DGPU_MAX_HEADS 4


//! See also ::D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.
typedef struct _HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU_PATH_INFO
{
    LwU32                   ChildId;
    LwU32                   SourceId;       
    
    // source mode information
    LwU32                   Width;              //!< Width of the mode
    LwU32                   Height;             //!< Height of the mode
    LwU32                   PixelFormat;        //!< Pixel format of the mode indicating the depth.
    LwU32                   VSyncNumerator;     //!< Numerator of the refresh rate of the mode
    LwU32                   VSyncDenominator;   //!< Denominator of the refresh rate of the mode
    
    // These fields will be based on the corresponding D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE/ROTATION/SCALING enums.
    LwU32                   ImportanceOrdinal;  //!< Reference  
    LwU32                   Rotation;           //!< Rotation setting
    LwU32                   Scaling;            //!< Scaling setting
    LwU32                   ScanlineOrdering;   //!< Interlaced or progressive mode flag
} *PHYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU_PATH_INFO, HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU_PATH_INFO;


//! Power up the DGPU, switch to hybrid perf mode, and do a modeset with the full specified topology.
//! This gets called for the following scenarios: 
//! - CCD restoring persistence when another external monitor is already connected.
//! - User going to MSPanel to activate the dgpu monitor.
//! - Any general running application doing a modeset to activate the dgpu monitor.
typedef struct _LW_EVENT_BLOCK_HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU
{
    LwU32 NumPathCount;  // Number of paths.
    HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU_PATH_INFO PathInfo[FULL_TOPOLOGY_POWERUP_DGPU_MAX_HEADS];
} LW_EVENT_BLOCK_HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU, *PLW_EVENT_BLOCK_HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU;


//! Coproc/Gplex/Carlsbad \n
//! Container for LW_EVENT_ID_COPROC_POWER_REF_COUNT
typedef struct _LW_EVENT_BLOCK_COPROC_POWER_REF_COUNT
{
    LwU64       SequenceNumber;     //!< Keeps events and queries in order

    LwU32       ReferenceCount;     //!< Will be 0 or 1
                                    //! 0 - safe to power off this adapter.
                                    //!< nonzero - not safe to power off.
    LwU32       pad0;

} LW_EVENT_BLOCK_COPROC_POWER_REF_COUNT;



typedef struct _LW_EVENT_BLOCK_HYBRID_DGPU_EVENT
{
    LwU32 gpioEvent;  //!< Event fired off by dGpu gpio if DeepIdle fails.
} LW_EVENT_BLOCK_HYBRID_DGPU_EVENT, *PLW_EVENT_BLOCK_HYBRID_DGPU_EVENT;




//
//! Desktop resolution limit changed event - 
//! Sent when the KMD needs LwSvc to re-enumerate display modes and set the desktop resolution.
typedef struct _LW_EVENT_BLOCK_COPROC_RESOLUTION_LIMIT_CHANGED
{
    LwU32   ulLwrMaxResolutionSize;     //!< current limit as W x H in pixels
    LwU32   bDisabled;                  //!< true if ulLwrMaxResolutionSize is 0; false, otherwise

} LW_EVENT_BLOCK_COPROC_RESOLUTION_LIMIT_CHANGED, *PLW_EVENT_BLOCK_COPROC_RESOLUTION_LIMIT_CHANGED;

//
//! Hotkey Event on CoProc - 
//! This Event is triggered to LwSvc whenever there is a HotKey Event on Coproc systems.
typedef struct _LW_EVENT_BLOCK_COPROC_HOTKEY_NEXT_MDTL_INDEX_TO_LWSVC
{
    LwU32 ulMDTLNextSequenceIndex;
    
}LW_EVENT_BLOCK_COPROC_HOTKEY_NEXT_MDTL_INDEX_TO_LWSVC,*PLW_EVENT_BLOCK_COPROC_HOTKEY_NEXT_MDTL_INDEX_TO_LWSVC;

typedef struct _LW_EVENT_BLOCK_PHYSX_ILWALID_CONFIG
{
    LwU64 hProcessId;
} LW_EVENT_BLOCK_PHYSX_ILWALID_CONFIG, *PLW_EVENT_BLOCK_PHYSX_ILWALID_CONFIG;


typedef enum _LW_COPROC_FORCE_GPU_MODE
{
    LW_COPROC_NONE,           //!< Non Optimus platforms.
    LW_COPROC_FORCE_IGPU,     //!< Forced IGPU mode.
    LW_COPROC_FORCE_DGPU,     //!< Forced DGPU mode.
    LW_COPROC_OPTIMUS,        //!< Normal Optimus platform.
} LW_COPROC_FORCE_GPU_MODE;

//! ACPI event on coproc for hardware switch - 
//! This Event is triggered to LwSvc whenever there is a hardware switch ACPI Event on Coproc systems.
typedef struct _LW_EVENT_BLOCK_COPROC_FORCE_GPU_POLICY
{
    LW_COPROC_FORCE_GPU_MODE forcedGPUMode;
} LW_EVENT_BLOCK_COPROC_FORCE_GPU_POLICY, *PLW_EVENT_BLOCK_COPROC_FORCE_GPU_POLICY;



//! Fan Speed Level
typedef struct _LW_EVENT_BLOCK_FAN_SPEED_CHANGE
{
    LwU32 fanSpeedLevel;         //!< Returns fan Speed Level
}LW_EVENT_BLOCK_FAN_SPEED_CHANGE, *PLW_EVENT_BLOCK_FAN_SPEED_CHANGE;

//! Thermal Level
typedef struct _LW_EVENT_BLOCK_THERMAL_CHANGE
{
    LwU32 thermalLevel;          //!< Returns thermal Level
}LW_EVENT_BLOCK_THERMAL_CHANGE, *PLW_EVENT_BLOCK_THERMAL_CHANGE;


typedef enum _LW_COLOR_PROFILE_CHANGE_TYPE
{
    LW_COLOR_PROFILE_CHANGE_DISABLE_OVERRIDE   = 0x00,
    LW_COLOR_PROFILE_CHANGE_ENABLE_OVERRIDE    = 0x01,
} LW_COLOR_PROFILE_CHANGE_TYPE;

typedef struct _LW_EVENT_BLOCK_COLOR_PROFILE_CHANGE
{
    LW_COLOR_PROFILE_CHANGE_TYPE profileChange;   //!< change requested
    LwU32 gpuId;                                  //!< GPU to which the target display is attached
    LwU32 outputId;                               //!< Source to which the target display is attached
    LwU32 position;                               //!< If clone, target display's position relative to source
} LW_EVENT_BLOCK_COLOR_PROFILE_CHANGE, *PLW_EVENT_BLOCK_COLOR_PROFILE_CHANGE;



typedef enum
{
    LW_EVENT_BLOCK_VMODE_TRANSITION_ENTERING_VMODE = 1,
    LW_EVENT_BLOCK_VMODE_TRANSITION_LEAVING_VMODE,
} LW_EVENT_BLOCK_VMODE_TRANSITION;

typedef struct _LW_EVENT_BLOCK_VMODE
{
    LW_EVENT_BLOCK_VMODE_TRANSITION transition;
} LW_EVENT_BLOCK_VMODE, *PLW_EVENT_BLOCK_VMODE;

typedef enum _LW_DISPLAY_CONFIG_TYPE
{
    LW_DISPLAY_CONFIG_TYPE_STANDARD      = 1,
    LW_DISPLAY_CONFIG_TYPE_STREAM_CLONED = 2,
    LW_DISPLAY_CONFIG_TYPE_MOSAIC        = 3, 
} LW_DISPLAY_CONFIG_TYPE;

typedef enum _LW_TOPO_EVENTTYPE
{
    LW_TOPO_EVENTTYPE_DISPLAY_HOTPLUG         = 1,  // For monitors associated with the OS monitor
    LW_TOPO_EVENTTYPE_DISPLAY_UNPLUG          = 2,  // For monitors associated with the OS monitor
    LW_TOPO_EVENTTYPE_NEW_DEVICE              = 3,  // For DP12 devices
    LW_TOPO_EVENTTYPE_LOST_DEVICE             = 4,
    LW_TOPO_EVENTTYPE_DETECT_COMPLETED        = 5,
    LW_TOPO_EVENTTYPE_BANDWIDTH_CHANGED       = 6,
    LW_TOPO_EVENTTYPE_MUST_DISCONNECT         = 7,
    LW_TOPO_EVENTTYPE_ZOMBIE_STATE_CHANGED    = 8,
    LW_TOPO_EVENTTYPE_CABLE_STATE_CHANGED     = 9,
} LW_TOPO_EVENTTYPE;

//! NOTES:
//! - gpuId, subDeviceId and displayId are used to describe the connector the device/node is attached. The values are always valid.
//! - childUid is the same id reported to OS and is associated with this node (for now, video sinks). If the node is not reported to OS, it is invalid and is LWL_MONITOR_ILWALID_TARGETID(0).
//! - dpNode.displayId may contain the current displayId associated to this node.  If the device is active, the value is valid.  Otherwise, it is invalid and is 0.
//! - dpNode.dpAddress is aux address for this node. If the node is a stream cloning node, representing one or more cloned devices, this value is invalid and is LWL_MONITOR_ILWALID_DPMSTADDRESS(0).
//! - In stream cloning, the chilUid can be used to enumerate the dpAddresses of member devices
//! - A connector event, non-node, is reported when both childUid and dpNode.dpAddress is zero
//! displayType is to identify a display type when event is regarding OS monitor object

typedef struct _LW_EVENT_BLOCK_TOPOLOGY_CHANGED
{
    LW_TOPO_EVENTTYPE     eventType;          //!< may need to check flags for the associated eventType, e.g. Zombie state changed, check isZombie flag
    LwU32               gpuId;                //!< gpuId of the connector to which the device is attached
    LwU32               subdeviceId;          //!< subdeviceId of the connector to which the device is attached
    LwU32               connectorId;          //!< connectorId of the connector to which the device is attached
    LwU32               childUid;             //!< Zero if the device is not reported to the OS, e.g. branch devices, audio only devices
    union // depend on eventtype, 1 and 2 uses displaytype
    {
        LW_DISPLAY_CONFIG_TYPE    displayType;       //!< indicate whether it is standard monitor, stream clone monitor, mosaic monitor, etc representing abstract concept that the OS cares
        LW_DP_NODE_INFO           dpNode;            //!< Node-specific info
    };
} LW_EVENT_BLOCK_TOPOLOGY_CHANGED;

typedef struct _LW_EVENT_TOPOLOGY_CHANGED
{
    LW_EVENT header;
    LW_EVENT_BLOCK_TOPOLOGY_CHANGED data;
} LW_EVENT_TOPOLOGY_CHANGED;

//! Indicates why the display driver is calling lwsvc with the SET_SURFACE_INFO_AND_MODESET call.
typedef enum _LW_HCLONE_EVENT_REASON
{
    LW_HCLONE_EVENT_REASON_SETTING_HCLONE_TOPOLOGY=0,            //!< The caller is setting up an hclone topology.
                                                              
    LW_HCLONE_EVENT_REASON_CLEARING_HCLONE_TOPOLOGY_VOLUNTARY,   //!< The caller is voluntarily clearing hclone topology.
                                                                 //!< Consequently the secondary surface needs to be freed and force mode
                                                                 //!< enumeration needs to be done.
                                                              
    LW_HCLONE_EVENT_REASON_CLEARING_HCLONE_TOPOLOGY_ILWOLUNTARY, //!< HClone topology is being cleared ilwoluntarily. This can happen when DD
                                                                 //!< detects certain conditions such as target grabbing by the OS, source
                                                                 //!< grabbing by the OS with no additional hardware sources available,
                                                                 //!< StopDevice() called on one of the adapters in the hclone topology,
                                                                 //!< etc... the secondary surface needs to be freed and force mode
                                                                 //!< enumeration needs to be done.
    LW_HCLONE_EVENT_REASON_RESOLUTION_CHANGED,                   //!< Topology is unchanged. But the resolution has changed. So DD has 
                                                                 //!< NULLified the hclone secondary surface.
                                                                 //!< need to recreate the secondary surface appropriately.
    LW_HCLONE_EVENT_REASON_ZERO_FIND_ZEROR_GAMMA,                //!< When enable HClone, zero gamma table is detected by DD
                                                                 //!< Issue this event to CPL to reset OS gamma.
} LW_HCLONE_EVENT_REASON;

typedef struct _LW_EVENT_BLOCK_HCLONE_SET_SURFACE_INFO_AND_MODESET
{
    LW_HCLONE_EVENT_REASON       eventReason;          //!< The reason why DD triggered this event to lwsvc.
} LW_EVENT_BLOCK_HCLONE_SET_SURFACE_INFO_AND_MODESET;

typedef struct _LW_EVENT_HCLONE_SET_SURFACE_INFO_AND_MODESET
{
    LW_EVENT header;
    LW_EVENT_BLOCK_HCLONE_SET_SURFACE_INFO_AND_MODESET data;
} LW_EVENT_HCLONE_SET_SURFACE_INFO_AND_MODESET;

typedef enum _LW_COPROC_POWER_STATE_CHANGE
{
    LW_COPROC_POWER_STATE_CHANGE_ON   = 0x206E4F20,
    LW_COPROC_POWER_STATE_CHANGE_GOLD = 0x476F6C64,
} LW_COPROC_POWER_STATE_CHANGE;

typedef struct _LW_EVENT_BLOCK_COPROC_POWER_STATE_CHANGE
{
    LW_COPROC_POWER_STATE_CHANGE coprocPowerStateChange;
} LW_EVENT_BLOCK_COPROC_POWER_STATE_CHANGE, *PLW_EVENT_BLOCK_COPROC_POWER_STATE_CHANGE;

typedef enum _LW_GC5_STATE_CHANGE
{
    LW_GC5_STATE_CHANGE_DISARMED = 0,       // The system may no longer enter the GC5 low power state
    LW_GC5_STATE_CHANGE_ARMED    = 1,       // The system may now enter the GC5 low power state
} LW_GC5_STATE_CHANGE;

typedef enum _LW_GC6_NOTIFY_STATE_CHANGE
{
    LW_GC6_NOTIFY_STATE_CHANGE_ENTRY = 0,       // System enter to GC6 entry point
    LW_GC6_NOTIFY_STATE_CHANGE_EXIT  = 1,       // System enter to GC6 Exit point
} LW_GC6_NOTIFY_STATE_CHANGE;


//---------------------------------------------------------------------------------
//! Structures for LW_EVENT_ID_COMMIT_VIDPN_DONE.

typedef enum _LW_EVENT_ENUM_COMMIT_VIDPN_DONE_SCENARIO
{
    LW_EVENT_ENUM_COMMIT_VIDPN_DONE_SCENARIO_DEFAULT = 0,
    LW_EVENT_ENUM_COMMIT_VIDPN_DONE_SCENARIO_RESUME_FROM_HIBERNATION,
    LW_EVENT_ENUM_COMMIT_VIDPN_DONE_SCENARIO_RESUME_FROM_STANDBY,
} LW_EVENT_BLOCK_COMMIT_VIDPN_DONE_SCENARIO;

typedef struct _LW_EVENT_BLOCK_COMMIT_VIDPN_DONE
{
    LW_EVENT_BLOCK_COMMIT_VIDPN_DONE_SCENARIO   scenario;
} LW_EVENT_BLOCK_COMMIT_VIDPN_DONE;

typedef struct _LW_EVENT_COMMIT_VIDPN_DONE
{
    LW_EVENT                                    header;
    LW_EVENT_BLOCK_COMMIT_VIDPN_DONE            data;            
} LW_EVENT_COMMIT_VIDPN_DONE;

//---------------------------------------------------------------------------------
typedef struct _LW_EVENT_BLOCK_GC5_STATE_CHANGE
{
    LW_GC5_STATE_CHANGE gc5StateChange;
} LW_EVENT_BLOCK_GC5_STATE_CHANGE, *PLW_EVENT_BLOCK_GC5_STATE_CHANGE;

typedef struct _LW_EVENT_GC5_STATE_CHANGE
{
    LW_EVENT header;
    LW_EVENT_BLOCK_GC5_STATE_CHANGE data;
} LW_EVENT_GC5_STATE_CHANGE, *PLW_EVENT_GC5_STATE_CHANGE;

//------------------------------------------------------------------------------------

typedef struct _LW_EVENT_BLOCK_GC6_NOTIFY_STATE_CHANGE
{
    LW_GC6_NOTIFY_STATE_CHANGE gc6StateChange;
} LW_EVENT_BLOCK_GC6_NOTIFY_STATE_CHANGE, *PLW_EVENT_BLOCK_GC6_NOTIFY_STATE_CHANGE;

typedef struct _LW_EVENT_GC6_NOTIFY_STATE_CHANGE
{
    LW_EVENT header;
    LW_EVENT_BLOCK_GC6_NOTIFY_STATE_CHANGE data;
} LW_EVENT_GC6_NOTIFY_STATE_CHANGE, *PLW_EVENT_GC6_NOTIFY_STATE_CHANGE;

//---------------------------------------------------------------------------------
//! Structures for LW_EVENT_ID_DESKTOP_REDRAW_REQUEST.

// helper define to avoid cross module build breaks.
#define LW_EVENT_DESKTOP_REDRAW_REQUEST_DEFINED

typedef enum _LW_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD
{
    LW_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD_SET_PIXEL = 0,
    LW_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD_RENDER_BEFORE_FLIP,
    LW_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD_GDI_DESKTOP_REDRAW,
} LW_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD;

typedef struct _LW_EVENT_BLOCK_DESKTOP_REDRAW_REQUEST
{
    LwU32                                        redraw;    //!< true lwservice should redraw (portions of) the desktop
    LW_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD  method;    //!< method to use when redrawing (portions of) the desktop
    LwU32                                        displayId; //!< set if method is GDI_DESKTOP_REDRAW

} LW_EVENT_BLOCK_DESKTOP_REDRAW_REQUEST;

typedef struct _LW_EVENT_DESKTOP_REDRAW_REQUEST
{
    LW_EVENT                                    header;
    LW_EVENT_BLOCK_DESKTOP_REDRAW_REQUEST       data;            
} LW_EVENT_DESKTOP_REDRAW_REQUEST;

//---------------------------------------------------------------------------------
//! Structures & enums for LW_EVENT_ID_REQUEST_FORCED_TDR.

typedef enum _TDR_REASON
{
    TDR_REASON_UNKNOWN   = 0,
    TDR_REASON_BUS_RESET = 1,
    TDR_REASON_GC6_RESET = 2,
    TDR_REASON_NORMAL_RESET = 3
} TDR_REASON;

typedef struct _LW_EVENT_BLOCK_REQUEST_FORCED_TDR
{
    TDR_REASON tdrReason;
} LW_EVENT_BLOCK_REQUEST_FORCED_TDR, *PLW_EVENT_BLOCK_REQUEST_FORCED_TDR;

typedef struct _LW_EVENT_REQUEST_FORCED_TDR
{
    LW_EVENT header;
    LW_EVENT_BLOCK_REQUEST_FORCED_TDR data;
} LW_EVENT_REQUEST_FORCED_TDR, *PLW_EVENT_REQUEST_FORCED_TDR;

//! Callback Format
typedef void (__cdecl *LW_EVENT_CALLBACK)(LW_EVENT* Event, void* CallbackParam);


//! @}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Event_RegisterForEvents
//
//! DESCRIPTION:  This function registers the process for events.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//!
//!  \param [in]  Callback          Pointer to the function to call on new events
//!  \param [in]  CallbackParam     void* Parameter to be passed to the callback function
//!  \param [out] phClient          Handle to the client for use with an unregister function
//!
//!  \retval      LWAPI_OK          Completed request
//!  \retval      LWAPI_ERROR       Miscellaneous error oclwrred
//!
//!  \ingroup sysevent
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Event_RegisterForEvents(LW_EVENT_CALLBACK Callback, 
                                              void* CallbackParam, 
                                              LwEventHandle* phClient);
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Event_Unregister
//
//! DESCRIPTION:  This function unregisters an event handle.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//!   \param [in] hClient      The handle associated with this listener's
//!                            event queue. It is the same handle passed by 
//!                            LwAPI_Event_RegisterForEvents().
//!
//!   \retval     LWAPI_OK     Completed request
//!   \retval     LWAPI_ERROR  Miscellaneous error oclwrred
//!
//!   \ingroup    sysevent
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Event_Unregister(LwEventHandle hClient);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:  LwAPI_SYS_SetDisplayDeviceInfo
//
//! \fn LwAPI_SYS_SetDisplayDeviceInfo(__in LwU32 displayDeviceCount, __in_ecount(displayDeviceCount) LWAPI_DISPLAY_DEVICE_INFO *displayDeviceInfo, __in LWAPI_DEVICE_INFO_TYPE infoType)
//! 
//! DESCRIPTION:   This API sends information about display devices to the display driver.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] displayDeviceCount - Number of elements in the displayDeviceInfo array.
//! \param [in] displayDeviceInfo  - Array of LWAPI_DISPLAY_DEVICE_INFO structure which holds the display info.
//! \param [in] infoType           - Possible values are : 
//!                                  1. LWAPI_DEVICE_INFO_HOTKEY_INIT :
//!                                     This flag should be when user mode wants to send this information (in the case of hotkey handling), 
//!                                     and the caller is sending fresh data for the first time.
//!                                     Caller should send target id and ACPI id in this call.
//!                                  2. LWAPI_DEVICE_INFO_HOTKEY_UPDATE :
//!                                     This flag should be used when user mode wants to send this information (in the case of hotkey handling), 
//!                                     and the caller is sending the updated information.
//!                                     Caller should send target id, isConnected and isActive information in this call.
//!                                  3. LWAPI_DEVICE_INFO_DEVICE_CHANGE_UPDATE :
//!                                     This flag should be used when user mode wants to send this information while the caller is sending the
//!                                     updated information after a device change event.
//!                                     Caller should send target id, isConnected and isActive information in this call.
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//! 
//!  \retval  ::LWAPI_VALUE_ALREADY_SET      If the API is called with isUpdatedInfo as value zero more than once, the API will
//!                                          return this error code from second call. 
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup sysevent
//! Information of the display device connected to non-Lwpu GPU.

typedef enum
{
    LWAPI_DEVICE_INFO_UNKNOWN = 0,
    LWAPI_DEVICE_INFO_HOTKEY_INIT,           //!< New information under hotkey path.
    LWAPI_DEVICE_INFO_HOTKEY_UPDATE,         //!< Updated information under hotkey path.
    LWAPI_DEVICE_INFO_DEVICE_CHANGE_UPDATE   //!< Updated information after device change event.
}LWAPI_DEVICE_INFO_TYPE;

typedef struct
{
        LwU32 version;
        
        LwU32 targetID;            //!< Target Id of the display.
        LwU32 acpiID;              //!< ACPI Id of the display
        LwU32 isNonLWDisplay : 1;  //!< Whether the display is connected to an LWPU GPU or non-LWPU GPU.
        LwU32 isConnected    : 1;  //!< Whether the display is connected or not.
        LwU32 isActive       : 1;  //!< Whether the display is active or not.
        LwU32 reserved       : 29; //!< Reserved.
}LWAPI_DISPLAY_DEVICE_INFO_V1;

typedef LWAPI_DISPLAY_DEVICE_INFO_V1     LWAPI_DISPLAY_DEVICE_INFO;

#define LWAPI_DISPLAY_DEVICE_INFO_VER1   MAKE_LWAPI_VERSION(LWAPI_DISPLAY_DEVICE_INFO_V1, 1) 
#define LWAPI_DISPLAY_DEVICE_INFO_VER    LWAPI_DISPLAY_DEVICE_INFO_VER1 

//! \ingroup sysevent
LWAPI_INTERFACE LwAPI_SYS_SetDisplayDeviceInfo(__in LwU32 displayDeviceCount, __in_ecount(displayDeviceCount) LWAPI_DISPLAY_DEVICE_INFO *displayDeviceInfo, __in LWAPI_DEVICE_INFO_TYPE infoType);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_CreateContext
//
//! \code
//! INPUT:         phContext  - Pointer to store handle of created 3D Vision Pro
//!                             context handle to.
//!
//! OUTPUT:        *phContext - Handle of a 3D Vision Pro context (NULL on
//!                             failure).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Creates 3D VISION PRO (3DVP) context. May fail if 3DVP
//!                - is generally not supported on this system, or
//!                - it has been already acquired by another thread and
//!                  conlwrrent access is not supported.
//!
//! RETURN STATUS: LWAPI_OK                      - Success
//!               LWAPI_ERROR                   - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED     - LwAPI was not intialized
//!                LWAPI_ILWALID_POINTER         - phContext is NULL
//!                LWAPI_OUT_OF_MEMORY           - Failed to create context due to OOM
//!                LWAPI_LWIDIA_DEVICE_NOT_FOUND - No LWPU GPU found
//!                LWAPI_NOT_SUPPORTED           - 3DVP is not supported on this system
//!                LWAPI_NO_IMPLEMENTATION       - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_3DVP_CreateContext( Lw3DVPContextHandle * phContext );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_DestroyContext
//
//! \code
//! INPUT:         hContext - Handle of 3DVP context to destroy.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Destroys 3DVP context.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE      - Invalid context handle
//!                LWAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_3DVP_DestroyContext( Lw3DVPContextHandle hContext );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_EnumTransceiver
//
//! \code
//! INPUT:         hContext       - Handle of 3DVP context to enumerate
//!                                 transceivers for.
//!                phTransceiver  - Pointer to transceiver handle. Set
//!                                 *phTransceiver to NULL to begin an
//!                                 enumeration, and to the result of the
//!                                 last enumeration to continue an enumeration.
//!
//! OUTPUT:        *phTransceiver - Handle of enumerated transceiver (NULL on
//!                                 failure, or at the end of an enumeration).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Enumerates transceivers for given context. Set
//!                *phTransceiver to NULL to start a new enumeration, and to
//!                the last enumeration result to continue an enumeration.
//!                Returns LWAPI_END_ENUMERATION and sets *phTransceiver to
//!                NULL at the end of an enumeration.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_POINTER     - phTransceiver is NULL
//!                LWAPI_ILWALID_HANDLE      - Invalid context or transceiver handle
//!                LWAPI_END_ENUMERATION     - No more transceivers to enumerate
//!                LWAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_3DVP_EnumTransceiver( Lw3DVPContextHandle hContext, Lw3DVPTransceiverHandle * phTransceiver );






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_OpenTransceiver
//
//! \fn LwAPI_3DVP_OpenTransceiver
//! \code
//! INPUT:         hContext     - Handle of 3DVP context to open given transceiver for.
//!                hTransceiver - Handle of transceiver to open.
//!                access       - Access mode to open transceiver with.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Opens a transceiver for given context in given access mode.
//!                May fail if a transceiver was already opened by another
//!                context and cannot be shared in given access mode (e.g.
//!                N readers, but max. one writer). Also note that this might
//!                cause other transceivers to be closed for given context due
//!                to resource constraints. Finally, the access mode for a
//!                transceiver determines the access mode to all glasses that
//!                are paired to this transceiver.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE      - Invalid context or transceiver handle
//!                LWAPI_ILWALID_ARGUMENT    - Invalid access mode
//!                LWAPI_ACCESS_DENIED       - Transceiver was already opened by another
//!                                            context and cannot be shared in given access mode
//!                LWAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereo3dvpapi
//! 3D Vision Pro access modes:
typedef enum _LWAPI_3DVP_ACCESS
{
    LWAPI_3DVP_ACC_NONE = 0,  //!< No access
    LWAPI_3DVP_ACC_READ,      //!< Read-only access
    LWAPI_3DVP_ACC_READWRITE, //!< Read+write access
    LWAPI_3DVP_ACC_COUNT,     //!< Number of access modes
} LWAPI_3DVP_ACCESS;

//! \ingroup stereo3dvpapi
LWAPI_INTERFACE LwAPI_3DVP_OpenTransceiver( Lw3DVPContextHandle hContext, Lw3DVPTransceiverHandle hTransceiver, LWAPI_3DVP_ACCESS access );






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_OpenTransceiverPriviledged
//
//! \code
//! INPUT:         hContext     - Handle of 3DVP context to open given transceiver for.
//!                hTransceiver - Handle of transceiver to open.
//!                access       - Access mode to open transceiver with.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Same as above except that this function will stay private to
//!                be exclusively used by the LWPU control panel.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE      - Invalid context or transceiver handle
//!                LWAPI_ILWALID_ARGUMENT    - Invalid access mode
//!                LWAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_3DVP_OpenTransceiverPriviledged( Lw3DVPContextHandle hContext, Lw3DVPTransceiverHandle hTransceiver, LWAPI_3DVP_ACCESS access );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_CloseTransceiver
//
//! \code
//! Input:         hContext     - Handle of 3DVP context to close transceiver for.
//!                hTransceiver - Handle of transceiver to close.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Closes a transceiver.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE      - Invalid context or transceiver handle
//!                LWAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_3DVP_CloseTransceiver( Lw3DVPContextHandle hContext, Lw3DVPTransceiverHandle hTransceiver );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_GetTransceiverAccess
//
//! \code
//! INPUT:         hContext     - Handle of 3DVP context of which to get the access mode
//!                               for given transceiver.
//!                hTransceiver - Handle of transceiver to get access mode for.
//!                pMode        - Pointer to store the LWAPI_3DVP_ACCESS mode to.
//!
//! OUTPUT:        *pMode       - Mode in which given context can access given
//!                               transceiver (LWAPI_3DVP_ACC_NONE on failure, or
//!                               if given transceiver was not opened for given
//!                               context at all).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves the mode in which a given context can access a
//!                specific transceiver.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE      - Invalid context or transceiver handle
//!                LWAPI_ILWALID_POINTER     - pMode is NULL
//!                LWAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_3DVP_GetTransceiverAccess( Lw3DVPContextHandle hContext, Lw3DVPTransceiverHandle hTransceiver, LWAPI_3DVP_ACCESS * pAccess );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_ResetTransceiverToFactorySettings
//
//! \code
//! INPUT:         hContext     - Handle of 3DVP context with access to given transceiver.
//!                hTransceiver - Handle of transceiver to reset.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Resets a transceiver to its factory settings. Fails if
//!                context has no write-access for given transceiver.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE      - Invalid context or transceiver handle
//!                LWAPI_ACCESS_DENIED       - Context has insufficient access rights to given transceiver 
//!                LWAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                LWAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_3DVP_ResetTransceiverToFactorySettings( Lw3DVPContextHandle hContext, Lw3DVPTransceiverHandle hTransceiver );





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_GetTransceiverInfo
//
//! \fn LwAPI_3DVP_GetTransceiverInfo
//! \code
//! INPUT:         hContext     - Handle of 3DVP context with access to given transceiver.
//!                hTransceiver - Handle of transceiver to get info about.
//!                pInfo        - Pointer to store transceiver info to.
//!
//! OUTPUT:        *pInfo       - Retrieved transceiver info (undefined on
//!                               failure).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves common information about a transceiver. Fails if
//!                context has no read-access to given transceiver.
//!
//! RETURN STATUS: LWAPI_OK                          - Success
//!                LWAPI_ERROR                       - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED         - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE              - Invalid context or transceiver handle
//!                LWAPI_ILWALID_POINTER             - pInfo is NULL
//!                LWAPI_INCOMPATIBLE_STRUCT_VERSION - *pInfo version incompatible 
//!                LWAPI_ACCESS_DENIED               - Context has insufficient access rights to given transceiver 
//!                LWAPI_NOT_SUPPORTED               - Function is not supported by HW
//!                LWAPI_NO_IMPLEMENTATION           - Function is not implemented by SW
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereo3dvpapi
//! @{


//! 3D Vision Pro RF address - just 5 opaque bytes (like a MAC address):
typedef struct
{
    LwU8 a0;
    LwU8 a1;
    LwU8 a2;
    LwU8 a3;
    LwU8 a4;
} LWAPI_3DVP_RF_ADDRESS;

//! 3D Vision Pro HW serial number - array of LWAPI_3DVP_SERIAL_NUMBER_LENGTH digits
#define LWAPI_3DVP_SERIAL_NUMBER_LENGTH 13
typedef LwU8 LWAPI_3DVP_SERIAL_NUMBER[LWAPI_3DVP_SERIAL_NUMBER_LENGTH];

//! 3D Vision Pro transceiver info:
typedef struct
{
    LwU32                    version;      //!< LwAPI struct version
    LwU32                    hwFeatures;   //!< opaque bitfield of HW features
    LwU32                    fwRevA;       //!< firmware version of chip A
    LwU32                    fwRevB;       //!< firmware version of chip B
    LwU32                    fwRevC;       //!< firmware version of chip C
    LWAPI_3DVP_RF_ADDRESS    rfAddress;    //!< RF address of this transceiver
    LwU32                    channelCount; //!< number of channels on this transceiver
    LWAPI_3DVP_SERIAL_NUMBER serialNumber; //!< serial number
    LwU32                    isEmbedded;   //!< embedded transceiver?
} LWAPI_3DVP_TRANSCEIVER_INFO;

//! LWAPI_3DVP_TRANSCEIVER_INFO version history:
//! 1 - intial version
//! 2 - added serialNumber, isEmbedded
#define LWAPI_3DVP_TRANSCEIVER_INFO_VER MAKE_LWAPI_VERSION(LWAPI_3DVP_TRANSCEIVER_INFO,2)

//! @}


//! \ingroup stereo3dvpapi
LWAPI_INTERFACE LwAPI_3DVP_GetTransceiverInfo( Lw3DVPContextHandle hContext, Lw3DVPTransceiverHandle hTransceiver, LWAPI_3DVP_TRANSCEIVER_INFO * pInfo );





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_IsAirplaneModeEnabled
//
//! DESCRIPTION:   Queries whether airplane mode is enabled for given transceiver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!
//! \param [in]  hContext     - Handle of 3DVP context with access to given
//!                             transceiver
//! \param [in]  hTransceiver - Handle of transceiver to get the airplane mode state for
//! \param [out] pEnabled    - != 0: Airplane mode is enabled, 0: otherwise
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//!
//! \retval LWAPI_ACCESS_DENIED - Context has insufficient access rights to given transceiver 
//!
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////

LWAPI_INTERFACE LwAPI_3DVP_IsAirplaneModeEnabled( __in  Lw3DVPContextHandle hContext,
                                                  __in  Lw3DVPTransceiverHandle hTransceiver,
                                                  __out LwU32 * pEnabled );




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_GetTransceiverSignalQuality
//
//! DESCRIPTION:   Retrieves the current signal quality for a specific transceiver.
//!                Fails if context has no read-access for given transceiver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!
//! \param [in]  hContext     - Handle of 3DVP context with access to given
//!                             transceiver
//! \param [in]  hTransceiver - Handle of transceiver to get the signal quality for
//! \param [out] pQuality     - Signal quality [0(worst)..100(best)]
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//!
//! \retval ::LWAPI_ACCESS_DENIED - Context has insufficient access rights to given transceiver 
//!
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////

LWAPI_INTERFACE LwAPI_3DVP_GetTransceiverSignalQuality( __in  Lw3DVPContextHandle hContext,
                                                        __in  Lw3DVPTransceiverHandle hTransceiver,
                                                        __out LwU8 * pQuality );


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_GetTransceiverChannelInfo
//
//! \fn LwAPI_3DVP_GetTransceiverChannelInfo
//! \code
//! INPUT:         hContext     - Handle of 3DVP context with access to given transceiver.
//!                hTransceiver - Handle of transceiver to get channel info for.
//!                channelIndex - Index of channel to get info about, range:
//!                                (0..LWAPI_3DVP_TRANSCEIVER_INFO.channelCount].
//!                pInfo        - Pointer to store channel info to.
//!
//! OUTPUT:        *pInfo       - Retrieved channel info (undefined on failure).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves info about a channel of a given transceiver. Fails
//!                if context has no read-access to given transceiver.
//!
//! RETURN STATUS: LWAPI_OK                          - Success
//!                LWAPI_ERROR                       - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED         - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE              - Invalid context or transceiver handle
//!                LWAPI_ILWALID_POINTER             - pInfo is NULL
//!                LWAPI_INCOMPATIBLE_STRUCT_VERSION - *pInfo version incompatible 
//!                LWAPI_ACCESS_DENIED               - Context has insufficient access rights to given transceiver 
//!                LWAPI_NOT_SUPPORTED               - Function is not supported by HW
//!                LWAPI_NO_IMPLEMENTATION           - Function is not implemented by SW
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereo3dvpapi
//! @{

//! 3D Vision Pro transceiver channel info:
typedef struct
{
    LwU32 version;   //!< LwAPI struct version
    LwU32 frequency; //!< Channel frequency (kHz)
    LwU32 quality;   //!< Channel quality (percent)
} LWAPI_3DVP_CHANNEL_INFO;

#define LWAPI_3DVP_CHANNEL_INFO_VER MAKE_LWAPI_VERSION(LWAPI_3DVP_CHANNEL_INFO,1)

//! @}

//! \ingroup stereo3dvpapi
LWAPI_INTERFACE LwAPI_3DVP_GetTransceiverChannelInfo(__in Lw3DVPContextHandle hContext, __in Lw3DVPTransceiverHandle hTransceiver, __in LwU32 channelIndex, __inout LWAPI_3DVP_CHANNEL_INFO * pInfo );






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_GetTransceiverChannels
//
//! \fn LwAPI_3DVP_GetTransceiverChannels( __in Lw3DVPContextHandle hContext, __in Lw3DVPTransceiverHandle hTransceiver, __out LWAPI_3DVP_CHANNELS * pChannels )
//! DESCRIPTION:   Retrieves the channel sequence that is lwrrently used by a
//!                specific transceiver. Fails if context has no read-access
//!                for given transceiver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hContext     - Handle of 3DVP context with access to given
//!                             transceiver
//! \param [in]  hTransceiver - Handle of transceiver to get the current channel for
//! \param [out] pChannels    - Channel sequence used by transceiver for
//!                             communication ({0,0,0,0} on failure)
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//!
//! \retval ::LWAPI_ACCESS_DENIED - Context has insufficient access rights to given transceiver 
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereo3dvpapi
typedef struct {
    LwU8 c0;
    LwU8 c1;
    LwU8 c2;
    LwU8 c3;            
} LWAPI_3DVP_CHANNELS;

//! \ingroup stereo3dvpapi
LWAPI_INTERFACE LwAPI_3DVP_GetTransceiverChannels( __in  Lw3DVPContextHandle hContext,
                                                   __in  Lw3DVPTransceiverHandle hTransceiver,
                                                   __out LWAPI_3DVP_CHANNELS * pChannels );


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_SetTransceiverChannels
//
//! DESCRIPTION:   Defines the channel sequence that is to be used by given
//!                transceiver, where i) pChannels->c0..c3 should be within
//!                [0..LWAPI_3DVP_TRANSCEIVER_INFO.channelCount] with at least
//!                one non-zero channel, or ii) pChannels should be NULL to
//!                make the transceiver auto-select a channel sequence.
//!                Fails if context has no write-access for given transceiver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!
//! \param [in] hContext     - Handle of 3DVP context with access to given
//!                            transceiver
//! \param [in] hTransceiver - Handle of transceiver to set the current channel for
//! \param [in] pChannels    - Channel sequence to be used by given transceiver
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//!
//! \retval ::LWAPI_ACCESS_DENIED - Context has insufficient access rights to given transceiver 
//!
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_3DVP_SetTransceiverChannels( __in Lw3DVPContextHandle hContext,
                                                   __in Lw3DVPTransceiverHandle hTransceiver,
                                                   __in_opt LWAPI_3DVP_CHANNELS * pChannels );

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_GetTransceiverChannel
//
//! \code
//! INPUT:         hContext       - Handle of 3DVP context with access to given
//!                                 transceiver
//!                hTransceiver   - Handle of transceiver to get the current channel for
//!                pChannelIndex  - Pointer to store channel index to
//!
//! OUTPUT:        *pChannelIndex - Index of channel used by transceiver for
//!                                 communication (0 on failure)
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves the channel that is lwrrently used by a specific
//!                transceiver. Fails if context has no read-access for given
//!                transceiver.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE      - Invalid context or transceiver handle
//!                LWAPI_ILWALID_POINTER     - pChannelIndex is NULL
//!                LWAPI_ACCESS_DENIED       - Context has insufficient access rights to given transceiver 
//!                LWAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                LWAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_3DVP_GetTransceiverChannel( Lw3DVPContextHandle hContext, Lw3DVPTransceiverHandle hTransceiver, LwU32 * pChannelIndex );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_SetTransceiverChannel
//
//! \code
//! INPUT:         hContext     - Handle of 3DVP context with access to given transceiver
//!                hTransceiver - Handle of transceiver to set the channel for
//!                channelIndex - Index of channel that should be used by
//!                               given transceiver
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Sets the channel that a specific transceiver should use for
//!                communication. Fails if context has no write-access to given
//!                transceiver.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE      - Invalid context or transceiver handle
//!                LWAPI_ILWALID_ARGUMENT    - channelIndex out of range
//!                LWAPI_ACCESS_DENIED       - Context has insufficient access rights to given transceiver 
//!                LWAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                LWAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_3DVP_SetTransceiverChannel( Lw3DVPContextHandle hContext, Lw3DVPTransceiverHandle hTransceiver, LwU32 channelIndex );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_GetTransceiverMode
//
//! \fn LwAPI_3DVP_GetTransceiverMode
//! \code
//! INPUT:         hContext     - Handle of 3DVP context with access to given transceiver.
//!                hTransceiver - Handle of transceiver to get mode for.
//!                pMode        - Pointer to store mode to.
//!
//! OUTPUT:        *pMode       - Transceiver mode (LWAPI_3DVP_TM_ILWALID on failure)
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves mode in which a transceiver operates. Fails if
//!                context has no read-access for given transceiver.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE      - Invalid context or transceiver handle
//!                LWAPI_ILWALID_POINTER     - pMode is NULL
//!                LWAPI_ACCESS_DENIED       - Context has insufficient access rights to given transceiver 
//!                LWAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                LWAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereo3dvpapi
//! 3D Vision Pro transceiver mode:
typedef enum _LWAPI_3DVP_TRANSCEIVER_MODE
{
    LWAPI_3DVP_TM_ILWALID = 0,  //!< invalid
    LWAPI_3DVP_TM_LOW_RANGE,    //!< bidirectional
    LWAPI_3DVP_TM_MEDIUM_RANGE, //!< bidirectional
    LWAPI_3DVP_TM_HIGH_RANGE,   //!< may be bidirectinoal just up to a given range, and unidirectional beyond it
    LWAPI_3DVP_TM_COUNT,        //!< total number of transceiver modes
} LWAPI_3DVP_TRANSCEIVER_MODE;


//! \ingroup stereo3dvpapi
LWAPI_INTERFACE LwAPI_3DVP_GetTransceiverMode( Lw3DVPContextHandle hContext, Lw3DVPTransceiverHandle hTransceiver, LWAPI_3DVP_TRANSCEIVER_MODE * pMode );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_SetTransceiverMode
//
//! \code
//! INPUT:         hContext     - Handle of 3DVP context with access to given transceiver.
//!                hTransceiver - Handle of transceiver to set mode for.
//!                mode         - Mode that should be used by transceiver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Sets the mode in which a transceiver should operate. Fails
//!                if context has no write-access to given transceiver.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE      - Invalid context or transceiver handle
//!                LWAPI_ILWALID_ARGUMENT    - mode out of range
//!                LWAPI_ACCESS_DENIED       - Context has insufficient access rights to given transceiver 
//!                LWAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                LWAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_3DVP_SetTransceiverMode( Lw3DVPContextHandle hContext, Lw3DVPTransceiverHandle hTransceiver, LWAPI_3DVP_TRANSCEIVER_MODE mode );




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_GetTransceiverState
//
//! \fn LwAPI_3DVP_GetTransceiverState
//! \code
//! INPUT:         hContext     - Handle of 3DVP context with access to given transceiver.
//!                hTransceiver - Handle of transceiver to get state for.
//!                pState       - Pointer to store transceiver state to.
//!
//! OUTPUT:        *pState      - Current transceiver state (undefined on
//!                               failure).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves the hardware state of a transceiver. Fails if
//!                context cannot be accessed.
//!
//! RETURN STATUS: LWAPI_OK                          - Success
//!                LWAPI_ERROR                       - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED         - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE              - Invalid context or transceiver handle
//!                LWAPI_ILWALID_POINTER             - pState is NULL
//!                LWAPI_INCOMPATIBLE_STRUCT_VERSION - *pState version incompatible
//!                LWAPI_ACCESS_DENIED               - Context has insufficient access rights to given transceiver 
//!                LWAPI_NOT_SUPPORTED               - Function is not supported by HW
//!                LWAPI_NO_IMPLEMENTATION           - Function is not implemented by SW
//! \endcode
///////////////////////////////////////////////////////////////////////////////


//! \ingroup stereo3dvpapi
//! 3D Vision Pro transceiver state:
typedef struct
{
    LwU32 version; // LwAPI struct version
    LwU32 button;  // button state [bitfield: button0, ..., button31]
    LwS32 wheel;   // wheel state [relative clicks]
}  LWAPI_3DVP_TRANSCEIVER_STATE;

//! \ingroup stereo3dvpapi
#define LWAPI_3DVP_TRANSCEIVER_STATE_VER MAKE_LWAPI_VERSION(LWAPI_3DVP_TRANSCEIVER_STATE,1)

//! \ingroup stereo3dvpapi
LWAPI_INTERFACE LwAPI_3DVP_GetTransceiverState( Lw3DVPContextHandle hContext, Lw3DVPTransceiverHandle hTransceiver, LWAPI_3DVP_TRANSCEIVER_STATE * pState );


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_PairGlasses
//
//! \fn LwAPI_3DVP_PairGlasses
//! \code
//! INPUT:         hContext     - Handle of 3DVP context with access to given transceiver.
//!                hTransceiver - Handle of transceiver to pair glasses on.
//!                timeOut      - Pairing timeout in seconds or pairing mode (see description).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Puts a transceiver into pairing mode to gather additional
//!                3DVP glasses, where the time out value controls the pairing:
//!                - STOP_PAIRING stops any pairing by zero timeout,
//!                - START_PAIRING_BEACON starts continuous pairing via beacon
//!                  mode, and
//!                - any other number N puts the transceiver into pairing mode
//!                  for N seconds.
//!                Fails if context has no write-access to given transceiver.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE      - Invalid context or transceiver handle
//!                LWAPI_ACCESS_DENIED       - Context has insufficient access rights to given transceiver 
//!                LWAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                LWAPI_NO_IMPLEMENTATION           - Function is not implemented by SW
//! \endcode
///////////////////////////////////////////////////////////////////////////////


//! \ingroup stereo3dvpapi
//! 3D Vision Pro pairing mode - to be used as timeOur values for PairGlasses() to control beacon pairing
typedef enum _LWAPI_3DVP_PAIRING_MODE
{
    LWAPI_3DVP_PM_STOP_PAIRING         = 0,          //!< stops any pairing
    LWAPI_3DVP_PM_START_PAIRING_BEACON = 0xFFFFFFFF, //!< starts pairing in beacon mode
} LWAPI_3DVP_PAIRING_MODE;

//! \ingroup stereo3dvpapi
LWAPI_INTERFACE LwAPI_3DVP_PairGlasses( Lw3DVPContextHandle hContext, Lw3DVPTransceiverHandle hTransceiver, LwU32 timeOut );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_UnpairGlasses
//
//! \code
//! INPUT:         hContext     - Handle of 3DVP context with access to given transceiver.
//!                hTransceiver - Handle of transceiver to unpair glasses from.
//!                hGlasses     - Handle of glasses to unpair from transceiver. Set this
//!                               to NULL to unpair *any* glasses.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Tells a specific pair of glasses ( glasses != NULL ), or
//!                *all* glasses ( glasses == NULL ) to unpair (glasses will
//!                "forget" the address of the transceiver to which they have
//!                been paired). Fails if context has no write-access to given
//!                transceiver.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE      - Invalid context or transceiver handle
//!                LWAPI_ACCESS_DENIED       - Context has insufficient access rights to given transceiver 
//!                LWAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                LWAPI_NO_IMPLEMENTATION           - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_3DVP_UnpairGlasses( Lw3DVPContextHandle hContext, Lw3DVPTransceiverHandle hTransceiver, Lw3DVPGlassesHandle hGlasses );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_DiscoverGlasses
//! \code
//! INPUT:         hContext     - Handle of 3DVP context with access to given transceiver.
//!                hTransceiver - Handle of transceiver to discover glasses on.
//!                timeOut      - Timeout in seconds for discovering glasses.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Glasses that have been paired using START_PAIRING_BEACON are
//!                unknown to the transceiver until they are manually discovered
//!                using LwAPI_3DVP_DiscoverGlasses.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE      - Invalid context or transceiver handle
//!                LWAPI_ACCESS_DENIED       - Context has insufficient access rights to given transceiver 
//!                LWAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                LWAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_3DVP_DiscoverGlasses( Lw3DVPContextHandle hContext, Lw3DVPTransceiverHandle hTransceiver, LwU32 timeOut );






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_EnumGlasses
//
//! \code
//! INPUT:         hContext     - Handle of 3DVP context with access to given transceiver.
//!                hTransceiver - Handle of transceiver to enumerate glasses on.
//!                phGlasses    - Pointer to store glasses handle to. Set this
//!                               to NULL to begin an enumeration, and pass last
//!                               result to continue an enumeration.
//!
//! OUTPUT:        *phGlasses   - Enumerated transceiver handle (NULL on failure
//!                               and on end of enumeration).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Enumerates glasses on a given transceiver. Set
//!                *phGlasses to NULL to start a new enumeration, and to
//!                the last enumeration result to continue an enumeration.
//!                Returns LWAPI_END_ENUMERATION and sets *phGlasses to
//!                NULL at the end of an enumeration. Fails if context has no
//!                read-access for given transceiver.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE      - Invalid context or transceiver handle
//!                LWAPI_ILWALID_POINTER     - phGlasses is NULL
//!                LWAPI_ACCESS_DENIED       - Context has insufficient access rights to given transceiver 
//!                LWAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                LWAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_3DVP_EnumGlasses( Lw3DVPContextHandle hContext, Lw3DVPTransceiverHandle hTransceiver, Lw3DVPGlassesHandle * phGlasses );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_GetTransceiver
//
//! \code
//! INPUT:         hContext       - Handle of 3DVP context with access to given glasses.
//!                hGlasses       - Handle of glasses to get transceiver for.
//!                phTransceiver  - Pointer to store transceiver handle to.
//!
//! OUTPUT:        *phTransceiver - Handle of transceiver to which given glasses
//!                                 are paired (NULL on failure).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves transceiver to that given glasses are associated.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE      - Invalid context or glasses handle
//!                LWAPI_ILWALID_POINTER     - phTransceiver is NULL
//!                LWAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_3DVP_GetTransceiver( Lw3DVPContextHandle hContext, Lw3DVPGlassesHandle hGlasses, Lw3DVPTransceiverHandle * pTransceiver );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_GetGlassesAccess
//
//! \code
//! INPUT:         hContext - Handle of 3DVP context with access to given glasses.
//!                hGlasses - Handle of glasses to get access mode for.
//!                pAccess  - Pointer to store access mode to.
//!
//! OUTPUT:        *pAccess - Glasses access mode (LWAPI_3DVP_ACC_NONE on
//!                          failure).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves the access mode for given glasses, which is
//!                inherited from (= equals) the access mode to the
//!                transceiver to which given glasses are paired.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE      - Invalid context or glasses handle
//!                LWAPI_ILWALID_POINTER     - pAccess is NULL
//!                LWAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_3DVP_GetGlassesAccess( Lw3DVPContextHandle hContext, Lw3DVPGlassesHandle hGlasses, LWAPI_3DVP_ACCESS * pAccess );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_IdentifyGlasses
//
//! \code
//! INPUT:         hContext - Handle of 3DVP context with access to given glasses.
//!                hGlasses - Handle of glasses to identify.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Causes glasses LEDs to flash for a short period of time.
//!                Fails if context has no write-access for given glasses.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE      - Invalid context or glasses handle
//!                LWAPI_ACCESS_DENIED       - Context has insufficient access rights to given glasses
//!                LWAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                LWAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_3DVP_IdentifyGlasses( Lw3DVPContextHandle hContext, Lw3DVPGlassesHandle hGlasses );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_ResetGlassesToFactorySettings
//
//! \code
//! INPUT:         hContext - Handle of 3DVP context with access to given glasses.
//!                hGlasses - Handle of glasses to reset.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Resets glasses to factory settings. Fails if given context
//!                has no write-access for given glasses.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE      - Invalid context or glasses handle
//!                LWAPI_ACCESS_DENIED       - Context has insufficient access rights to given glasses
//!                LWAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                LWAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_3DVP_ResetGlassesToFactorySettings( Lw3DVPContextHandle hContext, Lw3DVPGlassesHandle hGlasses );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_GetGlassesInfo
//
//! \fn LwAPI_3DVP_GetGlassesInfo
//! \code
//! INPUT:         hContext - Handle of 3DVP context with access to given glasses.
//!                hGlasses - Handle of glasses to get info for.
//!                pInfo    - Pointer to store glasses info to.
//!
//! OUTPUT:        *pInfo   - Glasses info (undefined on failure).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves info about glasses. Fails if context has no
//!                read-access to given glasses.
//!
//! RETURN STATUS: LWAPI_OK                          - Success
//!                LWAPI_ERROR                       - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED         - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE              - Invalid context or glasses handle
//!                LWAPI_ILWALID_POINTER             - pInfo is NULL
//!                LWAPI_INCOMPATIBLE_STRUCT_VERSION - *pInfo version incompatible
//!                LWAPI_ACCESS_DENIED               - Context has insufficient access rights to given glasses
//!                LWAPI_NOT_SUPPORTED               - Function is not supported by HW
//!                LWAPI_NO_IMPLEMENTATION           - Function is not implemented by SW
//! \endcode
///////////////////////////////////////////////////////////////////////////////


//! \ingroup stereo3dvpapi
//! 3D Vision Pro glasses info:
typedef struct
{
    LwU32                    version;      //!< LwAPI struct version
    LwU32                    hwFeatures;   //!< opaque bitfield of HW features
    LwU32                    fwRevA;       //!< firmware version of chip A
    LWAPI_3DVP_RF_ADDRESS    rfAddress;    //!< RF address assigned to these glasses
    LWAPI_3DVP_SERIAL_NUMBER serialNumber; //!< serial number
    LwU32                    repairCount;  //!< number of times these glasses have been re-paired
}  LWAPI_3DVP_GLASSES_INFO;

//! LWAPI_3DVP_GLASSES_INFO version history:
//! 1 - intial version
//! 2 - added serialNumber, repairCount
#define LWAPI_3DVP_GLASSES_INFO_VER MAKE_LWAPI_VERSION(LWAPI_3DVP_GLASSES_INFO,2)

//! \ingroup stereo3dvpapi
LWAPI_INTERFACE LwAPI_3DVP_GetGlassesInfo( Lw3DVPContextHandle hContext, Lw3DVPGlassesHandle hGlasses, LWAPI_3DVP_GLASSES_INFO * pInfo );


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_GetGlassesSyncCycle
//
//! \code
//! INPUT:         hContext - Handle of 3DVP context with access to given glasses.
//!                hGlasses - Handle of glasses to get sync cycle for.
//!                pCycle   - Pointer to store glasses sync cycle to.
//!
//! OUTPUT:        *pCycle  - Glasses sync cycle [milliseconds] (0 on failure).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves the sync cycle duration [milliseconds] of glasses.
//!                Fails if context has no read-access to given glasses.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE      - Invalid context or glasses handle
//!                LWAPI_ILWALID_POINTER     - pCycle is NULL
//!                LWAPI_ACCESS_DENIED       - Context has insufficient access rights to given glasses
//!                LWAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                LWAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_3DVP_GetGlassesSyncCycle( Lw3DVPContextHandle hContext, Lw3DVPGlassesHandle hGlasses, LwU32 * pSyncCycle );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_SetGlassesSyncCycle
//
//! \code
//! INPUT:         hContext - Handle of 3DVP context with access to given glasses.
//!                hGlasses - Handle of glasses to set sync cycle for.
//!                cycle    - Glasses sync cycle [milliseconds].
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Sets the sync cycle duration [milliseconds] that glasses
//!                should use. Fails if context has no write-access for given
//!                glasses.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE      - Invalid context or glasses handle
//!                LWAPI_ACCESS_DENIED       - Context has insufficient access rights to given glasses
//!                LWAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                LWAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_3DVP_SetGlassesSyncCycle( Lw3DVPContextHandle hContext, Lw3DVPGlassesHandle hGlasses, LwU32 syncCycle );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_GetGlassesName
//
//! \code
//! INPUT:         hContext - Handle of 3DVP context with access to given glasses.
//!                hGlasses - Handle of glasses to get name of.
//!                pName    - Pointer to store glasses name to.
//!
//! OUTPUT:        *pName   - Glasses name ("" on failure).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves name of glasses. Fails if context has no
//!                read-access for given glasses.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE      - Invalid context or glasses handle
//!                LWAPI_ILWALID_POINTER     - pName is NULL
//!                LWAPI_ACCESS_DENIED       - Context has insufficient access rights to given glasses
//!                LWAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                LWAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_3DVP_GetGlassesName( Lw3DVPContextHandle hContext, Lw3DVPGlassesHandle hGlasses, LwAPI_UnicodeString * pName );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_SetGlassesName
//
//! \code
//! INPUT:         hContext - Handle of 3DVP context with access to given glasses.
//!                hGlasses - Handle of glasses to set name of.
//!                name     - Glasses name.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Sets name that glasses should use. Fails if context has no
//!                write-access for given glasses.
//!
//! RETURN STATUS: LWAPI_OK                  - Success
//!                LWAPI_ERROR               - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE      - Invalid context or glasses handle
//!                LWAPI_ACCESS_DENIED       - Context has insufficient access rights to given glasses
//!                LWAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                LWAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_3DVP_SetGlassesName( Lw3DVPContextHandle hContext, Lw3DVPGlassesHandle hGlasses, LwAPI_UnicodeString name );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_GetGlassesState
//
//! \fn LwAPI_3DVP_GetGlassesState
//! \code
//! INPUT:         hContext - Handle of 3DVP context with access to given glasses.
//!                hGlasses - Handle of glasses to get state for.
//!                pState   - Pointer to store glasses state to.
//!
//! OUTPUT:        *pState  - Current state of given glasses (undefined on
//!                           failure).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves state of glasses - note that the state of glasses
//!                is updated just once per sync cycle so that its update
//!                frequency equals 1 / (glasses' sync cycle duration).
//!                Fails if context has no read-access for given glasses.
//!
//! RETURN STATUS: LWAPI_OK                          - Success
//!                LWAPI_ERROR                       - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED         - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE              - Invalid context or glasses handle
//!                LWAPI_ILWALID_POINTER             - pState is NULL
//!                LWAPI_INCOMPATIBLE_STRUCT_VERSION - *pState version incompatible
//!                LWAPI_ACCESS_DENIED               - Context has insufficient access rights to given glasses
//!                LWAPI_NOT_SUPPORTED               - Function is not supported by HW
//!                LWAPI_NO_IMPLEMENTATION           - Function is not implemented by SW
//! \endcode
///////////////////////////////////////////////////////////////////////////////


//! \ingroup stereo3dvpapi
//! 3D Vision Pro glasses state:
typedef struct
{
    LwU32 version;         //!< LwAPI struct version
    LwU32 missedCycles;    //!< number of recently missed state sync cycles
    LwU32 battery;         //!< battery level [percent]
    LwU32 batteryVoltage;  //!< battery voltage
    LwU32 batteryCharging; //!< battery charge state
}  LWAPI_3DVP_GLASSES_STATE;

//! LWAPI_3DVP_GLASSES_STATE version history:
//! 1 - intial version
//! 2 - added batteryVoltage, batteryCharging; removed compass, accel
#define LWAPI_3DVP_GLASSES_STATE_VER MAKE_LWAPI_VERSION(LWAPI_3DVP_GLASSES_STATE,1)

//! \ingroup stereo3dvpapi
LWAPI_INTERFACE LwAPI_3DVP_GetGlassesState( Lw3DVPContextHandle hContext, Lw3DVPGlassesHandle hGlasses, LWAPI_3DVP_GLASSES_STATE * pState );

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_3DVP_WaitEvent
//
//! \fn LwAPI_3DVP_WaitEvent
//! \code
//! INPUT:         hContext - Handle of 3DVP context on whose events to wait.
//!                pEvent   - Pointer to store an event to
//!                timeout  - Timeout in milliseconds used to wait for events.
//!
//! OUTPUT:        *pEvent  - 3DVP event (undefined on failure).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Waits for a 3DVP event and stores it in *pEvent. Note that
//!                this functions blocks until an event was generated, so that
//!                it should be exelwted in a dedicated thread.
//!                Destroy the context passed to WaitEvent to stop waiting for
//!                events (WaitEvent will return a CONTEXT_DESTROYED event).
//!
//! RETURN STATUS: LWAPI_OK                          - Success
//!                LWAPI_TIMEOUT                     - WaitEvent timed out waiting for events
//!                LWAPI_ERROR                       - Unspecified error
//!                LWAPI_API_NOT_INITIALIZED         - LwAPI was not intialized
//!                LWAPI_ILWALID_HANDLE              - Invalid context handle
//!                LWAPI_ILWALID_POINTER             - pEvent is NULL
//!                LWAPI_INCOMPATIBLE_STRUCT_VERSION - *pEvent version incompatible
//!                LWAPI_NOT_SUPPORTED               - Function is not supported by HW
//!                LWAPI_NO_IMPLEMENTATION           - Function is not implemented by SW
//! \endcode
///////////////////////////////////////////////////////////////////////////////


//! \ingroup stereo3dvpapi
// 3D Vision Pro event types:
typedef enum _LWAPI_3DVP_EVENT_TYPE
{
    LWAPI_3DVP_ET_ILWALID = 0,                  //!< no event type
    LWAPI_3DVP_ET_CONTEXT_DESTROYED,            //!< context that was passed to WaitEvent has been destroyed
    LWAPI_3DVP_ET_TRANSCEIVER_ENUM_DIRTY,       //!< enumeration of transceivers has been ilwalidated (PnP)
    LWAPI_3DVP_ET_TRANSCEIVER_STALLED,          //!< given transceiver stalled due to an internal error
    LWAPI_3DVP_ET_AIRPLANE_MODE_TOGGLED,        //!< airplane mode was toggled for given transceiver
    LWAPI_3DVP_ET_SIGNAL_QUALITY_CHANGED,       //!< signal quality changed for given transceiver
    LWAPI_3DVP_ET_PAIRING_GLASSES_STARTED,      //!< given transceiver started pairing glasses
    LWAPI_3DVP_ET_PAIRING_GLASSES_COMPLETE,     //!< given transceiver completed pairing glasses
    LWAPI_3DVP_ET_DISCOVERING_GLASSES_STARTED,  //!< given transceiver started discovering glasses
    LWAPI_3DVP_ET_DISCOVERING_GLASSES_COMPLETE, //!< given transceiver completed discovering glasses
    LWAPI_3DVP_ET_GLASSES_ENUM_DIRTY,           //!< enumeration of glasses changed for given transceiver
    LWAPI_3DVP_ET_GLASSES_NAMES_CHANGED,        //!< names of some glasses changed for given transceiver
    LWAPI_3DVP_ET_GLASSES_STATES_CHANGED,       //!< state of some glasses changed for given transceiver
    LWAPI_3DVP_ET_COUNT,                        //!< total number of event types (not an event type)
} LWAPI_3DVP_EVENT_TYPE;

//! 3D Vision Pro event:
typedef struct
{
    LwU32                   version;      //!< LwAPI struct version
    LWAPI_3DVP_EVENT_TYPE   type;         //!< event type (see above)
    Lw3DVPTransceiverHandle hTransceiver; //!< optional: transceiver this events refers to (see LWAPI_3DVP_EVENT_TYPE)
} LWAPI_3DVP_EVENT;

//! LWAPI_3DVP_EVENT version history:
//! 1 - intial version
//! 2 - replaced event arg union by single, optional transceiver parameter
#define LWAPI_3DVP_EVENT_VER MAKE_LWAPI_VERSION(LWAPI_3DVP_EVENT,2)

//! \ingroup stereo3dvpapi
LWAPI_INTERFACE LwAPI_3DVP_WaitEvent( __in  Lw3DVPContextHandle hContext,
                                      __inout LWAPI_3DVP_EVENT * pEvent,
                                      __in LwU32 timeout );

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetDisplayDriverVersion
//! \fn LwAPI_GetDisplayDriverVersion(LwDisplayHandle hLwDisplay, LW_DISPLAY_DRIVER_VERSION *pVersion)
//! This function returns a struct that describes aspects of the display driver
//!                build.
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use LwAPI_SYS_GetDriverAndBranchVersion.
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 80
//!
//! \param [in]  hLwDisplay LWPU display handle.
//! \param [out] pVersion Pointer to LW_DISPLAY_DRIVER_VERSION struc
//!
//! \retval LWAPI_ERROR
//! \retval LWAPI_OK
///////////////////////////////////////////////////////////////////////////////

//! \ingroup driverapi
//! Used in LwAPI_GetDisplayDriverVersion()
typedef struct 
{
    LwU32              version;             // Structure version
    LwU32              drvVersion;           
    LwU32              bldChangeListNum;     
    LwAPI_ShortString  szBuildBranchString; 
    LwAPI_ShortString  szAdapterString;
} LW_DISPLAY_DRIVER_VERSION;

//! \ingroup driverapi
#define LW_DISPLAY_DRIVER_VERSION_VER  MAKE_LWAPI_VERSION(LW_DISPLAY_DRIVER_VERSION,1)


//! \ingroup driverapi
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use LwAPI_SYS_GetDriverAndBranchVersion.")
LWAPI_INTERFACE LwAPI_GetDisplayDriverVersion(LwDisplayHandle hLwDisplay, LW_DISPLAY_DRIVER_VERSION *pVersion);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SYS_GetDriverAndBranchVersion
//
//!   DESCRIPTION: This API returns display driver version and driver-branch string.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! 
//! \param [out]  pDriverVersion         Contains the driver version after successful return.
//! \param [out]  szBuildBranchString    Contains the driver-branch string after successful return.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT: either pDriverVersion is NULL or enum index too big
//! \retval ::LWAPI_OK - completed request
//! \retval ::LWAPI_API_NOT_INTIALIZED - LWAPI not initialized
//! \retval ::LWAPI_ERROR - miscellaneous error oclwrred
//! 
//! \ingroup driverapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetDriverAndBranchVersion(LwU32* pDriverVersion, LwAPI_ShortString szBuildBranchString);

//! \ingroup driverapi
//! Used in LwAPI_GPU_GetMemoryInfo().
typedef struct 
{
    LwU32   version;                        //!< Version info
    LwU32   dedicatedVideoMemory;           //!< Size(in kb) of the physical framebuffer.
    LwU32   availableDedicatedVideoMemory;  //!< Size(in kb) of the available physical framebuffer for allocating video memory surfaces.
    LwU32   systemVideoMemory;              //!< Size(in kb) of system memory the driver allocates at load time.
    LwU32   sharedSystemMemory;             //!< Size(in kb) of shared system memory that driver is allowed to commit for surfaces across all allocations.

} LW_DISPLAY_DRIVER_MEMORY_INFO_V1;


//! \ingroup driverapi
//! Used in LwAPI_GPU_GetMemoryInfo().
typedef struct
{
    LwU32   version;                           //!< Version info
    LwU32   dedicatedVideoMemory;              //!< Size(in kb) of the physical framebuffer.
    LwU32   availableDedicatedVideoMemory;     //!< Size(in kb) of the available physical framebuffer for allocating video memory surfaces.
    LwU32   systemVideoMemory;                 //!< Size(in kb) of system memory the driver allocates at load time.
    LwU32   sharedSystemMemory;                //!< Size(in kb) of shared system memory that driver is allowed to commit for surfaces across all allocations.
    LwU32   lwrAvailableDedicatedVideoMemory;  //!< Size(in kb) of the current available physical framebuffer for allocating video memory surfaces.

} LW_DISPLAY_DRIVER_MEMORY_INFO_V2;


//! \ingroup driverapi
typedef LW_DISPLAY_DRIVER_MEMORY_INFO_V2 LW_DISPLAY_DRIVER_MEMORY_INFO;

//! \ingroup driverapi
//! Macro for constructing the version field of LW_DISPLAY_DRIVER_MEMORY_INFO_V1
#define LW_DISPLAY_DRIVER_MEMORY_INFO_VER_1  MAKE_LWAPI_VERSION(LW_DISPLAY_DRIVER_MEMORY_INFO_V1,1)

//! \ingroup driverapi
//! Macro for constructing the version field of LW_DISPLAY_DRIVER_MEMORY_INFO_V2
#define LW_DISPLAY_DRIVER_MEMORY_INFO_VER_2  MAKE_LWAPI_VERSION(LW_DISPLAY_DRIVER_MEMORY_INFO_V2,2)

//! \ingroup driverapi
#define LW_DISPLAY_DRIVER_MEMORY_INFO_VER    LW_DISPLAY_DRIVER_MEMORY_INFO_VER_2




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetMemoryInfo
//
//!   DESCRIPTION: This function retrieves the available driver memory footprint for the specified GPU. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 177
//!
//!  \param [in]   hPhysicalGpu  Handle of the physical GPU for which the memory information is to be extracted.
//!  \param [out]  pMemoryInfo   The memory footprint available in the driver. See LW_DISPLAY_DRIVER_MEMORY_INFO.
//!
//!  \retval       LWAPI_ILWALID_ARGUMENT             pMemoryInfo is NULL.
//!  \retval       LWAPI_OK                           Call successful.
//!  \retval       LWAPI_LWIDIA_DEVICE_NOT_FOUND      No LWPU GPU driving a display was found.
//!  \retval       LWAPI_INCOMPATIBLE_STRUCT_VERSION  LW_DISPLAY_DRIVER_MEMORY_INFO structure version mismatch.
//!
//!  \ingroup  driverapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetMemoryInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_DISPLAY_DRIVER_MEMORY_INFO *pMemoryInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetDisplayDriverMemoryInfo
//
//! This function retrieves the display driver memory information for the active display handle. \n 
//! In a multi-GPU scenario, the physical framebuffer information is obtained for the GPU associated with active display handle. \n
//! In an SLI-mode scenario, the physical framebuffer information is obtained only from the display owner GPU. \n
//!
//!
//! \deprecated  Do not use this function - it is deprecated in release 313. Instead, use LwAPI_GPU_GetMemoryInfo.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [in]  hLwDisplay   LWPU Display selection. It can be #LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [out] pMemoryInfo  The memory footprint available in the driver.
//!
//! \retval  LWAPI_ILWALID_ARGUMENT             pMemoryInfo is NULL.
//! \retval  LWAPI_OK                           Call successful.
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND      No LWPU GPU driving a display was found.
//! \retval  LWAPI_EXPECTED_DISPLAY_HANDLE      hLwDisplay is not a valid display handle.
//! \retval  LWAPI_INCOMPATIBLE_STRUCT_VERSION  LW_DISPLAY_DRIVER_MEMORY_INFO structure version mismatch.
//! \ingroup driverapi
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 313. Instead, use LwAPI_GPU_GetMemoryInfo.")
LWAPI_INTERFACE LwAPI_GetDisplayDriverMemoryInfo(LwDisplayHandle hLwDisplay, LW_DISPLAY_DRIVER_MEMORY_INFO *pMemoryInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetDriverMemoryInfo
//
//! \fn LwAPI_GetDriverMemoryInfo(LwDisplayHandle hLwDisplay, LW_DRIVER_MEMORY_INFO *pMemoryInfo)
//!   DESCRIPTION: This function retrieves the display driver memory information for the active display handle. 
//!                In case of a multi-GPU scenario the physical framebuffer information is obtained for the GPU
//!                associated with the active display handle.
//!                In the case of SLI, the physical framebuffer information is obtained only from the display owner GPU.
//!
//! \deprecated  Do not use this function - it is deprecated in release 313. Instead, use LwAPI_GPU_GetMemoryInfo.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 177
//!
//! \param [in]   hLwDisplay        LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [out]  pMemoryInfo       The memory footprint available in the driver.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT
//! \retval ::LWAPI_OK
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND
//! \retval ::LWAPI_EXPECTED_DISPLAY_HANDLE 
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION   LW_DISPLAY_DRIVER_MEMORY_INFO structure version mismatch.
//
///////////////////////////////////////////////////////////////////////////////

 
//! \ingroup driverapi
//! Driver memory information - used in LwAPI_GetDriverMemoryInfo().
typedef struct 
{
    LwU32   version;                        //!< Version info
    LwU32   dedicatedVideoMemory;           //!< Size(in kb) of the physical framebuffer.
    LwU32   systemVideoMemory;              //!< Size(in kb) of system memory the driver allocates at load time.
    LwU32   sharedSystemMemory;             //!< Size(in kb) of shared system memory that driver is allowed to commit for surfaces across all allocations.

} LW_DRIVER_MEMORY_INFO;

//! \ingroup driverapi
//! Used in LW_DRIVER_MEMORY_INFO.
#define LW_DRIVER_MEMORY_INFO_VER   MAKE_LWAPI_VERSION(LW_DRIVER_MEMORY_INFO,1)


//! \ingroup driverapi 
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 313. Instead, use LwAPI_GPU_GetMemoryInfo.")
LWAPI_INTERFACE LwAPI_GetDriverMemoryInfo(LwDisplayHandle hLwDisplay, LW_DRIVER_MEMORY_INFO *pMemoryInfo);






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetDisplayDriverBuildTitle
//
//!  This function retrieves a string describing the driver build (its title).
//!  This corresponds in the driver build to the #define LW_DISPLAY_DRIVER_TITLE. 
//!
//!  For example, for "Nightly lwr40 40021217 Chloe_Palenchar"
//!        -  The first word is one of "Official" (for BM), "Nightly" (for BM),
//!           "DVSvirtual", "DVSreal", or "Private", describing the build source.
//!        - The second word will be the branch, minus "OEM/" if it exists eg: R40B4, lwr40, main
//!        - The third word will either be a version or a directory-ish name eg: 41.11, 35021216, LW021216
//!        - The fourth word is the author of the most recent changelist that went into the build 
//!          (or author of virtual submission), or "unknown".
//!        - There will always be at least 2 space characters in the string. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \return  LWAPI_ERROR or LWAPI_OK
//! \ingroup driverapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetDisplayDriverBuildTitle(LwDisplayHandle hLwDisplay, LwAPI_String szTitle);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetDisplayDriverCompileType
//
//! \fn LwAPI_GetDisplayDriverCompileType(LwDisplayHandle hLwDisplay, LwU32 *pCompileType)
//!  This function retrieves a value describing the compile type of the display driver.
//!
//!                See enum ::LWAPI_COMPILE_TYPE
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \return  LWAPI_ERROR or LWAPI_OK
///////////////////////////////////////////////////////////////////////////////

//! \ingroup driverapi
typedef enum
{
    LWAPI_COMPILE_TYPE_UNKNONW = 0,
    LWAPI_COMPILE_TYPE_DEBUG   = 1,
    LWAPI_COMPILE_TYPE_RELEASE = 2,
    LWAPI_COMPILE_TYPE_DEVELOP = 3
} LWAPI_COMPILE_TYPE;

//! \ingroup driverapi
LWAPI_INTERFACE LwAPI_GetDisplayDriverCompileType(LwDisplayHandle hLwDisplay, LwU32 *pCompileType);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetDisplayDriverSelwrityType
//
//!  This function retrieves a value describing the display driver security level.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \return  LWAPI_ERROR or LWAPI_OK
//! \ingroup driverapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetDisplayDriverSelwrityLevel(LwDisplayHandle hLwDisplay, LwU32 *pdrvSelwrityLevel);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Diag_GetLwConfigData
//
//! \fn LwAPI_Diag_GetLwConfigData(LW_DIAG_LWCONFIG_DATA *pLwConfigData)
//! \code
//!   DESCRIPTION: Retrieves an encrypted form of the lwconfig data active when lwapi.dll
//!                was constructed.  Consumed by swak.
//!
//!   dataSize member is set to the size of the data returned in the 'data' member
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: LWAPI_ERROR or LWAPI_OK
//!                LWAPI_INCOMPATIBLE_STRUCT_VERSION: if LW_DIAG_LWCONFIG_DATA structure version mismatches.
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup driverapi
#define LW_MAX_LWCONFIG_BUFFER_SIZE (128*1024)

//! \ingroup driverapi
typedef struct
{
    LwU32      version;       //!< structure version
    LwU32      dataSize;      //!< number of lwconfig bytes actually loaded
    LwU8       data[LW_MAX_LWCONFIG_BUFFER_SIZE];
} LW_DIAG_LWCONFIG_DATA;

//! \ingroup driverapi
//! Macro for constructing the version field of LW_DIAG_LWCONFIG_DATA
#define LW_DIAG_LWCONFIG_DATA_VER  MAKE_LWAPI_VERSION(LW_DIAG_LWCONFIG_DATA,1)

//! \ingroup driverapi
LWAPI_INTERFACE LwAPI_Diag_GetLwConfigData(LW_DIAG_LWCONFIG_DATA *pLwConfigData);




//! \ingroup driverapi
//! Driver access type flags - used in LW_REGISTRY_DATA
typedef enum 
{
    // driver access type flags
    LWAPI_REG_READ_DWORD      , //!< read a dword registry value
    LWAPI_REG_WRITE_DWORD     , //!< write a dword registry value
    LWAPI_REG_READ_BINARY     , //!< read a binary registry value
    LWAPI_REG_WRITE_BINARY    , //!< write a binary registry value
    LWAPI_REG_DELETE_VALUE    , //!< deletes a specific value

} LWAPI_REG_ACCESS_TYPE;

//! \ingroup driverapi
#define LW_MAX_REGISTRY_KEY_NAME 1024

//! \ingroup driverapi
#define LW_MAX_REGISTRY_KEY_VALUE_SIZE 32768

//! \ingroup driverapi
//! Used in LwAPI_AccessDisplayDriverRegistry()
typedef struct
{
    LwU32                      version;                              //!< structure version
    LWAPI_REG_ACCESS_TYPE      iAccessType;                          //!< read or write, DWORD or binary
    char                       pszKeyName[LW_MAX_REGISTRY_KEY_NAME]; //!< display driver registry key to read or write
    LwU32                      cbData;                               //!< size of data to read or write
    void                       *pvData;                              //!< data to read or write
} LW_REGISTRY_DATA;

//! \ingroup driverapi
#define LW_REGISTRY_DATA_VER  MAKE_LWAPI_VERSION(LW_REGISTRY_DATA,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_AccessDisplayDriverRegistry
//
//
//!  This function allows DWORD or binary read/write access to the display driver registry.
//!  The path to the registry is fixed to the display driver registry path for
//!  the hLwDisplay.  Only that registry path will be used and is determined at runtime.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 85
//!
//! \param  hLwDisplay  handle to display you wish to read/write values for
//! \param  plwRegData  Parameter block for registry operation.  Only pass in the
//!                     key name, not a path.
//!
//! \return  LWAPI_ERROR, LWAPI_OK, or invalid device
//! \ingroup driverapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_AccessDisplayDriverRegistry(LwDisplayHandle hLwDisplay, LW_REGISTRY_DATA *plwRegData);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetDisplayDriverRegistryPath
//
//!  This function retrieves the display device registry path.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \return  LWAPI_ERROR or LWAPI_OK
//! \ingroup driverapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetDisplayDriverRegistryPath(LwDisplayHandle hLwDisplay, LwAPI_String szRegistryPath);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetUnAttachedDisplayDriverRegistryPath
//
//!  This function retrieves the display device registry path for the unattached display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Version: 95
//!
//! \return  LWAPI_ERROR or LWAPI_OK
//! \ingroup driverapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetUnAttachedDisplayDriverRegistryPath(LwUnAttachedDisplayHandle hLwUnAttachedDisp, LwAPI_String szRegistryPath);






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_ExpertModeSet[Get]
//
//! \name LwAPI_OGL_ExpertModeSet[Get] Functions
//@{
//!  This function configures OpenGL Expert Mode, an API usage feedback and
//!  advice reporting mechanism. The effects of this call are
//!  applied only to the current context, and are reset to the
//!  defaults when the context is destroyed.
//!
//!  \note  This feature is valid at runtime only when GLExpert
//!         functionality has been built into the OpenGL driver
//!         installed on the system. All Windows Vista OpenGL
//!         drivers provided by LWPU have this instrumentation
//!         included by default. Windows XP, however, requires a
//!         special display driver available with the LWPU
//!         PerfSDK found at developer.lwpu.com.
//!
//!  \note These functions are valid only for the current OpenGL
//!        context. Calling these functions prior to creating a
//!        context and calling MakeLwrrent with it will result
//!        in errors and undefined behavior.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \param   expertDetailMask  Mask made up of LWAPI_OGLEXPERT_DETAIL bits,
//!                            this parameter specifies the detail level in
//!                            the feedback stream.
//!
//! \param   expertReportMask  Mask made up of LWAPI_OGLEXPERT_REPORT bits,
//!                            this parameter specifies the areas of
//!                            functional interest.
//!
//! \param   expertOutputMask  Mask made up of LWAPI_OGLEXPERT_OUTPUT bits,
//!                            this parameter specifies the feedback output
//!                            location.
//!
//! \param   expertCallback    Used in conjunction with OUTPUT_TO_CALLBACK,
//!                            this is a simple callback function the user
//!                            may use to obtain the feedback stream. The
//!                            function will be called once per fully
//!                            qualified feedback stream extry.
//!
//! \retval  LWAPI_API_NOT_INTIALIZED          LWAPI not initialized
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND     No LWPU GPU found
//! \retval  LWAPI_OPENGL_CONTEXT_NOT_LWRRENT  No LWPU OpenGL context
//!                                            which supports GLExpert
//!                                            has been made current
//! \retval  LWAPI_ERROR                       OpenGL driver failed to load properly
//! \retval  LWAPI_OK                          Success
//
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup oglapi
//! @{
#define LWAPI_OGLEXPERT_DETAIL_NONE                 0x00000000
#define LWAPI_OGLEXPERT_DETAIL_ERROR                0x00000001
#define LWAPI_OGLEXPERT_DETAIL_SWFALLBACK           0x00000002
#define LWAPI_OGLEXPERT_DETAIL_BASIC_INFO           0x00000004
#define LWAPI_OGLEXPERT_DETAIL_DETAILED_INFO        0x00000008
#define LWAPI_OGLEXPERT_DETAIL_PERFORMANCE_WARNING  0x00000010
#define LWAPI_OGLEXPERT_DETAIL_QUALITY_WARNING      0x00000020
#define LWAPI_OGLEXPERT_DETAIL_USAGE_WARNING        0x00000040
#define LWAPI_OGLEXPERT_DETAIL_ALL                  0xFFFFFFFF

#define LWAPI_OGLEXPERT_REPORT_NONE                 0x00000000
#define LWAPI_OGLEXPERT_REPORT_ERROR                0x00000001
#define LWAPI_OGLEXPERT_REPORT_SWFALLBACK           0x00000002
#define LWAPI_OGLEXPERT_REPORT_PIPELINE_VERTEX      0x00000004
#define LWAPI_OGLEXPERT_REPORT_PIPELINE_GEOMETRY    0x00000008
#define LWAPI_OGLEXPERT_REPORT_PIPELINE_XFB         0x00000010
#define LWAPI_OGLEXPERT_REPORT_PIPELINE_RASTER      0x00000020
#define LWAPI_OGLEXPERT_REPORT_PIPELINE_FRAGMENT    0x00000040
#define LWAPI_OGLEXPERT_REPORT_PIPELINE_ROP         0x00000080
#define LWAPI_OGLEXPERT_REPORT_PIPELINE_FRAMEBUFFER 0x00000100
#define LWAPI_OGLEXPERT_REPORT_PIPELINE_PIXEL       0x00000200
#define LWAPI_OGLEXPERT_REPORT_PIPELINE_TEXTURE     0x00000400
#define LWAPI_OGLEXPERT_REPORT_OBJECT_BUFFEROBJECT  0x00000800
#define LWAPI_OGLEXPERT_REPORT_OBJECT_TEXTURE       0x00001000
#define LWAPI_OGLEXPERT_REPORT_OBJECT_PROGRAM       0x00002000
#define LWAPI_OGLEXPERT_REPORT_OBJECT_FBO           0x00004000
#define LWAPI_OGLEXPERT_REPORT_FEATURE_SLI          0x00008000
#define LWAPI_OGLEXPERT_REPORT_ALL                  0xFFFFFFFF


#define LWAPI_OGLEXPERT_OUTPUT_TO_NONE       0x00000000
#define LWAPI_OGLEXPERT_OUTPUT_TO_CONSOLE    0x00000001
#define LWAPI_OGLEXPERT_OUTPUT_TO_DEBUGGER   0x00000004
#define LWAPI_OGLEXPERT_OUTPUT_TO_CALLBACK   0x00000008
#define LWAPI_OGLEXPERT_OUTPUT_TO_ALL        0xFFFFFFFF

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION TYPE: LWAPI_OGLEXPERT_CALLBACK
//
//!   DESCRIPTION: Used in conjunction with OUTPUT_TO_CALLBACK, this is a simple 
//!                callback function the user may use to obtain the feedback 
//!                stream. The function will be called once per fully qualified 
//!                feedback stream entry.
//!
//!   \param   categoryId    Contains the bit from the LWAPI_OGLEXPERT_REPORT 
//!                          mask that corresponds to the current message
//!   \param   messageId     Unique ID for the current message
//!   \param   detailLevel   Contains the bit from the LWAPI_OGLEXPERT_DETAIL
//!                          mask that corresponds to the current message
//!   \param   objectId      Unique ID of the object that corresponds to the
//!                          current message
//!   \param   messageStr    Text string from the current message
//!
//!   \ingroup oglapi
///////////////////////////////////////////////////////////////////////////////
typedef void (* LWAPI_OGLEXPERT_CALLBACK) (unsigned int categoryId, unsigned int messageId, unsigned int detailLevel, int objectId, const char *messageStr);



//! \ingroup oglapi
//! SUPPORTED OS:  Windows XP and higher
//!
LWAPI_INTERFACE LwAPI_OGL_ExpertModeSet(LwU32 expertDetailLevel,
                                        LwU32 expertReportMask,
                                        LwU32 expertOutputMask,
                     LWAPI_OGLEXPERT_CALLBACK expertCallback);

//! \addtogroup oglapi
//! SUPPORTED OS:  Windows XP and higher
//!
LWAPI_INTERFACE LwAPI_OGL_ExpertModeGet(LwU32 *pExpertDetailLevel,
                                        LwU32 *pExpertReportMask,
                                        LwU32 *pExpertOutputMask,
                     LWAPI_OGLEXPERT_CALLBACK *pExpertCallback);

//@}
///////////////////////////////////////////////////////////////////////////////
//
//! \name LwAPI_OGL_ExpertModeDefaultsSet[Get] Functions
//!
//@{
//!  This function configures OpenGL Expert Mode global defaults. These settings
//!  apply to any OpenGL application which starts up after these
//!  values are applied (i.e. these settings *do not* apply to
//!  lwrrently running applications).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \param   expertDetailLevel Value which specifies the detail level in
//!                            the feedback stream. This is a mask made up
//!                            of LWAPI_OGLEXPERT_LEVEL bits.
//!
//! \param   expertReportMask  Mask made up of LWAPI_OGLEXPERT_REPORT bits,
//!                            this parameter specifies the areas of
//!                            functional interest.
//!
//! \param   expertOutputMask  Mask made up of LWAPI_OGLEXPERT_OUTPUT bits,
//!                            this parameter specifies the feedback output
//!                            location. Note that using OUTPUT_TO_CALLBACK
//!                            here is meaningless and has no effect, but
//!                            using it will not cause an error.
//!
//! \return  ::LWAPI_ERROR or ::LWAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup oglapi
//! SUPPORTED OS:  Windows XP and higher
//!
LWAPI_INTERFACE LwAPI_OGL_ExpertModeDefaultsSet(LwU32 expertDetailLevel,
                                                LwU32 expertReportMask,
                                                LwU32 expertOutputMask);

//! \addtogroup oglapi
//! SUPPORTED OS:  Windows XP and higher
//!
LWAPI_INTERFACE LwAPI_OGL_ExpertModeDefaultsGet(LwU32 *pExpertDetailLevel,
                                                LwU32 *pExpertReportMask,
                                                LwU32 *pExpertOutputMask);
//@}



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_GetPersistenceData [Set]
//
//   DESCRIPTION: Retrieves, saves, and finds persist data stored in the persist file              
//
//         INPUT: hPhysicalGpu - unused (reserved for later)
//
//                pData - Detailed persistence data structure.
//
//                flags - Persistence find flags (see defines for description)
//                              
//
// RETURN STATUS: LWAPI_ILWALID_ARGUMENT: hLwDisplay is invalid
//                LWAPI_OK: the persist operation succeed
//                LWAPI_ERROR: the persist operation failed
///////////////////////////////////////////////////////////////////////////////

// Persistence find flags

//! \name Inputs: for LWAPI_GetPersistenceData() 
// @{
//! Find last mode configuration
//! - activeMask: required [index 0 is GDI primary display]
//! - connectedMasks: optional
//! - hPhysicalGpu: optional
//! \ingroup driverapi
#define LW_PERSIST_FIND_LAST_MODE     0x00000001            


//! Find last active configuration
//! - connectedMasks: optional
//! - hPhysicalGpu: optional
//! \ingroup driverapi
#define LW_PERSIST_FIND_LAST_ACTIVE   0x00000002 



//! This flag must be ORed with an LW_PERSIST_FIND_ method. 
//! This flag is used when the EDIDs of the connected devices are already known (supplied in the structure), and
//! a lookup for persistence is needed based on this information.
//! - connectedMasks: required [EDIDs are ordered from rightmost bit to left]
//! - activeMask: based on the LW_PERSIST_FIND_ method selected
//! - hPhysicalGpu: ignored
//!
//! NOTE: Not supported for LW_PERSIST_FIND_LWRRENT
//! \ingroup driverapi
#define LW_PERSIST_EDID_SUPPLIED      0x80000000           


           
//! Find current active configuration
//! - activeMask: required [index 0 is GDI primary display]
//! - connectedMasks: optional
//! - hPhysicalGpu: optional
//! \ingroup driverapi
#define LW_PERSIST_FIND_LWRRENT       0x00000003           


//! Defines to support backward compatibility (to be removed once integration completed)
//! \ingroup driverapi
#define MAX_PERSIST_DEVICES 8

// @}

//! \ingroup driverapi
//! Used in LW_PERSIST_DATA
typedef struct
{
    LwU32 width;                                //!< (IN/OUT) GDI width
    LwU32 height;                               //!< (IN/OUT) GDI height
    LwU32 depth;                                //!< (IN/OUT) GDI color depth
    LwU32 refresh;                              //!< (IN/OUT) GDI refresh rate
    LwU32 interlaced;                           //!< (IN/OUT) Interlaced mode
    LwU32 primary:1;                            //!< (IN/OUT) Desktop primary
    LwU32 posx;                                 //!< (IN/OUT) GDI x position
    LwU32 posy;                                 //!< (IN/OUT) GDI y position
} LW_PERSIST_MODE;

//! \ingroup driverapi
//! Used in LW_PERSIST_DATA_INFO
typedef struct 
{
    LwU32                  activeMask;          //!< (IN/OUT) Active device mask
    LW_TARGET_VIEW_MODE    state;               //!< (IN/OUT) lwiew state
    LwU32                  rotation;            //!< (IN/OUT) lwiew rotation
    LwU32                  scaling;             //!< (IN/OUT) lwiew scaling
    LwU32                  tvFormat;            //!< (IN/OUT) TV format
    LW_PERSIST_MODE        physicalMode;        //!< (IN/OUT) Physical mode
    LW_PERSIST_MODE        virtualMode;         //!< (IN/OUT) Virtual mode
} LW_PERSIST_DATA1;


//! \ingroup driverapi
//! Used in LW_PERSIST_DATA_INFO
typedef struct
{
    LwU32 activeMask;                           //!< (IN/OUT) Active device mask
    LW_TARGET_VIEW_MODE state;                  //!< (IN/OUT) lwiew state
    LwU32 rotation;                             //!< (IN/OUT) lwiew rotation
    LwU32 scaling;                              //!< (IN/OUT) lwiew scaling
    LwU32 tvFormat;                             //!< (IN/OUT) TV format
    LW_PERSIST_MODE physicalMode;               //!< (IN/OUT) Physical mode
    LW_PERSIST_MODE virtualMode;                //!< (IN/OUT) Virtual mode
    LwU32 connectedCRC32CommonEDIDs;            //!< (IN/OUT) Only the part of EDID that should be common for the same make of the displays. For finding partial match.
    LwU32 ulUnderscanX;                         //!< (IN/OUT) Underscan % for X
    LwU32 ulUnderscanY;                         //!< (IN/OUT) Underscan % for Y
} LW_PERSIST_DATA2;

//! \addtogroup driverapi
//! @{

typedef LW_PERSIST_DATA2        LW_PERSIST_DATA;

//! Macro for constructing the version field of LW_PERSIST_DATA1
#define LW_PERSIST_DATA_VER1    MAKE_LWAPI_VERSION(LW_PERSIST_DATA1, 1);

//! Macro for constructing the version field of LW_PERSIST_DATA2
#define LW_PERSIST_DATA_VER2    MAKE_LWAPI_VERSION(LW_PERSIST_DATA2, 2);


#define LW_PERSIST_DATA_VER     LW_PERSIST_DATA_VER2

//! @}




//! \ingroup driverapi
//! Used in LwAPI_GetPersistenceData() and LwAPI_SetPersistenceData()
typedef struct
{
    LwU32                   version;                        //!< (IN) Structure version
    LwAPI_LongString        lookupKey;                      //!< (IN/OUT) Look-up Key strings
    LwU32                   connectedMasks;                 //!< (IN/OUT) Connected device mask
    LwU32                   count;                          //!< (IN/OUT) Target count
    LW_PERSIST_DATA1        target[LWAPI_MAX_VIEW_TARGET];  //!< (IN/OUT) Persistence data
} LW_PERSIST_DATA_INFO1;


//! \ingroup driverapi
//! Used in LwAPI_GetPersistenceData() and LwAPI_SetPersistenceData()
typedef struct
{
    LwU32                   version;                        //!< (IN) Structure version
    LwAPI_LongString        lookupKey;                      //!< (IN/OUT) Lookup Key strings
    LwU32                   connectedMasks;                 //!< (IN/OUT) Connected device mask
    LwU32                   count;                          //!< (IN/OUT) Target count
    LW_PERSIST_DATA1        target[LWAPI_MAX_VIEW_TARGET];  //!< (IN/OUT) Persist data
    LW_EDID                 connectedEDIDs[LWAPI_MAX_HEADS_PER_GPU];    //!< (IN) Connected EDID list, based on connectedMask from right to left
} LW_PERSIST_DATA_INFO2;




//! \addtogroup driverapi
//! @{

//! Used in LwAPI_GetPersistenceData() and LwAPI_SetPersistenceData()
typedef struct
{
    LwU32                   version;                        //!<  (IN) structure version
    LwAPI_LongString        lookupKey;                      //!<  (IN/OUT) lookupKey strings
    LwU32                   connectedMasks;                 //!<  (IN/OUT) connected device mask
    LwU32                   count;                          //!<  (IN/OUT) target count
    LW_PERSIST_DATA1        target[LWAPI_ADVANCED_MAX_VIEW_TARGET];  //!<  (IN/OUT) persist data
    LW_EDID                 connectedEDIDs[LWAPI_MAX_HEADS_PER_GPU]; //!<  (IN) Connected EDID list, based on connectedMask from right to left
} LW_PERSIST_DATA_INFO3;


//! Used in LwAPI_GetPersistenceData() and LwAPI_SetPersistenceData()
typedef struct
{
    LwU32                   version;                        //!< (IN) structure version
    LwAPI_LongString        lookupKey;                      //!< (IN/OUT) lookupKey strings
    LwU32                   connectedMasks;                 //!< (IN/OUT) connected device mask
    LwU32                   count;                          //!< (IN/OUT) target count
    LW_PERSIST_DATA         target[LWAPI_ADVANCED_MAX_VIEW_TARGET];  //!< (IN/OUT) persist data
    LW_EDID                 connectedEDIDs[LWAPI_MAX_HEADS_PER_GPU]; //!< (IN) Connected EDID list, based on connectedMask from right to left
} LW_PERSIST_DATA_INFO4;



typedef LW_PERSIST_DATA_INFO4  LW_PERSIST_DATA_INFO;

//! Macro for constructing the version field of LW_PERSIST_DATA_INFO1
#define LW_PERSIST_DATA_INFO_VER1  MAKE_LWAPI_VERSION(LW_PERSIST_DATA_INFO1,1)

//! Macro for constructing the version field of LW_PERSIST_DATA_INFO2
#define LW_PERSIST_DATA_INFO_VER2  MAKE_LWAPI_VERSION(LW_PERSIST_DATA_INFO2,2)

//! Macro for constructing the version field of LW_PERSIST_DATA_INFO3
#define LW_PERSIST_DATA_INFO_VER3  MAKE_LWAPI_VERSION(LW_PERSIST_DATA_INFO3,3)

//! Macro for constructing the version field of LW_PERSIST_DATA_INFO4
#define LW_PERSIST_DATA_INFO_VER4  MAKE_LWAPI_VERSION(LW_PERSIST_DATA_INFO4,4)


#define LW_PERSIST_DATA_INFO_VER   LW_PERSIST_DATA_INFO_VER4

//! @}


//////////////////////////////////////////////////////////////////////////////////////////////////////
//
//! \name LwAPI_GetPersistenceData [Set] Functions
// @{
//! These functions retrieve, save, and find persistence data stored in the persist file.              
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [in] hPhysicalGpu Unused (reserved for later)
//! \param pData             Detailed persistence data structure.
//! \param flags             Persistence find flags (see defines for description)
//!                              
//!
//! \retval  LWAPI_ILWALID_ARGUMENT  hLwDisplay is invalid
//! \retval  LWAPI_OK                The persist operation succeed
//! \retval  LWAPI_ERROR             The persist operation failed

//! \ingroup driverapi
//! SUPPORTED OS:  Windows XP and higher
//!
LWAPI_INTERFACE LwAPI_GetPersistenceData(LwPhysicalGpuHandle hPhysicalGpu, LW_PERSIST_DATA_INFO *pData, LwU32 flags);

//! \ingroup driverapi
//! SUPPORTED OS:  Windows XP and higher
//!
LWAPI_INTERFACE LwAPI_SetPersistenceData(LwPhysicalGpuHandle hPhysicalGpu, LW_PERSIST_DATA_INFO *pData);

// @}






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Diag_DP_ASSR
//
//! \code
//!   DESCRIPTION: Makes a control call to RM to get ASSR status/disable ASSR
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \param [in]    lwGPUHandle The GPU Handle to which the display is connected.
//!                            This parameter is ignored when the outputID is an LwAPI displayId.
//! \param [in]    outputID    Output mask or LwAPI DisplayID for the display.
//! \param [in]    disable     The parameter representing the request for the specific operation.
//!                            0 : Get ASSR status
//!                            1 : Disable ASSR
//! \param [out]   enabled     The parameter representing the current ASSR status.
//!                            0 : ASSR is lwrrently disabled.
//!                            1 : ASSR is lwrrently enabled.
//!                            This parameter is optional for 'disable ASSR' request.
//! param [out]    err         This parameter represents the error code returned by RM.
//!                            0 : LW0073_CTRL_DP_ASSR_ERR_CAP_NOERR
//!                            1 : LW0073_CTRL_DP_ASSR_ERR_CAP_ERR
//!
//! \return    This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//! \endcode
//! \ingroup driverapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Diag_DP_ASSR(__in_opt LwPhysicalGpuHandle lwGPUHandle, __in LwU32 outputID, __in LwU32 disable, __out_opt LwU32 *enabled, __out LwU32 *err);







///////////////////////////////////////////////////////////////////////////////
//
// (*obsolete*) 
//  We are trying to move away from LwAPI_EnumAppStatistics into LwAPI_GetAppStatistics
// (*obsolete*)
// FUNCTION NAME:   LwAPI_EnumAppStatistics
//
//!   \fn LwAPI_EnumAppStatistics(LwU32 enumIndex, LwU32 flags, LWAPI_PROCESS_POLL_INFO *pProcessInfo)
//!   DESCRIPTION:   This API polls the driver for any 3D contexts that have been created/destroyed.
//!                  This information will be collected by the VdChip Experience client, and sent to
//!                  LWPU servers for data-mining purposes. The client should keep enumerating until it
//!                  returns LWAPI_END_ENUMERATION.
//!                  - Both exelwted and running applications are treated the same. Running applications would have 0 closeTime.
//!                  - Time is defined as a count of 100-nanosecond intervals since January 1, 1601.
//!                  - Operation mode is specified by Flags. 
//! 
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use LwAPI_GetAppStatistics.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 177
//!
//!   \param [in]      flags         Either ::LW_APPENUMFLAG_READ, ::LW_APPENUMFLAG_READERASE, or ::LW_APPENUMFLAG_READACTIVE. 
//!   \param [in,out]  enumIndex     Indicates the position where the enumeration starts
//!   \param [out]     pProcessInfo   
//!
//!   \retval          LWAPI_OK                Completed request, and potentially have more entry
//!   \retval          LWAPI_END_ENUMERATION   No more entries
//!   \retval          LWAPI_ERROR             Miscellaneous error oclwrred
//!   \retval          LWAPI_ILWALID_ARGUMENT  Invalid argument
//
/////////////////////////////////////////////////////////////////////////////////

//! \addtogroup driverapi
//! @{
#define LW_APPENUMFLAG_READ                 0x00000000  //!< Read only. See LwAPI_EnumAppStatistics().
#define LW_APPENUMFLAG_READERASE            0x00000001  //!< Read then erase. See LwAPI_EnumAppStatistics().
#define LW_APPENUMFLAG_READACTIVE           0x00000002  //!< Read only active applications. See LwAPI_EnumAppStatistics().
#define LW_APPENUMFLAG_READERASE_INACTIVE   0x00000003   
//! @}

//! \ingroup driverapi
#define LWAPI_MAX_CODEC_ENTRIES_PER_PROCESSID 32  //!< Arbitrarily large number. Flash in Firefox uses the same PID for all tabs that might be playing video.



//! \ingroup driverapi
//! Used in LWAPI_PROCESS_POLL_INFO.
typedef enum
{
    LWAPI_API_UNKNOWN      = -1,
    LWAPI_API_OPENGL       = 0x1,
    LWAPI_API_DX9          = 0x2,
    LWAPI_API_DX10         = 0x3,
    LWAPI_API_DX9_LWDA     = 0x4,
    LWAPI_API_DX10_LWDA    = 0x5,
    LWAPI_API_OPENGL_LWDA  = 0x6,
    LWAPI_API_DX9_VIDEO    = 0x7,
    LWAPI_API_DX10_1       = 0x8,
    LWAPI_API_DX10_1_LWDA  = 0x9,
    LWAPI_API_DX11         = 0xA,
    LWAPI_API_DX11_LWDA    = 0xB,
    LWAPI_API_PHYSX        = 0x20, 
    LWAPI_API_OPENGL_PHYSX = 0x21,
    LWAPI_API_DX9_PHYSX    = 0x22,
    LWAPI_API_DX10_PHYSX   = 0x23,
    LWAPI_API_DX10_1_PHYSX = 0x28,
    LWAPI_API_DX11_PHYSX   = 0x2A
} LWAPI_API_TYPE;


//! \ingroup videoapi
typedef enum
{
    LWAPI_VIDEO_CODEC_UNKNOWN = 0,
    LWAPI_VIDEO_CODEC_MPEG,
    LWAPI_VIDEO_CODEC_H264,
    LWAPI_VIDEO_CODEC_VC1,
    LWAPI_VIDEO_CODEC_MPEG4,
} LWAPI_VIDEO_CODEC_TYPE;

//! \ingroup videoapi
typedef struct
{
    LWAPI_VIDEO_CODEC_TYPE codecTypes[LWAPI_MAX_CODEC_ENTRIES_PER_PROCESSID];//!< codec type
    LwU64 instanceCount;  //!< number of instances in which processID is the same but codecs are different
} LWAPI_VIDEO_CODEC_INFO;


//! \ingroup gpu
typedef enum _LWAPI_SLI_TOPOLOGY
{
    LWAPI_SLI_TOPOLOGY_AUTOSELECT  = 0,     //!< AutoSelect
    LWAPI_SLI_TOPOLOGY_AFR         = 1,     //!< Alternate Frames
    LWAPI_SLI_TOPOLOGY_SFR         = 2,     //!< Split Frame
    LWAPI_SLI_TOPOLOGY_SINGLE      = 3,     //!< Single GPU
    LWAPI_SLI_TOPOLOGY_AFR_OF_SFR  = 4      //!< AFR of SFR
} LWAPI_SLI_TOPOLOGY;


//! \ingroup gpu
typedef struct
{
    LWAPI_SLI_TOPOLOGY  mode;            //!< [OUT] Current SLI mode
    LwU32   numSLIAA;
    LwU32   numSFR;
    LwU32   numAFR;
    LwU32   numActiveGpus;
} LWAPI_SLI_RUNTIME_INFO;


//! \ingroup gpu

#define LWAPI_FPS_HISTOGRAM_NUM_BUCKETS 32
#define LWAPI_FPS_HIST_MIN 10
#define LWAPI_FPS_HIST_MAX 150
#define LWAPI_FPS_MIN_IN_MS (1000.0 / (LwF32)LWAPI_FPS_HIST_MIN)
#define LWAPI_FPS_MAX_IN_MS (1000.0 / (LwF32)LWAPI_FPS_HIST_MAX)
#define LWAPI_FPS_MS_RESOLUTION ((LWAPI_FPS_MAX_IN_MS-LWAPI_FPS_MIN_IN_MS) / LWAPI_FPS_HISTOGRAM_NUM_BUCKETS)
#define LWAPI_FRAME_RATE_DERIVATIVE_HISTOGRAM_NUM_BUCKETS 32
#define LWAPI_FPS_DELTA_MIN_RANGE -2.0
#define LWAPI_FPS_DELTA_MAX_RANGE 2.0
#define LWAPI_FPS_DELTA_RESOLUTION = ((LWAPI_FPS_DELTA_MAX_RANGE - LWAPI_FPS_DELTA_MIN_RANGE) / (LwF32)LWAPI_FRAME_RATE_DERIVATIVE_HISTOGRAM_NUM_BUCKETS)

#define PSTATE_HISTOGRAM_NUM_BUCKETS 10
#define LWCLK_HISTOGRAM_NUM_BUCKETS  16
#define GPCCLK_HISTOGRAM_NUM_BUCKETS 16

//! \ingroup gpu
typedef struct
{
    LwU32                           perFrameCreateTimeHistogram[LWAPI_FPS_HISTOGRAM_NUM_BUCKETS];                               //!< [OUT] A histogram of frame creation times (in MS)
    LwU32                           perFrameCreateTimeDerivativeHistogram[LWAPI_FRAME_RATE_DERIVATIVE_HISTOGRAM_NUM_BUCKETS];   //!< [OUT] A histogram of the derivative of frame to frame creation times.
    LwU32                           pStateHistogram[PSTATE_HISTOGRAM_NUM_BUCKETS];                                              //!< [OUT] A histogram of pstates used.
    float                           batteryPct;                                                                                 //!< [OUT] Percent of time the battery is used to power the computer.
    float                           cordedPct;                                                                                  //!< [OUT] Percent of time the computer is plugged in.
} LWAPI_GFE_INFO;


//! \ingroup gpu
typedef struct
{
    LwU32 isStereoActivated         : 1;
    LwU32 isStereoBlocked           : 1;
    LwU32 isAnaglyph                : 1;
    LwU32 isHDMIStereo              : 1;
    LwU32 isHDMIAllowed             : 1;
    LwU32 isHDMISupported           : 1;
    LwU32 isHDMIProtected           : 1;
    LwU32 isHDMIWindowed            : 1;
    LwU32 isSliBroadcast            : 1;
    LwU32 isClonedMode              : 1;
    LwU32 isBulkLicense             : 1;
    LwU32 isFullLicense             : 1;
    LwU32 isUserLicense             : 1;
    LwU32 isPanelReleased           : 1;
    LwU32 isTestLicense             : 1;
    LwU32 isDisplayIdentified       : 1;
    LwU32 isDisplayReleased         : 1;
    LwU32 isNB                      : 1;
    LwU32 isDisableHighVBIOverride  : 1;
    LwU32 isDisableAuthentication   : 1;
    LwU32 isBrowserStereoApp        : 1;
    LwU32 isAeroEnabled             : 1;
    LwU32 isGDIWindowModeEnabled    : 1;
    LwU32 isGDIWindowModeActivated  : 1;
    LwU32 isSandbox                 : 1;
    LwU32 isGameProfiled            : 1;
    LwU32 isNBInternalPanel         : 1;
    LwU32 isEnabledInRegistry       : 1;

    LwU32 stereoHWType;
} LWAPI_STEREO_RUNTIME_INFO;




//! \ingroup driverapi
//! Used in LwAPI_EnumAppStatistics().
typedef struct
{
    LwU32                           version;
    LWAPI_API_TYPE                  APIType;
    LwU32                           processId;
    LwU64                           openTime;
    LwU64                           closeTime;
    LwU64                           averageFrameRate;
    char                            exeName[LWAPI_LONG_STRING_MAX];
} LWAPI_PROCESS_POLL_INFO_V1;


//! \ingroup driverapi
//! Used in LwAPI_EnumAppStatistics().
typedef struct
{
    LwU32                           version;
    LWAPI_API_TYPE                  APIType;
    LwU32                           processId;
    LwU64                           openTime;
    LwU64                           closeTime;
    LwU64                           averageFrameRate;
    char                            exeName[LWAPI_LONG_STRING_MAX];
    LWAPI_VIDEO_CODEC_INFO          videoCodecInfo;                     //!< video codec info (check only if APITYPE == LWAPI_API_DX9_VIDEO)
} LWAPI_PROCESS_POLL_INFO_V2;

//! \ingroup driverapi
#define LWAPI_PATH_MAX_LENGTH                260 // same as MAX_PATH defined in windows

//! \ingroup driverapi
typedef struct
{
    LwU32                           version;
    LWAPI_API_TYPE                  APIType;
    LwU32                           processId;
    LwU64                           openTime;
    LwU64                           closeTime;
    LwU64                           averageFrameRate;
    char                            exeName[LWAPI_LONG_STRING_MAX];
    LWAPI_VIDEO_CODEC_INFO          videoCodecInfo;                     //!< video codec info (check only if APITYPE == LWAPI_API_DX9_VIDEO)
    LWAPI_SLI_RUNTIME_INFO          sliInfo;
    char                            pathName[LWAPI_PATH_MAX_LENGTH];
    float                           minFrameRate;
    float                           maxFrameRate;
} LWAPI_PROCESS_POLL_INFO_V3;

//! \ingroup driverapi
typedef struct
{
    LwU32                           version;
    LWAPI_API_TYPE                  APIType;
    LwU32                           processId;
    LwU64                           openTime;
    LwU64                           closeTime;
    LwU64                           averageFrameRate;
    char                            exeName[LWAPI_LONG_STRING_MAX];   
    LWAPI_VIDEO_CODEC_INFO          videoCodecInfo;                     //!< video codec info (check only if APITYPE == LWAPI_API_DX9_VIDEO)
    LWAPI_SLI_RUNTIME_INFO          sliInfo;
    char                            pathName[LWAPI_PATH_MAX_LENGTH];
    float                           minFrameRate;
    float                           maxFrameRate;
    LWAPI_GFE_INFO                  gfeInfo;
    LWAPI_STEREO_RUNTIME_INFO       stereoInfo;
    LwAPI_UnicodeString             exeNameW;    
    LwAPI_UnicodeString             pathNameW;    
    LwAPI_UnicodeString             workingDirNameW;
} LWAPI_PROCESS_POLL_INFO_V4;

//! \ingroup driverapi
typedef struct
{
    LwU32                           version;
    LWAPI_API_TYPE                  APIType;
    LwU32                           processId;
    LwU64                           openTime;
    LwU64                           closeTime;
    LwU64                           averageFrameRate;
    char                            exeName[LWAPI_LONG_STRING_MAX];   
    LWAPI_VIDEO_CODEC_INFO          videoCodecInfo;                     //!< video codec info (check only if APITYPE == LWAPI_API_DX9_VIDEO)
    LWAPI_SLI_RUNTIME_INFO          sliInfo;
    char                            pathName[LWAPI_PATH_MAX_LENGTH];
    float                           minFrameRate;
    float                           maxFrameRate;
    LWAPI_GFE_INFO                  gfeInfo;
    LWAPI_STEREO_RUNTIME_INFO       stereoInfo;
    LwAPI_UnicodeString             exeNameW;    
    LwAPI_UnicodeString             pathNameW;    
    LwAPI_UnicodeString             workingDirNameW;
    LwAPI_UnicodeString             cmdLineArgsW;    
    char                            sid[LWAPI_LONG_STRING_MAX];                                                   //!< [OUT] Security identifier of the user who ran the app.
} LWAPI_PROCESS_POLL_INFO_V5;

//! \ingroup driverapi
//! @{

typedef LWAPI_PROCESS_POLL_INFO_V4     LWAPI_PROCESS_POLL_INFO_LIVE;                                              //!< Version that is lwrrently in the wild.
typedef LWAPI_PROCESS_POLL_INFO_V5     LWAPI_PROCESS_POLL_INFO;                                                   //!< Version to be released next.

#define LWAPI_PROCESS_POLL_INFO_VER_1  MAKE_LWAPI_VERSION(LWAPI_PROCESS_POLL_INFO_V1,1)
#define LWAPI_PROCESS_POLL_INFO_VER_2  MAKE_LWAPI_VERSION(LWAPI_PROCESS_POLL_INFO_V2,2)
#define LWAPI_PROCESS_POLL_INFO_VER_3  MAKE_LWAPI_VERSION(LWAPI_PROCESS_POLL_INFO_V3,3)
#define LWAPI_PROCESS_POLL_INFO_VER_4  MAKE_LWAPI_VERSION(LWAPI_PROCESS_POLL_INFO_V4,4)
#define LWAPI_PROCESS_POLL_INFO_VER_5  MAKE_LWAPI_VERSION(LWAPI_PROCESS_POLL_INFO_V5, 5)
#define LWAPI_PROCESS_POLL_INFO_VER    LWAPI_PROCESS_POLL_INFO_VER_5

//! @}


//!   \ingroup driverapi
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use LwAPI_GetAppStatistics.")
LWAPI_INTERFACE LwAPI_EnumAppStatistics(LwU32 enumIndex, LwU32 flags, LWAPI_PROCESS_POLL_INFO *pProcessInfo);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GetAppStatistics
//
//! \fn LwAPI_GetAppStatistics(LwU32 *pNum, LwU32 flags, LWAPI_PROCESS_POLL_INFO *pProcessInfo)
//!   DESCRIPTION:   This API polls the driver for any 3D contexts that have been created or destroyed. 
//!                  This information is collected by the VdChip Experience client and sent to
//!                  our servers for data-mining purposes. The client would get all entries at once.
//!                  \note Both exelwted and running applications are treated the same. A running application would have 0 closeTime.
//!                  Time is defined as is a count of 100-nanosecond intervals since January 1, 1601.
//!                  Operation mode is specified by Flags.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//! 
//! \param [in]     flags       These flags are exclusive, and cannot be combined in usage:
//!                             - LW_APPENUMFLAG_READ                 read only
//!                             - LW_APPENUMFLAG_READERASE            read then erase
//!                             - LW_APPENUMFLAG_READACTIVE           read only active apps
//!                             - LW_APPENUMFLAG_READERASE_INACTIVE   read then erase inactive apps.
//!                  
//! \param [in,out] pNum          - in(the number of entries in pProcessInfo array)
//!                               - out(the number of entries being filled)
//! \param [out]    pProcessInfo  An array of LWAPI_PROCESS_POLL_INFO
//!
//! \retval ::LWAPI_OK - completed request, and potentially have more entry
//! \retval ::LWAPI_ERROR - miscellaneous error oclwrred
//! \retval ::LWAPI_ILWALID_ARGUMENT - invalid argument
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup driverapi
#define LWAPI_MAX_PROCESS_INFO_ENTRIES  16


//! \ingroup driverapi
LWAPI_INTERFACE LwAPI_GetAppStatistics(LwU32 *pNum, LwU32 flags, LWAPI_PROCESS_POLL_INFO *pProcessInfo);




// 3D profile for one key cinema feature



//! \addtogroup appprofileapi
//! @{

//! See LW_3D_SETTING_RANGE.
#define LW_3D_MAX_RANGE         25


//! 3D property names used in LW_3D_SETTING and LW_3D_SETTING_RANGE
typedef enum
{
    LW_3D_PROPERTY_AS         = 1,  //!< Anti-Aliasing selector
    LW_3D_PROPERTY_AA         = 2,  //!< Anti-Aliasing setting
    LW_3D_PROPERTY_AF         = 3,  //!< Anisotropic filtering
    LW_3D_PROPERTY_MAX_FRAMES = 4,  //!< Maximum pre-rendered frames
    LW_3D_PROPERTY_TEX_FILTER = 5,  //!< Texture filtering
} LW_3D_PROPERTY;


//! Used in LwAPI_3D_GetProperty() and LwAPI_3D_SetProperty().
typedef struct
{
    LwU32           version;                //!< [in] Structure version
    LW_3D_PROPERTY  settingName;            //!< [in] 3D setting
    LwU32           flags;                  //!< [out] Indicates whether the settings are read only
    LwU32           defaultValue;           //!< [out] Default base value at driver install
    LwU32           lwrrentValue;           //!< [in/out] Current value or new value to update
} LW_3D_SETTING;


//! Used in LwAPI_3D_GetPropertyRange().
typedef struct
{
    LwU32           version;                //!< [in] Structure version
    LW_3D_PROPERTY  settingName;            //!< [in] 3D setting
    LwU32           value[LW_3D_MAX_RANGE]; //!< [out] Range of values as unique array of numbers
    LwU32           validRangeCount;        //!< [out] Number of valid items in the property
} LW_3D_SETTING_RANGE;


//! Macro for constructing the version field of LW_3D_SETTING
#define LW_3D_PROFILE_VERSION           MAKE_LWAPI_VERSION(LW_3D_SETTING,1)


//! Macro for constructing the version field of LW_3D_SETTING_RANGE
#define LW_3D_PROFILE_RANGE_VERSION     MAKE_LWAPI_VERSION(LW_3D_SETTING_RANGE,1)


//! @}

/////////////////////////////////////////////////////////////////////////////// 
// 
// FUNCTION NAME:  LwAPI_3D_GetProperty 
// 
//! DESCRIPTION:    This API gets the specific 3D profile property. \n
//! HOW TO USE:    
//!                -# Set profileName to "Base Profile"
//!                -# Set 3D property name to settingName of LW_3D_SETTING
//!                -# On call success: It returns the specific profile property setting
//!
//! \param [in]     profileName  Which profile to access
//! \param [in,out] p3dSettings  Setting of the 3D profile property 
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//! 
//! \retval ::LWAPI_OK  
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_ILWALID_ARGUMENT 
//!
//! \ingroup appprofileapi
/////////////////////////////////////////////////////////////////////////////// 
LWAPI_INTERFACE LwAPI_3D_GetProperty(LwAPI_ShortString szProfileName, LW_3D_SETTING* p3dSetting);

/////////////////////////////////////////////////////////////////////////////// 
// 
// FUNCTION NAME:  LwAPI_3D_SetProperty 
// 
//! DESCRIPTION:    This API sets the specific 3D profile property. \n
//! HOW TO USE:    
//!                -# Set profileName to "Base Profile"
//!                -# Set 3D property name to settingName of LW_3D_SETTING
//!                -# On call success: It returns the specific profile property setting
//!
//! \param [in]     profileName  Which profile to access
//! \param [in,out] p3dSettings  Setting of the 3D profile property 
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//! 
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_ILWALID_ARGUMENT 
//!
//! \ingroup appprofileapi
/////////////////////////////////////////////////////////////////////////////// 
LWAPI_INTERFACE LwAPI_3D_SetProperty(LwAPI_ShortString szProfileName, LW_3D_SETTING* p3dSetting);

/////////////////////////////////////////////////////////////////////////////// 
// 
// FUNCTION NAME:  LwAPI_3D_GetPropertyRange 
//
//! DESCRIPTION:    This API gets the specific 3D profile property setting range. \n
//! HOW TO USE:    -# Set profileName to "Base Profile".
//!                -# Set 3D property name to settingName of LW_3D_SETTING_RANGE.
//!                -# On call success: It returns the specific profile property setting.
//!
//! \param [in]     profileName      Which profile to access
//! \param [in,out] p3dSettingRange  Setting range of the 3D profile property 
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//! 
//! \retval ::LWAPI_OK  
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_ILWALID_ARGUMENT 
//!
//! \ingroup appprofileapi
/////////////////////////////////////////////////////////////////////////////// 
LWAPI_INTERFACE LwAPI_3D_GetPropertyRange(LwAPI_ShortString szProfileName, LW_3D_SETTING_RANGE* p3dsettingRange);





///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GPU_GetAppStatistics
//
//! \code
//!   DESCRIPTION:   This API lets caller to lets us poll the driver for
//!                  any 3D contexts that have been created/destroyed on a GPU. 
//!                  This information will be collected by the VdChip Experience client, and sent to
//!                  our servers for data-mining purposes. The client would get all entries at once
//!                  (Both exelwted and running apps are treated the same.  Running app would have 0 closeTime.)
//!                  (Time is defined as is a count of 100-nanosecond intervals since January 1, 1601)
//!                  (Operation mode is specified by Flags. )
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!    PARAMETERS: (IN)      hPhysicalGpu    Handle for Physical GPU Handle for which statistics will be retrieved.
//!                (IN)      flags           reserved for future use, (must be 0)
//!                (IN/OUT)  pNum            in(the number of entries in pProcessInfo array)
//!                (OUT)     pProcessInfo    an array of LWAPI_PROCESS_POLL_INFO
//!
//! RETURN STATUS:   LWAPI_OK - completed request, and potentially have more entry
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - invalid argument
//! \endcode
//! \ingroup driverapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetAppStatistics(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pNum, LwU32 flags, LWAPI_PROCESS_POLL_INFO *pProcessInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Mjolnir_SetupStreamingSession
//
//! \fn LwAPI_Mjolnir_SetupStreamingSession(LwU32 streamingProcessId, LwU32 flags)
//! DESCRIPTION: This function activates streaming interface between lwStreamer and UMD if streamingProcessId is not 0 and matches id of a process making this call. 
//!              If streamingProcessId is not 0 but does not match id of a process making this call then this function registers streamingProcessId as a child of streaming session.
//!              If streamingProcessId is 0 - streaming interface gets deactivated.
//!              flags parameter specifies additional information reqired for process registration.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]  streamingProcessId   Process ID that owns a streaming session or needs to be registered.
//! \param [in]  flags                Additional flags for registration.
//!
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!              specific meaning for this API, they are listed below.
//!
//! \retval      LWAPI_ILWALID_ARGUMENT  request to register a streaming session child when streaming session is not active. 
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup lwapifunctions
//! @{

//! \ingroup lwapifunctions
//! Available flag values
#define REGISTER_PROCESS_AS_GAME_ID 1

//! \ingroup lwapifunctions
LWAPI_INTERFACE LwAPI_Mjolnir_SetupStreamingSession(__in LwU32 streamingProcessId, __in LwU32 flags);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Mjolnir_GetStreamingInfo
//
//! \fn LwAPI_Mjolnir_GetStreamingInfo(LW_MJOLNIR_STREAMING_INFO *pStreamingInfo)
//! DESCRIPTION: This API returns information about current streaming session.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in, out]     pStreamingInfo      Pointer to LW_MJOLNIR_STREAMING_INFO structure with current streaming session info.
//!
//! \return    This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \retval    LWAPI_INCOMPATIBLE_STRUCT_VERSION - LW_MJOLNIR_STREAMING_INFO structure version mismatch. 
//! \retval    LWAPI_ILWALID_POINTER             - pStreamingInfo pointer is invalid. 
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup lwapifunctions
//! Array sizes
#define MAX_GAME_IDS     4
#define MAX_PROCESS_IDS 16

//! \ingroup lwapifunctions
//! @{

typedef struct _LW_MJOLNIR_STREAMING_INFO
{
    LwU32   version;             // Structure version
    LwU32   streamingSessionActive;
    LwU32   streamingSessionOwnerId;
    LwU32   fullScreen;
    LwU32   streamingSessionGameIds[MAX_GAME_IDS];
    LwU32   streamingSessionProcessIds[MAX_PROCESS_IDS];
} LW_MJOLNIR_STREAMING_INFO;

//! @}

//! \ingroup lwapifunctions
//! Macro for constructing the version field of STREAMING_INFO_VER_1
#define LW_MJOLNIR_STREAMING_INFO_VER_1  MAKE_LWAPI_VERSION(LW_MJOLNIR_STREAMING_INFO,1)

//! \ingroup lwapifunctions
LWAPI_INTERFACE LwAPI_Mjolnir_GetStreamingInfo(__inout LW_MJOLNIR_STREAMING_INFO *pStreamingInfo);
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetHybridPadInfo
//
//! \fn LwAPI_GPU_GetHybridPadInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_GET_HYBRID_PAD_INFO *hybridPadInfo)
//! \code
//!   DESCRIPTION: This API returns the Hybrid/Aux pad information of the specified physical ports.
//!                It tells the physical port count. If hybridPadInfo->pHybridPadInfo is NULL then the API gives the physical port count.
//!                Again called calles API with physical port count and pHybridPadInfo to get pad information about
//!                whether the pad is a hybrid pad, the pad's mode, the pad's current power state,
//!                and also the display mask associated with the pad.
//!                Following is the Wiki link with details about hybrid pads:
//!                https://wiki.lwpu.com/engwiki/index.php/Hybrid_pads_project
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: LWAPI_OK: request is completed and required information is in the parameter
//!                LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!                LWAPI_API_NOT_INITIALIZED: no  initialization of LwAPI
//!                LWAPI_NO_IMPLEMENTATION: Implementation is not found of LwAPI
//!                LWAPI_LWIDIA_DEVICE_NOT_FOUND: no LWPU GPU driving a display was found
//!                LWAPI_NOT_SUPPORTED: if the interface is not supported
//!                LWAPI_ILWALID_POINTER: if the pointer passed is NULL
//!                LWAPI_OUT_OF_MEMORY: if memory is not allocated.
//!                LWAPI_ERROR: miscellaneous error oclwrred
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
typedef struct
{
    LwU32  displayMask;                             //!< Output: Display mask of a specified physical port.
    LwU32  padLwrrMode;                             //!< Output: Current mode of a port can be I2C or AUX.
    LwU32  padPowerState :1;                        //!< Output: Power state of the specified pad.
    LwU32  usesHybridPad :1;                        //!< Output: Specifies whether or not the hybrid pad is used.
    LwU32  reserved :30;
} LW_HYBRID_PAD_DATA;

//! \ingroup gpu
typedef struct
{
    LwU32               version;                    //!< Input: Structure version.
    LwU32               phyPortCount;               //!< Output: Tells about physical port count.
    LW_HYBRID_PAD_DATA  *pHybridPadInfo;            //!< Output: Contain all information about hybrid pads.
} LW_GET_HYBRID_PAD_INFO_V1;

//! \ingroup gpu
#define LW_GET_HYBRID_PAD_INFO_VER1 MAKE_LWAPI_VERSION(LW_GET_HYBRID_PAD_INFO_V1, 1)

//! \ingroup gpu
#define LW_GET_HYBRID_PAD_INFO_VER  LW_GET_HYBRID_PAD_INFO_VER1

//! \ingroup gpu
typedef LW_GET_HYBRID_PAD_INFO_V1   LW_GET_HYBRID_PAD_INFO;

//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_GetHybridPadInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_GET_HYBRID_PAD_INFO *hybridPadInfo);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_EnumPhysicalGPUs
//
//! This function returns an array of physical GPU handles.
//! Each handle represents a physical GPU present in the system.
//! That GPU may be part of an SLI configuration, or may not be visible to the OS directly.
//!
//! At least one GPU must be present in the system and running an LWPU display driver.
//!
//! The array lwGPUHandle will be filled with physical GPU handle values. The returned
//! gpuCount determines how many entries in the array are valid.
//!
//! \note In drivers older than 105.00, all physical GPU handles get ilwalidated on a
//!       modeset. So the calling applications need to renum the handles after every modeset.\n
//!       With drivers 105.00 and up, all physical GPU handles are constant.
//!       Physical GPU handles are constant as long as the GPUs are not physically moved and 
//!       the SBIOS VGA order is unchanged.
//!
//!       For GPU handles in TCC MODE please use LwAPI_EnumTCCPhysicalGPUs()
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \par Introduced in
//! \since Release: 80
//!
//! \retval LWAPI_ILWALID_ARGUMENT         lwGPUHandle or pGpuCount is NULL
//! \retval LWAPI_OK                       One or more handles were returned
//! \retval LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_EnumPhysicalGPUs(LwPhysicalGpuHandle lwGPUHandle[LWAPI_MAX_PHYSICAL_GPUS], LwU32 *pGpuCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_EnumTCCPhysicalGPUs
//
//! This function returns an array of physical GPU handles that are in TCC Mode.
//! Each handle represents a physical GPU present in the system in TCC Mode.
//! That GPU may not be visible to the OS directly.
//!
//! The array lwGPUHandle will be filled with physical GPU handle values. The returned
//! gpuCount determines how many entries in the array are valid.
//!
//! NOTE: Handles enumerated by this API are only valid for LwAPIs that are tagged as TCC_SUPPORTED
//!       If handle is passed to any other API, it will fail with LWAPI_ILWALID_HANDLE
//!
//!       For WDDM GPU handles please use LwAPI_EnumPhysicalGPUs()
//!
//! SUPPORTED OS:  Windows Vista and higher,  Mac OS X
//!
//!
//! 
//! \param [out]   lwGPUHandle      Physical GPU array that will contain all TCC Physical GPUs
//! \param [out]   pGpuCount        count represent the number of valid entries in lwGPUHandle
//!  
//!
//! \retval LWAPI_ILWALID_ARGUMENT         lwGPUHandle or pGpuCount is NULL
//! \retval LWAPI_OK                       One or more handles were returned
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_EnumTCCPhysicalGPUs( LwPhysicalGpuHandle lwGPUHandle[LWAPI_MAX_PHYSICAL_GPUS], LwU32 *pGpuCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_EnumLogicalGPUs
//
//! This function returns an array of logical GPU handles.
//!
//! Each handle represents one or more GPUs acting in concert as a single graphics device.
//!
//! At least one GPU must be present in the system and running an LWPU display driver.
//!
//! The array lwGPUHandle will be filled with logical GPU handle values.  The returned
//! gpuCount determines how many entries in the array are valid.
//!
//! \note All logical GPUs handles get ilwalidated on a GPU topology change, so the calling 
//!       application is required to renum the logical GPU handles to get latest physical handle
//!       mapping after every GPU topology change activated by a call to LwAPI_SetGpuTopologies().
//!
//! To detect if SLI rendering is enabled, use LwAPI_D3D_GetLwrrentSLIState().
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 80
//!
//! \retval LWAPI_ILWALID_ARGUMENT         lwGPUHandle or pGpuCount is NULL
//! \retval LWAPI_OK                       One or more handles were returned
//! \retval LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_EnumLogicalGPUs(LwLogicalGpuHandle lwGPUHandle[LWAPI_MAX_LOGICAL_GPUS], LwU32 *pGpuCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetPhysicalGPUsFromDisplay
//
//! This function returns an array of physical GPU handles associated with the specified display.
//!
//! At least one GPU must be present in the system and running an LWPU display driver.
//!
//! The array lwGPUHandle will be filled with physical GPU handle values.  The returned
//! gpuCount determines how many entries in the array are valid.
//!
//! If the display corresponds to more than one physical GPU, the first GPU returned
//! is the one with the attached active output.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \retval LWAPI_ILWALID_ARGUMENT         hLwDisp is not valid; lwGPUHandle or pGpuCount is NULL
//! \retval LWAPI_OK                       One or more handles were returned
//! \retval LWAPI_LWIDIA_DEVICE_NOT_FOUND  no LWPU GPU driving a display was found
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetPhysicalGPUsFromDisplay(LwDisplayHandle hLwDisp, LwPhysicalGpuHandle lwGPUHandle[LWAPI_MAX_PHYSICAL_GPUS], LwU32 *pGpuCount);
 

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_EnumPhysicalGPUsInternal
//
//!   DESCRIPTION: Description and usage is the same as LwAPI_EnumPhysicalGPUs().  
//!                Only the PhysX engine and PhysX APIs can use this API due to the WAR for http://lwbugs/388093.
//!                The WAR applies only to LwAPI_EnumPhysicalGPUs() and LwAPI_EnumLogicalGPUs(), and is 
//!                for applications such as 3dmarkvantage.exe, crysis64.exe, etc. 
//!                In the workaround the driver returns fake logical and physical GPUs instead of system wide GPUs.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!  \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_EnumPhysicalGPUsInternal(LwPhysicalGpuHandle lwGPUHandle[LWAPI_MAX_PHYSICAL_GPUS], LwU32 *pGpuCount);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_EnumLogicalGPUsInternal
//
//!   DESCRIPTION: Description and usage is the same as LwAPI_EnumLogicalGPUs().  
//!                Only the PhysX engine and PhysX APIs can use this due to the WAR for http://lwbugs/388093.
//!                This WAR applies only to LwAPI_EnumLogicalGPUs() and LwAPI_EnumPhysicalGPUs() and is 
//!                for applications such as 3dmarkvantage.exe, crysis64.exe, etc. 
//!                In the workaround the driver returns fake logical and physical GPUs instead of system wide GPUs.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!  \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_EnumLogicalGPUsInternal(LwLogicalGpuHandle lwGPUHandle[LWAPI_MAX_LOGICAL_GPUS], LwU32 *pGpuCount);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetDisplayFromPhysicalGPU
//
//!   DESCRIPTION: This API returns a display associated with a physical GPU handle.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//
//! \since Release: 180
//!
//!  \retval ::LWAPI_ILWALID_ARGUMENT  lwGPUHandle is not valid; hLwDisp is NULL
//!  \retval ::LWAPI_OK                one handle was returned
//!
//!  \ingroup gpu
/////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetDisplayFromPhysicalGPU(LwPhysicalGpuHandle lwGPUHandle, LwDisplayHandle *hLwDisp);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DISP_GetUnAttachedDisplayFromPhysicalGPU
//
//!   DESCRIPTION: Returns an unattached display associated with a physical GPU handle.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: lwGPUHandle is not valid; hLwDisp is NULL
//!                LWAPI_OK: one handle was returned
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetUnAttachedDisplayFromPhysicalGPU(LwPhysicalGpuHandle lwGPUHandle, LwUnAttachedDisplayHandle *hUnAttachedLwDisp);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetAssociatedDisplayFromOutputId
//
//!   DESCRIPTION: Returns a display a associated with a physical GPU handle and the outputId.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                If there are return error codes with specific meaning for this API, they are listed below.
//!                (None)
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetAssociatedDisplayFromOutputId(LwPhysicalGpuHandle lwGPUHandle, LwU32 outputId, LwDisplayHandle *hLwDisp);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetPhysicalGPUFromUnAttachedDisplay
//
//! This function returns a physical GPU handle associated with the specified unattached display.
//! The source GPU is a physical render GPU which renders the frame buffer but may or may not drive the scan out.
//!
//! At least one GPU must be present in the system and running an LWPU display driver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \retval LWAPI_ILWALID_ARGUMENT         hLwUnAttachedDisp is not valid or pPhysicalGpu is NULL.
//! \retval LWAPI_OK                       One or more handles were returned
//! \retval LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetPhysicalGPUFromUnAttachedDisplay(LwUnAttachedDisplayHandle hLwUnAttachedDisp, LwPhysicalGpuHandle *pPhysicalGpu);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetLogicalGPUFromDisplay
//
//! This function returns the logical GPU handle associated with the specified display.
//! At least one GPU must be present in the system and running an LWPU display driver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \retval LWAPI_ILWALID_ARGUMENT         hLwDisp is not valid; pLogicalGPU is NULL
//! \retval LWAPI_OK                       One or more handles were returned
//! \retval LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetLogicalGPUFromDisplay(LwDisplayHandle hLwDisp, LwLogicalGpuHandle *pLogicalGPU);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DISP_GetLogicalLwdaGPUFromDisplay
//
//!   DESCRIPTION: This API returns a logical GPU handle associated with the specified display.
//!                On Hybrid SLI systems, this returns the GPU on which LWCA will be 
//!                running (so it returns the rendering GPU and not the scan-out GPU, unlike the
//!                behavior of LwAPI_GetLogicalGPUFromDisplay()). This is a hotfix for bug 506582.  
//!                For fixing bug 523171, we will need a more comprehensive solution.
//!
//!                At least one GPU must be present in the system and running an LWIDA display driver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!
//! \since Release: 180
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT         hLwDisp is not valid; pLogicalGPU is NULL
//! \retval ::LWAPI_OK                       One or more handles were returned
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetLogicalLwdaGPUFromDisplay(LwDisplayHandle hLwDisp, LwLogicalGpuHandle *pLogicalGPU);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetLogicalGPUFromPhysicalGPU
//
//! This function returns the logical GPU handle associated with specified physical GPU handle.
//! At least one GPU must be present in the system and running an LWPU display driver.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 80
//!
//! \retval LWAPI_ILWALID_ARGUMENT         hPhysicalGPU is not valid; pLogicalGPU is NULL
//! \retval LWAPI_OK                       One or more handles were returned
//! \retval LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetLogicalGPUFromPhysicalGPU(LwPhysicalGpuHandle hPhysicalGPU, LwLogicalGpuHandle *pLogicalGPU);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetPhysicalGPUsFromLogicalGPU
//
//!  This function returns the physical GPU handles associated with the specified logical GPU handle.
//!  At least one GPU must be present in the system and running an LWPU display driver.
//!
//!  The array hPhysicalGPU will be filled with physical GPU handle values.  The returned
//!  gpuCount determines how many entries in the array are valid.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \retval LWAPI_ILWALID_ARGUMENT             hLogicalGPU is not valid; hPhysicalGPU is NULL
//! \retval LWAPI_OK                           One or more handles were returned
//! \retval LWAPI_LWIDIA_DEVICE_NOT_FOUND      No LWPU GPU driving a display was found
//! \retval LWAPI_EXPECTED_LOGICAL_GPU_HANDLE  hLogicalGPU was not a logical GPU handle
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetPhysicalGPUsFromLogicalGPU(LwLogicalGpuHandle hLogicalGPU,LwPhysicalGpuHandle hPhysicalGPU[LWAPI_MAX_PHYSICAL_GPUS], LwU32 *pGpuCount);
   
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetPhysicalGPUsFromLogicalGPUInEngineOrder
//
//!  This function returns the physical GPU handles associated with the specified logical GPU handle.
//!  At least one GPU must be present in the system and running an LWPU display driver.
//!
//!  The array hPhysicalGPU will be filled with physical GPU handle values.  The returned
//!  gpuCount determines how many entries in the array are valid.
//!
//!  The ordering of the returned GPUs will be a best-guess at the engine-ordinal ordering
//!  of the GPUs.  In particular, creating a WDDM context with D3DKMT_CREATECONTEXT::EngineAffinity
//!  set to (1 << i) will result in work being exelwted on physical GPU hPhysicalGPU[i].
//!
//!  It should be noted that by 'best-guess' here, we mean 'the first and last elements
//!  are probably right, but the middle ones may be muddled.'  PhysX is only impacted by 
//!  the last element, so this will fix the relevant PhysX issues.  It may be valuable
//!  at some point to retrieve the full predicted engine ordering.
//!
//!  This API is a hot-fix and is already deprecated, see bug 922240.
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use LwAPI_GetPhysicalGPUsFromLogicalGPUInEngineOrder.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 290
//!
//! \retval LWAPI_ILWALID_ARGUMENT             hLogicalGPU is not valid; hPhysicalGPU is NULL
//! \retval LWAPI_OK                           One or more handles were returned
//! \retval LWAPI_LWIDIA_DEVICE_NOT_FOUND      No LWPU GPU driving a display was found
//! \retval LWAPI_EXPECTED_LOGICAL_GPU_HANDLE  hLogicalGPU was not a logical GPU handle
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use LwAPI_GetPhysicalGPUsFromLogicalGPUInEngineOrder.")
LWAPI_INTERFACE LwAPI_GetPhysicalGPUsFromLogicalGPUInEngineOrder(LwLogicalGpuHandle hLogicalGPU,LwPhysicalGpuHandle hPhysicalGPU[LWAPI_MAX_PHYSICAL_GPUS], LwU32 *pGpuCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetPhysicalGPUFromDisplay
//
//!   DESCRIPTION: This function returns the physical GPU handle that is associated with the specified attached display handle. 
//!                \note This API reflects the GPU association that the OS is aware of, unlike LwAPI_GetPhysicalGPUsFromDisplay().
//!
//!                At least one GPU must be present in the system and running an LWPU display driver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 175
//!
//!  \retval  ::LWAPI_ILWALID_ARGUMENT   
//!  \retval  ::LWAPI_OK 
//!  \retval  ::LWAPI_LWIDIA_DEVICE_NOT_FOUND
//!
//!  \ingroup gpu
//////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetPhysicalGPUFromDisplay(LwDisplayHandle hLwDisplay, LwPhysicalGpuHandle *pPhysicalGpu);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetPhysicalGPUFromGPUID
//
//!  This function returns the physical GPU handle associated with the RM's GPUID value.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 80
//!
//! \retval LWAPI_ILWALID_ARGUMENT         rmGPUID is zero or pPhysicalGPU is NULL
//! \retval LWAPI_OK                       Handle was returned
//! \retval LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetPhysicalGPUFromGPUID(LwU32 gpuId, LwPhysicalGpuHandle *pPhysicalGPU);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetGPUIDfromPhysicalGPU
//
//! Returns the GPUID for the queried GPU handle. This ID can be used to maintain persistence 
//! in the calling applications when switching between GPU topologies.
//! \note GPU IDs are invalid if the graphics boards are physically removed or swapped.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 95
//!
//! \retval LWAPI_ILWALID_ARGUMENT         hPhysicalGPUID is NULL or invalid. Re-enumerate the GPU handles.
//! \retval LWAPI_OK                       Handle was returned
//! \retval LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetGPUIDfromPhysicalGPU(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pGpuId);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DISP_GetTargetPhysicalGPUsFromUnAttachedDisplay
//
//!   DESCRIPTION: This API returns an array of physical display GPU handles that can possibly drive the specified unattached display handle.
//!                The target GPU is a physical display GPU which can be used to drive scan out but may or may not render the frame buffer. 
//!
//!                At least one GPU must be present in the system and running an LWPU display driver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT         hLwUnAttachedDisp is not valid or pPhysicalGpu is NULL.
//! \retval ::LWAPI_OK                       One or more handles were returned
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetTargetPhysicalGPUsFromUnAttachedDisplay(LwUnAttachedDisplayHandle hLwUnAttachedDisp, LwPhysicalGpuHandle lwGPUHandle[LWAPI_MAX_PHYSICAL_GPUS], LwU32 *pGpuCount);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetPerGpuRegistryPath(LwPhysicalGpuHandle hPhysicalGpu, char *pRegistryPath)
//
//! \code
//!   DESCRIPTION: Retrieves the GPU registry path. This is different for each GPU.
//!                This is needed since writing to the per display registry 
//!                writes to only the GPU's which have displays attached.
//!                
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   PARAMETERS: hPhysicalGpu  - handle to the GPU you wish to read/write values for
//!               pRegistryPath - path of the per GPU registry hive
//!
//!   RETURN STATUS: LWAPI_OK: GPU Registry hive data returned
//!                  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle,
//!                  LWAPI_ILWALID_ARGUMENT: pRegistryPath is NULL
//!                  LWAPI_ERROR: Error finding the corresponding registry path
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPerGpuRegistryPath(LwPhysicalGpuHandle hPhysicalGpu, char *pRegistryPath);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetRawFuseData
//
//! \fn LwAPI_GPU_GetRawFuseData(LwPhysicalGpuHandle hPhysicalGpu,LW_RAW_FUSE_DATA *pFuseData)
//!  This function retrieves the raw bytes of the fuse data of each GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \retval  LWAPI_ILWALID_ARGUMENT              pFuseData is NULL
//! \retval  LWAPI_OK                            Fuse data was returned
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
#define LWAPI_MAX_RAW_FUSE_DATA_SIZE   64

//! \ingroup gpu
//! Used in LwAPI_GPU_GetRawFuseData()
typedef struct
{
    LwU32   version;        // structure version
    
    LwU8    fuseData[LWAPI_MAX_RAW_FUSE_DATA_SIZE];
    LwU32   fuseDataSize;
} LW_RAW_FUSE_DATA;

//! \ingroup gpu
#define LW_RAW_FUSE_DATA_VER  MAKE_LWAPI_VERSION(LW_RAW_FUSE_DATA,1)


//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_GetRawFuseData(LwPhysicalGpuHandle hPhysicalGpu,LW_RAW_FUSE_DATA *pFuseData);

 

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetFoundry
//
//! \fn LwAPI_GPU_GetFoundry(LwPhysicalGpuHandle hPhysicalGpu,LWAPI_FOUNDRY_ID *pFoundry)
//!  DESCRIPTION: This function retrieves the identity of the foundry that manufactured the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!  \param [out]  pFoundry                       See \ref LWAPI_FOUNDRY_ID for list of possible values.
//!
//!  \retval  LWAPI_ILWALID_ARGUMENT              pFoundry is NULL
//!  \retval  LWAPI_OK                            Foundry ID was returned
//!  \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//!  \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//!  \retval  LWAPI_NOT_SUPPORTED                 The interface is not supported (pre-G80 GPU)
//
//////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! Used in LwAPI_GPU_GetFoundry().
typedef enum
{
    LWAPI_FOUNDRY_UNKNOWN      = 0,
    LWAPI_FOUNDRY_TSMC         = 1,
    LWAPI_FOUNDRY_UMC          = 2,
    LWAPI_FOUNDRY_IBM          = 3,
    LWAPI_FOUNDRY_SMIC         = 4,
    LWAPI_FOUNDRY_CHARTERED    = 5,
    LWAPI_FOUNDRY_TOSHIBA      = 6,
} LWAPI_FOUNDRY_ID;


//!  \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_GetFoundry(LwPhysicalGpuHandle hPhysicalGpu,LWAPI_FOUNDRY_ID *pFoundry);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetVPECount
//
//! This function retrieves the number of Vertex Processing Engines (VPEs) on the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 95
//!
//! \retval LWAPI_ILWALID_ARGUMENT              pCount is NULL.
//! \retval LWAPI_OK                           *pCount is set.
//! \retval LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//! \retval LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetVPECount(LwPhysicalGpuHandle hPhysicalGpu,LwU32 *pCount);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetShaderPipeCount
//
//!  This function retrieves the number of Shader Pipes on the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \retval LWAPI_ILWALID_ARGUMENT              pCount is NULL.
//! \retval LWAPI_OK                           *pCount is set.
//! \retval LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//! \retval LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetShaderPipeCount(LwPhysicalGpuHandle hPhysicalGpu,LwU32 *pCount);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetShaderSubPipeCount
//
//!   DESCRIPTION: This function retrieves the number of Shader SubPipes on the GPU
//!                On newer architectures, this corresponds to the number of SM units
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: pCount is NULL
//!                LWAPI_OK: *pCount is set
//!                LWAPI_LWIDIA_DEVICE_NOT_FOUND: no LWPU GPU driving a display was found
//!                LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!
//! \ingroup   gpu  
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetShaderSubPipeCount(LwPhysicalGpuHandle hPhysicalGpu,LwU32 *pCount);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_RegisterOp
//
//! \fn LwAPI_GPU_RegisterOp(LwPhysicalGpuHandle hPhysicalGpu,LW_GPU_REGISTER_OP_DATA *pRegOps)
//!   DESCRIPTION: This function performs one or more read or write operations on GPU registers.
//!
//!      !! This is an extremely sensitive API and CANNOT be exported outside of LWPU. !!
//!      !! It is meant only for use by our internal developers for diagnostics.         !!
//!
//!   A series of operations on registers are described by an array of LW_GPU_REGISTER_OP structs.
//!
//!   For each operation, flags define read/write, global or GR Context, 32 or 64 bit;
//!   - A 32-bit offset into BAR0 defines the starting offset.
//!   - A 64-bit writeMask field defines which bits to preserve in the destination.
//!   - A 64-bit value field defines the data to write, or the bits that were read.
//!   - A returned status field reports the result of each register operation.
//!
//!   \note
//!   This interface is only supported on G8x onward.
//!
//!   See lwpu/sdk/inc/ctrl/ctrl2080/ctrl2080gpu.h LW2080_CTRL_GPU_REG_OP for further
//!   details on the underlying RM interface.
//!
//!   LWAPI_GPU_REG_OP_FLAG_TYPE_GLOBAL - The register is a global privileged register.
//!      Write operations take effect immediately.
//!
//!   LWAPI_GPU_REG_OP_FLAG_TYPE_GR_CTX - The register is a graphics context register.
//!      Read operations return the current value from the associated global register.
//!      Write operations are applied to all existing graphics engine contexts.  Any 
//!      newly created graphics engine contexts will also be modified.
//!
//!
//!   32bit read operations       \n                  
//!   ------------------------------------------    \n  
//!   regValueLo = read(bar0 + offset)\n                
//!   regValueHi = 0                                  
//!
//!   64bit read operations\n  
//!   ---------------------------------------------\n  
//!   regValueLo = read(bar0 + offset)\n  
//!   regValueHi = read(bar0 + offset + 4)  
//!
//!   32bit write operations  \n                      
//!   ------------------------------------------------------   \n 
//!   new = ((read(bar0 + offset) & ~writeMaskLo) | valueLo) write(bar0 + offset, new)  
//!
//!   64bit write operations  \n
//!   ------------------------------------------------------------- \n
//!   new_lo = ((read(bar0 + offset) & ~writeMaskLo) | valueLo)  \n
//!   new_hi = ((read(bar0 + offset + 4) &  ~writeMaskHi) | valueHi) 
//!   write(bar0 + offset, new_lo)
//!   write(bar0 + offset + 4, new_hi)  
//!
//!   See lwapichk for example usage.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//!   \retval  LWAPI_ILWALID_ARGUMENT              pRegOps is NULL or opCount is illegal.
//!   \retval  LWAPI_NOT_SUPPORTED                 The interface is not supported (eg: earlier than G8x).
//!   \retval  LWAPI_OK                            Data was returned.
//!   \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//!   \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
#define LWAPI_GPU_MAX_REGISTER_OP_COUNT 256

//! \ingroup gpu
//! Used in \ref LW_GPU_REGISTER_OP.
typedef enum
{
    LWAPI_GPU_REG_OP_FLAG_READ             = 0x00000001,
    LWAPI_GPU_REG_OP_FLAG_WRITE            = 0x00000002,
    LWAPI_GPU_REG_OP_FLAG_32BIT            = 0x00000004,
    LWAPI_GPU_REG_OP_FLAG_64BIT            = 0x00000008,
    LWAPI_GPU_REG_OP_FLAG_TYPE_GLOBAL      = 0x00000010,
    LWAPI_GPU_REG_OP_FLAG_TYPE_GR_CTX      = 0x00000020,
} LWAPI_GPU_REG_OP_FLAGS;

//! \ingroup gpu
//! Used in \ref LW_GPU_REGISTER_OP.
typedef enum
{
    LWAPI_GPU_REG_OP_STATUS_SUCCESS        = 0x00000000,
    LWAPI_GPU_REG_OP_STATUS_ILWALID_OP     = 0x00000001,    //!< Operation is not valid. 
    LWAPI_GPU_REG_OP_STATUS_ILWALID_TYPE   = 0x00000002,    //!< Type (global/Gr_ctx) is not valid.
    LWAPI_GPU_REG_OP_STATUS_ILWALID_OFFSET = 0x00000004,    //!< Offset is not valid.
    LWAPI_GPU_REG_OP_STATUS_UNSUPPORTED_OP = 0x00000008,    //!< Operation is not supported at this offset.
} LWAPI_GPU_REG_OP_STATUS;

//! \ingroup gpu
//! Used in \ref LW_GPU_REGISTER_OP_DATA.
typedef struct
{
    LwU16 flags;     // bit flags from LWAPI_GPU_REG_OP_FLAGS
    LwU16 status;    // status of this operation from LWAPI_GPU_REG_OP_STATUS
    LwU32 offset;    // Offset from BAR0
    LwU64 writeMask; // Bits set here indicate which bits of the value field to write to the target offset
    LwU64 value;     // register value to write (or result from read)
} LW_GPU_REGISTER_OP;

//! \ingroup gpu
//! Used in LwAPI_GPU_RegisterOp().
typedef struct
{
    LwU32              version;  // structure version [implicitly versions LW_GPU_REGISTER_OP as well]
    LwU32              opCount;
    LW_GPU_REGISTER_OP op[LWAPI_GPU_MAX_REGISTER_OP_COUNT];
} LW_GPU_REGISTER_OP_DATA;

//! \ingroup gpu
#define LW_GPU_REGISTER_OP_DATA_VER  MAKE_LWAPI_VERSION(LW_GPU_REGISTER_OP_DATA,1)



//!   \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_RegisterOp(LwPhysicalGpuHandle hPhysicalGpu,LW_GPU_REGISTER_OP_DATA *pRegOps);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetPartitionCount
//
//!  This function retrieves the number of frame buffer partitions on the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 95
//!
//! \retval LWAPI_ILWALID_ARGUMENT              pCount is NULL.
//! \retval LWAPI_OK                           *pCount is set.
//! \retval LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//! \retval LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPartitionCount(LwPhysicalGpuHandle hPhysicalGpu,LwU32 *pCount);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetMemPartitionMask
//
//!   DESCRIPTION: This function retrieves a 32-bit mask showing which memory partitions are enabled.
//!                LwAPI_GPU_GetPartitionCount() returns the count of enabled partitions.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 177
//! 
//!  \retval  LWAPI_ILWALID_ARGUMENT              pMask is NULL
//!  \retval  LWAPI_OK                           *pMask is set
//!  \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//!  \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//!
//!  \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetMemPartitionMask(LwPhysicalGpuHandle hPhysicalGpu,LwU32 *pMask);


///////////////////////////////////////////////////////////////////////////////
//!  This escape is meant FOR SWAK USE ONLY.  Please contact
//!  sw-lwapi if you wish to use this interface.
//!
//! FUNCTION NAME: LwAPI_GPU_GetGPCMask
//!
//! \code
//!   DESCRIPTION: Retrieves a 32-bit mask showing which GPCs (Graphics Processor Cluster)
//!                are enabled.
//!
//!                Returns 0 on pre-Fermi architectures.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: pMask is NULL
//!                LWAPI_OK: *pMask is set
//!                LWAPI_LWIDIA_DEVICE_NOT_FOUND: no LWPU GPU driving a display was found
//!                LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!                LWAPI_NOT_SUPPORTED: API call is not supported on current architecture
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetGPCMask(LwPhysicalGpuHandle hPhysicalGpu,LwU32 *pMask);



///////////////////////////////////////////////////////////////////////////////
//!  This escape is meant FOR SWAK USE ONLY.  Please contact
//!  sw-lwapi if you wish to use this interface.
//!
//! FUNCTION NAME: LwAPI_GPU_GetTPCMaskOnGPC
//!
//! \code
//!  DESCRIPTION: Retrieves a 32-bit mask showing which Fermi TPCs
//!                (Texture Processor Cluster) are enabled on the GPC idenified by gpcId.
//!
//!                gpcId values start at 0 and correspond to the position of bits
//!                returned by LwAPI_GPU_GetGPCMask().
//!
//!                Returns 0 on pre-Fermi architectures.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: pMask is NULL
//!                LWAPI_OK: *pMask is set
//!                LWAPI_LWIDIA_DEVICE_NOT_FOUND: no LWPU GPU driving a display was found
//!                LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!                LWAPI_NOT_SUPPORTED: API call is not supported on current architecture
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetTPCMaskOnGPC(LwPhysicalGpuHandle hPhysicalGpu,LwU32 gpcId,LwU32 *pMask);

///////////////////////////////////////////////////////////////////////////////
//!  This escape is meant FOR SWAK USE ONLY.  Please contact
//!  sw-lwapi if you wish to use this interface.
//!
//! FUNCTION NAME: LwAPI_GPU_GetZLWLLMask
//!
//! \code
//!   DESCRIPTION: Retrieves a 32-bit mask showing which ZLWLL
//!                are enabled on the GPC idenified by gpcId.
//!
//!                gpcId values start at 0 and correspond to the position of bits
//!                returned by LwAPI_GPU_GetGPCMask().
//!
//!                Returns 0 on pre-Fermi architectures.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: pMask is NULL
//!                LWAPI_OK: *pMask is set
//!                LWAPI_LWIDIA_DEVICE_NOT_FOUND: no LWPU GPU driving a display was found
//!                LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!                LWAPI_NOT_SUPPORTED: API call is not supported on current architecture
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetZLWLLMask(LwPhysicalGpuHandle hPhysicalGpu,LwU32 gpcId,LwU32 *pMask);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetTPCMask
//
//!   DESCRIPTION: This function retrieves a 32-bit mask showing which TPCs 
//!                (Texture Processor Cluster) are enabled.  
//!                Returns 0 on architectures that don't have TPCs.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 177
//! 
//!  \retval  LWAPI_ILWALID_ARGUMENT              pMask is NULL
//!  \retval  LWAPI_OK                           *pMask is set
//!  \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//!  \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//!  \retval  LWAPI_NOT_SUPPORTED                 API call is not supported on current architecture
//!
//!  \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetTPCMask(LwPhysicalGpuHandle hPhysicalGpu,LwU32 *pMask);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetSMMask
//
//!   DESCRIPTION: This function retrieves a 32-bit mask showing which SMs 
//!                (Streaming Multiprocessors) are enabled on the TPC identified by tpcNdx. \n
//!                tpcNdx values start at 0 and correspond to the position of bits
//!                returned by LwAPI_GPU_GetTPCMask().  [mask bit = 2^tpcNdx]
//!                Returns 0 on architectures that don't have SMs.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 177
//!  
//!  \retval   LWAPI_ILWALID_ARGUMENT              pMask is NULL, or tpcId does not match a TPC
//!  \retval   LWAPI_OK                           *pMask is set
//!  \retval   LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//!  \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!  \retval  LWAPI_NOT_SUPPORTED                 API call is not supported on current architecture
//!
//!  \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetSMMask(LwPhysicalGpuHandle hPhysicalGpu,LwU32 tpcId,LwU32 *pMask);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetTotalTPCCount
//
//!   DESCRIPTION: This function retrieves the total number of enabled TPCs (Texture Processor Clusters)
//!                Returns 0 on architectures that don't have TPCs.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!  
//! \retval  LWAPI_ILWALID_ARGUMENT              pCount is NULL
//! \retval  LWAPI_OK                           *pCount is set
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetTotalTPCCount(LwPhysicalGpuHandle hPhysicalGpu,LwU32 *pCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetTotalSMCount
//
//!   DESCRIPTION: This function retrieves the total number of enabled SMs 
//!               (Streaming Multiprocessors) across all TPCs (Texture Processor Clusters). \n 
//!                Returns 0 on architectures that don't have SMs.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!   
//! \retval  LWAPI_ILWALID_ARGUMENT: pCount is NULL
//! \retval  LWAPI_OK: *pCount is set
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND: no LWPU GPU driving a display was found
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!  \retval  LWAPI_NOT_SUPPORTED                 API call is not supported on current architecture
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetTotalSMCount(LwPhysicalGpuHandle hPhysicalGpu,LwU32 *pCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetTotalSPCount
//
//!   DESCRIPTION: This function retrieves the total number of enabled SPs across all SMs 
//!                (Streaming Multiprocessors) on all TPCs (Texture Processor Clusters). \n
//!                Returns 0 on architectures that don't have SPs.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!   
//! \retval  LWAPI_ILWALID_ARGUMENT: pCount is NULL
//! \retval  LWAPI_OK: *pCount is set
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND: no LWPU GPU driving a display was found
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!  \retval  LWAPI_NOT_SUPPORTED                 API call is not supported on current architecture
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetTotalSPCount(LwPhysicalGpuHandle hPhysicalGpu,LwU32 *pCount);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetGpuCoreCount
//
//!   DESCRIPTION: Retrieves the total number of cores defined for a GPU.
//!                Returns 0 on architectures that don't define GPU cores.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT              pCount is NULL
//! \retval ::LWAPI_OK                            *pCount is set
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND       no LWPU GPU driving a display was found
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//! \retval ::LWAPI_NOT_SUPPORTED                 API call is not supported on current architecture
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetGpuCoreCount(LwPhysicalGpuHandle hPhysicalGpu,LwU32 *pCount);


////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetDisplayChangeInhibitState
//
//! \fn LwAPI_GPU_GetDisplayChangeInhibitState(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pInhibitState)
//!  This function retrieves the display change inhibit state. See LW_GPU_DISPLAY_CHANGE_INHIBIT.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \retval  LWAPI_ILWALID_ARGUMENT              pInhibitState is NULL
//! \retval  LWAPI_OK                           *pInhibitState is set to one or more values in LW_GPU_DISPLAY_CHANGE_INHIBIT
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup dispcontrol
//! Used in LwAPI_GPU_GetDisplayChangeInhibitState()
typedef enum _LW_GPU_DISPLAY_CHANGE_INHIBIT
{
    LWAPI_GPU_DISPLAY_CHANGE_INHIBIT_SPAN             = 0x00000001,
    LWAPI_GPU_DISPLAY_CHANGE_INHIBIT_VIDEO            = 0x00000002,
    LWAPI_GPU_DISPLAY_CHANGE_INHIBIT_3D_FULLSCREEN    = 0x00000004,
    LWAPI_GPU_DISPLAY_CHANGE_INHIBIT_DOS_FULLSCREEN   = 0x00000008,
} LW_GPU_DISPLAY_CHANGE_INHIBIT;



//! \ingroup dispcontrol
LWAPI_INTERFACE LwAPI_GPU_GetDisplayChangeInhibitState(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pInhibitState);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetAllOutputs
//
//!  This function returns set of all GPU-output identifiers as a bitmask.
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use LwAPI_GPU_GetAllDisplayIds.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 85
//!
//! \retval   LWAPI_ILWALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL.
//! \retval   LWAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers.
//! \retval   LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//! \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use LwAPI_GPU_GetAllDisplayIds.")
LWAPI_INTERFACE LwAPI_GPU_GetAllOutputs(LwPhysicalGpuHandle hPhysicalGpu,LwU32 *pOutputsMask);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetInternalDisplays
//!
//! \code
//!   DESCRIPTION: Returns set of internal Displays as a bitmask.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: hPhysicalGpu or pOutputsMask is NULL
//!                LWAPI_OK: *pInternalDisplaysMask contains a set of GPU-internal display identifiers
//!                LWAPI_LWIDIA_DEVICE_NOT_FOUND: no LWPU GPU driving a display was found
//!                LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetInternalDisplays(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pInternalDisplaysMask);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetConnectedOutputs
//
//! This function is the same as LwAPI_GPU_GetAllOutputs() but returns only the set of GPU output 
//! identifiers that are connected to display devices.
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use LwAPI_GPU_GetConnectedDisplayIds.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \retval   LWAPI_ILWALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL.
//! \retval   LWAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers.
//! \retval   LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//! \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use LwAPI_GPU_GetConnectedDisplayIds.")
LWAPI_INTERFACE LwAPI_GPU_GetConnectedOutputs(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pOutputsMask);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetConnectedSLIOutputs
//
//!   DESCRIPTION: This function is the same as LwAPI_GPU_GetConnectedOutputs() but returns only the set of GPU-output 
//!                identifiers that can be selected in an SLI configuration. 
//!                 NOTE: This function matches LwAPI_GPU_GetConnectedOutputs()
//!                 - On systems which are not SLI capable.
//!                 - If the queried GPU is not part of a valid SLI group.
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use LwAPI_GPU_GetConnectedDisplayIds.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \retval   LWAPI_ILWALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL
//! \retval   LWAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers
//! \retval   LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//! \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//! 
//! \ingroup gpu  
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use LwAPI_GPU_GetConnectedDisplayIds.")
LWAPI_INTERFACE LwAPI_GPU_GetConnectedSLIOutputs(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pOutputsMask);




//! \ingroup gpu
//! @[
#define LW_GPU_CONNECTED_FLAG_UNCACHED 0x0
#define LW_GPU_CONNECTED_FLAG_CACHED   0x1
#define LW_GPU_CONNECTED_FLAG_FAKE     0x2
//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetConnectedOutputsEx
//
//!   DESCRIPTION: This function is the same as LwAPI_GPU_GetConnectedOutputs() except it takes a flag to request cached
//!                or uncached connected devices. Lwrrently XP cached/uncached is the same, so this is private.
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use LwAPI_GPU_GetConnectedDisplayIds.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 105
//!
//! \retval  LWAPI_ILWALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL
//! \retval  LWAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use LwAPI_GPU_GetConnectedDisplayIds.")
LWAPI_INTERFACE LwAPI_GPU_GetConnectedOutputsEx(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pOutputsMask, LwU32 flag);




//! \ingroup gpu
typedef enum
{
    LW_MONITOR_CONN_TYPE_UNINITIALIZED = 0,
    LW_MONITOR_CONN_TYPE_VGA,
    LW_MONITOR_CONN_TYPE_COMPONENT,
    LW_MONITOR_CONN_TYPE_SVIDEO,
    LW_MONITOR_CONN_TYPE_HDMI,
    LW_MONITOR_CONN_TYPE_DVI,
    LW_MONITOR_CONN_TYPE_LVDS,
    LW_MONITOR_CONN_TYPE_DP,
    LW_MONITOR_CONN_TYPE_COMPOSITE,
    LW_MONITOR_CONN_TYPE_UNKNOWN =  -1
} LW_MONITOR_CONN_TYPE;



//! \addtogroup gpu
//! @{
#define LW_GPU_CONNECTED_IDS_FLAG_UNCACHED          LW_BIT(0) //!< Get uncached connected devices
#define LW_GPU_CONNECTED_IDS_FLAG_SLI               LW_BIT(1) //!< Get devices such that those can be selected in an SLI configuration
#define LW_GPU_CONNECTED_IDS_FLAG_LIDSTATE          LW_BIT(2) //!< Get devices such that to reflect the Lid State
#define LW_GPU_CONNECTED_IDS_FLAG_FAKE              LW_BIT(3) //!< Get devices that includes the fake connected monitors
#define LW_GPU_CONNECTED_IDS_FLAG_EXCLUDE_MST       LW_BIT(4) //!< Excludes devices that are part of the multi stream topology.               
#define LW_GPU_CONNECTED_IDS_FLAG_SYMMETRIC         LW_BIT(5) //!< Get devices in symmetric order across GPUs.
#define LW_GPU_CONNECTED_IDS_FLAG_ORDERED           LW_BIT(6) //!< Get devices ordered by display number. NOT supported on winxp.

//! @}

//! \ingroup gpu
typedef struct _LW_GPU_DISPLAYIDS
{
    LwU32    version;
    LW_MONITOR_CONN_TYPE connectorType; //!< out: vga, tv, dvi, hdmi and dp. This is reserved for future use and clients should not rely on this information. Instead get the 
                                        //!< GPU connector type from LwAPI_GPU_GetConnectorInfo/LwAPI_GPU_GetConnectorInfoEx
    LwU32    displayId;                 //!< this is a unique identifier for each device
    LwU32    isDynamic:1;               //!< if bit is set then this display is part of MST topology and it's a dynamic
    LwU32    isMultiStreamRootNode:1;   //!< if bit is set then this displayID belongs to a multi stream enabled connector(root node). Note that when multi stream is enabled and 
                                        //!< a single multi stream capable monitor is connected to it, the monitor will share the display id with the RootNode. 
                                        //!< When there is more than one monitor connected in a multi stream topology, then the root node will have a separate displayId.
    LwU32    isActive:1;                //!< if bit is set then this display is being actively driven
    LwU32    isCluster:1;               //!< if bit is set then this display is the representative display
    LwU32    isOSVisible:1;             //!< if bit is set, then this display is reported to the OS
    LwU32    isWFD:1;                   //!< if bit is set, then this display is wireless 
    LwU32    isConnected:1;             //!< if bit is set, then this display is connected
    LwU32    isTile:1;                  //!< if bit is set, then this display is a tile
    LwU32    isVirtual:1;               //!< Reserved for future use. Do not use.
    LwU32    reserved: 23;              //!< must be zero
} LW_GPU_DISPLAYIDS;

//! \ingroup gpu
//! Macro for constructing the version field of ::_LW_GPU_DISPLAYIDS
#define LW_GPU_DISPLAYIDS_VER1          MAKE_LWAPI_VERSION(LW_GPU_DISPLAYIDS,1)

#define LW_GPU_DISPLAYIDS_VER LW_GPU_DISPLAYIDS_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetConnectedDisplayIds
//
//! \code
//!   DESCRIPTION: Due to space limitation LwAPI_GPU_GetConnectedOutputs can return maximum 32 devices, but 
//!                this is no longer true for DPMST. LwAPI_GPU_GetConnectedDisplayIds will return all 
//!                the connected display devices in the form of displayIds for the associated hPhysicalGpu.
//!                This function can accept set of flags to request cached, uncached, sli and lid to get the connected devices.
//!                Default value for flags will be cached .
//! HOW TO USE: 1) for each PhysicalGpu, make a call to get the number of connected displayId's 
//!                using LwAPI_GPU_GetConnectedDisplayIds by passing the pDisplayIds as NULL
//!                On call success:
//!             2) Allocate memory based on pDisplayIdCount then make a call LwAPI_GPU_GetConnectedDisplayIds to populate DisplayIds
//! SUPPORTED OS:  Windows XP and higher
//!
//! PARAMETERS:     hPhysicalGpu (IN)  - GPU selection
//!                 flags        (IN)  - One or more defines from LW_GPU_CONNECTED_IDS_FLAG_* as valid flags. 
//!                 pDisplayIds  (IN/OUT) - Pointer to an LW_GPU_DISPLAYIDS struct, each entry represents a one displayID and its attributes
//!                 pDisplayIdCount(OUT)- Number of displayId's.
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: hPhysicalGpu or pDisplayIds or pDisplayIdCount is NULL
//!                LWAPI_OK: *pDisplayIds contains a set of GPU-output identifiers
//!                LWAPI_LWIDIA_DEVICE_NOT_FOUND: no LWPU GPU driving a display was found
//!                LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetConnectedDisplayIds(__in LwPhysicalGpuHandle hPhysicalGpu,  __inout_ecount_part_opt(*pDisplayIdCount, *pDisplayIdCount) LW_GPU_DISPLAYIDS* pDisplayIds, __inout LwU32* pDisplayIdCount, __in LwU32 flags);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetAllDisplayIds
//
//!   DESCRIPTION: This API returns display IDs for all possible outputs on the GPU.
//!                For DPMST connector, it will return display IDs for all the video sinks in the topology. \n
//! HOW TO USE: 1. The first call should be made to get the all display ID count. To get the display ID count, send in \n
//!                  a) hPhysicalGpu    - a valid GPU handle(enumerated using LwAPI_EnumPhysicalGPUs()) as input,      \n
//!                  b) pDisplayIds     - NULL, as we just want to get the display ID count.                           \n 
//!                  c) pDisplayIdCount - a valid pointer to LwU32, whose value is set to ZERO.                        \n
//!                If all parameters are correct and this call is successful, this call will return the display ID's count. \n
//!             2. To get the display ID array, make the second call to LwAPI_GPU_GetAllDisplayIds() with              \n
//!                  a) hPhysicalGpu    - should be same value which was sent in first call,                           \n
//!                  b) pDisplayIds     - pointer to the display ID array allocated by caller based on display ID count,    \n 
//!                                       eg. malloc(sizeof(LW_GPU_DISPLAYIDS) * pDisplayIdCount).                     \n
//!                  c) pDisplayIdCount - a valid pointer to LwU32. This indicates for how many display IDs            \n
//!                                       the memory is allocated(pDisplayIds) by the caller.                          \n
//!                If all parameters are correct and this call is successful, this call will return the display ID array and actual
//!                display ID count (which was obtained in the first call to LwAPI_GPU_GetAllDisplayIds). If the input display ID count is
//!                less than the actual display ID count, it will overwrite the input and give the pDisplayIdCount as actual count and the
//!                API will return LWAPI_INSUFFICIENT_BUFFER.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     hPhysicalGpu         GPU selection.
//! \param [in,out] DisplayIds           Pointer to an array of LW_GPU_DISPLAYIDS structures, each entry represents one displayID 
//!                                      and its attributes.
//! \param [in,out] pDisplayIdCount      As input, this parameter indicates the number of display's id's for which caller has 
//!                                      allocated the memory. As output, it will return the actual number of display IDs.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval  LWAPI_INSUFFICIENT_BUFFER  When the input buffer(pDisplayIds) is less than the actual number of display IDs, this API 
//!                                     will return LWAPI_INSUFFICIENT_BUFFER. 
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetAllDisplayIds(__in LwPhysicalGpuHandle hPhysicalGpu, __inout_ecount_part_opt(*pDisplayIdCount, *pDisplayIdCount) LW_GPU_DISPLAYIDS* pDisplayIds, __inout LwU32* pDisplayIdCount);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetConnectedOutputsWithLidState
//
//!  This function is similar to LwAPI_GPU_GetConnectedOutputs(), and returns the connected display identifiers that are connected 
//!  as an output mask but unlike LwAPI_GPU_GetConnectedOutputs() this API "always" reflects the Lid State in the output mask.
//!  Thus if you expect the LID close state to be available in the connection mask use this API.
//!  - If LID is closed then this API will remove the LID panel from the connected display identifiers. 
//!  - If LID is open then this API will reflect the LID panel in the connected display identifiers. 
//!
//! \note This API should be used on notebook systems and on systems where the LID state is required in the connection 
//!       output mask. On desktop systems the returned identifiers will match LwAPI_GPU_GetConnectedOutputs().
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use LwAPI_GPU_GetConnectedDisplayIds.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \retval  LWAPI_ILWALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL
//! \retval  LWAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use LwAPI_GPU_GetConnectedDisplayIds.")
LWAPI_INTERFACE LwAPI_GPU_GetConnectedOutputsWithLidState(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pOutputsMask);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetConnectedSLIOutputsWithLidState
//
//!   DESCRIPTION: This function is the same as LwAPI_GPU_GetConnectedOutputsWithLidState() but returns only the set
//!                of GPU-output identifiers that can be selected in an SLI configuration. With SLI disabled,
//!                this function matches LwAPI_GPU_GetConnectedOutputsWithLidState().
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use LwAPI_GPU_GetConnectedDisplayIds.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \retval  LWAPI_ILWALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL
//! \retval  LWAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use LwAPI_GPU_GetConnectedDisplayIds.")
LWAPI_INTERFACE LwAPI_GPU_GetConnectedSLIOutputsWithLidState(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pOutputsMask);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetConnectedOutputsWithLidStateEx
//
//!   DESCRIPTION: This function is similar to LwAPI_GPU_GetConnectedOutputsWithLidState() except takes a flag to request
//!                cached or uncached connection data.  Lwrrently XP cached/uncached is the same, so 
//!                this is private.
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use LwAPI_GPU_GetConnectedDisplayIds.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \retval  LWAPI_ILWALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL
//! \retval  LWAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use LwAPI_GPU_GetConnectedDisplayIds.")
LWAPI_INTERFACE LwAPI_GPU_GetConnectedOutputsWithLidStateEx(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pOutputsMask, LwU32 flag);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetConnectedSLIOutputsWithLidStateEx
//
//!   DESCRIPTION: This function is the same as LwAPI_GPU_GetConnectedOutputsWithLidStateEx() but returns only the set of GPU-output 
//!                identifiers that can be selected in an SLI configuration. With SLI disabled
//!                this function matches LwAPI_GPU_GetConnectedOutputsWithLidStateEx().
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use LwAPI_GPU_GetConnectedDisplayIds.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 173
//!
//! \retval  LWAPI_ILWALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL
//! \retval  LWAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use LwAPI_GPU_GetConnectedDisplayIds.")
LWAPI_INTERFACE LwAPI_GPU_GetConnectedSLIOutputsWithLidStateEx(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pOutputsMask, LwU32 flag);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetSystemType
//
//! \fn LwAPI_GPU_GetSystemType(LwPhysicalGpuHandle hPhysicalGpu, LW_SYSTEM_TYPE *pSystemType)
//!  This function identifies whether the GPU is a notebook GPU or a desktop GPU.
//!       
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!         
//! \retval  LWAPI_ILWALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL
//! \retval  LWAPI_OK                           *pSystemType contains the GPU system type
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! Used in LwAPI_GPU_GetSystemType()
typedef enum
{
    LW_SYSTEM_TYPE_UNKNOWN = 0,
    LW_SYSTEM_TYPE_LAPTOP  = 1,
    LW_SYSTEM_TYPE_DESKTOP = 2,

} LW_SYSTEM_TYPE;



//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_GetSystemType(LwPhysicalGpuHandle hPhysicalGpu, LW_SYSTEM_TYPE *pSystemType);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetActiveOutputs
//
//!  This function is the same as LwAPI_GPU_GetAllOutputs but returns only the set of GPU output 
//!  identifiers that are actively driving display devices.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 85
//!
//! \retval    LWAPI_ILWALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL.
//! \retval    LWAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers.
//! \retval    LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//! \retval    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetActiveOutputs(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pOutputsMask);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetEdidEx
//
//! fn LwAPI_GPU_GetEdidEx(LwU32 displayId, LW_EDID_FLAG *pFlag, LW_EDID *pEdid)
//! \code
//!   DESCRIPTION: Returns the EDID data for the specified display Id
//!
//!   PARAMETERS:    displayId(IN) - LWPU Display ID. It is the value 
//!                                  returned from 
//!                                  LwAPI_SYS_GetDisplayIdFromGpuAndOutputId()
//!                  flags(IN/OUT) - the type of EDID to retrieve (IN)
//!                                  and the actual EDID type returned (OUT)
//!                                  If _DEFAULT or _COOKED is passed in and _COOKED is
//!                                  returned, then the returned EDID may or may not be
//!                                  the same as the raw (unmodified) EDID.
//!                  pEdid(OUT)    - The pointer to the LW_EDID structure which has 
//!                                  the EDID returned from the driver. It can be NULL
//!                                  so the API only returns the EDID type/flag from "flags".
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: pEDID is NULL; displayId is invalid
//!                LWAPI_OK: *pEDID contains valid data.
//!                LWAPI_LWIDIA_DEVICE_NOT_FOUND: no LWPU GPU driving a display was found.
//!                LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle.
//!                LWAPI_DATA_NOT_FOUND: requested display does not contain an EDID
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
typedef enum
{
    LW_EDID_FLAG_DEFAULT  = 0,   //!< the EDID which is actively used by the driver, it could be _RAW/_COOKED/_FORCED/_INF.
    LW_EDID_FLAG_RAW      = 1,   //!< the EDID which is not modified by the driver. If there's no _FORCED edid engaged, it 
                                 //!< will be the unmodified monitor EDID from the I2C bus. Otherwise it is original _FORCED edid.
    LW_EDID_FLAG_COOKED   = 2,   //!< the EDID has been modified by the driver for compatibility
    LW_EDID_FLAG_FORCED   = 3,   //!< the EDID is forced by the end-user over s/w interface, 
    LW_EDID_FLAG_INF      = 4,   //!< the EDID is from monitor INF
    LW_EDID_FLAG_HW       = 5,   //!< the EDID is from the monitor over I2C bus without any modification.
} LW_EDID_FLAG;

//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_GetEdidEx(LwU32 displayId, LW_EDID_FLAG *pFlag, LW_EDID *pEdid);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetEdidEx2
//
//! \code
//!   DESCRIPTION:   Returns the EDID data for the specified display Id
//!                  (LwAPI_GPU_GetConnectedDisplayIds() can be used to get the DisplayIds).
//!                  pEdid buffer has to be allocated by caller and to get the size of pEdid buffer,
//!                  call this function with pEdid as NULL. In most of the cases
//!                  buffer size of 384 bytes is sufficient, hence ideal way to call
//!                  this function is by allocating 384 bytes of memory to pEdid and
//!                  set pSizeofEDID to 384. If the function returns LWAPI_INSUFFICIENT_BUFFER
//!                  call this function again after freeing old buffer and
//!                  allocating a new buffer of size pSizeofEDID, returned in previous call.
//!
//!   PARAMETERS:    displayId(IN)       -   LWPU Display ID.
//!                  pFlag(IN/OUT)       -   The type of EDID to retrieve (IN)
//!                                          and the actual EDID type returned (OUT)
//!                                          This can be null.
//!                  pEdid(OUT)          -   The pointer to the buffer, in which,
//!                                          the EDID data is returned from the driver.
//!                                          Buffer has to be allocated by the caller.
//!                                          It can be NULL so the API only returns the
//!                                          EDID type/flag from "flags" and pSizeofEDID.
//!                                          If pEdid is present, pSizeofEDID cannot
//!                                          be NULL and value pointed by pSizeofEDID
//!                                          cannot be 0.
//!                  pSizeofEDID(IN/OUT) -   Size of input pEdid buffer on input and
//!                                          size of actual EDID data on output.
//!                                          If this parameter is NULL, pEdid has to be NULL
//!                                          and pFlag has to be present.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: Invalid combination of argument. Few of them quoted below
//!                                        * All NULL.
//!                                        * Neither pFlag nor pSizeofEDID is present. 
//!                                        * pEdid present and pSizeofEDID is NULL.
//!                                        * pEdid present and value pointed by pSizeofEDID is 0.
//!                LWAPI_OK: *pEDID contains valid data.
//!                LWAPI_LWIDIA_DEVICE_NOT_FOUND: no LWPU GPU driving a display was found.
//!                LWAPI_DATA_NOT_FOUND: requested display does not contain an EDID.
//!                LWAPI_INSUFFICIENT_BUFFER: Reallocate buffer with pSizeofEDID and call again to get complete data.
//!                                        In this case pEdid is contains undefined data.
//!                                        This error oclwrs only when pEdid is present.
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetEdidEx2(LwU32 displayId, LW_EDID_FLAG *pFlag, LwU8 *pEdid, LwU32 *pSizeofEDID);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DISP_ValidateEdid
//
//! \fn LwAPI_DISP_ValidateEdid(LwU32 displayId, LW_EDID *pEdid, LwU32 *pVFlag)
//! \code 
//!   DESCRIPTION: Check the possible errors with the given Edid
//!
//!   PARAMETERS:    displayId(IN) - LWPU Display Id (it is the value returned from LwAPI_GPU_GetConnectedDisplayIds()). 
//!                                  It could be zero, so the LwAPI does not check the compatibility between the Edid and the displayId.
//!                  pEdid(IN)     - The pointer to the LW_EDID structure which has the Edid data to check
//!                  pVFlag(OUT)   - bit-wised Edid errors
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: LWAPI_OK : the validation result is valid in pVFlag
//!                LWAPI_ILWALID_ARGUMENT: pEDID/pVFlag is NULL; 
//!                LWAPI_LWIDIA_DEVICE_NOT_FOUND: no LWPU GPU driving a display was found.
//!                LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle.
//!                LWAPI_DATA_NOT_FOUND: requested display does not contain an EDID
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup gpu
//! @{
#define LW_EDID_OK                               0    //!< the EDID is good
#define LW_EDID_BAD_CHECKSUM                     0x1  //!< the EDID has bad checksum (base or extension block)
#define LW_EDID_INCOMPATIBLE_CONNECTOR           0x2  //!< the EDID claimed the interface/connector is incompatible with the physical connector
#define LW_EDID_UNSUPPORTED_PIXEL_CLOCK          0x4  //!< the EDID claimed certain timings with pixel above the h/w limit
#define LW_EDID_INCOMPATIBLE_VESA_SPEC           0x8  //!< the EDID is not fully compatible with the VESA/EDID spec
//! @}

//! \ingroup gpu
LWAPI_INTERFACE LwAPI_DISP_ValidateEdid(LwU32 displayId, LW_EDID *pEdid, LwU32 *pVFlag);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_SetEDID
//
//!  Thus function sets the EDID data for the specified GPU handle and connection bit mask.
//!  displayOutputId should have exactly 1 bit set to indicate a single display. See \ref handles.
//!  \note The EDID will be cached across the boot session and will be enumerated to the OS in this call.
//!        To remove the EDID set sizeofEDID to zero.
//!        OS and LWAPI connection status APIs will reflect the newly set or removed EDID dynamically.
//!
//!                This feature will NOT be supported on the following boards:
//!                - VdChip
//!                - Lwdqro VX 
//!                - Tesla  
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \retval  LWAPI_ILWALID_ARGUMENT              pEDID is NULL; displayOutputId has 0 or > 1 bits set
//! \retval  LWAPI_OK                           *pEDID data was applied to the requested displayOutputId.
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle.
//! \retval  LWAPI_NOT_SUPPORTED                 For the above mentioned GPUs
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetEDID(LwPhysicalGpuHandle hPhysicalGpu, LwU32 displayOutputId, LW_EDID *pEDID);


///////////////////////////////////////////////////////////////////////////////
//! \fn LwAPI_GPU_SetEDIDInternal(LwU32 displayId, LW_EDID_LOCKING_FLAG flag, LwU8 *pEDID, LwU32 SizeofEDID)
//! \code
//! FUNCTION NAME: LwAPI_GPU_SetEDIDInternal
//!
//!   DESCRIPTION: This API sets the EDID data for the specified Display.
//!                Note:The EDID will be cached across the boot session and will be enumerated to the OS in this call.
//!                     To remove the EDID set SizeofEDID to zero.
//!                     OS and LWAPI connection status APIs will reflect the newly set or removed EDID dynamically.
//!   PARAMETERS:    displayId(IN)       -   LWPU Display ID. It is the value
//!                                          returned from
//!                                          LwAPI_SYS_GetDisplayIdFromGpuAndOutputId()
//!                  flag                -   Must be set to LWAPI_EDID_LOCKING_DEFAULT, other values are defined for internal usage.
//!                                          Indicates if this use is internal to LWPU,
//!                                          It will have enum values defined by LW_EDID_LOCKING_FLAG.
//!                  pEDID               -   pEDID points to the buffer containing EDID data of SizeofEDID.
//!                                          Lwrrently only LW_EDID_DATA_SIZE bytes of EDID data is supported.
//!                  SizeofEDID          -   Size of the buffer to which pEDID points.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS:   LWAPI_ILWALID_ARGUMENT: displayId is 0 or SizeofEDID is non zero and pEDID is null.
//!                  LWAPI_OK: *pEDID data was applied to the requested displayId.
//!                  LWAPI_LWIDIA_DEVICE_NOT_FOUND: no LWPU GPU driving a display was found.
//!                  LWAPI_ARGUMENT_EXCEED_MAX_SIZE: SizeofEDID is greater than LW_EDID_DATA_SIZE.
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! @{
typedef enum _LW_EDID_LOCKING_FLAG
{
    LWAPI_EDID_LOCKING_DEFAULT    = 0,         //!< For default use, actual edid locking
    LWAPI_INTERNAL_EDID_LOCKING   = 1,         //!< For an internal client to override Edid Locking
    LWAPI_DDAUTOTEST_EDID_LOCKING = 2,         //!< For DDAutoTest usage only and no other client is supposed to use this value.
} LW_EDID_LOCKING_FLAG;

LWAPI_INTERFACE LwAPI_GPU_SetEDIDInternal(LwU32 displayId, LW_EDID_LOCKING_FLAG flag, LwU8 *pEDID, LwU32 SizeofEDID);

//! @}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetTargetID
//! \code
//!   DESCRIPTION: Returns the target ID for the specified displayOutputId.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] hPhysicalGpu        Handle to the physical GPU to which the display is connected. This parameter is ignored
//!                                 when the displayOutputId is a LwAPI display Id obtained
//!
//! \param [in] displayOutputId     This can either be the connection bit mask or the newer LwAPI display Id. When the legacy
//!                                 connection bit mask is passed, it should have exactly 1 bit set to indicate a single display
//!
//! \param [out] pTargetId          Pointer to a LwU32 that will receive the targetId output.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetTargetID(LwPhysicalGpuHandle hPhysicalGpu, LwU32 displayOutputId, LwU32 *pTargetId);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetOutputType
//
//! \fn LwAPI_GPU_GetOutputType(LwPhysicalGpuHandle hPhysicalGpu, LwU32 outputId, LW_GPU_OUTPUT_TYPE *pOutputType)
//!  This function returns the output type for a specific physical GPU handle and outputId (exactly 1 bit set - see \ref handles).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \Version Earliest supported ForceWare version: 82.61
//!
//! \retval     LWAPI_ILWALID_ARGUMENT              hPhysicalGpu, outputId, or pOutputsMask is NULL; or outputId has > 1 bit set
//! \retval     LWAPI_OK                           *pOutputType contains a LwGpuOutputType value
//! \retval     LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//! \retval     LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! used in LwAPI_GPU_GetOutputType()
typedef enum _LW_GPU_OUTPUT_TYPE
{
    LWAPI_GPU_OUTPUT_UNKNOWN  = 0,
    LWAPI_GPU_OUTPUT_CRT      = 1,     //!<  CRT display device
    LWAPI_GPU_OUTPUT_DFP      = 2,     //!<  Digital Flat Panel display device
    LWAPI_GPU_OUTPUT_TV       = 3,     //!<  TV display device
} LW_GPU_OUTPUT_TYPE;




//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_GetOutputType(LwPhysicalGpuHandle hPhysicalGpu, LwU32 outputId, LW_GPU_OUTPUT_TYPE *pOutputType);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetDeviceDisplayMode
//
//! \fn LwAPI_GPU_GetDeviceDisplayMode(LwPhysicalGpuHandle hPhysicalGpu, LwU32 displayId, LW_GPU_DISPLAY_MODE *pDeviceDisplayMode)
//!   DESCRIPTION: For the specified physical GPU handle and single active displayId (exactly 1 bit set), this API
//!                returns the device display mode (see LW_GPU_DISPLAY_MODE) according to hardware (including raster extension). This
//!                includes the backend timing info.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \retval   LWAPI_ILWALID_ARGUMENT              hPhysicalGpu, displayId or pOutputsMask is NULL; displayId has > 1 bit set;
//!                                                displayId is not an active display.
//!  \retval   LWAPI_OK                           *pDeviceDisplayMode contains the returned display mode information.
//!  \retval   LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//!  \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! Used in LwAPI_GPU_GetDeviceDisplayMode().
typedef struct
{
    LwU32 version;          //!< Structure version
    LwU32 activeWidth;      //!< Number of active horizontal pixels
    LwU32 activeHeight;     //!< Number of active vertical pixels
    LwU32 totalWidth;       //!< Total size of raster width (including blanking)
    LwU32 totalHeight;      //!< Total size of raster height (including blanking)
    LwU32 depth;            //!< Color depth
    LwU32 frequency;        //!< Callwlated refresh rate based upon current raster and pixel clock
} LW_GPU_DISPLAY_MODE;

//! \ingroup gpu
#define LW_GPU_DISPLAY_MODE_VER  MAKE_LWAPI_VERSION(LW_GPU_DISPLAY_MODE,1)


//!  \ingroup  gpu
LWAPI_INTERFACE LwAPI_GPU_GetDeviceDisplayMode(LwPhysicalGpuHandle hPhysicalGpu, LwU32 displayId, LW_GPU_DISPLAY_MODE *pDeviceDisplayMode);




//DISPLAYPORT is all private for now. Do not change category until that info is public.
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetFlatPanelInfo
//
//! \fn LwAPI_GPU_GetFlatPanelInfo(LwPhysicalGpuHandle hPhysicalGpu, LwU32 outputId, LW_GPU_FLAT_PANEL_INFO *pFlatPanelInfo)
//!  Given a physical GPU handle and a single display outputId of the flat panel (see \ref handles), this API 
//!  returns the flat panel attributes.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \retval  LWAPI_ILWALID_ARGUMENT              hPhysicalGpu, outputId, or pFlatPanelInfo is NULL; or outputId has > 1 bit set.
//! \retval  LWAPI_OK                           *pFlatPanelInfo contains the returned flat panel information.
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \retval  LWAPI_EXPECTED_DIGITAL_FLAT_PANEL   outputId is not associated with digital flat panel.
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! Used in LW_GPU_FLAT_PANEL_INFO
typedef enum _LW_GPU_FLATPANEL_SIGNAL_TYPE
{
  LW_GPU_FLATPANEL_SIGNAL_TYPE_TMDS         = 0,
  LW_GPU_FLATPANEL_SIGNAL_TYPE_LVDS         = 1,
  LW_GPU_FLATPANEL_SIGNAL_TYPE_SDI          = 2,
  LW_GPU_FLATPANEL_SIGNAL_TYPE_DISPLAYPORT  = 3,
    
} LW_GPU_FLATPANEL_SIGNAL_TYPE;


//! \ingroup gpu
//! Used in LW_GPU_FLAT_PANEL_INFO
typedef enum _LW_GPU_FLATPANEL_SIGNAL_LINK
{
  LW_GPU_FLATPANEL_SIGNAL_SINGLE_LINK       = 1,
  LW_GPU_FLATPANEL_SIGNAL_DUAL_LINK         = 2,
    
} LW_GPU_FLATPANEL_SIGNAL_LINK;


//! \ingroup gpu
//! Used in LW_GPU_FLAT_PANEL_INFO
typedef enum _LW_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_LANES
{
  LW_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_NONE              = 0,
  LW_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_SINGLE_LANE       = 1,
  LW_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_DUAL_LANE         = 2,
  LW_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_QUAD_LANE         = 3,
    
} LW_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_LANES;


//! \ingroup gpu
//! Used in LW_GPU_FLAT_PANEL_INFO
typedef enum _LW_GPU_FLATPANEL_SIGNAL_COLOR_FLAGS
{
  LW_GPU_FLATPANEL_SIGNAL_COLOR_LIMITED_RANGE           = 0x00000001,   //!< Flatpanel supports limited color range.
  LW_GPU_FLATPANEL_SIGNAL_COLOR_AUTO_CONFIGURE          = 0x00000002,   //!< Flatpanel supports auto-configuring the color range.
  LW_GPU_FLATPANEL_SIGNAL_COLOR_FORMAT_YCBCR422_CAPABLE = 0x00000004,   //!< Flatpanel is YCBCR422 color format capable.
  LW_GPU_FLATPANEL_SIGNAL_COLOR_FORMAT_YCBCR444_CAPABLE = 0x00000008,   //!< Flatpanel is YCBCR444 color format capable.
   
} LW_GPU_FLATPANEL_SIGNAL_COLOR_FLAGS;


//! \ingroup gpu
//! Used in LwAPI_GPU_GetFlatPanelInfo()
typedef struct
{
    LwU32                                       version;                    //!< Structure version
    LW_GPU_FLATPANEL_SIGNAL_TYPE                signalType;                 //!< Flat panel signal type
    LW_GPU_FLATPANEL_SIGNAL_LINK                linkType;                   //!< Link type
    LW_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_LANES   displayPortLanes;           //!< 1, 2 or 4 DisplayPort lanesconnected panel. 
    LwU32                                       colorFlags;                 //!< One or more bits from LW_GPU_FLATPANEL_SIGNAL_COLOR_FLAGS
    LwU32                                       hdmiCapable:1;              //!< HMDI status
    LwU32                                       scalerDisabled:1;           //!< Indicates if GPU scaling is disabled (possible with SLI active on certain GPUs)

    LwU32                                       refreshRateLocked:1;        //!< Flat panel supports 60 Hz only
}
LW_GPU_FLAT_PANEL_INFO;


//! \ingroup gpu
#define LW_GPU_FLAT_PANEL_INFO_VER  MAKE_LWAPI_VERSION(LW_GPU_FLAT_PANEL_INFO,1)


//! \ingroup gpu  
LWAPI_INTERFACE LwAPI_GPU_GetFlatPanelInfo(LwPhysicalGpuHandle hPhysicalGpu, LwU32 outputId, LW_GPU_FLAT_PANEL_INFO *pFlatPanelInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_ValidateOutputCombination
//
//!  This function determines if a set of GPU outputs can be active 
//!  simultaneously.  While a GPU may have <n> outputs, typically they cannot 
//!  all be active at the same time due to internal resource sharing.
//!
//!  Given a physical GPU handle and a mask of candidate outputs, this call
//!  will return LWAPI_OK if all of the specified outputs can be driven
//!  simultaneously.  It will return LWAPI_ILWALID_COMBINATION if they cannot.
//!                
//!  Use LwAPI_GPU_GetAllOutputs() to determine which outputs are candidates.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 85
//!
//! \retval  LWAPI_OK                            Combination of outputs in outputsMask are valid (can be active simultaneously).
//! \retval  LWAPI_ILWALID_COMBINATION           Combination of outputs in outputsMask are NOT valid.
//! \retval  LWAPI_ILWALID_ARGUMENT              hPhysicalGpu or outputsMask does not have at least 2 bits set.
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ValidateOutputCombination(LwPhysicalGpuHandle hPhysicalGpu, LwU32 outputsMask);




//! \ingroup gpu
//! Used in LwAPI_GPU_GetConnectorState()
typedef struct _LW_CONNECTOR_STATE
{
    LwU32       version;                            //!<  Structure version

    LwU64       isMultiStreamEnabled    : 1;        //!< Specifies if multi stream is enabled on this connector
    LwU64       isStreamCloneEnabled    : 1;        //!< Specifies if stream clone is enabled on this connector
    LwU64       reserved                : 62;       //!< Reserved. Must be set to ZERO.

} LW_CONNECTOR_STATE_V1;

//! \ingroup gpu
typedef LW_CONNECTOR_STATE_V1 LW_CONNECTOR_STATE;

#define LW_CONNECTOR_STATE_VER1  MAKE_LWAPI_VERSION(LW_CONNECTOR_STATE_V1, 1)
#define LW_CONNECTOR_STATE_VER   LW_CONNECTOR_STATE_VER1 

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetConnectorState
//
//! \fn LwAPI_GPU_GetConnectorState(__in LwU32 displayId, __inout LW_CONNECTOR_STATE *pConnectorState)
//!
//!   Description: This API returns the connector state for a given connector identified by the input
//!                displayId parameter. Note that when the display id represents a device in a multi stream topology,
//!                the state of the physical connector to which the display is rooted to, will be returned. If the 
//!                display is rooted to multiple physical connectors (when connected via a concentrator), the 
//!                output is not guaranteed to be of any connector. In such cases, the user should pass the display id
//!                of the connector specifically.
//!
//! \param[in]     displayId        The displayId of a device connected to the required connector
//! \param[in/out] pConnectorState  Pointer to LW_CONNECTOR_STATE structure that will receive the data
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!              specific meaning for this API, they are listed below.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetConnectorState(__in LwU32 displayId, __inout LW_CONNECTOR_STATE *pConnectorState);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetShortName
//
//!  This function retrieves the GPU short name - for example, "LW40", "G70", etc..
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 85
//!
//! \return  LWAPI_ERROR or LWAPI_OK
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetShortName(LwPhysicalGpuHandle hPhysicalGpu, LwAPI_ShortString szName);

 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetFullName
//
//!  This function retrieves the full GPU name as an ASCII string - for example, "Lwdqro FX 1400".
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 90
//!
//! \return  LWAPI_ERROR or LWAPI_OK
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetFullName(LwPhysicalGpuHandle hPhysicalGpu, LwAPI_ShortString szName);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetPCIIdentifiers
//
//!  This function returns the PCI identifiers associated with this GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 90
//!
//! \param   DeviceId      The internal PCI device identifier for the GPU.
//! \param   SubSystemId   The internal PCI subsystem identifier for the GPU.
//! \param   RevisionId    The internal PCI device-specific revision identifier for the GPU.
//! \param   ExtDeviceId   The external PCI device identifier for the GPU.
//!
//! \retval  LWAPI_ILWALID_ARGUMENT              hPhysicalGpu or an argument is NULL
//! \retval  LWAPI_OK                            Arguments are populated with PCI identifiers
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPCIIdentifiers(LwPhysicalGpuHandle hPhysicalGpu,LwU32 *pDeviceId,LwU32 *pSubSystemId,LwU32 *pRevisionId,LwU32 *pExtDeviceId);
    



//! \ingroup gpu
//! Used in LwAPI_GPU_GetGPUType().    
typedef enum _LW_GPU_TYPE
{
    LW_SYSTEM_TYPE_GPU_UNKNOWN     = 0, 
    LW_SYSTEM_TYPE_IGPU            = 1, //!< Integrated GPU
    LW_SYSTEM_TYPE_DGPU            = 2, //!< Discrete GPU
    LW_SYSTEM_TYPE_SOCGPU          = 3, //!< SoC GPU
} LW_GPU_TYPE; 


/////////////////////////////////////////////////////////////////////////////// 
// 
// FUNCTION NAME: LwAPI_GPU_GetGPUType 
// 
//!  DESCRIPTION: This function returns the GPU type (integrated or discrete).
//!               See ::LW_GPU_TYPE. 
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 173
//!
//! \retval  LWAPI_ILWALID_ARGUMENT              hPhysicalGpu 
//! \retval  LWAPI_OK                           *pGpuType contains the GPU type 
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found 
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle 
//!
//!  \ingroup gpu 
///////////////////////////////////////////////////////////////////////////////     
LWAPI_INTERFACE LwAPI_GPU_GetGPUType(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_TYPE *pGpuType);




//! \ingroup gpu
//! Used in LwAPI_GPU_GetBusType()
typedef enum _LW_GPU_BUS_TYPE
{
    LWAPI_GPU_BUS_TYPE_UNDEFINED    = 0,
    LWAPI_GPU_BUS_TYPE_PCI          = 1,
    LWAPI_GPU_BUS_TYPE_AGP          = 2,
    LWAPI_GPU_BUS_TYPE_PCI_EXPRESS  = 3,
    LWAPI_GPU_BUS_TYPE_FPCI         = 4,
    LWAPI_GPU_BUS_TYPE_AXI          = 5,
} LW_GPU_BUS_TYPE;
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetBusType
//
//!  This function returns the type of bus associated with this GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 90
//!
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!              specific meaning for this API, they are listed below.
//! \retval      LWAPI_ILWALID_ARGUMENT             hPhysicalGpu or pBusType is NULL.
//! \retval      LWAPI_OK                          *pBusType contains bus identifier.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetBusType(LwPhysicalGpuHandle hPhysicalGpu,LW_GPU_BUS_TYPE *pBusType);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetBusId
//
//!   DESCRIPTION: Returns the ID of the bus associated with this GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 167
//!
//!  \retval  LWAPI_ILWALID_ARGUMENT              hPhysicalGpu or pBusId is NULL.
//!  \retval  LWAPI_OK                           *pBusId contains the bus ID.
//!  \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//!  \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//!
//!  \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetBusId(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pBusId);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetBusSlotId
//
//!   DESCRIPTION: Returns the ID of the bus slot associated with this GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 167
//!
//!  \retval  LWAPI_ILWALID_ARGUMENT              hPhysicalGpu or pBusSlotId is NULL.
//!  \retval  LWAPI_OK                           *pBusSlotId contains the bus slot ID.
//!  \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//!  \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//!
//!  \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetBusSlotId(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pBusSlotId);




//! \ingroup gpu
//! @{
typedef struct
{
    LwU32 version;                //!< (IN)  structure version
    LwU32 speedSwitchErrorCount;  //!< (OUT) Returns the speed switch error count 
    LwU32 widthSwitchErrorCount;  //!< (OUT) Returns the width switch error count                     
} LW_PCIELINK_SWITCH_ERROR_INFO_V1;


typedef LW_PCIELINK_SWITCH_ERROR_INFO_V1    LW_PCIELINK_SWITCH_ERROR_INFO;
#define LW_PCIELINK_SWITCH_ERROR_INFO_VER1  MAKE_LWAPI_VERSION(LW_PCIELINK_SWITCH_ERROR_INFO_V1,1)
#define LW_PCIELINK_SWITCH_ERROR_INFO_VER   LW_PCIELINK_SWITCH_ERROR_INFO_VER1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetPCIELinkSwitchErrorInfo
//
//!   DESCRIPTION: This API returns the error count of the ASLM switch or Gen1<->Gen2 switch.  
//!
//! \param [in]    hPhysicalGpu           Physical GPU Handle for GPU Selection
//! \param [out]   pSwitchErrorInfo       Switch Error Count information returned by system. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \return The following are return error codes with specific meaning for this API. In addition, this API can return any of the error codes enumerated in #LwAPI_Status.
//! \retval LWAPI_LWIDIA_DEVICE_NOT_FOUND No LWPU GPU driving a display was found
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPCIELinkSwitchErrorInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_PCIELINK_SWITCH_ERROR_INFO *pSwitchErrorInfo);



//! \ingroup gpu

typedef enum
{
    LW_INTERRUPT_LEGACY_IRQL_TYPE = 0,  //!< legacy line based interrupts
    LW_INTERRUPT_MSI_TYPE = 1,          //!< Message Signaled Interrupts
} LW_INTERRUPT_TYPE;

typedef struct _LW_INTERRUPT_INFO
{
    LwU32 version;                   //!< structure version
    LW_INTERRUPT_TYPE type; //!< one of LW_INTERRUPT_TYPE
    LwU32 IRQ;                        //!< IRQ. It is valid for LW_INTERRUPT_LEGACY_IRQL_TYPE only

}LW_INTERRUPT_INFO_V1;

typedef LW_INTERRUPT_INFO_V1    LW_INTERRUPT_INFO;
#define LW_INTERRUPT_INFO_VER1  MAKE_LWAPI_VERSION(LW_INTERRUPT_INFO_V1,1)
#define LW_INTERRUPT_INFO_VER   LW_INTERRUPT_INFO_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetInterruptInfo
//
//!  This function returns the interrupt info associated with this GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 319
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetInterruptInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_INTERRUPT_INFO *interruptInfo);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetIRQ
//
//!  This function returns the interrupt number associated with this GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 90
//!
//! \retval  LWAPI_ILWALID_ARGUMENT              hPhysicalGpu or pIRQ is NULL.
//! \retval  LWAPI_OK                           *pIRQ contains interrupt number.
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetIRQ(LwPhysicalGpuHandle hPhysicalGpu,LwU32 *pIRQ);
    
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetVbiosRevision
//
//!  This function returns the revision of the video BIOS associated with this GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 90
//!
//! \retval    LWAPI_ILWALID_ARGUMENT               hPhysicalGpu or pBiosRevision is NULL.
//! \retval    LWAPI_OK                            *pBiosRevision contains revision number.
//! \retval    LWAPI_LWIDIA_DEVICE_NOT_FOUND        No LWPU GPU driving a display was found.
//! \retval    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE   hPhysicalGpu was not a physical GPU handle.
//! \ingroup   gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetVbiosRevision(LwPhysicalGpuHandle hPhysicalGpu,LwU32 *pBiosRevision);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetVbiosOEMRevision
//
//!  This function returns the OEM revision of the video BIOS associated with this GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 90
//!
//! \retval    LWAPI_ILWALID_ARGUMENT              hPhysicalGpu or pBiosRevision is NULL
//! \retval    LWAPI_OK                           *pBiosRevision contains revision number
//! \retval    LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//! \retval    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//! \ingroup   gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetVbiosOEMRevision(LwPhysicalGpuHandle hPhysicalGpu,LwU32 *pBiosRevision);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetBridgeVersionInfo
//
//! \fn LwAPI_GPU_GetBridgeInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout_ecount_part_opt(*pBridgeCount, *pBridgeCount) LW_BRIDGE_FIRMWARE_INFO *pBridgeFirmwareInfo, __inout LwU32 *pBridgeCount, )
//!     DESCRIPTION: Returns information about the bridge associated with this GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \param [in]     hPhysicalGpu        GPU selection.
//! \param [out]    pBridgeCount        Count of physical bridges.
//! \param [out]    pBridgeFirmwareInfo Structure containing bridge firmware information.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//! \retval  LWAPI_ILWALID_ARGUMENT     hPhysicalGpu or pBiosRevision or pOemVersion or pSiliconRevision is NULL.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
typedef enum _HWBC_RES_TYPE
{
    HWBC_UNKNOWN = 0,   
    HWBC_LWIDIA_MCP55,
    HWBC_LWIDIA_BR03,
    HWBC_LWIDIA_C55,
    HWBC_LWIDIA_MCP65,
    HWBC_LWIDIA_BR04,
    HWBC_LWIDIA_C73,
    HWBC_LWIDIA_MCP79,
    HWBC_PLX_PEX8747
} HWBC_RES_TYPE;

//! \ingroup gpu
typedef struct _LW_BRIDGE_FIRMWARE_INFO_V1
{
    LwU32   version;            //!<structure version
    LwU32   bridgeId;           //!<bridge id assigned by RM
    LwU32   fwVersion;          //!<firmware version of the bridge
    LwU8    oemVersion;         //!<oem version of bridge firmware
    LwU8    siliconRevision;    //!<silicon revision of the bridge chip
    LwU8    bridgeName;         //!<bridge name will be one of enum type HWBC_RES_TYPE
} LW_BRIDGE_FIRMWARE_INFO_V1;

//! \ingroup gpu
typedef struct _LW_BRIDGE_FIRMWARE_INFO_V2
{
    LwU32   version;            //!<structure version
    LwU32   bridgeId;           //!<bridge id assigned by RM
    LwU32   fwVersion;          //!<firmware version of the bridge
    LwU8    oemVersion;         //!<oem version of bridge firmware
    LwU8    siliconRevision;    //!<silicon revision of the bridge chip
    LwU8    bridgeName;         //!<bridge name will be one of enum type HWBC_RES_TYPE
    LwU32   domain;             //!<domain of the physical bridge
    LwU8    bus;                //!<bus number of the physical bridge
    LwU8    device;             //!<device number of the physical bridge
    LwU8    func;               //!<function number of the physical bridge
} LW_BRIDGE_FIRMWARE_INFO_V2;

//! \ingroup gpu
typedef LW_BRIDGE_FIRMWARE_INFO_V2 LW_BRIDGE_FIRMWARE_INFO;

//! \ingroup gpu
//! Macro for constructing the version field of ::LW_BRIDGE_FIRMWARE_INFO
#define LW_BRIDGE_FIRMWARE_INFO_VER_1 MAKE_LWAPI_VERSION(LW_BRIDGE_FIRMWARE_INFO_V1,1)
#define LW_BRIDGE_FIRMWARE_INFO_VER_2 MAKE_LWAPI_VERSION(LW_BRIDGE_FIRMWARE_INFO_V2,2)
#define LW_BRIDGE_FIRMWARE_INFO_VER LW_BRIDGE_FIRMWARE_INFO_VER_2

//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_GetBridgeVersionInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout_ecount_part_opt(*pBridgeCount, *pBridgeCount) LW_BRIDGE_FIRMWARE_INFO *pBridgeFirmwareInfo, __inout LwU32 *pBridgeCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetVbiosOemInfo
//
//! \fn LwAPI_GPU_GetVbiosOemInfo(LwPhysicalGpuHandle hPhysicalGpu,LW_VBIOS_OEM_INFO *pVbiosOemInfo)
//! \code
//!   DESCRIPTION: Returns some OEM specific data from the vbios associated this GPU.
//!
//!    PARAMETERS: hPhysicalGpu(IN) - GPU selection.
//!                pVbiosOemInfo(OUT) - Structure containing OEM information retrieved.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! RETURN STATUS: LWAPI_OK: *pVbiosOemInfo contains info
//!                LWAPI_ILWALID_ARGUMENT: hPhysicalGpu or pVbiosOemInfo is NULL
//!                LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
typedef struct
{
    LwU32              version;        //!<structure version
    LwAPI_ShortString  vendorName;
    LwAPI_ShortString  productName;
    LwAPI_ShortString  productRevision;
} LW_VBIOS_OEM_INFO;

//! \ingroup gpu
//! Macro for constructing the version field of ::LW_VBIOS_OEM_INFO
#define LW_VBIOS_OEM_INFO_VER MAKE_LWAPI_VERSION(LW_VBIOS_OEM_INFO,1)

//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_GetVbiosOemInfo(LwPhysicalGpuHandle hPhysicalGpu,LW_VBIOS_OEM_INFO *pVbiosOemInfo);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetVbiosMxmVersion
//
//!   DESCRIPTION: This API returns the MXM Spec version of the video BIOS associated with the specified GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \param [in]  hPhysicalGpu      GPU selection.
//! \param [out] pBiosMxmVersion   MXM Version information retrieved.
//!
//! \retval ::LWAPI_OK                           *pBiosMxmVersion contains version number
//! \retval ::LWAPI_ILWALID_ARGUMENT              hPhysicalGpu or pBiosMxmVersion is NULL
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//! \retval ::LWAPI_NOT_SUPPORTED                 The specified GPU is not MXM form factor
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetVbiosMxmVersion(LwPhysicalGpuHandle hPhysicalGpu,LwU32 *pBiosMxmVersion);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetVbiosImage
//
//! \fn LwAPI_GPU_GetVbiosImage(LwPhysicalGpuHandle hPhysicalGpu,LW_VBIOS_IMAGE *pImage)
//!  This function returns the entire video BIOS image associated with this GPU.
//!
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 100
//!
//! \retval  LWAPI_ILWALID_ARGUMENT              hPhysicalGpu or pImage is NULL.
//! \retval  LWAPI_OK                           *pImage contains the VBIOS image. (Parsing it is up to the caller)
//! \retval  LWAPI_INCOMPATIBLE_STRUCT_VERSION   LW_VBIOS_IMAGE version is not compatible with driver.
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! Used in LW_VBIOS_IMAGE 
#define LW_VBIOS_IMAGE_SIZE (64*1024)

//! \ingroup gpu
//! Used in LwAPI_GPU_GetVbiosImage()
typedef struct
{
    LwU32   version;        //!< Structure version
    LwU32   bufferSize;
    LwU8    buffer[LW_VBIOS_IMAGE_SIZE];
} LW_VBIOS_IMAGE;

//! \ingroup gpu
#define LW_VBIOS_IMAGE_VER MAKE_LWAPI_VERSION(LW_VBIOS_IMAGE,1)



//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_GetVbiosImage(LwPhysicalGpuHandle hPhysicalGpu,LW_VBIOS_IMAGE *pImage);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetVbiosSelwrityInfo
//
//! \fn LwAPI_GPU_GetVbiosSelwrityInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_VBIOS_SELWRITY_INFO *pVbiosSelwrityInfo)
//!  This function returns the VBIOS security information from this GPU.
//!
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 295
//!
//! \retval  LWAPI_ILWALID_ARGUMENT              hPhysicalGpu or pImage is NULL.
//! \retval  LWAPI_OK                           *pVbiosSelwrityInfo contains the security information
//! \retval  LWAPI_INCOMPATIBLE_STRUCT_VERSION   LW_VBIOS_SELWRITY_INFO version is not compatible with driver.
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! @{
typedef enum
{
    LW_VBIOS_SELWRITY_INFO_TYPE_ILWALID                   = 0x00,
    LW_VBIOS_SELWRITY_INFO_TYPE_UNSIGNED                  = 0x01,
    LW_VBIOS_SELWRITY_INFO_TYPE_LWIDIA_DEBUG              = 0x02,
    LW_VBIOS_SELWRITY_INFO_TYPE_LWIDIA_RELEASE            = 0x03,
    LW_VBIOS_SELWRITY_INFO_TYPE_LWIDIA_AE_DEBUG           = 0x04,
    LW_VBIOS_SELWRITY_INFO_TYPE_PARTNER_DEBUG             = 0x05,
    LW_VBIOS_SELWRITY_INFO_TYPE_PARTNER                   = 0x06,
} LW_VBIOS_SELWRITY_INFO_TYPE;

typedef enum _LW_VBIOS_INFO_STATUS
{    
    LW_VBIOS_INFO_STATUS_OK                                    = 0x00,
    LW_VBIOS_INFO_STATUS_EXPIRED                               = 0x01,
    LW_VBIOS_INFO_STATUS_ILWALID                               = 0x02,
    LW_VBIOS_INFO_STATUS_DEVID_MISMATCH                        = 0x03,
    LW_VBIOS_INFO_STATUS_ERR_ROMPACK_OFFSET                    = 0x04,
    LW_VBIOS_INFO_STATUS_INSUFFICIENT_RESOURCES                = 0x05, 
    LW_VBIOS_INFO_STATUS_NBSI_INCOMPLETE                       = 0x06, 
    LW_VBIOS_INFO_STATUS_ILWALID_CERT                          = 0x07, 
    LW_VBIOS_INFO_STATUS_ILWALID_HASH                          = 0x08, 
    LW_VBIOS_INFO_STATUS_VBIOS_HASH_NOT_STARTED                = 0x09, 
    LW_VBIOS_INFO_STATUS_SELWRITY_BLOCK_NOT_FOUND              = 0x0a, 
    LW_VBIOS_INFO_STATUS_FIRST_X509_NOT_FOUND                  = 0x0b, 
    LW_VBIOS_INFO_STATUS_ILWALID_PEM_FORMAT                    = 0x0c, 
    LW_VBIOS_INFO_STATUS_UNKNOWN_CERT_TYPE                     = 0x0d, 
    LW_VBIOS_INFO_STATUS_DUPLICATE_VENDOR_CERT_FOUND           = 0x0e, 
    LW_VBIOS_INFO_STATUS_NO_PUBLIC_KEY                         = 0x0f, 
    LW_VBIOS_INFO_STATUS_POINTER_PAST_SELWRITY_BLK             = 0x10, 
    LW_VBIOS_INFO_STATUS_ILWALID_HASH_HEADER_VERSION           = 0x11, 
    LW_VBIOS_INFO_STATUS_ERR_HASH_HEADER_FLAG_SET              = 0x12, 
    LW_VBIOS_INFO_STATUS_ILWALID_SIGNATURE_HEADER_VER          = 0x13, 
    LW_VBIOS_INFO_STATUS_SIG_UNKNOWN_DIGEST_ALGO               = 0x14, 
    LW_VBIOS_INFO_STATUS_SIG_UNKNOWN_FORMAT                    = 0x15, 
    LW_VBIOS_INFO_STATUS_SIG_ILWALID_SIZE                      = 0x16, 
    LW_VBIOS_INFO_STATUS_SIG_VERIFICATION_FAILURE              = 0x17, 
    LW_VBIOS_INFO_STATUS_PRESERV_TABLE_HASH_NOT_STARTED        = 0x18, 
    LW_VBIOS_INFO_STATUS_NO_EXPANSION_ROM                      = 0x19, 
    LW_VBIOS_INFO_STATUS_UNKNOWN_HASH_TYPE                     = 0x1a, 
    LW_VBIOS_INFO_STATUS_POINTER_PAST_HASH_BLK                 = 0x1b,
    LW_VBIOS_INFO_STATUS_CERT_VALIDITY_PERIOD_NOT_FOUND        = 0x1c,
    LW_VBIOS_INFO_STATUS_CERT_OEM_NAME_NOT_FOUND               = 0x1d,
    LW_VBIOS_INFO_STATUS_CERT_CHAIN_OF_TRUST_FAILURE           = 0x1e,
    LW_VBIOS_INFO_STATUS_NO_BIT_HEADER                         = 0x1f,
    LW_VBIOS_INFO_STATUS_NO_VBIOS_FOUND                        = 0x20,
    LW_VBIOS_INFO_STATUS_ILWALID_PARAMS                        = 0x21,
    LW_VBIOS_INFO_STATUS_NOT_SILICON_OR_EMULATION              = 0x22,
    LW_VBIOS_INFO_STATUS_LW_CONFIG_PCI_LW_20_READ_ERROR        = 0x23,
    LW_VBIOS_INFO_STATUS_ILWALID_PCI_ROM_SIG                   = 0x24,
    LW_VBIOS_INFO_STATUS_ILWALID_PCI_DATA_SIG                  = 0x25,
    LW_VBIOS_INFO_STATUS_ILWALID_PCI_HEADER                    = 0x26,
    LW_VBIOS_INFO_STATUS_ILWALID_CHECKSUM                      = 0x27,
    LW_VBIOS_INFO_STATUS_NO_NBSI_BLOCK                         = 0x28,
    LW_VBIOS_INFO_STATUS_CANNOT_MAP_TO_KERNEL_SPACE            = 0x29,
    LW_VBIOS_INFO_STATUS_IMAGE_EXCEEDS_PCIR_SIZE               = 0x2a,
    LW_VBIOS_INFO_STATUS_PCIR_VENDOR_ID_MISMATCH               = 0x2b,
    LW_VBIOS_INFO_STATUS_PCIR_LEN_EXCEEDS_IMAGE                = 0x2c,
    LW_VBIOS_INFO_STATUS_IMAGE_SIZE_OUT_OF_BOUNDS              = 0x2d,
    LW_VBIOS_INFO_STATUS_REGISTRY_NOT_FOUND                    = 0x2e,
    LW_VBIOS_INFO_STATUS_VOLATILE_REGISTRY_NOT_FOUND           = 0x2f,
    LW_VBIOS_INFO_STATUS_GPUMGR_OBJECT_NOT_FOUND               = 0x30,
    LW_VBIOS_INFO_STATUS_GPUMGR_BUFFER_TOO_SMALL               = 0x31,
    LW_VBIOS_INFO_STATUS_INSTANCE_NOT_FOUND                    = 0x32,
    LW_VBIOS_INFO_STATUS_IMAGE_VERIFICATION_FAILURE            = 0x33,
    LW_VBIOS_INFO_STATUS_UNSET                                 = 0x34    
} LW_VBIOS_INFO_STATUS;

typedef struct
{
    LwU32           version;            //!< Structure version
    LwU8            vbiosType;          //!< Vbios type - LW_VBIOS_SELWRITY_INFO_TYPE
    LwU8            status;             //!< Vbios status - LW2080_CTRL_BIOS_INFO_SELWRITY_STATUS
    LwU8            expirationDay;      //!< Vbios expiration day
    LwU8            expirationMonth;    //!< Vbios expiration month
    LwU16           expirationYear;     //!< Vbios expiration year
    LwU8            bShowInCpl;         //!< Show expiration date in CPL - Deprecated, always 0
    LwU8            bShowInOverlay;     //!< Show expiration date in Overlay - Deprecated, always 0
} LW_VBIOS_SELWRITY_INFO_V1;

typedef struct
{
    LwU32           version;            //!< Structure version
    LwU8            vbiosType;          //!< Vbios type - LW_VBIOS_SELWRITY_INFO_TYPE
    LwU8            status;             //!< Vbios status - LW2080_CTRL_BIOS_INFO_SELWRITY_STATUS
    LwU8            expirationDay;      //!< Vbios expiration day
    LwU8            expirationMonth;    //!< Vbios expiration month
    LwU16           expirationYear;     //!< Vbios expiration year
    LwU8            bShowInCpl;         //!< Show expiration date in CPL - Deprecated, always 0
    LwU8            bShowInOverlay;     //!< Show expiration date in Overlay - Deprecated, always 0
    LwU8            creationDay;        //!< Vbios creation day
    LwU8            creationMonth;      //!< Vbios creation month
    LwU16           creationYear;       //!< Vbios creation year
    LwAPI_String    OEMName;            //!< OEM name
} LW_VBIOS_SELWRITY_INFO_V2;

typedef struct
{
    LwU32           version;            //!< Structure version
    LwU8            vbiosType;          //!< Vbios type - LW_VBIOS_SELWRITY_INFO_TYPE
    LwU8            status;             //!< Vbios status - LW2080_CTRL_BIOS_INFO_SELWRITY_STATUS
    LwU8            expirationDay;      //!< Vbios expiration day
    LwU8            expirationMonth;    //!< Vbios expiration month
    LwU16           expirationYear;     //!< Vbios expiration year
    LwU8            creationDay;        //!< Vbios creation day
    LwU8            creationMonth;      //!< Vbios creation month
    LwU16           creationYear;       //!< Vbios creation year
    LwAPI_String    OEMName;            //!< OEM name
    LwU16           vbiosDevId;         //!< Device ID recorded in VBIOS
    LwU16           callwlatedDevId;    //!< Callwlated device ID, what is reported usually  
} LW_VBIOS_SELWRITY_INFO_V3;


typedef LW_VBIOS_SELWRITY_INFO_V3 LW_VBIOS_SELWRITY_INFO;

#define LW_VBIOS_SELWRITY_INFO_VER_1  MAKE_LWAPI_VERSION(LW_VBIOS_SELWRITY_INFO_V1,1)
#define LW_VBIOS_SELWRITY_INFO_VER_2  MAKE_LWAPI_VERSION(LW_VBIOS_SELWRITY_INFO_V2,2)
#define LW_VBIOS_SELWRITY_INFO_VER_3  MAKE_LWAPI_VERSION(LW_VBIOS_SELWRITY_INFO_V3,3)
#define LW_VBIOS_SELWRITY_INFO_VER    LW_VBIOS_SELWRITY_INFO_VER_3


LWAPI_INTERFACE LwAPI_GPU_GetVbiosSelwrityInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_VBIOS_SELWRITY_INFO *pVbiosSelwrityInfo);
//! @}

///////////////////////////////////////////////////////////////////////////////
//! \fn LwAPI_GPU_GetPostTime(LwPhysicalGpuHandle hPhysicalGpu, LW_VBIOS_POST_DATA *pVbiosPostData)
//! \code
//! FUNCTION NAME: LwAPI_GPU_GetPostTime
//!
//!   DESCRIPTION: Return the vbios post time in msec, for secondary gpu it will
//!                return the time spent in devinit exelwtion.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! TCC_SUPPORTED
//!
//! RETURN STATUS: LWAPI_API_NOT_INITIALIZED: lwapi not initialized
//!                 LWAPI_NO_IMPLEMENTATION: OS not supported
//!                 LWAPI_ILWALID_ARGUMENT: pVbiosPostData is NULL
//!                 LWAPI_INCOMPATIBLE_STRUCT_VERSION: version mismatch
//!                 LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!                 LWAPI_NOT_SUPPORTED: vbios doesn't contain POST flag
//!                 LWAPI_ERROR: Either KDA buffer is not present or some unknown error oclwred
//!                 LWAPI_OK: pVbiosPostData->vbiosPostTime contains valid post time value
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! @{
typedef struct
{
    LwU32   version;        //!< structure version
    LwU64   vbiosPostTime;  //!< contains vbios post time
} LW_VBIOS_POST_DATA_V1;

typedef LW_VBIOS_POST_DATA_V1 LW_VBIOS_POST_DATA;
#define LW_VBIOS_POST_DATA_VER1  MAKE_LWAPI_VERSION(LW_VBIOS_POST_DATA_V1,1)
#define LW_VBIOS_POST_DATA_VER    LW_VBIOS_POST_DATA_VER1

LWAPI_INTERFACE LwAPI_GPU_GetPostTime(LwPhysicalGpuHandle hPhysicalGpu, LW_VBIOS_POST_DATA *pVbiosPostData);

//! @}

///////////////////////////////////////////////////////////////////////////////
//! \fn LwAPI_DIAG_GetRcErrorData(LwPhysicalGpuHandle hPhysicalGpu, LW_RC_ERROR_DATA *pRcErrorData)
//!
//! FUNCTION NAME: LwAPI_DIAG_GetRcErrorData
//!
//!   DESCRIPTION: This API either returns the RC error data or resets the error history
//!                depending on the request type.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_ILWALID_USER_PRIVILEGE       - The caller does not have administrative privileges
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! @{

typedef struct
{
    LwU32   version;        //!< structure version
    LwU32   resetRcData :1; //!< [IN] Flag to reset the RC data
    LwU32   reserved :31;
    LwU32   rcErrorCount;   //!< [OUT] Contains the RC count
} LW_RC_ERROR_DATA_V1;

typedef LW_RC_ERROR_DATA_V1             LW_RC_ERROR_DATA;
#define LW_RC_ERROR_DATA_VER1           MAKE_LWAPI_VERSION(LW_RC_ERROR_DATA_V1, 1)
#define LW_RC_ERROR_DATA_VER            LW_RC_ERROR_DATA_VER1

LWAPI_INTERFACE LwAPI_DIAG_GetRcErrorData(LwPhysicalGpuHandle hPhysicalGpu, LW_RC_ERROR_DATA *pRcErrorData);

//! @}



///////////////////////////////////////////////////////////////////////////////
// 
// FUNCTION NAME: LwAPI_GPU_GetMXMBlock
//
//! \fn LwAPI_GPU_GetMXMBlock(LwPhysicalGpuHandle hPhysicalGpu, LW_MXM_BLOCK *pMXMBlock)
//! This function returns the MXM information block.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \retval   LWAPI_ILWALID_ARGUMENT              hPhysicalGpu or pMXMBlock is NULL.
//! \retval   LWAPI_OK                           *pMXMBlock is now set.
//! \retval   LWAPI_INCOMPATIBLE_STRUCT_VERSION   LW_MXM_BLOCK version not compatible with driver.
//! \retval   LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//! \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup gpu
//! Used in LW_MXM_BLOCK
#define LW_MXM_BLOCK_SIZE (64*1024)


//! \ingroup gpu
//! Used in LwAPI_GPU_GetMXMBlock()
typedef struct
{
    LwU32   version;        //!< Structure version
    LwU32   bufferSize;
    LwU8    buffer[LW_MXM_BLOCK_SIZE];
} LW_MXM_BLOCK;

//! \ingroup gpu
#define LW_MXM_BLOCK_VER MAKE_LWAPI_VERSION(LW_MXM_BLOCK,1)



//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_GetMXMBlock(LwPhysicalGpuHandle hPhysicalGpu, LW_MXM_BLOCK *pMXMBlock);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetVbiosVersionString
//
//!  This function returns the full video BIOS version string in the form of xx.xx.xx.xx.yy where
//!  - xx numbers come from LwAPI_GPU_GetVbiosRevision() and 
//!  - yy comes from LwAPI_GPU_GetVbiosOEMRevision().
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 90
//!
//! \retval   LWAPI_ILWALID_ARGUMENT              hPhysicalGpu is NULL.
//! \retval   LWAPI_OK                            szBiosRevision contains version string.
//! \retval   LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//! \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetVbiosVersionString(LwPhysicalGpuHandle hPhysicalGpu,LwAPI_ShortString szBiosRevision);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetAGPAperture
//
//!  This function returns the AGP aperture in megabytes.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 90
//!
//! \retval   LWAPI_ILWALID_ARGUMENT              pSize is NULL.
//! \retval   LWAPI_OK                            Call successful.
//! \retval   LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//! \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetAGPAperture(LwPhysicalGpuHandle hPhysicalGpu,LwU32 *pSize);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetLwrrentAGPRate
//
//!  This function returns the current AGP Rate (0 = AGP not present, 1 = 1x, 2 = 2x, etc.).
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 90
//!
//! \retval   LWAPI_ILWALID_ARGUMENT              pRate is NULL.
//! \retval   LWAPI_OK                            Call successful.
//! \retval   LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//! \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetLwrrentAGPRate(LwPhysicalGpuHandle hPhysicalGpu,LwU32 *pRate);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetLwrrentPCIEDownstreamWidth
//
//!  This function returns the number of PCIE lanes being used for the PCIE interface 
//!  downstream from the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 90
//!
//! \retval  LWAPI_ILWALID_ARGUMENT              pWidth is NULL.
//! \retval  LWAPI_OK                            Call successful.
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetLwrrentPCIEDownstreamWidth(LwPhysicalGpuHandle hPhysicalGpu,LwU32 *pWidth);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_SetLwrrentPCIEWidth
//
//!   DESCRIPTION: This function sets the number of PCIE lanes being used for the PCIE interface.
//!                The corresponding "Get" for this function is:
//!                pInfo->gpu.lwrrentWidth from LwAPI GPU_GetPCIEInfo()
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_ILWALID_USER_PRIVILEGE       - The caller does not have administrative privileges
//! \retval ::LWAPI_ILWALID_ARGUMENT              - newWidth is not a valid PCIE width value for the system.
//!
//!  \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetLwrrentPCIEWidth(LwPhysicalGpuHandle hPhysicalGpu,LwU32 newWidth);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_SetLwrrentPCIESpeed
//
//!   DESCRIPTION: Sets the PCIE speed in mega-bits per second for the PCIE interface.
//!                Typical PCIE speeds are 2500 Mbps or 5000 Mbps.
//!                The exact corresponding Get for this function is:
//!                    pInfo->gpu.lwrrentSpeed from LwAPI GPU_GetPCIEInfo()
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 173
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT             - newSpeed is not a valid PCIE speed value for the system.
//! \retval ::LWAPI_ILWALID_USER_PRIVILEGE       - the caller does not have administrative privileges.
//!
//!   \ingroup gpu 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetLwrrentPCIESpeed(LwPhysicalGpuHandle hPhysicalGpu, LwU32 newSpeed);




//! \ingroup gpu
//! Used in LW_PCIE_LINK_INFO_V1 and LW_PCIE_LINK_INFO_V1.  
typedef enum
{
    LW_PCIE_ASPM_STATE_DISABLED = 0,
    LW_PCIE_ASPM_STATE_L0S      = 0x1,
    LW_PCIE_ASPM_STATE_L1       = 0x2,
    LW_PCIE_ASPM_STATE_L0S_L1   = 0x3,
} LW_PCIE_ASPM_STATE;


//! \ingroup gpu
//! Used in LW_PCIE_LINK_INFO_V2.
typedef enum
{
    LW_PCIE_GENERATION_GEN_1 = 1,
    LW_PCIE_GENERATION_GEN_2 = 2,
    LW_PCIE_GENERATION_GEN_3 = 3,
    LW_PCIE_GENERATION_GEN_NONE = -1,
} LW_PCIE_GENERATION;


//! \ingroup gpu
//! Used in LW_PCIE_INFO_V1
typedef struct
{
    LwU32 maxSpeed;               //!< In Mega-bits per second
    LwU32 maxWidth;               //!< In lanes
    LwU32 supportedStates;        //!< See LW_PCIE_ASPM_STATE
    LwU32 lwrrentSpeed;           //!< In Mega-bits per second
    LwU32 lwrrentWidth;           //!< In lanes
    LwU32 lwrrentState;           //!< See LW_PCIE_ASPM_STATE
} LW_PCIE_LINK_INFO_V1;
  
//! \ingroup gpu
//! Used in LwAPI_GPU_GetPCIEInfo().
typedef struct 
{
    LwU32 version;

    LW_PCIE_LINK_INFO_V1 root;
    LW_PCIE_LINK_INFO_V1 gpu;
    LW_PCIE_LINK_INFO_V1 upstream;
    LW_PCIE_LINK_INFO_V1 downstream;
    
} LW_PCIE_INFO_V1;   


//! \ingroup gpu
//! Used in LW_PCIE_INFO_V2
typedef struct
{
    LwU32 maxSpeed;                         //!< In Mega-bits per second
    LW_PCIE_GENERATION maxGeneration;       //!< Implemented PCIe Generation
    LwU32 maxWidth;                         //!< Maximum width, in lanes
    LW_PCIE_ASPM_STATE supportedStates;     //!< See ::LW_PCIE_ASPM_STATE
    LwU32 lwrrentSpeed;                     //!< In Mega-bits per second
    LW_PCIE_GENERATION lwrrentGeneration;   //!< Lwrrently negotiated PCIe Generation
    LwU32 lwrrentWidth;                     //!< Current width, in lanes
    LW_PCIE_ASPM_STATE lwrrentState;        //!< See ::LW_PCIE_ASPM_STATE
} LW_PCIE_LINK_INFO_V2;


//! \ingroup gpu
//! Used in LwAPI_GPU_GetPCIEInfo().
typedef struct
{
    LwU32 version;

    LW_PCIE_LINK_INFO_V2 root;
    LW_PCIE_LINK_INFO_V2 gpu;
    LW_PCIE_LINK_INFO_V2 upstream;  //!< Same as board
    LW_PCIE_LINK_INFO_V2 downstream;
    LW_PCIE_LINK_INFO_V2 board;

} LW_PCIE_INFO_V2;

//! \ingroup gpu
typedef LW_PCIE_LINK_INFO_V2 LW_PCIE_LINK_INFO;

//! \ingroup gpu
typedef LW_PCIE_INFO_V2 LW_PCIE_INFO;

//! \ingroup gpu
#define LW_PCIE_INFO_VER_1  MAKE_LWAPI_VERSION(LW_PCIE_INFO_V1,1)

//! \ingroup gpu
#define LW_PCIE_INFO_VER_2  MAKE_LWAPI_VERSION(LW_PCIE_INFO_V2,2)

//! \ingroup gpu
#define LW_PCIE_INFO_VER    LW_PCIE_INFO_VER_2

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetPCIEInfo
//
//!  This function returns the PCIE bus capabilities and current PCIE state both upstream
//!  and downstream from the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 105
//!
//! \retval  LWAPI_ILWALID_ARGUMENT              pInfo is NULL.
//! \retval  LWAPI_OK                            Call successful.
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPCIEInfo(LwPhysicalGpuHandle hPhysicalGpu,LW_PCIE_INFO *pInfo);




//! \ingroup gpu
typedef enum
{
    LW_PCIE_GPU_CYA_ASPM_DISABLED = 0x0,
    LW_PCIE_GPU_CYA_ASPM_L0S      = 0x1,
    LW_PCIE_GPU_CYA_ASPM_L1       = 0x2,
    LW_PCIE_GPU_CYA_ASPM_L0S_L1   = 0x3
} LW_PCIE_GPU_CYA_ASPM;

//! \ingroup gpu
typedef enum
{
    LW_PCIE_GPU_CYA_ASPM_INFO_VALID_NO = 0x0,
    LW_PCIE_GPU_CYA_ASPM_INFO_VALID_YES = 0x1,
}LW_PCIE_GPU_CYA_ASPM_INFO_VALID;

//! \ingroup gpu
typedef struct
{
    LwU32 version;                        //!< structure version
    LwU32 bIsCyaAspmInfoValid;            //!< boolean specifies whether info is valid or not
    LW_PCIE_GPU_CYA_ASPM cyaAspmState;    //!< see ::LW_PCIE_GPU_CYA_ASPM
} LW_PCIE_GPU_CYA_ASPM_INFO;

//! \ingroup gpu
#define LW_PCIE_GPU_CYA_ASPM_INFO_VER  MAKE_LWAPI_VERSION(LW_PCIE_GPU_CYA_ASPM_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetCyaAspmInfo
//! \code
//!   DESCRIPTION: Returns info about whether GPU ASPM CYA L0s & L1 is enabled or not
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: LWAPI_API_NOT_INTIALIZED: lwapi not initialized
//!                LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!                LWAPI_ILWALID_ARGUMENT: pInfo is NULL
//!                LWAPI_OK: call successful
//!                LWAPI_ERROR: If there is some garbage value is read
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetCyaAspmInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_PCIE_GPU_CYA_ASPM_INFO *pInfo);


//! \ingroup gpu
//! Used in \ref LW_PCIE_LINK_ERROR_INFO.
typedef enum
{
    LW_PCIE_LINK_ERROR_CORR_ERROR       = 0x00000001,
    LW_PCIE_LINK_ERROR_NON_FATAL_ERROR  = 0x00000002,
    LW_PCIE_LINK_ERROR_FATAL_ERROR      = 0x00000004,
    LW_PCIE_LINK_ERROR_UNSUPP_REQUEST   = 0x00000008,
} LW_PCIE_LINK_ERROR;


//! \ingroup gpu
typedef enum
{
    LW_PCIE_LINK_ERROR_FLAG_MASK_KNOWN_CORR_ERROR_ON_RECOVERY = 0x00000001,
} LW_PCIE_LINK_ERROR_FLAG;




//! \ingroup gpu
//! Used in LwAPI_GPU_ClearPCIELinkErrorInfo().
typedef struct 
{
    LwU32 version;

    LwU32 root;     //!< Returns PCIE link error on ROOT (bitfield of LW_PCIE_LINK_ERROR)
    LwU32 gpu;      //!< Returns PCIE link error on GPU  (bitfield of LW_PCIE_LINK_ERROR)

} LW_PCIE_LINK_ERROR_INFO_V1;


//! \ingroup gpu
//! Used in LwAPI_GPU_ClearPCIELinkErrorInfo().
typedef struct
{
    LwU32 version;

    LwU32 root;     //!< Returns PCIE link error on ROOT (bitfield of LW_PCIE_LINK_ERROR)
    LwU32 gpu;      //!< Returns PCIE link error on GPU  (bitfield of LW_PCIE_LINK_ERROR)

    LwU32 flags;    //!< Special options  (bitfield of LW_PCIE_LINK_ERROR_FLAG)

} LW_PCIE_LINK_ERROR_INFO_V2;

//! \ingroup gpu
typedef LW_PCIE_LINK_ERROR_INFO_V2     LW_PCIE_LINK_ERROR_INFO;

//! \ingroup gpu
//! Macro for constructing the version field of LW_PCIE_LINK_ERROR_INFO_V1
#define LW_PCIE_LINK_ERROR_INFO_VER_1  MAKE_LWAPI_VERSION(LW_PCIE_LINK_ERROR_INFO_V1,1)

//! \ingroup gpu
//! Macro for constructing the version field of LW_PCIE_LINK_ERROR_INFO_V2
#define LW_PCIE_LINK_ERROR_INFO_VER_2  MAKE_LWAPI_VERSION(LW_PCIE_LINK_ERROR_INFO_V2,2)

//! \ingroup gpu
#define LW_PCIE_LINK_ERROR_INFO_VER    LW_PCIE_LINK_ERROR_INFO_VER_2
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_ClearPCIELinkErrorInfo
//
//! \fn LwAPI_GPU_ClearPCIELinkErrorInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_PCIE_LINK_ERROR_INFO *pInfo)
//! DESCRIPTION: This function returns and clears PCIE link errors on both the GPU and the root port.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 165
//!
//! \retval  LWAPI_ILWALID_ARGUMENT              pInfo is NULL.
//! \retval  LWAPI_OK                            Call successful.
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ClearPCIELinkErrorInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_PCIE_LINK_ERROR_INFO *pInfo);


//! \ingroup gpu
//! Advanced Error Reporting bitfields (see LwAPI_GPU_ClearPCIELinkAERInfo())
typedef enum
{
    LW_PCIE_LINK_AER_UNCORR_TRAINING_ERR      = 0x00000001,
    LW_PCIE_LINK_AER_UNCORR_DLINK_PROTO_ERR   = 0x00000002,
    LW_PCIE_LINK_AER_UNCORR_POISONED_TLP      = 0x00000004,
    LW_PCIE_LINK_AER_UNCORR_FC_PROTO_ERR      = 0x00000008,
    LW_PCIE_LINK_AER_UNCORR_CPL_TIMEOUT       = 0x00000010,
    LW_PCIE_LINK_AER_UNCORR_CPL_ABORT         = 0x00000020,
    LW_PCIE_LINK_AER_UNCORR_UNEXP_CPL         = 0x00000040,
    LW_PCIE_LINK_AER_UNCORR_RCVR_OVERFLOW     = 0x00000080,
    LW_PCIE_LINK_AER_UNCORR_MALFORMED_TLP     = 0x00000100,
    LW_PCIE_LINK_AER_UNCORR_ECRC_ERROR        = 0x00000200,
    LW_PCIE_LINK_AER_UNCORR_UNSUPPORTED_REQ   = 0x00000400,
    LW_PCIE_LINK_AER_CORR_RCV_ERR             = 0x00010000,
    LW_PCIE_LINK_AER_CORR_BAD_TLP             = 0x00020000,
    LW_PCIE_LINK_AER_CORR_BAD_DLLP            = 0x00040000,
    LW_PCIE_LINK_AER_CORR_RPLY_ROLLOVER       = 0x00080000,
    LW_PCIE_LINK_AER_CORR_RPLY_TIMEOUT        = 0x00100000,
    LW_PCIE_LINK_AER_CORR_ADVISORY_NONFATAL   = 0x00200000,
} LW_PCIE_LINK_AER;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_ClearPCIELinkAERInfo
//
//!   DESCRIPTION: This function returns and clears PCIE link errors using Advanced Error Reporting (AER).
//!                pInfo is a ::LW_PCIE_LINK_AER bitfield.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 177
//!
//!   \retval   LWAPI_ILWALID_ARGUMENT              pInfo is NULL
//!   \retval   LWAPI_OK                            Call successful
//!   \retval   LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//!   \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//!
//!   \ingroup  gpu 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ClearPCIELinkAERInfo(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pInfo);

//! \ingroup gpu
//! Frame buffer calibration lock failure counts - used in LwAPI_GPU_GetFrameBufferCalibrationLockFailures().  
typedef struct
{
    LwU32 version;

    LwU32 driveStrengthRiseCount;             //!< Failure count for drive strength rising
    LwU32 driveStrengthFallCount;             //!< Failure count for drive strength falling
    LwU32 driveStrengthTermCount;             //!< Failure count for drive strength termination
    LwU32 slewStrengthRiseCount;              //!< Failure count for slew strength rising
    LwU32 slewStrengthFallCount;              //!< Failure count for slew strength falling
} LW_GPU_FRAMEBUFFER_CALIBRATION_LOCK_FAILURES_INFO;


//! \ingroup gpu
//! Used in LW_GPU_FRAMEBUFFER_CALIBRATION_LOCK_FAILURES_INFO.
#define LW_GPU_FRAMEBUFFER_CALIBRATION_LOCK_FAILURES_INFO_VER  MAKE_LWAPI_VERSION(LW_GPU_FRAMEBUFFER_CALIBRATION_LOCK_FAILURES_INFO,1)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetFrameBufferCalibrationLockFailures
//
//!   DESCRIPTION: This function returns the number of various types of frame buffer calibration lock failures.
//!
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 177
//!
//!   \retval   LWAPI_ILWALID_ARGUMENT              pParams is NULL
//!   \retval   LWAPI_OK                            Call successful
//!   \retval   LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//!   \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//!   \retval   LWAPI_NOT_SUPPORTED                 Frame buffer calibration lock failure detection is not supported on this GPU.
//!   \retval   LWAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the INFO struct is not supported
//!
//!   \ingroup  gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetFrameBufferCalibrationLockFailures(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_FRAMEBUFFER_CALIBRATION_LOCK_FAILURES_INFO *pParams);


//! \ingroup gpu
//! Used in LwAPI_GPU_SetDisplayUnderflowMode().
typedef enum _LW_DISPLAY_UNDERFLOW_MODE
{
    LW_DISPLAY_UNDERFLOW_MODE_DISABLED,  //!< Underflow checking is disabled.
    LW_DISPLAY_UNDERFLOW_MODE_REPEAT,    //!< Checking is enabled, but periodically the underflow is cleared automatically.
    LW_DISPLAY_UNDERFLOW_MODE_STICKY,    //!< Underflow bit is sticky until explicitly cleared. 
} LW_DISPLAY_UNDERFLOW_MODE;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_SetDisplayUnderflowMode
//
//! DESCRIPTION:    This function sets the current HW handling on display underflow for testing and debugging.
//!
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 177
//!
//! \retval ::LWAPI_ILWALID_HANDLE
//! \retval ::LWAPI_ILWALID_ARGUMENT
//! \retval ::LWAPI_OK
//! \retval ::LWAPI_NOT_SUPPORTED
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetDisplayUnderflowMode(LwDisplayHandle hLwDisplay, LW_DISPLAY_UNDERFLOW_MODE mode);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetDisplayUnderflowStatus
//
//! DESCRIPTION:    This function returns the underflow status bit, which is set when the GPU was unable to keep up with display output. 
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 177
//!
//! \param [in]    hLwDisplay           LWPU display selection
//! \param [in]    clearUnderflow       If set, the underflow status bit will be cleared after the result is returned.
//! \param [out]   pUnderflowDetected   Display underflow status
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetDisplayUnderflowStatus(LwDisplayHandle hLwDisplay, LwU32 clearUnderflow, LwU32 *pUnderflowDetected);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetPhysicalFrameBufferSize
//
//!   This function returns the physical size of framebuffer in KB.  This does NOT include any
//!   system RAM that may be dedicated for use by the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 90
//!
//! \retval  LWAPI_ILWALID_ARGUMENT              pSize is NULL
//! \retval  LWAPI_OK                            Call successful
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPhysicalFrameBufferSize(LwPhysicalGpuHandle hPhysicalGpu,LwU32 *pSize);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetVirtualFrameBufferSize
//
//!  This function returns the virtual size of framebuffer in KB.  This includes the physical RAM plus any
//!  system RAM that has been dedicated for use by the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 90
//!
//! \retval  LWAPI_ILWALID_ARGUMENT              pSize is NULL.
//! \retval  LWAPI_OK                            Call successful.
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetVirtualFrameBufferSize(LwPhysicalGpuHandle hPhysicalGpu,LwU32 *pSize);


 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetBarInfo
//
//! \fn LwAPI_GPU_GetBarInfo(LwPhysicalGpuHandle hPhysicalGpu,LW_GPU_BAR_INFO *pInfo)
//!  DESCRIPTION: This function retrieves information on all GPU base-address-registers.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 105
//!
//! \retval  LWAPI_ILWALID_ARGUMENT              pInfo is NULL.
//! \retval  LWAPI_OK                           *pInfo is set (count gives the # of BARs populated in the array).
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
#define LW_GPU_MAX_BAR_COUNT 8

//! Used in LwAPI_GPU_GetBarInfo().
//! \ingroup gpu
typedef struct
{
    LwU32   version;        //!< Structure version
    LwU8    count;
    struct
    {
        LwU32 flags;        // For future use (no flags yet defined)
        LwU32 barSize;
        LwU64 barOffset;
    } barInfo[LW_GPU_MAX_BAR_COUNT];
} LW_GPU_BAR_INFO;

//! \ingroup gpu
#define LW_GPU_BAR_INFO_VER         MAKE_LWAPI_VERSION(LW_GPU_BAR_INFO,1)


//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_GetBarInfo(LwPhysicalGpuHandle hPhysicalGpu,LW_GPU_BAR_INFO *pInfo);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetQuadroStatus
//
//!  This function retrieves the Lwdqro status for the GPU (1 if Lwdqro, 0 if VdChip)
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 80
//!
//! \return  LWAPI_ERROR or LWAPI_OK
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetQuadroStatus(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pStatus); 


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetPSFloorSweepStatus
//                LwAPI_GPU_GetVSFloorSweepStatus                  
//
//@{
//!  This function retrieves floorsweeping information for the vertex and pixel
//!  shader units.  Bit field for each, unified architectures will
//!  return the same value for both VS and PS. 
//!
//!  <b> NEVER TO BE EXPOSED!!!!!</b>
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 80
//!
//! \return  LWAPI_ERROR or LWAPI_OK
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_GetPSFloorSweepStatus(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pReturn);

//! \addtogroup gpu
//! SUPPORTED OS:  Windows XP and higher
//!
LWAPI_INTERFACE LwAPI_GPU_GetVSFloorSweepStatus(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pReturn);
//@}


 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetSerialNumber
//
//!  This function retrieves a unique serial number from the specified GPU
//!  The format may vary from GPU to GPU, but is within 64-bits
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 95
//!
//! \return  LWAPI_ERROR or LWAPI_OK
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetSerialNumber(LwPhysicalGpuHandle hPhysicalGpu, LwU64 *pSerialNum);

 


//! \ingroup gpu
typedef struct _LW_BOARD_INFO
{
    LwU32 version;                   //!< structure version
    LwU8 BoardNum[16];               //!< Board Serial Number

}LW_BOARD_INFO_V1;

//! \ingroup gpu
typedef LW_BOARD_INFO_V1    LW_BOARD_INFO;
//! \ingroup gpu
#define LW_BOARD_INFO_VER1  MAKE_LWAPI_VERSION(LW_BOARD_INFO_V1,1)
//! \ingroup gpu
#define LW_BOARD_INFO_VER   LW_BOARD_INFO_VER1

//! SUPPORTED OS:  Windows XP and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetBoardInfo
//
//!   DESCRIPTION: This API Retrieves the Board information (a unique GPU Board Serial Number) stored in the InfoROM.
//!
//! \param [in]      hPhysicalGpu       Physical GPU Handle.
//! \param [in,out]  LW_BOARD_INFO      Board Information.
//!
//! TCC_SUPPORTED
//!
//! \retval ::LWAPI_OK                     completed request
//! \retval ::LWAPI_ERROR                  miscellaneous error oclwrred
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  handle passed is not a physical GPU handle
//! \retval ::LWAPI_API_NOT_INTIALIZED            LWAPI not initialized
//! \retval ::LWAPI_ILWALID_POINTER               pBoardInfo is NULL
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION   the version of the INFO struct is not supported
//! 
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetBoardInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_BOARD_INFO *pBoardInfo);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_ManufacturingInfo
//
//! \fn LwAPI_GPU_ManufacturingInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_MANUFACTURING_INFO *info)
//! \code
//!   DESCRIPTION: Retrieves a unique serial number from the specified GPU
//!                The format may vary from GPU to GPU, but is within 128-bits
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! RETURN STATUS: LWAPI_ERROR or LWAPI_OK
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
typedef struct 
{
    LwU32 version;
    LwU64 ecid[2];
}LW_MANUFACTURING_INFO;

//! \ingroup gpu
//! Macro for constructing the version field of ::LW_MANUFACTURING_INFO
#define LW_MANUFACTURING_INFO_VER  MAKE_LWAPI_VERSION(LW_MANUFACTURING_INFO,1)

//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_ManufacturingInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_MANUFACTURING_INFO *info);





//! \ingroup gpu
//! Used in LwAPI_GPU_GetRamType()
typedef enum
{
    LW_GPU_RAM_TYPE_UNKNOWN = 0,
    LW_GPU_RAM_TYPE_SDRAM   = 1,
    LW_GPU_RAM_TYPE_DDR1    = 2,
    LW_GPU_RAM_TYPE_DDR2    = 3,
    LW_GPU_RAM_TYPE_GDDR2   = 4,
    LW_GPU_RAM_TYPE_GDDR3   = 5,
    LW_GPU_RAM_TYPE_GDDR4   = 6,
    LW_GPU_RAM_TYPE_DDR3    = 7,
    LW_GPU_RAM_TYPE_GDDR5   = 8,
    LW_GPU_RAM_TYPE_LPDDR2  = 9
} LW_GPU_RAM_TYPE;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetRamType
//
//! This function retrieves the type of VRAM associated with this GPU
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 95
//!
//! \return LWAPI_ERROR or LWAPI_OK
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetRamType(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_RAM_TYPE *pRamType);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetRamVendorID
//
//! \fn LwAPI_GPU_GetRamVendorID(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_RAM_VENDOR_ID *pVendorID)
//! \code
//!   DESCRIPTION: Retrieves an ID for the Vendor of VRAM associated with this GPU.
//!                The value comes from the Memory Information Table in the VBIOS
//!                See enum LW_GPU_RAM_VENDOR_ID.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! RETURN STATUS: 
//!    LWAPI_OK: all ok, value returned (may be LW_GPU_RAM_VENDOR_ID_UNKNOWN)
//!    LWAPI_API_NOT_INTIALIZED: LWAPI not initialized
//!    LWAPI_ERROR: miscellaneous error oclwrred
//!    LWAPI_ILWALID_ARGUMENT: pVendorID is NULL
//!    LWAPI_HANDLE_ILWALIDATED: handle passed has been ilwalidated (see user guide)
//!    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: handle passed is not a physical GPU handle
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu 
typedef enum
{
    LW_GPU_RAM_VENDOR_ID_UNKNOWN     = 0,
    LW_GPU_RAM_VENDOR_ID_SAMSUNG     = 1,
    LW_GPU_RAM_VENDOR_ID_QIMONDA     = 2,
    LW_GPU_RAM_VENDOR_ID_ELPIDA      = 3,
    LW_GPU_RAM_VENDOR_ID_ETRON       = 4,
    LW_GPU_RAM_VENDOR_ID_NANYA       = 5,
    LW_GPU_RAM_VENDOR_ID_HYNIX       = 6,
    LW_GPU_RAM_VENDOR_ID_MOSEL       = 7,
    LW_GPU_RAM_VENDOR_ID_WINBOND     = 8,
    LW_GPU_RAM_VENDOR_ID_ESMT        = 9,
    LW_GPU_RAM_VENDOR_ID_MICRON      = 10
} LW_GPU_RAM_VENDOR_ID;

//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_GetRamVendorID(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_RAM_VENDOR_ID *pVendorID);




 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetRamConfigStrap
//
//! This function retrieves a 32-bit value that indicates (indirectly) the type of 
//! RAM configuration associated with the GPU.
//!  
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 95
//!              
//! \return LWAPI_ERROR or LWAPI_OK
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetRamConfigStrap(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pRamConfigStrap);


 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetRamBusWidth
//
//!  This function returns the width of the GPU's RAM memory bus.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 100                 
//!
//!  \return LWAPI_ERROR or LWAPI_OK
//!  \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetRamBusWidth(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pBusWidth);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetFBWidthAndLocation
//
//! \fn LwAPI_GPU_GetFBWidthAndLocation(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pBusWidth, LW_GPU_FB_LOCATION *pFBLocation)
//!   DESCRIPTION: This API returns the width and location of the GPU's RAM memory bus.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 185
//!
//! \return ::LWAPI_ERROR or ::LWAPI_OK
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup gpu
//! Used in LwAPI_GPU_GetFBWidthAndLocation().
typedef enum _LW_GPU_FB_LOCATION
{
    LW_GPU_FB_RAM_LOCATION_UNKNOWN       = 0,
    LW_GPU_FB_RAM_LOCATION_GPU_DEDICATED = 1,
    LW_GPU_FB_RAM_LOCATION_SYS_SHARED    = 2,
    LW_GPU_FB_RAM_LOCATION_SYS_DEDICATED = 3,
} LW_GPU_FB_LOCATION;

//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_GetFBWidthAndLocation(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pBusWidth, LW_GPU_FB_LOCATION *pFBLocation);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetRamBankCount
//
//!  This function returns the number of banks of RAM associated with the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 100                 
//!
//!  \return LWAPI_ERROR or LWAPI_OK
//!  \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetRamBankCount(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pBankCount);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetArchInfo
//
//! \fn LwAPI_GPU_GetArchInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_ARCH_INFO *pGpuArchInfo)
//!  This function retrieves the architecture, implementation and chip revision for the specified GPU .
//!
//!  <b>INTERNAL USE ONLY!</b>
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED       // This needs to be changed to Tag
//! \since Release: 85
//!
//! \return LWAPI_ERROR or LWAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! Used in LwAPI_GPU_GetArchInfo()
typedef struct 
{
    LwU32 version;

    LwU32 architecture;
    LwU32 implementation;
    LwU32 revision;
    
} LW_GPU_ARCH_INFO_V1;   

//! LW_GPU_ARCH_INFO() values to identify Architecture level for the GPU. 
typedef enum _LW_GPU_ARCHITECTURE_ID 
{ 

    LW_GPU_ARCHITECTURE_T2X   = 0xE0000020, 
    LW_GPU_ARCHITECTURE_T3X   = 0xE0000030, 
    LW_GPU_ARCHITECTURE_T4X   = 0xE0000040,
    LW_GPU_ARCHITECTURE_T12X  = 0xE0000040,
    LW_GPU_ARCHITECTURE_LW40  = 0x00000040, 
    LW_GPU_ARCHITECTURE_LW50  = 0x00000050, 
    LW_GPU_ARCHITECTURE_G78   = 0x00000060, 
    LW_GPU_ARCHITECTURE_G80   = 0x00000080, 
    LW_GPU_ARCHITECTURE_G90   = 0x00000090, 
    LW_GPU_ARCHITECTURE_GT200 = 0x000000A0, 
    LW_GPU_ARCHITECTURE_GF100 = 0x000000C0, 
    LW_GPU_ARCHITECTURE_GF110 = 0x000000D0, 
    LW_GPU_ARCHITECTURE_GK100 = 0x000000E0, 
    LW_GPU_ARCHITECTURE_GK110 = 0x000000F0, 
    LW_GPU_ARCHITECTURE_GK200 = 0x00000100, 
    LW_GPU_ARCHITECTURE_GM000 = 0x00000110, 

}LW_GPU_ARCHITECTURE_ID; 

//! LW_GPU_ARCH_INFO() values to identify GPU Architecture Implementation. 
typedef enum _LW_GPU_ARCH_IMPLEMENTATION_ID 
{

    LW_GPU_ARCH_IMPLEMENTATION_T20    = 0x00000000,

    LW_GPU_ARCH_IMPLEMENTATION_T30    = 0x00000000,
    LW_GPU_ARCH_IMPLEMENTATION_T35    = 0x00000005,

    LW_GPU_ARCH_IMPLEMENTATION_T40    = 0x00000000,
    LW_GPU_ARCH_IMPLEMENTATION_T124   = 0x00000000,

    LW_GPU_ARCH_IMPLEMENTATION_LW40   = 0x00000000,
    LW_GPU_ARCH_IMPLEMENTATION_LW41   = 0x00000001,
    LW_GPU_ARCH_IMPLEMENTATION_LW42   = 0x00000002,
    LW_GPU_ARCH_IMPLEMENTATION_LW43   = 0x00000003,
    LW_GPU_ARCH_IMPLEMENTATION_LW44   = 0x00000004,
    LW_GPU_ARCH_IMPLEMENTATION_LW44A  = 0x0000000A,
    LW_GPU_ARCH_IMPLEMENTATION_LW46   = 0x00000006,
    LW_GPU_ARCH_IMPLEMENTATION_LW47   = 0x00000007,
    LW_GPU_ARCH_IMPLEMENTATION_LW49   = 0x00000009,
    LW_GPU_ARCH_IMPLEMENTATION_LW4B   = 0x0000000B,
    LW_GPU_ARCH_IMPLEMENTATION_LW4C   = 0x0000000C,
    LW_GPU_ARCH_IMPLEMENTATION_LW4E   = 0x0000000E,

    LW_GPU_ARCH_IMPLEMENTATION_LW50   = 0x00000000,

    LW_GPU_ARCH_IMPLEMENTATION_LW63   = 0x00000003,
    LW_GPU_ARCH_IMPLEMENTATION_LW67   = 0x00000007,

    LW_GPU_ARCH_IMPLEMENTATION_G84    = 0x00000004,
    LW_GPU_ARCH_IMPLEMENTATION_G86    = 0x00000006,

    LW_GPU_ARCH_IMPLEMENTATION_G92    = 0x00000002,
    LW_GPU_ARCH_IMPLEMENTATION_G94    = 0x00000004,
    LW_GPU_ARCH_IMPLEMENTATION_G96    = 0x00000006,
    LW_GPU_ARCH_IMPLEMENTATION_G98    = 0x00000008,

    LW_GPU_ARCH_IMPLEMENTATION_GT200  = 0x00000000,
    LW_GPU_ARCH_IMPLEMENTATION_GT212  = 0x00000002,
    LW_GPU_ARCH_IMPLEMENTATION_GT214  = 0x00000004,
    LW_GPU_ARCH_IMPLEMENTATION_GT215  = 0x00000003,
    LW_GPU_ARCH_IMPLEMENTATION_GT216  = 0x00000005,
    LW_GPU_ARCH_IMPLEMENTATION_GT218  = 0x00000008,
    LW_GPU_ARCH_IMPLEMENTATION_MCP77  = 0x0000000A,
    LW_GPU_ARCH_IMPLEMENTATION_GT21C  = 0x0000000B,
    LW_GPU_ARCH_IMPLEMENTATION_MCP79  = 0x0000000C,
    LW_GPU_ARCH_IMPLEMENTATION_GT21A  = 0x0000000D,
    LW_GPU_ARCH_IMPLEMENTATION_MCP89  = 0x0000000F,

    LW_GPU_ARCH_IMPLEMENTATION_GF100  = 0x00000000,
    LW_GPU_ARCH_IMPLEMENTATION_GF100B = 0x00000008,
    LW_GPU_ARCH_IMPLEMENTATION_GF104  = 0x00000004,
    LW_GPU_ARCH_IMPLEMENTATION_GF104B = 0x0000000E,
    LW_GPU_ARCH_IMPLEMENTATION_GF106  = 0x00000003,
    LW_GPU_ARCH_IMPLEMENTATION_GF106B = 0x0000000F,
    LW_GPU_ARCH_IMPLEMENTATION_GF108  = 0x00000001,

    LW_GPU_ARCH_IMPLEMENTATION_GF110  = 0x00000000,
    LW_GPU_ARCH_IMPLEMENTATION_GF112  = 0x00000002,
    LW_GPU_ARCH_IMPLEMENTATION_GF116  = 0x00000006,
    LW_GPU_ARCH_IMPLEMENTATION_GF117  = 0x00000007,
    LW_GPU_ARCH_IMPLEMENTATION_GF118  = 0x00000008,
    LW_GPU_ARCH_IMPLEMENTATION_GF119  = 0x00000009,

    LW_GPU_ARCH_IMPLEMENTATION_GK100  = 0x00000000,
    LW_GPU_ARCH_IMPLEMENTATION_GK104  = 0x00000004,
    LW_GPU_ARCH_IMPLEMENTATION_GK106  = 0x00000006,
    LW_GPU_ARCH_IMPLEMENTATION_GK107  = 0x00000007,
    LW_GPU_ARCH_IMPLEMENTATION_GK20A  = 0x0000000A,
    LW_GPU_ARCH_IMPLEMENTATION_GK110  = 0x00000000,

    LW_GPU_ARCH_IMPLEMENTATION_GK208  = 0x00000008,

    LW_GPU_ARCH_IMPLEMENTATION_GM000  = 0x00000000,

}LW_GPU_ARCH_IMPLEMENTATION_ID;

typedef enum _LW_GPU_CHIP_REVISION
{
    LW_GPU_CHIP_REV_EMULATION_QT        = 0x00000000,   //!< QT chip
    LW_GPU_CHIP_REV_EMULATION_FPGA      = 0x00000001,   //!< FPGA implementation of the chipset
    LW_GPU_CHIP_REV_A01                 = 0x00000011,   //!< First silicon chipset revision
    LW_GPU_CHIP_REV_A02                 = 0x00000012,   //!< Second Silicon chipset revision
    LW_GPU_CHIP_REV_A03                 = 0x00000013,   //!< Third Silicon chipset revision
    LW_GPU_CHIP_REV_UNKNOWN             = 0xffffffff,   //!< Unknown chip revision
}LW_GPU_CHIP_REVISION;

//! \ingroup gpu
//! Used in LwAPI_GPU_GetArchInfo()
typedef struct 
{
    LwU32 version;

    union
    {
        LwU32                           architecture;       //!< architecture and architecture_id are the same. The former is LwU32 while the latter is an enum made for readability.
        LW_GPU_ARCHITECTURE_ID          architecture_id;    //!< specifies the architecture level for the GPU.
    };
    union
    {
        LwU32                           implementation;     //!< implementation and implementation_id are the same. The former is LwU32 while the latter is an enum made for readability.
        LW_GPU_ARCH_IMPLEMENTATION_ID   implementation_id;  //!< specifies the implementation of the architecture for the GPU.
    };
    union
    {
        LwU32                           revision;           //!< revision and revision_id are the same. The former is LwU32 while the latter is an enum made for readability.
        LW_GPU_CHIP_REVISION            revision_id;        //!< specifies the architecture revision of the GPU.
    };
    
} LW_GPU_ARCH_INFO_V2;

//! \ingroup gpu
typedef LW_GPU_ARCH_INFO_V2 LW_GPU_ARCH_INFO; 

//! \ingroup gpu
#define LW_GPU_ARCH_INFO_VER_1  MAKE_LWAPI_VERSION(LW_GPU_ARCH_INFO_V1,1)
#define LW_GPU_ARCH_INFO_VER_2  MAKE_LWAPI_VERSION(LW_GPU_ARCH_INFO_V2,2)
#define LW_GPU_ARCH_INFO_VER    LW_GPU_ARCH_INFO_VER_2


//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_GetArchInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_ARCH_INFO *pGpuArchInfo);


 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetExtendedMinorRevision
//
//!   This function retrieves the extended minor revision for the specified GPU.
//!
//!   <b>INTERNAL USE ONLY!</b>
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 158
//! 
//! \return LWAPI_ERROR or LWAPI_OK \n
//!         LWAPI_NOT_SUPPORTED if the value is not available on this GPU
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetExtendedMinorRevision(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pValue);

 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_GPU_GetSampleType
//
//! \fn LwAPI_GPU_GetSampleType(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_SAMPLE_TYPE *pValue)
//!  This function retrieves the type of sample for the specified GPU.
//!
//! INTERNAL USE ONLY!
//!  
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 158
//!
//! \return LWAPI_ERROR or LWAPI_OK \n
//!         LWAPI_NOT_SUPPORTED if the value is not available on this GPU
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup gpu
//! Used in LwAPI_GPU_GetSampleType()
typedef enum _LW_GPU_SAMPLE_TYPE
{
    LW_GPU_SAMPLE_NONE       = 0,    //!< The GPU is not a sample, it's a production part.
    LW_GPU_SAMPLE_ES         = 1,    //!< The GPU is an engineering sample. (ES)
    LW_GPU_SAMPLE_QS         = 2,    //!< The GPU is a qualification sample. (QS)
    LW_GPU_SAMPLE_PS         = 3,    //!< The GPU is a production sample. (PS)
    LW_GPU_SAMPLE_QS_PS_PROD = 4,    //!< The GPU is QS, PS, or a production part, but NOT an ES.
} LW_GPU_SAMPLE_TYPE;


 

//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_GetSampleType(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_SAMPLE_TYPE *pValue);


 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetHardwareQualType
//
//! \fn LwAPI_GPU_GetHardwareQualType(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_HW_QUAL_TYPE *pValue)
//!  This function retrieves the hardware qualification type for the specified GPU.
//!  INTERNAL USE ONLY!
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 158
//!
//!  \return LWAPI_ERROR or LWAPI_OK \n
//!          LWAPI_NOT_SUPPORTED if the value is not available on this GPU
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup gpu
//! Used in LwAPI_GPU_GetHardwareQualType()
typedef enum _LW_GPU_HW_QUAL_TYPE
{
    LW_GPU_HW_QUAL_TYPE_NONE          = 0,    //!< The GPU is not a HW Qual part, there is no HW qual type
    LW_GPU_HW_QUAL_TYPE_NOMINAL       = 1,
    LW_GPU_HW_QUAL_TYPE_SLOW          = 2,
    LW_GPU_HW_QUAL_TYPE_FAST          = 3,
    LW_GPU_HW_QUAL_TYPE_HIGH_LEAKAGE  = 4,
} LW_GPU_HW_QUAL_TYPE;



//!  \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_GetHardwareQualType(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_HW_QUAL_TYPE *pValue);


///////////////////////////////////////////////////////////////////////////////
//
//  GPU Clock Control
//
//  These APIs allow the user to get and set individual clock domains
//  on a per-GPU basis.
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup gpuclock
//! @{
#define LWAPI_MAX_GPU_CLOCKS 32
#define LWAPI_MAX_GPU_PUBLIC_CLOCKS     32
#define LWAPI_MAX_GPU_PERF_CLOCKS       32
#define LWAPI_MAX_GPU_PERF_VOLTAGES     16
#define LWAPI_MAX_GPU_PERF_PSTATES      16
//! @}

//! \ingroup gpuclock
//!  LW_GPU_CLOCK_INFO_DOMAIN_ID is obsolete.  Use ::LW_GPU_PUBLIC_CLOCK_ID.
//!  Remove after ::LW_GPU_PUBLIC_CLOCK_ID propagates and all applications are updated.
typedef enum _LW_GPU_CLOCK_INFO_DOMAIN_ID
{
    LWAPI_GPU_CLOCK_INFO_DOMAIN_LW      = 0,
    LWAPI_GPU_CLOCK_INFO_DOMAIN_M       = 4,
    LWAPI_GPU_CLOCK_INFO_DOMAIN_HOTCLK  = 7,
    LWAPI_GPU_CLOCK_INFO_DOMAIN_UNDEFINED = LWAPI_MAX_GPU_CLOCKS,
} LW_GPU_CLOCK_INFO_DOMAIN_ID;


//! \ingroup gpuclock
//!  LW_GPU_PERF_CLOCK_DOMAIN_ID is obsolete.  Use ::LW_GPU_PUBLIC_CLOCK_ID.
//!  Remove after ::LW_GPU_PUBLIC_CLOCK_ID propagates and all applications are updated.
typedef enum _LW_GPU_PERF_CLOCK_DOMAIN_ID
{
    LWAPI_GPU_PERF_CLOCK_DOMAIN_GRAPHICS_CLK  = 0,
    LWAPI_GPU_PERF_CLOCK_DOMAIN_MEMORY_CLK    = 4,   
    LWAPI_GPU_PERF_CLOCK_DOMAIN_PROCESSOR_CLK = 7, 
} LW_GPU_PERF_CLOCK_DOMAIN_ID;


//! \ingroup gpuclock
typedef enum _LW_GPU_PUBLIC_CLOCK_ID
{
    LWAPI_GPU_PUBLIC_CLOCK_GRAPHICS  = 0,
    LWAPI_GPU_PUBLIC_CLOCK_MEMORY    = 4,
    LWAPI_GPU_PUBLIC_CLOCK_PROCESSOR = 7,
    LWAPI_GPU_PUBLIC_CLOCK_UNDEFINED = LWAPI_MAX_GPU_PUBLIC_CLOCKS,
} LW_GPU_PUBLIC_CLOCK_ID;


//! \ingroup gpuclock
typedef enum _LW_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID
{
    LWAPI_GPU_PERF_VOLTAGE_INFO_DOMAIN_CORE      = 0,
    LWAPI_GPU_PERF_VOLTAGE_INFO_DOMAIN_UNDEFINED = LWAPI_MAX_GPU_PERF_VOLTAGES,
} LW_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID;




//! \ingroup gpuclock
//! Used in #LW_GPU_CLOCK_INFO to identify the relevant domain. 
typedef enum _LW_GPU_CLOCK_DOMAIN_ID
{
    LWAPI_GPU_CLOCK_DOMAIN_LW      = 0,
    LWAPI_GPU_CLOCK_DOMAIN_G       = 1,
    LWAPI_GPU_CLOCK_DOMAIN_S       = 2,
    LWAPI_GPU_CLOCK_DOMAIN_R       = 3,
    LWAPI_GPU_CLOCK_DOMAIN_M       = 4,
    LWAPI_GPU_CLOCK_DOMAIN_HOST    = 5,
    LWAPI_GPU_CLOCK_DOMAIN_DISP    = 6,
    LWAPI_GPU_CLOCK_DOMAIN_HOTCLK  = 7,
    LWAPI_GPU_CLOCK_DOMAIN_PCLK0   = 8,
    LWAPI_GPU_CLOCK_DOMAIN_PCLK1   = 9,
    LWAPI_GPU_CLOCK_DOMAIN_BYPCLK  = 10,
    LWAPI_GPU_CLOCK_DOMAIN_XCLK    = 11,
    LWAPI_GPU_CLOCK_DOMAIN_VPV     = 12,
    LWAPI_GPU_CLOCK_DOMAIN_VPS     = 13,
    LWAPI_GPU_CLOCK_DOMAIN_GPUCACHECLK     = 14,
    LWAPI_GPU_CLOCK_DOMAIN_GPC2    = 15,
    LWAPI_GPU_CLOCK_DOMAIN_XBAR2   = 16,
    LWAPI_GPU_CLOCK_DOMAIN_SYS2    = 17,
    LWAPI_GPU_CLOCK_DOMAIN_HUB2    = 18,
    LWAPI_GPU_CLOCK_DOMAIN_LEG     = 19,
    LWAPI_GPU_CLOCK_DOMAIN_PWR     = 20,
    LWAPI_GPU_CLOCK_DOMAIN_MSD     = 21,
    LWAPI_GPU_CLOCK_DOMAIN_UTILS   = 22,
    LWAPI_GPU_CLOCK_DOMAIN_COLD_LW     = 23,
    LWAPI_GPU_CLOCK_DOMAIN_COLD_HOTCLK = 24,
    LWAPI_GPU_CLOCK_DOMAIN_LTC2    = 25,
    LWAPI_GPU_CLOCK_DOMAIN_2D      = 26,    //! 2D graphics clock domain
    LWAPI_GPU_CLOCK_DOMAIN_3D      = 27,    //! 3D graphics clock domain
    LWAPI_GPU_CLOCK_DOMAIN_HOST1X    = 28,  //! host1x clock domain
    LWAPI_GPU_CLOCK_DOMAIN_DISP0     = 29,  //! display clock domain for display controller 0
    LWAPI_GPU_CLOCK_DOMAIN_DISP1     = 30,  //! display clock domain for display controller 1
    LWAPI_GPU_CLOCK_DOMAIN_UNDEFINED = LWAPI_MAX_GPU_CLOCKS,
} LW_GPU_CLOCK_DOMAIN_ID;


//! \ingroup gpuclock
typedef enum _LW_GPU_PERF_VOLTAGE_DOMAIN_ID
{
    LWAPI_GPU_PERF_VOLTAGE_DOMAIN_CORE         = 0,
    LWAPI_GPU_PERF_VOLTAGE_DOMAIN_FB           = 1,
    LWAPI_GPU_PERF_VOLTAGE_DOMAIN_COLD_CORE    = 2,
    LWAPI_GPU_PERF_VOLTAGE_DOMAIN_CORE_NOMINAL = 3,    
    LWAPI_GPU_PERF_VOLTAGE_DOMAIN_UNDEFINED = LWAPI_MAX_GPU_PERF_VOLTAGES,

} LW_GPU_PERF_VOLTAGE_DOMAIN_ID;




//! \ingroup gpuclock
//! Used in LW_GPU_CLOCK_INFO.
typedef enum
{
    LW_GPU_CLOCK_PSTATE_USAGE_FIXED     = 0x0,
    LW_GPU_CLOCK_PSTATE_USAGE_PSTATE    = 0x1,
    LW_GPU_CLOCK_PSTATE_USAGE_DECOUPLED = 0x2,
    LW_GPU_CLOCK_PSTATE_USAGE_RATIO     = 0x3,
} LW_GPU_CLOCK_INFO_DOMAIN_PSTATE_USAGE;

//! \ingroup gpuclock
//! Used in LW_GPU_CLOCK_INFO.
typedef struct
{
        LwU32                  frequency;       //!< Clock frequency (kHz)
        
        LwU32                  bIsPresent:1;    //!< Set if this domain is present on this GPU (for LwAPI_GPU_GetAllClocks() only).
        LwU32                  bDrivingDDR:1;   //!< Set if clock is driving DDR memory (for LwAPI_GPU_GetAllClocks() only)).
        LwU32                  bSetClock:1;     //!< If set during the LwAPI_GPU_SetClocks() call, this domain will be set.
        LwU32                  pstateUsage:2;   //!< One of LW_GPU_CLOCK_INFO_DOMAIN_PSTATE_USAGE (for LwAPI_GPU_GetAllClocks() only).
        LwU32                  reserved:27;     //!< These bits are reserved for future use.
} LW_GPU_CLOCK_INFO_DOMAIN;

//! \ingroup gpuclock
//! Used in LwAPI_GPU_GetAllClocks() and LwAPI_GPU_SetClocks()
typedef struct 
{
    LwU32                  version;         //!<  Structure version
    LW_GPU_CLOCK_INFO_DOMAIN domain[LWAPI_MAX_GPU_CLOCKS];
} LW_GPU_CLOCK_INFO_V1;

//! \ingroup gpuclock
typedef struct 
{
    LwU32                  version;                     //!< Structure version
    LW_GPU_CLOCK_INFO_DOMAIN domain[LWAPI_MAX_GPU_CLOCKS];
//! below struct extendedDomain is not supported on ARM(CheetAh) so ignore those variables
    struct 
    {
        LwU32                   effectiveFrequency;     //!< == domain[i].frequency unless there is some slowdown (i.e. thermal)
        LW_GPU_CLOCK_DOMAIN_ID  ratioDomain;
        LwU32                   ratio;
        LwU32                   reserved[4];            //!< Reserved for binary compatibility in future API extensions.
    } extendedDomain[LWAPI_MAX_GPU_CLOCKS];             //!< Used in LwAPI_GPU_GetAllClocks() to retrieve thermal slowdown frequency values.
} LW_GPU_CLOCK_INFO_V2;


//! \ingroup gpuclock
typedef LW_GPU_CLOCK_INFO_V2 LW_GPU_CLOCK_INFO;


//! \addtogroup gpuclock
//! @{
#define LW_GPU_CLOCK_INFO_VER_1  MAKE_LWAPI_VERSION(LW_GPU_CLOCK_INFO_V1,1)
#define LW_GPU_CLOCK_INFO_VER_2  MAKE_LWAPI_VERSION(LW_GPU_CLOCK_INFO_V2,2)
#define LW_GPU_CLOCK_INFO_VER    LW_GPU_CLOCK_INFO_VER_2
//! @}

 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetAllClocks
//
//!   This function retrieves the LW_GPU_CLOCK_INFO structure for the specified physical GPU.
//!
//!   For each clock domain:
//!      - bIsPresent is set for each domain that is present on the GPU
//!      - bDrivingDDR is set if that clock is driving dual-data-rate RAM
//!        frequency is the rate (in kHz) of the clock at the time of the call
//!
//!   Each domain's info is indexed in the array.  For example:
//!   clkInfo.domain[LWAPI_GPU_CLOCK_DOMAIN_M] holds the info for the 'M' domain.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 85
//!
//! \retval   LWAPI_OK                            Completed request
//! \retval   LWAPI_ERROR                         Miscellaneous error oclwrred.
//! \retval   LWAPI_ILWALID_ARGUMENT              pClkInfo is NULL.
//! \retval   LWAPI_HANDLE_ILWALIDATED            Handle passed has been ilwalidated (see user guide).
//! \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//! \retval   LWAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the INFO struct is not supported.
//! \ingroup gpuclock
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetAllClocks(LwPhysicalGpuHandle hPhysicalGPU, LW_GPU_CLOCK_INFO *pClkInfo);


//! \ingroup gpuclock
//! Used in LwAPI_GPU_GetAllClockFrequencies()
typedef struct 
{
    LwU32   version;    //!< Structure version
    LwU32   reserved;   //!< These bits are reserved for future use.
    struct
    {
        LwU32 bIsPresent:1;         //!< Set if this domain is present on this GPU
        LwU32 reserved:31;          //!< These bits are reserved for future use.
        LwU32 frequency;            //!< Clock frequency (kHz)
    }domain[LWAPI_MAX_GPU_PUBLIC_CLOCKS];
} LW_GPU_CLOCK_FREQUENCIES_V1;

//! \ingroup gpuclock
//! Used in LwAPI_GPU_GetAllClockFrequencies()
typedef enum
{
    LW_GPU_CLOCK_FREQUENCIES_LWRRENT_FREQ =   0,
    LW_GPU_CLOCK_FREQUENCIES_BASE_CLOCK   =   1,
    LW_GPU_CLOCK_FREQUENCIES_BOOST_CLOCK  =   2,
    LW_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE_NUM = 3
}   LW_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE;

//! \ingroup gpuclock
//! Used in LwAPI_GPU_GetAllClockFrequencies()
typedef struct 
{
    LwU32   version;        //!< Structure version
    LwU32   ClockType:2;    //!< One of LW_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE. Used to specify the type of clock to be returned.
    LwU32   reserved:22;    //!< These bits are reserved for future use. Must be set to 0.
    LwU32   reserved1:8;    //!< These bits are reserved.
    struct
    {
        LwU32 bIsPresent:1;         //!< Set if this domain is present on this GPU
        LwU32 reserved:31;          //!< These bits are reserved for future use.
        LwU32 frequency;            //!< Clock frequency (kHz)
    }domain[LWAPI_MAX_GPU_PUBLIC_CLOCKS];
} LW_GPU_CLOCK_FREQUENCIES_V2;

//! \ingroup gpuclock
//! Used in LwAPI_GPU_GetAllClockFrequencies()
typedef LW_GPU_CLOCK_FREQUENCIES_V2 LW_GPU_CLOCK_FREQUENCIES;

//! \addtogroup gpuclock
//! @{
#define LW_GPU_CLOCK_FREQUENCIES_VER_1    MAKE_LWAPI_VERSION(LW_GPU_CLOCK_FREQUENCIES_V1,1)
#define LW_GPU_CLOCK_FREQUENCIES_VER_2    MAKE_LWAPI_VERSION(LW_GPU_CLOCK_FREQUENCIES_V2,2)
#define LW_GPU_CLOCK_FREQUENCIES_VER      LW_GPU_CLOCK_FREQUENCIES_VER_2
//! @}
 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetAllClockFrequencies
//
//!   This function retrieves the LW_GPU_CLOCK_FREQUENCIES structure for the specified physical GPU.
//!
//!   For each clock domain:
//!      - bIsPresent is set for each domain that is present on the GPU
//!      - frequency is the domain's clock freq in kHz
//!
//!   Each domain's info is indexed in the array.  For example:
//!   clkFreqs.domain[LWAPI_GPU_PUBLIC_CLOCK_MEMORY] holds the info for the MEMORY domain.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 295
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//! \retval  LWAPI_ILWALID_ARGUMENT     pClkFreqs is NULL.
//! \ingroup gpuclock
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetAllClockFrequencies(__in LwPhysicalGpuHandle hPhysicalGPU, __inout LW_GPU_CLOCK_FREQUENCIES *pClkFreqs);


//! \ingroup gpuclock
//! Used in LW_GPU_PUBLIC_CLOCK_INFO.
typedef enum
{
    LW_GPU_PUBLIC_CLOCK_DOMAIN_PROGRAMMABLE     = 0x00000001,
} LW_GPU_PUBLIC_CLOCK_INFO_DOMAINS_FLAGS;
//! \ingroup gpuclock
//! Used in LwAPI_GPU_GetPublicClockInfo().
typedef struct
{
    LwU32   version;
    LwU32   flags;
    struct
    {
        LW_GPU_CLOCK_DOMAIN_ID clkId;
        LwU32 flags;                        //!< Mask of ::LW_GPU_PUBLIC_CLOCK_INFO_DOMAINS_FLAGS
        LwU32 frequencyAdjustPercent;
    }domains[LWAPI_MAX_GPU_PUBLIC_CLOCKS];
   
}LW_GPU_PUBLIC_CLOCK_INFO;
//! \ingroup gpuclock
//! Macro for constructing the version field of LW_GPU_PUBLIC_CLOCK_INFO
#define LW_GPU_PUBLIC_CLOCK_INFO_VER  MAKE_LWAPI_VERSION(LW_GPU_PUBLIC_CLOCK_INFO,1)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetPublicClockInfo
//
//!   DESCRIPTION: This API retrieves information on the clock domains that are
//!                exposed to the public.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \param [in]   hPhysicalGPU       GPU selection
//! \param [out]  pPublicClockInfo   Retrieved information concerning
//!               all clock domains exposed to the public, detailed as follows:
//!                    - flags is reserved for future use.
//!                    - domains contains each domain's info indexed in the 
//!                    array. For example: publicClockInfo.domains[LWAPI_GPU
//!                    _PUBLIC_CLOCK_MEMORY] holds the information for the 
//!                    memory clock domain.
//!                    - clkId is the internal clock domain that the public 
//!                      domain is mapped to.
//!                    - flags
//!                      bit 0 indicates the programmability of the domain.
//!                    - frequencyAdjustPercent is the frequency ratio between
//!                      the public and internal clock domain in percentage.
//!                      For example: if clkId = LWAPI_GPU_CLOCK_DOMAIN_GPC2 
//!                     and frequencyAdjustPercent = 50 in domains[LWAPI_GPU
//!                      _PUBLIC_CLOCK_GRAPHICS], it means that the graphics
//!                      clock frequency = the GPC2 clock frequency x 50%.
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_ILWALID_ARGUMENT              pPublicClockInfo is NULL
//! \retval ::LWAPI_HANDLE_ILWALIDATED 
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE 
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION   the version of the LW_GPU_PUBLIC_CLOCK_INFO struct is not supported
//!
//! \ingroup gpuclock
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPublicClockInfo(LwPhysicalGpuHandle hPhysicalGPU, LW_GPU_PUBLIC_CLOCK_INFO *pPublicClockInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_SetClocks
//
//!    This function allows the caller to set one or more GPU clock domains with one call.
//!    Depending on the architecture, some domains MUST be changed in conjunction with other domains.
//!    The caller must be familiar with the requirements and take the appropriate action.
//!
//!    If bSetDeferred is set, the clocks will be changed with the next modeset event.
//!    Otherwise, the clocks will be set at the time of the call.
//!      
//!    Only domains in the array with bSetClock set will be affected. Due to PLL
//!    programming constraints, the actual value set may vary slightly from the 
//!    requested frequency.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 85
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_ILWALID_USER_PRIVILEGE       - The caller does not have administrative privileges
//! \ingroup gpuclock
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetClocks(LwPhysicalGpuHandle hPhysicalGPU, LwU32 bSetDeferred, LW_GPU_CLOCK_INFO *pClkInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_SetClocksShmoo
//
//!   DESCRIPTION: This allows the caller to shmoo all clocks that share the same PLL as the given clock. 
//!                The caller must supply the target clocks and target PLL frequency.
//!
//!                This API is designed to support shmooing derivative clocks that share the same PLL.
//!                All other clocks will not be supported by this API.
//!
//!                Due to PLL programming constraints, the actual value set 
//!                may vary slightly from the requested frequency.
//!
//!                Fermi only.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_ILWALID_USER_PRIVILEGE  - The caller does not have administrative privileges
//! \retval ::LWAPI_NOT_SUPPORTED           - Shmooing is not supported on this GPU for the given clock.
//!
//! \ingroup gpuclock
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetClocksShmoo(LwPhysicalGpuHandle hPhysicalGPU, LW_GPU_CLOCK_INFO *pClkInfo);



//! \addtogroup gpuclock
//! @{
//! @name Performance flags for the HybridMode APIs.
// @{
#define LW_PERF_CLOCK_GPU_HYBRID_MODE_SUPPORTED       0x00000001 //!< Hybrid mode available on the selected GPU
#define LW_PERF_CLOCK_GPU_HYBRID_MODE_ENABLE          0x00000002 //!< Enable Hybrid Mode
#define LW_PERF_CLOCK_GPU_HYBRID_MODE_DISABLE         0x00000004 //!< Disable Hybrid Mode
#define LW_PERF_CLOCK_GPU_HYBRID_MODE_ACTIVE          0x00000008 //!< Hybrid Mode enabled and active with higher voltage
#define LW_PERF_CLOCK_GPU_HYBRID_MODE_INACTIVE        0x00000010 //!< Hybrid Mode enabled but inactive with no gpu demand or default clocks.
// @}
//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_SetPerfHybridMode
//
//!  This function enables or disables the performance overclocking Hybrid Mode. 
//!  On LWAPI_OK the perf tables should be re-queried with LwAPI_GPU_GetPerfClocks.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 90
//!
//! \param [in]      hPhysicalGPU   GPU selection.
//! \param [in]      gpuPerfFlags   Hybrid mode selection set to LW_PERF_CLOCK_GPU_HYBRID_MODE_ENABLE or DISABLE.
//!
//! \retval   LWAPI_OK                             Completed request
//! \retval   LWAPI_ERROR                          Miscellaneous error oclwrred.
//! \retval   LWAPI_HANDLE_ILWALIDATED             Handle passed has been ilwalidated (see user guide).
//! \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE   Handle passed is not a physical GPU handle.
//! \retval   LWAPI_NOT_SUPPORTED                  HybridMode is not supported on this GPU.
//! \ingroup  gpuclock
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetPerfHybridMode(LwPhysicalGpuHandle hPhysicalGpu, LwU32 gpuPerfFlags);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetPerfHybridMode
//
//!  This function queries the performance overclocking Hybrid Mode status.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 90
//!
//! \param [in]      hPhysicalGPU   GPU selection.
//! \param [out]     pgpuPerfFlags  Hybrid mode status. One or more flags from LW_PERF_CLOCK_GPU_HYBRID_MODE.
//!
//! \retval   LWAPI_OK                             Completed request
//! \retval   LWAPI_ERROR                          Miscellaneous error oclwrred.
//! \retval   LWAPI_HANDLE_ILWALIDATED             Handle passed has been ilwalidated (see user guide).
//! \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE   Handle passed is not a physical GPU handle.
//! \retval   LWAPI_ILWALID_ARGUMENT               pGpuPerfFlags is NULL.
//! \retval   LWAPI_NOT_SUPPORTED                  HybridMode is not supported on this GPU.
//! \ingroup  gpuclock
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPerfHybridMode(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pGpuPerfFlags);

 

//Performance table overclocking 


//! \addtogroup gpuclock 
//! @{

#define LWAPI_MAX_PERF_CLOCK_LEVELS     12
#define LWAPI_TARGET_ALL_PERF_LEVELS    0xffffffff

#define LW_PERF_CLOCK_LEVEL_STATE_DEFAULT                   0x00000000 //!< Level is in its default state
#define LW_PERF_CLOCK_LEVEL_STATE_OVERCLOCKED               0x00000001 //!< Level is overclocked
#define LW_PERF_CLOCK_LEVEL_STATE_DESKTOP                   0x00000002 //!< 2D Desktop perf level
#define LW_PERF_CLOCK_LEVEL_STATE_PERFORMANCE               0x00000004 //!< 3D applications perf level
#define LW_PERF_CLOCK_LEVEL_STATE_TEST                      0x00000008 //!< Test the new clocks for this level. Does not apply.
#define LW_PERF_CLOCK_LEVEL_STATE_TEST_SUCCESS              0x00000010 //!< Test result
      
#define LW_PERF_CLOCK_GPU_STATE_DEFAULT                     0x00000000 //!< Default state
#define LW_PERF_CLOCK_GPU_STATE_DYNAMIC_SUPPORTED           0x00000001 //!< GPU supports dynamic performance level transitions
#define LW_PERF_CLOCK_GPU_STATE_DESKTOP                     0x00000002 //!< GPU in desktop level
#define LW_PERF_CLOCK_GPU_STATE_PERFORMANCE                 0x00000004 //!< GPU in performance level
#define LW_PERF_CLOCK_GPU_STATE_ACTIVE_CLOCKING_SUPPORTED   0x00000008 //!< Active clocking supported
#define LW_PERF_CLOCK_GPU_STATE_ACTIVE_CLOCKING_ENABLE      0x00000010 //!< Enable active clocking
#define LW_PERF_CLOCK_GPU_STATE_ACTIVE_CLOCKING_DISABLE     0x00000020 //!< Disable active clocking
#define LW_PERF_CLOCK_GPU_STATE_MEMCLK_CONTROL_DISABLED     0x00000040 //!< Memory clock control disabled
#define LW_PERF_CLOCK_GPU_STATE_GFXCLK_CONTROL_DISABLED     0x00000080 //!< Core clock control disabled
#define LW_PERF_CLOCK_GPU_STATE_SET_DEFERRED                0x00000100 //!< No immediate perf transitions. Deferred until perf triggers kick in.
#define LW_PERF_CLOCK_GPU_STATE_TESTING_CLOCKS_SUPPORTED    0x00000200 //!< Testing clocks supported
//! @}


//! \ingroup  gpuclock 
//! Used in LwAPI_GPU_GetPerfClocks() and LwAPI_GPU_GetPerfClocks() 
typedef struct
{
    LwU32   version;                                //!< IN perf clock table version
    LwU32   levelCount;                             //!< number of the performance levels. count increases everytime a level is overclocked
    LwU32   gpuPerflevel;                           //!< OUT the current perf level. This is a dynamic level which can possibly change on every call
    LwU32   domainCount;                            //!< IN/OUT number of domains
    LwU32   gpuPerfFlags;                           //!< IN/OUT gpu flags - one of the flags defined in LW_PERF_CLOCK_GPU_STATE
    struct
    {
        LwU32   level;                              //!< IN/OUT performance level indicator, range 0 to levelCount - 1.
        LwU32   flags;                              //!< IN/OUT per level flags - one of more flags defined in LW_PERF_CLOCK_LEVEL_STATE 
        struct
        {
            LW_GPU_PUBLIC_CLOCK_ID      domainId;       //!< IN/OUT current domain indicator - one of the ids from LW_GPU_PUBLIC_CLOCK_ID
            LwU32                       domainFlags;    //!< reserved unused domain flags 
            LwU32                       lwrrentFreq;    //!< IN/OUT current clock kHz
            LwU32                       defaultFreq;    //!< default clock kHz
            LwU32                       minFreq;        //!< min kHz
            LwU32                       maxFreq;        //!< max kHz
            LwU32                       bSetClock:1;    //!< IN if set during LwAPI_GPU_SetPerfClocks call, this domain lwrrentFreq will be applied
        } domain[LWAPI_MAX_GPU_PERF_CLOCKS];
    } perfLevel[LWAPI_MAX_PERF_CLOCK_LEVELS];
    
} LW_GPU_PERF_CLOCK_TABLE;

//! \ingroup  gpuclock 
#define LW_GPU_PERF_CLOCK_TABLE_VER  MAKE_LWAPI_VERSION(LW_GPU_PERF_CLOCK_TABLE,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetPerfClocks
//
//!  This function retrieves the performance clock table information for one or all the supported levels.
//!                  NOTE: This call will return 0 for system memory.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 85
//!
//! \param [in]     hPhysicalGPU    GPU selection.
//! \param [in]     level           Specific level selection. Zero for all levels. Number of levels increases with overclocking of the levels.
//! \param [out]    pPerfClkTable   Table of performance levels retrieved.
//!
//! \retval   LWAPI_OK                             Completed request
//! \retval   LWAPI_ERROR                          Miscellaneous error oclwrred
//! \retval   LWAPI_HANDLE_ILWALIDATED             Handle passed has been ilwalidated (see user guide)
//! \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE   Handle passed is not a physical GPU handle
//! \retval   LWAPI_INCOMPATIBLE_STRUCT_VERSION    The version of the PERF_CLOCK_TABLE struct is not supported
//! \ingroup  gpuclock 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPerfClocks(LwPhysicalGpuHandle hPhysicalGpu, LwU32 level, LW_GPU_PERF_CLOCK_TABLE *pPerfClkTable);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_SetPerfClocks
//
//!  This function sets the Overclock to a specific level in the performance table or overclocks all levels with bSetClock set.
//! \note           The clocks represented by LW_GPU_PUBLIC_CLOCK_ID are interlocked on some GPU families. 
//!                 The API will fail to set the clocks if the interlocking ratios are violated.
//!                 For the Fermi family : PROCESSOR_CLK = 2 x GRAPHICS_CLK
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 85
//!
//! \param [in]      hPhysicalGPU    GPU selection.
//! \param [in]      level           Specific level selection. Zero for all levels. Number of levels increases with overclocking of the levels.
//! \param [in]      pPerfClkTable   Table of performance levels to set.
//!                                  Any other than DEFAULT for GPU and Level flags - gpuPerfFlags and level flags gets applied.
//!                                  If bSetClock is set, lwrrentFreq gets applied.
//!                                  Overclocking DOMAIN_LW requires simulteneous overclocking of DOMAIN_M, else overclocking will fail.
//!
//!  \retval   LWAPI_OK                            Completed request
//!  \retval   LWAPI_ERROR                         Miscellaneous error oclwrred
//!  \retval   LWAPI_HANDLE_ILWALIDATED            Handle passed has been ilwalidated (see user guide)
//!  \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle
//!  \retval   LWAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the PERF_CLOCK_TABLE struct is not supported
//!  \retval   LWAPI_TESTING_CLOCKS_NOT_SUPPORTED  Testing clocks not supported
//!
//!  \ingroup  gpuclock
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetPerfClocks(LwPhysicalGpuHandle hPhysicalGpu, LwU32 level, LW_GPU_PERF_CLOCK_TABLE *pPerfClkTable);

 
///////////////////////////////////////////////////////////////////////////////////
//  GPU Cooler Controls
//  Provides ability to Get and Set the fan level or equivalent cooler levels for various target devices associated with the GPU


//! \addtogroup gpucooler
//! @{

#define LWAPI_MAX_COOLERS_PER_GPU_VER1  3
#define LWAPI_MAX_COOLERS_PER_GPU_VER2  20
#define LWAPI_MAX_COOLERS_PER_GPU_VER3  LWAPI_MAX_COOLERS_PER_GPU_VER2
#define LWAPI_MAX_COOLERS_PER_GPU_VER4  LWAPI_MAX_COOLERS_PER_GPU_VER2

#define LWAPI_MAX_COOLERS_PER_GPU       LWAPI_MAX_COOLERS_PER_GPU_VER3
#define LWAPI_MIN_COOLER_LEVEL      0
#define LWAPI_MAX_COOLER_LEVEL      100
#define LWAPI_MAX_COOLER_LEVELS 24

//! Used in LW_GPU_GETCOOLER_SETTINGS_V1 and LW_GPU_GETCOOLER_SETTINGS_V2
typedef enum 
{
    LWAPI_COOLER_TYPE_NONE = 0,
    LWAPI_COOLER_TYPE_FAN,
    LWAPI_COOLER_TYPE_WATER,
    LWAPI_COOLER_TYPE_LIQUID_NO2,
} LW_COOLER_TYPE;


//! Used in LW_GPU_GETCOOLER_SETTINGS_V1 and LW_GPU_GETCOOLER_SETTINGS_V2
typedef enum 
{
    LWAPI_COOLER_CONTROLLER_NONE = 0,
    LWAPI_COOLER_CONTROLLER_ADI,
    LWAPI_COOLER_CONTROLLER_INTERNAL,
} LW_COOLER_CONTROLLER;

//! Used in LW_GPU_GETCOOLER_SETTINGS_V1 and LW_GPU_GETCOOLER_SETTINGS_V2
typedef enum
{
    LWAPI_COOLER_POLICY_NONE                      = 0x00000000,
    LWAPI_COOLER_POLICY_MANUAL                    = 0x00000001, //!<Manual adjustment of cooler level. Gets applied right away independent of temperature or performance level.
    LWAPI_COOLER_POLICY_PERF                      = 0x00000002, //!<GPU performance controls the cooler level.
    LWAPI_COOLER_POLICY_TEMPERATURE_DISCRETE      = 0x00000004, //!<Discrete thermal levels control the cooler level.
    LWAPI_COOLER_POLICY_TEMPERATURE_CONTINUOUS    = 0x00000008, //!<Cooler level adjusted at continuous thermal levels by HW.
    LWAPI_COOLER_POLICY_TEMPERATURE_CONTINUOUS_SW = 0x00000010, //!<Cooler level adjusted at continuous thermal levels by SW.
    LWAPI_COOLER_POLICY_DEFAULT                   = 0x00000020, //!<Default is used to allowe system to chose system's default policy.
} LW_COOLER_POLICY;

//! Used in LW_GPU_GETCOOLER_SETTINGS_V1 and LW_GPU_GETCOOLER_SETTINGS_V2
typedef enum
{
    LWAPI_COOLER_TARGET_NONE = 0,
    LWAPI_COOLER_TARGET_GPU,                //!< GPU cooler requires LwPhysicalGpuHandle
    LWAPI_COOLER_TARGET_MEMORY,             //!< GPU memory cooler requires LwPhysicalGpuHandle
    LWAPI_COOLER_TARGET_POWER_SUPPLY = 4,   //!< GPU power supply cooler requires LwPhysicalGpuHandle
    LWAPI_COOLER_TARGET_ALL = 7,            //!< This cooler cools all of the components related to its target GPU.
    LWAPI_COOLER_TARGET_VCD_COOLER1 = 8,    //!< Visual Computing Device cooler 1; Requires LwVisualComputingDeviceHandle
    LWAPI_COOLER_TARGET_VCD_COOLER2,    //!< Visual Computing Device cooler 2; Requires LwVisualComputingDeviceHandle        
    LWAPI_COOLER_TARGET_VCD_COOLER3,    //!< Visual Computing Device cooler 3; Requires LwVisualComputingDeviceHandle
    LWAPI_COOLER_TARGET_VCD_COOLER4,    //!< Visual Computing Device cooler 4; Requires LwVisualComputingDeviceHandle
    LWAPI_COOLER_TARGET_VCD_COOLER5,    //!< Visual Computing Device cooler 5; Requires LwVisualComputingDeviceHandle
    LWAPI_COOLER_TARGET_VCD_COOLER6,    //!< Visual Computing Device cooler 6; Requires LwVisualComputingDeviceHandle
    LWAPI_COOLER_TARGET_VCD_COOLER7,    //!< Visual Computing Device cooler 7; Requires LwVisualComputingDeviceHandle
    LWAPI_COOLER_TARGET_VCD_COOLER8,    //!< Visual Computing Device cooler 8; Requires LwVisualComputingDeviceHandle
    LWAPI_COOLER_TARGET_VCD_COOLER9,    //!< Visual Computing Device cooler 9; Requires LwVisualComputingDeviceHandle
    LWAPI_COOLER_TARGET_VCD_COOLER10,    //!< Visual Computing Device cooler 10; Requires LwVisualComputingDeviceHandle
    LWAPI_COOLER_TARGET_VCD_COOLER11,    //!< Visual Computing Device cooler 11; Requires LwVisualComputingDeviceHandle
    LWAPI_COOLER_TARGET_VCD_COOLER12,    //!< Visual Computing Device cooler 12; Requires LwVisualComputingDeviceHandle
    LWAPI_COOLER_TARGET_VCD_COOLER13,    //!< Visual Computing Device cooler 13; Requires LwVisualComputingDeviceHandle
    LWAPI_COOLER_TARGET_VCD_COOLER14,    //!< Visual Computing Device cooler 14; Requires LwVisualComputingDeviceHandle
    LWAPI_COOLER_TARGET_VCD_COOLER15,    //!< Visual Computing Device cooler 15; Requires LwVisualComputingDeviceHandle
    LWAPI_COOLER_TARGET_VCD_COOLER16,    //!< Visual Computing Device cooler 16; Requires LwVisualComputingDeviceHandle
    LWAPI_COOLER_TARGET_VCD_COOLER17,    //!< Visual Computing Device cooler 17; Requires LwVisualComputingDeviceHandle
    LWAPI_COOLER_TARGET_VCD_COOLER18,    //!< Visual Computing Device cooler 18; Requires LwVisualComputingDeviceHandle
    LWAPI_COOLER_TARGET_VCD_COOLER19,    //!< Visual Computing Device cooler 19; Requires LwVisualComputingDeviceHandle
    LWAPI_COOLER_TARGET_VCD_COOLER20,    //!< Visual Computing Device cooler 20; Requires LwVisualComputingDeviceHandle

} LW_COOLER_TARGET;

//! Used in LW_GPU_GETCOOLER_SETTINGS_V1 and LW_GPU_GETCOOLER_SETTINGS_V2
typedef enum
{
    LWAPI_COOLER_CONTROL_NONE = 0,
    LWAPI_COOLER_CONTROL_TOGGLE,                   //!< ON/OFF
    LWAPI_COOLER_CONTROL_VARIABLE,                 //!< Supports variable control.
} LW_COOLER_CONTROL;

//! Used in LW_GPU_GETCOOLER_SETTINGS_V1 and LW_GPU_GETCOOLER_SETTINGS_V2
typedef enum
{
    LWAPI_INACTIVE = 0,             //!< Inactive or unsupported
    LWAPI_ACTIVE = 1,               //!< Active and spinning (in the case of a fan)
} LW_COOLER_ACTIVITY_LEVEL;


//! Used in LW_GPU_GETCOOLER_SETTINGS_V3.
typedef struct
{
    LwU32   speedRPM;       //!< current tachometer reading in RPM
    LwU8    bSupported;     //!< cooler supports tach function?
    LwU32   maxSpeedRPM;    //!< Maximum RPM corresponding to 100% defaultMaxLevel
    LwU32   minSpeedRPM;    //!< Minimum RPM corresponding to 100% defaultMinLevel
} LW_COOLER_TACHOMETER;


//! Used in LwAPI_GPU_GetCoolerSettings()
typedef struct
{
    LwU32   version;                //!< Structure version 
    LwU32   count;                  //!< Number of associated coolers with the selected GPU
    struct 
    {
        LW_COOLER_TYPE              type;               //!< Type of cooler - FAN, WATER, LIQUID_NO2...
        LW_COOLER_CONTROLLER        controller;         //!< Internal, ADI...
        LwU32                       defaultMinLevel;    //!< The min default value % of the cooler
        LwU32                       defaultMaxLevel;    //!< The max default value % of the cooler
        LwU32                       lwrrentMinLevel;    //!< The current allowed min value % of the cooler
        LwU32                       lwrrentMaxLevel;    //!< The current allowed max value % of the cooler
        LwU32                       lwrrentLevel;       //!< The current value % of the cooler
        LW_COOLER_POLICY            defaultPolicy;      //!< Cooler control policy - auto-perf, auto-thermal, manual, hybrid...
        LW_COOLER_POLICY            lwrrentPolicy;      //!< Cooler control policy - auto-perf, auto-thermal, manual, hybrid...
        LW_COOLER_TARGET            target;             //!< Cooling target - GPU, memory, chipset, powersupply, canoas...
        LW_COOLER_CONTROL           controlType;        //!< Toggle or variable
        LW_COOLER_ACTIVITY_LEVEL    active;             //!< Is the cooler active - fan spinning...
    } cooler[LWAPI_MAX_COOLERS_PER_GPU_VER1];
} LW_GPU_GETCOOLER_SETTINGS_V1;

//! Used in LwAPI_GPU_GetCoolerSettings()
//! In Version 2, the LWAPI_MAX_COOLERS_PER_GPU changed from 3 to 20 to account for 20 fans on VCD.
typedef struct
{
    LwU32   version;                //!< structure version
    LwU32   count;                  //!< number of associated coolers with the selected GPU
    struct
    {
        LW_COOLER_TYPE              type;               //!< Type of cooler - FAN, WATER, LIQUID_NO2...
        LW_COOLER_CONTROLLER        controller;         //!< Internal, ADI...
        LwU32                       defaultMinLevel;    //!< The min default value % of the cooler
        LwU32                       defaultMaxLevel;    //!< The max default value % of the cooler
        LwU32                       lwrrentMinLevel;    //!< The current allowed min value % of the cooler
        LwU32                       lwrrentMaxLevel;    //!< The current allowed max value % of the cooler
        LwU32                       lwrrentLevel;       //!< The current value % of the cooler
        LW_COOLER_POLICY            defaultPolicy;      //!< Cooler control policy - auto-perf, auto-thermal, manual, hybrid...
        LW_COOLER_POLICY            lwrrentPolicy;      //!< Cooler control policy - auto-perf, auto-thermal, manual, hybrid...
        LW_COOLER_TARGET            target;             //!< Cooling target - GPU, memory, chipset, powersupply, Visual Computing Device...
        LW_COOLER_CONTROL           controlType;        //!< Toggle or variable
        LW_COOLER_ACTIVITY_LEVEL    active;             //!< Is the cooler active - fan spinning...
    } cooler[LWAPI_MAX_COOLERS_PER_GPU_VER2];
} LW_GPU_GETCOOLER_SETTINGS_V2;


typedef struct
{
    LwU32   version;                //!< structure version
    LwU32   count;                  //!< number of associated coolers with the selected GPU
    struct
    {
        LW_COOLER_TYPE              type;               //!< type of cooler - FAN, WATER, LIQUID_NO2...
        LW_COOLER_CONTROLLER        controller;         //!< internal, ADI...
        LwU32                       defaultMinLevel;    //!< the min default value % of the cooler
        LwU32                       defaultMaxLevel;    //!< the max default value % of the cooler
        LwU32                       lwrrentMinLevel;    //!< the current allowed min value % of the cooler
        LwU32                       lwrrentMaxLevel;    //!< the current allowed max value % of the cooler
        LwU32                       lwrrentLevel;       //!< the current value % of the cooler
        LW_COOLER_POLICY            defaultPolicy;      //!< cooler control policy - auto-perf, auto-thermal, manual, hybrid...
        LW_COOLER_POLICY            lwrrentPolicy;      //!< cooler control policy - auto-perf, auto-thermal, manual, hybrid...
        LW_COOLER_TARGET            target;             //!< cooling target - GPU, memory, chipset, powersupply, Visual Computing Device...
        LW_COOLER_CONTROL           controlType;        //!< toggle or variable
        LW_COOLER_ACTIVITY_LEVEL    active;             //!< is the cooler active - fan spinning...
        LW_COOLER_TACHOMETER        tachometer;         //!< cooler tachometer info
    } cooler[LWAPI_MAX_COOLERS_PER_GPU_VER3];
} LW_GPU_GETCOOLER_SETTINGS_V3;

typedef struct
{
    LwU32   version;                //!< structure version
    LwU32   count;                  //!< number of associated coolers with the selected GPU
    struct
    {
        LW_COOLER_TYPE              type;               //!< type of cooler - FAN, WATER, LIQUID_NO2...
        LW_COOLER_CONTROLLER        controller;         //!< internal, ADI...
        LwU32                       defaultMinLevel;    //!< the min default value % of the cooler
        LwU32                       defaultMaxLevel;    //!< the max default value % of the cooler
        LwU32                       lwrrentMinLevel;    //!< the current allowed min value % of the cooler
        LwU32                       lwrrentMaxLevel;    //!< the current allowed max value % of the cooler
        LwU32                       lwrrentLevel;       //!< the current value % of the cooler
        LW_COOLER_POLICY            defaultPolicy;      //!< cooler control policy - auto-perf, auto-thermal, manual, hybrid...
        LW_COOLER_POLICY            lwrrentPolicy;      //!< cooler control policy - auto-perf, auto-thermal, manual, hybrid...
        LW_COOLER_TARGET            target;             //!< cooling target - GPU, memory, chipset, powersupply, Visual Computing Device...
        LW_COOLER_CONTROL           controlType;        //!< toggle or variable
        LW_COOLER_ACTIVITY_LEVEL    active;             //!< is the cooler active - fan spinning...
        LW_COOLER_TACHOMETER        tachometer;         //!< cooler tachometer info
        LwU32                       supportedPolicies;  //!< supported cooler policies.    
    } cooler[LWAPI_MAX_COOLERS_PER_GPU_VER4];
} LW_GPU_GETCOOLER_SETTINGS_V4;


//!#Between ver1 and ver2 the LWAPI_MAX_COOLERS_PER_GPU changed from 3 to 20 to account for 20 fans on VCD

#define LW_GPU_GETCOOLER_SETTINGS           LW_GPU_GETCOOLER_SETTINGS_V4

#define LW_GPU_GETCOOLER_SETTINGS_VER1      MAKE_LWAPI_VERSION(LW_GPU_GETCOOLER_SETTINGS_V1,1)
#define LW_GPU_GETCOOLER_SETTINGS_VER2A     MAKE_LWAPI_VERSION(LW_GPU_GETCOOLER_SETTINGS_V2,1)  //!< For shipped R180 compatibility
#define LW_GPU_GETCOOLER_SETTINGS_VER2      MAKE_LWAPI_VERSION(LW_GPU_GETCOOLER_SETTINGS_V2,2)
#define LW_GPU_GETCOOLER_SETTINGS_VER3      MAKE_LWAPI_VERSION(LW_GPU_GETCOOLER_SETTINGS_V3,3)
#define LW_GPU_GETCOOLER_SETTINGS_VER4      MAKE_LWAPI_VERSION(LW_GPU_GETCOOLER_SETTINGS_V4,4)

#define LW_GPU_GETCOOLER_SETTINGS_VER       LW_GPU_GETCOOLER_SETTINGS_VER4


//! Used in LwAPI_GPU_SetCoolerLevels()
typedef struct 
{
    LwU32   version;        //!< Structure version 
    struct 
    {
        LwU32               lwrrentLevel;           //!< The new value % of the cooler
        LW_COOLER_POLICY    lwrrentPolicy;          //!< The new cooler control policy - auto-perf, auto-thermal, manual, hybrid...
    } cooler[LWAPI_MAX_COOLERS_PER_GPU_VER1];

} LW_GPU_SETCOOLER_LEVEL_V1;


//! Used in LwAPI_GPU_SetCoolerLevels()
typedef struct
{
    LwU32   version;        //structure version
    struct
    {
        LwU32               lwrrentLevel;           //!< The new value % of the cooler
        LW_COOLER_POLICY    lwrrentPolicy;          //!< The new cooler control policy - auto-perf, auto-thermal, manual, hybrid...
    } cooler[LWAPI_MAX_COOLERS_PER_GPU_VER2];
} LW_GPU_SETCOOLER_LEVEL_V2;

#define LW_GPU_SETCOOLER_LEVEL          LW_GPU_SETCOOLER_LEVEL_V2


#define LW_GPU_SETCOOLER_LEVEL_VER1     MAKE_LWAPI_VERSION(LW_GPU_SETCOOLER_LEVEL_V1,1)
#define LW_GPU_SETCOOLER_LEVEL_VER2     MAKE_LWAPI_VERSION(LW_GPU_SETCOOLER_LEVEL_V2,1)

#define LW_GPU_SETCOOLER_LEVEL_VER      LW_GPU_SETCOOLER_LEVEL_VER2


//! Used in LwAPI_GPU_GetCoolerPolicyTable()
typedef struct
{
    LwU32               version;        //!< Structure version
    LW_COOLER_POLICY    policy;         //!< selected policy to update the cooler levels for, example LWAPI_COOLER_POLICY_PERF
    struct 
    {
        LwU32 levelId;      //!< Level indicator for a policy
        LwU32 lwrrentLevel; //!< New cooler level for the selected policy level indicator
        LwU32 defaultLevel; //!< Default cooler level for the selected policy level indicator
    } policyCoolerLevel[LWAPI_MAX_COOLER_LEVELS];
} LW_GPU_COOLER_POLICY_TABLE;

#define LW_GPU_COOLER_POLICY_TABLE_VER MAKE_LWAPI_VERSION(LW_GPU_COOLER_POLICY_TABLE,1)

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetCoolerSettings
//
//!  This function retrieves the cooler information of all coolers or a specific cooler associated with the selected GPU.
//!  Coolers are indexed 0 to LWAPI_MAX_COOLERS_PER_GPU-1.
//!  - To retrieve specific cooler info, set the coolerIndex to the appropriate cooler index. 
//!  - To retrieve info for all coolers, set coolerIndex to LWAPI_COOLER_TARGET_ALL. 
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 85
//!
//! \param [in]     hPhysicalGPU    GPU selection.
//! \param [in]     coolerIndex     Explicit cooler index selection. 
//! \param [out]    pCoolerInfo     Array of cooler settings.
//!
//! \retval   LWAPI_OK                             Completed request
//! \retval   LWAPI_ERROR                          Miscellaneous error oclwrred.
//! \retval   LWAPI_ILWALID_ARGUMENT               pCoolerInfo is NULL.
//! \retval   LWAPI_HANDLE_ILWALIDATED             Handle passed has been ilwalidated (see user guide).
//! \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE   Handle passed is not a physical GPU handle.
//! \retval   LWAPI_INCOMPATIBLE_STRUCT_VERSION    The version of the INFO struct is not supported.
//! \ingroup  gpucooler
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetCoolerSettings(LwPhysicalGpuHandle hPhysicalGpu, LwU32 coolerIndex, LW_GPU_GETCOOLER_SETTINGS *pCoolerInfo);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_SetCoolerLevels
//
//!  This function sets the cooler levels for all coolers or a specific cooler associated with the selected GPU.
//!  Coolers are indexed 0 to LWAPI_MAX_COOLERS_PER_GPU-1. Every cooler level with non-zero lwrrentpolicy gets applied.          
//!  The new level should be in the range of minlevel and maxlevel retrieved from GetCoolerSettings API or between 
//!  and LWAPI_MIN_COOLER_LEVEL to MAX_COOLER_LEVEL.
//!  - To set level for a specific cooler, set the coolerIndex to the appropriate cooler index. 
//!  - To set level for all coolers, set coolerIndex to LWAPI_COOLER_TARGET_ALL. 
//!
//! \note      To lock the fan speed independent of the temperature or performance changes, set the cooler lwrrentPolicy to 
//!            LWAPI_COOLER_POLICY_MANUAL, else set it to the current policy retrieved from the GetCoolerSettings API.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 85
//! 
//! \param [in]       hPhysicalGPU    GPU selection.
//! \param [in]       coolerIndex     Explicit cooler index selection.
//! \param [in]       pCoolerLevels   Updated cooler level and cooler policy.
//!
//! \retval   LWAPI_OK                            Completed request
//! \retval   LWAPI_ERROR                         Miscellaneous error oclwrred.
//! \retval   LWAPI_ILWALID_ARGUMENT              pCoolerLevels is NULL.
//! \retval   LWAPI_HANDLE_ILWALIDATED            Handle passed has been ilwalidated (see user guide).
//! \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//! \retval   LWAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the INFO struct is not supported.
//! \ingroup  gpucooler
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetCoolerLevels(LwPhysicalGpuHandle hPhysicalGpu, LwU32 coolerIndex, LW_GPU_SETCOOLER_LEVEL *pCoolerLevels);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_RestoreCoolerSettings
//
//!  This function restores the modified cooler settings to LWPU defaults.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 85
//!
//! \param [in]       hPhysicalGPU     GPU selection.
//! \param [in]       pCoolerIndex     Array containing absolute cooler indexes to restore. Pass NULL restore all coolers.
//! \param            CoolerCount      Number of coolers to restore.
//!
//! \retval   LWAPI_OK                            Completed request
//! \retval   LWAPI_ERROR                         Miscellaneous error oclwrred.
//! \retval   LWAPI_HANDLE_ILWALIDATED            Handle passed has been ilwalidated (see user guide).
//! \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//! \retval   LWAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the INFO struct is not supported.
//! \ingroup  gpucooler
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_RestoreCoolerSettings(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pCoolerIndex, LwU32 coolerCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetCoolerPolicyTable
//
//!  This function retrieves the table of cooler and policy levels for the selected policy.
//!  Supported only for LWAPI_COOLER_POLICY_PERF.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 85
//!
//! \param [in]     hPhysicalGPU       GPU selection.
//! \param [in]     coolerIndex        Cooler index selection.
//! \param [out]    pCoolerTable       Table of policy levels and associated cooler levels.
//! \param [out]    count              Count of the number of valid levels for the selected policy.
//!
//! \retval   LWAPI_OK                            Completed request
//! \retval   LWAPI_ERROR                         Miscellaneous error oclwrred.
//! \retval   LWAPI_HANDLE_ILWALIDATED            Handle passed has been ilwalidated (see user guide).
//! \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//! \retval   LWAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the INFO struct is not supported.
//! \ingroup  gpucooler
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetCoolerPolicyTable(LwPhysicalGpuHandle hPhysicalGpu, LwU32 coolerIndex, LW_GPU_COOLER_POLICY_TABLE *pCoolerTable, LwU32 *count);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_SetCoolerPolicyTable
//
// DESCRIPTION:     Restore the modified cooler settings to LWPU defaults. Supported only for LWAPI_COOLER_POLICY_PERF.
//
//!  This function restores the modified cooler settings to LWPU defaults. Supported only for LWAPI_COOLER_POLICY_PERF.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 85
//!
//! \param [in]     hPhysicalGPU  GPU selection.
//! \param [in]     coolerIndex   Cooler index selection.
//! \param [in]     pCoolerTable  Updated table of policy levels and associated cooler levels. Every non-zero policy level gets updated.
//! \param [in]     count         Number of valid levels in the policy table.
//!
//! \retval   LWAPI_OK                            Completed request
//! \retval   LWAPI_ERROR                         Miscellaneous error oclwrred.
//! \retval   LWAPI_HANDLE_ILWALIDATED            Handle passed has been ilwalidated (see user guide).
//! \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//! \retval   LWAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the INFO struct is not supported.
//! \ingroup  gpucooler
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetCoolerPolicyTable(LwPhysicalGpuHandle hPhysicalGpu, LwU32 coolerIndex, LW_GPU_COOLER_POLICY_TABLE *pCoolerTable, LwU32 count);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_RestoreCoolerPolicyTable
//
//! DESCRIPTION:    This function restores the perf table policy levels to the defaults.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 85
//!
//! \param [in]   hPhysicalGPU   GPU selection.
//! \param [in]   coolerIndex    Cooler index selection.
//! \param [in]   pCoolerIndex   Array containing absolute cooler indexes to restore. Pass NULL restore all coolers.
//! \param        coolerCount    Number of coolers to restore.
//! \param        policy         Restore for the selected policy
//!
//! \retval   LWAPI_OK                           Completed request
//! \retval   LWAPI_ERROR                        Miscellaneous error oclwrred.
//! \retval   LWAPI_HANDLE_ILWALIDATED           Handle passed has been ilwalidated (see user guide).
//! \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE Handle passed is not a physical GPU handle.
//! \ingroup  gpucooler
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_RestoreCoolerPolicyTable(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pCoolerIndex, LwU32 coolerCount, LW_COOLER_POLICY policy);




//! addtogroup gputhermal
//! @{

#define LW_GPU_PMU_FAN_PRIVATE_DATA_HEADER_REVISION_MAJOR_REVISION            7:4
#define LW_GPU_PMU_FAN_PRIVATE_DATA_HEADER_REVISION_MAJOR_REVISION_1X  0x00000001
#define LW_GPU_PMU_FAN_PRIVATE_DATA_HEADER_REVISION_MINOR_REVISION            3:0
#define LW_GPU_PMU_FAN_PRIVATE_DATA_HEADER_REVISION_MINOR_REVISION_0   0x00000000

typedef struct
{
    LwU8  revision;  //!< The private data revision
    LwU8  size;      //!< The private data size

} LW_GPU_PMU_FAN_PRIVATE_DATA_HEADER;

#define LW_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_ENABLE                    0:0
#define LW_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_ENABLE_DISABLED  (0x00000000)
#define LW_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_ENABLE_ENABLED   (0x00000001)
#define LW_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_MODE                      2:1
#define LW_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_MODE_AUTOMATIC   (0x00000000)
#define LW_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_MODE_MANUAL      (0x00000001)
#define LW_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_GEMINI                    4:3
#define LW_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_GEMINI_DISABLED  (0x00000000)
#define LW_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_GEMINI_MASTER    (0x00000001)
#define LW_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_GEMINI_SLAVE     (0x00000002)
#define LW_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_GEMINI_SHARING   (0x00000003)
#define LW_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_ALGORITHM                7:5
#define LW_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_ALGORITHM_LINEAR (0x00000000)
#define LW_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_ALGORITHM_2_SEG  (0x00000001)

typedef struct
{
    //Configuration fields
    LwS16 m;              //!< Fixed point M - FXP8.8 colwerts temperature/100 C to PWM fraction
    LwS16 b;              //!< Fixed point B - FXP8.8 typically m=1...3 and b=0..-0.5
    LwS16 accelGain;      //!< Fan acceleration gain - FXP8.8 typically +2...-0.9
    LwS16 midpointGain;   //!< Gain to use in history - FXP8.8
    LwU8  historyCount;   //!< Number of second samples to keep - unsigned units
    LwU8  lookback;       //!< Number of samples for lookback smoothing for accleration - maximum of 10
    LwU16 controlField;   //!< Bit field for various PMU control bits - see macros above
    LwS16 slopeLimit0;    //!< Minimum slope of EF line segment, typically 1 - FXP8.8
    LwS16 slope1;         //!< Fixed slope of FG line segment, typically 2 - FXP8.8
    LwS16 gravity;        //!< Gravity to add to Fx at every iteration - FXP11.5

} LW_GPU_PMU_FAN_PRIVATE_DATA_1X;

typedef struct
{
    LwU32                              version;   //!< LWAPI structure version
    LW_GPU_PMU_FAN_PRIVATE_DATA_HEADER header;
    LW_GPU_PMU_FAN_PRIVATE_DATA_1X     pvtData1X; //!< Private data revision 1.X

} LW_GPU_PMU_FAN_PRIVATE_DATA_V1;

#define LW_GPU_PMU_FAN_PRIVATE_DATA_VER1     MAKE_LWAPI_VERSION(LW_GPU_PMU_FAN_PRIVATE_DATA_V1,1)
#define LW_GPU_PMU_FAN_PRIVATE_DATA_VER      LW_GPU_PMU_FAN_PRIVATE_DATA_VER1

typedef LW_GPU_PMU_FAN_PRIVATE_DATA_V1       LW_GPU_PMU_FAN_PRIVATE_DATA;

#define LW_GPU_PMU_FAN_PWM_SOURCE                      2:0
#define LW_GPU_PMU_FAN_PWM_SOURCE_ILWALID       0x00000000 //!< Default return value in all error cases (when PWM source expected).
#define LW_GPU_PMU_FAN_PWM_SOURCE_PMGR_FAN      0x00000001 //!< PWM source is PMGR "FAN" that allows OVERTEMP override.
#define LW_GPU_PMU_FAN_PWM_SOURCE_PMGR_PWM      0x00000002 //!< PWM source is PMGR "PWM".
#define LW_GPU_PMU_FAN_PWM_SOURCE_THERM_PWM     0x00000003 //!< PWM source belongs to OBJTHERM (GF11x+)
#define LW_GPU_PMU_FAN_PWM_ILWERT                      3:3
#define LW_GPU_PMU_FAN_PWM_ILWERT_DISABLED      0x00000000
#define LW_GPU_PMU_FAN_PWM_ILWERT_ENABLED       0x00000001

#define LW_GPU_PMU_FAN_RAMP_SLOPE_NOT_USED 0

typedef struct
{
    LwU32 version;          //!< LWAPI structure version
    LwU8  pwmPctMin;        //!< Minimum permitted fan percent 0..100, typically 0..40%
    LwU8  pwmPctMax;        //!< Maximum permitted fan percent 0..100, typically TDPMAX+10% 90..100
    LwU8  pwmPctManual;     //!< Raw duty cycle for PWM, used in manual mode, typically less than 16 bits
    LwU8  pwmSource;        //!< The PWM source which is driving the GPIO - used to determine which registers to write.
    LwS16 pwmScaleSlope;    //!< The slope/m for scaling electrical pwm % -> electrical pwm duty cycle - FXP4.12
    LwS16 pwmScaleOffset;   //!< The offset/b for scaling electrical pwm % -> electrical pwm duty cycle - FXP4.12
    LwU32 pwmRawPeriod;     //!< Raw period for PWM, typically less than 16 bits
    LwU16 pwmRampUpSlope;   //!< Ramp up slope in ms / %    - This is an *optional* parameter
    LwU16 pwmRampDownSlope; //!< Ramp down slope in ms / %  - This is an *optional* parameter

} LW_GPU_PMU_FAN_FAN_DESCRIPTION_V1;

#define LW_GPU_PMU_FAN_FAN_DESCRIPTION_VER1     MAKE_LWAPI_VERSION(LW_GPU_PMU_FAN_FAN_DESCRIPTION_V1,1)
#define LW_GPU_PMU_FAN_FAN_DESCRIPTION_VER      LW_GPU_PMU_FAN_FAN_DESCRIPTION_VER1

typedef LW_GPU_PMU_FAN_FAN_DESCRIPTION_V1       LW_GPU_PMU_FAN_FAN_DESCRIPTION;

typedef struct
{
    LwU32   version;        //!< LWAPI structure version
    struct
    {
        LW_GPU_PMU_FAN_FAN_DESCRIPTION_V1 fanDesc;
        LW_GPU_PMU_FAN_PRIVATE_DATA_V1    pvtData;

    } ctrlBlk;

} LW_GPU_PMU_FAN_CONTROL_BLOCK_V1;

#define LW_GPU_PMU_FAN_CONTROL_BLOCK_VER1     MAKE_LWAPI_VERSION(LW_GPU_PMU_FAN_CONTROL_BLOCK_V1,1)
#define LW_GPU_PMU_FAN_CONTROL_BLOCK_VER      LW_GPU_PMU_FAN_CONTROL_BLOCK_VER1

typedef LW_GPU_PMU_FAN_CONTROL_BLOCK_V1       LW_GPU_PMU_FAN_CONTROL_BLOCK;

//! @}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetPmuFanControlBlock
//
//! DESCRIPTION:     This API returns current the PMU fan control block.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \param [in]     hPhysicalGPU          GPU selection.
//! \param [in]     coolerIndex           cooler index selection.
//! \param [out]    pPmuFanControlBlock   Current PMU fan control block.
//!
//! \retval ::LWAPI_OK                 completed request
//! \retval ::LWAPI_NOT_SUPPORTED      PMU fan control is not supported on this setup
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the LW_GPU_PMU_FAN_CONTROL_BLOCK struct is not supported
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPmuFanControlBlock(LwPhysicalGpuHandle hPhysicalGpu, LwU32 coolerIndex, LW_GPU_PMU_FAN_CONTROL_BLOCK *pPmuFanControlBlock);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_SetPmuFanControlBlock
//
//! DESCRIPTION:     This API sets current the PMU fan control block.
//!                  Clients must set major and minor revision in LW_GPU_PMU_FAN_PRIVATE_DATA_HEADER
//!                  before calling this API.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \param [in]       hPhysicalGPU          GPU selection.
//! \param [in]       coolerIndex)          cooler index selection.
//! \param [in]       pPmuFanControlBlock   Client supplied PMU fan control block.
//
// RETURN STATUS:
//! \retval ::LWAPI_OK - completed request
//! \retval ::LWAPI_NOT_SUPPORTED - pmu fan control is not supported on this setup
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the LW_GPU_PMU_FAN_CONTROL_BLOCK struct is not supported
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetPmuFanControlBlock(LwPhysicalGpuHandle hPhysicalGpu, LwU32 coolerIndex, LW_GPU_PMU_FAN_CONTROL_BLOCK *pPmuFanControlBlock);




//! \addtogroup gpupstate
//! @{

#define LW_GPU_PERF_SET_FORCE_PSTATE_FLAGS_ASYNC    0x00000001 


#define LW_GPU_PERF_INPUT_FLAGS_DEFAULT_SETTINGS         0x00000001
#define LW_GPU_PERF_INPUT_FLAGS_MAX_CLOCK_FREQ           0x00000002
#define LW_GPU_PERF_INPUT_FLAGS_MIN_CLOCK_FREQ           0x00000004

#define LW_GPU_PERF_PSTATES_FLAGS_PERFMON_ENABLED        0x00000001 
#define LW_GPU_PERF_PSTATES_FLAGS_DYN_PSTATES_CAPABLE    0x00000002 
#define LW_GPU_PERF_PSTATES_FLAGS_DYNAMIC_PSTATE_ENABLED 0x00000004 
#define LW_GPU_PERF_PSTATES_FLAGS_MODE_INTERNAL_TEST     0x00000008 

#define LW_GPU_PERF_PSTATE_FLAGS_PCIELIMIT_GEN1       0x00000001 
#define LW_GPU_PERF_PSTATE_FLAGS_OVERCLOCKED_TRUE     0x00000002 
#define LW_GPU_PERF_PSTATE_FLAGS_OVERCLOCKABLE        0x00000004 

#define LW_GPU_PERF_PSTATE_CLOCK_FLAGS_OVERCLOCKABLE  0x00000001 

#define LW_GPU_PERF_PSTATE_CLOCK_INTERNAL_FLAGS_FORCE_PLL      0x00000001
#define LW_GPU_PERF_PSTATE_CLOCK_INTERNAL_FLAGS_FORCE_BYPASS   0x00000002

#define LW_GPU_PERF_PSTATE_VOLTAGE_FLAGS_VDT          0x00000001

//! @}

//! \addtogroup gpupstate
//! @{

typedef enum _LW_GPU_PERF_PSTATE_ID
{
    LWAPI_GPU_PERF_PSTATE_P0 = 0,
    LWAPI_GPU_PERF_PSTATE_P1,
    LWAPI_GPU_PERF_PSTATE_P2,
    LWAPI_GPU_PERF_PSTATE_P3,
    LWAPI_GPU_PERF_PSTATE_P4,
    LWAPI_GPU_PERF_PSTATE_P5,
    LWAPI_GPU_PERF_PSTATE_P6,
    LWAPI_GPU_PERF_PSTATE_P7,
    LWAPI_GPU_PERF_PSTATE_P8,
    LWAPI_GPU_PERF_PSTATE_P9,
    LWAPI_GPU_PERF_PSTATE_P10,
    LWAPI_GPU_PERF_PSTATE_P11,
    LWAPI_GPU_PERF_PSTATE_P12,
    LWAPI_GPU_PERF_PSTATE_P13,
    LWAPI_GPU_PERF_PSTATE_P14,
    LWAPI_GPU_PERF_PSTATE_P15,
    LWAPI_GPU_PERF_PSTATE_UNDEFINED = LWAPI_MAX_GPU_PERF_PSTATES,
    LWAPI_GPU_PERF_PSTATE_ALL,

} LW_GPU_PERF_PSTATE_ID;

//! @}



//! \addtogroup gpupstate
//! @{

//! Used in LwAPI_GPU_GetPstates().
typedef enum _LW_GPU_PERF_PSTATE_FALLBACK
{
    LWAPI_GPU_PERF_PSTATE_FALLBACK_RETURN_ERROR = 0,
    LWAPI_GPU_PERF_PSTATE_FALLBACK_HIGHER_PERF  = 1,
    LWAPI_GPU_PERF_PSTATE_FALLBACK_LOWER_PERF   = 2,

} LW_GPU_PERF_PSTATE_FALLBACK;



//! Used in LwAPI_GPU_GetPstates(), LwAPI_GPU_GetPstatesEx(), and LwAPI_GPU_SetPstates().
typedef struct
{
    LwU32   version;     //!< Structure version
    LwU32   flags;       //!< - bit 0 indicates if perfmon is enabled or not
                         //!< - bit 1 indicates if dynamic Pstate is capable or not
                         //!< - bit 2 indicates if dynamic Pstate is enable or not
                         //!< - set bit 3 if the call is for internal test mode
                         //!< - all other bits must be set to 0
    LwU32   numPstates;  //!< The number of available P-States
    LwU32   numClocks;   //!< The number of clock domains supported by each P-State
    LwU32   numVoltages; //!< The number of voltage domains supported by each P-State

    //! ID of the P-State, with valid index range of 0 to numPstates-1 
    struct
    {
        LW_GPU_PERF_PSTATE_ID   pstateId; //!<  ID of the P-State
        LwU32                   flags;    //!<  - bit 0 indicates if the PCIE limit is GEN1 or GEN2
                                          //!<  - bit 1 indicates if the Pstate is overclocked or not
                                          //!<  - bit 2 indicates if the Pstate is overclockable or not
                                          //!<  - all other bits must be set to 0

        //! Valid index range of 0 to numClocks-1
        struct
        {
            LW_GPU_CLOCK_DOMAIN_ID domainId;
            LwU32                                flags:2;       //!< - bit 0 indicates that clock is forced to source from PLL
                                                                //!< - bit 1 indicates that clock is forced to source from bypass
            LwU32                                reserved:29;   //!< Reserved for future use. Must be set to 0
            LwU32                                bApplyRatio:1; //!< Apply freq to other ratio clocks
            LwU32                                freq;          //!< Clock frequency in kHz

        } clocks[LWAPI_MAX_GPU_PERF_CLOCKS];
        
        //! Valid index range of 0 to numVoltages-1
        struct
        {
            LW_GPU_PERF_VOLTAGE_DOMAIN_ID domainId;  //!< ID of the voltage domain
            LwU32                       flags;       //!< -  bit 0 indicates that mvolt is evaluated from VDT
                                                     //!< -  all other bits must be set to 0
            LwU32                       mvolt;       //!< Voltage level in mV. 

        } voltages[LWAPI_MAX_GPU_PERF_VOLTAGES];

    } pstates[LWAPI_MAX_GPU_PERF_PSTATES];
    
} LW_GPU_PERF_PSTATES_V1;

typedef  LW_GPU_PERF_PSTATES_V1  LW_GPU_PERF_PSTATES;


//! Used in LwAPI_GPU_GetPstates().
#define LW_GPU_PERF_PSTATES_VER1  MAKE_LWAPI_VERSION(LW_GPU_PERF_PSTATES_V1,1)
#define LW_GPU_PERF_PSTATES_VER   LW_GPU_PERF_PSTATES_VER1

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetPstates
//
//! DESCRIPTION:     This function retrieves all performance states (P-States) information.
//!                  This API is defined for internal usage.  A similar API LwAPI_GPU_GetPstatesInfo() is 
//!                  provided for NDA users with restricted functions.
//!
//!                  P-States are GPU active/exelwting performance capability and power consumption states. \n
//!                  P-States range from P0 to P15, with P0 being the highest performance/power state, and
//!                  P15 being the lowest performance/power state. Each P-State maps to a
//!                  performance level. Not all P-States are available on a given system. The definition
//!                  of each P-States are lwrrently as follows:
//!                  - P0/P1 - Maximum 3D performance
//!                  - P2/P3 - Balanced 3D performance-power
//!                  - P8 - Basic HD video playback
//!                  - P10 - DVD playback
//!                  - P12 - Minimum idle power consumption
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 165
//!
//!  \param [in]  hPhysicalGPU  GPU selection.
//!  \param [out] pPerfPstates  P-States information retrieved. See \ref LW_GPU_PERF_PSTATES.
//!
//!  \retval    LWAPI_OK                            Completed request.
//!  \retval    LWAPI_ERROR                         Miscellaneous error oclwrred.
//!  \retval    LWAPI_HANDLE_ILWALIDATED            Handle passed has been ilwalidated (see user guide).
//!  \retval    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//!  \retval    LWAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the LW_GPU_PERF_PSTATES struct is not supported.
//!
//!  \ingroup   gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPstates(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_PERF_PSTATES *pPerfPstates);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetPstatesEx
//
//! DESCRIPTION:     This function retrieves all performance states (P-States) information.
//!                  This is the same as LwAPI_GPU_GetPstates(), but supports an input flag
//!                  for various options.
//!
//!                  P-States are GPU active/exelwting performance capability and power consumption states. \n
//!                  P-States range from P0 to P15, with P0 being the highest performance/power state, and
//!                  P15 being the lowest performance/power state. Each P-State maps to a
//!                  performance level. Not all P-States are available on a given system. The definition
//!                  of each P-States are lwrrently as follows:
//!                  - P0/P1 - Maximum 3D performance
//!                  - P2/P3 - Balanced 3D performance-power
//!                  - P8 - Basic HD video playback
//!                  - P10 - DVD playback
//!                  - P12 - Minimum idle power consumption
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//!  \param [in]  hPhysicalGPU  GPU selection.
//!  \param [out] pPerfPstates  P-States information retrieved. See \ref LW_GPU_PERF_PSTATES.
//!  \param [in]  inputFlags    This can be used to select various options:
//!                  - if bit 0 is set, pPerfPstates would contain the default settings
//!                    instead of the current, possibily overclocked settings.
//!                  - if bit 1 is set, pPerfPstates would contain the maximum clock 
//!                    frequencies instead of the nominal frequencies.
//!                  - if bit 2 is set, pPerfPstates would contain the minimum clock 
//!                    frequencies instead of the nominal frequencies.
//!                  - all other bits must be set to 0.
//!
//!  \retval    LWAPI_OK                            Completed request.
//!  \retval    LWAPI_ERROR                         Miscellaneous error oclwrred.
//!  \retval    LWAPI_HANDLE_ILWALIDATED            Handle passed has been ilwalidated (see user guide).
//!  \retval    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//!  \retval    LWAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the LW_GPU_PERF_PSTATES struct is not supported.
//!
//!  \ingroup   gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPstatesEx(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_PERF_PSTATES *pPerfPstates, LwU32 inputFlags);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_SetPstates
//
//! \code
//! DESCRIPTION:     Sets a subset (from 1 to all) of all performance states (P-States) information.  This 
//!                  API is defined for NDA usage.
//!
//!                  P-States are GPU active/exelwting performance capability and power consumption states.
//!                  P-States ranges from P0 to P15, with P0 being the highest performance/power state, and
//!                  P15 being the lowest performance/power state. Each P-State, if available, maps to a
//!                  performance level. Not all P-States are available on a given system. The definition
//!                  of each P-States are lwrrently as follow:
//!                    P0/P1 - Maximum 3D performance
//!                    P2/P3 - Balanced 3D performance-power
//!                    P8 - Basic HD video playback
//!                    P10 - DVD playback
//!                    P12 - Minimum idle power consumption
//!
//!                  The changes this API makes are *not* persistent across a driver unload or reboot.  
//!                  Client applications must handle enforcing persistence.  However, client apps should
//!                  also be careful not to persist bad pstate configurations across reboots (i.e. if the
//!                  bad pstate configuration hangs the chip and the client application always applies that
//!                  configuration on boot, the user will never be able to boot and revert those changes
//!                  without booting to safe mode).
//!
//!                  Some important caveats for this API, we will keep this information internal only for 
//!                  the present:
//!                    a) At present, we can only override the P0 pstate with this function.  For more
//!                       information about unlocking this for other pstate (for internal testing only!) 
//!                       see documentation of LW2080_CTRL_CMD_PERF_SET_PSTATE_INFO.  Any attempt to 
//!                       override pstates below P0 will silently fail: everything will return okay but no
//!                       changes will be made.
//!                    b) We are unable to change the pstate voltage on pre-Fermi boards.  To enable this
//!                       on Tesla dGPUs (for internal testing only!) see documentation of 
//!                       LW2080_CTRL_CMD_PERF_SET_PSTATE_INFO.  Any attempt to change the voltage will 
//!                       silently fail.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! PARAMETERS:      hPhysicalGPU(IN)  - GPU selection.
//!                  pPerfPstates(IN) - P-States information retrieved, as detailed below:
//!                  - flags is reserved for future use
//!                  - numPstates the number of p-states specified
//!                  - numClocks is the number of clock domains specified in each p-state.
//!                  - numVoltages is the number of voltage domains specified in each p-State
//!                  - pstates has valid index range from 0 to numPstates - 1
//!                  - pstates[i].pstateId is the ID of the P-State,
//!                      containing the following info:
//!                    - pstates[i].flags is reserved for future use
//!                    - pstates[i].clocks has valid index range from 0 to numClocks -1
//!                    - pstates[i].clocks[j].domainId is the ID of the clock domain,
//!                        containing the following info:
//!                      - pstates[i].clocks[j].flags is reserved for future use.
//!                      - pstates[i].clocks[j].freq is the clock frequency in kHz
//!                    - pstates[i].voltages has valid index range from 0 to numVoltages - 1
//!                    - pstates[i].voltages[j].domainId is the ID of the voltage domain,
//!                        containing the following info:
//!                      - pstates[j].voltages[j].flags is reserved for future use.
//!                      - pstates[j].voltages[j].mvolt is the voltage level in milli-volt
//!
//! RETURN STATUS:
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    LWAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the LW_GPU_PERF_PSTATES struct is not supported
//! \endcode
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetPstates(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_PERF_PSTATES *pPerfPstates);



//! \ingroup gpupstate
//! Used in LwAPI_GPU_GetPstatesInfoEx()
//! Used in LwAPI_GPU_GetPstatesInfo() and LwAPI_GPU_SetPstatesInfo().
typedef struct
{
    LwU32   version;
    LwU32   flags;           //!< - bit 0 indicates if perfmon is enabled or not
                             //!< - bit 1 indicates if dynamic Pstate is capable or not
                             //!< - bit 2 indicates if dynamic Pstate is enable or not
                             //!< - all other bits must be set to 0
    LwU32   numPstates;      //!< The number of available p-states 
    LwU32   numClocks;       //!< The number of clock domains supported by each P-State
    struct
    {
        LW_GPU_PERF_PSTATE_ID   pstateId; //!< ID of the p-state.  
        LwU32                   flags;    //!< - bit 0 indicates if the PCIE limit is GEN1 or GEN2
                                          //!< - bit 1 indicates if the Pstate is overclocked or not
                                          //!< - bit 2 indicates if the Pstate is overclockable or not
                                          //!< - all other bits must be set to 0
        struct
        {
            LW_GPU_PUBLIC_CLOCK_ID           domainId;  //!< ID of the clock domain   
            LwU32                               flags;  //!< Reserved. Must be set to 0
            LwU32                                freq;  //!< Clock frequency in kHz

        } clocks[LWAPI_MAX_GPU_PERF_CLOCKS];
    } pstates[LWAPI_MAX_GPU_PERF_PSTATES];

} LW_GPU_PERF_PSTATES_INFO_V1;


//! \ingroup gpupstate
typedef struct
{
    LwU32   version;
    LwU32   flags;             //!< - bit 0 indicates if perfmon is enabled or not
                               //!< - bit 1 indicates if dynamic Pstate is capable or not
                               //!< - bit 2 indicates if dynamic Pstate is enable or not
                               //!< - all other bits must be set to 0
    LwU32   numPstates;        //!< The number of available p-states 
    LwU32   numClocks;         //!< The number of clock domains supported by each P-State   
    LwU32   numVoltages; 
    struct
    {
        LW_GPU_PERF_PSTATE_ID   pstateId;  //!< ID of the p-state. 
        LwU32                   flags;     //!< - bit 0 indicates if the PCIE limit is GEN1 or GEN2
                                           //!< - bit 1 indicates if the Pstate is overclocked or not
                                           //!< - bit 2 indicates if the Pstate is overclockable or not
                                           //!< - all other bits must be set to 0
        struct
        {
            LW_GPU_PUBLIC_CLOCK_ID            domainId;       
            LwU32                                flags; //!< bit 0 indicates if this clock is overclockable
                                                        //!< all other bits must be set to 0
            LwU32                                 freq;

        } clocks[LWAPI_MAX_GPU_PERF_CLOCKS];
        struct
        {
            LW_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID domainId; //!< ID of the voltage domain, containing flags and mvolt info 
            LwU32                       flags;           //!< Reserved for future use. Must be set to 0
            LwU32                       mvolt;           //!< Voltage in mV  

        } voltages[LWAPI_MAX_GPU_PERF_VOLTAGES];

    } pstates[LWAPI_MAX_GPU_PERF_PSTATES];  //!< Valid index range is 0 to numVoltages-1

} LW_GPU_PERF_PSTATES_INFO_V2;

//! \ingroup gpupstate
typedef  LW_GPU_PERF_PSTATES_INFO_V2 LW_GPU_PERF_PSTATES_INFO;


//! \ingroup gpupstate
//! @{

//! Macro for constructing the version field of LW_GPU_PERF_PSTATES_INFO_V1 
#define LW_GPU_PERF_PSTATES_INFO_VER1  MAKE_LWAPI_VERSION(LW_GPU_PERF_PSTATES_INFO_V1,1)

//! Macro for constructing the version field of LW_GPU_PERF_PSTATES_INFO_V2 
#define LW_GPU_PERF_PSTATES_INFO_VER2  MAKE_LWAPI_VERSION(LW_GPU_PERF_PSTATES_INFO_V2,2)

//! Macro for constructing the version field of LW_GPU_PERF_PSTATES_INFO 
#define LW_GPU_PERF_PSTATES_INFO_VER   LW_GPU_PERF_PSTATES_INFO_VER2

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetPstatesInfo
//
//! DESCRIPTION:     This API retrieves all performance states (P-States) information.
//!
//!                  P-States are GPU active/exelwting performance capability and power consumption states.
//!                  P-States range from P0 to P15, with P0 being the highest performance/power state, and
//!                  P15 being the lowest performance/power state. Each P-State, if available, maps to a
//!                  performance level. Not all P-States are available on a given system. The definition
//!                  of each P-States are lwrrently as follow:
//!                  - P0/P1 - Maximum 3D performance
//!                  - P2/P3 - Balanced 3D performance-power
//!                  - P8 - Basic HD video playback
//!                  - P10 - DVD playback
//!                  - P12 - Minimum idle power consumption
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 185
//!
//! \param [in]   hPhysicalGPU   GPU selection.
//! \param [out]  pPerfPstates   P-States information retrieved, as detailed below:
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_HANDLE_ILWALIDATED 
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE 
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  The version of the LW_GPU_PERF_PSTATES struct is not supported
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPstatesInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_PERF_PSTATES_INFO *pPerfPstatesInfo);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetPstatesInfoEx
//
//! DESCRIPTION:     This API retrieves all performance states (P-States) information. This is the same as
//!                  LwAPI_GPU_GetPstatesInfo(), but supports an input flag for various options.
//!
//!                  P-States are GPU active/exelwting performance capability and power consumption states.
//!
//!                  P-States ranges from P0 to P15, with P0 being the highest performance/power state, and
//!                  P15 being the lowest performance/power state. Each P-State, if available, maps to a
//!                  performance level. Not all P-States are available on a given system. The definitions
//!                  of each P-State are lwrrently as follows: \n
//!                  - P0/P1 - Maximum 3D performance
//!                  - P2/P3 - Balanced 3D performance-power
//!                  - P8 - Basic HD video playback
//!                  - P10 - DVD playback
//!                  - P12 - Minimum idle power consumption
//!
//! \deprecated  Do not use this function - it is deprecated in release 304. Instead, use LwAPI_GPU_GetPstates20.
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \param [in]     hPhysicalGPU       GPU selection.
//! \param [out]    pPerfPstatesInfo   P-States information retrieved, as detailed below: \n
//!                  - flags is reserved for future use.
//!                  - numPstates is the number of available P-States
//!                  - numClocks is the number of clock domains supported by each P-State
//!                  - pstates has valid index range from 0 to numPstates - 1
//!                  - pstates[i].pstateId is the ID of the P-State,
//!                      containing the following info:
//!                    - pstates[i].flags containing the following info:
//!                        - bit 0 indicates if the PCIE limit is GEN1 or GEN2
//!                        - bit 1 indicates if the Pstate is overclocked or not
//!                        - bit 2 indicates if the Pstate is overclockable or not
//!                    - pstates[i].clocks has valid index range from 0 to numClocks -1
//!                    - pstates[i].clocks[j].domainId is the public ID of the clock domain,
//!                        containing the following info:
//!                      - pstates[i].clocks[j].flags containing the following info:
//!                          bit 0 indicates if the clock domain is overclockable or not
//!                      - pstates[i].clocks[j].freq is the clock frequency in kHz
//!                    - pstates[i].voltages has a valid index range from 0 to numVoltages - 1
//!                    - pstates[i].voltages[j].domainId is the ID of the voltage domain,
//!                        containing the following info:
//!                      - pstates[i].voltages[j].flags is reserved for future use.
//!                      - pstates[i].voltages[j].mvolt is the voltage in mV
//!                  inputFlags(IN)   - This can be used to select various options:
//!                    - if bit 0 is set, pPerfPstatesInfo would contain the default settings
//!                        instead of the current, possibily overclocked settings.
//!                    - if bit 1 is set, pPerfPstatesInfo would contain the maximum clock 
//!                        frequencies instead of the nominal frequencies.
//!                    - if bit 2 is set, pPerfPstatesInfo would contain the minimum clock 
//!                        frequencies instead of the nominal frequencies.
//!                    - all other bits must be set to 0.
//!
//! \retval ::LWAPI_OK                            Completed request
//! \retval ::LWAPI_ERROR                         Miscellaneous error oclwrred
//! \retval ::LWAPI_HANDLE_ILWALIDATED            Handle passed has been ilwalidated (see user guide)
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the LW_GPU_PERF_PSTATES struct is not supported
//!
//! \ingroup gpupstate 
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 304. Instead, use LwAPI_GPU_GetPstates20.")
LWAPI_INTERFACE LwAPI_GPU_GetPstatesInfoEx(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_PERF_PSTATES_INFO *pPerfPstatesInfo, LwU32 inputFlags);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_SetPstatesInfo
//
//! DESCRIPTION:     This API set the performance states (P-States) of the specified GPU.
//!
//!                  P-States are GPU active/exelwting performance capability and power consumption states.
//!                  P-States ranges from P0 to P15, with P0 being the highest performance/power state, and
//!                  P15 being the lowest performance/power state. Each P-State, if available, maps to a
//!                  performance level. Not all P-States are available on a given system. The definition
//!                  of each P-States are lwrrently as follow:
//!                    - P0/P1 - Maximum 3D performance
//!                    - P2/P3 - Balanced 3D performance-power
//!                    - P8 - Basic HD video playback
//!                    - P10 - DVD playback
//!                    - P12 - Minimum idle power consumption
//!
//!                  The changes this API makes are *not* persistent across a driver unload or reboot.  
//!                  Client applications must handle enforcing persistence.  However, client apps should
//!                  also be careful not to persist bad pstate configurations across reboots (i.e. if the
//!                  bad pstate configuration hangs the chip and the client application always applies that
//!                  configuration on boot, the user will never be able to boot and revert those changes
//!                  without booting to safe mode).
//!
//!                  NOTE: This API was introduced starting with LW_GPU_PERF_PSTATES_INFO structure version 
//!                  LW_GPU_PERF_PSTATES_INFO_VER2.  This API must be called with structure version 
//!                  >= LW_GPU_PERF_PSTATES_INFO_VER2.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \param [in]      hPhysicalGPU   GPU selection.
//! \param [in]      pPerfPstates   P-States information retrieved, as detailed below:
//!                  - flags is reserved for future use.
//!                  - numPstates the number of p-states specified
//!                  - numClocks is the number of clock domains specified in each p-state.
//!                  - numVoltages is the number of voltage domains specified in each p-State
//!                  - pstates has valid index range from 0 to numPstates - 1
//!                  - pstates[i].pstateId is the ID of the P-State,
//!                      containing the following info:
//!                    - pstates[i].flags is reserved for future use
//!                    - pstates[i].clocks has valid index range from 0 to numClocks -1
//!                    - pstates[i].clocks[j].domainId is the public ID of the clock domain,
//!                        containing the following info:
//!                      - pstates[i].clocks[j].flags is reserved for future use.
//!                      - pstates[i].clocks[j].freq is the clock frequency in kHz
//!                    - pstates[i].voltages has a valid index range from 0 to numVoltages - 1
//!                    - pstates[i].voltages[j].domainId is the ID of the voltage domain,
//!                        containing the following info:
//!                      - pstates[i].voltages[j].flags is reserved for future use.
//!                      - pstates[i].voltages[j].mvolt is the voltage in mV
//!
//! \retval ::LWAPI_OK - completed request
//! \retval ::LWAPI_ERROR - miscellaneous error oclwrred
//! \retval ::LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the LW_GPU_PERF_PSTATES struct is not supported
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetPstatesInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_PERF_PSTATES_INFO *pPerfPstatesInfo);


//! \addtogroup gpupstate
//! @{

#define LWAPI_MAX_GPU_PSTATE20_PSTATES          16
#define LWAPI_MAX_GPU_PSTATE20_CLOCKS           8
#define LWAPI_MAX_GPU_PSTATE20_BASE_VOLTAGES    4

//! Used to identify clock type
typedef enum
{
    //! Clock domains that use single frequency value within given pstate
    LWAPI_GPU_PERF_PSTATE20_CLOCK_TYPE_SINGLE = 0,

    //! Clock domains that allow range of frequency values within given pstate
    LWAPI_GPU_PERF_PSTATE20_CLOCK_TYPE_RANGE,
} LW_GPU_PERF_PSTATE20_CLOCK_TYPE_ID;

//! Used to describe both voltage and frequency deltas
//! Fields marked with [SET] must be populated when making LwAPI_GPU_SetPstates20() call.
typedef struct
{
    //! [SET] 
    //! Value of parameter delta (in respective units [kHz, uV])
    LwS32       value;

    struct
    {
        //! Min value allowed for parameter delta (in respective units [kHz, uV])
        LwS32   min;

        //! Max value allowed for parameter delta (in respective units [kHz, uV])
        LwS32   max;
    } valueRange;
} LW_GPU_PERF_PSTATES20_PARAM_DELTA;

//! Used to describe single clock entry
//! Fields marked with [SET] must be populated when making LwAPI_GPU_SetPstates20() call.
typedef struct
{
    //! [SET] 
    //! ID of the clock domain
    LW_GPU_PUBLIC_CLOCK_ID                      domainId;

    //! Clock type ID
    LW_GPU_PERF_PSTATE20_CLOCK_TYPE_ID          typeId;
    //! Set if this clock domain can be modified using LwAPI_GPU_SetPstates20() call,
    //! otherwise it is cleared
    LwU32                                       bIsEditable:1;

    //! These bits are reserved for future use (must be always 0)
    LwU32                                       reserved:31;

    //! [SET] 
    //! Current frequency delta from nominal settings in (kHz)
    LW_GPU_PERF_PSTATES20_PARAM_DELTA           freqDelta_kHz;

    //! Clock domain type dependant information
    union
    {
        struct
        {
            //! Clock frequency within given pstate in (kHz)
            LwU32                               freq_kHz;
        } single;

        struct
        {
            //! Min clock frequency within given pstate in (kHz)
            LwU32                               minFreq_kHz;

            //! Max clock frequency within given pstate in (kHz)
            LwU32                               maxFreq_kHz;

            //! Voltage domain ID and value range in (uV) required for this clock
            LW_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID  domainId;
            LwU32                               milwoltage_uV;
            LwU32                               maxVoltage_uV;
        } range;
    } data;
} LW_GPU_PSTATE20_CLOCK_ENTRY_V1;

//! Used to describe single base voltage entry
//! Fields marked with [SET] must be populated when making LwAPI_GPU_SetPstates20() call.
typedef struct
{
    //! [SET] 
    //! ID of the voltage domain
    LW_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID  domainId;
    //! Set if this voltage domain can be modified using LwAPI_GPU_SetPstates20() call,
    //! otherwise it is cleared
    LwU32                               bIsEditable:1;

    //! These bits are reserved for future use (must be always 0)
    LwU32                               reserved:31;

    //! Current base voltage settings in [uV]
    LwU32                               volt_uV;

    //! [SET] 
    LW_GPU_PERF_PSTATES20_PARAM_DELTA   voltDelta_uV; // Current base voltage delta from nominal settings in [uV]
} LW_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1;

//! Used in LwAPI_GPU_GetPstates20() interface call.
//! Structure is used to retrieve/modify current clock and voltage pstate settings.
//! Fields marked with [SET] must be populated when making LwAPI_GPU_SetPstates20() call.

typedef struct
{
    //! [SET] 
    //! Version info of the structure (LW_GPU_PERF_PSTATES20_INFO_VER<n>)
    LwU32   version; 

    //! Set if at least one pstate parameter (clock and/or voltage) on this GPU
    //! can be modified using LwAPI_GPU_SetPstates20() call, otherwise it is cleared
    LwU32   bIsEditable:1;

    //! These bits are reserved for future use (must be always 0)
    LwU32   reserved:31;

    //! [SET] 
    //! Number of populated pstates
    LwU32   numPstates;

    //! [SET] 
    //! Number of populated clocks (per pstate)
    LwU32   numClocks;

    //! [SET] 
    //! Number of populated base voltages (per pstate)
    LwU32   numBaseVoltages;

    //! Performance state (P-State) settings
    //! Valid index range is 0 to numPstates-1
    struct
    {
    //! [SET] 
    //! ID of the P-State
        LW_GPU_PERF_PSTATE_ID                   pstateId;

        //! Set if at least one parameter (clock and/or voltage) within this pstate
        //! can be modified using LwAPI_GPU_SetPstates20() call, otherwise it is cleared
        LwU32                                   bIsEditable:1;

        //! These bits are reserved for future use (must be always 0)
        LwU32                                   reserved:31;

        //! Array of clock entries
        //! Valid index range is 0 to numClocks-1
        LW_GPU_PSTATE20_CLOCK_ENTRY_V1          clocks[LWAPI_MAX_GPU_PSTATE20_CLOCKS];

        //! Array of baseVoltage entries
        //! Valid index range is 0 to numBaseVoltages-1
        LW_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1   baseVoltages[LWAPI_MAX_GPU_PSTATE20_BASE_VOLTAGES];
    } pstates[LWAPI_MAX_GPU_PSTATE20_PSTATES];
} LW_GPU_PERF_PSTATES20_INFO_V1;

//! Used in LwAPI_GPU_GetPstates20() interface call.
//! Structure is used to retrieve/modify current clock and voltage pstate settings.
//! Fields marked with [SET] must be populated when making LwAPI_GPU_SetPstates20() call.

typedef struct _LW_GPU_PERF_PSTATES20_INFO_V2
{
    //! [SET] 
    //! Version info of the structure (LW_GPU_PERF_PSTATES20_INFO_VER<n>)
    LwU32   version; 

    //! Set if at least one pstate parameter (clock and/or voltage) on this GPU
    //! can be modified using LwAPI_GPU_SetPstates20() call, otherwise it is cleared
    LwU32   bIsEditable:1;

    //! These bits are reserved for future use (must be always 0)
    LwU32   reserved:31;

    //! [SET] 
    //! Number of populated pstates
    LwU32   numPstates;

    //! [SET] 
    //! Number of populated clocks (per pstate)
    LwU32   numClocks;

    //! [SET] 
    //! Number of populated base voltages (per pstate)
    LwU32   numBaseVoltages;

    //! Performance state (P-State) settings
    //! Valid index range is 0 to numPstates-1
    struct
    {
    //! [SET] 
    //! ID of the P-State
        LW_GPU_PERF_PSTATE_ID                   pstateId;

        //! Set if at least one parameter (clock and/or voltage) within this pstate
        //! can be modified using LwAPI_GPU_SetPstates20() call, otherwise it is cleared
        LwU32                                   bIsEditable:1;

        //! These bits are reserved for future use (must be always 0)
        LwU32                                   reserved:31;

        //! Array of clock entries
        //! Valid index range is 0 to numClocks-1
        LW_GPU_PSTATE20_CLOCK_ENTRY_V1          clocks[LWAPI_MAX_GPU_PSTATE20_CLOCKS];

        //! Array of baseVoltage entries
        //! Valid index range is 0 to numBaseVoltages-1
        LW_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1   baseVoltages[LWAPI_MAX_GPU_PSTATE20_BASE_VOLTAGES];
    } pstates[LWAPI_MAX_GPU_PSTATE20_PSTATES];

    //! OV settings - Please refer to LWPU over-volting recommendation to understand impact of this functionality
    //! Valid index range is 0 to numVoltages-1
    struct
    {
        //! [SET] 
        //! Number of populated voltages
        LwU32                                 numVoltages;

        //! Array of voltage entries
        //! Valid index range is 0 to numVoltages-1
        LW_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1 voltages[LWAPI_MAX_GPU_PSTATE20_BASE_VOLTAGES];
    } ov;
} LW_GPU_PERF_PSTATES20_INFO_V2;

typedef LW_GPU_PERF_PSTATES20_INFO_V2   LW_GPU_PERF_PSTATES20_INFO;

//! Macro for constructing the version field of LW_GPU_PERF_PSTATES20_INFO_V1
#define LW_GPU_PERF_PSTATES20_INFO_VER1 MAKE_LWAPI_VERSION(LW_GPU_PERF_PSTATES20_INFO_V1,1)

//! Macro for constructing the version field of LW_GPU_PERF_PSTATES20_INFO_V2
#define LW_GPU_PERF_PSTATES20_INFO_VER2 MAKE_LWAPI_VERSION(LW_GPU_PERF_PSTATES20_INFO_V2,2)

//! Macro for constructing the version field of LW_GPU_PERF_PSTATES20_INFO
#define LW_GPU_PERF_PSTATES20_INFO_VER  LW_GPU_PERF_PSTATES20_INFO_VER2

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetPstates20
//
//! DESCRIPTION:    This API retrieves all performance states (P-States) 2.0 information.
//!
//!                 P-States are GPU active/exelwting performance capability states.
//!                 They range from P0 to P15, with P0 being the highest performance state,
//!                 and P15 being the lowest performance state. Each P-State, if available,
//!                 maps to a performance level. Not all P-States are available on a given system.
//!                 The definition of each P-States are lwrrently as follow:
//!                 - P0/P1 - Maximum 3D performance
//!                 - P2/P3 - Balanced 3D performance-power
//!                 - P8 - Basic HD video playback
//!                 - P10 - DVD playback
//!                 - P12 - Minimum idle power consumption
//!
//! TCC_SUPPORTED
//!
//! \since Release: 295
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hPhysicalGPU  GPU selection
//! \param [out]  pPstatesInfo  P-States information retrieved, as dolwmented in declaration above
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPstates20(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_PERF_PSTATES20_INFO *pPstatesInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_SetPstates20
//
//! DESCRIPTION:    This API sets the performance states (P-States) 2.0 information.
//!                 This API can modify only parameters (frequencies/voltages) that
//!                 support overrides by specifying delta offset to the parameter's nominal
//!                 value (as advertized in the flags of given parameter).
//!                 It replaces existing deprecated API calls LwAPI_GPU_SetPstatesInfo().
//!
//!                 Note: Only fields marked as [SET] are required to be populated within
//!                       the LW_GPU_PERF_PSTATES20_INFO structure before calling this API.
//!                 Note: Call expects correctly populated structure, and obsolete voltage
//!                       and/or clock entries can be ignored providing _UNDEFINDED ID-s
//!                       (LWAPI_GPU_PERF_VOLTAGE_INFO_DOMAIN_UNDEFINED or
//!                        LWAPI_GPU_PUBLIC_CLOCK_UNDEFINED respectively)
//!
//!                 P-States are GPU active/exelwting performance capability states.
//!                 They range from P0 to P15, with P0 being the highest performance state,
//!                 and P15 being the lowest performance state. Each P-State, if available,
//!                 maps to a performance level. Not all P-States are available on a given system.
//!                 The definition of each P-States are lwrrently as follow:
//!                 - P0/P1 - Maximum 3D performance
//!                 - P2/P3 - Balanced 3D performance-power
//!                 - P8 - Basic HD video playback
//!                 - P10 - DVD playback
//!                 - P12 - Minimum idle power consumption
//!
//! \since Release: 295
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hPhysicalGPU  GPU selection
//! \param [out]  pPstatesInfo  P-States information to be applied
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//! \retval  LWAPI_NOT_SUPPORTED            at least one requested parameter cannot be modified as requested
//! \retval  LWAPI_ILWALID_USER_PRIVILEGE   the caller does not have administrative privileges
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetPstates20(__in LwPhysicalGpuHandle hPhysicalGpu, __in LW_GPU_PERF_PSTATES20_INFO *pPstatesInfo);




//! \addtogroup gpupstate
//! @{

#define LWAPI_MAX_GPU_PSTATE20_CLOCKS_PRIVATE       16
#define LWAPI_MAX_GPU_PSTATE20_VOLTAGES_PRIVATE      8

//! Used to describe single private clock entry
//! Fields marked with [SET] must be populated when making LwAPI_GPU_SetPstates20Private() call.
typedef struct
{
    //! [SET] ID of the clock domain
    LW_GPU_CLOCK_DOMAIN_ID                      domainId;

    //! Clock usage ID
    LW_GPU_CLOCK_INFO_DOMAIN_PSTATE_USAGE       usage;

    //! Set if this clock domain can be modified using LwAPI_GPU_SetPstates20Private() call,
    //! otherwise it is cleared
    LwU32                                       bIsEditable:1;

    //! These bits are reserved for future use (must be always 0)
    LwU32                                       reserved:31;

    //! [SET] Current frequency delta from nominal settings in [kHz]
    LW_GPU_PERF_PSTATES20_PARAM_DELTA           freqDelta_kHz;

    //! Clock usage dependant information
    union
    {
        struct
        {
            //! Clock frequency in (kHz)
            LwU32                               freq_kHz;
        } fixed;

        struct
        {
            //! Clock frequency within given pstate in (kHz)
            LwU32                               freq_kHz;
        } pstate;

        struct
        {
            //! Min clock frequency withing given pstate in (kHz)
            LwU32                               minFreq_kHz;

            //! Max clock frequency withing given pstate in (kHz)
            LwU32                               maxFreq_kHz;

            //! Voltage domain ID and value range in (uV) required for this clock
            LW_GPU_PERF_VOLTAGE_DOMAIN_ID       domainId;
            LwU32                               milwoltage_uV;
            LwU32                               maxVoltage_uV;
        } decoupled;

        struct
        {
            //! Min clock frequency withing given pstate in (kHz)
            LwU32                               minFreq_kHz;

            //! Max clock frequency withing given pstate in (kHz)
            LwU32                               maxFreq_kHz;
        } ratio;
    } data;
} LW_GPU_PSTATE20_PRIVATE_CLOCK_ENTRY_V1;

typedef enum _LW_GPU_PSTATE20_VOLTAGE_ENTRY_TYPE
{
    LW_GPU_PSTATE20_VOLTAGE_ENTRY_TYPE_LOGICAL    = 0x0,
    LW_GPU_PSTATE20_VOLTAGE_ENTRY_TYPE_VDT        = 0x1,
    LW_GPU_PSTATE20_VOLTAGE_ENTRY_TYPE_DELTA_ONLY = 0x2,
} LW_GPU_PSTATE20_VOLTAGE_ENTRY_TYPE;

//! Used to describe single private voltage entry
//! Fields marked with [SET] must be populated when making LwAPI_GPU_SetPstates20Private() call.
typedef struct
{
    //! [SET] ID of the voltage domain
    LW_GPU_PERF_VOLTAGE_DOMAIN_ID       domainId;

    //! [SET] Votage type ID
    LW_GPU_PSTATE20_VOLTAGE_ENTRY_TYPE  type;

    //! Set if this voltage domain can be modified using LwAPI_GPU_SetPstates20Private() call,
    //! otherwise it is cleared
    LwU32                               bIsEditable:1;

    //! These bits are reserved for future use (must be always 0)
    LwU32                               reserved:31;

    //! Current voltage settings, evaluated in [uV]
    LwU32                               volt_uV;

    //! [SET] Current voltage delta from nominal settings in [uV]
    LW_GPU_PERF_PSTATES20_PARAM_DELTA   voltDelta_uV;

    //! Voltage type dependant information
    union
    {
        struct
        {
            //! [SET] Nominal voltage settings in [uV]
            LwU32                       nominal_uV;
        } logical;

        struct
        {
            //! [SET] Nominal voltage settings as index to VDT
            LwU8                        vdtIndex;
        } vdt;

        //! Voltage type _DELTA_ONLY does not require additional information
    } data;
} LW_GPU_PSTATE20_VOLTAGE_ENTRY_V1;

//! Used in LwAPI_GPU_GetPstates20Private()/LwAPI_GPU_SetPstates20Private() interface calls.
//! Structure is used to retrieve/modify current clock and voltage pstate settings.
//! Fields marked with [SET] must be populated when making LwAPI_GPU_SetPstates20Private() call.
typedef struct
{
    //! [SET] Version info of the structure (LW_GPU_PERF_PSTATES20_PRIVATE_INFO_VER<n>)
    LwU32   version;

    //! Set if at least one pstate parameter (clock and/or voltage) on this GPU
    //! can be modified using LwAPI_GPU_SetPstates20Private() call, otherwise it is cleared
    LwU32   bIsEditable:1;

    //! These bits are reserved for future use (must be always 0)
    LwU32   reserved:31;

    //! [SET] Number of populated pstates
    LwU32   numPstates;

    //! [SET] Number of populated clocks (per pstate)
    LwU32   numClocks;

    //! [SET] Number of populated voltages (per pstate)
    LwU32   numVoltages;

    //! Performance state (P-State) settings
    //! Valid index range is 0 to numPstates-1
    struct
    {
        //! [SET] ID of the P-State
        LW_GPU_PERF_PSTATE_ID                   pstateId;

        //! Set if at least one parameter (clock and/or voltage) within this pstate can be
        //! modified using LwAPI_GPU_SetPstates20Private() call, otherwise it is cleared
        LwU32                                   bIsEditable:1;

        //! These bits are reserved for future use (must be always 0)
        LwU32                                   reserved:31;

        //! Array of clock entries
        //! Valid index range is 0 to numClocks-1
        LW_GPU_PSTATE20_PRIVATE_CLOCK_ENTRY_V1  clocks[LWAPI_MAX_GPU_PSTATE20_CLOCKS_PRIVATE];

        //! Array of voltage entries
        //! Valid index range is 0 to numVoltages-1
        LW_GPU_PSTATE20_VOLTAGE_ENTRY_V1        voltages[LWAPI_MAX_GPU_PSTATE20_VOLTAGES_PRIVATE];
    } pstates[LWAPI_MAX_GPU_PSTATE20_PSTATES];
} LW_GPU_PERF_PSTATES20_PRIVATE_INFO_V1;

//! Used in LwAPI_GPU_GetPstates20Private()/LwAPI_GPU_SetPstates20Private() interface calls.
//! Structure is used to retrieve/modify current clock and voltage pstate settings.
//! Fields marked with [SET] must be populated when making LwAPI_GPU_SetPstates20Private() call.
typedef struct _LW_GPU_PERF_PSTATES20_PRIVATE_INFO_V2
{
    //! [SET] Version info of the structure (LW_GPU_PERF_PSTATES20_PRIVATE_INFO_VER<n>)
    LwU32   version;

    //! Set if at least one pstate parameter (clock and/or voltage) on this GPU
    //! can be modified using LwAPI_GPU_SetPstates20Private() call, otherwise it is cleared
    LwU32   bIsEditable:1;

    //! These bits are reserved for future use (must be always 0)
    LwU32   reserved:31;

    //! [SET] Number of populated pstates
    LwU32   numPstates;

    //! [SET] Number of populated clocks (per pstate)
    LwU32   numClocks;

    //! [SET] Number of populated voltages (per pstate)
    LwU32   numVoltages;

    //! Performance state (P-State) settings
    //! Valid index range is 0 to numPstates-1
    struct
    {
        //! [SET] ID of the P-State
        LW_GPU_PERF_PSTATE_ID                   pstateId;

        //! Set if at least one parameter (clock and/or voltage) within this pstate can be
        //! modified using LwAPI_GPU_SetPstates20Private() call, otherwise it is cleared
        LwU32                                   bIsEditable:1;

        //! These bits are reserved for future use (must be always 0)
        LwU32                                   reserved:31;

        //! Array of clock entries
        //! Valid index range is 0 to numClocks-1
        LW_GPU_PSTATE20_PRIVATE_CLOCK_ENTRY_V1  clocks[LWAPI_MAX_GPU_PSTATE20_CLOCKS_PRIVATE];

        //! Array of voltage entries
        //! Valid index range is 0 to numVoltages-1
        LW_GPU_PSTATE20_VOLTAGE_ENTRY_V1        voltages[LWAPI_MAX_GPU_PSTATE20_VOLTAGES_PRIVATE];
    } pstates[LWAPI_MAX_GPU_PSTATE20_PSTATES];

    //! OV settings
    //! Valid index range is 0 to numVoltages-1
    struct
    {
        //! [SET] Number of populated voltages
        LwU32                            numVoltages;

        //! Array of voltage entries
        //! Valid index range is 0 to numVoltages-1
        LW_GPU_PSTATE20_VOLTAGE_ENTRY_V1 voltages[LWAPI_MAX_GPU_PSTATE20_VOLTAGES_PRIVATE];
    } ov;
} LW_GPU_PERF_PSTATES20_PRIVATE_INFO_V2;

typedef LW_GPU_PERF_PSTATES20_PRIVATE_INFO_V2   LW_GPU_PERF_PSTATES20_PRIVATE_INFO;

//! Macro for constructing the version field of LW_GPU_PERF_PSTATES20_PRIVATE_INFO_V1
#define LW_GPU_PERF_PSTATES20_PRIVATE_INFO_VER1 MAKE_LWAPI_VERSION(LW_GPU_PERF_PSTATES20_PRIVATE_INFO_V1,1)

//! Macro for constructing the version field of LW_GPU_PERF_PSTATES20_PRIVATE_INFO_V2
#define LW_GPU_PERF_PSTATES20_PRIVATE_INFO_VER2 MAKE_LWAPI_VERSION(LW_GPU_PERF_PSTATES20_PRIVATE_INFO_V2,2)

//! Macro for constructing the version field of LW_GPU_PERF_PSTATES20_PRIVATE_INFO
#define LW_GPU_PERF_PSTATES20_PRIVATE_INFO_VER  LW_GPU_PERF_PSTATES20_PRIVATE_INFO_VER2

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetPstates20Private
//
//! DESCRIPTION:    This API retrieves all performance states (P-States) 2.0 information,
//!                 as internal/enhanced version of LwAPI_GPU_GetPstates20() NDA call.
//!                 It replaces existing deprecated API calls LwAPI_GPU_GetPstates()
//!                 and LwAPI_GPU_GetPstatesEx().
//!
//!                 P-States are GPU active/exelwting performance capability states.
//!                 They range from P0 to P15, with P0 being the highest performance state,
//!                 and P15 being the lowest performance state. Each P-State, if available,
//!                 maps to a performance level. Not all P-States are available on a given system.
//!                 The definition of each P-States are lwrrently as follow:
//!                 - P0/P1 - Maximum 3D performance
//!                 - P2/P3 - Balanced 3D performance-power
//!                 - P8 - Basic HD video playback
//!                 - P10 - DVD playback
//!                 - P12 - Minimum idle power consumption
//!
//! \since Release: 295
//!
//! TCC_SUPPORTED
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hPhysicalGPU  GPU selection
//! \param [out]  pPstatesInfo  P-States information retrieved, as dolwmented in declaration above
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPstates20Private(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_PERF_PSTATES20_PRIVATE_INFO *pPstatesInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_SetPstates20Private
//
//! DESCRIPTION:    This API sets the performance states (P-States) 2.0 information,
//!                 as internal/enhanced version of LwAPI_GPU_SetPstates20() NDA call.
//!                 This API can modify only parameters (frequencies/voltages) that
//!                 support overrides by specifying delta offset to the parameter's nominal
//!                 value (as advertized in the flags of given parameter).
//!                 It replaces existing deprecated API calls LwAPI_GPU_SetPstates().
//!
//!                 Note: Only fields marked as [SET] are required to be populated within the
//!                       LW_GPU_PERF_PSTATES20_PRIVATE_INFO structure before calling this API.
//!                 Note: Call expects correctly populated structure, and obsolete voltage
//!                       and/or clock entries can be ignored providing _UNDEFINDED ID-s
//!                       (LWAPI_GPU_PERF_VOLTAGE_INFO_DOMAIN_UNDEFINED or
//!                        LWAPI_GPU_PUBLIC_CLOCK_UNDEFINED respectively)
//!
//!                 P-States are GPU active/exelwting performance capability states.
//!                 They range from P0 to P15, with P0 being the highest performance state,
//!                 and P15 being the lowest performance state. Each P-State, if available,
//!                 maps to a performance level. Not all P-States are available on a given system.
//!                 The definition of each P-States are lwrrently as follow:
//!                 - P0/P1 - Maximum 3D performance
//!                 - P2/P3 - Balanced 3D performance-power
//!                 - P8 - Basic HD video playback
//!                 - P10 - DVD playback
//!                 - P12 - Minimum idle power consumption
//!
//! \since Release: 295
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hPhysicalGPU  GPU selection
//! \param [out]  pPstatesInfo  P-States information to be applied
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//!
//! \retval ::LWAPI_NOT_SUPPORTED           - at least one requested parameter cannot be modified as requested
//! \retval ::LWAPI_ILWALID_USER_PRIVILEGE  - the caller does not have administrative privileges
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetPstates20Private(__in LwPhysicalGpuHandle hPhysicalGpu, __in LW_GPU_PERF_PSTATES20_PRIVATE_INFO *pPstatesInfo);



//! \ingroup gpupstate
//! @{

//! Used in \ref LW_GPU_PERF_VF_TABLES_V1.  Describes a VF Indexes Table
//! entry, specifying a range of VF Entries Table entries for a given clock
//! domain and pstate.
#define LW_GPU_PERF_VF_INDEXES_TABLE_MAX_ENTRIES_V1                           64
typedef struct
{
    /*!
     * Pstate for this VF Indexes Table entry.  LWAPI_GPU_PERF_PSTATE_ALL
     * applies to all pstates not otherwise specified for the given clock
     * domain.
     */
    LW_GPU_PERF_PSTATE_ID   pstateId;
    /*!
     * Clock domain for this VF Indexes Table entry.
     */
    LW_GPU_CLOCK_DOMAIN_ID  domainId;
    /*!
     * First index into the VF Entries Table for this pstate and clock domain.
     */
    LwU32                   entryIndexFirst;
    /*!
     * Last index into the VF Entries Table for this pstate and clock domain.
     */
    LwU32                   entryIndexLast;
} LW_GPU_PERF_VF_INDEXES_TABLE_ENTRY_V1;

//! Used in \ref LW_GPU_PERF_VF_TABLES_V1.  Describes a VF Entries Table
//! entry, correlating a maximum frequency point to its required minimum
//! voltage.
#define LW_GPU_PERF_VF_ENTRIES_TABLE_MAX_ENTRIES_V1                           64
#define LW_GPU_PERF_VF_ENTRIES_TABLE_MAX_ENTRIES_V2                          128
#define LW_GPU_PERF_VF_ENTRIES_TABLE_STEP_SIZE_NONE                            0
#define LW_GPU_PERF_VF_ENTRIES_TABLE_STEP_SIZE_ALL                             1
typedef struct
{
    /*!
     * Maximum supported frequency in (KHz) for this VF Entries Table entry.
     */
    LwU32                   maxFreqKHz;
    /*!
     * Step size to use for values below this maximum frequency while still
     * applying this entry.  Note special values
     * LW_GPU_PERF_VF_ENTRIES_TABLE_STEP_SIZE_NONE and
     * LW_GPU_PERF_VF_ENTRIES_TABLE_STEP_SIZE_ALL, which correspond to no steps
     * below and and infinite steps below, respectively.
     */
    LwU32                   freqStepSizeKHz;
    /*!
     * Flags bit field.
     */
    LwU32                   bForcePll:1;       //!< - Clock is forced to source from PLL
    LwU32                   bForceBypass:1;    //!< - Clock is forced to source from bypass
    LwU32                   flags:30;          //!< - Lwrrently unused/reserved. Must be set to 0
    /*!
     * Minimum required voltage for this VF Entries Table entry.
     */
    struct
    {
        LW_GPU_PERF_VOLTAGE_DOMAIN_ID domainId;  //!< ID of the voltage domain
        LwU32                       flags;       //!< -  bit 0 indicates that mvolt is evaluated from VDT
        LwU32                       mvolt;       //!< Voltage level in mV. 
    } voltage;
} LW_GPU_PERF_VF_ENTRIES_TABLE_ENTRY_V1;

//! Used in \ref LwAPI_GPU_PerfVfTablesGetInfo().
typedef struct
{
    /*!
     * Version of this structure.  Must always be first element in this structure.
     */
    LwU32 version;

    /*!
     * Number of VF Indexes Table entries in the indexes array.
     */
    LwU32 numIndexes;
    /*!
     * Array of VF Indexes Table entries.  This array has a valid index range of
     * 0 to numIndexes - 1.
     */
    LW_GPU_PERF_VF_INDEXES_TABLE_ENTRY_V1 indexes[LW_GPU_PERF_VF_INDEXES_TABLE_MAX_ENTRIES_V1];

    /*!
     * Number of VF Entires Table entries in the entries array.
     */
    LwU32 numEntries;
    /*!
     * Array of VF Entries Table entries.  This array has a valid index range of
     * 0 to numEntries - 1.
     */
    LW_GPU_PERF_VF_ENTRIES_TABLE_ENTRY_V1 entries[LW_GPU_PERF_VF_ENTRIES_TABLE_MAX_ENTRIES_V1];
} LW_GPU_PERF_VF_TABLES_V1;

//! Used in \ref LwAPI_GPU_PerfVfTablesGetInfo().
typedef struct _LW_GPU_PERF_VF_TABLES_V2
{
    LwU32 version;           //!< Version of this structure.  Must always be first element in this structure.

    LwU32 numIndexes;        //!< Number of VF Indexes Table entries in the indexes array.
    LW_GPU_PERF_VF_INDEXES_TABLE_ENTRY_V1 indexes[LW_GPU_PERF_VF_INDEXES_TABLE_MAX_ENTRIES_V1]; 
                             //!< Array of VF Indexes Table entries.  This array has a valid index range of 0 to numIndexes - 1.
    LwU32 numEntries;        //!< Number of VF Entires Table entries in the entries array.
    LW_GPU_PERF_VF_ENTRIES_TABLE_ENTRY_V1 entries[LW_GPU_PERF_VF_ENTRIES_TABLE_MAX_ENTRIES_V2]; 
                             //!< Array of VF Entries Table entries.  This array has a valid index range of 0 to numEntries - 1.
} LW_GPU_PERF_VF_TABLES_V2;

typedef LW_GPU_PERF_VF_TABLES_V2 LW_GPU_PERF_VF_TABLES;

//! Macro for constructing the version field of LW_GPU_PERF_VF_TABLES_V1
#define LW_GPU_PERF_VF_TABLES_VER1  MAKE_LWAPI_VERSION(LW_GPU_PERF_VF_TABLES_V1,1)
#define LW_GPU_PERF_VF_TABLES_VER2  MAKE_LWAPI_VERSION(LW_GPU_PERF_VF_TABLES_V2,2)

//! Macro for constructing the version field of LW_GPU_PERF_VF_TABLES
#define LW_GPU_PERF_VF_TABLES_VER   LW_GPU_PERF_VF_TABLES_VER2

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_PerfVfTablesGetInfo
//
//! DESCRIPTION:     This function retrieves the Voltage Frequency (VF) Tables
//!                  which describe various clocks' relationship between voltage
//!                  and frequency across various pstates.
//!
//!                  The Voltage Frequency Indexes Table provides the range of
//!                  indexes into the Voltage Frequency Entries Table for a
//!                  given clock domain in a given pstate.
//!
//!                  The Voltage Frequncy Entries Table provides the mapping
//!                  between various maximum frequency points and the voltages
//!                  required to sustain them.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 285
//!
//! \param [in]      hPhysicalGPU      GPU selection
//! \param [out]     pPerfVfTablesInfo Structure containing the description of the VF tables.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup   gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PerfVfTablesGetInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_PERF_VF_TABLES *pPerfVfTablesInfo);



//! \ingroup gpupstate
//! @{

/*!
 * Structure for static information describing the  RATED_TDP functionality.
 */
typedef struct
{
    /*!
     * Version of this structure.  Must always be first element in this structure.
     */
    LwU32 version;

    /*!
     * Boolean describing whether the RATED_TDP feature is supported on this
     * GPU.
     */
    LwU8  bSupported;
} LW_GPU_PERF_RATED_TDP_INFO_V1;

typedef LW_GPU_PERF_RATED_TDP_INFO_V1 LW_GPU_PERF_RATED_TDP_INFO;

//! Macro for constructing the version field of LW_GPU_PERF_RATED_TDP_INFO_V1
#define LW_GPU_PERF_RATED_TDP_INFO_VER1  MAKE_LWAPI_VERSION(LW_GPU_PERF_RATED_TDP_INFO_V1,1)

//! Macro for constructing the version field of LW_GPU_PERF_RATED_INFO
#define LW_GPU_PERF_RATED_TDP_INFO_VER   LW_GPU_PERF_RATED_TDP_INFO_VER1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_PerfRatedTdpGetInfo
//
//! DESCRIPTION:     This command returns the static state describing the
//!                  RATED_TDP power/perf control capabilities on this GPU per the
//!                  clock/pstate/vpstate POR.
//!
//!                  The RATED_TDP point, specified per the VPstate Table, is
//!                  the maximum sustainable clock and voltage point w.r.t.
//!                  thermal/power for the given TDP app/workload - i.e. the
//!                  highest guaranteed clocks with respect to the various power
//!                  controllers.
//!
//!                  The RM's RATED_TDP functionality exposes the ability for
//!                  various clients to expose or limit VF points above
//!                  RATED_TDP - effectively limiting power-/thermal-aware boost
//!                  (GPUBoost, etc.).  This functionality can be useful to help
//!                  eliminate performance variation for profiling or for
//!                  synchronized workloads.
//!
//!                  https://wiki.lwpu.com/engwiki/index.php/Resman/PState/Data_Tables/VPState_Table
//!                  https://wiki.lwpu.com/engwiki/index.php/Resman/PState/Data_Tables/VPState_Table/1.0_Spec
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release:  313
//!
//! \param [in]      hPhysicalGPU      GPU selection
//! \param [out]     pInfo             Structure containing the description of the RATED_TDP feature.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup   gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PerfRatedTdpGetInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_PERF_RATED_TDP_INFO *pInfo);



//! \ingroup gpupstate
//! @{

/*!
 * Enumeration of the RATED_TDP arbitration clients which make requests to force
 * enable/disable VF points above the RATED_TDP point.
 *
 * These clients are sorted in descending priority - the RM will arbitrate
 * between all clients in order of priority, taking as output the first client
 * whose input action != @ref LW_GPU_PERF_RATED_TDP_ACTION_DEFAULT.
 */
typedef enum
{
    /*!
     * Internal RM client corresponding to the RM's internal state and features.
     * The RM client will either allow default behavior (@ref
     * LW_GPU_PERF_RATED_TDP_ACTION_DEFAULT) or will limit to RATED_TDP
     * (@ref LW_GPU_PERF_RATED_TDP_ACTION_FORCE_LIMIT) when no power
     * controllers are active.
     */
    LW_GPU_PERF_RATED_TDP_CLIENT_RM          = 0x0,
    /*!
     * Global client request.  This client is expected to be used by a global
     * switch functionality in an end-user tool, such as EVGA Precision, to
     * either force enabling boost above RATED_TDP (@ref
     * LW_GPU_PERF_RATED_TDP_ACTION_FORCE_EXCEED) or to force limiting to
     * RATED_TDP (@ref LW_GPU_PERF_RATED_TDP_ACTION_FORCE_LIMIT) across the
     * board, regardless of any app-profie settings.
     */
    LW_GPU_PERF_RATED_TDP_CLIENT_GLOBAL,
    /*!
     * Operating system request.  This client is expected to be used by the
     * operating system to set @ref LW_GPU_PERF_RATED_TDP_ACTION_FORCE_LOCK
     * for performance profiling.
     */
    LW_GPU_PERF_RATED_TDP_CLIENT_OS,
    /*!
     * App profile client requests.  This client is expected to be used by the
     * app-profile settings to either default to whatever was requested by
     * higher-priority clients (@ref LW_GPU_PERF_RATED_TDP_ACTION_DEFAULT)
     * or to limit to RATED_TDP (@ref
     * LW_GPU_PERF_RATED_TDP_ACTION_FORCE_LIMIT) for apps which have shown
     * bad behavior when boosting.
     */
    LW_GPU_PERF_RATED_TDP_CLIENT_PROFILE,
    /*!
     * Number of supported clients.
     *
     * @Note MUST ALWAY BE LAST!
     */
    LW_GPU_PERF_RATED_TDP_CLIENT_NUM_CLIENTS,
} LW_GPU_PERF_RATED_TDP_CLIENT;


/*!
 * Enumeration RATED_TDP actions - these are the requested actions clients can
 * make to change the behavior of the RATED_TDP functionality.
 */
typedef enum
{
    /*!
     * The default action - meaning no explicit request from the client other
     * than to take the default behavior (allowing boosting above RATED_TDP) or
     * any explicit actions from lower priority clients.
     */
    LW_GPU_PERF_RATED_TDP_ACTION_DEFAULT       = 0x0,
    /*!
     * Force allow boosting above RATED_TDP - this action explicitly requests
     * boosting above RATED_TDP, preventing lower priority clients to limit to
     * RATED_TDP.
     */
    LW_GPU_PERF_RATED_TDP_ACTION_FORCE_EXCEED,
    /*!
     * Force to limit above RATED_TDP - this action explicitly requests to limit
     * to RATED_TDP.  This is the opposite of the default behavior to allow
     * boosting above RATED_TDP.  Clients specify this action when they
     * explicitly need boost to be disabled (e.g. eliminating perf variation,
     * special apps which exhibit bad behavior, etc.).
     */
    LW_GPU_PERF_RATED_TDP_ACTION_FORCE_LIMIT,
    /*!
     * Lock to RATED_TDP - this action requests the clocks to be fixed at the
     * RATED_TDP.  Used for acheiving stable clocks required for profiling.
     */
    LW_GPU_PERF_RATED_TDP_ACTION_FORCE_LOCK,
} LW_GPU_PERF_RATED_TDP_ACTION;

/*!
 * Structure describing dynamic state of the RATED_TDP feature.
 */
typedef struct
{
    /*!
     * Version of this structure.  Must always be first element in this structure.
     */
    LwU32 version;

    /*!
     * Structure of internal RM state - these values are used to determine the
     * behavior of LW_GPU_PERF_RATED_TDP_CLIENT_RM per the RM's @ref
     * perfPwrRatedTdpLimitRegisterClientActive() interface.
     */
    struct
    {
        /*!
         * Mask of active client controllers (@ref PERF_PWR_RATED_TDP_CLIENT)
         * which are lwrrently regulating TDP.  When this mask is zero,
         * LW_GPU_PERF_RATED_TDP_CLIENT_RM will request
         * LW_GPU_PERF_RATED_TDP_ACTION_FORCE_LIMIT.
         */
        LwU32 clientActiveMask;
        /*!
         * Boolean indicating that user has requested locking to RATED_TDP
         * vPstate via corresponding regkey LW_REG_STR_RM_PERF_RATED_TDP_LIMIT.
         * When the boolean value is true, LW_GPU_PERF_RATED_TDP_CLIENT_RM
         * will request LW_GPU_PERF_RATED_TDP_ACTION_FORCE_LIMIT.
         */
        LwU8  bRegkeyLimitRatedTdp;
    } rm;

    /*!
     * Arbitrated output action of all client requests (@ref inputs).  This is
     * the current state of the RATED_TDP feature.  Will only be @ref
     * LW_GPU_PERF_RATED_TDP_ACTION_FORCE_EXCEED, @ref
     * LW_GPU_PERF_RATED_TDP_ACTION_FORCE_LIMIT, or @ref
     * LW_GPU_PERF_RATED_TDP_ACTION_FORCE_LOCK.
     */
    LW_GPU_PERF_RATED_TDP_ACTION output;
    /*!
     * Array of input client request actions, indexed via @ref
     * LW_GPU_PERF_RATED_TDP_CLIENT_<xyz>.  RM will arbitrate between these
     * requests, choosing the highest priority request != @ref
     * LW_GPU_PERF_RATED_TDP_ACTION_DEFAULT or fallback to choosing @ref
     * LW_GPU_PERF_RATED_TDP_ACTION_FORCE_EXCEED.
     */
    LW_GPU_PERF_RATED_TDP_ACTION
        inputs[LW_GPU_PERF_RATED_TDP_CLIENT_NUM_CLIENTS];
} LW_GPU_PERF_RATED_TDP_STATUS_V1;

typedef LW_GPU_PERF_RATED_TDP_STATUS_V1 LW_GPU_PERF_RATED_TDP_STATUS;

//! Macro for constructing the version field of LW_GPU_PERF_RATED_TDP_STATUS_V1
#define LW_GPU_PERF_RATED_TDP_STATUS_VER1  MAKE_LWAPI_VERSION(LW_GPU_PERF_RATED_TDP_STATUS_V1,1)

//! Macro for constructing the version field of LW_GPU_PERF_RATED_STATUS
#define LW_GPU_PERF_RATED_TDP_STATUS_VER   LW_GPU_PERF_RATED_TDP_STATUS_VER1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_PerfRatedTdpGetStatus
//
//! DESCRIPTION:     This command returns the dynamic state of the RATED_TDP
//!                  power/perf control feature of this GPU.  This includes
//!                  dumping all client requests for boosting above or limiting
//!                  to RATED_TDP, as well as the current output action for
//!                  boost/limit.
//!
//!                  This command is useful for debugging the state of the
//!                  RATED_TDP feature to figure out which component are
//!                  limiting to RATED_TDP.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release:  313
//!
//! \param [in]      hPhysicalGPU      GPU selection
//! \param [out]     pStatus           Structure containing the dynnamic status of the RATED_TDP feature.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup   gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PerfRatedTdpGetStatus(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_PERF_RATED_TDP_STATUS *pStatus);



//! \ingroup gpupstate
//! @{

/*!
 * Structure containing the requested action for a RATED_TDP client (@ref
 * LW_GPU_PERF_RATED_TDP_CLIENT).
 */
typedef struct
{
    /*!
     * Version of this structure.  Must always be first element in this structure.
     */
    LwU32 version;

    /*!
     * Specified client for request.
     */
    LW_GPU_PERF_RATED_TDP_CLIENT client;
    /*!
     * Client's requested action.
     */
    LW_GPU_PERF_RATED_TDP_ACTION input;
} LW_GPU_PERF_RATED_TDP_CONTROL_V1;

typedef LW_GPU_PERF_RATED_TDP_CONTROL_V1 LW_GPU_PERF_RATED_TDP_CONTROL;

//! Macro for constructing the version field of LW_GPU_PERF_RATED_TDP_INFO_V1
#define LW_GPU_PERF_RATED_TDP_CONTROL_VER1  MAKE_LWAPI_VERSION(LW_GPU_PERF_RATED_TDP_CONTROL_V1,1)

//! Macro for constructing the version field of LW_GPU_PERF_RATED_INFO
#define LW_GPU_PERF_RATED_TDP_CONTROL_VER   LW_GPU_PERF_RATED_TDP_CONTROL_VER1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_PerfRatedTdpGetControl
//
//! DESCRIPTION:     This command retrieves the current requested RATED_TDP
//!                  action corresponding to the specified client.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release:  313
//!
//! \param [in]      hPhysicalGPU      GPU selection
//! \param [out]     pControl          Structure containing the control values for the specified client.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup   gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PerfRatedTdpGetControl(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_PERF_RATED_TDP_CONTROL *pControl);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_PerfRatedTdpSetControl
//
//! DESCRIPTION:     This command sets the requested RATED_TDP action
//!                  corresponding to the specified client.  @Note, however,
//!                  that this command is unable to set @ref LW_GPU_PERF_RATED_TDP_CLIENT_RM.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release:  313
//!
//! \param [in]      hPhysicalGPU      GPU selection
//! \param [out]     pControl          Structure containing the control values for the specified client.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup   gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PerfRatedTdpSetControl(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_PERF_RATED_TDP_CONTROL *pControl);




//! \ingroup gpupstate
//! @{

/*!
 * LW_GPU_VDT_INFO_V1 represents version one of the Voltage Descriptor Table Header.
 * The VDT Header stores some general information about the table and some hardware
 * parameter information.
 */
typedef struct
{
    /*!
     * Version of this structure.  Must always be first element in this structure.
     */
    LwU32                           version;

    /*!
     * Cached HW SPEEDO fuse.  Used in VDT/CVB callwlations to callwlate target
     * voltage.
     */
    LwU32                           hwSpeedo;

    /*!
     * Cached HW SPEEDO version fuse.  Compared against the VDT speedo version
     * value to confirm the units of the SPEEDO fuse match the expectation for
     * the VDT/CVB callwlations.
     */
    LwU32                           hwSpeedoVersion;

    /*!
     * SPEEDO version to be used for this table.  Will be compared against a HW
     * fuse to confirm the units of the SPEEDO fuse match the expectation for
     * the VDT/CVB callwlations.
     */
    LwU32                           speedoVersion;

    /*!
     * Polling period for re-evaluating any temperature-based requested
     * voltages.
     */
    LwU16                           tempPollingPeriodms;

    /*!
     * Number of VDT entries in the table.
     */
    LwU8                            numEntries;

    /*!
     * Original/nominal P0 voltage before voltage tuning.  This is a legacy
     * feature from GF100 voltage tuning to increase yields due to fabric
     * issues.
     */
    LwU8                            nominalP0VdtEntry;

    /*!
     * Voltage Reliability Limit entry - index into table for entry specifying
     * the maximum reliability limit of the silicon.
     * VOLTAGE_DESCRIPTOR_TABLE_ENTRY_ILWALID/0xFF = none.
     */
    LwU8                            reliabilityLimitEntry;

    /*!
     * User Over-Voltage Limit entry - index into table for entry specifying
     * the maximum user over-voltage limit.
     * VOLTAGE_DESCRIPTOR_TABLE_ENTRY_ILWALID/0xFF = none.
     */
    LwU8                            overVoltageLimitEntry;

    /*!
     * Voltage Tuning Entry - index into table for entry reserved for tuning
     * voltage with a delta value.
     * VOLTAGE_DESCRIPTOR_TABLE_ENTRY_ILWALID/0xFF = none.
     */
    LwU8                            voltageTuningEntry;
} LW_GPU_VDT_INFO_V1;

typedef LW_GPU_VDT_INFO_V1 LW_GPU_VDT_INFO;

//! Macro for constructing the version field of LW_GPU_VDT_INFO_V1
#define LW_GPU_VDT_INFO_VER1  MAKE_LWAPI_VERSION(LW_GPU_VDT_INFO_V1,1)

//! Macro for constructing the version field of LW_GPU_VDT_INFO
#define LW_GPU_VDT_INFO_VER   LW_GPU_VDT_INFO_VER1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_VdtGetInfo
//
//! DESCRIPTION:     This function retrieves the Voltage Descriptor Table Header
//!                  which provides general settings for the voltage callwlation
//!                  based on Voltage Descriptor Table.
//!
//!                  Voltage Descriptor Table provides information on the number
//!                  of VDT Entries, voltage limits, hardware parameter infomation,
//!                  polling period, and Voltage Tuning Entry.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 295.xx
//!
//! \param [in]      hPhysicalGPU      GPU selection
//! \param [out]     pVdtInfo          Structure containing the description of 
//!                                    VDT Header.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup   gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_VdtGetInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_VDT_INFO *pVdtInfo);

//! \ingroup gpupstate
//! @{

#define LW_GPU_VDT_ENTRY_INFO_MAX_ENTRIES_V1                                 128

typedef enum
{
    LW_GPU_VDT_ENTRY_TYPE_CVB10 = 0x0,
    LW_GPU_VDT_ENTRY_TYPE_CVB20,
    LW_GPU_VDT_ENTRY_TYPE_CVB10_DPA,
    LW_GPU_VDT_ENTRY_TYPE_MAX,
    LW_GPU_VDT_ENTRY_TYPE_UNKNOWN = 0xFFFFFFFF
} LW_GPU_VDT_ENTRY_TYPE;

//! This structure contains CVB10 specific coefficients
typedef struct
{
    /*!
     * Signed 32-bit coefficient0 (0.1 uV).  Stored as signed 64-bit to expedite
     * 64-bit callwlations.
     */
    LwS64     coefficient0;
    /*!
     * Signed 32-bit coefficient1 (0.1 uV).  Stored as signed 64-bit to expedite
     * 64-bit callwlations.
     */
    LwS64     coefficient1;
    /*!
     * Signed 32-bit coefficient2 (0.00001 uV).  Stored as signed 64-bit to
     * expedite 64-bit callwlations.
     */
    LwS64     coefficient2;
} LW_GPU_VDT_ENTRY_INFO_DATA_CVB10;

//! This structure contains CVB20 specific coefficients
typedef struct
{
    /*!
     * Second-order Coefficient 5 (V / C^2_adj, F8.24 signed)
     *
     * term5 = coefficient5 * tjSqAdj
     */
    LwS32     coefficient5;

    /*!
     * Second-order Coefficient 4 (V, F8.24 signed)
     *
     * term4 = coefficient4 * speedoSqAdj
     */
    LwS32     coefficient4;

    /*!
     * First-order Coefficient 3 (V / C, F16.16 signed)
     *
     * term3 = coefficient3 * tj * speedo
     */
    LwS32    coefficient3;

    /*!
     * First-order Coefficient 2 (V / C, F16.16 signed)
     *
     * term2 = coefficient2 * tj
     */
    LwS32    coefficient2;

    /*!
     * First-order Coefficient 1 (V, F8.24 signed)
     *
     * term1 = coefficient1 * speedo
     */
    LwS32     coefficient1;

    /*!
     * Constant Term Coefficient 0 (V, F8.24 signed)
     *
     * term= coefficient0
     */
    LwS32     coefficient0;
} LW_GPU_VDT_ENTRY_INFO_DATA_CVB20;

//! This structure contains CVB10 Double-Precision Adjustment specific coefficients
typedef struct _LW_GPU_VDT_ENTRY_INFO_DATA_CVB10_DPA
{
    /*!
     * Signed 32-bit coefficient0 (0.1 uV).  Stored as signed 64-bit to expedite
     * 64-bit callwlations.
     */
    LwS64     coefficient0;
    /*!
     * Signed 32-bit coefficient1 (0.1 uV).  Stored as signed 64-bit to expedite
     * 64-bit callwlations.
     */
    LwS64     coefficient1;
    /*!
     * Signed 32-bit coefficient2 (0.00001 uV).  Stored as signed 64-bit to
     * expedite 64-bit callwlations.
     */
    LwS64     coefficient2;
} LW_GPU_VDT_ENTRY_INFO_DATA_CVB10_DPA;

//! This structure contains VDT MAX class indexes
typedef struct _LW_GPU_VDT_ENTRY_INFO_DATA_MAX
{
    /*!
     * Represents the first VDT entry index evaluated by VDT class MAX.
     * Bits 7:0 of coefficient0
     */
    LwU8 index0;

    /*!
     * Represents the second  VDT entry index evaluated by VDT class MAX.
     * Bits 15:8 of coefficient0
     */
    LwU8 index1;
} LW_GPU_VDT_ENTRY_INFO_DATA_MAX;

typedef union
{
    LW_GPU_VDT_ENTRY_INFO_DATA_CVB10     cvb10;
    LW_GPU_VDT_ENTRY_INFO_DATA_CVB20     cvb20;
    LW_GPU_VDT_ENTRY_INFO_DATA_CVB10_DPA cvb10Dpa;
    LW_GPU_VDT_ENTRY_INFO_DATA_MAX       vdtMax;
} LW_GPU_VDT_ENTRY_INFO_DATA;

/*!
 * This structure represent version one of a single Voltage Descriptor Table
 * entry. It contains necessary information for callwlating a voltage.
 */
typedef struct
{
    /*!
     * VDT table entry index
     */

    LwU8   index;
    /*!
     * The voltage callwlated based this VDT entry and all the ones
     * linked to it.
     * This value is bounded to what the voltage regulator can support,
     * and will be bound to 0 if it's negative.
     */
    LwU32  lwrrTargetVoltageuV;

    /*!
     * The voltage callwlated based only on the current VDT entry.
     * This value is unbounded, so it could be a negative value.
     */
    LwS32  localUnboundVoltageuV;

    /*!
     * Pointer to the next entry in the linked list to evaluate.
     */
    LwU8  nextEntry;

    /*!
     * Minimum voltage (uV) to bound the output of this entry
     */
    LwS32 voltageMinuV;

    /*!
     * Maximum voltage (uV) to bound the output of this entry
     */
    LwS32 voltageMaxuV;

    /*!
     * CVB Table Type, lwrrently there are only CVB10 and CVB20
     */
    LW_GPU_VDT_ENTRY_TYPE type;

    /*!
     * Union of CVB10 and CVB20 coefficients
     */
    LW_GPU_VDT_ENTRY_INFO_DATA data;
} LW_GPU_VDT_ENTRY_INFO_V1;

typedef struct
{
    /*!
     * Version of this structure.  Must always be first element in this structure.
     */
    LwU32 version;

    /*!
     * Number of entries to the client wants to access.
     * 0 means all available entries.
     */
    LwU32 numEntries;

    /*!
     * Array of VDT table entries
     */
    LW_GPU_VDT_ENTRY_INFO_V1 entries[LW_GPU_VDT_ENTRY_INFO_MAX_ENTRIES_V1];
} LW_GPU_VDT_ENTRIES_INFO_V1;

typedef LW_GPU_VDT_ENTRIES_INFO_V1 LW_GPU_VDT_ENTRIES_INFO;

//! Macro for constructing the version field of LW_GPU_VDT_ENTRIES_INFO_V1
#define LW_GPU_VDT_ENTRIES_INFO_VER1  MAKE_LWAPI_VERSION(LW_GPU_VDT_ENTRIES_INFO_V1,1)

//! Macro for constructing the version field of LW_GPU_VDT_ENTRIES_INFO
#define LW_GPU_VDT_ENTRIES_INFO_VER   LW_GPU_VDT_ENTRIES_INFO_VER1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_VdtEntriesGetInfo
//
//! DESCRIPTION:     This function retrieves the Voltage Descriptor Table Entries
//!                  which provide coefficients and min/max limits for callwlating
//!                  voltage, as well as pointer to the VDT entry in the linked list.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 295.xx
//!
//! \param [in]      hPhysicalGPU      GPU selection
//! \param [out]     pVdtEntriesInfo   Structure that describes the VDT Entries
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup   gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_VdtEntriesGetInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_VDT_ENTRIES_INFO *pVdtEntriesInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_VdtEntriesSetInfo
//
//! DESCRIPTION:     This function mutates the VDT Entries based on the
//!                  client's input VDT Entries.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 295.xx
//!
//! \param [in]      hPhysicalGPU      GPU selection
//! \param [out]     pPerfVfTablesInfo Structure containing the description of the VF tables.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup   gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_VdtEntriesSetInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __in LW_GPU_VDT_ENTRIES_INFO *pVdtEntriesInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetLwrrentPstate
//
//! DESCRIPTION:     This function retrieves the current performance state (P-State).
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 165
//!
//! TCC_SUPPORTED
//!
//! \param [in]      hPhysicalGPU     GPU selection
//! \param [out]     pLwrrentPstate   The ID of the current P-State of the GPU - see \ref LW_GPU_PERF_PSTATES.
//!
//! \retval    LWAPI_OK                             Completed request
//! \retval    LWAPI_ERROR                          Miscellaneous error oclwrred.
//! \retval    LWAPI_HANDLE_ILWALIDATED             Handle passed has been ilwalidated (see user guide).
//! \retval    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE   Handle passed is not a physical GPU handle.
//! \retval    LWAPI_NOT_SUPPORTED                  P-States is not supported on this setup.
//!
//! \ingroup   gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetLwrrentPstate(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_PERF_PSTATE_ID *pLwrrentPstate);



//! \ingroup gpupstate
//! Used in LwAPI_GPU_GetPstateClientLimits().
typedef enum _LW_PERF_PSTATE_CLIENT_LIMIT_ID
{
    LWAPI_PERF_PSTATE_CLIENT_LIMIT_HARD                 = 0x00000001,       //!< P-States Hard limit 
    LWAPI_PERF_PSTATE_CLIENT_LIMIT_SOFT                 = 0x00000002,       //!< P-States Soft limit 
    LWAPI_PERF_PSTATE_CLIENT_LIMIT_BOTH                 = 0x00000003        //!< For both hard and soft P-States limits
} LW_GPU_PERF_PSTATE_CLIENT_LIMIT_ID;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetPstateClientLimits
//
//! DESCRIPTION:     This API gets the soft or hard performance state (P-State) limit
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 185
//! 
//! \param [in]    hPhysicalGPU   GPU selection.
//! \param [in]    limitId        Indicates hard limit or soft limit 
//! \param [out]   PstateLimit    The ID of the P-State that is the current limit
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_HANDLE_ILWALIDATED 
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE 
//! \retval ::LWAPI_ILWALID_ARGUMENT 
//! \retval ::LWAPI_NOT_SUPPORTED P-States is not supported on this setup
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPstateClientLimits(LwPhysicalGpuHandle hPhysicalGpu,
                                                LW_GPU_PERF_PSTATE_CLIENT_LIMIT_ID limitId,
                                                LW_GPU_PERF_PSTATE_ID* PstateLimit);
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_SetPstateClientLimits
//
//! DESCRIPTION:     This API sets the soft or hard performance state (P-State) limit.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 185
//!
//! \param [in]     hPhysicalGPU    GPU selection.
//! \param [in]     limitId         To indicate hard limit, soft limit or both
//! \param [in]     PstateLimit     The ID of the P-State to be the new limit
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_ILWALID_USER_PRIVILEGE       - The caller does not have administrative privileges
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetPstateClientLimits(LwPhysicalGpuHandle hPhysicalGpu,
                                                LW_GPU_PERF_PSTATE_CLIENT_LIMIT_ID limitId,
                                                LW_GPU_PERF_PSTATE_ID PstateLimit);


//! \addtogroup gpupstate
//! @{

/*!
 * The software performance policy. Each policy could request to set
 * performance in software. 
 */
typedef enum
{
    /*!
     * Power. Indicating perf is limited by total power limit.
     */
    LW_GPU_PERF_POLICY_ID_SW_POWER = 0,
    /*!
     * Thermal. Indicating perf is limited by temperature limit.
     */
    LW_GPU_PERF_POLICY_ID_SW_THERMAL,
    /*!
     * Reliability. Indicating perf is limited by reliability voltage.
     */
    LW_GPU_PERF_POLICY_ID_SW_RELIABILITY,
    /*!
     * Operating. Indicating perf is limited by max operating voltage.
     */
    LW_GPU_PERF_POLICY_ID_SW_OPERATING,
    /*!
     * Utilization. Indicating perf is limited by GPU utilization.
     */
    LW_GPU_PERF_POLICY_ID_SW_UTILIZATION,
    /*!
     * SLI GPUBoost Synchronization.
     */
    LW_GPU_PERF_POLICY_ID_SW_SLI_GPU_BOOST_SYNC,
} LW_GPU_PERF_POLICY_ID_SW;
#define LW_GPU_PERF_POLICY_ID_SW_NUM_V1       12

/*!
 * The performance point. Each perf point represents a specific upper limit
 * of performance.
 */
typedef enum
{
    /*!
     * Max clock. Indicating the request is to set GPC2CLK below maximum clock.
     */
    LW_GPU_PERF_POINT_ID_MAX_CLOCK   = 0,
    /*!
     * Turbo Boost. Indicating the request is to set GPC2CLK below Tubo Boost clock.
     */
    LW_GPU_PERF_POINT_ID_BOOST_CLOCK,
    /*!
     * Rated TDP. Indicating the request is to set GPC2CLK below Rated TDP,
     * aka base clock.
     */
    LW_GPU_PERF_POINT_ID_BASE_CLOCK,
} LW_GPU_PERF_POINT_ID;
#define LW_GPU_PERF_POINT_ID_NUM_V1           6

/*!
 * Structure to store perf policies info.
 * Used in LwAPI_GPU_PerfPoliciesGetInfo().
 */
typedef struct
{
    /*!
     * Version of this structure.  Must always be first element in this structure.
     */
    LwU32   version;
    /*!
     * Output: Mask of supported perf points.
     */
    LwU32   supportedPointMask;
    /*!
     * Output: Mask of supported perf policies.
     */
    LwU32   supportedPolicyMask;
    /*!
     * Reserved space for future use.
     */
    LwU32   rsvd[16];
} LW_GPU_PERF_POLICIES_INFO_PARAMS_V1;

#define LW_GPU_PERF_POLICIES_INFO_PARAMS_VER_1    MAKE_LWAPI_VERSION(LW_GPU_PERF_POLICIES_INFO_PARAMS_V1, 1)
#define LW_GPU_PERF_POLICIES_INFO_PARAMS_VER      LW_GPU_PERF_POLICIES_INFO_PARAMS_VER_1 

typedef LW_GPU_PERF_POLICIES_INFO_PARAMS_V1       LW_GPU_PERF_POLICIES_INFO_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_PerfPoliciesGetInfo()
//
//! DESCRIPTION:    Returns perf limiting policies information, including supported performance points
//!                 and supported performance policies. Values are returned in bitmasks.
//!                 Application should call this API to obtain info before calling to the 
//!                 @ref LwAPI_GPU_PerfPoliciesGetStatus() API.
//!
//! \since Release: 313
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! \param [in]     hPhysicalGPU        - GPU selection.
//! \param [inout]  pPerfPoliciesInfo   - Returned performance policies info structure.
//!
//! \return         This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                 If there are return error codes with specific meaning for this API, 
//!                 they are listed below.
//! \retval:        LWAPI_ILWALID_POINTER: if pPerfPoliciesInfo is invalid pointer
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PerfPoliciesGetInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_PERF_POLICIES_INFO_PARAMS *pPerfPoliciesInfo);

//! \addtogroup gpupstate
//! @{

/*!
 * Structure representing one perf policy's status.
 */
typedef struct
{
    /*!
     * Output: mask of perf points that are lwrrently violated.
     */
    LwU32   perfPointMask;
    /*!
     * Output: violation time for each perf point. Units in nanoseconds.
     */
    LwU64   perfPointTimeNs[LW_GPU_PERF_POINT_ID_NUM_V1];
    /*!
     * Reserved space for future use.
     */
    LwU32   rsvd[8];
} LW_GPU_PERF_POLICY_STATUS_V1;

/*!
 * Structure to hold perf policy's status data
 * Used in LwAPI_GPU_PerfPoliciesGetStatus().
 */
typedef struct
{
    /*!
     * Version of this structure.  Must always be first element in this structure.
     */
    LwU32                             version;
    /*!
     * Input: Requested policies mask by user. Will only retrieve status for
     * designated policies.
     */
    LwU32                             requestedPolicyMask;
    /*!
     * Output: reference timer's output. Units in nano-seconds.
     */
    LwU64                             referenceTimeNs;
    /*!
     * Output: mask of current limiting SW perf policies.
     */
    LwU32                             limitingPoliciesMask;
    /*!
     * Output: system's global status and violation time for each perf point. 
     */
    LW_GPU_PERF_POLICY_STATUS_V1      global;
    /*!
     * Output: Each SW policy's current status and violation time for each perf
     * point.
     */
    LW_GPU_PERF_POLICY_STATUS_V1      policies[LW_GPU_PERF_POLICY_ID_SW_NUM_V1];
    /*!
     * Reserved space for future use.
     */
    LwU32                             rsvd[48];
} LW_GPU_PERF_POLICIES_STATUS_PARAMS_V1;

#define LW_GPU_PERF_POLICIES_STATUS_PARAMS_VER_1  MAKE_LWAPI_VERSION(LW_GPU_PERF_POLICIES_STATUS_PARAMS_V1, 1)
#define LW_GPU_PERF_POLICIES_STATUS_PARAMS_VER    LW_GPU_PERF_POLICIES_STATUS_PARAMS_VER_1

typedef LW_GPU_PERF_POLICIES_STATUS_PARAMS_V1     LW_GPU_PERF_POLICIES_STATUS_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_PerfPoliciesGetStatus()
//
//! DESCRIPTION:    Returns @ref LW_GPU_PERF_POLICIES_STATUS_PARAMS structure.
//!                 The global status is the result of all lwrrently engaged policies.
//!                 The per-policy status contains information specific to a policy.
//!                 For parameter detail, see @ref LW_GPU_PERF_POLICIES_STATUS_PARAMS_V1.
//!
//! \since Release: 313
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! \param [in]     hPhysicalGPU        - GPU selection.
//! \param [out]    pPerfPoliciesStatus - Returned performance reason status.
//!
//! \return         This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                 If there are return error codes with specific meaning for this API, 
//!                 they are listed below.
//! \retval:        LWAPI_ILWALID_POINTER: if pPerfPoliciesStatus is invalid pointer
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PerfPoliciesGetStatus(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_PERF_POLICIES_STATUS_PARAMS *pPerfPoliciesStatus);

///////////////////////////////////////////////////////////////////////////////
//! \fn LwAPI_GPU_SetPerfLimit
//! \code
//! FUNCTION NAME:   LwAPI_GPU_SetPerfLimit
//!
//! DESCRIPTION:     This API sets the new fine-grained performance limit.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! PARAMETERS:      hPhysicalGPU(IN)  - GPU selection.
//!                  limit(IN)         - The target fine-grained performance limit.
//!                                      Setting LW_GPU_PERF_LIMIT_MAX is the
//!                                      same as clearing the limit.
//!                  flags(IN/OUT)     - Reserved for future use.
//!
//! RETURN STATUS:
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_API_NOT_INITIALIZED - lwapi not initialized
//!    LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    LWAPI_ILWALID_HANDLE - physical GPU handle is invalid
//!    LWAPI_ILWALID_POINTER - the pointer argument is NULL
//!    LWAPI_NOT_SUPPORTED - fine-grained performance limit is not supported on this setup
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpupstate
//! @{
#define LW_GPU_PERF_LIMIT_MAX (0xff)

LWAPI_INTERFACE LwAPI_GPU_SetPerfLimit(LwPhysicalGpuHandle hPhysicalGpu,
                                       LwU8 limit,
                                       LwU32 *flags);
//! @}

///////////////////////////////////////////////////////////////////////////////
//! \code
//! FUNCTION NAME:   LwAPI_GPU_GetPerfLimit
//!
//! DESCRIPTION:     This API gets the current fine-grained performance limit.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! PARAMETERS:      hPhysicalGPU(IN)  - GPU selection.
//!                  limit(OUT)        - The current actual fine-grained performance limit. 
//!                                      LW_GPU_PERF_LIMIT_MAX is same as not having a limit.
//!                  flags(IN/OUT)     - Reserved for future use.
//!
//! RETURN STATUS:
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_API_NOT_INITIALIZED - lwapi not initialized
//!    LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    LWAPI_ILWALID_HANDLE - physical GPU handle is invalid
//!    LWAPI_ILWALID_POINTER - the pointer argument is NULL
//!    LWAPI_NOT_SUPPORTED - fine-grained performance limit is not supported on this setup
//! \endcode
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPerfLimit(LwPhysicalGpuHandle hPhysicalGpu,
                                       LwU8 *limit,
                                       LwU32 *flags);


///////////////////////////////////////////////////////////////////////////////
//! \fn LwAPI_GPU_SetPerfPwmPeriod
//! \code
//! FUNCTION NAME:   LwAPI_GPU_SetPerfPwmPeriod
//!
//! DESCRIPTION:     This API sets the PWM period used for fine-grained performance.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! PARAMETERS:      hPhysicalGPU(IN)  - GPU selection.
//!                  periodUs(IN)      - The new PWM period used for fine-grained 
//!                                      performance in microseconds. If this is set 
//!                                      to LW_GPU_PERF_PWM_PERIOD_AUTO, the period 
//!                                      will be set adaptively in runtime.
//!                  flags(IN/OUT)     - Reserved for future use.
//!
//! RETURN STATUS:
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_API_NOT_INITIALIZED - lwapi not initialized
//!    LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    LWAPI_ILWALID_HANDLE - physical GPU handle is invalid
//!    LWAPI_ILWALID_POINTER - the pointer argument is NULL
//!    LWAPI_NOT_SUPPORTED - fine-grained performance PWM is not supported on this setup
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpupstate
//! @{
#define LW_GPU_PERF_PWM_PERIOD_AUTO (0x00000000)

LWAPI_INTERFACE LwAPI_GPU_SetPerfPwmPeriod(LwPhysicalGpuHandle hPhysicalGpu,
                                           LwU32 periodUs,
                                           LwU32 *flags);
//! @}

//! \ingroup gpupstate
typedef struct
{
    LwU32       version;        //!< Structure version
    LwU32       flags;          //!< Reserved for future use
    LwU32       bEnabled;       //!< Boolean: Set if VPS is enabled
    LwU32       bRunning;       //!< Boolean: Set if VPS is running
    LwU32       bStateHigh;     //!< Boolean: Set if lwrrently on high Pstate
    LwU32       highPstate;     //!< The high (fast) Pstate to alternate
    LwU32       lowPstate;      //!< lowPstate = highPstate - 1
    LwU32       highUs;         //!< Time spent (microseconds) in high Pstate within each cycle
    LwU32       lowUs;          //!< lowUs = periodUs - highUs
} LW_GPU_PERF_PWM_INFO;



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GPU_PerfGetFstate
//
//! DESCRIPTION:     This API sets gets the current and max f-state.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[in]      hPhysicalGPU(IN)  - GPU selection.
//! \param[out]     current(OUT)      - The current f-state.
//! \param[out]     max(OUT)          - Maximum f-state available.
//! \param[out]     flags(INOUT)      - Reserved for future use.  Pass in 0 now.
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPerfFstate(LwPhysicalGpuHandle hPhysicalGpu,
                                           LwU32 *current,
                                           LwU32 *max,
                                           LwU32 *flags);


//! \ingroup gpupstate
#define LW_GPU_PERF_PWM_INFO_VER MAKE_LWAPI_VERSION(LW_GPU_PERF_PWM_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//! \code
//! FUNCTION NAME:   LwAPI_GPU_GetPerfPwmInfo
//!
//! DESCRIPTION:     This API acquires the PWM period information.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      hPhysicalGPU(IN)     - GPU selection.
//!                  pPerfPwmInfo(IN/OUT) - The LW_GPU_PERF_PWM_INFO struct to retrieve
//!
//! RETURN STATUS:
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_API_NOT_INITIALIZED - lwapi not initialized
//!    LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    LWAPI_ILWALID_HANDLE - physical GPU handle is invalid
//!    LWAPI_ILWALID_POINTER - the pointer argument is NULL
//!    LWAPI_NOT_SUPPORTED - fine-grained performance PWM is not supported on this setup
//! \endcode
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPerfPwmInfo(LwPhysicalGpuHandle hPhysicalGpu,
                                         LW_GPU_PERF_PWM_INFO *pPerfPwmInfo);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_EnableOverclockedPstates
//
//! DESCRIPTION:     This API allows overclocked P-states. 
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 185
//!
//! \param [in]     hPhysicalGP    GPU selection
//! \param [in]     bEnable        (Boolean) Enables or disables overclocked P-states 
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_HANDLE_ILWALIDATED 
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE 
//! \retval ::LWAPI_ILWALID_ARGUMENT 
//! \retval ::LWAPI_NOT_SUPPORTED  P-States or overclocked P-states is not supported on this setup
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_EnableOverclockedPstates(LwPhysicalGpuHandle hPhysicalGpu,
                                                   LwU8 bEnable);
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_EnableDynamicPstates
//
//! DESCRIPTION:     This API enables or disables dynamic P-states 
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 185
//!
//! \param [in]     hPhysicalGPU   GPU selection.
//! \param [in]     bEnable        (Boolean) Enables or disables dynamic P-states 
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_HANDLE_ILWALIDATED 
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE 
//! \retval ::LWAPI_ILWALID_ARGUMENT 
//! \retval ::LWAPI_NOT_SUPPORTED  P-States is not supported on this setup
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_EnableDynamicPstates(LwPhysicalGpuHandle hPhysicalGpu,
                                               LwU8 bEnable);





//! \addtogroup gpupstate
//! @{


//! Used in LW_GPU_DYNAMIC_PSTATES_INFO.
#define LWAPI_MAX_GPU_UTILIZATIONS 8


//! Used in LW_GPU_DYNAMIC_PSTATES_INFO -> utilization[].
typedef enum _LW_GPU_UTILIZATION_DOMAIN_ID
{
    LWAPI_GPU_UTILIZATION_DOMAIN_GPU    = 0, //!< Graphics engine domain
    LWAPI_GPU_UTILIZATION_DOMAIN_FB     = 1, //!< Frame buffer domain
    LWAPI_GPU_UTILIZATION_DOMAIN_VID    = 2, //!< Video engine domain
    LWAPI_GPU_UTILIZATION_DOMAIN_BUS    = 3, //!< Bus interface domain
} LW_GPU_UTILIZATION_DOMAIN_ID;

//! @}



//! \addtogroup gpupstate
//! @{

//! Used in LwAPI_GPU_GetDynamicPstatesInfo().
typedef struct 
{
    LwU32       version;        //!< Structure version
    LwU32       flags;          //!< Reserved for future use
    struct
    {
        LwU32   bIsPresent:1;   //!< Set if this utilization domain is present on this GPU        
        LwU32   percentage;     //!< Percentage of time where the domain is considered busy in the last 1-second interval
        LwU32   incThreshold;   //!< Utilization threshold that can trigger a perf-increasing P-State change when crossed
        LwU32   decThreshold;   //!< Utilization threshold that can trigger a perf-decreasing P-State change when crossed
    } utilization[LWAPI_MAX_GPU_UTILIZATIONS];
} LW_GPU_DYNAMIC_PSTATES_INFO;



//! Used in LW_GPU_DYNAMIC_PSTATES_INFO.
#define LW_GPU_DYNAMIC_PSTATES_INFO_VER MAKE_LWAPI_VERSION(LW_GPU_DYNAMIC_PSTATES_INFO,1)

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetDynamicPstatesInfo
//
//! DESCRIPTION:   This retrieves the LW_GPU_DYNAMIC_PSTATES_INFO structure for the specified physical GPU. \n
//!                flags is reserved for future use. \n
//!                For each utilization domain:
//!                   - bIsPresent is set for each domain that is present on the GPU.
//!                   - percentage is the percentage of time where the domain is considered busy in the last 1 second interval.
//!                   - incThreshold is utilization threshold that can trigger a perf-increasing P-State change when crossed.
//!                   - decThreshold is utilization threshold that can trigger a perf-decreasing P-State change when crossed.
//!
//!                Each domain's info is indexed in the array.  For example: 
//!                    pDynamicPstatesInfo->utilization[LWAPI_GPU_UTILIZATION_DOMAIN_GPU] holds the info for the GPU domain. \n
//!                There are lwrrently 4 domains, for which GPU utilization and dynamic P-State thresholds can be retrieved - 
//!                    graphic engine (GPU), frame buffer (FB), video engine (VID), and bus interface (BUS).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 173
//! 
//! TCC_SUPPORTED
//!
//!  \retval    LWAPI_OK                            completed request
//!  \retval    LWAPI_ERROR                         miscellaneous error oclwrred
//!  \retval    LWAPI_ILWALID_ARGUMENT              pDynamicPstatesInfo is NULL
//!  \retval    LWAPI_HANDLE_ILWALIDATED            handle passed has been ilwalidated (see user guide)
//!  \retval    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  handle passed is not a physical GPU handle
//!  \retval    LWAPI_INCOMPATIBLE_STRUCT_VERSION   the version of the INFO struct is not supported
//!
//!  \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetDynamicPstatesInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_DYNAMIC_PSTATES_INFO *pDynamicPstatesInfo);





//! \ingroup gpupstate
#define LWAPI_MAX_GPU_UTILIZATIONS 8



//! \ingroup gpupstate
//! Used in LwAPI_GPU_GetDynamicPstatesInfoEx().
typedef struct
{
    LwU32       version;        //!< Structure version
    LwU32       flags;          //!< bit 0 indicates if the dynamic Pstate is enabled or not
    struct
    {
        LwU32   bIsPresent:1;   //!< Set if this utilization domain is present on this GPU
        LwU32   percentage;     //!< Percentage of time where the domain is considered busy in the last 1 second interval
    } utilization[LWAPI_MAX_GPU_UTILIZATIONS];
} LW_GPU_DYNAMIC_PSTATES_INFO_EX;

//! \ingroup gpupstate
//! Macro for constructing the version field of LW_GPU_DYNAMIC_PSTATES_INFO_EX
#define LW_GPU_DYNAMIC_PSTATES_INFO_EX_VER MAKE_LWAPI_VERSION(LW_GPU_DYNAMIC_PSTATES_INFO_EX,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetDynamicPstatesInfoEx
//
//! DESCRIPTION:   This API retrieves the LW_GPU_DYNAMIC_PSTATES_INFO_EX structure for the specified physical GPU.
//!                Each domain's info is indexed in the array.  For example: 
//!                - pDynamicPstatesInfo->utilization[LWAPI_GPU_UTILIZATION_DOMAIN_GPU] holds the info for the GPU domain. \p
//!                There are lwrrently 4 domains for which GPU utilization and dynamic P-State thresholds can be retrieved:
//!                   graphic engine (GPU), frame buffer (FB), video engine (VID), and bus interface (BUS).
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 185
//! 
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_ILWALID_ARGUMENT  pDynamicPstatesInfo is NULL
//! \retval ::LWAPI_HANDLE_ILWALIDATED 
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE 
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION The version of the INFO struct is not supported
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetDynamicPstatesInfoEx(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_DYNAMIC_PSTATES_INFO_EX *pDynamicPstatesInfoEx);




//! \ingroup gpupstate
#define LWAPI_MAX_GPU_PERF_DOMAIN_VOLTAGES   128

//! \ingroup gpupstate
typedef struct
{
    LwU32   version;
    LwU32   flags;       //!< Lwrrently unsupported
    LwU32   numDomains;  //!< The number of voltage domains supported on the board

    struct
    {
        LW_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID domainId;     //!< Domain ID
        LwU32                              flags;        //!< Lwrrently unsupported
        LwU32                              numVoltages;  //!< The number of voltage levels defined for this domain
        struct
        {
            LwU32                       flags;           //!< Lwrrently unsupported  
            LwU32                       mvolt;           //!< Voltage in mV
        } voltages[LWAPI_MAX_GPU_PERF_DOMAIN_VOLTAGES];  //!< Valid index range from 0 to domains[i].numVoltages - 1
    } domains[LWAPI_MAX_GPU_PERF_VOLTAGES];              //!< Valid index range from 0 to numDomains-1

} LW_GPU_PERF_VOLTAGES;  

//! \ingroup gpupstate
//! Macro for contructing the version field of LW_GPU_PERF_VOLTAGES
#define LW_GPU_PERF_VOLTAGES_VER  MAKE_LWAPI_VERSION(LW_GPU_PERF_VOLTAGES,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetVoltages
//
//! DESCRIPTION:     This API returns the supported voltage levels for each supported voltage domain on the board.
//!                  These are the valid voltage levels which can be used for LwAPI_GPU_SetPstates() and
//!                  LwAPI_GPU_SetPstatesInfo().
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \param [in]      hPhysicalGPU    GPU selection.
//! \param [out]     pPerfVoltages   Voltage information retrieved, as detailed below:
//!                  - flags - lwrrently unsupported
//!                  - numDomains - the number of voltage domains supported on the board
//!                  - domains - valid index range from 0 to numDomains - 1
//!                    - domains[i].domainId - the ID of the voltage domain
//!                    - domains[i].flags - lwrrently unsupported
//!                    - domains[i].numVoltages - number of voltage levels defined for this domain
//!                    - domains[i].voltages -  valid index range from 0 to domains[i].numVoltages - 1
//!                      - domains[i].voltages[j].flags - lwrrently unsupported
//!                      - domains[i].voltages[j].mvolt - voltage in mV
//!
//! \retval ::LWAPI_OK - completed request
//! \retval ::LWAPI_ERROR - miscellaneous error oclwrred
//! \retval ::LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the LW_GPU_PERF_PSTATES struct is not supported
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetVoltages(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_PERF_VOLTAGES *pPerfVoltages);




//! \ingroup gpuvoltage
#define LW_GPU_VOLTAGES_FLAGS_INTERNAL     0x00000001

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetVoltagesInternal
//
//! \code
//! DESCRIPTION:     Returns all the supported voltage levels for each supported voltage domain on the board,
//!                  ignoring board overvoltage-ability and board reliability max.
//!                  These are the valid voltage levels which can be used for LwAPI_GPU_SetPstates().
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! PARAMETERS:      hPhysicalGPU(IN)  - GPU selection.
//!                  flags(IN)
//!                    bit 0 indicates whether we need to get all the voltage levels supported by the board,
//!                    ignoring board overvoltage-ability and board reliability max. 
//!                  pPerfVoltages(OUT) - Voltage information retrieved, as detailed below:
//!                  - flags - lwrrently unsupported
//!                  - numDomains - the number of voltage domains supported on the board
//!                  - domains - valid index range from 0 to numDomains - 1
//!                    - domains[i].domainId - the ID of the voltage domain
//!                    - domains[i].flags - lwrrently unsupported
//!                    - domains[i].numVoltages - number of voltage levels defined for this domain
//!                    - domains[i].voltages -  valid index range from 0 to domains[i].numVoltages - 1
//!                      - domains[i].voltages[j].flags - lwrrently unsupported
//!                      - domains[i].voltages[j].mvolt - voltage in mV
//!
//! RETURN STATUS:
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    LWAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the LW_GPU_PERF_PSTATES struct is not supported
//! \endcode
//! \ingroup gpuvoltages
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetVoltagesInternal(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_PERF_VOLTAGES *pPerfVoltages, LwU32 flags);







 
///////////////////////////////////////////////////////////////////////////////////
//  Thermal API
//  Provides ability to get temperature levels from the various thermal sensors associated with the GPU

//! \ingroup gputhermal
#define LWAPI_MAX_THERMAL_SENSORS_PER_GPU 3

//! \ingroup gputhermal
//! Used in LW_GPU_THERMAL_SETTINGS
typedef enum 
{
    LWAPI_THERMAL_TARGET_NONE          = 0,
    LWAPI_THERMAL_TARGET_GPU           = 1,     //!< GPU core temperature requires LwPhysicalGpuHandle
    LWAPI_THERMAL_TARGET_MEMORY        = 2,     //!< GPU memory temperature requires LwPhysicalGpuHandle
    LWAPI_THERMAL_TARGET_POWER_SUPPLY  = 4,     //!< GPU power supply temperature requires LwPhysicalGpuHandle
    LWAPI_THERMAL_TARGET_BOARD         = 8,     //!< GPU board ambient temperature requires LwPhysicalGpuHandle
    LWAPI_THERMAL_TARGET_VCD_BOARD     = 9,     //!< Visual Computing Device Board temperature requires LwVisualComputingDeviceHandle
    LWAPI_THERMAL_TARGET_VCD_INLET     = 10,    //!< Visual Computing Device Inlet temperature requires LwVisualComputingDeviceHandle
    LWAPI_THERMAL_TARGET_VCD_OUTLET    = 11,    //!< Visual Computing Device Outlet temperature requires LwVisualComputingDeviceHandle

    LWAPI_THERMAL_TARGET_ALL           = 15,
    LWAPI_THERMAL_TARGET_UNKNOWN       = -1,
} LW_THERMAL_TARGET;

//! \ingroup gputhermal
//! Used in LW_GPU_THERMAL_SETTINGS
typedef enum
{
    LWAPI_THERMAL_CONTROLLER_NONE = 0,
    LWAPI_THERMAL_CONTROLLER_GPU_INTERNAL,  
    LWAPI_THERMAL_CONTROLLER_ADM1032,
    LWAPI_THERMAL_CONTROLLER_MAX6649,       
    LWAPI_THERMAL_CONTROLLER_MAX1617,      
    LWAPI_THERMAL_CONTROLLER_LM99,      
    LWAPI_THERMAL_CONTROLLER_LM89,         
    LWAPI_THERMAL_CONTROLLER_LM64,         
    LWAPI_THERMAL_CONTROLLER_ADT7473,
    LWAPI_THERMAL_CONTROLLER_SBMAX6649,
    LWAPI_THERMAL_CONTROLLER_VBIOSEVT,  
    LWAPI_THERMAL_CONTROLLER_OS,    
    LWAPI_THERMAL_CONTROLLER_UNKNOWN = -1,
} LW_THERMAL_CONTROLLER;

//! \ingroup gputhermal
//! Used in LwAPI_GPU_GetThermalSettings()
typedef struct
{
    LwU32   version;                //!< structure version 
    LwU32   count;                  //!< number of associated thermal sensors
    struct 
    {
        LW_THERMAL_CONTROLLER       controller;        //!< internal, ADM1032, MAX6649...
        LwU32                       defaultMinTemp;    //!< The min default temperature value of the thermal sensor in degree Celsius 
        LwU32                       defaultMaxTemp;    //!< The max default temperature value of the thermal sensor in degree Celsius 
        LwU32                       lwrrentTemp;       //!< The current temperature value of the thermal sensor in degree Celsius 
        LW_THERMAL_TARGET           target;            //!< Thermal sensor targeted @ GPU, memory, chipset, powersupply, Visual Computing Device, etc.
    } sensor[LWAPI_MAX_THERMAL_SENSORS_PER_GPU];

} LW_GPU_THERMAL_SETTINGS_V1;

//! \ingroup gputhermal
typedef struct
{
    LwU32   version;                //!< structure version
    LwU32   count;                  //!< number of associated thermal sensors
    struct
    {
        LW_THERMAL_CONTROLLER       controller;         //!< internal, ADM1032, MAX6649...
        LwS32                       defaultMinTemp;     //!< Minimum default temperature value of the thermal sensor in degree Celsius
        LwS32                       defaultMaxTemp;     //!< Maximum default temperature value of the thermal sensor in degree Celsius
        LwS32                       lwrrentTemp;        //!< Current temperature value of the thermal sensor in degree Celsius
        LW_THERMAL_TARGET           target;             //!< Thermal sensor targeted - GPU, memory, chipset, powersupply, Visual Computing Device, etc
    } sensor[LWAPI_MAX_THERMAL_SENSORS_PER_GPU];

} LW_GPU_THERMAL_SETTINGS_V2;

//! \ingroup gputhermal
typedef LW_GPU_THERMAL_SETTINGS_V2  LW_GPU_THERMAL_SETTINGS;

//! \ingroup gputhermal
//! @{

//! Macro for constructing the version field of LW_GPU_THERMAL_SETTINGS_V1
#define LW_GPU_THERMAL_SETTINGS_VER_1   MAKE_LWAPI_VERSION(LW_GPU_THERMAL_SETTINGS_V1,1)

//! Macro for constructing the version field of LW_GPU_THERMAL_SETTINGS_V2
#define LW_GPU_THERMAL_SETTINGS_VER_2   MAKE_LWAPI_VERSION(LW_GPU_THERMAL_SETTINGS_V2,2)

//! Macro for constructing the version field of LW_GPU_THERMAL_SETTINGS
#define LW_GPU_THERMAL_SETTINGS_VER     LW_GPU_THERMAL_SETTINGS_VER_2
//! @}




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetThermalSettings
//
//!  This function retrieves the thermal information of all thermal sensors or specific thermal sensor associated with the selected GPU.
//!  Thermal sensors are indexed 0 to LWAPI_MAX_THERMAL_SENSORS_PER_GPU-1.
//!
//!  - To retrieve specific thermal sensor info, set the sensorIndex to the required thermal sensor index. 
//!  - To retrieve info for all sensors, set sensorIndex to LWAPI_THERMAL_TARGET_ALL. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 85
//!
//! \param [in]   hPhysicalGPU      GPU selection.
//! \param [in]   sensorIndex       Explicit thermal sensor index selection. 
//! \param [out]  pThermalSettings  Array of thermal settings.
//!
//! \retval   LWAPI_OK                           Completed request
//! \retval   LWAPI_ERROR                        Miscellaneous error oclwrred.
//! \retval   LWAPI_ILWALID_ARGUMENT             pThermalInfo is NULL.
//! \retval   LWAPI_HANDLE_ILWALIDATED           Handle passed has been ilwalidated (see user guide).
//! \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE Handle passed is not a physical GPU handle.
//! \retval   LWAPI_INCOMPATIBLE_STRUCT_VERSION  The version of the INFO struct is not supported.
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetThermalSettings(LwPhysicalGpuHandle hPhysicalGpu, LwU32 sensorIndex, LW_GPU_THERMAL_SETTINGS *pThermalSettings);



// ====================================================
// Thermal slowdown status
// ====================================================

//! \ingroup gputhermal
//! Thermal slowdown options - used in LwAPI_GPU_SetThermalSlowdownState() 
typedef enum
{
    LWAPI_GPU_THERMAL_SLOWDOWN_ENABLED                = 0x0000,         //!< Thermal slowdown mechanisms enabled
    LWAPI_GPU_THERMAL_SLOWDOWN_DISABLED_ALL           = 0xFFFF,         //!< All thermal slowdown mechanisms disabled (HW, SW, Pstate)
} LW_GPU_THERMAL_SLOWDOWN;



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_SetThermalSlowdownState
//
//! DESCRIPTION:    This function disables/enables thermal slowdown for the specified GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 177
//!
//! \param [in]   hPhysicalGpu   The handle for the physical GPU  
//! \param [in]   slowdownState  Slowdown state, lwrrently NONE/ALL. See #LW_GPU_THERMAL_SLOWDOWN.
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_ILWALID_ARGUMENT 
//! \retval ::LWAPI_HANDLE_ILWALIDATED 
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE 
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetThermalSlowdownState(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_THERMAL_SLOWDOWN slowdownState);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetThermalSlowdownState
//
//! DESCRIPTION:    This function retreives the thermal slowdown information for the specified GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 177
//!
//! \param [in]    hPhysicalGpu   The handle for the physical GPU  
//! \param [out]   slowdownState  Slowdown state, lwrrently NONE/ALL. See #LW_GPU_THERMAL_SLOWDOWN.
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_ILWALID_ARGUMENT 
//! \retval ::LWAPI_HANDLE_ILWALIDATED 
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE 
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetThermalSlowdownState(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_THERMAL_SLOWDOWN *slowdownState);



// ====================================================
// Thermal simulation mode
// ====================================================

//! \ingroup gputhermal
//! Used in LwAPI_GPU_GetThermalSimulationMode() and LwAPI_GPU_SetThermalSimulationMode().
typedef enum
{
    LWAPI_GPU_THERMAL_SIMULATION_DISABLED               = 0x0000,
    LWAPI_GPU_THERMAL_SIMULATION_ENABLED                = 0x0001,
} LW_GPU_THERMAL_SIMULATION_MODE;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_SetThermalSimulationMode
//
//!                 This LwAPI call lets you simulate the temperature for an existing
//!                 thermal sensor. Once thermal simulation mode is enabled,
//!                 the readings from that particular sensor will be a constant value
//!                 (simulated temperature). Disabling this feature returns
//!                 the thermal sensor to its original state.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \param [in] sensor         Target sensor
//! \param [in] tempSimMode    Enable/disable thermal simulation mode
//! \param [in] temperature    Simulated temperature (0 <= temp <= 255 deg Celsius)
//!                           (unused if tempSimMode is _DISABLED)
//!
//! \retval  ::LWAPI_OK                              Completed request
//! \retval  ::LWAPI_ERROR                           Miscellaneous error oclwrred
//! \retval  ::LWAPI_ILWALID_ARGUMENT                Invalid mode selected, or temperature is out of range
//! \retval  ::LWAPI_HANDLE_ILWALIDATED              Handle passed has been ilwalidated (see user guide)
//! \retval  ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE    Handle passed is not a physical GPU handle
//! \retval  ::LWAPI_NOT_SUPPORTED                   Thermal simulation is not supported
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetThermalSimulationMode(LwPhysicalGpuHandle hPhysicalGpu, LwU32 sensor, LW_GPU_THERMAL_SIMULATION_MODE tempSimMode, LwU32 temperature);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_SetExtendedThermalSimulationMode
//
//! \code
//! DESCRIPTION:     Disables/enables extended thermal simulation mode.
//!                  This LwAPI call basicaly provides same functionality as
//!                  previous call (LwAPI_GPU_SetThermalSimulationMode())
//!                  with difference that it allows simulation of negative
//!                  temperatures on GPUs that suppors that.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! PARAMETERS :     sensor(IN) - affected sensor
//!                  tempSimMode(IN) - turning ON/OFF temp. simulation mode
//!                  temperature(IN) - simulated temperature
//!                                    (check LwAPI_GPU_GetThermalSettings() for allowed range)
//!                                    (unused if tempSimMode is _DISABLED)
//!
//! RETURN STATUS:
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_ILWALID_ARGUMENT - invalid mode selected
//!    LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    LWAPI_NOT_SUPPORTED - Thermal simulation is not supported
//! \endcode
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetExtendedThermalSimulationMode(LwPhysicalGpuHandle hPhysicalGpu, LwU32 sensor, LW_GPU_THERMAL_SIMULATION_MODE tempSimMode, LwS32 temperature);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetThermalSimulationMode
//
//! DESCRIPTION:     This API retreives the thermal simulation mode. See LwAPI_GPU_SetThermalSimulationMode().
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \param [in]  sensor       Target sensor
//! \param [out] tempSimMode  The temperature simulation mode
//!
//! \retval  ::LWAPI_OK                              Completed request
//! \retval  ::LWAPI_ERROR                           Miscellaneous error oclwrred
//! \retval  ::LWAPI_ILWALID_ARGUMENT                NULL pointer passed (tempSimMode)
//! \retval  ::LWAPI_HANDLE_ILWALIDATED              Hhandle passed has been ilwalidated (see user guide)
//! \retval  ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE    Handle passed is not a physical GPU handle
//! \retval  ::LWAPI_NOT_SUPPORTED                   Thermal simulation is not supported
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetThermalSimulationMode(LwPhysicalGpuHandle hPhysicalGpu, LwU32 sensor, LW_GPU_THERMAL_SIMULATION_MODE *tempSimMode);



//! \ingroup gputhermal
typedef struct
{
    LwU32   version;                //!< Structure version
    LwU32   sensorIndex;            //!< Index of requested internal thermal sensor

    LwU32   rawReading;             //!< Thermal sensor's RAW reading
    LwS32   slope;                  //!< Slope parameter for temperature callwlation
                                    //!< Fixed point value with 16 decimal bits
    LwS32   offset;                 //!< Offset parameter for temperature callwlation
                                    //!< Fixed point value with 16 decimal bits
    //!< Current temperature can be callwlated using following formula:
    //!< T [C] = (slope * rawReading + offset) >> 16

} LW_DIAG_INTERNAL_THERMAL_SENSOR_INFO_V1;

//! \ingroup gputhermal
typedef LW_DIAG_INTERNAL_THERMAL_SENSOR_INFO_V1      LW_DIAG_INTERNAL_THERMAL_SENSOR_INFO;

//! \ingroup gputhermal
#define LW_DIAG_INTERNAL_THERMAL_SENSOR_VER_1   MAKE_LWAPI_VERSION(LW_DIAG_INTERNAL_THERMAL_SENSOR_INFO_V1,1)

//! \ingroup gputhermal
#define LW_DIAG_INTERNAL_THERMAL_SENSOR_VER     LW_DIAG_INTERNAL_THERMAL_SENSOR_VER_1


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Diag_GetInternalThermalSensorInfo
//
//! \code
//! DESCRIPTION:     Retreives the internal thermal sensor diagnostic information.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS :     pDiagData(IN/OUT) - internal thermal sensor diagnostic data
//!
//! RETURN STATUS:
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_ILWALID_ARGUMENT - NULL pointer passed (pDiagData)
//!    LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    LWAPI_NOT_SUPPORTED - internal thermal sensor diagnotic call is not supported
//!    LWAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the INFO struct is not supported
//! \endcode
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Diag_GetInternalThermalSensorInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_DIAG_INTERNAL_THERMAL_SENSOR_INFO *pDiagData);



//! \ingroup gputhermal
//! @{

#define LW_GPU_THERMAL_POLICY_MAX_POLICIES_V1                               16

/*!
 * Enumeration of Thermal Policy types. Different types implement the
 * Thermal Policy functionality via different mechanisms. Also, specifies how
 * to interpret the policy type data union.
 */
typedef enum _LW_GPU_THERMAL_POLICY_TYPE
{
    LW_GPU_THERMAL_POLICY_TYPE_DTC_VPSTATE = 0x00000001,
    LW_GPU_THERMAL_POLICY_TYPE_DTC_VF,
    LW_GPU_THERMAL_POLICY_TYPE_DTC_VOLT,

    /*!
     * The following are virtual Thermal Policy classes/types. They are
     * interface types with other Thermal Policy classes will implement.
     */
    LW_GPU_THERMAL_POLICY_TYPE_DTC    = 0xFFFFFFFD,
    LW_GPU_THERMAL_POLICY_TYPE_DOMGRP = 0xFFFFFFFE,

    /*!
     * Unknown/unsupported type via LWAPI. Should always be last.
     */
    LW_GPU_THERMAL_POLICY_TYPE_UNKNOWN = 0xFFFFFFFF,
} LW_GPU_THERMAL_POLICY_TYPE;

/*!
 * Used in \ref LW_GPU_THERMAL_POLICY_INFO_V1. Structure representing the
 * static data found in the VPSTATE domain group controller.
 */
typedef struct _LW_GPU_THERMAL_POLICY_INFO_DTC_VPSTATE_V1
{
    /*!
     * Number of virtual P-states.
     */
    LwU32 vpstateNum;

    /*!
     * Virtual P-states that contains the rated TDP clocks.
     */
    LwU32 vpstateTdp;
} LW_GPU_THERMAL_POLICY_INFO_DTC_VPSTATE_V1;

/*!
 * Used in \ref LW_GPU_THERMAL_POLICY_INFO_V1. Structure representing the
 * static data found in the VF domain group controller.
 */
typedef struct _LW_GPU_THERMAL_POLICY_INFO_DTC_VF_V1
{
    /*!
     * Maximum frequency used by the controller for the GPC2CLK limit.
     */
    LwU32 limitFreqMaxKHz;

    /*!
     * Minimum frequency used by the controller for the GPC2CLK limit.
     */
    LwU32 limitFreqMinKHz;

    /*!
     * Rated TDP frequency.
     */
    LwU32 ratedTdpFreqKHz;
} LW_GPU_THERMAL_POLICY_INFO_DTC_VF_V1;

/*!
 * Used in \ref LW_GPU_THERMAL_POLICY_INFO_V1. Structure representing the
 * static data found in the VOLT domain group controller.
 */
typedef struct _LW_GPU_THERMAL_POLICY_INFO_DTC_VOLT_V1
{
    /*!
     * Rated TDP frequency.
     */
    LwU32 ratedTdpFreqKHz;

    /*!
     * Rated TDP P-state index.
     */
    LwU32 pstateIdxTdp;

    /*!
     * Maximum voltage value to limit. Limiting to this voltage will cause the
     * GPU to be perf. limited the least.
     */
    LwU32 voltageMaxuV;

    /*!
     * Minimum voltage value to limit. Limiting to this voltage will cause the
     * GPU to be perf. limited the most.
     */
    LwU32 voltageMinuV;

    /*!
     * The size of the voltage limit step.
     */
    LwU32 voltageStepuV;
} LW_GPU_THERMAL_POLICY_INFO_DTC_VOLT_V1;

/*!
 * Used in \ref LW_GPU_THERMAL_POLICY_INFO_PARAMS_V1. Structure of static
 * information describing a Thermal Policy, which specifies a thermal policy/
 * limit to enforce on the GPU.
 */
typedef struct _LW_GPU_THERMAL_POLICY_INFO_V1
{
    /*!
     * LW_GPU_THERMAL_POLICY_TYPE_<xyz>
     */
    LW_GPU_THERMAL_POLICY_TYPE type;

    /*!
     * Index into Thermal Channel Table for input channel.
     */
    LwU8 chIdx;

    /*!
     * Minimum allowed limit value. Signed number of 1/256 degree Celsius.
     */
    LwS32 limitMin;

    /*!
     * Rated/default limit value. Signed number of 1/256 degree Celsius.
     */
    LwS32 limitRated;

    /*!
     * Maximum allowed limit value. Signed number of 1/256 degree Celsius.
     */
    LwS32 limitMax;

    /*!
     * Type-specific information.
     */
    union
    {
        LW_GPU_THERMAL_POLICY_INFO_DTC_VPSTATE_V1   dtcVpstate;
        LW_GPU_THERMAL_POLICY_INFO_DTC_VF_V1        dtcVf;
        LW_GPU_THERMAL_POLICY_INFO_DTC_VOLT_V1      dtcVolt;
        /*!
         * Reserving 32 bytes of space so we can add new types without
         * needing to add a new version.
         */
        LwU8 rsvd[32];
    } data;
} LW_GPU_THERMAL_POLICY_INFO_V1;

/*!
 * Used in \ref LwAPI_GPU_ThermalPolicyGetInfo. Structure representing the
 * static state information associated with the GPU's Thermal Policy
 * functionality.
 */
typedef struct _LW_GPU_THERMAL_POLICY_INFO_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first.
     */
    LwU32 version;

    /*!
     * Mask of Thermal Policy entries specified on this GPU.
     */
    LwU32 policyMask;

    /*!
     * Thermal Policy Table index for the policy controlling the GPS
     * temperature controller.
     */
    LwU8 gpsPolicyIdx;

    /*!
     * Thermal Policy Table index for the policy controlling acoustics.
     */
    LwU8 acousticPolicyIdx;

    /*!
     * Array of Thermal Policy entries. Has valid indexes corresponding to the
     * bits in \ref policyMask.
     */
    LW_GPU_THERMAL_POLICY_INFO_V1 policies[LW_GPU_THERMAL_POLICY_MAX_POLICIES_V1];
} LW_GPU_THERMAL_POLICY_INFO_PARAMS_V1;

#define LW_GPU_THERMAL_POLICY_INFO_PARAMS_VER_1 MAKE_LWAPI_VERSION(LW_GPU_THERMAL_POLICY_INFO_PARAMS_V1,1)
#define LW_GPU_THERMAL_POLICY_INFO_PARAMS_VER   LW_GPU_THERMAL_POLICY_INFO_PARAMS_VER_1

#define LW_GPU_THERMAL_POLICY_INFO_PARAMS       LW_GPU_THERMAL_POLICY_INFO_PARAMS_V1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_ThermalPolicyGetInfo()
//
//! DESCRIPTION:    Retrieves information about the Thermal Policy support on
//!                 the GPU.
//!
//!                 Thermal Policy entries are limits (in temperature) which
//!                 the RM/PMU Thermal Policy functionality must try to enforce
//!                 via a specified mechanism.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 328.00
//!
//! \param [in]     hPhysicalGpu    GPU selection
//! \param [in,out] pPolicyInfo
//!     Structure containing the description of Thermal Policies.
//!
//! \return This API can return any of the error codes enumerated in
//!         #LwAPI_Status. If there are return error codes with specific
//!         meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ThermalPolicyGetInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_THERMAL_POLICY_INFO_PARAMS *pPolicyInfo);

//! \ingroup gputhermal
//! @{

#define LW_GPU_THERMAL_POLICY_DOMAIN_GROUPS_LIMITS_MAX_DOMAIN_GROUPS          3
#define LW_GPU_THERMAL_POLICY_DOMAIN_GROUP_LIMIT_VALUE_DISABLED      0xFFFFFFFF

/*!
 * Used in \ref LW_GPU_THERMAL_POLICY_STATUS_DTC_VPSTATE, \ref
 * LW_GPU_THERMAL_POLICY_STATUS_DTC_VF, and \ref
 * LW_GPU_THERMAL_POLICY_STATUS_DTC_VOLT. Structure representing the dynamic
 * status of a particular domain group controller.
 */
typedef struct _LW_GPU_THERMAL_POLICY_STATUS_DOMGRP
{
    /*!
     * Limits imposed by the controller.
     */
    LwU32 limits[LW_GPU_THERMAL_POLICY_DOMAIN_GROUPS_LIMITS_MAX_DOMAIN_GROUPS];
} LW_GPU_THERMAL_POLICY_STATUS_DOMGRP;

/*!
 * Used in \ref LW_GPU_THERMAL_POLICY_STATUS_DTC_VPSTATE, \ref
 * LW_GPU_THERMAL_POLICY_STATUS_DTC_VF, and \ref
 * LW_GPU_THERMAL_POLICY_STATUS_DTC_VOLT. Structure representing the dynamic
 * status of a particular domain group controller.
 */
typedef struct _LW_GPU_THERMAL_POLICY_STATUS_DTC
{
    /*!
     * Keeps track of the number of samples taken for the current threshold
     * range. If the number of samples exceeds the sample threshold, the
     * algorithm will alter its behavior.
     */
    LwU8 sampleCount;
} LW_GPU_THERMAL_POLICY_STATUS_DTC;

/*!
 * Used in \ref LW_GPU_THERMAL_POLICY_STATUS_V1. Structure representing the
 * current dynamic status of a particular VPSTATE domain group controller.
 */
typedef struct _LW_GPU_THERMAL_POLICY_STATUS_DTC_VPSTATE
{
    /*!
     * Domain Group dynamic data. Must always be first.
     */
    LW_GPU_THERMAL_POLICY_STATUS_DOMGRP domgrp;

    /*!
     * DTC controller dynamic data.
     */
    LW_GPU_THERMAL_POLICY_STATUS_DTC dtc;

    /*!
     * Current virtual P-state used as the controller's limit.
     */
    LwU32 vpstateLimitLwrr;
} LW_GPU_THERMAL_POLICY_STATUS_DTC_VPSTATE;

/*!
 * Used in \ref LW_GPU_THERMAL_POLICY_STATUS_V1. Structure representing the
 * current dynamic status of a particular VF domain group controller.
 */
typedef struct _LW_GPU_THERMAL_POLICY_STATUS_DTC_VF
{
    /*!
     * Domain Group dynamic data. Must always be first.
     */
    LW_GPU_THERMAL_POLICY_STATUS_DOMGRP domgrp;

    /*!
     * DTC controller dynamic data.
     */
    LW_GPU_THERMAL_POLICY_STATUS_DTC dtc;
} LW_GPU_THERMAL_POLICY_STATUS_DTC_VF;

/*!
 *
 */
typedef struct _LW_GPU_THERMAL_POLICY_STATUS_DTC_VOLT
{
    /*!
     * Domain Group dynamic data. Must always be first.
     */
    LW_GPU_THERMAL_POLICY_STATUS_DOMGRP domgrp;

    /*!
     * DTC controller dynamic data.
     */
    LW_GPU_THERMAL_POLICY_STATUS_DTC dtc;
} LW_GPU_THERMAL_POLICY_STATUS_DTC_VOLT;

/*!
 * Used in \ref LW_GPU_THERMAL_POLICY_STATUS_PARAMS_V1. Structure representing
 * the dynamic state associated with a Thermal Policy entry.
 */
typedef struct _LW_GPU_THERMAL_POLICY_STATUS_V1
{
    /*!
     * LW_GPU_THERMAL_POLICY_TYPE_<xyz>
     */
    LW_GPU_THERMAL_POLICY_TYPE type;

    /*!
     * Current value retrieved from the monitored Thermal Channel. Stored as 1/256 degree Celsius.
     */
    LwS32 valueLwrr;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    LwU8 rsvd[16];

    /*!
     * Type-specific dynamic state.
     */
    union
    {
        LW_GPU_THERMAL_POLICY_STATUS_DOMGRP         domGrp;
        LW_GPU_THERMAL_POLICY_STATUS_DTC_VPSTATE    dtcVpstate;
        LW_GPU_THERMAL_POLICY_STATUS_DTC_VF         dtcVf;
        LW_GPU_THERMAL_POLICY_STATUS_DTC_VOLT       dtcVolt;
    } data;
} LW_GPU_THERMAL_POLICY_STATUS_V1;

/*!
 * Used in \ref LwAPI_GPU_ThermalPolicyGetStatus. Structure representing the
 * dynamic status information associated with a set of Thermal Policies within
 * the GPU's Thermal Policy functionality.
 */
typedef struct _LW_GPU_THERMAL_POLICY_STATUS_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first.
     */
    LwU32 version;

    /*!
     * Mask of Thermal Policy entries requested by the client.
     */
    LwU32 policyMask;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    LwU8 rsvd[16];

    /*!
     * Array of Thermal Policy entries. Has valid indexes corresponding to
     * the bits set in \ref policyMask.
     */
    LW_GPU_THERMAL_POLICY_STATUS_V1 policies[LW_GPU_THERMAL_POLICY_MAX_POLICIES_V1];
} LW_GPU_THERMAL_POLICY_STATUS_PARAMS_V1;

#define LW_GPU_THERMAL_POLICY_STATUS_PARAMS_VER_1   MAKE_LWAPI_VERSION(LW_GPU_THERMAL_POLICY_STATUS_PARAMS_V1,1)
#define LW_GPU_THERMAL_POLICY_STATUS_PARAMS_VER     LW_GPU_THERMAL_POLICY_STATUS_PARAMS_VER_1

#define LW_GPU_THERMAL_POLICY_STATUS_PARAMS         LW_GPU_THERMAL_POLICY_STATUS_PARAMS_V1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_ThermalPolicyGetStatus()
//
//! DESCRIPTION:    Retrieves the current dynamic state of a set of Thermal
//!                 Policy entries on the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 328.00
//!
//! \param [in]     hPhysicalGpu    GPU selection
//! \param [in/out] pPolicyStatus
//!     Structure containing the state of a set of Thermal Policies.
//!
//! \return This API can return any of the error codes enumerated in
//!         #LwAPI_Status. If there are return error codes with specific
//!         meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ThermalPolicyGetStatus(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_THERMAL_POLICY_STATUS_PARAMS *pPolicyStatus);



//! \ingroup gputhermal
//! @{

/*!
 * Used in \ref LW_GPU_THERMAL_POLICY_DTC_CONTROL,
 * \ref LW_GPU_THERMAL_POLICY_DTC_VPSTATE_CONTROL, and
 * \ref LW_GPU_THERMAL_POLICY_DTC_VOLT_CONTROL. Structure representing the
 * domain group controller.
 */
typedef struct _LW_GPU_THERMAL_POLICY_DOMGRP_CONTROL_V1
{
    /*!
     * A boolean flag to indicate the controller shall not impose a perf.
     * limit that would cause the clocks to fall below the Rated TDP VPstate.
     */
    LwU8 hasRatedTdpVpstateFloor:1;
    LwU8 rsvd:7;
} LW_GPU_THERMAL_POLICY_DOMGRP_CONTROL_V1;

/*!
 * Used in \ref LW_GPU_THERMAL_POLICY_DTC_CONTROL,
 * \ref LW_GPU_THERMAL_POLICY_DTC_VPSTATE_CONTROL, and
 * \ref LW_GPU_THERMAL_POLICY_DTC_VOLT_CONTROL. Structure representing the
 * control parameters of the DTC algorithm.
 */
typedef struct _LW_GPU_THERMAL_POLICY_DTC_CONTROL_V1
{
    /*!
     * The number of levels the controller will step when the temperature lies
     * in the aggressive range.
     */
    LwU8 aggressiveStep;

    /*!
     * The number of levels the controller will step when the temperature lies
     * in the release range.
     */
    LwU8 releaseStep;

    /*!
     * The number of contiguous samples the controller must have in the hold
     * range before increasing the perf. by one controller level. A value of
     * 0xFF specifies the controller will not increase perf. while in the hold
     * range.
     */
    LwU8 holdSampleThreshold;

    /*!
     * The number of contiguous samples the controller must have in the
     * aggressive, moderate, or release range before holding the perf. level,
     * allowing any temperature lag to catch up.
     */
    LwU8 stepSampleThreshold;

    /*!
     * Critical temperature threshold. Value is stored as signed 1/256 degree Celsius.
     */
    LwS32 thresholdCritical;

    /*!
     * Aggressive temperature threshold. Value is stored as signed 1/256 degree Celsius.
     */
    LwS32 thresholdAggressive;

    /*!
     * Moderate temperature threshold. Value is stored as signed 1/256 degree Celsius.
     */
    LwS32 thresholdModerate;

    /*!
     * Release temperature threshold. Value is stored as signed 1/256 degree Celsius.
     */
    LwS32 thresholdRelease;

    /*!
     * Disengage temperature threshold. Value is stored as signed 1/256 degree Celsius.
     */
    LwS32 thresholdDisengage;
} LW_GPU_THERMAL_POLICY_DTC_CONTROL_V1;

/*!
 * Used in \ref LW_GPU_THERMAL_POLICY_CONTROL_V1. Structure representing the
 * DTC temperature controller that uses virtual P-states as its limits.
 */
typedef struct _LW_GPU_THERMAL_POLICY_DTC_VPSTATE_CONTROL_V1
{
    /*!
     * Domain group controller control parameters. Must always be first!
     */
    LW_GPU_THERMAL_POLICY_DOMGRP_CONTROL_V1 super;

    /*!
     * DTC control algorithm control parameters.
     */
    LW_GPU_THERMAL_POLICY_DTC_CONTROL_V1 dtc;
} LW_GPU_THERMAL_POLICY_DTC_VPSTATE_CONTROL_V1;

/*!
 * Used in \ref LW_GPU_THERMAL_POLICY_CONTROL_V1. Structure representing the
 * DTC temperature controller that uses VF points as its limits.
 */
typedef struct _LW_GPU_THERMAL_POLICY_DTC_VF_CONTROL_V1
{
    /*!
     * Domain group controller control parameters. Must always be first!
     */
    LW_GPU_THERMAL_POLICY_DOMGRP_CONTROL_V1 super;

    /*!
     * DTC control algorithm control parameters.
     */
    LW_GPU_THERMAL_POLICY_DTC_CONTROL_V1 dtc;
} LW_GPU_THERMAL_POLICY_DTC_VF_CONTROL_V1;

/*!
 * Used in \ref LW_GPU_THERMAL_POLICY_CONTROL_V1. Structure representing the
 * DTC temperature controller that uses voltage as its limits.
 */
typedef struct _LW_GPU_THERMAL_POLICY_DTC_VOLT_CONTROL_V1
{
    /*!
     * Domain group controller control parameters. Must always be first!
     */
    LW_GPU_THERMAL_POLICY_DOMGRP_CONTROL_V1 super;

    /*!
     * DTC control algorithm control parameters.
     */
    LW_GPU_THERMAL_POLICY_DTC_CONTROL_V1 dtc;
} LW_GPU_THERMAL_POLICY_DTC_VOLT_CONTROL_V1;

/*!
 * Used in \ref LW_GPU_THERMAL_POLICY_CONTROL_PARAMS_V1. Structure representing
 * the control/policy parameters of a Thermal Policy entry.
 */
typedef struct _LW_GPU_THERMAL_POLICY_CONTROL_V1
{
    /*!
     * LW_GPU_THERMAL_POLICY_TYPE_<xyz>
     */
    LW_GPU_THERMAL_POLICY_TYPE type;

    /*!
     * Current limit value to enforce as requested by a client. Must always be
     * within range of [\ref LW_GPU_THERMAL_POLICY_INFO_V1::limitMin, \ref
     * LW_GPU_THERMAL_POLICY_INFO_V1::limitMax].
     */
    LwS32 limitLwrr;

    /*!
     * Current polling period of the thermal policy. A value of 0 indicates
     * the policy does not actively poll the thermal channel it is monitoring.
     * Units are in microseconds.
     */
    LwU32 pollingPeriodms;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    LwU8 rsvd[16];

    /*!
     * Type-specific data.
     */
    union
    {
        LW_GPU_THERMAL_POLICY_DTC_VPSTATE_CONTROL_V1    dtcVpstate;
        LW_GPU_THERMAL_POLICY_DTC_VF_CONTROL_V1         dtcVf;
        LW_GPU_THERMAL_POLICY_DTC_VOLT_CONTROL_V1       dtcVolt;
        /*!
         * Reserving 32 bytes for future use w/o needing to add new structure
         * version.
         */
        LwU8 rsvd[32];
    } data;
} LW_GPU_THERMAL_POLICY_CONTROL_V1;
/*!
 * Used in \ref LwAPI_GPU_ThermalPolicyGetControl, \ref LwAPI_GPU_ThermalPolicySetControl.
 * Structure representing the control/policy parameters associated with a set
 * of Thermal Policy entries in the GPU's thermal policy functionality.
 */
typedef struct
{
    /*!
     * Version of structure. Must always be first.
     */
    LwU32 version;

    /*!
     * Mask of Thermal Policy entries requested by the client.
     */
    LwU32 policyMask;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    LwU8 rsvd[16];

    /*!
     * Array of Thermal Policy entries. Has valid indexes corresponding to the
     * bits set in \ref policyMask.
     */
    LW_GPU_THERMAL_POLICY_CONTROL_V1 policies[LW_GPU_THERMAL_POLICY_MAX_POLICIES_V1];
} LW_GPU_THERMAL_POLICY_CONTROL_PARAMS_V1;

#define LW_GPU_THERMAL_POLICY_CONTROL_PARAMS_VER_1  MAKE_LWAPI_VERSION(LW_GPU_THERMAL_POLICY_CONTROL_PARAMS_V1,1)
#define LW_GPU_THERMAL_POLICY_CONTROL_PARAMS_VER    LW_GPU_THERMAL_POLICY_CONTROL_PARAMS_VER_1

#define LW_GPU_THERMAL_POLICY_CONTROL_PARAMS        LW_GPU_THERMAL_POLICY_CONTROL_PARAMS_V1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_ThermalPolicyGetControl()
//
//! DESCRIPTION:    This function retrieves the current control/policy of a
//!                 set of thermal policy entries in the RM/PMU's Thermal
//!                 Policy functionality.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 238.00
//!
//! \param [in]     hPhysicalGpu    GPU selection
//! \param [in/out] pPolicyControl
//!     Structure containing the current control/policy of a set of Thermal
//!     Policy entries.
//!
//! \return This API can return any of the error codes enumerated in
//!         #LwAPI_Status. If there are return error codes with specific
//!         meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ThermalPolicyGetControl(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_THERMAL_POLICY_CONTROL_PARAMS *pPolicyControl);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_ThermalPolicySetControl()
//
//! DESCRIPTION:    This function requests the control/policy of a set of
//!                 thermal policy entries in the RM/PMU's Thermal Policy
//!                 functionality.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 328.00
//!
//! \param [in]     hPhysicalGpu    GPU selection
//! \param [in]     hPolicyControl
//!     Structure containing the requested control/policy of a set of Thermal
//!     Policy entries.
//!
//! \return This API can return any of the error codes enumerated in
//!         #LwAPI_Status. If there are return error codes with specific
//!         meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ThermalPolicySetControl(__in LwPhysicalGpuHandle hPhysicalGpu, __in LW_GPU_THERMAL_POLICY_CONTROL_PARAMS *pPolicyControl);



//! \addtogroup gputhermal
//! @{

/*!
 * Enumeration of Thermal Policies.  Unique identifiers for different Thermal
 * Policies being enforced on the GPU.
 */
typedef enum
{
    LW_GPU_CLIENT_THERMAL_POLICIES_POLICY_GPS,
    LW_GPU_CLIENT_THERMAL_POLICIES_POLICY_ACOUSTIC,
} LW_GPU_CLIENT_THERMAL_POLICIES_POLICY_ID;

/*!
 * Enumeration of thermal readings.  Specifies the type of temperature reading
 * that is driving the Thermal Policy.
 */
typedef enum
{
    LW_GPU_CLIENT_THERMAL_READING_ID_GPU_AVG,
    LW_GPU_CLIENT_THERMAL_READING_ID_GPU_MAX,
    LW_GPU_CLIENT_THERMAL_READING_ID_BOARD,
    LW_GPU_CLIENT_THERMAL_READING_ID_MEMORY,
    LW_GPU_CLIENT_THERMAL_READING_ID_PWR_SUPPLY
} LW_GPU_CLIENT_THERMAL_READING_ID;

#define LW_GPU_CLIENT_THERMAL_POLICIES_NUM_POLICIES_MAX      4

/*!
 * Used in \ref LW_GPU_CLIENT_THERMAL_POLICIES_INFO_V1.
 */
typedef struct
{
    /*!
     * Policy ID.  Unique identifier for a policy.
     */
    LW_GPU_CLIENT_THERMAL_POLICIES_POLICY_ID policyId;

    /*!
     * Thermal reading ID driving this thermal policy.
     */
    LW_GPU_CLIENT_THERMAL_READING_ID channelId;

    /*!
     * Minimum allowed thermal policy limit.
     */
    LwS32 thermalLimitMin;

    /*!
     * Default thermal policy limit.
     */
    LwS32 thermalLimitDefault;

    /*!
     * Maximum allowed thermal policy limit.
     */
    LwS32 thermalLimitMax;

} LW_GPU_CLIENT_THERMAL_POLICIES_POLICY_INFO_V1;

/*!
 * Used in \ref LW_GPU_CLIENT_THERMAL_POLICIES_INFO_V2.
 */
typedef struct
{
    /*!
     * Policy ID.  Unique identifier for a policy.
     */
    LW_GPU_CLIENT_THERMAL_POLICIES_POLICY_ID policyId;

    /*!
     * Thermal reading ID driving this thermal policy.
     */
    LW_GPU_CLIENT_THERMAL_READING_ID channelId;

    /*!
     * Minimum allowed thermal policy limit.
     */
    LwS32 thermalLimitMin;

    /*!
     * Default thermal policy limit.
     */
    LwS32 thermalLimitDefault;

    /*!
     * Maximum allowed thermal policy limit.
     */
    LwS32 thermalLimitMax;

    /*!
     * Specifies whether or not the thermal policy can impose greater
     * performance restrictions to maintain acoustic levels.
     */
    LwU8 acousticPreferenceAvailable:1;
    LwU8 reserved                   :7;

} LW_GPU_CLIENT_THERMAL_POLICIES_POLICY_INFO_V2;

/*!
 * Used in \ref LW_GPU_CLIENT_THERMAL_POLICIES_INFO_V1.
 *
 * Describes the set of Thermal Policies which are controlling GPU temperature.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32 version;

    /*!
     * Indicates that this GPU support Client Thermal Policy Interfaces.
     */
    LwU8 isSupported:1;
    LwU8 reserved   :7;

    /*!
     * Number of Thermal Policies this GPU supports.
     */
    LwU8 numPolicies;

    /*
     * Array of static information for each Thermal Policy.  Array has a valid
     * index ranging from 0 to numPolicies - 1.
     */
    LW_GPU_CLIENT_THERMAL_POLICIES_POLICY_INFO_V1
        policies[LW_GPU_CLIENT_THERMAL_POLICIES_NUM_POLICIES_MAX];

} LW_GPU_CLIENT_THERMAL_POLICIES_INFO_V1;

/*!
 * Used in \ref LW_GPU_CLIENT_THERMAL_POLICIES_INFO_V2.
 *
 * Describes the set of Thermal Policies which are controlling GPU temperature.
 */
typedef struct _LW_GPU_CLIENT_THERMAL_POLICIES_INFO_V2
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32 version;

    /*!
     * Indicates that this GPU support Client Thermal Policy Interfaces.
     */
    LwU8 isSupported:1;
    LwU8 reserved   :7;

    /*!
     * Number of Thermal Policies this GPU supports.
     */
    LwU8 numPolicies;

    /*
     * Array of static information for each Thermal Policy.  Array has a valid
     * index ranging from 0 to numPolicies - 1.
     */
    LW_GPU_CLIENT_THERMAL_POLICIES_POLICY_INFO_V2
        policies[LW_GPU_CLIENT_THERMAL_POLICIES_NUM_POLICIES_MAX];

} LW_GPU_CLIENT_THERMAL_POLICIES_INFO_V2;

#define LW_GPU_CLIENT_THERMAL_POLICIES_INFO_VER_1 MAKE_LWAPI_VERSION(LW_GPU_CLIENT_THERMAL_POLICIES_INFO_V1,1)
#define LW_GPU_CLIENT_THERMAL_POLICIES_INFO_VER_2 MAKE_LWAPI_VERSION(LW_GPU_CLIENT_THERMAL_POLICIES_INFO_V2,2)
#define LW_GPU_CLIENT_THERMAL_POLICIES_INFO_VER   LW_GPU_CLIENT_THERMAL_POLICIES_INFO_VER_2

typedef LW_GPU_CLIENT_THERMAL_POLICIES_INFO_V2    LW_GPU_CLIENT_THERMAL_POLICIES_INFO;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_ClientThermalPoliciesGetInfo
//
//! DESCRIPTION: Accessor for static information describing the public GPU
//!              thermal policies which are controlling GPU temperature.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 310
//!
//! \param [in]  hPhysicalGpu               GPU selection
//! \param [out] pClientThermalPoliciesInfo Structure containing the description
//!                  of the GPU thermal policies.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ClientThermalPoliciesGetInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_CLIENT_THERMAL_POLICIES_INFO *pClientThermalPoliciesInfo);



//! \addtogroup gputhermal
//! @{

/*!
 * Used in \ref LW_GPU_CLIENT_THERMAL_POLICIES_STATUS_V1.
 */
typedef struct
{
    /*!
     * Policy ID.  Unique identifier for a policy.
     */
    LW_GPU_CLIENT_THERMAL_POLICIES_POLICY_ID policyId;

    /*!
     * Current thermal policy limit.
     */
    LwS32 thermalLimit;
} LW_GPU_CLIENT_THERMAL_POLICIES_POLICY_STATUS_V1;

/*!
 * Used in \ref LW_GPU_CLIENT_THERMAL_POLICIES_STATUS_V2.
 */
typedef struct _LW_GPU_CLIENT_THERMAL_POLICIES_POLICY_STATUS_V2
{
    /*!
     * Policy ID.  Unique identifier for a policy.
     */
    LW_GPU_CLIENT_THERMAL_POLICIES_POLICY_ID policyId;

    /*!
     * Current thermal policy limit.
     */
    LwS32 thermalLimit;

    /*!
     * Specifies the calling is willing to sacrifice performance to maintain
     * acoustics.
     */
    LwU8 preferAcoustics:1;
    LwU8 reserved       :7;

} LW_GPU_CLIENT_THERMAL_POLICIES_POLICY_STATUS_V2;

/*!
 * Used in \ref LW_GPU_CLIENT_THERMAL_POLICIES_STATUS_V1.
 *
 * Describes/specifies the current settings of a set of Thermal Policies which
 * are controlling GPU temperature.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32 version;

    /*!
     * Number of Thermal Policies specified in the policies array.  Caller sets
     * this value to 0 to specify that all policies should be queried.
     */
    LwU8 numPolicies;

    /*!
     * Array of current settings for each specified Thermal Policy.  This array
     * has a valid index ranging from 0 to numPolicies - 1.
     */
    LW_GPU_CLIENT_THERMAL_POLICIES_POLICY_STATUS_V1
        policies[LW_GPU_CLIENT_THERMAL_POLICIES_NUM_POLICIES_MAX];

} LW_GPU_CLIENT_THERMAL_POLICIES_STATUS_V1;

/*!
 * Used in \ref LW_GPU_CLIENT_THERMAL_POLICIES_STATUS_V2.
 *
 * Describes/specifies the current settings of a set of Thermal Policies which
 * are controlling GPU temperature.
 */
typedef struct _LW_GPU_CLIENT_THERMAL_POLICIES_STATUS_V2
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32 version;

    /*!
     * Number of Thermal Policies specified in the policies array.  Caller sets
     * this value to 0 to specify that all policies should be queried.
     */
    LwU8 numPolicies;

    /*!
     * Array of current settings for each specified Thermal Policy.  This array
     * has a valid index ranging from 0 to numPolicies - 1.
     */
    LW_GPU_CLIENT_THERMAL_POLICIES_POLICY_STATUS_V2
        policies[LW_GPU_CLIENT_THERMAL_POLICIES_NUM_POLICIES_MAX];

} LW_GPU_CLIENT_THERMAL_POLICIES_STATUS_V2;

#define LW_GPU_CLIENT_THERMAL_POLICIES_STATUS_VER_1 MAKE_LWAPI_VERSION(LW_GPU_CLIENT_THERMAL_POLICIES_STATUS_V1,1)
#define LW_GPU_CLIENT_THERMAL_POLICIES_STATUS_VER_2 MAKE_LWAPI_VERSION(LW_GPU_CLIENT_THERMAL_POLICIES_STATUS_V2,2)
#define LW_GPU_CLIENT_THERMAL_POLICIES_STATUS_VER   LW_GPU_CLIENT_THERMAL_POLICIES_STATUS_VER_2

typedef LW_GPU_CLIENT_THERMAL_POLICIES_STATUS_V2    LW_GPU_CLIENT_THERMAL_POLICIES_STATUS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_ClientThermalPoliciesGetStatus
//
// !DESCRIPTION: Accessor for current state of the public GPU thermal
//!              policies which are controlling GPU temperature.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 310
//!
//! \param [in]  hPhysicalGpu                 GPU selection
//! \param [out] pClientThermalPoliciesStatus Structure containing the current
//!                  state of a set of GPU thermal policies.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ClientThermalPoliciesGetStatus(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_CLIENT_THERMAL_POLICIES_STATUS *pClientThermalPoliciesStatus);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_ClientThermalPoliciesSetStatus
//
//! DESCRIPTION: Mutator for state of the public GPU thermal policies which
//!              are controlling GPU temperature.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 310
//!
//! \param [in] hPhysicalGpu                 GPU selection
//! \param [in] pClientThermalPoliciesStatus Structure containing the requested
//!                 state of a set of GPU thermal policies.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ClientThermalPoliciesSetStatus(__in LwPhysicalGpuHandle hPhysicalGpu, __in LW_GPU_CLIENT_THERMAL_POLICIES_STATUS *pClientThermalPoliciesStatus);





//! \ingroup gpu
//! Used in LwAPI_GPU_SetDitherControl(). 
typedef enum _LWAPI_DITHER_TYPE
{
    LWAPI_DITHER_TYPE_DEFAULT = 0,  //!< enable/disable based on the default behavior
    LWAPI_DITHER_TYPE_ENABLE  = 1,  //!< enable dithering
    LWAPI_DITHER_TYPE_DISABLE = 2,  //!< disable dithering
} LWAPI_DITHER_TYPE;


//! \ingroup gpu
//! Used in LwAPI_GPU_SetDitherControl().
typedef enum _LWAPI_DITHER_BITS
{
    LWAPI_DITHER_BITS_6BITS = 0,
    LWAPI_DITHER_BITS_8BITS = 1,
    LWAPI_DITHER_BITS_10BITS = 2,
} LWAPI_DITHER_BITS;


//! \ingroup gpu
//! Used in LwAPI_GPU_SetDitherControl().
typedef enum _LWAPI_DITHER_MODE
{
    LWAPI_DITHER_MODE_DYNAMIC_ERR_ACC = 0,
    LWAPI_DITHER_MODE_STATIC_ERR_ACC  = 1,
    LWAPI_DITHER_MODE_DYNAMIC_2X2     = 2,
    LWAPI_DITHER_MODE_STATIC_2X2      = 3,
    LWAPI_DITHER_MODE_TEMPORAL        = 4,
} LWAPI_DITHER_MODE;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_SetDitherControl
//
//! DESCRIPTION: This API sets display related hardware dither controls (for example, dithering a higher bpp framebuffer to a lower bpp display).
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]  outputId     One of the selected outputId retrieved from LwAPI_GPU_GetActiveOutputs() or
//!                           LwAPI_GetView(), to identify the targeted TV.
//! \param [in]  type         The dithering mode to apply (default, enable, or disable)
//! \param [in]  bits         The bits to dither to
//! \param [in]  mode         The dither mode
//!
//! \retval ::LWAPI_OK                             Dither controls successfully set.
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE   Handle passed is not a physical GPU handle.
//! \retval ::LWAPI_ILWALID_ARGUMENT               Parameters passed do not match the hardware implementation.
//! \retval ::LWAPI_NOT_SUPPORTED                  Dither control feature is not supported on the selected GPU.
//! \retval ::LWAPI_NO_IMPLEMENTATION              No implementation for dither controls implemented for this GPU.
//! \retval ::LWAPI_ERROR                          Dither controls were not successfully propogated
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetDitherControl(LwPhysicalGpuHandle hPhysicalGpu,
                                           LwU32 outputId,
                                           LWAPI_DITHER_TYPE type,
                                           LWAPI_DITHER_BITS bits,
                                           LWAPI_DITHER_MODE mode);



//! \ingroup gpu
//! @{

typedef enum _LWAPI_DITHER_CONTROL_CAP_MODE
{
    LWAPI_DITHER_CONTROL_CAP_MODE_DYNAMIC_ERR_ACC     = LW_BIT(LWAPI_DITHER_MODE_DYNAMIC_ERR_ACC),
    LWAPI_DITHER_CONTROL_CAP_MODE_STATIC_ERR_ACC      = LW_BIT(LWAPI_DITHER_MODE_STATIC_ERR_ACC),
    LWAPI_DITHER_CONTROL_CAP_MODE_DYNAMIC_2X2         = LW_BIT(LWAPI_DITHER_MODE_DYNAMIC_2X2),
    LWAPI_DITHER_CONTROL_CAP_MODE_STATIC_2X2          = LW_BIT(LWAPI_DITHER_MODE_STATIC_2X2),
    LWAPI_DITHER_CONTROL_CAP_MODE_TEMPORAL            = LW_BIT(LWAPI_DITHER_MODE_TEMPORAL),
} LWAPI_DITHER_CONTROL_CAP_MODE;

typedef enum _LWAPI_DITHER_CONTROL_CAP_BITS
{
    LWAPI_DITHER_CONTROL_CAP_BITS_6BITS               = LW_BIT(LWAPI_DITHER_BITS_6BITS),
    LWAPI_DITHER_CONTROL_CAP_BITS_8BITS               = LW_BIT(LWAPI_DITHER_BITS_8BITS),
    LWAPI_DITHER_CONTROL_CAP_BITS_10BITS              = LW_BIT(LWAPI_DITHER_BITS_10BITS),
} LWAPI_DITHER_CONTROL_CAP_BITS;

typedef struct _LW_GPU_DITHER_CONTROL_V1
{
    LwU32               version;            //!< Structure version

    LWAPI_DITHER_TYPE   ditherEnable;       //!< The dithering mode to apply (default, enable, or disable)
    LWAPI_DITHER_BITS   ditherBitDepth;     //!< The bits per component of the output
    LWAPI_DITHER_MODE   ditherMode;         //!< The dither mode

    LwU32               ditherBitDepths;    //!< Bitfield of supported LWAPI_DITHER_CONTROL_CAP_MODEs
    LwU32               ditherModes;        //!< Bitfield of supported LWAPI_DITHER_CONTROL_CAP_BITS


} LW_GPU_DITHER_CONTROL_V1;

typedef LW_GPU_DITHER_CONTROL_V1           LW_GPU_DITHER_CONTROL;

#define LW_GPU_DITHER_CONTROL_VER1         MAKE_LWAPI_VERSION(LW_GPU_DITHER_CONTROL_V1,1)
#define LW_GPU_DITHER_CONTROL_VER          LW_GPU_DITHER_CONTROL_VER1

//! @}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetDitherControl
//
//! DESCRIPTION: This API returns display-related GPU dither controls. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    displayId     Address of target active GPU output
//! \param [out]   pDitherData   Struct containing dithering state information
//!
//! \retval ::LWAPI_OK                            Dither controls successfully received.
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//! \retval ::LWAPI_ILWALID_ARGUMENT              Parameters passed do not match the hardware implementation
//! \retval ::LWAPI_NOT_SUPPORTED                 Dither control feature is not supported on the selected GPU
//! \retval ::LWAPI_NO_IMPLEMENTATION             No implementation for dither controls implemented for this GPU
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetDitherControl(LwU32 displayId, 
                                           LW_GPU_DITHER_CONTROL *pDitherData);


//! \ingroup gpucsc  
//! @{

#define LWAPI_CSC_MATRIX_WIDTH 3
#define LWAPI_CSC_MATRIX_HEIGHT 4

//! Colorspace colwersion
typedef struct _LWAPI_CSC_MATRIX
{
    LwU32   useLwstomMatrix : 1;                                           //!< If this value is 0, aCSCCoeff values are ignored.
    LwU32   reserved        : 31;                                          //!< Reserved for future expansion
    float   aCSCCoeff [LWAPI_CSC_MATRIX_WIDTH][LWAPI_CSC_MATRIX_HEIGHT];   //!< 3x4 matrix of CSC coefficients
} LWAPI_CSC_MATRIX;

//! Enum of predefined colorspaces that are supported
typedef enum _LW_STANDARD_COLORSPACE
{
    LW_STANDARD_COLORSPACE_DISABLED            = 0,                             //!< CSC disabled, user matrices ignored
    LW_STANDARD_COLORSPACE_AUTOSELECT          = 1,                             //!< Use the display-specific info, user matrices ignored.
    LW_STANDARD_COLORSPACE_sRGB                = 2,                             //!< Only user matrices are applied, output is sRGB
    LW_STANDARD_COLORSPACE_MONITOR_RGB         = 3,                             //!< Use the display-specific info, plus user matrices if indicated
    LW_STANDARD_COLORSPACE_ADOBE_RGB           = 4,                             //!< output is in Adobe RGB, plus user matrices if indicated
    LW_STANDARD_COLORSPACE_ADOBE_WIDE_GAMUT    = 5,                             //!< output is in Adobe Wide Gamut RGB, plus user matrices if indicated
    LW_STANDARD_COLORSPACE_APPLE               = 6,                             //!< output is in Apple RGB, plus user matrices if indicated
    LW_STANDARD_COLORSPACE_NTSC                = 7,                             //!< output is in NTSC RGB, plus user matrices if indicated
    LW_STANDARD_COLORSPACE_HDTV                = 8,                             //!< output is in HDTV RGB, plus user matrices if indicated
    LW_STANDARD_COLORSPACE_PAL                 = 9,                             //!< output is in PAL/SECAM RGB, plus user matrices if indicated
    LW_STANDARD_COLORSPACE_DCIP3               = 10,                            //!< output is in DCI-P3 (SMPTE-431-2)

    LW_STANDARD_COLORSPACE_MAX                                                  //!< Max valid value +1, for range checking
} LW_STANDARD_COLORSPACE;

//! Enum of colorspace status flags
typedef enum _LW_COLORSPACE_COLWERSION_STATUS_FLAG
{
    LW_COLORSPACE_COLWERSION_STATUS_FLAG_USER_MATRIX_RANGE_CLAMPED = LW_BIT(0),  //!< If User Matrix coefficients were out of range, this flag means some values were automatically clamped to range
    LW_COLORSPACE_COLWERSION_STATUS_FLAG_SW_EMULATION              = LW_BIT(1),  //!< If present, CSC is performed by pixel shaders.  Otherwise, CSC is done in dedicated hardware
} LW_COLORSPACE_COLWERSION_STATUS_FLAG;




//! Param struct used by SetCSC and GetCSC
typedef struct _LW_GPU_COLORSPACE_COLWERSION_V1
{   
     LwU32                    version;                            //!<  Structure version

    LW_STANDARD_COLORSPACE   sourceColorSpace;                   //!<  Specify a predefined colorspace configuration that represents the source material
    LW_STANDARD_COLORSPACE   outputColorSpace;                   //!<  Specify a predefined colorspace configuration to output
    LwU32                    flags;                              //!<  Combination of LW_COLORSPACE_COLWERSION_STATUS_FLAGs
    LwU32                    clientID;                           //!<  Optional Client identifier generated by EnableLicense.  If zero, the system license is used.

    LWAPI_CSC_MATRIX         MatrixPre;                          //!<  Custom CSC Matrix, applied in preorder to colorspace config transform 
    LWAPI_CSC_MATRIX         MatrixPost;                         //!<  Custom CSC Matrix, applied in postorder to colorspace config transform 
} LW_GPU_COLORSPACE_COLWERSION_V1;

typedef LW_GPU_COLORSPACE_COLWERSION_V1     LW_GPU_COLORSPACE_COLWERSION;

#define LW_GPU_COLORSPACE_COLWERSION_VER1   MAKE_LWAPI_VERSION(LW_GPU_COLORSPACE_COLWERSION_V1,1)
#define LW_GPU_COLORSPACE_COLWERSION_VER    LW_GPU_COLORSPACE_COLWERSION_VER1

//! @}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetColorSpaceColwersion
//
//
//! DESCRIPTION: Returns the colorspace colwersion matrix lwrrently applied by the GPU
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    displayId     Address of target active GPU output
//! \param [out]   pColorData    Current color space colwersion data
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, 
//!         they are listed below.          
//!
//! \ingroup gpucsc
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetColorSpaceColwersion(LwU32 displayId, 
                                                  LW_GPU_COLORSPACE_COLWERSION *pColorData);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_SetColorSpaceColwersion
//
//
//! DESCRIPTION: Sets the colorspace colwersion matrix 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   displayId      Address of target active GPU output
//! \param [in]   colorData      New color space colwersion data
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, 
//!         they are listed below.          
//! \retval ::LWAPI_ACCESS_DENIED:  the client ID is not authorized or the system license is invalid.
//! 
//! \ingropup gpucsc
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetColorSpaceColwersion(LwU32 displayId, 
                                                  LW_GPU_COLORSPACE_COLWERSION *pColorData);




//! \ingroup gpulicense
//! @{
//! Enable License Commands
typedef enum _LWAPI_SYS_ENABLE_LICENSE_COMMAND
{
    LWAPI_SYS_ENABLE_LICENSE_CMD_CHALLENGE = 0x01,
    LWAPI_SYS_ENABLE_LICENSE_CMD_RESPONSE  = 0x02,
} LWAPI_SYS_ENABLE_LICENSE_COMMAND;
//! @} 

//! \ingroup gpulicense
//! @{
//! Enable License Constant: Expected Size in bytes of Challenge value
#define LWAPI_SYS_ENABLE_LICENSE_CHALLENGE_SIZE     16
//! Enable License Constant: Expected Size in bytes of Response value
#define LWAPI_SYS_ENABLE_LICENSE_RESPONSE_SIZE      20
//! @} 

//! \ingroup gpulicense
//! @{
//! Parameter data structure for the LWAPI_SYS_ENABLE_LICENSE_CMD_CHALLENGE command - 
//! This command requests a random challenge from driver.
//! It must be ilwoked before the LWAPI_SYS_ENABLE_LICENSE_CMD_RESPONSE command.
typedef struct _LWAPI_SYS_ENABLE_LICENSE_CHALLENGE_PARAMS
{
    LwU8  challenge[LWAPI_SYS_ENABLE_LICENSE_CHALLENGE_SIZE];    //!< random challenge from driver (OUT)
} LWAPI_SYS_ENABLE_LICENSE_CHALLENGE_PARAMS;

//
//! Parameter data structure for the LWAPI_SYS_ENABLE_LICENSE_CMD_RESPONSE command
//!
//! The response is callwlated as HMAC(vendorKEY, (vendorGUID || challenge))
//! where HMAC is the Keyed-Hash Message Authentication Code using SHA-1 as the
//! underlying hash function. See FIPS Publication 198 for details of the algorithm.
typedef struct _LWAPI_SYS_ENABLE_LICENSE_RESPONSE_PARAMS
{
    LwU8   response[LWAPI_SYS_ENABLE_LICENSE_RESPONSE_SIZE];    //!< response from the app (IN/OUT)
} LWAPI_SYS_ENABLE_LICENSE_RESPONSE_PARAMS;

typedef struct _LWAPI_SYS_ENABLE_LICENSE
{
    LwU32  version;                                //!< structure version (IN)
    LWAPI_SYS_ENABLE_LICENSE_COMMAND dwCommand;    //!< command (IN)
    LwGUID vendorGUID;                             //!< vendor GUID from app (IN)
    union
    {
        LWAPI_SYS_ENABLE_LICENSE_CHALLENGE_PARAMS   ChallengeParams;
        LWAPI_SYS_ENABLE_LICENSE_RESPONSE_PARAMS    ResponseParams;
        LwU32                                       ClientID;
    };
} LWAPI_SYS_ENABLE_LICENSE_V1;
//! @} 

//! \ingroup gpulicense
//! @{
typedef LWAPI_SYS_ENABLE_LICENSE_V1      LWAPI_SYS_ENABLE_LICENSE;
#define LWAPI_SYS_ENABLE_LICENSE_VER1    MAKE_LWAPI_VERSION(LWAPI_SYS_ENABLE_LICENSE_V1, 1)
#define LWAPI_SYS_ENABLE_LICENSE_VER     LWAPI_SYS_ENABLE_LICENSE_VER1
//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION_NAME: LwAPI_SYS_EnableLicense
//
//!   DESCRIPTION:   This API allows an approved application to enable an ISV client 
//!    to access a specific feature for which a license is required.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, 
//!         they are listed below.          
//!
//! \ingroup gpulicense
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_EnableLicense(__inout LWAPI_SYS_ENABLE_LICENSE *pEnableLicenseParams);



///////////////////////////////////////////////////////////////////////////////////
//  GPU topology reconfiguration APIs.
//  Provides ability to define one or more SLI devices and standalone GPU topology.
//
//  LW_GPU_TOPOLOGY - this structure defines a set of all GPUs present in a system.  All GPUs with
//  the same parentNdx value describe a single logical GPU.  GPUs that have a unique parentNdx
//  represent standalone GPUs. 
//
//  The values returned in parentNdx are arbitrary.  They are only used to determine which
//  physical GPUs will belong to the same logical-GPU.
//   

//! \addtogroup gputopology
//! @{

//! Used in LW_GPU_TOPOLOGY
typedef enum
{ 
    LW_GPU_TOPOLOGY_STATUS_OK                       = 0x00000000,//!< SLI is capable, topology "status" field indicates this state.
    LW_GPU_TOPOLOGY_STATUS_ILWALID_GPU_COUNT        = 0x00000001,//!< SLI is NOT capable, "pStatus" param in LwAPI_GetValidGpuTopologies() indicates these states.
    LW_GPU_TOPOLOGY_STATUS_OS_NOT_SUPPORTED         = 0x00000002,
    LW_GPU_TOPOLOGY_STATUS_OS_ERROR                 = 0x00000004,
    LW_GPU_TOPOLOGY_STATUS_NO_VIDLINK               = 0x00000008,
    LW_GPU_TOPOLOGY_STATUS_INSUFFICIENT_LINK_WIDTH  = 0x00000010,
    LW_GPU_TOPOLOGY_STATUS_CPU_NOT_SUPPORTED        = 0x00000020,
    LW_GPU_TOPOLOGY_STATUS_GPU_NOT_SUPPORTED        = 0x00000040,
    LW_GPU_TOPOLOGY_STATUS_BUS_NOT_SUPPORTED        = 0x00000080,
    LW_GPU_TOPOLOGY_STATUS_NON_APPROVED_CHIPSET     = 0x00000100,
    LW_GPU_TOPOLOGY_STATUS_VBIOS_NOT_SUPPORTED      = 0x00000200,
    LW_GPU_TOPOLOGY_STATUS_GPU_MISMATCH             = 0x00000400,
    LW_GPU_TOPOLOGY_STATUS_ARCH_MISMATCH            = 0x00000800,
    LW_GPU_TOPOLOGY_STATUS_IMPL_MISMATCH            = 0x00001000,
    LW_GPU_TOPOLOGY_STATUS_REV_MISMATCH             = 0x00002000,
    LW_GPU_TOPOLOGY_STATUS_NON_PCIE_BUS             = 0x00004000,
    LW_GPU_TOPOLOGY_STATUS_FB_MISMATCH              = 0x00008000,
    LW_GPU_TOPOLOGY_STATUS_VBIOS_MISMATCH           = 0x00010000,
    LW_GPU_TOPOLOGY_STATUS_QUADRO_MISMATCH          = 0x00020000,
    LW_GPU_TOPOLOGY_STATUS_BUS_TOPOLOGY_ERROR       = 0x00040000,
    LW_GPU_TOPOLOGY_STATUS_PCI_ID_MISMATCH          = 0x00080000,
    LW_GPU_TOPOLOGY_STATUS_CONFIGSPACE_ACCESS_ERROR = 0x00100000,
    LW_GPU_TOPOLOGY_STATUS_INCONSISTENT_CONFIG_SPACE= 0x00200000,
    LW_GPU_TOPOLOGY_STATUS_CONFIG_NOT_SUPPORTED     = 0x00400000,
    LW_GPU_TOPOLOGY_STATUS_RM_NOT_SUPPORTED         = 0x00800000,
    LW_GPU_TOPOLOGY_STATUS_TOPOLOGY_NOT_ALLOWED     = 0x01000000,
    LW_GPU_TOPOLOGY_STATUS_MOBILE_MISMATCH          = 0x02000000,//!< The system has a mix of notebook and desktop GPUs.
    LW_GPU_TOPOLOGY_STATUS_NO_TOPOLOGIES_IN_HYBRID_POWER_MODE = 0x04000000,
    LW_GPU_TOPOLOGY_STATUS_INSUFFICIENT_FB          = 0x08000000,
    LW_GPU_TOPOLOGY_STATUS_ECC_MISMATCH             = 0x10000000,//!< The ECC state of the GPUs in the topology is mismatched
    LW_GPU_TOPOLOGY_STATUS_SLI_COOKIE_NOT_PRESENT   = 0x20000000, //!< The required SLI cookie has not been found
    LW_GPU_TOPOLOGY_STATUS_SLI_FINGER_NOT_SUPPORTED = 0x40000000, //!< The SLI bridge is connected on the wrong finger
    LW_GPU_TOPOLOGY_STATUS_SLI_WITH_ECC_NOT_SUPPORTED = 0x80000000 //!< SLI + ECC is not supported on Lwdqro
} LW_GPU_TOPOLOGY_STATUS_FLAGS;

//! Used in LwAPI_SetGpuTopologies()
typedef enum
{ 
    LW_SET_GPU_TOPOLOGY_DEFER_APPLY                 = 0x00000001,//!< Calling application controls the reload of the display driver
    LW_SET_GPU_TOPOLOGY_DEFER_3D_APP_SHUTDOWN       = 0x00000002,//!< Calling application will control the shutdown of 3d applications holding hw resources
    LW_SET_GPU_TOPOLOGY_DEFER_DISPLAY_RECONFIG      = 0x00000004,//!< Calling application will control the display configuration required for the settopology to work
    LW_SET_GPU_TOPOLOGY_RELOAD_DRIVER               = 0x80000000,//!< Calling application requesting force reload given correct topology.
    LW_SET_GPU_TOPOLOGY_DEFER_DISPLAY_REAPPLY       = 0x00000008,//!< Calling application will control the display configuration after the settopology returns.
} LW_SET_GPU_TOPOLOGY_FLAGS;


//! Used in LW_GPU_TOPOLOGY.
//! All of these flags are read-only unless otherwise noted in LwAPI_SetGpuTopologies().
typedef enum
{
    LW_GPU_TOPOLOGY_ACTIVE                          = 0x00000001,//!< This topology is lwrrently active.
    LW_GPU_TOPOLOGY_VIDLINK_PRESENT                 = 0x00000002,//!< Video link betweem all GPUs is present (physically bridged).
    LW_GPU_TOPOLOGY_MULTIGPU                        = 0x00000004,//!< This is a "multi-GPU" labelled topology. 
    LW_GPU_TOPOLOGY_GX2_BOARD                       = 0x00000008,//!< GPUs comprising this topology are "Dagwoods".
    LW_GPU_TOPOLOGY_DYNAMIC_NOT_ALLOWED             = 0x00000010,//!< Dynamically switching to SLI is not allowed, but requires a reboot.
    LW_GPU_TOPOLOGY_ACTIVE_IMPLICIT                 = 0x00000020,//!< Implicit read only SLI is ACTIVE on this topology of GPU. LwAPI_SetHybridMode() can be used to disable this topology.
    
    LW_GPU_TOPOLOGY_ENABLE_SLI_BY_DEFAULT           = 0x00000040,//!< SLI must be enabled by default, otherwise SLI is optional
    LW_GPU_TOPOLOGY_ENABLE_CORELOGIC_BROADCAST      = 0x00000080,//!< Broadcast mode is enabled in the core logic chipset.
    LW_GPU_TOPOLOGY_BROADCAST                       = 0x00000100,//!< Broadcast mode is enabled
    LW_GPU_TOPOLOGY_UNICAST                         = 0x00000200,//!< Unicast mode enabled
    LW_GPU_TOPOLOGY_4_WAY_SLI                       = 0x00000400,//!< This is a "4-Way-SLI"-labeled topology.
    LW_GPU_TOPOLOGY_COMPUTE                         = 0x00010000,//!< GPUs in this topology are for SLI compute.
                                                                 //!< All GPUs of this SLI compute group can be enumerated using LwAPI_GPU_LwdaEnumComputeCapableGpus().
    LW_GPU_TOPOLOGY_SLIMULTIMON                     = 0x00020000,//!< This topology allows multi-display SLI output. 
    LW_GPU_TOPOLOGY_VIDLINK_CONNECTOR_PRESENT       = 0x00040000,//!< Video link connectors on all GPUs are present (but not necessarily connected).
    LW_GPU_TOPOLOGY_VIEW_CAN_SPAN_GPUS              = 0x00080000,//!< This topology allows multi-display SLI output across GPUs.
    LW_GPU_TOPOLOGY_DRIVER_RELOADING                = 0x00100000,//!< The display driver for this topology is lwrrently being reloaded.
    LW_GPU_TOPOLOGY_BASE_MOSAIC                     = 0x00200000,//!< This topology is only for Base Mosaic mode.
    LW_GPU_TOPOLOGY_ALLOW_SLI_MOSAIC                = 0x00400000,//!< This topology will allow SLI Mosaic mode.
    LW_GPU_TOPOLOGY_ALLOW_SLI_MOSAIC_ONLY           = 0x00800000,//!< This topology will allow SLI Mosaic Only. Also, SLI without mosaic is not available.
} LW_GPU_TOPOLOGY_FLAGS;



typedef enum
{
    LW_SLI_GROUP_ACTIVE                          = 0x00000001,//!< This SLI group is lwrrently active.
} LW_SLI_GROUP_FLAGS;



//! Used in LW_GPU_TOPOLOGIES. 
//! This structure defines a set of all GPUs present in a system.  All GPUs with
//! the same parentNdx value describe a single logical GPU.  GPUs that have a unique parentNdx
//! represent standalone GPUs. \n
//! The values returned in parentNdx are arbitrary.  They are only used to determine which
//! physical GPUs belong to the same logical-GPU.
typedef struct
{
    LwU32                   version;                                    //!< Structure version
    LwU32                   gpuCount;                                   //!< Count of GPUs in this topology
    LwPhysicalGpuHandle     hPhysicalGpu[LWAPI_MAX_GPU_PER_TOPOLOGY];   //!< Array of GPU handles
    LwU32                   displayGpuIndex;                            //!< Index of the display GPU owner in the GPU array
    LwU32                   displayOutputTargetMask;                    //!< Target device mask
    LwU32                   flags;                                      //!< One or more topology flags from LW_GPU_TOPOLOGY_FLAGS
    LwU32                   status;                                     //!< Indicates one of the flags in LW_GPU_TOPOLOGY_STATUS_FLAGS
} LW_GPU_TOPOLOGY_V1;


//! Macro for constructing the version field of LW_GPU_TOPOLOGY_V1
#define LW_GPU_TOPOLOGY_VER_1  MAKE_LWAPI_VERSION(LW_GPU_TOPOLOGY_V1,1)

//! Used in LW_GPU_TOPOLOGIES. 
//! This structure defines a set of all GPUs present in a system.  All GPUs with
//! the same parentNdx value describe a single logical GPU.  GPUs that have a unique parentNdx
//! represent standalone GPUs. \n
//! The values returned in parentNdx are arbitrary.  They are only used to determine which
//! physical GPUs belong to the same logical-GPU.
typedef struct
{
    LwU32                   version;                                    //!< Structure version
    LwU32                   gpuCount;                                   //!< Count of GPUs in this topology
    LwPhysicalGpuHandle     hPhysicalGpu[LWAPI_MAX_GPU_PER_TOPOLOGY];   //!< Array of GPU handles
    LwU32                   displayGpuIndex;                            //!< Index of the display GPU owner in the GPU array
    union {
        LwU32               displayOutputTargetMask;                    //!< Target device mask
        LwU32               displayId;                                  //!< Target displayId
    };         
    LwU32                   noDisplayGpuMask;                           //!< Index mask in the hPhysicalGpu[] array pointing to GPUs that cannot display when SLI is enabled
    LwU32                   flags;                                      //!< One or more topology flags from LW_GPU_TOPOLOGY_FLAGS
    LwU32                   status;                                     //!< Indicates one or more of the flags defined in LW_GPU_TOPOLOGY_STATUS_FLAGS
} LW_GPU_TOPOLOGY_V2;

//! Macro for constructing the version field of LW_GPU_TOPOLOGY_V2
#define LW_GPU_TOPOLOGY_VER_2  MAKE_LWAPI_VERSION(LW_GPU_TOPOLOGY_V2,2)

#define LW_GPU_TOPOLOGY        LW_GPU_TOPOLOGY_V2
#define LW_GPU_TOPOLOGY_VER    LW_GPU_TOPOLOGY_VER_2


typedef struct
{
    LwU32                   version;                                    //!< Structure version
    LwU64                   topologyMask;                               //!< Mask of indexes in gpuTopo
    LwU32                   flags;                                      //!< One or more SLI group flags from LW_GPU_SLI_GROUP_FLAGS
} LW_SLI_GROUP;


//! Macro for constucting the version field of LW_SLI_GROUP
#define LW_GPU_SLI_GROUP_VER  MAKE_LWAPI_VERSION(LW_SLI_GROUP,1)


//! First version of LW_GPU_TOPOLOGIES
typedef struct
{
    LwU32                   version;                                    //!< Structure version
    LwU32                   gpuTopoCount;                               //!< Count of valid topologies
    LW_GPU_TOPOLOGY_V1      gpuTopo[LWAPI_MAX_AVAILABLE_GPU_TOPOLOGIES];//!< Maximum number of GPU topologies
} LW_GPU_TOPOLOGIES_V1;


//! Macro for constructing the version field of LW_GPU_TOPOLOGIES_V1
#define LW_GPU_TOPOLOGIES_VER_1  MAKE_LWAPI_VERSION(LW_GPU_TOPOLOGIES_V1,1)


//! Second version of LW_GPU_TOPOLOGIES
typedef struct
{
    LwU32                   version;                                    //!< Structure version
    LwU32                   gpuTopoCount;                               //!< Count of valid topologies
    LW_GPU_TOPOLOGY_V1      gpuTopo[LWAPI_MAX_AVAILABLE_GPU_TOPOLOGIES];//!< Maximum gputopologies
    LwU32                   sliGroupCount;                              //!< Count of valid SLI groups
    LW_SLI_GROUP            sliGroup[LWAPI_MAX_AVAILABLE_SLI_GROUPS];   //!< Maximum SLI groups
} LW_GPU_TOPOLOGIES_V2;

//! Macro for constructing the version field of LW_GPU_TOPOLOGIES_V2
#define LW_GPU_TOPOLOGIES_VER_2  MAKE_LWAPI_VERSION(LW_GPU_TOPOLOGIES_V2,2)




//! Used in LwAPI_GetValidGpuTopologies() and LwAPI_SetGpuTopologies()
typedef struct 
{
    LwU32                   version;                                    //!< Structure version
    LwU32                   gpuTopoCount;                               //!< Count of valid topologies
    LW_GPU_TOPOLOGY         gpuTopo[LWAPI_MAX_AVAILABLE_GPU_TOPOLOGIES];//!< Maximum number of GPU topologies
    LwU32                   sliGroupCount;                              //!< Count of valid SLI groups
    LW_SLI_GROUP            sliGroup[LWAPI_MAX_AVAILABLE_SLI_GROUPS];   //!< Maximum number of SLI groups
} LW_GPU_TOPOLOGIES;

//! Macro for constructing the version field of LW_GPU_TOPOLOGIES
#define LW_GPU_TOPOLOGIES_VER  MAKE_LWAPI_VERSION(LW_GPU_TOPOLOGIES,3)

#define LW_GPU_VALID_GPU_TOPOLOGIES LW_GPU_TOPOLOGIES
#define LW_GPU_ILWALID_GPU_TOPOLOGIES LW_GPU_TOPOLOGIES
#define LW_GPU_VALID_GPU_TOPOLOGIES_VER  LW_GPU_TOPOLOGIES_VER
#define LW_GPU_ILWALID_GPU_TOPOLOGIES_VER  LW_GPU_TOPOLOGIES_VER
#define LW_GPU_VALID_GPU_TOPOLOGIES_V1 LW_GPU_TOPOLOGIES_V1
#define LW_GPU_ILWALID_GPU_TOPOLOGIES_V1 LW_GPU_TOPOLOGIES_V1
#define LW_GPU_VALID_GPU_TOPOLOGIES_VER_1  LW_GPU_TOPOLOGIES_VER_1
#define LW_GPU_ILWALID_GPU_TOPOLOGIES_VER_1  LW_GPU_TOPOLOGIES_VER_1
#define LW_GPU_VALID_GPU_TOPOLOGIES_V2 LW_GPU_TOPOLOGIES_V2
#define LW_GPU_ILWALID_GPU_TOPOLOGIES_V2 LW_GPU_TOPOLOGIES_V2
#define LW_GPU_VALID_GPU_TOPOLOGIES_VER_2  LW_GPU_TOPOLOGIES_VER_2
#define LW_GPU_ILWALID_GPU_TOPOLOGIES_VER_2  LW_GPU_TOPOLOGIES_VER_2


//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GetValidGpuTopologies
//
//!  This function returns all valid GPU topologies that can be used to configure the physical GPUs 
//!  using the LwAPI_SetGpuTopologies API. It also returns the current active topologies.
//! 
//!  This call returns an array of LW_GPU_TOPOLOGY structs; one for each valid configuration 
//!  of GPUs present in the system.  Note that this list is constant as long as GPUs remain in the 
//!  same slots in the system.  It is not affected by which GPUs are presently in use.
//!  LW_GPU_TOPOLOGY.displayGpuIndex returned will match the boot GPU if it exists as an active topology.  
//!  If it not an active topology, it points to the "first" GPU that has a display monitor connected.
//!
//!  This call also returns an array of LW_SLI_GROUP, describing the list of topology combinations 
//!  that can be enabled at the same time.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 85
//!
//! \param [out]      ptopology  An array of *pCount (OUT) topology structures. Use LwAPI_SetGpuTopologies() to set up
//!                              one or several of these GPU topologies.
//! \param [out]      sliGroup   An array of *sliGroupCount (OUT) SLI goup structures, describing which topologies
//!                              can be set up conlwrrently.
//! \param [out]      pStatus    Any system status returned in case zero topology is retrieved.
//!                              System status is one or more flags in ::LW_GPU_TOPOLOGY_STATUS_FLAGS when SLI is NOT capable.
//!
//! \retval    ::LWAPI_OK                       Call succeeded; If SLI is supported then one or more GPU topologies are returned; else zero topologies are returned.
//! \retval    ::LWAPI_ILWALID_ARGUMENT         One or more arguments are invalid.
//! \retval    ::LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found.
//! \retval    ::LWAPI_ERROR                    Miscellaneous Error.
//!
//! \ingroup    gputopology
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetValidGpuTopologies(LW_GPU_VALID_GPU_TOPOLOGIES *pTopology, LwU32 *pStatus);


///////////////////////////////////////////////////////////////////////////////////
//  I2C API
//  Provides ability to read or write data using I2C protocol.
//  These APIs allow I2C access only to DDC monitors


//! \addtogroup i2capi
//! @{
#define LWAPI_MAX_SIZEOF_I2C_DATA_BUFFER    4096
#define LWAPI_MAX_SIZEOF_I2C_REG_ADDRESS       4
#define LWAPI_DISPLAY_DEVICE_MASK_MAX         24
#define LWAPI_I2C_SPEED_DEPRECATED        0xFFFF

typedef enum
{
    LWAPI_I2C_SPEED_DEFAULT,    //!< Set i2cSpeedKhz to I2C_SPEED_DEFAULT if default I2C speed is to be chosen, ie.use the current frequency setting.
    LWAPI_I2C_SPEED_3KHZ,
    LWAPI_I2C_SPEED_10KHZ,
    LWAPI_I2C_SPEED_33KHZ,
    LWAPI_I2C_SPEED_100KHZ,
    LWAPI_I2C_SPEED_200KHZ,
    LWAPI_I2C_SPEED_400KHZ,
} LW_I2C_SPEED;

//! Used in LwAPI_I2CRead() and LwAPI_I2CWrite()
typedef struct
{
    LwU32                   version;            //!< The structure version.
    LwU32                   displayMask;        //!< The Display Mask of the concerned display.
    LwU8                    bIsDDCPort;         //!< This flag indicates either the DDC port (TRUE) or the communication port
                                                //!< (FALSE) of the concerned display.
    LwU8                    i2cDevAddress;      //!< The address of the I2C slave.  The address should be shifted left by one.  For
                                                //!< example, the I2C address 0x50, often used for reading EDIDs, would be stored
                                                //!< here as 0xA0.  This matches the position within the byte sent by the master, as
                                                //!< the last bit is reserved to specify the read or write direction.
    LwU8*                   pbI2cRegAddress;    //!< The I2C target register address.  May be NULL, which indicates no register
                                                //!< address should be sent.
    LwU32                   regAddrSize;        //!< The size in bytes of target register address.  If pbI2cRegAddress is NULL, this
                                                //!< field must be 0.
    LwU8*                   pbData;             //!< The buffer of data which is to be read or written (depending on the command).
    LwU32                   cbSize;             //!< The size of the data buffer, pbData, to be read or written.
    LwU32                   i2cSpeed;           //!< The target speed of the transaction (between 28Kbps to 40Kbps; not guaranteed).
} LW_I2C_INFO_V1;

//! Used in LwAPI_I2CRead() and LwAPI_I2CWrite()
typedef struct
{
    LwU32                   version;            //!< The structure version.
    LwU32                   displayMask;        //!< The Display Mask of the concerned display.
    LwU8                    bIsDDCPort;         //!< This flag indicates either the DDC port (TRUE) or the communication port
                                                //!< (FALSE) of the concerned display.
    LwU8                    i2cDevAddress;      //!< The address of the I2C slave.  The address should be shifted left by one.  For
                                                //!< example, the I2C address 0x50, often used for reading EDIDs, would be stored
                                                //!< here as 0xA0.  This matches the position within the byte sent by the master, as
                                                //!< the last bit is reserved to specify the read or write direction.
    LwU8*                   pbI2cRegAddress;    //!< The I2C target register address.  May be NULL, which indicates no register
                                                //!< address should be sent.
    LwU32                   regAddrSize;        //!< The size in bytes of target register address.  If pbI2cRegAddress is NULL, this
                                                //!< field must be 0.
    LwU8*                   pbData;             //!< The buffer of data which is to be read or written (depending on the command).
    LwU32                   cbSize;             //!< The size of the data buffer, pbData, to be read or written.
    LwU32                   i2cSpeed;           //!< Deprecated, Must be set to LWAPI_I2C_SPEED_DEPRECATED.
    LW_I2C_SPEED            i2cSpeedKhz;        //!< The target speed of the transaction in (kHz) (Chosen from the enum LW_I2C_SPEED).
} LW_I2C_INFO_V2;

//! Used in LwAPI_I2CRead() and LwAPI_I2CWrite()
typedef struct
{
    LwU32                   version;            //!< The structure version.
    LwU32                   displayMask;        //!< The Display Mask of the concerned display.
    LwU8                    bIsDDCPort;         //!< This flag indicates either the DDC port (TRUE) or the communication port
                                                //!< (FALSE) of the concerned display.
    LwU8                    i2cDevAddress;      //!< The address of the I2C slave.  The address should be shifted left by one.  For
                                                //!< example, the I2C address 0x50, often used for reading EDIDs, would be stored
                                                //!< here as 0xA0.  This matches the position within the byte sent by the master, as
                                                //!< the last bit is reserved to specify the read or write direction.
    LwU8*                   pbI2cRegAddress;    //!< The I2C target register address.  May be NULL, which indicates no register
                                                //!< address should be sent.
    LwU32                   regAddrSize;        //!< The size in bytes of target register address.  If pbI2cRegAddress is NULL, this
                                                //!< field must be 0.
    LwU8*                   pbData;             //!< The buffer of data which is to be read or written (depending on the command).
    LwU32                   cbSize;             //!< The size of the data buffer, pbData, to be read or written.
    LwU32                   i2cSpeed;           //!< Deprecated, Must be set to LWAPI_I2C_SPEED_DEPRECATED.
    LW_I2C_SPEED            i2cSpeedKhz;        //!< The target speed of the transaction in (kHz) (Chosen from the enum LW_I2C_SPEED).
    LwU8                    portId;             //!< The portid on which device is connected (remember to set bIsPortIdSet if this value is set)
                                                //!< Optional for pre-Kepler
    LwU32                   bIsPortIdSet;       //!< set this flag on if and only if portid value is set
} LW_I2C_INFO_V3;

typedef LW_I2C_INFO_V3                     LW_I2C_INFO;

#define LW_I2C_INFO_VER3  MAKE_LWAPI_VERSION(LW_I2C_INFO_V3,3)
#define LW_I2C_INFO_VER2  MAKE_LWAPI_VERSION(LW_I2C_INFO_V2,2)
#define LW_I2C_INFO_VER1  MAKE_LWAPI_VERSION(LW_I2C_INFO_V1,1)

#define LW_I2C_INFO_VER  LW_I2C_INFO_VER3
//! @}

/***********************************************************************************/


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_I2CRead
//
//!  This function reads the data buffer from the I2C port.
//!                 The I2C request must be for a DDC port: pI2cInfo->bIsDDCPort = 1.
//!
//!                 A data buffer size larger than 16 bytes may be rejected if a register address is specified.  In such a case,
//!                 LWAPI_ARGUMENT_EXCEED_MAX_SIZE would be returned.
//!
//!                 If a register address is specified (i.e. regAddrSize is positive), then the transaction will be performed in
//!                 the combined format described in the I2C specification.  The register address will be written, followed by
//!                 reading into the data buffer.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 85
//!
//! \param [in]   hPhysicalGPU     GPU selection.
//! \param [out]  LW_I2C_INFO     *pI2cInfo The I2C data input structure
//!
//! \retval   LWAPI_OK                            Completed request
//! \retval   LWAPI_ERROR                         Miscellaneous error oclwrred.
//! \retval   LWAPI_HANDLE_ILWALIDATED            Handle passed has been ilwalidated (see user guide).
//! \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//! \retval   LWAPI_INCOMPATIBLE_STRUCT_VERSION   Structure version is not supported.
//! \retval   LWAPI_ILWALID_ARGUMENT - argument does not meet specified requirements
//! \retval   LWAPI_ARGUMENT_EXCEED_MAX_SIZE - an argument exceeds the maximum 
//!
//! \ingroup i2capi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_I2CRead(LwPhysicalGpuHandle hPhysicalGpu, LW_I2C_INFO *pI2cInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_I2CWrite
//
//!  This function writes the data buffer to the I2C port.
//!
//!                 The I2C request must be for a DDC port: pI2cInfo->bIsDDCPort = 1.
//!
//!                 A data buffer size larger than 16 bytes may be rejected if a register address is specified.  In such a case,
//!                 LWAPI_ARGUMENT_EXCEED_MAX_SIZE would be returned.
//!
//!                 If a register address is specified (i.e. regAddrSize is positive), then the register address will be written
//!                 and the data buffer will immediately follow without a restart.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 85
//!
//! \param [in]   hPhysicalGPU     GPU selection.
//! \param [in]   pI2cInfo         The I2C data input structure
//!
//! \retval   LWAPI_OK                            Completed request
//! \retval   LWAPI_ERROR                         Miscellaneous error oclwrred.
//! \retval   LWAPI_HANDLE_ILWALIDATED            Handle passed has been ilwalidated (see user guide).
//! \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//! \retval   LWAPI_INCOMPATIBLE_STRUCT_VERSION    Structure version is not supported.
//! \retval   LWAPI_ILWALID_ARGUMENT              Argument does not meet specified requirements
//! \retval   LWAPI_ARGUMENT_EXCEED_MAX_SIZE      Argument exceeds the maximum 
//!
//! \ingroup i2capi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_I2CWrite(LwPhysicalGpuHandle hPhysicalGpu, LW_I2C_INFO *pI2cInfo);


//! \addtogroup i2capi
//! @{
#define LWAPI_I2C_FLAGS_NONE                  0 //!< None
#define LWAPI_I2C_FLAGS_PRIVILEGE           0x1 //!< Used in LW_I2C_INFO_EX.
#define LWAPI_I2C_FLAGS_DATA_ENCRYPTED      0x2 //!< Encrypted I2C has been deprecated. 
#define LWAPI_I2C_FLAGS_NONSTD_SI1930UC     0x4 //!< Used in LW_I2C_INFO_EX.
#define LWAPI_I2C_FLAGS_FORCE_MOT           0x8  //!< Lwrrently supports only DP and Vista above.
                                                 //!< Forces MOT bit on irrespective of size of the data to be passed
                                                 //!< till transaction is completed
#define LWAPI_I2C_FLAGS_PX3540              0x10 //!< Used in LW_I2C_INFO_EX.
//! @}


//! \ingroup i2capi
//! Used in LwAPI_I2CWriteEx() and LwAPI_I2CReadEx().
typedef struct 
{
    LwU32                   flags;        //!< I2C flags for Privileged, encrypted and non-standard Si1930uC i2c access
    LwU32                   encrClientID; //!< Client ID for Encrypted I2C (unused)
} LW_I2C_INFO_EX;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_I2CWriteEx
//
//! DESCRIPTION:   This function writes the data buffer to the I2C port. \n
//!                 Pass displayMask as zero, if I2C access is required for non-display devices.
//!
//!                 A data buffer size larger than 16 bytes may be rejected if a register address is specified.  In such a case,
//!                 LWAPI_ARGUMENT_EXCEED_MAX_SIZE would be returned.
//!
//!                 If a register address is specified (i.e. regAddrSize is positive), then the register address will be written
//!                 and the data buffer will immediately follow without a restart.
//!
//!                 If a DDC port is passed (bIsDDCPort = 1), then displayMask is a required parameter.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 170
//!
//! \param [in]  hPhysicalGPU                  GPU selection
//! \param       LW_I2C_INFO     *pI2cInfo     The I2C data input structure
//! \param       LW_I2C_INFO_EX  *pI2cInfoEx   The I2C extended data input structure
//!
//! \retval      LWAPI_OK                           Completed request
//! \retval      LWAPI_ERROR                        Miscellaneous error oclwrred
//! \retval      LWAPI_HANDLE_ILWALIDATED           Handle passed has been ilwalidated (see user guide)
//! \retval      LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE Handle passed is not a physical GPU handle
//! \retval      LWAPI_INCOMPATIBLE_STRUCT_VERSION  Structure version is not supported
//! \retval      LWAPI_ILWALID_ARGUMENT             Argument does not meet specified requirements
//! \retval      LWAPI_ARGUMENT_EXCEED_MAX_SIZE     Argument exceeds the maximum 
//!
//! \ingroup i2capi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_I2CWriteEx(LwPhysicalGpuHandle hPhysicalGpu, LW_I2C_INFO *pI2cInfo, LW_I2C_INFO_EX *pI2cInfoEx);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_I2CReadEx
//
//! DESCRIPTION:   This function reads the data buffer from the I2C port.
//!                 Please pass displayMask as zero, if I2C access required for non-display devices.
//!
//!                 A data buffer size larger than 16 bytes may be rejected if a register address is specified.  In such a case,
//!                 LWAPI_ARGUMENT_EXCEED_MAX_SIZE would be returned.
//!
//!                 If a register address is specified (i.e. regAddrSize is positive), then the transaction will be performed in
//!                 the combined format described in the I2C specification.  The register address will be written, followed by
//!                 reading into the data buffer.
//!
//!                 If a DDC port is passed (bIsDDCPort = 1), then displayMask is a required parameter.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 170
//!
//! \param [in] hPhysicalGPU                 GPU selection.
//! \param      LW_I2C_INFO     *pI2cInfo    The I2C data input structure
//! \param      LW_I2C_INFO_EX  *pI2cInfoEx  The I2C extended data input structure
//!
//! \retval    LWAPI_OK                            Completed request
//! \retval    LWAPI_ERROR                         Miscellaneous error oclwrred
//! \retval    LWAPI_HANDLE_ILWALIDATED            Handle passed has been ilwalidated (see user guide)
//! \retval    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle
//! \retval    LWAPI_INCOMPATIBLE_STRUCT_VERSION   Structure version is not supported
//! \retval    LWAPI_ILWALID_ARGUMENT              Argument does not meet specified requirements
//! \retval    LWAPI_ARGUMENT_EXCEED_MAX_SIZE      An argument exceeds the maximum 
//!
//! \ingroup i2capi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_I2CReadEx(LwPhysicalGpuHandle hPhysicalGpu, LW_I2C_INFO *pI2cInfo, LW_I2C_INFO_EX *pI2cInfoEx);


/*!
 * The IDs of each type of I2C command available 
 */
typedef enum
{
   /*!
    * This transaction type is used to perform the Quick SMBus Read/write command 
    * on a slave device. No data is sent or received, just used to verify the 
    * presence of the device.
    * Refer SMBus spec 2.0 (section 5.5.1 Quick Command)
    * SMBus Quick Write : S Addr|Wr [A] P
    * SMBus Quick Read  : S Addr|Rd [A] P
    */
   LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_QUICK_RW,
   /*!
    * This transaction type is used to perform the I2C byte read/write from/to 
    * a slave device. As per the spec last byte should be NA (Not Acknolwedged) 
    * by slave.
    * Refer I2CBus spec 3.0 (section 9 Fig 11 and Fig 12) or Refer SMBus spec 
    * 2.0 (section 5.5.2 Send Byte and 5.5.3 Receive Byte).
    * I2C Byte Write : S Addr|Wr [A] Data [NA] P
    * I2C Byte Read  : S Addr|Rd [A] Data NA P
    */
   LW_I2C_INFO_TRANSACTION_TYPE_I2C_BYTE_RW,
   /*!
    * This transaction type is used to perform the I2C block (buffer) 
    * read/write from/to a slave device. As per the spec last byte should be NA
    * (Not Acknolwedged) by slave.
    * Refer I2CBus spec 3.0 (section 9 Fig 11 and Fig 12)
    * I2C Byte Write : S Addr|Wr [A] Data1 [A]...Data(N-1) [A] DataN [NA] P
    * I2C Byte Read  : S Addr|Rd [A] Data1 A...Data(N-1) A DataN NA P
    *
    * Distinction between I2C_BLOCK and SMBUS_BLOCK protocol:
    * In I2C Block write it is the slave device (and in I2C Block read its 
    * the master device) that determines the number of bytes to transfer by 
    * asserting the NAK at last bit before stop. This differs from the SMBus 
    * block mode write command in which the master determines the block 
    * write transfer size. In I2c Block read there is no limit to maximum size 
    * of data that could be transferred whereas in SMBus block it is restricted
    * to 255 bytes (0xFF).
    */
   LW_I2C_INFO_TRANSACTION_TYPE_I2C_BLOCK_RW,
   /*!
    * This transaction type is used to perform the I2C Buffer read/write 
    * from/to a register of a slave device. It does not send bytecount as 
    * part of data buffer.
    * Not a part of SMBus spec.
    * I2C Buffer Write : S Addr|Wr [A] cmd [A] Data1 [A]...DataN[A] P
    * I2C Buffer Read  : S Addr|Wr [A] cmd [A] Sr Addr|Rd [A] Data1 A...
    *                    DataN-1 A DataN A P
    *
    * Distinction between SMBUS_BLOCK and I2C_BUFFER protocol:
    * In SMBUS_BLOCK Read/write the first byte of data buffer contains the 
    * count size (The number of bytes to be transferred) and it is restricted 
    * to 255 bytes whereas in I2C_BUFFER, count size is not sent during the 
    * transfer and there is no restriction in terms of size.
    *
    * Distinction between I2C_BLOCK and I2C_BUFFER protocol:
    * I2C_BUFFER takes the register address as argument whereas I2C_BLOCK does
    * not have any register or command provision.
    */
   LW_I2C_INFO_TRANSACTION_TYPE_I2C_BUFFER_RW,
   /*!
    * This transaction type is used to perform the I2C byte read/write from/to
    * a slave device
    * Refer SMBus spec 2.0 (section 5.5.4 Write Byte and 5.5.5 Read Byte)
    * SMBus Byte Write : S Addr|Wr [A] cmd [A] Data [A] P
    * SMBus Byte Read  : S Addr|Wr [A] cmd [A] Sr Addr|Rd [A] Data A P
    */
   LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_BYTE_RW,
   /*!
    * This transaction type is used to perform the SMBus byte read/write 
    * from/to a register of a slave device
    * Refer SMBus spec 2.0 (section 5.5.4 Write Word and 5.5.5 Read Word)
    * SMBus Word Write : S Addr|Wr [A] cmd [A] DataLow [A] DataHigh [A] P 
    * SMBus Word Read  : S Addr|Wr [A] cmd [A] Sr Addr|Rd [A] DataLow A 
    *                    DataHigh A P
    */
   LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_WORD_RW,
   /*!
    * This transaction type is used to perform the SMBus Block read/write 
    * from/to a register of a slave device
    * Refer SMBus spec 2.0 (section 5.5.7 Block Write/Read)
    * SMBus Block Write : S Addr|Wr [A] cmd [A] ByteCount [A] Data1 [A]...
    *                    DataN-1 [A] DataN[A] P
    * SMBus Block Read  : S Addr|Wr [A] cmd [A] Sr Addr|Rd [A] ByteCount A 
    *                    Data1 A...DataN-1 A DataN A P
    *
    * Distinction between I2C_BLOCK and SMBUS_BLOCK protocol:
    * In I2C Block write it is the slave device (and in I2C Block read its 
    * the master device) that determines the number of bytes to transfer by 
    * asserting the NAK at last bit before stop. This differs from the SMBus 
    * block mode write/Read command in which the master determines the block 
    * write transfer size. In I2c Block read/Write there is no limit to maximum 
    * size of data that could be transferred whereas in SMBus block it is 
    * restricted to 255 bytes (0xFF).
    */
   LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_BLOCK_RW,
   /*!
    * This transaction type is used to perform the SMBus process call. It sends 
    * data and waits for the slave to return a value dependent on that data. 
    * The protocol is simply a SMBus write Word followed by a SMBus Read Word 
    * without the Read-Word command field and the Write-Word STOP bit. 
    * Note that there is no STOP condition before the repeated START condition, 
    * and that a NACK signifies the end of the read transfer. 
    *
    * Refer SMBus spec 2.0 (section 5.5.6 Process Call)
    * SMBus Process Call : S Addr|Wr [A] cmd [A] DataLow [A] DataHigh [A] 
    *                      Sr Addr|Rd [A] DataLow [A] DataHigh [NA] P
    */
   LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_PROCESS_CALL,
   /*!
    * This transaction type is used to perform the SMBus Block Write Block Read
    * process call.
    * The block write-block read process call is a two-part message. The call 
    * begins with a slave address and a write condition. After the command code
    * the host issues a write byte count (M) that describes how many more bytes
    * will be written in the first part of the message.
    * If a master has 6 bytes to send, the byte count field will have the value
    * 6 (0000 0110b), followed by the 6 bytes of data. The write byte count (M)
    * cannot be zero. 
    * The second part of the message is a block of read data beginning with a 
    * repeated start condition followed by the slave address and a Read bit.
    * The next byte is the read byte count (N), which may differ from the write
    * byte count (M). The read byte count (N) cannot be zero. The combined data
    * payload must not exceed 32 bytes. 
    * The byte length restrictions of this process call are summarized as 
    * follows:
    * M >= 1 byte 
    * N >= 1 byte 
    * M + N <= 32 bytes 
    * Note that there is no STOP condition before the repeated START condition, 
    * and that a NACK signifies the end of the read transfer.
    *
    * Refer SMBus spec 2.0 (section 5.5.8 Block Write Block Read Process Call)
    * SMBus Process Call : S Addr|Wr [A] cmd [A] ByteCount=M [A] Data1 [A]...
    *                      DataN-1 [A] DataM[A] Sr Addr|Rd [A] ByteCount=N [A] 
    *                      Data1 [A]...DataN [NA] P
    */
   LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_BLOCK_PROCESS_CALL,
   /*!
    * This transaction type is used to perform SMBus buffer read/write 
    * from/to multiple registers of a slave device known as Auto Increment.
    * It is not a part of any standard I2C/SMBus spec but a feature of many
    * SMBus devices like EEPROM.
    * It is also used for reading a block of bytes from a designated register 
    * that is specified through the two Comm bytes.of a slave device or writing
    * a block of bytes from a designated register of a slave device (Note : The
    * command byte in this case could be 0, 2 or 4 Bytes)
    * SMBus Multi-Byte Register Block Write : S Addr|Wr [A] cmd1 A cmd 2 [A]...
    *                cmdN [A] data1 [A] Data2 [A].....DataN [A] P
    * SMBus Multi-Byte Register Block Read : S Addr|Rd [A] cmd1 A cmd 2 [A]...
    *                cmdN [A] data1 [A] Sr Addr [A] Data1 A Data2 A...DataN A P
    *
    * This transaction type could be also used for those devices which supports 
    * AUTO_INC. Even though it is frequently related to I2C/SMBus, automatic 
    * incrementation is not part of any I2C standard but rather a common
    * feature found in many I2C devices. What it means is that the device
    * maintains in internal pointer which is  automatically incremented upon 
    * data read or write activities and which can be manually set to a fixed 
    * value. This comes in handy when storing larger amounts of data for 
    * instance in an ordinary I2C RAM or EEPROM.
    * SMBus AUTO_INC Write : S Addr|Wr [A] cmd1 A Data1 [A] Data2 [A]...
    *                        DataN [A] P
    * SMBus AUTO_INC Read : S Addr|Rd [A] cmd1 A data1 [A] Sr Addr [A] Data1 A
    *                       Data2 A...DataN A P
    * If the device does not support AUTO_INC set warFlags of 
    * LW_I2C_INFO_TRANSACTION_DATA_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW to 
    * LW_LW_I2C_INFO_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW_WAR_FLAGS_NO_AUTO_INC.
    */
   LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW,
   /*!
    * This transaction type is used to perform the EDID read via DDC.
    */
   LW_I2C_INFO_TRANSACTION_TYPE_READ_EDID_DDC
} LW_I2C_INFO_TRANSACTION_TYPE;

/*!
 * The following defines specify WAR flags that can be specified during
 * I2C Quick Read or Write command (Refer LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_QUICK_RW).
 *
 * _NONE
 *    No workaround is needed.
 *
 * _TEST_PORT
 *     Use this flag to have the client sent a request to test a port instead 
 *     of performing any transaction on it. Transaction type has to be 
 *     LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_QUICK_RW.
 */

#define LW_I2C_INFO_SMBUS_QUICK_RW_WAR_FLAGS_NONE                            0
#define LW_I2C_INFO_SMBUS_QUICK_RW_WAR_FLAGS_TEST_PORT                       1

/*!
 * LW_I2C_INFO_TRANSACTION_DATA_SMBUS_QUICK_RW
 *
 * Specifies the structure of data filled by the client for I2C transaction 
 * when the.transaction type is LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_QUICK_RW.
 *
 */
typedef struct
{
   /*!
    * This field must be specified by the client to indicate whether the
    * command is a write (TUE) or a read (FALSE).
    */
    LwU8  bWrite;
    /*!
    * Transaction specific flags. (see To do)
    */
   LwU32 warFlags;
} LW_I2C_INFO_TRANSACTION_DATA_SMBUS_QUICK_RW;

/*!
 * LW_I2C_INFO_TRANSACTION_DATA_I2C_BYTE_RW
 *
 * Specifies the structure of data filled by the client for I2C transaction 
 * when the.transaction type is LW_I2C_INFO_TRANSACTION_TYPE_I2C_BYTE_RW.
 *
 */
typedef struct
{
   /*!
    * This field must be specified by the client to indicate whether the
    * command is a write (TRUE) or a read (FALSE).
    */
   LwU8  bWrite;
   /*!
    * The main message data.
    */
   LwU8 *pMessage;
} LW_I2C_INFO_TRANSACTION_DATA_I2C_BYTE_RW;

/*!
 * LW_I2C_INFO_TRANSACTION_DATA_I2C_BLOCK_RW
 *
 * Specifies the structure of data filled by the client for I2C transaction 
 * when the transaction type is LW_I2C_INFO_TRANSACTION_TYPE_I2C_BLOCK_RW.
 *
 */
typedef struct
{
   /*!
    * This field must be specified by the client to indicate whether the
    * command is a write (TRUE) or a read (FALSE).
    */
   LwU8  bWrite;
   /*!
    * This parameter specifies the number of bytes to read or
    * write from the slave after the register address is written.
    */
   LwU32 messageLength;
   /*!
    * The main message data.
    */
   LwU8 *pMessage;
} LW_I2C_INFO_TRANSACTION_DATA_I2C_BLOCK_RW;

/*!
 * LW_I2C_INFO_TRANSACTION_DATA_SMBUS_BYTE_RW
 *
 * Specifies the structure of data filled by the client for I2C transaction 
 * when the.transaction type is LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_BYTE_RW.
 *
 */
typedef struct
{
   /*!
    * This field must be specified by the client to indicate whether the
    * command is a write (TRUE) or a read (FALSE).
    */
   LwU8  bWrite;
   /*!
    * The address of the register.
    */
   LwU8  registerAddress;
   /*!
    * The main message data.
    */
   LwU8 *pMessage;
} LW_I2C_INFO_TRANSACTION_DATA_SMBUS_BYTE_RW;

/*!
 * LW_I2C_INFO_TRANSACTION_DATA_SMBUS_WORD_RW
 *
 * Specifies the structure of data filled by the client for I2C transaction 
 * when the.transaction type is LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_WORD_RW.
 *
 */
typedef struct
{
   /*!
    * This field must be specified by the client to indicate whether the
    * command is a write (TRUE) or a read (FALSE).
    */
   LwU8  bWrite;
   /*!
    * The address of the register.
    */
   LwU8  registerAddress;
   /*!
    * The main message data.
    */
   LwU16 *pMessage;
} LW_I2C_INFO_TRANSACTION_DATA_SMBUS_WORD_RW;

/*!
 * LW_I2C_INFO_TRANSACTION_DATA_SMBUS_BUFFER_RW
 *
 * Specifies the structure of data filled by the client for I2C transaction 
 * when the.transaction type is LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_BUFFER_RW.
 *
 */
typedef struct
{
   /*!
    * This field must be specified by the client to indicate whether the
    * command is a write (TRUE) or a read (FALSE).
    */
   LwU8  bWrite;
   /*!
    * Transaction specific flags to be set (see 
    * LW_LW_I2C_INFO_BUFFER_RW_WAR_FLAGS_*)
    */
   LwU32 warFlags;
   /*!
    * This parameter specifies how many bytes to write as part of the
    * register address. If zero is specified, then no index will be sent.
    */
   LwU8  registerAddress;
   /*!
    * This parameter specifies the number of bytes to read or 
    * write from the slave after the register address is written.
    */
   LwU32 messageLength;
   /*!
    * The main message data.
    */
   LwU8  *pMessage;
} LW_I2C_INFO_TRANSACTION_DATA_I2C_BUFFER_RW;

/*!
 * LW_I2C_INFO_TRANSACTION_DATA_SMBUS_BLOCK_RW
 *
 * Specifies the structure of data filled by the client for I2C transaction 
 * when the.transaction type is LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_BLOCK_RW.
 *
 */
typedef struct
{
   /*!
    * This field must be specified by the client to indicate whether the
    * command is a write (TRUE) or a read (FALSE).
    */
   LwU8   bWrite;
   /*!
    * This parameter specifies how many bytes to write as part of the
    * register address. If zero is specified, then no index will be sent.
    */
   LwU8   registerAddress;
   /*!
    * This parameter specifies the number of bytes to read or 
    * write from the slave after the register address is written.
    */
   LwU32  messageLength;
   /*!
    * The main message data.
    */
   LwU8  *pMessage;
} LW_I2C_INFO_TRANSACTION_DATA_SMBUS_BLOCK_RW;

/*!
 * LW_I2C_INFO_TRANSACTION_DATA_SMBUS_PROCESS_CALL
 *
 * Specifies the structure of data filled by the client for I2C transaction 
 * when the.transaction type is LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_PROCESS_CALL.
 *
 */
typedef struct
{
   /*!
    * This parameter specifies how many bytes to write as part of the
    * register address. If zero is specified, then no index will be sent.
    */
   LwU8  registerAddress;
   /*!
    * The message data to be written to the slave.
    */
   LwU16 *pWriteMessage;
   /*!
    * The message data to be read from the slave.
    */
   LwU16 *pReadMessage;
} LW_I2C_INFO_TRANSACTION_DATA_SMBUS_PROCESS_CALL;

/*!
 * LW_I2C_INFO_TRANSACTION_DATA_SMBUS_BLOCK_PROCESS_CALL
 *
 * Specifies the structure of data filled by the client for I2C transaction 
 * when the.transaction type is 
 * LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_BLOCK_PROCESS_CALL.
 *
 */
typedef struct
{
   /*!
    * This parameter specifies how many bytes to write as part of the
    * register address. If zero is specified, then no index will be sent.
    */
   LwU8  registerAddress;
   /*!
    * This parameter specifies the number of bytes to write the the slave 
    * after the writeByteCount is sent to the slave.
    */
   LwU32 writeMessageLength;
   /*!
    * The message buffer to be written to the slave.
    */
   LwU8 *pWriteMessage;
   /*!
    * This parameter specifies the number of bytes to read from the slave 
    * after the readByteCount is sent to the slave.
    */
   LwU32 readMessageLength;
   /*!
    * The message buffer to be read from the slave.
    */
   LwU8  *pReadMessage;
} LW_I2C_INFO_TRANSACTION_DATA_SMBUS_BLOCK_PROCESS_CALL;

/*!
 * The following defines specify WAR flags that can be specified during
 * I2C buffer Read or Write to Multibyte Regsiter 
 * (Refer LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW)
 *
 * _NONE
 *    No workaround is needed.
 *
 * _NO_AUTO_INC
 *   This value specifies that the device does not support auto-increment.
 *   Most devices allow you to write multiple bytes after specifying a
 *   register address, and the subsequent bytes will go to incremented
 *   addresses. Without auto-increment, we write a buffer of data as a
 *   sequence of address-register-value triplets separated by starts.
 */

#define LW_I2C_INFO_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW_WAR_FLAGS_NONE         0
#define LW_I2C_INFO_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW_WAR_FLAGS_NO_AUTO_INC  1
/*!
 * LW_I2C_INFO_TRANSACTION_DATA_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW
 *
 * Specifies the structure of data filled by the client for I2C transaction 
 * when the.transaction type is 
 * LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW.
 */
typedef struct
{
   /*!
    * This field must be specified by the client to indicate whether the
    * command is a write (TRUE) or a read (FALSE).
    */
    LwU8  bWrite;
   /*!
    * Transaction specific flags (see 
    * LW_I2C_INFO_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW_WAR_FLAGS_*)
    */
   LwU32  warFlags;
   /*!
    * This parameter specifies how many bytes to write as part of the
    * register address. If zero is specified, then no index will be sent.
    */
   LwU32  indexLength;
   /*!
    * Optional indexing data; aka register address.
    */
   LwU8  *pIndex;
   /*!
    * This parameter specifies the number of bytes to read or 
    * write from the slave after the register address is written.
    */
   LwU32  messageLength;
   /*!
    * The main message data.
    */
   LwU8  *pMessage;
} LW_I2C_INFO_TRANSACTION_DATA_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW;

/*!
 * LW_I2C_INFO_TRANSACTION_DATA_READ_EDID_DDC
 *
 * Specifies the structure of data filled by the client for I2C transaction 
 * when the.transaction type is LW_I2C_INFO_TRANSACTION_TYPE_READ_EDID_DDC.
 *
 */
typedef struct
{
    /*!
     * The segment number of the EDID block which is to be read.
     */
    LwU8  segmentNumber;
    /*!
     * The address of the register.
     */
    LwU8  registerAddress;
   /*!
    * This parameter specifies the number of bytes to read or
    * write from the slave after the register address is written.
    */
    LwU32 messageLength;
    /*!
     * The main message data.
     */
    LwU8 *pMessage;
} LW_I2C_INFO_TRANSACTION_DATA_READ_EDID_DDC;

/*!
 * LW_I2C_INFO_TRANSACTION_DATA
 *
 * This union encapsulates the transaction data corresponding to the 
 * transaction type enlisted above.
 */
typedef union
{
   /*!
    * This transaction data is to be filled when transaction type is 
    * LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_QUICK_RW.
    */
    LW_I2C_INFO_TRANSACTION_DATA_SMBUS_QUICK_RW                    smbusQuickData;
   /*!
    * This transaction data is to be filled when transaction type is 
    * LW_I2C_INFO_TRANSACTION_TYPE_I2C_BYTE_RW.
    */
    LW_I2C_INFO_TRANSACTION_DATA_I2C_BYTE_RW                       i2cByteData;
   /*!
    * This transaction data is to be filled when transaction type is 
    * LW_I2C_INFO_TRANSACTION_TYPE_I2C_BLOCK_RW.
    */
    LW_I2C_INFO_TRANSACTION_DATA_I2C_BLOCK_RW                      i2cBlockData;
   /*!
    * This transaction data is to be filled when transaction type is 
    * LW_I2C_INFO_TRANSACTION_TYPE_I2C_BUFFER_RW.
    */
    LW_I2C_INFO_TRANSACTION_DATA_I2C_BUFFER_RW                     i2cBufferData;
   /*!
    * This transaction data is to be filled when transaction type is 
    * LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_BYTE_RW.
    */
    LW_I2C_INFO_TRANSACTION_DATA_SMBUS_BYTE_RW                     smbusByteData;
   /*!
    * This transaction data is to be filled when transaction type is 
    * LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_WORD_RW.
    */
    LW_I2C_INFO_TRANSACTION_DATA_SMBUS_WORD_RW                     smbusWordData;
   /*!
    * This transaction data is to be filled when transaction type is 
    * LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_BLOCK_RW.
    */
    LW_I2C_INFO_TRANSACTION_DATA_SMBUS_BLOCK_RW                    smbusBlockData;
   /*!
    * This transaction data is to be filled when transaction type is 
    * LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_PROCESS_CALL.
    */
    LW_I2C_INFO_TRANSACTION_DATA_SMBUS_PROCESS_CALL                smbusProcessData;
   /*!
    * This transaction data is to be filled when transaction type is 
    * LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_BLOCK_PROCESS_CALL.
    */
    LW_I2C_INFO_TRANSACTION_DATA_SMBUS_BLOCK_PROCESS_CALL          smbusBlockProcessData;
   /*!
    * This transaction data is to be filled when transaction type is 
    * LW_I2C_INFO_TRANSACTION_TYPE_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW.
    */
    LW_I2C_INFO_TRANSACTION_DATA_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW smbusMultibyteRegisterData;
   /*!
    * This transaction data is to be filled when transaction type is 
    * LW_I2C_INFO_TRANSACTION_TYPE_READ_EDID_DDC.
    */
    LW_I2C_INFO_TRANSACTION_DATA_READ_EDID_DDC edidData;
} LW_I2C_INFO_TRANSACTION_DATA;

/*!
 * LOCATION_TYPE
 *
 * This enum specifies different I2C supported according different location
 * used to communicate with slave
 */
typedef enum
{
   /*!
    * This type is used to specify transaction with display (DDC)
    */
    LOCATION_TYPE_DISPLAY = 0x0,
    /*!
    * This type is used to specify plain I2C transaction
    */
    LOCATION_TYPE_ADDRESS,
} LOCATION_TYPE;

/*!
 * LOCATION_TYPE_DATA_DISPLAY
 *
 * Structure holds information for I2C over DDC
 */
typedef struct
{
   /*!
    * DisplayId of the display device to be communicated
    */
    LwU32 displayId;
} LOCATION_TYPE_DATA_DISPLAY;

/*!
 * LOCATION_TYPE_DATA_ADDRESS
 *
 * Structure holds information for I2C over DDC
 */
typedef struct
{
   /*!
    * The address of the I2C slave. The address of the I2C slave. The
    * address should be shifted left by one. For example, the I2C
    * address 0x50, often used for reading EDIDs, would be stored here
    * as 0xA0. This matches the position within the byte sent by the
    * master, as the last bit is reserved to specify the read or write
    * direction.
    */
    LwU16 deviceAddress;
} LOCATION_TYPE_DATA_ADDRESS;

/*!
 * LOCATION_DATA
 *
 * This structure encapsulates union of the location type
 * enlisted in enum LOCATION_TYPE.
 */

 #define LW_I2C_INFO_PORT_ID_UNITIALIZED  (+255U)

typedef struct
{
   union
   {
        /*!
        * if Slave is Display device
        */
        LOCATION_TYPE_DATA_DISPLAY display;
        /*!
        * if Slave is Non DDC device
        */
        LOCATION_TYPE_DATA_ADDRESS address;
        /*!
        * Following variable is reserved for future use
        */
        LwU8 rsvd[16];
    };
    /*!
    * The logical port ID.
    * Note: Initialize to (LW_I2C_INFO_PORT_ID_UNITIALIZED) if want to use primary port
    */
    LwU8  portId;
    LOCATION_TYPE locDataType;
} LOCATION_DATA;

/*!
 * LW_I2C_TRANSACTION_INFO_V1
 *
 * Used in LwAPI_I2CTransaction()
 */
typedef struct
{
    /*!
     * The structure version.
     */
    LwU32  version;
    /*!
    * This parameter specifies optional flags used to control certain modal
    * features such as target speed and addressing mode. The lwrrently
    * defined fields are described previously; see LWAPI_I2C_FLAGS_* 
    */
    LwU32 flags;
    /*!
    * location at which to transact
    */
    LOCATION_DATA locData;
   /*!
    * The target speed of the transaction in (kHz) (Chosen from the enum LW_I2C_SPEED).
    */
    LW_I2C_SPEED i2cSpeedKhz;
   /*!
    * The transaction type.
    */
    LW_I2C_INFO_TRANSACTION_TYPE transType;
   /*!
    * The transaction data corresponding transaction type.
    */
    LW_I2C_INFO_TRANSACTION_DATA transData;
    /*!
     * Following variable is reserved for future use
     */
    LwU8 rsvd[32];
} LW_I2C_TRANSACTION_INFO_V1;

typedef LW_I2C_TRANSACTION_INFO_V1               LW_I2C_TRANSACTION_INFO;

#define LW_I2C_TRANSACTION_INFO_VER1             MAKE_LWAPI_VERSION(LW_I2C_TRANSACTION_INFO_V1,1)

#define LW_I2C_TRANSACTION_INFO_VER              LW_I2C_TRANSACTION_INFO_VER1
//! @}
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_I2CTransaction
//
//! DESCRIPTION:   This function reads/writes the data buffer from the I2C port.
//!
//!                 A data buffer size larger than 16 bytes may be rejected if a register address is specified.  In such a case,
//!                 LWAPI_ARGUMENT_EXCEED_MAX_SIZE would be returned.
//!
//!                 If a register address is specified (i.e. regAddrSize is positive), then the transaction will be performed in
//!                 the combined format described in the I2C specification.  The register address will be written, followed by
//!                 reading into the data buffer.
//!
//!                 If a DDC port is passed (bIsDDCPort = 1), then displayId is a required parameter.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      hPhysicalGPU          GPU selection.
//! \param [out]     pI2CPorts             Pointer to LW_I2C_TRANSACTION_INFO structure.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup i2capi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_I2CTransaction(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_I2C_TRANSACTION_INFO *pI2CTranInfo);




//! \ingroup i2capi
typedef struct
{
    LwU32                version;        //!< The structure version.
    LwU32                portId;            //!< [out]Port identifier. An integer between 0 to 15 to identify an I2C port
    LwU32                 portSpeed;        //!< [out]Contains the current I2C speed of the port.
} LW_I2C_PORT_INFO_V1;

//! \ingroup i2capi
typedef LW_I2C_PORT_INFO_V1                                     LW_I2C_PORT_INFO;

//! \ingroup i2capi
#define LW_I2C_PORT_INFO_VER1                                      MAKE_LWAPI_VERSION(LW_I2C_PORT_INFO_V1,1)

//! \ingroup i2capi
#define LW_I2C_PORT_INFO_VER                                    LW_I2C_PORT_INFO_VER1

//! \ingroup i2capi
#define LW_LWAPI_MAX_I2C_NUM_PORTS                                 16

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_Get_I2C_Ports_Info
//
//! DESCRIPTION:   This API gets information about the I2C ports.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      hPhysicalGPU          GPU selection.
//! \param [out]  pI2CPorts         Pointer to an array of LW_I2C_PORT_INFO structures. Typically, the size of this array should be LW_LWAPI_MAX_I2C_NUM_PORTS.
//! \param [in]      numPorts         The number of elements in the array pI2CPorts. 
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup i2capi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_Get_I2C_Ports_Info(__in LwPhysicalGpuHandle hPhysicalGpu, __inout_ecount(numPorts) LW_I2C_PORT_INFO *pI2CPorts, __in LwU32 numPorts);


// END OF I2C API

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_RestartDisplayDriver
//
//! DESCRIPTION:     This API restarts the display driver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \retval    LWAPI_OK                               Call succeeded.
//!  \retval    LWAPI_API_NOT_INTIALIZED               LWAPI not initialized
//!  \retval    LWAPI_ERROR                            The call failed
//!  \retval    LWAPI_TIMEOUT_RECONFIGURING_GPU_TOPO   Timeout oclwred while reconfiguring GPUs.
//!
//!  \ingroup driverapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_RestartDisplayDriver();




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GetValidGpuTopologiesInternal
//
//! DESCRIPTION:     This API is similar to LwAPI_GetValidGpuTopologies() but returns the topologies that are
//!                  valid but not allowed to be active, such as two GPUs in a subset of three GPUs.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [out]    ptopology    An array of *pCount (OUT) topology structures. Use LwAPI_SetGpuTopology() to set up
//!                              one or several of these GPU topologies.
//! \param [out]    sliGroup     An array of *sliGroupCount (OUT) SLI group structures, describing which topologies
//!                              can be set up conlwrrently.
//! \param [out]    pStatus      Any system status returned in case zero topology is retrieved.
//!                              System status is one or more flags in ::LW_GPU_TOPOLOGY_STATUS_FLAGS when SLI is NOT capable.
//!
//! \retval  ::LWAPI_OK                        Call succeeded; 1 or more GPU topologies were returned.
//! \retval  ::LWAPI_ILWALID_ARGUMENT          One or more arguments are invalid.
//! \retval  ::LWAPI_LWIDIA_DEVICE_NOT_FOUND   No LWPU GPU driving a display was found.
//! \retval  ::LWAPI_ERROR                     Miscellaneous Error.
//!
//! \ingroup  gputopology
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetValidGpuTopologiesInternal(LW_GPU_VALID_GPU_TOPOLOGIES *pTopology, LwU32 *pStatus);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetValidGpuTopologiesMosaic
//! \code
//! DESCRIPTION:     This API is similar to LwAPI_GetValidGpuTopologies() but it returns valid GPU topologies that will allow base Mosaic.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! PARAMETERS:      pTopology(OUT): An array of *pCount (OUT) topology structures. Use LwAPI_SetGpuTopology() to set
//!                  up one of these GPU topologies.
//!                  pTopology->sliGroup(OUT): An array of LW_SLI_GROUP structures, describing which topologies
//!                  can be set up conlwrrently.In base_mosaic case, there would be 1 topology per group.
//!                  pStatus(OUT): Any system status returned in case zero topology is retrieved.
//!                  System status is one or more flags in LW_GPU_TOPOLOGY_STATUS_FLAGS when SLI is NOT capable.
//!
//! RETURN STATUS    LWAPI_OK: Call succeeded; 1 or more GPU topologies were returned
//!                  LWAPI_ILWALID_ARGUMENT: one or more args are invalid
//!                  LWAPI_LWIDIA_DEVICE_NOT_FOUND: no LWPU GPU driving a display was found
//!                  LWAPI_ERROR: Miscellaneous Error.
//! \endcode
//! \ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetValidGpuTopologiesMosaic(LW_GPU_VALID_GPU_TOPOLOGIES *pTopology, LwU32 *pStatus);




///////////////////////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GetIlwalidGpuTopologies
//
//! DESCRIPTION:     This API returns all invalid GPU topologies and the current active topologies.
//!                  This call returns an array of LW_GPU_TOPOLOGY structs; one for each invalid configuration 
//!                  of GPUs present in the system. Note that this list is constant while GPUs remain in the 
//!                  same slots in the system.  It is not affected by which GPUs that are presently in use.
//!
//!                  The topologies with the status ::LW_GPU_TOPOLOGY_STATUS_TOPOLOGY_NOT_ALLOWED are valid for
//!                  the system but not for productization.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//!
//! \param [out]    ptopology      An array of *pCount (OUT) topology structures.
//! \param [out]    sliGroup       No SLI groups returned here.
//! \param [out]    sliGroupCount  *sliGroupCount = 0.
//!
//! \retval         LWAPI_OK                       Call succeeded; one or more GPU topologies were returned.
//! \retval         LWAPI_ILWALID_ARGUMENT         One or more arguments are invalid.
//! \retval         LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found.
//! \retval         LWAPI_ERROR                    Miscellaneous Error.
//!
//! \ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetIlwalidGpuTopologies(LW_GPU_ILWALID_GPU_TOPOLOGIES *pTopology);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_SetGpuTopologies
//
//! This function configures the physical GPUs in the system into one or more logical devices
//!                  defined by the LW_GPU_TOPOLOGY structure. After successful exelwtion of this call, the caller needs to enumerate  
//!                  all the GPU handles again.
//!
//! It is recommended that the calling application:
//!                  - Save the current GPU topology retrieved from LwAPI_EnumLogicalGPUs and LwAPI_GetPhysicalGPUsFromLogicalGPU APIs.
//!                  - Save the current view state for associated displays on these GPUs using the GetView and GetDisplayTargets APIs.
//!                  - Set LW_GPU_TOPOLOGY.displayGpuIndex to the GPU index in the topology with an active display connection.
//!                  - If DEFER_3D_APP_SHUTDOWN is not set, notify the user that all 3D application will be forced to close.
//!                  - Itself does not create 3D handles or objects that can block the topology transition.
//!
//! On Windows Vista:
//!                  - The calling application must run in elevated mode for the transition to succeed. 
//!                  - This API can be called from a system service to derive the elevated context of the System service.
//! 
//! - Running non-migratable applications can prevent a successful transition if DEFER_3D_APP_SHUTDOWN is set. 
//! - To query non-migratable applications, use the LwAPI_QueryNonMigratableApps() API.
//!
//! - When enabling more than one multi-GPU topology, set the LW_GPU_TOPOLOGY_SLI_GROUPS flag.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 85
//!
//! \param [in]  pTopology     a pointer to the LW_GPU_VALID_GPU_TOPOLOGIES structure defining the desired GPU topologies to be set.
//!                                  The set of possible GPU topologies can be first queried using LwAPI_GetValidGpuTopologies.
//! \param [in]  flags         \see LW_SET_GPU_TOPOLOGY_FLAGS
//!
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!              specific meaning for this API, they are listed below.
//! 
//! \retval      LWAPI_TIMEOUT_RECONFIGURING_GPU_TOPO  Timeout oclwrred while reconfiguring GPUs.
//! \retval      LWAPI_IMPLICIT_SET_GPU_TOPOLOGY_CHANGE_NOT_ALLOWED   There is any implicit GPU topology active. Use LWAPI_SetHybridMode() to change the topology.
//! \retval      LWAPI_REQUEST_USER_TO_CLOSE_NON_MIGRATABLE_APPS Prompt the user to close all non-migratable applications.
//!
//! \ingroup     gputopology
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetGpuTopologies(LW_GPU_VALID_GPU_TOPOLOGIES *pTopology, LwU32 flags);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_GPU_GetPerGpuTopologyStatus
//
//! This function returns per-GPU topology state flags from LW_GPU_TOPOLOGY_STATUS_FLAGS for the queried GPU handle.
//!  \note The per-GPU topology status can be queried independent of the whether the queried GPU is part of a topology or not.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [out]  hPhysicalGPU    GPU selection.
//! \param [out]  pStatus         Indicates one or more flags from LW_GPU_TOPOLOGY_STATUS_FLAGS which are the subset of the 
//!                               same flags retrieved from LW_GPU_TOPOLOGY.status or pStatus in LwAPI_GetValidGpuTopologies() API.
//!
//! \retval    LWAPI_OK                            Completed request
//! \retval    LWAPI_ERROR                         Miscellaneous error oclwrred
//! \retval    LWAPI_HANDLE_ILWALIDATED            Handle passed has been ilwalidated (see user guide)
//! \retval    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle
//! \ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPerGpuTopologyStatus(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pStatus);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetTopologyStatusString
//
//!  DESCRIPTION: This function colwerts an SLI status into a NULL-terminated string.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \return  NULL-terminated string (always, never NULL)
//!
//! \ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetTopologyStatusString(LwU32 nr,LwAPI_String szDesc);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetTopologyFlagString
//
//!   DESCRIPTION: This function colwerts an SLI topology flag value string into a NULL-terminated string.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//! 
//! \return  NULL-terminated string (always, never NULL)
//!
//! \ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetTopologyFlagString(LwU32 nr,LwAPI_String szDesc);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetSliGroupFlagString
//
//   DESCRIPTION: colwerts an SLI group flag value string into a null terminated string
//
//! SUPPORTED OS:  Windows XP and higher
//!
//
// RETURN STATUS: null terminated string (always, never NULL)
//
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetSliGroupFlagString(LwU32 nr,LwAPI_String szDesc);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetGpuTopologySystemProperties
//
//! DESCRIPTION: This function returns the system properties mask that determines the SLI approval
//!              state. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]   pTopology           Topology with the GPU count and the physical GPU handles set.
//! \param [out]  pSystemProperties   The system properties mask for this SLI config.
//!
//! \retval     LWAPI_OK                Request is completed.
//! \retval     LWAPI_ERROR             A miscellaneous error oclwrred.
//! \retval     LWAPI_ILWALID_ARGUMENT  One or more arguments are invalid.
//!
//! \ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetGpuTopologySystemProperties(LW_GPU_TOPOLOGY *pTopology, LwU32 *pSystemProperties);




//! \ingroup gputopology
//! Used in LwAPI_GetGpuTopologySystemPropertiesString().
typedef enum
{
    LW_GPU_TOPOLOGY_SYSPROP_IS_MOBILE               = 0x00000001, //!< Notebook configuration
    LW_GPU_TOPOLOGY_SYSPROP_IS_CANOAS               = 0x00000002, //!< Canoas configuration
    LW_GPU_TOPOLOGY_SYSPROP_IS_E551                 = 0x00000004, //!< E551 configuration
    LW_GPU_TOPOLOGY_SYSPROP_IS_BR02                 = 0x00000008, //!< The configuration has a BR02
    LW_GPU_TOPOLOGY_SYSPROP_IS_BR03                 = 0x00000010, //!< Each GPU is behind a BR03
    LW_GPU_TOPOLOGY_SYSPROP_IS_BR04                 = 0x00000020, //!< Each GPU is behind a BR04
    LW_GPU_TOPOLOGY_SYSPROP_IS_BR_ANY               = 0x00000040, //!< The configuration has either none or any BR03, BR04
    LW_GPU_TOPOLOGY_SYSPROP_IS_CPU_XEON             = 0x00000080, //!< Is the CPU a Xeon
    LW_GPU_TOPOLOGY_SYSPROP_IS_QUADRO               = 0x00000100, //!< Lwdqro only
    LW_GPU_TOPOLOGY_SYSPROP_IS_OS_VISTA             = 0x00000200, //!< OS is Vista
    LW_GPU_TOPOLOGY_SYSPROP_IS_2BR03                = 0x00000400, //!< Minimum of 2 Cascaded BR03s behind each GPU
    LW_GPU_TOPOLOGY_SYSPROP_IS_3BR03                = 0x00000800, //!< Minimum of 3 Cascaded BR03s behind each GPU
    LW_GPU_TOPOLOGY_SYSPROP_IS_OS_XP                = 0x00001000, //!< OS is XP
    LW_GPU_TOPOLOGY_SYSPROP_IS_VIDEO_BRIDGE         = 0x00002000, //!< Video bridge present
    LW_GPU_TOPOLOGY_SYSPROP_IS_OS_UNIX              = 0x00004000, //!< OS is Unix
    LW_GPU_TOPOLOGY_SYSPROP_IS_GEFORCE              = 0x00008000, //!< VdChip only
    LW_GPU_TOPOLOGY_SYSPROP_IS_CANOAS2              = 0x00010000, //!< Canoas 2.0 config
    LW_GPU_TOPOLOGY_SYSPROP_IS_OS_MODS              = 0x00040000, //!< OS is MODS
    LW_GPU_TOPOLOGY_SYSPROP_IS_COMMON_BR03          = 0x00080000, //!< All GPUs have a common BR03
    LW_GPU_TOPOLOGY_SYSPROP_IS_COMMON_BR04          = 0x00100000, //!< All GPUs have a common BR04
    LW_GPU_TOPOLOGY_SYSPROP_IS_SHARED_BR03          = 0x00200000, //!< Each GPU is shares a BR03 with another GPU
    LW_GPU_TOPOLOGY_SYSPROP_IS_SHARED_BR04          = 0x00400000, //!< Each GPU is shares a BR04 with another GPU
    LW_GPU_TOPOLOGY_SYSPROP_IS_2BR04                = 0x00800000, //!< There is a minimum of 2 Cascaded BR04s behind each GPU
    LW_GPU_TOPOLOGY_SYSPROP_IS_BR04_REV_A03         = 0x01000000, //!< All BR04 revisions are A03
    LW_GPU_TOPOLOGY_SYSPROP_IS_MXM_INTERPOSER       = 0x02000000, //!< All GPUS are behind an MXM_INTERPOSER interposer card
    LW_GPU_TOPOLOGY_SYSPROP_IS_NO_BR_NOTBR04A03     = 0x04000000, //!< All non-root port bridges in the system other than GX2 are BR04 A03
    LW_GPU_TOPOLOGY_SYSPROP_IS_SLI_APPROVAL_COOKIE  = 0x08000000, //!< The SBIOS has an SLI approval cookie
    LW_GPU_TOPOLOGY_SYSPROP_IS_BR04_PRESENT         = 0x10000000, //!< A BR04 is present in the system - not necessarily serving a GPU
    LW_GPU_TOPOLOGY_SYSPROP_IS_2BR04_NOT_CASCADED           = 0x20000000, //!< There is a minimum of two non-cascaded BR04s in the system.
    LW_GPU_TOPOLOGY_SYSPROP_IS_4_WAY_SLI_APPROVAL_COOKIE    = 0x40000000, //!< The SBIOS has an SLI approval cookie allowing 4-way SLI
    LW_GPU_TOPOLOGY_SYSPROP_IS_TEMPLATE_APPROVAL_COOKIE     = 0x80000000, //!< The SBIOS has an template approval cookie. It does not mean it is valid.
} LW_GPU_TOPOLOGY_SYSTEM_PROPERTY_FLAGS;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetGpuTopologySystemPropertiesString
//
//!   DESCRIPTION: This API colwerts an SLI system properties mask into a NULL-terminated string.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \return NULL-terminated string (always, never NULL)
//!
//! \ingroup ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetGpuTopologySystemPropertiesString(LwU32 nr,LwAPI_String szDesc);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetGpuTopologySystemPropertiesEx
//
//! \fn LwAPI_GetGpuTopologySystemPropertiesEx(LW_GPU_TOPOLOGY *pTopology, LW_GPU_TOPOLOGY_SYSTEM_PROPERTIES *pSystemProperties)
//! \code
//! DESCRIPTION: returns the system properties mask the SLI approval
//!              uses to make its decision
//!              This call deprecates LwAPI_GetGpuTopologySystemProperties()
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:     pTopology(IN) - Topology with the gpu count and the physical gpu handles set.
//!                 pSystemProperties(OUT)  - the system properties for this SLI config.
//!
//! RETURN STATUS:
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_ILWALID_ARGUMENT - one or more args are invalid
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gputopology
//! @{

typedef struct
{
    LwU32 version;                      //!< [00:31] Structure version

    LwU32 bIsMobile:1;                  //!< [32:32] Mobile config
    LwU32 bIsCanoas:1;                  //!< [33:33] Canoas config
    LwU32 bIsE551:1;                    //!< [34:34] E551 config
    LwU32 bIsBR02:1;                    //!< [35:35] Config has a BR02
    LwU32 bIsBR03:1;                    //!< [36:36] Each GPU is behind a BR03
    LwU32 bIsBR04:1;                    //!< [37:37] Each GPU is behind a BR04
    LwU32 bIsBrAny:1;                   //!< [38:38] Config has none or any BR03, BR04
    LwU32 bIsCPUXeon:1;                 //!< [39:39] Is the CPU a Xeon
    LwU32 bIsQuadro:1;                  //!< [40:40] Lwdqro only
    LwU32 bIsOSVista:1;                 //!< [41:41] OS is Vista
    LwU32 bIs2BR03:1;                   //!< [42:42] minimum of 2 Cascaded BR03s behind each GPU
    LwU32 bIs3BR03:1;                   //!< [43:43] minimum of 3 Cascaded BR03s behind each GPU
    LwU32 bIsOSXP:1;                    //!< [44:44] OS is XP
    LwU32 bIsVideoBridge:1;             //!< [45:45] Video bridge present, cirlwlar or not
    LwU32 bIsOSUnix:1;                  //!< [46:46] OS is Unix
    LwU32 bIsGeForce:1;                 //!< [47:47] VdChip only
    LwU32 bIsCanoas2:1;                 //!< [48:48] Canoas 2.0 config
    LwU32 bIsOSMODS:1;                  //!< [49:49] OS is MODS
    LwU32 bIsCommonBR03:1;              //!< [50:50] All GPUs have a common BR03
    LwU32 bIsCommonBR04:1;              //!< [51:51] All GPUs have a common BR04 
    LwU32 bIsSharedBR03:1;              //!< [52:52] Each GPU is shares a BR03 with another GPU
    LwU32 bIsSharedBR04:1;              //!< [53:53] Each GPU is shares a BR04 with another GPU
    LwU32 bIs2BR04:1;                   //!< [54:54] There is a minimum of 2 Cascaded BR04s behind each GPU
    LwU32 bIsBR04RevA03:1;              //!< [55:55] All BR04 revisions are A03
    LwU32 bIsMXMIinterposer:1;          //!< [56:56] All GPUS are behind an MXM_INTERPOSER interposer card
    LwU32 bIsNoBrNorBR04A03:1;          //!< [57:57] All non-root port bridges in the system other than GX2 are BR04 A03
    LwU32 bIsSliAapprovalCookie:1;      //!< [58:58] The SBIOS has an SLI approval cookie
    LwU32 bIsBR04Present:1;             //!< [59:59] A BR04 is present in the system - not necessarily serving a GPU
    LwU32 bIs2BR04NotCascaded:1;        //!< [60:60] There is a minimum of two non cascaded BR04s in the system
    LwU32 bIs4WaySliApprovalCookie:1;   //!< [60:60] The SBIOS has an SLI approval cookie allowing 4-way SLI
    LwU32 bIsTemplateApprovalCookie:1;  //!< [61:61] The SBIOS has an template approval cookie. It does not mean it is valid.
    LwU32 bIsCirlwlarVideoBridge:1;     //!< [62:62] Cirlwlar video bridge present
    LwU32 bIsGeforceOnWorkstation:1;    //!< [63:63] This system allows Vdchip SLI on workstation systems, applicable to _VER_2 or greater
             
 } LW_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V1;

typedef LW_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V1 LW_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V2;

typedef struct
{
    LwU32 version;                      //!< [00:31]  Structure version
    LwU32 bIsMobile:1;                  //!< [32:32]  Mobile config
    LwU32 bIsCanoas:1;                  //!< [33:33]  Canoas config
    LwU32 bIsE551:1;                    //!< [34:34]  E551 config
    LwU32 bIsBR02:1;                    //!< [35:35]  Config has a BR02
    LwU32 bIsBR03:1;                    //!< [36:36]  Each GPU is behind a BR03
    LwU32 bIsBR04:1;                    //!< [37:37]  Each GPU is behind a BR04
    LwU32 bIsBrAny:1;                   //!< [38:38]  Config has none or any BR03, BR04
    LwU32 bIsCPUXeon:1;                 //!< [39:39]  Is the CPU a Xeon
    LwU32 bIsQuadro:1;                  //!< [40:40]  Lwdqro only
    LwU32 bIsOSVista:1;                 //!< [41:41]  OS is Vista
    LwU32 bIs2BR03:1;                   //!< [42:42]  minimum of 2 Cascaded BR03s behind each GPU
    LwU32 bIs3BR03:1;                   //!< [43:43]  minimum of 3 Cascaded BR03s behind each GPU
    LwU32 bIsOSXP:1;                    //!< [44:44]  OS is XP
    LwU32 bIsVideoBridge:1;             //!< [45:45]  Video bridge present, cirlwlar or not
    LwU32 bIsOSUnix:1;                  //!< [46:46]  OS is Unix
    LwU32 bIsGeForce:1;                 //!< [47:47]  VdChip only
    LwU32 bIsCanoas2:1;                 //!< [48:48]  Canoas 2.0 config
    LwU32 bIsOSMODS:1;                  //!< [49:49]  OS is MODS
    LwU32 bIsCommonBR03:1;              //!< [50:50]  All GPUs have a common BR03
    LwU32 bIsCommonBR04:1;              //!< [51:51]  All GPUs have a common BR04 
    LwU32 bIsSharedBR03:1;              //!< [52:52]  Each GPU is shares a BR03 with another GPU
    LwU32 bIsSharedBR04:1;              //!< [53:53]  Each GPU is shares a BR04 with another GPU
    LwU32 bIs2BR04:1;                   //!< [54:54]  There is a minimum of 2 Cascaded BR04s behind each GPU
    LwU32 bIsBR04RevA03:1;              //!< [55:55]  All BR04 revisions are A03
    LwU32 bIsMXMIinterposer:1;          //!< [56:56]  All GPUS are behind an MXM_INTERPOSER interposer card
    LwU32 bIsNoBrNorBR04A03:1;          //!< [57:57]  This property is deprecated in favor of bIsNoBr3rdParty
    LwU32 bIsSliAapprovalCookie:1;      //!< [58:58]  The SBIOS has an SLI approval cookie
    LwU32 bIsBR04Present:1;             //!< [59:59]  A BR04 is present in the system - not necessarily serving a GPU
    LwU32 bIs2BR04NotCascaded:1;        //!< [60:60]  There is a minimum of two non-cascaded BR04s in the system
    LwU32 bIs4WaySliApprovalCookie:1;   //!< [61:61]  The SBIOS has an SLI approval cookie allowing 4-way SLI
    LwU32 bIsTemplateApprovalCookie:1;  //!< [62:62]  The SBIOS has an template approval cookie. It does not mean it is valid.
    LwU32 bIsCirlwlarVideoBridge:1;     //!< [63:63]  Cirlwlar video bridge present
    LwU32 bIsGeforceOnWorkstation:1;    //!< [64:64]  This system allows Vdchip SLI on workstation systems, applicable to _VER_2 or greater
    LwU32 bIsGpuNoSliSupport:1;         //!< [65:65]  Each GPU doesn't support SLI
    LwU32 bIsGpuGt200AndAbove:1;        //!< [66:66]  This property is deprecated in favor of bIsGpuBaseMosaicSupport
    LwU32 bIsNoVideoBridge:1;           //!< [67:67]  There is no video bridge
    LwU32 bIsP2PWriteAllowed:1;         //!< [68:68]  P2P Writes are allowed
    LwU32 bIsP2PReadAllowed:1;          //!< [69:69]  P2P Reads are allowed
    LwU32 bIsGpuBaseMosaicSupport:1;    //!< [70:70]  Each GPU supports base Mosaic
    LwU32 bIsPLX:1;                     //!< [71:71]  Each GPU is behind a PLX bridge
    LwU32 bIsCommonPLX:1;               //!< [72:72]  All GPUs have a common PLX bridge
    LwU32 bIsSharedPLX:1;               //!< [73:73]  Each GPU shares a PLX bridge with another GPU
    LwU32 bIsNoBr3rdParty;              //!< [74:74]  All non-root port bridges in the system other than GX2 are supported
    LwU32 reserved1:21;                 //!< [75:95]  reserved
    LwU32 reserved;                     //!< [96:127] reserved
} LW_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V3;

typedef LW_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V3 LW_GPU_TOPOLOGY_SYSTEM_PROPERTIES;

#define LW_GPU_TOPOLOGY_SYSTEM_PROPERTIES_VER_1 MAKE_LWAPI_VERSION(LW_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V1,1)
#define LW_GPU_TOPOLOGY_SYSTEM_PROPERTIES_VER_2 MAKE_LWAPI_VERSION(LW_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V2,2)
#define LW_GPU_TOPOLOGY_SYSTEM_PROPERTIES_VER_3 MAKE_LWAPI_VERSION(LW_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V3,1)
#define LW_GPU_TOPOLOGY_SYSTEM_PROPERTIES_VER   LW_GPU_TOPOLOGY_SYSTEM_PROPERTIES_VER_3

//! @}


//! \ingroup gputopology
LWAPI_INTERFACE LwAPI_GetGpuTopologySystemPropertiesEx(LW_GPU_TOPOLOGY *pTopology, LW_GPU_TOPOLOGY_SYSTEM_PROPERTIES *pSystemProperties);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetGpuTopologySystemPropertiesStringEx
//
//! \code
//! DESCRIPTION: Colwerts an SLI system properties mask into a null terminated string
//!              This call deprecates LwAPI_GetGpuTopologySystemPropertiesString
//!
//! PARAMETERS:  pSystemProperties(IN)  - the system properties structure for this SLI config.
//!              szDesc (OUT) - null terminated string (always, never NULL)
//!                 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: 
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//! \endcode
//! \ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetGpuTopologySystemPropertiesStringEx(LW_GPU_TOPOLOGY_SYSTEM_PROPERTIES *pSystemProperties, LwAPI_String szDesc);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_GPU_GetAllGpusOnSameBoard
//
//!  This function returns a set of GPUs handles that exists on the same board as the queried GPU handle.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 95
//!
//! \param [in]  hPhysicalGPU   GPU selection.
//! \param [out] lwGPUHandle    The associated GPUs on the same board as the queried GPU. This array includes the queried GPU handle too.
//! \param [out] pGpuCount      The count of GPUs that exists on the same board. This count includes the queried GPU handle too.
//!
//! \retval  LWAPI_OK                            Completed request
//! \retval  LWAPI_ERROR                         Miscellaneous error oclwrred.
//! \retval  LWAPI_HANDLE_ILWALIDATED            Handle passed has been ilwalidated (see user guide).
//! \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//! \ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetAllGpusOnSameBoard(LwPhysicalGpuHandle hPhysicalGpu, LwPhysicalGpuHandle lwGPUHandle[LWAPI_MAX_PHYSICAL_GPUS], LwU32 *pGpuCount);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SYS_GetChipSetTopologyStatus
//
//!  This function returns topology state flags from LW_GPU_TOPOLOGY_STATUS_FLAGS possible with the System ChipSet.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [out] pStatus  Indicates one or more flags from LW_GPU_TOPOLOGY_STATUS_FLAGS which are the subset of the 
//!                       same flags retrieved from LW_GPU_TOPOLOGY.status or pStatus in LwAPI_GetValidGpuTopologies() API.
//!  
//! \retval  LWAPI_OK     Completed request
//! \retval  LWAPI_ERROR  Miscellaneous error oclwrred
//! \ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetChipSetTopologyStatus(LwU32 *pStatus);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_SetTopologyDisplayGPU
//
//! DESCRIPTION:    This function switches the display output between GPUs in an active GPU topology.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165 
//!
//!  \param [in]    hLogicalGPU      Active logical GPU topology containing more than one physical GPU.
//!  \param [in]    hGPU             Target GPU handle for outputting the display.
//!  \param [in]    displayOutputId  Connected display output Id on the target GPU which should be activated. See \ref handles.
//!
//!  \retval        LWAPI_OK                       Call succeeded. Display output switched on the target GPU's displayOutputId.
//!  \retval        LWAPI_ILWALID_ARGUMENT         One or more arguments are invalid. displayOutputId should be connected to the target hGPU.
//!  \retval        LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found.
//!  \retval        LWAPI_NO_ACTIVE_SLI_TOPOLOGY   The logical GPU does not contain more than one physical GPU.
//!  \retval        LWAPI_NO_VIDLINK               A video bridge is required for this target GPU switch to succeed.
//!  \retval        LWAPI_ERROR                    The request failed.
//!
//!  \ingroup       gputopology
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetTopologyDisplayGPU(LwLogicalGpuHandle hLogicalGPU, LwPhysicalGpuHandle hGPU, LwU32 displayOutputId);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GetTopologyDisplayGPU
//
//! DESCRIPTION:    This function queries the target GPU and display output ID on an active GPU topology.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165 
//!
//!  \param [in]    hLogicalGPU         Active logical GPU topology containing more than one physical GPU.
//!  \param [out]   pPhysicalGpu        The target GPU handle where the display is getting outputted.
//!  \param [out]   pDisplayOutputId    The active connected display output ID on the target GPU. See \ref handles.
//!
//!  \retval        LWAPI_OK                       Call succeeded. 
//!  \retval        LWAPI_ILWALID_ARGUMENT         One or more arguments are invalid. 
//!  \retval        LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found.
//!  \retval        LWAPI_ERROR                    The request failed.
//!
//!  \ingroup       gputopology
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetTopologyDisplayGPU(LwLogicalGpuHandle hLogicalGPU, LwPhysicalGpuHandle *pPhysicalGpu, LwU32 *pDisplayOutputId);

// End of GPU topology configuration APIs





//! \ingroup gpu
//! Used in LwAPI_GPU_Get_DisplayPort_DongleInfo().
typedef struct
{
    LwU32      version;        //!< Structure version
    struct{
        LwU32   displayMask;  //!< This field name should be outputid and will have only one bit set.
    } input;
    struct{
        LwU32   isDP2DVI:1;           //!< Passive DP to DVI Dongle.
        LwU32   isDP2HDMI:1;          //!< Passive DP to HDMI Dongle.
        LwU32   isDMS592DVI:1;        //!< LFH_DVI
        LwU32   isDMS592VGA:1;        //!< LFH_VGA
        LwU32   isDP2VGA:1;           //!< DP to VGA Dongle. This information is not available on WinXP.
        LwU32   isDP2DVIActive:1;     //!< Active DP to DVI Dongle. This information is not available on WinXP.
        LwU32   isDP2HDMIActive:1;    //!< Active DP to HDMI Dongle. This information is not available on WinXP.
        LwU32   reserved : 25;
    } output;

} LW_LWAPI_GET_DP_DONGLE_INFO;

//! \ingroup gpu
//! Macro for constructing the version field of LW_LWAPI_GET_DP_DONGLE_INFO
#define LW_LWAPI_GET_DP_DONGLE_INFO_VER  MAKE_LWAPI_VERSION(LW_LWAPI_GET_DP_DONGLE_INFO,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_Get_DisplayPort_DongleInfo
//
//! DESCRIPTION: This API gets DisplayPort dongle information, such as DP2DVI or DP2HDMI. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//! 
//! \param [in]     hPhysicalGPU   GPU selection.
//! \param [in,out] pDongleInfo    Data input/output structure
//!            
//! \retval ::LWAPI_OK                            Completed request
//! \retval ::LWAPI_ERROR                         Miscellaneous error oclwrred
//! \retval ::LWAPI_ILWALID_ARGUMENT              One or more args are invalid
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_Get_DisplayPort_DongleInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_LWAPI_GET_DP_DONGLE_INFO *pDongleInfo);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_SetPerfLevel
//
//! DESCRIPTION: This function sets the GPU perf level to a specified level. For testing only.
//!              There is a known limitation that after locking to the target perf level, 
//!              there is lwrrently no way to release the lock. \n
//!              Note that this function is now obsolete and is being replaced by LwAPI_GPU_SetForcePstate.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 100
//!
//!  \retval  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle is invalid.
//!  \retval  LWAPI_OK                            GPU perf level is successfully set.
//!  \retval  LWAPI_ERROR                         Failed to set GPU perf level.
//!
//!  \ingroup gpuclock
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetPerfLevel(LwPhysicalGpuHandle hPhysicalGpu, LwU32 level);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_SetForcePstate
//
//! DESCRIPTION:    This function forces the GPU into the specified performance state (P-State).
//!                 \sa LwAPI_GPU_GetPstates() for list of P-States. 
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 165
//!
//!  \param [in]     hPhysicalGPU  GPU selection.
//!  \param [in]     forcePstate   The ID of the P-State to force the GPU into.
//!                                Specify LW_GPU_PERF_PSTATE_UNDEFINED to stop
//!                                forcing to any P-State, and allow the driver to
//!                                dynamically determine the optimal P-State. 
//!                                See \ref LW_GPU_PERF_PSTATE_ID
//!  \param [in]     fallback      The fallback strategy when the specified P-State
//!                                is not available.
//!                         - If FALLBACK_RETURN_ERROR is specified, the function returns an
//!                           error when the P-State specified by forcePstate is not available.
//!                         - If FALLBACK_HIGHER_PERF is specified, the function falls back
//!                           to a higher P-State, or to the highest possible P-State if no higher performance
//!                           P-State is found.
//!                         - If FALLBACK_LOWER_PERF is specified, the function falls back
//!                           to a lower P-State, or to the lowest possible P-State if no lower performance 
//!                           P-State is found.
//! 
//!   \retval     LWAPI_OK                             Completed request
//!   \retval     LWAPI_ERROR                          Miscellaneous error oclwrred.
//!   \retval     LWAPI_HANDLE_ILWALIDATED             Handle passed has been ilwalidated (see user guide).
//!   \retval     LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE   Handle passed is not a physical GPU handle.
//!   \retval     LWAPI_NOT_SUPPORTED                  P-States is not supported on this setup.
//!   \retval     LWAPI_ILWALID_ARGUMENT               Invalid input parameter
//!
//!   \ingroup    gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetForcePstate(LwPhysicalGpuHandle hPhysicalGpu, 
                                         LW_GPU_PERF_PSTATE_ID forcePstate,
                                         LW_GPU_PERF_PSTATE_FALLBACK fallback);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_SetForcePstateEx
//
//! DESCRIPTION:     This API forces the GPU into the specified performance state (P-State).
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \param [in]   hPhysicalGPU   GPU selection
//! \param [in]   forcePstate    The ID of the P-State into which to force the GPU; Specify
//!                              ::LW_GPU_PERF_PSTATE_UNDEFINED to stop forcing to any P-State, 
//!                              and allow the driver to dynamically determine the optimal P-State.
//!                              See \ref LW_GPU_PERF_PSTATE_ID. 
//! \param [in]   fallback       The fallback strategy when the specified P-State is not available.
//!                              For example, 
//!                              - If FALLBACK_RETURN_ERROR is specified, the function would just return
//!                                an error when the P-State specified by forcePstate is not available.
//!                              - If FALLBACK_HIGHER_PERF is specified, the function would fall back
//!                                to a higher performance P-State, or to the P-State with the highest
//!                                possible performance if no higher performance P-State is found.
//!                              - If FALLBACK_LOWER_PERF is specified, the function would fallback
//!                                to a lower performance P-State, or to the P-State with the lowest
//!                                possible performance if no lower performance P-State is found.
//! \param [in]    flags         Options that control the behavior of the P-State change.
//!                              Valid flags:
//!                              ::LW_GPU_PERF_SET_FORCE_PSTATE_FLAGS_ASYNC - Change the p-state asynchronously.
//!                              When this flag is set, the p-state change may not complete before the function returns.
//!
//! retval    ::LWAPI_OK                             Completed request
//! retval    ::LWAPI_ERROR                          Miscellaneous error oclwrred
//! retval    ::LWAPI_HANDLE_ILWALIDATED             Handle passed has been ilwalidated (see user guide)
//! retval    ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE   Handle passed is not a physical GPU handle
//! retval    ::LWAPI_NOT_SUPPORTED                  P-States is not supported on this setup
//! retval    ::LWAPI_ILWALID_ARGUMENT               Invalid input parameter
//!
//! \ingroup  gpupstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetForcePstateEx(LwPhysicalGpuHandle hPhysicalGpu,
                                           LW_GPU_PERF_PSTATE_ID forcePstate,
                                           LW_GPU_PERF_PSTATE_FALLBACK fallback,
                                           LwU32 flags);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_SetPerfClockControl
//
//!  This function sets the GPU perf controls - graphics, memory, and thermal. The
//!  changes for each of graphics, memory, and thermal controls will be 
//!  enabled/disabled according to the parameters passed in. \n
//!  1 = enabled, 0 = disabled.  \n
//!  For testing only.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 100
//!
//!  \param [in] hPhysicalGpu   The physical GPU handle
//!  \param [in] graphicsEnable Graphics perf control enable(1)/disable(0) 
//!  \param [in] memoryENable   Memory perf control enable(1)/disable(0)
//!  \param [in] thermalEnable  Thermal perf control enable(1)/disable(0)
//!
//!  \retval     LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE   Handle is invalid.
//!  \retval     LWAPI_OK                             GPU perf clock control is successfully set.
//!  \retval     LWAPI_ERROR                          Failed to set the GPU perf clock control.
//!
//!  \ingroup gpuclock
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetPerfClockControl(LwPhysicalGpuHandle hPhysicalGpu,
                                               LwU32 graphicsEnable,
                                               LwU32 memoryEnable,
                                               LwU32 thermalEnable);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetPerfClockControl
//
//!  This function retrieves dynamic performance clock controls status. \n 
//!  1 = enabled, 0 = disabled.
//! 
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 100
//!
//!  \param [in]  hPhysicalGpu   The physical GPU handle
//!  \param [out] graphicsEnable Describes whether or not dynamic graphics clock changes are enabled. 
//!  \param [out] memoryENable   Describes whether or not dynamic memory clock changes are enabled.
//!  \param [out] thermalEnable  Describes whether or not thermal changes are enabled.
//!
//!  \retval      LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle is invalid
//!  \retval      LWAPI_OK                            GPU perf clock control retrieved successfully.
//!  \retval      LWAPI_ERROR                         Failed to get the GPU perf clock control.
//! 
//!  \ingroup gpuclock
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPerfClockControl(LwPhysicalGpuHandle hPhysicalGpu,
                                              LwU32 *graphicsEnabled,
                                              LwU32 *memoryEnabled,
                                              LwU32 *thermalEnabled);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetCoreVoltage
//
//!   This function gets sampled GPU voltage in millivolts.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 100
//!
//!   \retval    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle is invalid.
//!   \retval    LWAPI_OK                            Successfully retrieved voltage value.
//!   \retval    LWAPI_ERROR                         Failed to get voltage value.
//!
//!   \ingroup gpuvoltage
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetCoreVoltage(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *voltage);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_SetCoreVoltageControl
//
//!   This function sets the GPU core-voltage control (enable or disable).
//!   On success, the core voltage change feature is enabled or disabled. \n
//!   1 = enabled, 0 = disabled. \n
//!   For testing purposes only.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 100
//!
//!   \retval   LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle is invalid.
//!   \retval   LWAPI_OK                            Successfully set voltage control.
//!   \retval   LWAPI_ERROR                         Failed to set voltage control.
//!
//!   \ingroup gpuvoltage
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetCoreVoltageControl(LwPhysicalGpuHandle hPhysicalGpu, LwU32 enable);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetCoreVoltageControl
//
//!   This function gets the GPU core voltage control state (enabled or disabled).
//!   On success, 'enabled' describes whether or not the core voltage change feature is enabled. \n
//!   1 = enabled, 0 = disabled.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 100
//!
//!   \retval    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle is invalid.
//!   \retval    LWAPI_OK                            Successfully got voltage control.
//!   \retval    LWAPI_ERROR                         Failed to get voltage control.
//!
//!   \ingroup gpuvoltage
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetCoreVoltageControl(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *enabled);



//! \addtogroup gpuvoltage
//! @{

//! Used in LwAPI_GPU_GetVoltageDomainsInfo().
//! Fields marked with [SET] must be populated when making LwAPI_GPU_GetVoltageDomainsInfo() call.
typedef struct _LW_GPU_VOLTAGE_DOMAIN_INFO_V1
{
    //! Domain ID (To be [SET] only if LW_GPU_VOLTAGE_DOMAINS_INFO_V<n>::numDomains > 0).
    LW_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID domainId;

    //! Voltage step size for this domain in uV.
    LwU32                              stepSizeuV;
} LW_GPU_VOLTAGE_DOMAIN_INFO_V1;

//! Used in LwAPI_GPU_GetVoltageDomainsInfo().
//! Fields marked with [SET] must be populated when making LwAPI_GPU_GetVoltageDomainsInfo() call.
typedef struct _LW_GPU_VOLTAGE_DOMAINS_INFO_V1
{
    //! [SET] Version info of the structure (LW_GPU_VOLTAGE_DOMAINS_INFO_VER<n>).
    LwU32 version;

    //! Reserved for future use.
    LwU32 flags;

    //! [SET] Number of voltage domains to query for obtaining their static information.
    //! Clients should set this to 0 to query all supported domains.
    LwU32 numDomains;

    //! Array of voltage domains and has 0 to numDomains - 1 as valid index range.
    LW_GPU_VOLTAGE_DOMAIN_INFO_V1 domains[LWAPI_MAX_GPU_PERF_VOLTAGES];
} LW_GPU_VOLTAGE_DOMAINS_INFO_V1;

//! Used in LwAPI_GPU_GetVoltageDomainsInfo().
typedef LW_GPU_VOLTAGE_DOMAINS_INFO_V1         LW_GPU_VOLTAGE_DOMAINS_INFO;

//! Macro for constructing the version field of LW_GPU_VOLTAGE_DOMAINS_INFO_V1.
#define LW_GPU_VOLTAGE_DOMAINS_INFO_VER1       MAKE_LWAPI_VERSION(LW_GPU_VOLTAGE_DOMAINS_INFO_V1, 1)

//! Macro for constructing the version field of LW_GPU_VOLTAGE_DOMAINS_INFO_VER1.
#define LW_GPU_VOLTAGE_DOMAINS_INFO_VER        LW_GPU_VOLTAGE_DOMAINS_INFO_VER1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetVoltageDomainsInfo
//
//! DESCRIPTION:  This API returns static information for the specified domains.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Version: 313.xx
//!
//! \param [in]  hPhysicalGpu          The physical GPU handle
//! \param [out] pVoltageDomainsInfo   Pointer to structure containing the static information
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status.
//!          If there are return error codes with specific meaning for this API,
//!          they are listed below.
//! \retval  LWAPI_ILWALID_ARGUMENT    Number of requested domains exceed LWAPI_MAX_GPU_PERF_VOLTAGES.
//! \ingroup gpuvoltage
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetVoltageDomainsInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_VOLTAGE_DOMAINS_INFO *pVoltageDomainsInfo);



//! \addtogroup gpuvoltage
//! @{

//! Used in LwAPI_GPU_GetVoltageDomainsStatus().
//! Fields marked with [SET] must be populated when making LwAPI_GPU_GetVoltageDomainsStatus() call.
typedef struct 
{
    //! Domain ID (To be [SET] only if LW_GPU_VOLTAGE_DOMAINS_STATUS_V<n>::numDomains > 0).
    LW_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID domainId;

    //! Current voltage for this domain in uV.
    LwU32                              voltageuV;
} LW_GPU_VOLTAGE_DOMAIN_STATUS_V1;

//! Used in LwAPI_GPU_GetVoltageDomainsStatus().
//! Fields marked with [SET] must be populated when making LwAPI_GPU_GetVoltageDomainsStatus() call.
typedef struct
{
    //! [SET] Version info of the structure (LW_GPU_VOLTAGE_DOMAINS_STATUS_VER<n>).
    LwU32 version;

    //! Reserved for future use.
    LwU32 flags;

    //! [SET] Number of voltage domains to query for obtaining their current status.
    //! Clients should set this to 0 to query all supported domains.
    LwU32 numDomains;

    //! Array of voltage domains and has 0 to numDomains - 1 as valid index range.
    LW_GPU_VOLTAGE_DOMAIN_STATUS_V1 domains[LWAPI_MAX_GPU_PERF_VOLTAGES];
} LW_GPU_VOLTAGE_DOMAINS_STATUS_V1;

//! Used in LwAPI_GPU_GetVoltageDomainsStatus().
typedef LW_GPU_VOLTAGE_DOMAINS_STATUS_V1       LW_GPU_VOLTAGE_DOMAINS_STATUS;

//! Macro for constructing the version field of LW_GPU_VOLTAGE_DOMAINS_STATUS_V1.
#define LW_GPU_VOLTAGE_DOMAINS_STATUS_VER1     MAKE_LWAPI_VERSION(LW_GPU_VOLTAGE_DOMAINS_STATUS_V1, 1)

//! Macro for constructing the version field of LW_GPU_VOLTAGE_DOMAINS_STATUS_VER1.
#define LW_GPU_VOLTAGE_DOMAINS_STATUS_VER      LW_GPU_VOLTAGE_DOMAINS_STATUS_VER1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetVoltageDomainsStatus
//
//! DESCRIPTION:  This API returns current status for the specified domains.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Version: 295.xx
//!
//! \param [in]  hPhysicalGpu          The physical GPU handle
//! \param [out] pVoltageDomainsStatus Pointer to structure containing the current status
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status.
//!          If there are return error codes with specific meaning for this API,
//!          they are listed below.
//! \retval  LWAPI_ILWALID_ARGUMENT    Number of requested domains exceed LWAPI_MAX_GPU_PERF_VOLTAGES.
//! \ingroup gpuvoltage
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetVoltageDomainsStatus(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_VOLTAGE_DOMAINS_STATUS *pVoltageDomainsStatus);





//! \addtogroup gpupower
//! @{
#define LW_GPU_POWER_DEVICE_MAX_DEVICES_V1                                    32

typedef enum _LW_GPU_POWER_DEVICE_TYPE
{
    LW_GPU_POWER_DEVICE_TYPE_DISABLED = 0,
    LW_GPU_POWER_DEVICE_TYPE_INA219,
    LW_GPU_POWER_DEVICE_TYPE_VT1165,
    LW_GPU_POWER_DEVICE_TYPE_CHL8112,
    LW_GPU_POWER_DEVICE_TYPE_INA209,
    LW_GPU_POWER_DEVICE_TYPE_INA3221,
    LW_GPU_POWER_DEVICE_TYPE_BA00,
    LW_GPU_POWER_DEVICE_TYPE_BA10HW,
    LW_GPU_POWER_DEVICE_TYPE_BA10SW,
    LW_GPU_POWER_DEVICE_TYPE_BA11HW,
    LW_GPU_POWER_DEVICE_TYPE_BA11SW,
    LW_GPU_POWER_DEVICE_TYPE_BA12HW,

} LW_GPU_POWER_DEVICE_TYPE;

typedef enum _LW_GPU_POWER_DEVICE_POWER_RAIL
{
  LW_GPU_POWER_DEVICE_POWER_RAIL_DISABLED              =        0x00000000,
  LW_GPU_POWER_DEVICE_POWER_RAIL_OUTPUT_LWVDD          =        0x00000001,
  LW_GPU_POWER_DEVICE_POWER_RAIL_OUTPUT_FBVDD          =        0x00000002,
  LW_GPU_POWER_DEVICE_POWER_RAIL_OUTPUT_FBVDDQ         =        0x00000003,
  LW_GPU_POWER_DEVICE_POWER_RAIL_OUTPUT_FBVDD_Q        =        0x00000004,
  LW_GPU_POWER_DEVICE_POWER_RAIL_OUTPUT_PEXVDD         =        0x00000005,
  LW_GPU_POWER_DEVICE_POWER_RAIL_OUTPUT_A3V3           =        0x00000006,
  LW_GPU_POWER_DEVICE_POWER_RAIL_INPUT_EXT12V_8PIN0    =        0x000000FA,
  LW_GPU_POWER_DEVICE_POWER_RAIL_INPUT_EXT12V_8PIN1    =        0x000000FB,
  LW_GPU_POWER_DEVICE_POWER_RAIL_INPUT_EXT12V_6PIN0    =        0x000000FC,
  LW_GPU_POWER_DEVICE_POWER_RAIL_INPUT_EXT12V_6PIN1    =        0x000000FD,
  LW_GPU_POWER_DEVICE_POWER_RAIL_INPUT_PEX3V3          =        0x000000FE,
  LW_GPU_POWER_DEVICE_POWER_RAIL_INPUT_PEX12V          =        0x000000FF,

} LW_GPU_POWER_DEVICE_POWER_RAIL;

/*!
 * Used in \ref LW_GPU_POWER_DEVICE_INFO_V2.
 *
 * Structure of static information specific to the BA00 power device.  This
 * Power Device is the very basic BA implementation found on GK10X and the
 * model which helps correct for its inaclwracy.
 */
typedef struct _LW_GPU_POWER_DEVICE_INFO_BA00
{
    /*!
     * Index into Power Equation table for equation to estimate leakage power.
     */
    LwU8 leakageIdx;
    /*!
     * Index into Power Equation table for first fit equation to estimate BA
     * v0.0 dynamic power.  BA v0.0 sensor will use all fits in the range
     * [\ref fitIdxFirst, \ref fitIdxLast] to estimate dynamic power.
     */
    LwU8 fitIdxFirst;
    /*!
     * Index into Power Equation table for last fit equation to estimate BA
     * v0.0 dynamic power.  BA v0.0 sensor will use all fits in the range
     * [\ref fitIdxFirst, \ref fitIdxLast] to estimate dynamic power.
     */
    LwU8 fitIdxLast;
    /*!
     * Index into Power Equation table for conservative "high power" fit
     * equation to estimate BA v0.0 dynamic power.  This fit equation is the
     * most conservative fit which was trained from the most aggresive power
     * virus app (e.g. GLI).
     *
     * This high power fit may be disabled by setting to \ref
     * LW_GPU_POWER_PWR_EQUATION_INDEX_ILWALID.  Otherwise, index must be
     * within range [\ref fitIdxFirst, \ref fitIdxLast].
     *
     * Due to lack of TEX coverage, BA v0.0 exhibits lack of level separation
     * between the most aggressive power virus apps (e.g. GLI) and and some of
     * the more aggressive perf apps (e.g. 3DM11 GT1) - thus certain perf apps
     * can be fit with the conservative high power fit and their power can be
     * over-estimated, leading to sub-optimal performance from over-capping.
     *
     * PWR_DEVICE_BA00 WARs this problem by only considering the conservative
     * "high power" fit when the last estimated total power (e.g. \ref
     * RM_PMU_PMGR_PWR_DEVICE_BA00_PROV_TOTAL_POWER) is > \ref threshmWHiPwr.
     * Board solutions will specify this threshold value at a value that perf
     * apps should not hit for worst-case operating conditions - i.e. such that
     * the perf-trained fits evaluate to this point only for very extreme
     * workloads.
     */
    LwU8 fitIdxHiPwr;
    /*!
     * Threshold for estimated total power (e.g. \ref
     * RM_PMU_PMGR_PWR_DEVICE_BA00_PROV_TOTAL_POWER) which will enable the
     * conservative "high power" fit - \ref fitIdxHiPwr, per the PWR_DEVICE_BA00
     * WAR for level separation.
     */
    LwU32 threshmWHiPwr;
} LW_GPU_POWER_DEVICE_INFO_BA00;

/*!
 * Used in \ref LW_GPU_POWER_DEVICE_INFO_V2.
 *
 * Structure of static information specific to the BA1XHW power device.  This
 * Power Device is GPU's internal HW logic designed for lwrent/power estimation
 * on GK11X (BA10HW), GK20X (BA11HW) and GM10X+ (BA12HW).
 */
typedef struct _LW_GPU_POWER_DEVICE_INFO_BA1XHW
{
    /*!
     * Index into Power Equation Table (PWR_EQUATION) for the scaling equation
     */
    LwU8    scalingEquIdx;
    /*!
     * Index into Power Equation Table (PWR_EQUATION) for the offset equation
     */
    LwU8    offsetEquIdx;
    /*!
     * Index of associated HW BA averaging window
     */
    LwU8    windowIdx;
    /*!
     * Number of bits to right-shift within Step Period Integrator HW
     */
    LwU8    sumShift;
    /*!
     * Size of BA averaging window expressed as log2(utils clocks)
     */
    LwU8    winPeriod;
    /*!
     * If set to '1' then device monitors/estimates GPU current [mA], 
     * otherwise power [mW]
     */
    LwU32   isMeasuringLwrrent:1;
    /*!
     * If set to '1' then include BA figures from silicon powerd with LWVDD
     */
    LwU32   isMonitoringLWVDD:1;
    /*!
     * If set to '1' then include BA figures from silicon powerd with FBVDDQ
     */
    LwU32   isMonitoringFBVDDQ:1;
    /*!
     * Reserved for future use  
     */
    LwU32   reserved:29;
} LW_GPU_POWER_DEVICE_INFO_BA1XHW;

/*!
 * Used in \ref LW_GPU_POWER_DEVICE_INFO_V2.
 *
 * Structure of static information specific to the BA1XSW power device.  This
 * Power Device is RM's SW wrapper around HW debug functionality designed for
 * lwrent/power estimation on GK11X (BA10SW) and GK20X (BA11SW).
 */
typedef struct _LW_GPU_POWER_DEVICE_INFO_BA1XSW
{
    /*!
     * Index into Power Devices Table of parent BA1XHW device to monitor.
     */
    LwU8    pwrDeviceIdx;
    /*!
     * Minimum sampling period in units of micro-seconds [us].
     *
     * Once PMU samples BA using debug registers they are cleared and it has to
     * wait this minimum time for new BA to accumulate before it samples again.
     * Meanwhile it will report cached value from previous period.
     */
    LwU32   minSamplingPeriodus;
} LW_GPU_POWER_DEVICE_INFO_BA1XSW;

/*!
 * Used in \ref LW_GPU_POWER_DEVICE_INFO_V2.
 *
 * Structure of static information specific to the INA209 power device.  This
 * Power Device is TI's INA209 ADC which can monitor power, current, and voltage
 * of a single provider, as well as provide various HW-threshold-based current
 * capping feautres.
 */
typedef struct _LW_GPU_POWER_DEVICE_INFO_INA209
{
    /*!
     * Shunt Resistor Resistance (mOhm)
     */
    LwU16 rShuntmOhm;
    /*!
     * Configuration register value
     */
    LwU16 calibration;
    /*!
     * Calibration register value
     */
    LwU16 configuration;
    /*!
     * Critical DAC+ register value
     */
    LwU16 criticalDacPos;
    /*!
     * Critical DAC- register value
     */
    LwU16 criticalDacNeg;
} LW_GPU_POWER_DEVICE_INFO_INA209;

/*!
 * Used in \ref LW_GPU_POWER_DEVICE_INFO_V2.
 *
 * Structure of static information specific to the INA219 power device.  This
 * Power Device is TI's INA219 ADC which can monitor power, current, and voltage
 * of a single provider.
 */
typedef struct _LW_GPU_POWER_DEVICE_INFO_INA219
{
    /*!
     * Shunt Resitor Resistance (mOhm)
     */
    LwU16 rShuntmOhm;
    /*!
     * Configuration register value
     */
    LwU16 calibration;
    /*!
     * Calibration register value
     */
    LwU16 configuration;
} LW_GPU_POWER_DEVICE_INFO_INA219;

/*!
 * Used in \ref LW_GPU_POWER_DEVICE_INFO_INA3221.
 *
 * Macro to represent number of physical channels on an INA3221 device.
 */
#define LW_GPU_POWER_DEVICE_INFO_INA3221_CH_NUM                             0x03

/*!
 * Used in \ref LW_GPU_POWER_DEVICE_INFO_V2.
 *
 * Structure of static information specific to the INA3221 power device.  This
 * Power Device is TI's INA3221 ADC which can monitor power, current, and
  * voltage of 3 providers as well as alert control functionality.
 */
typedef struct _LW_GPU_POWER_DEVICE_INFO_INA3221
{
    /*!
     * Shunt Resitor Resistance (mOhm)
     */
    LwU16       rShuntmOhm[LW_GPU_POWER_DEVICE_INFO_INA3221_CH_NUM];
    /*!
     * Configuration register value
     */
    LwU16       configuration;
    /*!
     * Mask/Enable register value
     */
    LwU16       maskEnable;
    /*!
     * The GPIO function this device could trigger.
     */
    LwU8        gpioFunction;
    /*!
     * Current value linear correction factor M. This is used to adjust
     * INA3221's measurement in using Mx + B correction. Unitless.
     * This value is in UFXP4_12 format.
     */
    LwU16       lwrrCorrectM;
    /*!
     * Current value linear correction factor B. Units of Amps. This value is in
     * SFXP4_12 format.
     */
    LwS16       lwrrCorrectB;
} LW_GPU_POWER_DEVICE_INFO_INA3221;

/*!
 * Used in \ref LW_GPU_POWER_DEVICE_GET_INFO_V1.
 *
 * Structure of static information describing a POWER_DEVICE, which specifies
 * per the Power Sensors Table spec a power sensor on the board or GPU which is
 * capable of provide telemtry for some subset of power, current, and voltage on
 * a set number of providers.
 */
typedef struct _LW_GPU_POWER_DEVICE_INFO_V1
{
    /*!
     * This will be populated using one of the enums values defined for
     * LW_GPU_POWER_DEVICE_TYPE.
     */
    LwU8  type;
    /*!
     * This will be populated using one of the enums values defined for
     * LW_GPU_POWER_DEVICE_TYPE.
     */
    LwU8  powerRail;
} LW_GPU_POWER_DEVICE_INFO_V1;

/*!
 * Used in \ref LW_GPU_POWER_DEVICE_GET_INFO_V2.
 *
 * Structure of static information describing a POWER_DEVICE, which specifies
 * per the Power Sensors Table spec a power sensor on the board or GPU which is
 * capable of provide telemtry for some subset of power, current, and voltage on
 * a set number of providers.
 */
typedef struct _LW_GPU_POWER_DEVICE_INFO_V2
{
    /*!
     * This will be populated using one of the enums values defined for
     * LW_GPU_POWER_DEVICE_TYPE.
     */
    LwU8  type;
    /*!
     * This will be populated using one of the enums values defined for
     * LW_GPU_POWER_DEVICE_TYPE.
     */
    LwU8  powerRail;

    /*!
     * Reserved 32 bytes of space so can add new data w/o needing to add a new
     * version.
     */
    LwU8 rsvd[32];

    /*!
     * Union of type-specific data.
     */
    union
    {
        LW_GPU_POWER_DEVICE_INFO_BA00    ba00;
        LW_GPU_POWER_DEVICE_INFO_BA1XHW  ba1xhw;
        LW_GPU_POWER_DEVICE_INFO_BA1XSW  ba1xsw;
        LW_GPU_POWER_DEVICE_INFO_INA209  ina209;
        LW_GPU_POWER_DEVICE_INFO_INA219  ina219;
        LW_GPU_POWER_DEVICE_INFO_INA3221 ina3221;

        /*!
         * Reserving 48 bytes of space so can add new types without needing to
         * add a new version.
         */
        LwU8 rsvd[48];
    } data;
} LW_GPU_POWER_DEVICE_INFO_V2;

/*!
 * Used in \ref LwAPI_GPU_PowerDeviceGetInfo().
 *
 * Structure representing the static state information associated with the GPU's
 * POWER_DEVICE functionality.
 */
typedef struct _LW_GPU_POWER_DEVICE_GET_INFO_V1
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32  version;

    /*!
     * Mask of POWER_DEVICE entries specified on this GPU.
     */
    LwU32  pwrDeviceMask;

    /*!
     * Array of POWER_DEVICE entries.  Has valid indexes corresponding to the
     * bits set in \ref pwrDeviceMask.
     */
    LW_GPU_POWER_DEVICE_INFO_V1
        devices[LW_GPU_POWER_DEVICE_MAX_DEVICES_V1];
} LW_GPU_POWER_DEVICE_GET_INFO_V1;

/*!
 * Used in \ref LwAPI_GPU_PowerDeviceGetInfo().
 *
 * Structure representing the static state information associated with the GPU's
 * POWER_DEVICE functionality.
 */
typedef struct _LW_GPU_POWER_DEVICE_GET_INFO_V2
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32  version;

    /*!
     * Mask of POWER_DEVICE entries specified on this GPU.
     */
    LwU32  pwrDeviceMask;

    /*!
     * Reserving 32 bytes of for future use w/o needing to add new structure
     * version.
     */
    LwU8   rsvd[32];

    /*!
     * Array of POWER_DEVICE entries.  Has valid indexes corresponding to the
     * bits set in \ref pwrDeviceMask.
     */
    LW_GPU_POWER_DEVICE_INFO_V2
        devices[LW_GPU_POWER_DEVICE_MAX_DEVICES_V1];
} LW_GPU_POWER_DEVICE_GET_INFO_V2;

#define LW_GPU_POWER_DEVICE_GET_INFO_VER_1   MAKE_LWAPI_VERSION(LW_GPU_POWER_DEVICE_GET_INFO_V1,1)
#define LW_GPU_POWER_DEVICE_GET_INFO_VER_2   MAKE_LWAPI_VERSION(LW_GPU_POWER_DEVICE_GET_INFO_V2,1)
#define LW_GPU_POWER_DEVICE_GET_INFO_VER     LW_GPU_POWER_DEVICE_GET_INFO_VER_2

typedef LW_GPU_POWER_DEVICE_GET_INFO_V2 LW_GPU_POWER_DEVICE_GET_INFO;


//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_PowerDeviceGetInfo
//
//! \code
//! DESCRIPTION: Gets information about the Power Device Support on the
//!              board.
//!
//! PARAMETERS:  hPhysicalGPU(IN) - GPU selection.
//!              pPwrDevInfo(OUT) - Structure describing the pwrDevices
//!                present/supported on the board.
//!              - pwrDeviceMask is a mask of the valid power device entries in
//!                  the devices[] array.  Every bit set in the mask represents
//!                  a valid entry in the array.
//!              - devices has valid indexes corresponding to the set bits in
//!                  pwrDeviceMask.
//!                - devices[i].type represents the type of power device.  Must
//!                    be one of the LW_GPU_POWER_DEVICE_TYPE_<xyz> enumerations.
//!                - devices[i].powerRaile representst he power rail the power
//!                    device is monitoring - maybe an input or output power
//!                    rail.  Must be one of the
//!                    LW_GPU_POWER_DEVICE_POWER_RAIL_<xyz> enumerations.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! RETURN STATUS:
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    LWAPI_NOT_SUPPORTED - P-States is not supported on this setup
//!    LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//! \endcode
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PowerDeviceGetInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_POWER_DEVICE_GET_INFO *pPwrDevInfo);


//! \ingroup gpupower
typedef struct
{
    LwU32  version;

    LwU32  pwrDeviceMask;
    struct
    {
        LwU32 powermW;
        LwU32 voltageuV;
        LwU32 lwrrentmA;
    } devices[LW_GPU_POWER_DEVICE_MAX_DEVICES_V1];
} LW_GPU_POWER_DEVICE_GET_STATUS_V1;

//! \ingroup gpupower
#define LW_GPU_POWER_DEVICE_GET_STATUS_VER_1   MAKE_LWAPI_VERSION(LW_GPU_POWER_DEVICE_GET_STATUS_V1,1)
//! \ingroup gpupower
#define LW_GPU_POWER_DEVICE_GET_STATUS_VER     LW_GPU_POWER_DEVICE_GET_STATUS_VER_1
//! \ingroup gpupower
#define LW_GPU_POWER_DEVICE_GET_STATUS         LW_GPU_POWER_DEVICE_GET_STATUS_V1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_PowerDeviceGetStatus
//
//! \code
//! DESCRIPTION: Queries the latest readings for a subset of the Power Devices
//!              on the board.
//!
//! PARAMETERS:  hPhysicalGPU(IN) - GPU selection.
//!              pPwrDevStatus(OUT) - Structure for querying a subset of the
//!                power devices present/supported on a board.
//!              - pwrDeviceMask specifies the subset of power devices to query.
//!                  This must be a subset of the mask returned by
//!                  LwAPI_GPU_PowerDeviceGetInfo().
//!              - devices has valid indexes corresponding to the set bits in
//!                  pwrDeviceMask.
//!                - devices[i].powermW returns the queried power device's latest
//!                    power reading in mW.
//!                - devices[i].voltageuV returns the queried power device's latest
//!                    voltage reading in uV.
//!                - devices[i].lwrrentmA returns the queried power device's latest
//!                    current reading in mA.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! RETURN STATUS:
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    LWAPI_NOT_SUPPORTED - P-States is not supported on this setup
//!    LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//! \endcode
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PowerDeviceGetStatus(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_POWER_DEVICE_GET_STATUS *pPwrDevStatus);


//! \ingroup gpupower
//! @{

#define LW_GPU_POWER_MONITOR_CHANNEL_INDEX_ILWALID                          0xFF

#define LW_GPU_POWER_MONITOR_MAX_CHANNELS_V1                                  32
#define LW_GPU_POWER_MONITOR_MAX_CHANNELS_V2                                  32

#define LW_GPU_POWER_MONITOR_MAX_CHANNEL_RELATIONSHIPS_V2                     32

/*!
 * Enumeration of POWER_CHANNEL types. Different types implement the
 * POWER_CHANNEL functionality via different mechanisms.  Also, specifies how
 * to interpret the channel type data union.
 */
typedef enum
{
    LW_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_DEFAULT = 0x00000000,
    LW_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_SUMMATION,
    LW_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_ESTIMATION,
    LW_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_SLOW,
    LW_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_GEMINI_CORRECTION,
    LW_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_1X,
    LW_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_SENSOR,
} LW_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE;

/*!
 * Enumeration of power rails a POWER_CHANNEL may be monitoring.  Rails prefixed
 * with "_OUTPUT" are output power rails, prefixed with "_INPUT" are input power
 * rails.
 */
typedef enum
{
    LW_GPU_POWER_CHANNEL_POWER_RAIL_UNKNOWN               =        0x00000000,
    LW_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_LWVDD          =        0x00000001,
    LW_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_FBVDD          =        0x00000002,
    LW_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_FBVDDQ         =        0x00000003,
    LW_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_FBVDD_Q        =        0x00000004,
    LW_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_PEXVDD         =        0x00000005,
    LW_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_A3V3           =        0x00000006,
    LW_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_3V3LW          =        0x00000007,
    LW_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_TOTAL_GPU      =        0x00000008,
    LW_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_TOTAL_BOARD     =        0x000000F5,
    LW_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_LWVDD           =        0x000000F6,
    LW_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_FBVDD           =        0x000000F7,
    LW_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_FBVDDQ          =        0x000000F8,
    LW_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_FBVDD_Q         =        0x000000F9,
    LW_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_EXT12V_8PIN0    =        0x000000FA,
    LW_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_EXT12V_8PIN1    =        0x000000FB,
    LW_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_EXT12V_6PIN0    =        0x000000FC,
    LW_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_EXT12V_6PIN1    =        0x000000FD,
    LW_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_PEX3V3          =        0x000000FE,
    LW_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_PEX12V          =        0x000000FF,
} LW_GPU_POWER_CHANNEL_POWER_RAIL;

/*!
 * Enumeration of POWER_CHANNEL_RELATIONSHIP types.  Different
 * POWER_CHANNEL_RELATIONSHIP types use different functionality to implement the
 * interface by which to scale power readings.  This enumeration also specifies
 * how to interpret the the channel relationship type data union.
 */
typedef enum
{
    LW_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_WEIGHT             = 0x00000000,
    LW_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_BALANCED_PHASE_EST,
    LW_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_BALANCING_PWM_WEIGHT,
} LW_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE;

/*!
 * Used in \ref LW_GPU_POWER_MONITOR_GET_INFO_V1.  Structure representing the
 * static state corresponding to a POWER_CHANNEL.
 *
 * \note This structure is deprecated for \ref
 *  LW_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2.
 */
typedef struct
{
    /*!
     * This field has been deprecated and will not be populated.
     *
     * Please see to \ref
     * LW_GPU_POWER_MONITOR_POWER_CHANNEL_SUMMATION_1X_INFO::pwrDeviceMask or
     * INFOLW_GPU_POWER_MONITOR_POWER_CHANNEL_SENSOR_INFO::pwrDevIdx.
     */
    LwU32 pwrDeviceMask;
    /*!
     * Static offset (in mW) which is added to all statistics related to power.
     */
    LwS32 pwrOffsetmW;
    /*!
     * This field has been deprecated and will not be populated.
     *
     * Please see to \ref
     * LW_GPU_POWER_MONITOR_POWER_CHANNEL_SUMMATION_1X_INFO::pwrLimitmW.
     */
    LwU32 pwrLimitmW;
} LW_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V1;

/*!
 * Used in \ref LwAPI_GPU_PowerMonitorGetInfo().  Structure representing static
 * state describing a GPU's supported power topology.  A "power topology" is
 * defined as the set of power rails (i.e. power channels) which can be
 * measured/estimated in some way and all the details about how they are
 * measured/estimated.
 *
 * \note This structure is deprecated for \ref
 *  LW_GPU_POWER_MONITOR_GET_INFO_V2.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32  version;

    /*!
     * Specifies whether power monitoring is supported on the board.
     */
    LwU8   bSupported;
    /*!
     * The period (in ms) between the samples of each power channel by the
     * RM/PMU PWR software stack.
     */
    LwU32  samplingPeriodms;
    /*!
     * The number of samples per "iteration".  An "iteration" is the number of
     * samples over which samples are averaged and after which all
     * POWER_CAPPPING or POWER_POLICY entires are evaluated.
     */
    LwU32  sampleCount;

    /*!
     * Mask of valid power monitoring channel entries in the \ref channels[]
     * array.  Every bit set represents a valid entry in the array.
     */
    LwU32  channelMask;
    /*!
     * Array of static information describing POWER_CHANNELs.  Has valid indexes
     * corresponding to the set bits in \ref channelMask.
     */
    LW_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V1 channels[LW_GPU_POWER_MONITOR_MAX_CHANNELS_V1];
} LW_GPU_POWER_MONITOR_GET_INFO_V1;

/*!
 * Used in \ref LW_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2.  Structure
 * representing data specific to \ref
 * LW_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_1X.  This POWER_CHANNEL type
 * represents the data specific to the Power Tables 1.0 channels used in GF10X
 * power capping.
 */
typedef struct
{
    /*!
     * Mask of POWER_DEVICEs to use as input for this channel.  The conception of
     * a mask of POWER_DEVICEs is legacy - the new PWR_CHANNEL_SENSOR class can
     * only refer to a single POWER_DEVICE and provider.
     */
    LwU32       pwrDeviceMask;

    /*!
     * Power Limit (mW)
     */
    LwU32       pwrLimitmW;
} LW_GPU_POWER_MONITOR_POWER_CHANNEL_1X_INFO;

/*!
 * Used in \ref LW_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2.  Structure
 * representing data specific to \ref
 * LW_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_1X.  This POWER_CHANNEL type
 * represents the data specific to the slowdown channels used in GF10X
 * power capping.
 */
typedef struct
{
    LW_GPU_POWER_MONITOR_POWER_CHANNEL_1X_INFO super;
} LW_GPU_POWER_MONITOR_POWER_CHANNEL_SLOW_INFO;

/*!
 * Used in \ref LW_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2.  Structure
 * representing data specific to \ref
 * LW_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_1X.  This POWER_CHANNEL type
 * represents the data specific the Gemini Correction channels used in GF10X
 * Gemini power capping.
 */
typedef struct
{
    LW_GPU_POWER_MONITOR_POWER_CHANNEL_SLOW_INFO super;
} LW_GPU_POWER_MONITOR_POWER_CHANNEL_GEMINI_CORRECTION_INFO;

/*!
 * Used in \ref LW_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2.  Structure
 * representing data specific to \ref
 * LW_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_SENSOR.  This POWER_CHANNEL type
 * queries the given POWER_DEVICE for power telemetry.
 */
typedef struct
{
    /*!
     * Index into the Power Sensors Table for the POWER_DEVICE from which this
     * POWER_CHANNEL should query power values.
     */
    LwU8 pwrDevIdx;

    /*!
     * Index of the POWER_DEVICE Provider to query.
     */
    LwU8 pwrDevProvIdx;
} LW_GPU_POWER_MONITOR_POWER_CHANNEL_SENSOR_INFO;

/*!
 * Used in \ref LW_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2.  Structure
 * representing data specific to \ref
 * LW_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_SUMMATION.  This POWER_CHANNEL type
 * will sum all the readings corresponding to all POWER_CHANNEL_RELATIONSHIPs in
 * the range [\ref relIdxFirst, \ref relIdxLast].
 */
typedef struct
{
    /*!
     * First index into the POWER_CHANNEL_RELATIONSHIP table.
     */
    LwU8 relIdxFirst;
    /*!
     * Last index into the POWER_CHANNEL_RELATIONSHIP table.
     */
    LwU8 relIdxLast;
} LW_GPU_POWER_MONITOR_POWER_CHANNEL_SUMMATION_INFO;

/*!
 * Used in \ref LW_GPU_POWER_MONITOR_GET_INFO_V2.  Structure representing the
 * static state corresponding to a POWER_CHANNEL.
 *
 * \note This structure must remain binary-compatible with \ref
 * LW_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V1 (from power 1.0/Power Capping).
 * Thus, some fields aren't grouped together logically and some fields aren't
 * applicablef or all POWER_CHANNEL types (\ref
 * LW_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE).
 */
typedef struct
{
    // Ordering of variables needs to be maintained with _V1.

    /*!
     * This field has been deprecated and will not be populated.
     *
     * Please see to \ref
     * LW_GPU_POWER_MONITOR_POWER_CHANNEL_SUMMATION_1X_INFO::pwrDeviceMask or
     * INFOLW_GPU_POWER_MONITOR_POWER_CHANNEL_SENSOR_INFO::pwrDevIdx.
     */
    LwU32 pwrDeviceMask;
    /*!
     * Power Correction Offset - signed mW.
     */
    LwS32 pwrOffsetmW;
    /*!
     * This field has been deprecated and will not be populated.
     *
     * Please see to \ref
     * LW_GPU_POWER_MONITOR_POWER_CHANNEL_SUMMATION_1X_INFO::pwrLimitmW.
     */
    LwU32 pwrLimitmW;

    // Begin new variables for _V2.

    /*!
     * LW_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_<xyz>.
     */
    LW_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE type;

    /*!
     * Power Rail - LW_GPU_POWER_CHANNEL_POWER_RAIL_<xyz>.
     */
    LwU8  pwrRail;
    /*!
     * Fixed voltage (in uV) to assume for this PWR_CHANNEL.  Used to simplify
     * power <-> current colwersion.
     */
    LwU32 voltFixeduV;
    /*!
     * Power Correction Slope - unsigned FXP20.12 value.
     */
    LwU32 pwrCorrSlope;

    /*!
     * Reserving 16 bytes of space so can add new types without needing to
     * add a new version.
     */
    LwU8 rsvd[16];

    /*!
     * Union of type-specific data.  Interpreted based on \ref type value.
     */
    union
    {
        LW_GPU_POWER_MONITOR_POWER_CHANNEL_1X_INFO                c1x;
        LW_GPU_POWER_MONITOR_POWER_CHANNEL_GEMINI_CORRECTION_INFO gemmCorr;
        LW_GPU_POWER_MONITOR_POWER_CHANNEL_SENSOR_INFO            sensor;
        LW_GPU_POWER_MONITOR_POWER_CHANNEL_SLOW_INFO              slow;
        LW_GPU_POWER_MONITOR_POWER_CHANNEL_SUMMATION_INFO         sum;
        /*!
         * Reserving 16 bytes of space so can add new types without needing to
         * add a new version.
         */
        LwU8 rsvd[16];
    } data;
} LW_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2;


/*!
 * Used in \ref LW_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V2.
 * Structure representing data specific to \ref
 * LW_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_WEIGHT.  This
 * POWER_CHANNEL_RELATIONSHIP type will take the power reading from the
 * specified channel (\ref chIdx) and will scale readings by teh specified \ref
 * weight to its reading.
 */
typedef struct
{
    /*!
     * Weight value by which to scale readings.  Signed FXP 20.12 number.
     * Unitless.
     */
    LwS32 weight;
} LW_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_WEIGHT_INFO;

/*!
 * Used in \ref LW_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V2.
 *
 * Structure representing data specific to \ref
 * LW_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_BALANCED_PHASE_EST.
 *
 * This is a relationship evaluates to a proportion of power
 * of the specififed channel index, where the proportion is a dynamic factor
 * depending on the value of the balanced phases.
 *
 * This Channel Relationship is intended to be used to compute the total input
 * power of a voltage regulator of which one or more phases are being
 * dynamically balanced via the _BALANCE Power Policy and Power Policy
 * Relationship Classes.
 */
typedef struct
{
    /*!
     * Total number of phases by which to scale up the estimated power.
     */
    LwU8 numTotalPhases;
    /*!
     * Number of static phases which should be included in the evaluation of
     * this Channel Relationship.
     */
    LwU8 numStaticPhases;
    /*!
     * Index of first _BALANCE Power Policy Relationship representing a
     * balanced phase.  This relationship must be of type _BALANCE.
     */
    LwU8 balancedPhasePolicyRelIdxFirst;
    /*!
     * Index of last _BALANCE Power Policy Relationship representing a
     * balanced phase.  This relationship must be of type _BALANCE.
     */
    LwU8 balancedPhasePolicyRelIdxLast;
} LW_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_BALANCED_PHASE_EST_INFO;

/*!
 * Used in \ref LW_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V2.
 *
 * Structure representing data specific to \ref
 * LW_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_BALANCING_PWM_WEIGHT.
 *
 * This is a relationship evaluates to a proportion of power of the specififed
 * channel index, where the proportion is the current PWM percentage of a
 * Balancing Power Policy Relationship.
 */
typedef struct
{
    /*!
     * Index to PWR_POLICY_RELATIONSHIP object of type
     * PWR_POLICY_RELATIONSHIP_BALANCE which will be queried for its current PWM
     * percentage.
     */
    LwU8   balancingRelIdx;

    /*!
     * Boolean indicating whether to use the primary/normal or
     * secondary/ilwerted PWM percentage as the weight.
     */
    LwU8   bPrimary;
} LW_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_BALANCING_PWM_WEIGHT_INFO;

/*!
 * Used in \ref LW_GPU_POWER_MONITOR_GET_INFO_V2.  Structure representing the
 * static state corresponding to a POWER_CHANNEL_RELATIONSHIP.
 */
typedef struct
{
    /*!
     * LW_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_<xyz>
     */
    LW_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE type;

    /*!
     * Index of the POWER_CHANNEL for this POWER_CHANNEL_RELATIONSHIP.  Readings
     * will be taken from this POWER_CHANNEL when evaluating this
     * POWER_CHANNEL_RELATIONSHIP.
     */
    LwU8 chIdx;

    /*!
     * Union of type-specific data.  Interpreted based on \ref type value.
     */
    union
    {
        LW_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_WEIGHT_INFO
            weight;
        LW_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_BALANCED_PHASE_EST_INFO
            balancedPhaseEst;
        LW_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_BALANCING_PWM_WEIGHT_INFO
            balancingPwmWeight;
        /*!
         * Reserving 16 bytes of space so can add new types without needing to
         * add a new version.
         */
        LwU8 rsvd[16];
    } data;
} LW_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V2;

/*!
 * Used in \ref LwAPI_GPU_PowerMonitorGetInfo().  Structure representing static
 * state describing a GPU's supported power topology.  A "power topology" is
 * defined as the set of power rails (i.e. power channels) which can be
 * measured/estimated in some way and all the details about how they are
 * measured/estimated.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32  version;

    /*!
     * Specifies whether power monitoring is supported on the board.
     */
    LwU8   bSupported;
    /*!
     * The period (in ms) between the samples of each power channel by the
     * RM/PMU PWR software stack.
     */
    LwU32  samplingPeriodms;
    /*!
     * The number of samples per "iteration".  An "iteration" is the number of
     * samples over which samples are averaged and after which all
     * POWER_CAPPPING or POWER_POLICY entires are evaluated.
     */
    LwU32  sampleCount;

    /*!
     * Mask of valid power monitoring channel entries in the \ref channels[]
     * array.  Every bit set represents a valid entry in the array.
     */
    LwU32  channelMask;
    /*!
     * Mask of valid power monitoring channel relationship entries in the \ref
     * chRels[] array.  Every bit set represents a valid entry in the array.
     */
    LwU32  chRelMask;
    /*!
     * Set of POWER_CHANNELs, that, when added up, yield total GPU power.  Must be a
     * subset of \ref channelMask above.
     *
     * \note This is as legacy implementation for
     * PWR1.0/Power Capping Table, in which all rails are listed separately and
     * must be summed separately. For PWR2.0/Power Policy Table, this mask is
     * implemented but it is deprecated in favor of \ref totalGpuChannelIdx.
     */
    LwU32  totalGpuPowerChannelMask;
    /*!
     * POWER_CHANNEL index corresponding to TOTAL_GPU power.  This value is to
     * be referenced in PWR2.0/Power Policy Table for the single channel which
     * represents total GPU power.
     *
     * \note LW_GPU_POWER_MONITOR_CHANNEL_INDEX_ILWALID denotes a single
     * POWER_CHANNEL for total GPU power is not supported.
     */
    LwU8   totalGpuChannelIdx;

    /*!
     * Reserving 11 bytes for future use w/o needing to add new structure
     * version.
     */
    LwU8   rsvd[11];

    /*!
     * Array of static information describing POWER_CHANNELs.  Has valid indexes
     * corresponding to the set bits in \ref channelMask.
     */
    LW_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2 channels[LW_GPU_POWER_MONITOR_MAX_CHANNELS_V2];

    /*!
     * Array of static information describing POWER_CHANNEL_RELATIONSHIPs.  Has
     * valid indexes corresponding to the set bits in \ref chRelMask.
     */
    LW_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V2 chRels[LW_GPU_POWER_MONITOR_MAX_CHANNEL_RELATIONSHIPS_V2];
} LW_GPU_POWER_MONITOR_GET_INFO_V2;

#define LW_GPU_POWER_MONITOR_GET_INFO_VER_1   MAKE_LWAPI_VERSION(LW_GPU_POWER_MONITOR_GET_INFO_V1,1)
#define LW_GPU_POWER_MONITOR_GET_INFO_VER_2   MAKE_LWAPI_VERSION(LW_GPU_POWER_MONITOR_GET_INFO_V2,1)
#define LW_GPU_POWER_MONITOR_GET_INFO_VER     LW_GPU_POWER_MONITOR_GET_INFO_VER_2

#define LW_GPU_POWER_MONITOR_GET_INFO         LW_GPU_POWER_MONITOR_GET_INFO_V2

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_PowerMonitorGetInfo
//
//! DESCRIPTION: Gets information about the Power Monitoring Support on the
//!              board.
//!
//!              Power Monitoring is a feature by which the PMU regularly samples
//!              a set of power channels, which are each a collection of one or
//!              more power devices.  Monitoring collects one or more samples on
//!              each channel per each iteration and then provides various
//!              statistical information about the iteration.  This statistical
//!              information is available to the user and also maybe used as input
//!              for other features (such as power capping).
//!
//! \param [in]  hPhysicalGPU GPU selection.
//! \param [out] pPwrMonInfo  Structure describing the power monitoring
//!                support on the baord.
//!
//! TCC_SUPPORTED
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! RETURN STATUS:
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    LWAPI_NOT_SUPPORTED - P-States is not supported on this setup
//!    LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//! \endcode
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PowerMonitorGetInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_POWER_MONITOR_GET_INFO *pPwrMonInfo);


//! \addtogroup gpupower
//! @{

/*!
 * Used in \ref LW_GPU_POWER_MONITOR_GET_STATUS_V1.  Structure representing the
 * most recent dynamic state of a POWER_CHANNEL.
 */
typedef struct
{
    /*!
     * Average power (in mW) for the last iteration of samples on this
     * POWER_CHANNEL.
     */
    LwU32 pwrAvgmW;
    /*!
     * Minimum power (in mW) for the last iteration of samples on this
     * POWER_CHANNEL.
     */
    LwU32 pwrMinmW;
    /*!
     * Maximum power (in mW) for the last iteration of samples on this
     * POWER_CHANNEL.
     */
    LwU32 pwrMaxmW;
} LW_GPU_POWER_MONITOR_POWER_CHANNEL_STATUS_V1;

/*!
 * Used in \ref LwAPI_GPU_PowerMonitorGetStatus().  Structure representing a
 * requested set of POWER_CHANNELs for which the client wants to retrieve the
 * latest/current set of dynamic state.
 *
 * \note This structure has been deprecated in favor of
 * \ref LW_GPU_POWER_MONITOR_GET_STATUS_V2.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32  version;

    /*!
     * Specifies the subset of power monitoring channels to query.  This must be
     * a subset of the mask returned by \ref LwAPI_GPU_PowerMonitorGetInfo().
     */
    LwU32  channelMask;

    /*!
     * Array of dynamic state corresponding to the specified set of
     * POWER_CHANNELs.  Has valid indexes corresponding to the set bits in \ref
     * channelMask.
     */
    LW_GPU_POWER_MONITOR_POWER_CHANNEL_STATUS_V1
        channels[LW_GPU_POWER_MONITOR_MAX_CHANNELS_V1];
} LW_GPU_POWER_MONITOR_GET_STATUS_V1;

/*!
 * Used in \ref LW_GPU_POWER_MONITOR_GET_STATUS_V1.  Structure representing the
 * most recent dynamic state of a POWER_CHANNEL.
 */
typedef struct
{
    /*!
     * Average power (in mW) for the last iteration of samples on this
     * POWER_CHANNEL.
     */
    LwU32 pwrAvgmW;
    /*!
     * Minimum power (in mW) for the last iteration of samples on this
     * POWER_CHANNEL.
     */
    LwU32 pwrMinmW;
    /*!
     * Maximum power (in mW) for the last iteration of samples on this
     * POWER_CHANNEL.
     */
    LwU32 pwrMaxmW;

    /*!
     * Reserving 32 bytes for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[32];
} LW_GPU_POWER_MONITOR_POWER_CHANNEL_STATUS_V2;

/*!
 * Used in \ref LwAPI_GPU_PowerMonitorGetStatus().  Structure representing a
 * requested set of POWER_CHANNELs for which the client wants to retrieve the
 * latest/current set of dynamic state.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32  version;

    /*!
     * Specifies the subset of power monitoring channels to query.  This must be
     * a subset of the mask returned by \ref LwAPI_GPU_PowerMonitorGetInfo().
     */
    LwU32  channelMask;

    /*!
     * Total GPU power corresponding ot the last iteration of sampling.  This is
     * the summation of the values corresponding to the POWER_CHANNELs indexes
     * provided in \ref
     * LW_GPU_POWER_MONITOR_GET_INFO_V2::totalGpuPowerChannelMask.
     */
    LwU32  totalGpuPowermW;

    /*!
     * Reserving 16 bytes of space so can add new types without needing to
     * add a new version.
     */
    LwU8 rsvd[16];

    /*!
     * Array of dynamic state corresponding to the specified set of
     * POWER_CHANNELs.  Has valid indexes corresponding to the set bits in \ref
     * channelMask.
     */
    LW_GPU_POWER_MONITOR_POWER_CHANNEL_STATUS_V2
        channels[LW_GPU_POWER_MONITOR_MAX_CHANNELS_V1];
} LW_GPU_POWER_MONITOR_GET_STATUS_V2;

#define LW_GPU_POWER_MONITOR_GET_STATUS_VER_1   MAKE_LWAPI_VERSION(LW_GPU_POWER_MONITOR_GET_STATUS_V1,1)
#define LW_GPU_POWER_MONITOR_GET_STATUS_VER_2   MAKE_LWAPI_VERSION(LW_GPU_POWER_MONITOR_GET_STATUS_V2,1)
#define LW_GPU_POWER_MONITOR_GET_STATUS_VER     LW_GPU_POWER_MONITOR_GET_STATUS_VER_2

#define LW_GPU_POWER_MONITOR_GET_STATUS         LW_GPU_POWER_MONITOR_GET_STATUS_V2

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_PowerMonitorGetStatus
//
//! \code
//! DESCRIPTION: Queries the latest statistics from a subset of Power Monitoring
//!              channels supported on the board.
//!
//! PARAMETERS:  hPhysicalGPU(IN) - GPU selection.
//!              pPwrMonStatus(IN/OUT) - Structure for querying a subset of power //!
//!                  monitoring channels supported on the board.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! RETURN STATUS:
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    LWAPI_NOT_SUPPORTED - P-States is not supported on this setup
//!    LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//! \endcode
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PowerMonitorGetStatus(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_POWER_MONITOR_GET_STATUS *pPwrMonStatus);


//! \addtogroup gpupower
//! @{
#define LW_GPU_POWER_CAPPING_ALG_DISABLED                         0x00000000
#define LW_GPU_POWER_CAPPING_ALG_TEMPERATURE_SLOWDOWN             0x00000001
#define LW_GPU_POWER_CAPPING_ALG_PSTATE_CAP                       0x00000002

typedef struct
{
    LwU32  version;

    LwU8   alg;
    LwU32  channelMask;
} LW_GPU_POWER_CAPPING_GET_INFO_V1;

#define LW_GPU_POWER_CAPPING_GET_INFO_VER_1   MAKE_LWAPI_VERSION(LW_GPU_POWER_CAPPING_GET_INFO_V1,1)
#define LW_GPU_POWER_CAPPING_GET_INFO_VER     LW_GPU_POWER_CAPPING_GET_INFO_VER_1

#define LW_GPU_POWER_CAPPING_GET_INFO         LW_GPU_POWER_CAPPING_GET_INFO_V1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_PowerCappingGetInfo
//
//! \code
//! DESCRIPTION: Gets information about the Power Capping support on the
//!              board.
//!
//!              Power Capping is a feature which monitors a subset of power
//!              monitoring channels and takes some corrective action when the
//!              channels exceed their limits, attempting to bring power back
//!              within the limits.
//!
//! PARAMETERS:  hPhysicalGPU(IN) - GPU selection.
//!              pPwrCapInfo(OUT) - Structure describing Power Capping support in
//!                the board.
//!              - alg specifies the Power Capping algorithm supported on the
//!                  board.  Must be an LW_GPU_POWER_CAPPING_ALG_<xyz>
//!                  enumeration.
//!              - channelMask is the subset of power monitoring channels which
//!                  the power capping algorithm is using as input.  This must be
//!                  a subset of the channelMask returned by
//!                  LwAPI_GPU_PowerMonitorGetInfo().
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! RETURN STATUS:
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    LWAPI_NOT_SUPPORTED - P-States is not supported on this setup
//!    LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//! \endcode
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PowerCappingGetInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_POWER_CAPPING_GET_INFO *pPwrCapInfo);




//! \addtogroup gpupower
//! @{
#define LW_GPU_POWER_CAPPING_SLOWDOWN_MAX_CHANNELS_V1                          8

typedef struct
{
    LwU32  version;

    LwU8   bEnabled;
    LwU8   factorIndex;
    LwU8   factorCount;
    LwU32  capRatio;
    struct
    {
        LwU8 numerator;
        LwU8 denominator;
    } factors[LW_GPU_POWER_CAPPING_SLOWDOWN_MAX_CHANNELS_V1];
} LW_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS_V1;

#define LW_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS_VER_1  MAKE_LWAPI_VERSION(LW_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS_V1,1)
#define LW_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS_VER    LW_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS_VER_1

#define LW_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS        LW_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS_V1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_PowerCappingSlowdownGetStatus
//
//! \code
//! DESCRIPTION: Queries the latest status for slowdown-based power capping.
//!
//! PARAMETERS:  hPhysicalGPU(IN) - GPU selection.
//!              pPwrCapSlowStatus(OUT) - Structure to query the latest status of
//!                slowdown-based power capping.
//!              - bEnabled specifies whether the power capping algorithm is
//!                  lwrrently enabled.  The algorithm may be dynamically
//!                  disabled/enabled for various reasons (power virus app
//!                  detection, etc.).
//!              - factorIndex is the index into the factors array corresponding
//!                  to the lwrrently active slowdown.
//!              - factorCount is the number of slowdown factors being used by
//!                  the slowdown algorithm.
//!              - capRatio is the ratio of their power limits under which all
//!                  power monitoring channels must be in order for the algorithm
//!                  to decrement the slowdown factor index.
//!              - factors is has valid indexes between 0 and factorCount - 1.
//!                - factors[i].numerator is the numerator of the slowdown factor
//!                    specified as numerator / denominator.
//!                - factors[i].denominator is the numerator of the slowdown 
//!                    factor specified as numerator / denominator.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! RETURN STATUS:
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    LWAPI_NOT_SUPPORTED - P-States is not supported on this setup
//!    LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//! \endcode
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PowerCappingSlowdownGetStatus(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS *pPwrCapSlowStatus);


//! \ingroup gpupower
//! @{

#define LW_GPU_POWER_EQUATION_MAX_EQUATIONS_V1                               32

/*!
 * Special value corresponding to an invalid Power Equation index.  This value
 * means that equation is not specified.
 */
#define LW_GPU_POWER_EQUATION_INDEX_ILWALID                                0xFF

/*!
 * Enumeration of POWER_EQUATION equation types.  Different types implement the
 * POWER_EQUATION functionality via different mechanisms.  Also, specifies how to
 * interpret the equation entry/equation type data union.
 */
typedef enum _LW_GPU_POWER_EQUATION_TYPE
{
    LW_GPU_POWER_EQUATION_TYPE_LEAKAGE_DTCS11  = 0x00000000,
    LW_GPU_POWER_EQUATION_TYPE_BA1X_SCALE      = 0x00000001,
    LW_GPU_POWER_EQUATION_TYPE_BA00_FIT        = 0x00000002,

    LW_GPU_POWER_EQUATION_TYPE_LEAKAGE         = 0xFFFFFFFE,
    /*!
     * Unknown/unsupported type via LWAPI.  Should always be last.
     */
    LW_GPU_POWER_EQUATION_TYPE_UNKNOWN         = 0xFFFFFFFF,
} LW_GPU_POWER_EQUATION_TYPE;

/*!
 * Used in \ref LW_GPU_POWER_EQUATION_INFO_V1.  Structure repesenting data
 * specific to \ref LW_GPU_POWER_EQUATION_TYPE_LEAKAGE. Data common to 
 * all leakage equations.
 */
typedef struct _LW_GPU_POWER_EQUATION_LEAKAGE_INFO
{
    /*!
     * Floor-sweeping efficiency percentage.  Unsigned FXP4.12 value.  Unitless.
     */
    LwU16 fsEff;
    /*!
     * Power-gating efficiency percentage.  Unsigned FXP4.12 value.  Unitless.
     */
    LwU16 pgEff;
} LW_GPU_POWER_EQUATION_LEAKAGE_INFO;

/*!
 * Used in \ref LW_GPU_POWER_EQUATION_INFO_V1.  Structure repesenting data
 * specifici to \ref LW_GPU_POWER_EQUATION_TYPE_LEAKAGE_DTCS11. This 
 * POWER_EQUATION type callwlates the equation power based on a set of 4 
 * coefficients, IDDQ, voltage, and temperature.
 */
typedef struct _LW_GPU_POWER_EQUATION_LEAKAGE_DTCS11_INFO
{
    /*!
     * Data common to all leakage power equations
     */
    LW_GPU_POWER_EQUATION_LEAKAGE_INFO  leakage;
    /*!
     * Coefficient 0.
     */
    LwU32 k0;
    /*!
     * Coefficient 1.
     */
    LwU32 k1;
    /*!
     * Coefficient 2.
     */
    LwU32 k2;
    /*!
     * Coefficient 3.
     */
    LwS32 k3;
} LW_GPU_POWER_EQUATION_LEAKAGE_DTCS11_INFO;

/*!
 * Used in \ref LW_GPU_POWER_EQUATION_INFO_V1.
 *
 * Structure repesenting data specific to \ref
 * LW_GPU_POWER_EQUATION_TYPE_BA00_FIT.  This POWER_EQUATION type is used by
 * LW_GPU_POWER_DEVICE_EQUATION_TYPE_BA00 to callwlate the dynamic power based
 * on observed BA, frequency, and voltage.
 */
typedef struct _LW_GPU_POWER_EQUATION_BA00_FIT_INFO
{
    /*!
     * Slope of GPC2CLk frequency (MHz) vs. expected BA (raw BA units) lwrve.
     */
    LwU32 expBASlope;
    /*!
     * Intercept of GPC2CLk frequency (MHz) vs. expected BA (raw BA units)
     * lwrve.
     */
    LwU32 expBAIntercept;
    /*!
     * Slope of BA (raw BA untis) vs. expected dynamic power normalized by
     * voltage squared (A / V) lwrve.
     */
    LwU32 expDynPwrSlope;
    /*!
     * Intercept of BA (raw BA untis) vs. expected dynamic power normalized by
     * voltage squared (A / V) lwrve.
     */
    LwU32 expDynPwrIntercept;
} LW_GPU_POWER_EQUATION_BA00_FIT_INFO;

/*!
 * Used in \ref LW_GPU_POWER_EQUATION_INFO_V1.
 *
 * Structure repesenting data specific to \ref
 * LW_GPU_POWER_EQUATION_BA1X_SCALE_INFO. This POWER_EQUATION type is used by
 * LW_GPU_POWER_EQUATION_TYPE_BA1X_SCALE to callwlate scaling factors
 * for BA1X devices.
 */
typedef struct _LW_GPU_POWER_EQUATION_BA1X_SCALE_INFO
{
    /*!
     * Reference voltage (uV)
     */
    LwU32   refVoltageuV;
    /*!
     * BA2mW scale factor [unitless unsigned FXP 20.12 value].
     */
    LwU32   ba2mW;
    /*!
     * Reference GPCCLK (MHz)
     */
    LwU32   gpcClkMHz;
    /*!
     * Reference UTILSCLK (MHz)
     */
    LwU32   utilsClkMHz;
} LW_GPU_POWER_EQUATION_BA1X_SCALE_INFO;

/*!
 * Used in \ref LW_GPU_POWER_EQUATION_INFO_PARAMS_V1.  Structure repesenting
 * data specific to \ref LW_GPU_POWER_EQUATION_INFO_V1.  This specifies static
 * information of PWR_EQUATION, which specifies Equations.
 */
typedef struct _LW_GPU_POWER_EQUATION_INFO_V1
{
    /*!
     * LW_GPU_POWER_EQUATION_TYPE_<xyz>.
     */
    LW_GPU_POWER_EQUATION_TYPE type;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[16];

    /*!
     * Union of type-specific data.  Interpreted based on \ref type value.
     */
    union
    {
        LW_GPU_POWER_EQUATION_LEAKAGE_INFO        leakage;
        LW_GPU_POWER_EQUATION_LEAKAGE_DTCS11_INFO dtcs11;
        LW_GPU_POWER_EQUATION_BA00_FIT_INFO       ba00Fit;
        LW_GPU_POWER_EQUATION_BA1X_SCALE_INFO     ba1xScale;
        /*!
         * Reserving 32 bytes of space so can add new types without needing to
         * add a new version.
         */
        LwU8 rsvd[32];
    } data;
} LW_GPU_POWER_EQUATION_INFO_V1;

/*!
 * Used in \ref LwAPI_GPU_PowerEquationGetInfo().  Structure representing the
 * static information/capabilities of a GPU's POWER_EQUATION functionality, sets
 * of equations for callwlating/estimating equation power on a power rail.
 */
typedef struct _LW_GPU_POWER_EQUATION_INFO_PARAMS_V1
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32  version;

    /*!
     * Data describing IDDQ used for equation evaluation
     */
    struct
    {
        /*!
         * HW IDDQ fuse version.
         */
        LwU32 versionHw;
        /*!
         * SW IDDQ version.
         */
        LwU32 version;
        /*!
         * IDDQ value (mA).
         */
        LwU32 valuemA;
    } iddq;

    /*!
     * Mask of valid power equation equation entries in the \ref equations[]
     * array.  Every bit set represents a valid entry in the array.
     */
    LwU32 equationMask;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[16];

    /*!
     * Array of static information describing POWER_EQUATIONs.  Has valid indexes
     * corresponding to the set bits in \ref equationMask.
     */
    LW_GPU_POWER_EQUATION_INFO_V1 equations[LW_GPU_POWER_EQUATION_MAX_EQUATIONS_V1];
} LW_GPU_POWER_EQUATION_INFO_PARAMS_V1;

#define LW_GPU_POWER_EQUATION_INFO_PARAMS_VER_1   MAKE_LWAPI_VERSION(LW_GPU_POWER_EQUATION_INFO_PARAMS_V1,1)
#define LW_GPU_POWER_EQUATION_INFO_PARAMS_VER     LW_GPU_POWER_EQUATION_INFO_PARAMS_VER_1

typedef LW_GPU_POWER_EQUATION_INFO_PARAMS_V1      LW_GPU_POWER_EQUATION_INFO_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_PowerEquationGetInfo()
//
//! DESCRIPTION: Retrieves information about the POWER_EQUATION support on the
//!              GPU.
//!
//!              POWER_EQUATION entries are equations which specifies set of
//!              independent variables and coefficients that can be used to
//!              callwlate various power related expressions.  This function
//!              retrieves static information about the set of POWER_EQUATIONs
//!              supported by this GPU for use by other features like 
//!              POWER_POLICYs and POWER_DEVICEs.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 310.67
//!
//! \param [in]  hPhysicalGPU   GPU selection
//! \param [out] pEquationInfo  Structure containing the description of the
//!                   POWER_EQUATION support on the GPU.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PowerEquationGetInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_POWER_EQUATION_INFO_PARAMS *pEquationInfo);


//! \ingroup gpupower
//! @{

#define LW_GPU_POWER_LEAKAGE_MAX_LEAKAGES_V1                                   4
#define LW_GPU_POWER_LEAKAGE_MAX_LEAKAGES_V2                                  32

/*!
 * Special value corresponding to an invalid Power Equation index.  This value
 * means that equation is not specified.
 */
#define LW_GPU_POWER_EQUATION_INDEX_ILWALID                                 0xFF

/*!
 * Enumeration of POWER_LEAKAGE equation types.  Different types implement the
 * POWER_LEAKAGE functionality via different mechanisms.  Also, specifies how to
 * interpret the leakage entry/equation type data union.
 */
typedef enum
{
    LW_GPU_POWER_LEAKAGE_TYPE_DTCS10    = 0x00000000,
    LW_GPU_POWER_LEAKAGE_TYPE_DTCS11    = 0x00000001,
    LW_GPU_POWER_LEAKAGE_TYPE_BA00_FIT  = 0x00000002,
    /*!
     * Unknown/unsupported type via LWAPI.  Should always be last.
     */
    LW_GPU_POWER_LEAKAGE_TYPE_UNKNOWN = 0xFFFFFFFF,
} LW_GPU_POWER_LEAKAGE_TYPE;

/*!
 * Used in \ref LW_GPU_POWER_LEAKAGE_INFO_V1.  Structure repesenting data
 * specifici to \ref LW_GPU_POWER_LEAKAGE_TYPE_DTCS10.  This POWER_LEAKAGE type
 * callwlates the leakage power based on a set of 4 coefficients, IDDQ, voltage,
 * and temperature.
 */
typedef struct
{
    /*!
     * Coefficient 0.
     */
    float k0;
    /*!
     * Coefficient 1.
     */
    float k1;
    /*!
     * Coefficient 2.
     */
    float k2;
    /*!
     * Coefficient 3.
     */
    LwS32 k3;
} LW_GPU_POWER_LEAKAGE_DTCS10_INFO;

/*!
 * Used in \ref LW_GPU_POWER_LEAKAGE_INFO_V1.  Structure repesenting data
 * specifici to \ref LW_GPU_POWER_LEAKAGE_TYPE_DTCS10.  This POWER_LEAKAGE type
 * callwlates the leakage power based on a set of 4 coefficients, IDDQ, voltage,
 * and temperature.
 */
typedef struct
{
    /*!
     * Coefficient 0.
     */
    LwU32 k0;
    /*!
     * Coefficient 1.
     */
    LwU32 k1;
    /*!
     * Coefficient 2.
     */
    LwU32 k2;
    /*!
     * Coefficient 3.
     */
    LwS32 k3;
} LW_GPU_POWER_LEAKAGE_DTCS11_INFO;

/*!
 * Used in \ref LW_GPU_POWER_LEAKAGE_INFO_PARAMS_V1.  Structure repesenting data
 * specific to \ref LW_GPU_POWER_LEAKAGE_TYPE_DTCS10.  This POWER_LEAKAGE type
 * callwlates the leakage power based on a set of 4 coefficients, IDDQ, voltage,
 * and temperature.
 */
typedef struct
{
    /*!
     * LW_GPU_POWER_LEAKAGE_TYPE_<xyz>.
     */
    LW_GPU_POWER_LEAKAGE_TYPE type;

    /*!
     * Floor-sweeping efficiency percentage.  Unsigned FXP4.12 value.  Unitless.
     */
    LwU16 fsEff;
    /*!
     * Power-gating efficiency percentage.  Unsigned FXP4.12 value.  Unitless.
     */
    LwU16 pgEff;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[16];

    /*!
     * Union of type-specific data.  Interpreted based on \ref type value.
     */
    union
    {
        LW_GPU_POWER_LEAKAGE_DTCS10_INFO    dtcs10;
        LW_GPU_POWER_LEAKAGE_DTCS11_INFO    dtcs11;
        LW_GPU_POWER_EQUATION_BA00_FIT_INFO ba00Fit;
        /*!
         * Reserving 32 bytes of space so can add new types without needing to
         * add a new version.
         */
        LwU8 rsvd[32];
    } data;
} LW_GPU_POWER_LEAKAGE_INFO_V1;

/*!
 * Used in \ref LwAPI_GPU_PowerLeakageGetInfo().  Structure representing the
 * static information/capabilities of a GPU's POWER_LEAKAGE functionality, sets
 * of equations for callwlating/estimating leakage power on a power rail.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32  version;

    /*!
     * HW IDDQ fuse version.
     */
    LwU32 hwIddqVersion;
    /*!
     * SW IDDQ version.
     */
    LwU32 iddqVersion;
    /*!
     * IDDQ value (mA).
     */
    LwU32 iddqmA;

    /*!
     * Mask of valid power leakage equation entries in the \ref leakages[]
     * array.  Every bit set represents a valid entry in the array.
     */
    LwU32 leakageMask;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[16];

    /*!
     * Array of static information describing POWER_LEAKAGEs.  Has valid indexes
     * corresponding to the set bits in \ref leakageMask.
     */
    LW_GPU_POWER_LEAKAGE_INFO_V1 leakages[LW_GPU_POWER_LEAKAGE_MAX_LEAKAGES_V1];
} LW_GPU_POWER_LEAKAGE_INFO_PARAMS_V1;

/*!
 * Used in \ref LwAPI_GPU_PowerLeakageGetInfo().  Structure representing the
 * static information/capabilities of a GPU's POWER_LEAKAGE functionality, sets
 * of equations for callwlating/estimating leakage power on a power rail.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32  version;

    /*!
     * HW IDDQ fuse version.
     */
    LwU32 hwIddqVersion;
    /*!
     * SW IDDQ version.
     */
    LwU32 iddqVersion;
    /*!
     * IDDQ value (mA).
     */
    LwU32 iddqmA;

    /*!
     * Mask of valid power leakage equation entries in the \ref leakages[]
     * array.  Every bit set represents a valid entry in the array.
     */
    LwU32 leakageMask;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[16];

    /*!
     * Array of static information describing POWER_LEAKAGEs.  Has valid indexes
     * corresponding to the set bits in \ref leakageMask.
     */
    LW_GPU_POWER_LEAKAGE_INFO_V1 leakages[LW_GPU_POWER_LEAKAGE_MAX_LEAKAGES_V2];
} LW_GPU_POWER_LEAKAGE_INFO_PARAMS_V2;

#define LW_GPU_POWER_LEAKAGE_INFO_PARAMS_VER_1   MAKE_LWAPI_VERSION(LW_GPU_POWER_LEAKAGE_INFO_PARAMS_V1,1)
#define LW_GPU_POWER_LEAKAGE_INFO_PARAMS_VER_2   MAKE_LWAPI_VERSION(LW_GPU_POWER_LEAKAGE_INFO_PARAMS_V2,1)
#define LW_GPU_POWER_LEAKAGE_INFO_PARAMS_VER     LW_GPU_POWER_LEAKAGE_INFO_PARAMS_VER_2

#define LW_GPU_POWER_LEAKAGE_INFO_PARAMS         LW_GPU_POWER_LEAKAGE_INFO_PARAMS_V2

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_PowerLeakageGetInfo()
//
//! DESCRIPTION: Retrieves information about the POWER_LEAKAGE support on the
//!              GPU.
//!
//!              POWER_LEAKAGE entries are equations which estimate leakage
//!              power on a given power rail.  This function retrieves static
//!              information about the set of POWER_LEAKAGE equations supported
//!              by this GPU for use by other features like POWER_POLICYs.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 295.40
//!
//! \param [in]  hPhysicalGPU  GPU selection
//! \param [out] pLeakageInfo  Structure containing the description of the
//!                   POWER_LEAKAGE support on the GPU.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PowerLeakageGetInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_POWER_LEAKAGE_INFO_PARAMS *pLeakageInfo);

//! \ingroup gpupower
//! @{

/*!
 * The following structures are used in \ref LwAPI_GPU_PowerLeakageGetStatus(),
 * which is now deprecated!
 */

#define LW_GPU_POWER_LEAKAGE_MAX_VOLTAGE_ENTRIES_V1                           32
#define LW_GPU_POWER_LEAKAGE_MAX_VOLTAGE_ENTRIES_V2                           64

/*!
 * Used in \ref LW_GPU_POWER_LEAKAGE_STATUS_V1.  Structure representing the
 * estimated leakage power associated with a given voltage.  This is provided to
 * allow estimating the leakage power under the current conditions (temperature,
 * IDDQ) at a different voltage.
 */
typedef struct
{
    /*!
     * Voltage (uV) key for this entry.
     */
    LwU32 voltageuV;
    /*!
     * Latest leakage power value (mW) for this leakage equation.
     */
    LwU32 pwrLeakagemW;
} LW_GPU_POWER_LEAKAGE_STATUS_VOLTAGE_ENTRY;

/*!
 * Used in \ref LW_GPU_POWER_LEAKAGE_STATUS_PARAMS_V1.  Structure representing
 * the set of leakage power estimates (based on voltage) for the current
 * conditions (temperature, IDDQ, etc.).
 */
typedef struct
{
    /*!
     * Number of voltage entries supported for this POWER_LEAKAGE equation.
     */
    LwU8 numVoltEntries;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[16];

    /*!
     * Array of voltage entries for this POWER_LEAKAGE equation.  Has valid
     * indexes in the range [0, \ref numVoltEntries).
     */
    LW_GPU_POWER_LEAKAGE_STATUS_VOLTAGE_ENTRY
        voltEntries[LW_GPU_POWER_LEAKAGE_MAX_VOLTAGE_ENTRIES_V1];
} LW_GPU_POWER_LEAKAGE_STATUS_V1;

/*!
 * Used in \ref LwAPI_GPU_PowerLeakageGetStatus.  Structure representing the
 * current state of a requested set of POWER_LEAKAGE equations.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32  version;

    /*!
     * Latest temperature used to callwlate leakage power.
     *
     * SIgned FXP 24.8 value.  Units of C.
     */
    LwS32 tj;

    /*!
     * Mask of POWER_LEAKAGE equation entries requested by the client.  Results
     * will be returned in the indexes within \ref leakages corresponding to
     * bits set in this mask.
     */
    LwU32 leakageMask;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[16];

    /*!
     * Array of current state of requested set of POWER_LEAKAGEs.  Has valid
     * indexes corresponding to the set bits in \ref leakageMask.
     */
    LW_GPU_POWER_LEAKAGE_STATUS_V1 leakages[LW_GPU_POWER_LEAKAGE_MAX_LEAKAGES_V1];
} LW_GPU_POWER_LEAKAGE_STATUS_PARAMS_V1;

/*!
 * Used in \ref LW_GPU_POWER_LEAKAGE_STATUS_PARAMS_V2.  Structure representing
 * the set of leakage power estimates (based on voltage) for the current
 * conditions (temperature, IDDQ, etc.).
 */
typedef struct
{
    /*!
     * Number of voltage entries supported for this POWER_LEAKAGE equation.
     */
    LwU8 numVoltEntries;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[16];

    /*!
     * Array of voltage entries for this POWER_LEAKAGE equation.  Has valid
     * indexes in the range [0, \ref numVoltEntries).
     */
    LW_GPU_POWER_LEAKAGE_STATUS_VOLTAGE_ENTRY
        voltEntries[LW_GPU_POWER_LEAKAGE_MAX_VOLTAGE_ENTRIES_V2];
} LW_GPU_POWER_LEAKAGE_STATUS_V2;

/*!
 * Used in \ref LwAPI_GPU_PowerLeakageGetStatus.  Structure representing the
 * current state of a requested set of POWER_LEAKAGE equations.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32  version;

    /*!
     * Latest temperature used to callwlate leakage power.
     *
     * SIgned FXP 24.8 value.  Units of C.
     */
    LwS32 tj;

    /*!
     * Mask of POWER_LEAKAGE equation entries requested by the client.  Results
     * will be returned in the indexes within \ref leakages corresponding to
     * bits set in this mask.
     */
    LwU32 leakageMask;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[16];

    /*!
     * Array of current state of requested set of POWER_LEAKAGEs.  Has valid
     * indexes corresponding to the set bits in \ref leakageMask.
     */
    LW_GPU_POWER_LEAKAGE_STATUS_V2 leakages[LW_GPU_POWER_LEAKAGE_MAX_LEAKAGES_V1];
} LW_GPU_POWER_LEAKAGE_STATUS_PARAMS_V2;


#define LW_GPU_POWER_LEAKAGE_STATUS_PARAMS_VER_1   MAKE_LWAPI_VERSION(LW_GPU_POWER_LEAKAGE_STATUS_PARAMS_V1,1)
#define LW_GPU_POWER_LEAKAGE_STATUS_PARAMS_VER_2   MAKE_LWAPI_VERSION(LW_GPU_POWER_LEAKAGE_STATUS_PARAMS_V2,1)
#define LW_GPU_POWER_LEAKAGE_STATUS_PARAMS_VER     LW_GPU_POWER_LEAKAGE_STATUS_PARAMS_VER_2

#define LW_GPU_POWER_LEAKAGE_STATUS_PARAMS         LW_GPU_POWER_LEAKAGE_STATUS_PARAMS_V2

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_PowerLeakageGetStatus()
//
//! DESCRIPTION: Retrieves the current state for a requested set of
//!              POWER_LEAKAGE equations on the GPU.
//!
//!              This call is now DEPRECATED.  It will only return LWAPI_OK with
//!              no functionality.
//!
//! \deprecated  Do not use this function - it is deprecated in release 295. Instead, use LwAPI_GPU_PowerLeakageGetStatus.
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 295.40
//!
//! \param [in]     hPhysicalGPU    GPU selection
//! \param [in/out] pLeakageStatus  Structure containing the description of the
//!                   POWER_LEAKAGE state of the GPU.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 295. Instead, use LwAPI_GPU_PowerLeakageGetStatus.")
LWAPI_INTERFACE LwAPI_GPU_PowerLeakageGetStatus(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_POWER_LEAKAGE_STATUS_PARAMS *pLeakageStatus);


//! \ingroup gpupower
//! @{

#define LW_GPU_POWER_POLICY_MAX_POLICIES_V1                                   16
#define LW_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1                       16

/*!
 * Enumeration of POWER_POLICY types.  Different types implement the
 * POWER_POLICY functionalty via different mechanisms.  Also, specifies how to
 * interpret the policy type data union.
 */
typedef enum
{
    LW_GPU_POWER_POLICY_TYPE_TOTAL_GPU = 0x00000000,
    LW_GPU_POWER_POLICY_TYPE_WORKLOAD,
    LW_GPU_POWER_POLICY_TYPE_BANG_BANG_VF,
    LW_GPU_POWER_POLICY_TYPE_PROP_LIMIT,
    LW_GPU_POWER_POLICY_TYPE_HW_THRESHOLD,
    LW_GPU_POWER_POLICY_TYPE_MARCH_N,
    /*!
     * This class is deprecated, but kept for backwards compatibility.
     */
    LW_GPU_POWER_POLICY_TYPE_MARCH_N_BA00,
    LW_GPU_POWER_POLICY_TYPE_MARCH_VF,
    /*!
     * This class is deprecated, but kept for backwards compatibility.
     */
    LW_GPU_POWER_POLICY_TYPE_MARCH_VF_BA00,
    LW_GPU_POWER_POLICY_TYPE_VIOLATION_CONTROL,
    LW_GPU_POWER_POLICY_TYPE_BALANCE,
    LW_GPU_POWER_POLICY_TYPE_GEMINI,
    /*!
     * The following are virtual Power Policy classes/types.  They are interface
     * types which other Power Policy classes will implement.
     */
    LW_GPU_POWER_POLICY_TYPE_MARCH_BA00 = 0xFFFFFFFA,
    /*!
     * This class is deprecated, but kept for backwards compatibility.
     */
    LW_GPU_POWER_POLICY_TYPE_MARCH      = 0xFFFFFFFB,
    LW_GPU_POWER_POLICY_TYPE_NDIV       = 0xFFFFFFFC,
    LW_GPU_POWER_POLICY_TYPE_DOMGRP     = 0xFFFFFFFD,
    LW_GPU_POWER_POLICY_TYPE_LIMIT      = 0xFFFFFFFE,
    /*!
     * Unknown/unsupported type via LWAPI.  Should always be last.
     */
    LW_GPU_POWER_POLICY_TYPE_UNKNOWN = 0xFFFFFFFF,
} LW_GPU_POWER_POLICY_TYPE;

/*!
 * Enumeration of units which a POWER_POLICY uses.  This specifies the units to
 * apply to both the \ref value and \ref limit fields.
 */
typedef enum
{
    LW_GPU_POWER_POLICY_LIMIT_UNIT_POWER_MW = 0x00000000,
    LW_GPU_POWER_POLICY_LIMIT_UNIT_LWRRENT_MA,
} LW_GPU_POWER_POLICY_LIMIT_UNIT;

/*!
 * Enumeration of POWER_POLICY_RELATIONSHIP types.  Different
 * POWER_POLICY_RELATIONSHIP types use different functionality to implement the
 * interface by which to set limits and retrieve values.  This enumeration also
 * specifies how to interpret the the channel relationship type data union.
 */
typedef enum
{
    LW_GPU_POWER_POLICY_RELATIONSHIP_TYPE_WEIGHT  = 0x00000000,
    LW_GPU_POWER_POLICY_RELATIONSHIP_TYPE_BALANCE,
    LW_GPU_POWER_POLICY_RELATIONSHIP_TYPE_UNKNOWN = 0xFFFFFFFF,
} LW_GPU_POWER_POLICY_RELATIONSHIP_TYPE;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_BANG_BANG_VF_INFO, \ref
 * LW_GPU_POWER_POLICY_WORKLOAD_INFO, \ref LW_GPU_POWER_POLICY_INFO_V1.
 * Structure of static information specific to the DOMGRP POWER_POLICY.  This
 * POWER_POLICY is a virtual/super class, which is extended/implemented by other
 * POWER_POLICY clases (e.g. WORKLOAD and BANG_BANG_VF).
 */
typedef struct _LW_GPU_POWER_POLICY_DOMGRP_INFO
{
    /*!
     * A boolean flag to indicate that the output Domain Group limits computed
     * by this POWER_POLICY should be floored to the 3D Boost VPstate (commonly
     * referred to as "Base Clock" in the GPU Boost/SmartPower/PWR 2.0
     * documentation).
     */
    LwU8 b3DBoostVpstateFloor;
    
    /*!
     * Cap the system below the "Inflection vpstate index" when the current
     * limit is smaller than this "Inflection limit". This inflection limit can
     * help improve some pstate thrashing issue when the power limit is reduced
     * into the "battery" or certain lower pstate range.
     */
    LwU32 limitInflection;
} LW_GPU_POWER_POLICY_DOMGRP_INFO;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_MARCH_N_INFO, \ref
 * LW_GPU_POWER_POLICY_MARCH_N_BA00_INFO, \ref LW_GPU_POWER_POLICY_INFO_V1.
 *
 * Structure of static information specific to the NDIV POWER_POLICY.  This
 * POWER_POLICY is a virtual/super class, which is extended/implemented by other
 * POWER_POLICY clases (e.g. MARCH_N).
 */
typedef struct _LW_GPU_POWER_POLICY_NDIV_INFO
{
    /*!
     * Maximum NDIV value for this policy.
     */
    LwU8       ndivCoeffMax;
} LW_GPU_POWER_POLICY_NDIV_INFO;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_INFO_V1.  Structure of static information
 * specific to the BANG_BANG_VF POWER_POLICY.  This POWER_POLICY implements a
 * bang-bang step controller along the VF lwrve.
 */
typedef struct _LW_GPU_POWER_POLICY_BANG_BANG_VF_INFO
{
    /*!
     * Must always be first in structure!
     */
    LW_GPU_POWER_POLICY_DOMGRP_INFO domGrp;

    /*!
     * Ratio of the limit (\ref LW_GPU_POWER_POLICY_STATUS_V1::limitLwrr) below
     * which the controlled value (LW_GPU_POWER_POLICY_STATUS_V1::valueLwrr)
     * must fall in order for the Bang-Bang algorithm to initiate the uncap
     * action.
     *
     * Unitless Unsigned FXP 4.12.
     */
    LwU16 uncapLimitRatio;
} LW_GPU_POWER_POLICY_BANG_BANG_VF_INFO;

/*!
 * Enumerations/macros defining the different types of hysteresis values a
 * PWR_POLICY_MARCH may use.
 *
 * _RATIO - The hysteresis amount is a ratio of the limit value:
 *      uncapLimit = limitValue * ratio.
 *
 * _STATIC_VALUE - The hysteresis amount is a static value which is subtracted
 *      from the limit value:
 *      uncapLimit = limitValue - staticValue
 */
#define LW_GPU_POWER_POLICY_MARCH_HYSTERESIS_TYPE_RATIO             0x00
#define LW_GPU_POWER_POLICY_MARCH_HYSTERESIS_TYPE_STATIC_VALUE      0x01

/*!
 * Union of type-specific hysteresis values.
 */
typedef union _LW_GPU_POWER_POLICY_MARCH_HYSTERESIS_DATA
{
    /*!
     * Ratio value corresponding to
     * LW_GPU_POWER_POLICY_MARCH_HYSTERESIS_TYPE_RATIO.
     */
    LwU16 ratio;
    /*!
     * Static value corresponding to
     * LW_GPU_POWER_POLICY_MARCH_HYSTERESIS_TYPE_STATIC_VALUE.
     */
    LwU16 staticValue;
} LW_GPU_POWER_POLICY_MARCH_HYSTERESIS_DATA;

/*!
 * Structure representing the hysteresis value for a PWR_POLICY_MARCH object.
 */
typedef struct _LW_GPU_POWER_POLICY_MARCH_HYSTERESIS
{
    /*!
     * @ref LW_GPU_POWER_POLICY_MARCH_HYSTERESIS_TYPE_<XYZ>
     */
    LwU8 type;
    /*!
     * Union of type specific data.  Interpreted by @ref type.
     */
    LW_GPU_POWER_POLICY_MARCH_HYSTERESIS_DATA data;
} LW_GPU_POWER_POLICY_MARCH_HYSTERESIS;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_MARCH_BA00_INFO.
 *
 * The GK10X BA v0.0 sensor has a lot of error/noise and thus does not have a
 * very reliable/accurate mapping between BA units and power.
 *
 * The best we can do is train the data for the worst-case workload, so that we
 * can guarantee for all workloads <= worst-case power will be <= the power
 * limit.
 *
 * The training fit is planar equation taking the following indepednent
 * variables:
 *     BA - Block Activity values in raw BA units.
 *     CF - dynamic power normalized for voltage - i.e. P_{D} / V^2 = C * V^2 *
 *         F / V^2 = C * F.  In units of A / V.
 *     F - Target frequency (MHz) as callwlated by the RM.
 *
 *     coeffBA * BA + coeffCF * CF + coeffF * F = intercept
 *
 *     The coefficients and intercept are all signed FXP20.12 values.
 */
typedef struct _LW_GPU_POWER_POLICY_MARCH_BA00_PLANE_FIT
{
    /*!
     * Coefficient for BA independent variable.  Signed FXP20.12.
     */
    LwS32 coeffBA;
    /*!
     * Coefficient for CF independent variable.  Signed FXP20.12.
     */
    LwS32 coeffCF;
    /*!
     * Coefficient for F independent variable.  Signed FXP20.12.
     */
    LwS32 coeffF;
    /*!
     * Intercept planar equation.  Signed FXP20.12.
     */
    LwS32 intercept;
} LW_GPU_POWER_POLICY_MARCH_BA00_PLANE_FIT;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_MARCH_INFO.
 *
 * Structure of static information specific to the MARCH BA00 POWER_POLICY
 * interface.  This interface provides marching functionality with correction
 * for GK10X BA v0.0 inaclwracy.
 */
typedef struct _LW_GPU_POWER_POLICY_MARCH_BA00_INFO
{
    /*!
     * Index of PWR_LEAKAGE equation which will be used to estimate the leakage
     * power and compute the dynamic power component:
     *
     *     dynamic = total - leakage
     */
    LwU8 leakageIdx;
    /*!
     * Equation defining the planar fit for BA and power.
     */
    LW_GPU_POWER_POLICY_MARCH_BA00_PLANE_FIT planeFit;
} LW_GPU_POWER_POLICY_MARCH_BA00_INFO;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_MARCH_N_INFO, \ref
 * LW_GPU_POWER_POLICY_MARCH_N_BA00_INFO, \ref
 * LW_GPU_POWER_POLICY_MARCH_VF_INFO, \ref
 * LW_GPU_POWER_POLICY_MARCH_VF_BA00_INFO.
 *
 * Structure of static
 * information specific to the MARCH POWER_POLICY interface.  This interface
 * provides marching functionality by which it issues actions to cap or uncap
 * corresponding to a policy's value and limit.
 */
typedef struct _LW_GPU_POWER_POLICY_MARCH_INFO
{
    /*!
     * \ref LW_GPU_POWER_POLICY_TYPE
     */
    LW_GPU_POWER_POLICY_TYPE type;
    /*!
     * Number of steps by which the implementing class should respond to various
     * actions.
     */
    LwU8 stepSize;
    /*!
     * Hysteresis amount for uncapping.
     */
    LW_GPU_POWER_POLICY_MARCH_HYSTERESIS hysteresis;

    /*!
     * Union of type-specific data.
     */
    union
    {
        LW_GPU_POWER_POLICY_MARCH_BA00_INFO ba00;
    } data;
} LW_GPU_POWER_POLICY_MARCH_INFO;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_INFO_V1.
 *
 * Structure of static information
 * specific to the MARCH_N POWER_POLICY.  This POWER_POLICY will adjust the NDIV
 * GPCCLK coefficient per the MARCH POWER_POLICY interface corresponding to the
 * policy's value and limit.
 */
typedef struct _LW_GPU_POWER_POLICY_MARCH_N_INFO
{
    /*!
     * @copydoc RM_PMU_PMGR_PWR_POLICY_NDIV
     *
     * Must always be first in structure!
     */
    LW_GPU_POWER_POLICY_NDIV_INFO  ndiv;
    /*!
     * @copydoc RM_PMU_PMGR_PWR_POLICY_MARCH
     *
     * The common PWR_POLICY_MARCH initialization data.  This data does not need
     * to be at any fixed location, it is handled elsewhere.
     */
    LW_GPU_POWER_POLICY_MARCH_INFO march;
} LW_GPU_POWER_POLICY_MARCH_N_INFO;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_INFO_V1.
 *
 * This structure is deprecated, but kept for backward-compatibility.
 */
typedef LW_GPU_POWER_POLICY_MARCH_N_INFO
    LW_GPU_POWER_POLICY_MARCH_N_BA00_INFO;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_INFO_V1.
 *
 * Structure of static information
 * specific to the _MARCH_VF POWER_POLICY.  This POWER_POLICY will adjust the NDIV
 * GPCCLK coefficient per the MARCH POWER_POLICY interface corresponding to the
 * policy's value and limit.
 */
typedef struct _LW_GPU_POWER_POLICY_MARCH_VF_INFO
{
    /*!
     * @copydoc RM_PMU_PMGR_PWR_POLICY_NDIV
     *
     * Must always be first in structure!
     */
    LW_GPU_POWER_POLICY_DOMGRP_INFO domGrp;
    /*!
     * @copydoc RM_PMU_PMGR_PWR_POLICY_MARCH
     *
     * The common PWR_POLICY_MARCH initialization data.  This data does not need
     * to be at any fixed location, it is handled elsewhere.
     */
    LW_GPU_POWER_POLICY_MARCH_INFO  march;
} LW_GPU_POWER_POLICY_MARCH_VF_INFO;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_INFO_V1.
 *
 * This structure is deprecated, but kept for backward-compatibility.
 */
typedef LW_GPU_POWER_POLICY_MARCH_VF_INFO
    LW_GPU_POWER_POLICY_MARCH_VF_BA00_INFO;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_INFO_V1.  Structure of static information
 * specific to the PROP_LIMIT POWER_POLICY.  This POWER_POLICY will update the
 * limits of all POWER_POLICYs corresponding to the specified
 * POWER_POLICY_RELATIONSHIPs by the proportion of this policy's value and
 * limit.
 */
typedef struct _LW_GPU_POWER_POLICY_PROP_LIMIT_INFO
{
    /*!
     * Index of first POWER_POLICY_RELATIONSHIP in the Power Policy Table.  This
     * PWR_POLICY_PROP_LIMIT will adjust the limits of all POWER_POLICYs
     * corresponding to the POWER_POLICY_RELATIONSHIPs in the range
     * [policyRelIdxFirst, \ref policyRelIdxLast].
     */
    LwU8 policyRelIdxFirst;
    /*!
     * Index of last POWER_POLICY_RELATIONSHIP in the Power Policy Table.  This
     * PWR_POLICY_PROP_LIMIT will adjust the limits of all POWER_POLICYs
     * corresponding to the POWER_POLICY_RELATIONSHIPs in the range
     * [\ref policyRelIdxFirst, policyRelIdxLast].
     */
    LwU8 policyRelIdxLast;
    /*!
     * Boolean flag indicating whether "dummy" operation is desired for this
     * PWR_POLICY_PROP_LIMIT object.  When "dummy" operation is engaged, the
     * PWR_POLICY_PROP_LIMIT object will compute the desired limit requests for
     * all referenced (via PWR_POLICY_RELATIONSHIPs) PWR_POLICY objects, but
     * will only store them internally and not issue the requests.
     *
     * This functionality is useful for IRB the PWR_POLICY_PROP_LIMIT is
     * controlling a single phase of LWVDD, such that any limit can be enforced
     * entirely via IRB by shifting the phase away -
     * i.e. even a limit of 0 can be satisfied.
     */
    LwU8 bDummy;
} LW_GPU_POWER_POLICY_PROP_LIMIT_INFO;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_INFO_V1.  Structure of static information
 * specific to the TOTAL_GPU POWER_POLICY.
 */
typedef struct _LW_GPU_POWER_POLICY_TOTAL_GPU_INFO
{
    /*!
     * Power Policy Table Relationship index corresponding to the FB
       POWER_POLICY to update for this Total GPU Power Policy.
     */
    LwU8  fbPolicyRelIdx;
    /*!
     * Power Policy Table Relationship index corresponding to the Core
       POWER_POLICY to update for this Total GPU Power Policy.
     */
    LwU8  corePolicyRelIdx;
    /*!
     * Static value (in specified units) to subtract out of the total available
     * limit before assigning the remainder to Core and FB.
     */
    LwU32 staticValue;
    /*!
     * Cap the system below the "Inflection vpstate index" when the current
     * limit is smaller than this "Inflection limit". This inflection limit can
     * help improve some pstate thrashing issue when the power limit is reduced
     * into the "battery" or certain lower pstate range.
     */
    LwU32 limitInflection;
    /*!
     * Boolean indicating that the adjustment behavior is enabled.
     */
    LwU8  bAdjEnabled;
    /*!
     * Index of the first Power Policy Relationship in the Power Policy Table,
     * specifying the set of PWR_POLICY objects to adjust as this object's limit
     * is changed by the user.  The set is specified as the range
     * [adjRelIdxFirst, @ref adjRelIdxLast].
     */
    LwU8  adjRelIdxFirst;
    /*!
     * Index of the last Power Policy Relationship in the Power Policy Table,
     * specifying the set of PWR_POLICY objects to adjust as this object's limit
     * is changed by the user.  The set is specified as the range
     * [@ref adjRelIdxFirst, adjRelIdxLast].
     */
    LwU8  adjRelIdxLast;
} LW_GPU_POWER_POLICY_TOTAL_GPU_INFO;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_INFO_V1.  Structure of static information
 * specific to the WORKLOAD POWER_POLICY.
 */
typedef struct _LW_GPU_POWER_POLICY_WORKLOAD_INFO
{
    /*!
     * Must always be first in structure!
     */
    LW_GPU_POWER_POLICY_DOMGRP_INFO domGrp;

    /*!
     * Index of leakage equation in Power Leakage Table.
     */
    LwU8   leakageIdx;
    /*!
     * Size of the workload median filter.
     */
    LwU8   medianFilterSize;
} LW_GPU_POWER_POLICY_WORKLOAD_INFO;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_INFO_V2.  Structure of static information
 * specific to the HW_THRESHOLD POWER_POLICY.
 */
typedef struct _LW_GPU_POWER_POLICY_HW_THRESHOLD_INFO
{
    /*!
     * HW Threshold index. The Theshold Index is a PWR_DEVICE-specific enum for
     * different threshold features in a given PWR_DEVICE. The definition of
     * each PWR_DEVICE's supported threshold indexes can be found in Power
     * Sensors Table Spec.
     */
    LwU8        thresholdIdx;
    /*!
     * Low HW Threshold index. The Low Threshold Index is a PWR_DEVICE-specific
     * enum for threshold holding either low limit or hysteresis value. It is
     * used when LW_GPU_POWER_POLICY_HW_THRESHOLD_INFO
     * ::isUsingLowThreshold is set to '1'. The definition of each PWR_DEVICE's
     * supported threshold indexes can be found in Power Sensors Table Spec.
     */
    LwU8        lowThresholdIdx;
    /*!
     * If set to '1' then low threshold data should be used and if set to '0'
     * then low threshold data should not be used. Supported only on
     * selected PWR_DEVICEs.
     */
    LwU8        isUsingLowThreshold;
    /*!
     * Value of low threshold relative to threshold limit. It is used when
     * LW2080_CTRL_PMGR_PWR_POLICY_INFO_DATA_HW_THRESHOLD::bUseLowThreshold is
     * set to LW_TRUE.
     */
    LwU16       lowThresholdValue;
} LW_GPU_POWER_POLICY_HW_THRESHOLD_INFO;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_INFO_V2.  Structure of static information
 * specific to the VIOLATION_CONTROL POWER_POLICY.
 */
typedef struct _LW_GPU_POWER_POLICY_VIOLATION_CONTROL_INFO
{
    /*!
     * HW_THRESHOLD specific data.
     */
    LW_GPU_POWER_POLICY_HW_THRESHOLD_INFO   hwThreshold;
    /*!
     * Limit Drop Rate. Once violation rate goes beyond this rate, VC will
     * try to drop target power policy's power limit.
     */
    LwU32   limitDropRate;
    /*!
     * Limit Raise Rate. Once violation rate goes below this rate, VC will
     * try to raise target power policy's power limit.
     */
    LwU32   limitRaiseRate;
    /*!
     * Limit Drop Value. The power value in milli-Watts that VC will drop
     * each time.
     */
    LwU32   limitDropValuemW;
    /*!
     * Limit Raise Value. The power value in milli-Watts that VC will raise
     * each time.
     */
    LwU32   limitRaiseValuemW;
    /*!
     * Policy Relationship table index. This index points to the target policy
     * VC is trying to control.
     */
    LwU8    policyRelIdx;
} LW_GPU_POWER_POLICY_VIOLATION_CONTROL_INFO;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_INFO_V2.  Structure of static information
 * specific to the BALANCE POWER_POLICY.
 */
typedef struct _LW_GPU_POWER_POLICY_BALANCE_INFO
{
    /*!
     * Index of first Power Policy Relationship object for this class.
     * The classes which extend this Virtual class will run the power balancing
     * algorithm on all controllers specified by @ref PWR_POLICY_RELATIONSHIP
     * objects in the range (@ref policyRelIdxFirst, @ref policyRelIdxLast)
     */
    LwU8          policyRelIdxFirst;

    /*!
     * Index of last Power Policy Relationship for this class.
     * The classes which extend this Virtual class will run the power balancing
     * algorithm on all controllers specified by @ref PWR_POLICY_RELATIONSHIP
     * objects in the range (@ref policyRelIdxFirst, @ref policyRelIdxLast)
     */
    LwU8          policyRelIdxLast;
} LW_GPU_POWER_POLICY_BALANCE_INFO;

/*!
 * Enumeration/handle for which GPU a PWR_POLICY_GEMINI class represents in the
 * PWR_GEMINI synchronized balancing algorithm.
 */
typedef enum
{
    /*!
     * The SLAVE policy does not specify the control parameters in
     * the VBIOS.  In the PWR_GEMINI algorithm, this is policy which is
     * associated with the negative polarity of the limitDelta.
     *
     * Otherwise, the MASTER and SLAVE are functionally equivalent.
     */
    LW_GPU_POWER_POLICY_GEMINI_GPU_SLAVE = 0x0,
    /*!
     * The MASTER policy is the one which specifies the control parameters in
     * the VBIOS.  In the PWR_GEMINI algorithm, this is policy which is
     * associated with the positive polarity of the limitDelta.
     *
     * Otherwise, the MASTER and SLAVE are functionally equivalent.
     */
    LW_GPU_POWER_POLICY_GEMINI_GPU_MASTER,
    /*!
     * Must always be last.
     */
    LW_GPU_POWER_POLICY_GEMINI_MAX_GPUS,
} LW_GPU_POWER_POLICY_GEMINI_GPU;

/*!
 * Structure representing the Gemini SLI Balancing parameters, populated from
 * the VBIOS in a GEMINI_MASTER class.  However, they are common to both
 * master and slave.
 */
typedef struct
{
    /*!
     * Sampling polling period (ms).
     */
    LwU16 samplePeriodms;
    /*!
     * Step size to use when shifting the deltas from one policy to another.  In
     * limit units (i.e. mW or mA).
     */
    LwU32 deltaStepSize;
    /*!
     * Absolute value maximum possible delta.  The maximum amount of power which
     * can be shifted from one GPU to another.
     */
    LwU32 deltaMax;
    /*!
     * Maximum allowed difference of the respective limits from the respective
     * values of the balanced PWR_POLICYs associated with a PWR_POLICY_GEMINI
     * for the PWR_POLICY_GEMINI object to be considered for balancing.
     *
     * This feature prevents the PWR_GEMINI algorithm from making a balancing
     * action which would not have any impact on the clocks - i.e. the none of
     * the balanced PWR_POLICYs are constraining the clocks, so giving them more
     * power won't increase performance.
     */
    LwU32 diffMax;
} LW_GPU_POWER_POLICY_GEMINI_CONTROLLER_PARAMS;

/*!
 * Structure representing static informtion of @ref PWR_GEMINI.  This is the
 * master controller which is associated with a pair of @ref PWR_POLICY_GEMINI
 * objects and implements the alwtal Gemini synchronized power balancing
 * algorithm.
 */
typedef struct
{
    /*!
     * Index of this object within the OBJGPUMGR::pwrGemini PMGR_DEVICE_GROUP.
     */
    LwU8  geminiIdx;

    /*!
     * The OBJGPU::boardId for this Gemini SLI balancing algorithm.  Unique
     * identifier for systems with multiple Gemini balancing algorithms.
     */
    LwU32 boardId;

    /*!
     * Control parameters for this Gemini SLI balancing algorithm.
     */
    LW_GPU_POWER_POLICY_GEMINI_CONTROLLER_PARAMS params;
} LW_GPU_POWER_POLICY_GEMINI_INFO_CONTROLLER;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_INFO_V2.  Structure of static information
 * specific to the GEMINI POWER_POLICY.
 */
typedef struct _LW_GPU_POWER_POLICY_GEMINI_INFO
{
    /*!
     * Handle for which GPU is this PWR_POLICY_GEMINI class in the
     * PWR_GEMINI synchronized balancing algorithm.
     */
    LW_GPU_POWER_POLICY_GEMINI_GPU gpu;

    /*!
     * Index of first Power Policy Relationship object for this class.
     * The classes which extend this Virtual class will run the power balancing
     * algorithm on all controllers specified by @ref PWR_POLICY_RELATIONSHIP
     * objects in the range (@ref policyRelIdxFirst, @ref policyRelIdxLast)
     */
    LwU8          policyRelIdxFirst;

    /*!
     * Index of last Power Policy Relationship for this class.
     * The classes which extend this Virtual class will run the power balancing
     * algorithm on all controllers specified by @ref PWR_POLICY_RELATIONSHIP
     * objects in the range (@ref policyRelIdxFirst, @ref policyRelIdxLast)
     */
    LwU8          policyRelIdxLast;

    /*!
     * Master controller static state.
     */
    LW_GPU_POWER_POLICY_GEMINI_INFO_CONTROLLER controller;
} LW_GPU_POWER_POLICY_GEMINI_INFO;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_INFO_PARAMS_V1.  Structure of static
 * information describing a POWER_POLICY, which specifies a power policy/limit to
 * enforce on the GPU.
 */
typedef struct _LW_GPU_POWER_POLICY_INFO_V1
{
    /*!
     * LW_GPU_POWER_POLICY_TYPE_<xyz>.
     */
    LW_GPU_POWER_POLICY_TYPE type;

    /*!
     * Index into Power Topology Table (POWER_CHANNEL) for input channel.
     */
    LwU8  chIdx;

    /*!
     * Units of limit values.
     */
    LW_GPU_POWER_POLICY_LIMIT_UNIT limitUnit;
    /*!
     * Minimum allowed limit value.
     */
    LwU32 limitMin;
    /*!
     * Rated/default limit value.
     */
    LwU32 limitRated;
    /*!
     * Maximum allowed limit value.
     */
    LwU32 limitMax;

    /*!
     * Reserving 16 bytes of space so can add new types without needing to
     * add a new version.
     */
    LwU8 rsvd[16];

    /*!
     * Type-specific information.  Interpreted by \ref type.
     */
    union
    {
        LW_GPU_POWER_POLICY_DOMGRP_INFO        domGrp;
        LW_GPU_POWER_POLICY_NDIV_INFO          ndiv;
        LW_GPU_POWER_POLICY_BANG_BANG_VF_INFO  bangBangVf;
        LW_GPU_POWER_POLICY_PROP_LIMIT_INFO    propLimit;
        LW_GPU_POWER_POLICY_TOTAL_GPU_INFO     totalGpu;
        LW_GPU_POWER_POLICY_WORKLOAD_INFO      workload;
        LW_GPU_POWER_POLICY_HW_THRESHOLD_INFO  hwThreshold;
        /*!
         * Reserving 16 bytes of space so can add new types without needing to
         * add a new version.
         */
        LwU8 rsvd[16];
    } data;
} LW_GPU_POWER_POLICY_INFO_V1;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_INFO_PARAMS_V1.  Structure of static
 * information describing a POWER_POLICY, which specifies a power policy/limit to
 * enforce on the GPU.
 */
typedef struct _LW_GPU_POWER_POLICY_INFO_V2
{
    /*!
     * LW_GPU_POWER_POLICY_TYPE_<xyz>.
     */
    LW_GPU_POWER_POLICY_TYPE type;

    /*!
     * Index into Power Topology Table (POWER_CHANNEL) for input channel.
     */
    LwU8  chIdx;

    /*!
     * Units of limit values.
     */
    LW_GPU_POWER_POLICY_LIMIT_UNIT limitUnit;
    /*!
     * Minimum allowed limit value.
     */
    LwU32 limitMin;
    /*!
     * Rated/default limit value.
     */
    LwU32 limitRated;
    /*!
     * Maximum allowed limit value.
     */
    LwU32 limitMax;
    /*!
     * Battery allowed limit value.
     */
    LwU32 limitBatt;
    /*!
     * Integral Control: No of past samples, looking at which the
     * control algorithm does an adjustment to the future samples.
     */
    LwU8   pastSampleCount;
    /*!
     * Integral Control: No of future samples to apply the limit adjustment.
     */
    LwU8   nextSampleCount;
    /*!
     * Integral Control: The minimum value of the bounding box for
     * the limit adjustment, a ratio from the current policy limit.
     *   
     * Unitless Unsigned FXP 4.12.
     */
    LwU16  ratioLimitMin;
    /*!
     * Integral Control: The maximum value of the bounding box for 
     * the limit adjustment, a ratio from the current policy limit.
     *
     * Unitless Unsigned FXP 4.12.
     */
    LwU16  ratioLimitMax;

    /*!
     * Reserving 6 bytes of space so can add new types without needing to
     * add a new version.
     */
    LwU8 rsvd[6];

    /*!
     * Type-specific information.  Interpreted by \ref type.
     */
    union
    {
        LW_GPU_POWER_POLICY_DOMGRP_INFO             domGrp;
        LW_GPU_POWER_POLICY_NDIV_INFO               ndiv;
        LW_GPU_POWER_POLICY_BANG_BANG_VF_INFO       bangBangVf;
        LW_GPU_POWER_POLICY_MARCH_N_INFO            marchN;
        LW_GPU_POWER_POLICY_MARCH_N_BA00_INFO       marchNBA00;
        LW_GPU_POWER_POLICY_MARCH_VF_INFO           marchVF;
        LW_GPU_POWER_POLICY_MARCH_VF_BA00_INFO      marchVFBA00;
        LW_GPU_POWER_POLICY_PROP_LIMIT_INFO         propLimit;
        LW_GPU_POWER_POLICY_TOTAL_GPU_INFO          totalGpu;
        LW_GPU_POWER_POLICY_WORKLOAD_INFO           workload;
        LW_GPU_POWER_POLICY_HW_THRESHOLD_INFO       hwThreshold;
        LW_GPU_POWER_POLICY_VIOLATION_CONTROL_INFO  vControl;
        LW_GPU_POWER_POLICY_BALANCE_INFO            balance;
        LW_GPU_POWER_POLICY_GEMINI_INFO             gemini;
        /*!
         * Reserving 48 bytes of space so can add new types without needing to
         * add a new version.
         */
        LwU8 rsvd[48];
    } data;
} LW_GPU_POWER_POLICY_INFO_V2;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_RELATIONSHIP_INFO_V1.  Structure
 * representing a POWER_POLICY_RELATIONSHIP which scales its applied limit value
 * by a specified coefficient/weight.
 */
typedef struct _LW_GPU_POWER_POLICY_RELATIONSHIP_WEIGHT_INFO
{
    /*!
     * Coefficient/weight by which to scale the limit value which the the
     * updating policy wants to apply to the POWER_POLICY corresponding to \ref
     * LW_GPU_POWER_POLICY_RELATIONSHIP_INFO_V1::policyIdx.
     *
     * Unsigned FXP4.12 value.  Unitless.
     */
    LwU16 weight;
} LW_GPU_POWER_POLICY_RELATIONSHIP_WEIGHT_INFO;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_RELATIONSHIP_INFO_V2.  Structure
 * representing a POWER_POLICY_RELATIONSHIP_BALANCE
 */
typedef struct _LW_GPU_POWER_POLICY_RELATIONSHIP_BALANCE_INFO
{
    /*!
     * Index into Power Policy Table. This should point to object of type
     * @ref PWR_POLICY_LIMIT (or class derived thereof)
     *
     * Another index used in conjunction with this is
     * @ref PWR_POLICY_RELATIONSHIP::policyIdx. (and hence this index is
     * secondary policy id)
     *
     * The policies pointed to by these two indexes will be used by a
     * @ref PWR_POLICY_BALANCE object which references instance of this class.
     */
    LwU8                    secPolicyIdx;

    /*!
     * GPIO function for Power Balancing PWM signal.
     */
    LwU32                   gpioFunc;

    /*!
     * PWM Source. @ref RM_PMU_PMGR_PWM_SOURCE
     */
    LwU8                    pwmSource;

    /*!
     * PWM frequency in Hz.
     */
    LwU32                   pwmFreqHz;

    /*!
     * PWM period. This is a value in terms of PWM generator's input-clock ticks.
     * This does not have the units of time.
     */
    LwU32                   pwmPeriod;

    /*!
     * PWM duty cycle at start. Unitless quantity in %.
     * Represented as unsigned FXP 16_16
     */
    LwU32                   pwmDutyCycleInitial;

    /*!
     * PWM duty cycle setp size. Unitless quantity in %.
     * Represented as unsigned FXP 16_16
     */
    LwU32                   pwmDutyCycleStepSize;

    /*!
     * Index into Power Topology Table @ref PWR_CHANNEL
     * The PWR_CHANNEL object at this index is used to estimate the power for the
     * corresponding phase. This estimate will be used by the
     * @ref PWR_POLICY_BALANCE object referenced by @ref PWR_POLICY_RELATIONSHIP::policyIdx.
     *
     * Value of @ref LW2080_CTRL_PMGR_PWR_CHANNEL_INDEX_ILWALID means the estimate
     * is not available and hence this value should not be used.
     */
    LwU8                    phaseEstimateChIdx;
} LW_GPU_POWER_POLICY_RELATIONSHIP_BALANCE_INFO;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_INFO_PARAMS_V1.  Structure representing a
 * POWER_POLICY_RELATIONSHIP - specifying how one policy can update the limit
 * value of another.  POWER_POLICYs which take policy actions by updating the
 * limits of other channels (i.e. implementing LW_GPU_POWER_POLICY_TYPE_LIMIT)
 * use indexes to POWER_POLICY_RELATIONSHIPs to determine which policies to
 * update.
 */
typedef struct _LW_GPU_POWER_POLICY_RELATIONSHIP_INFO_V1
{
    /*!
     * \ref LW_GPU_POWER_POLICY_RELATIONSHIP_TYPE_<xyz>
     */
    LW_GPU_POWER_POLICY_RELATIONSHIP_TYPE type;
    /*!
     * Index of POWER_POLICY to update.
     */
    LwU8 policyIdx;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[16];

    /*!
     * Type-specific information.
     */
    union
    {
        LW_GPU_POWER_POLICY_RELATIONSHIP_WEIGHT_INFO weight;
        /*!
         * Reserving 16 bytes for future use w/o needing to add new structure
         * version.
         */
        LwU8  rsvd[16];
    } data;
} LW_GPU_POWER_POLICY_RELATIONSHIP_INFO_V1;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_INFO_PARAMS_V2.  Structure representing a
 * POWER_POLICY_RELATIONSHIP - specifying how one policy can update the limit
 * value of another.  POWER_POLICYs which take policy actions by updating the
 * limits of other channels (i.e. implementing LW_GPU_POWER_POLICY_TYPE_LIMIT)
 * use indexes to POWER_POLICY_RELATIONSHIPs to determine which policies to
 * update.
 */
typedef struct _LW_GPU_POWER_POLICY_RELATIONSHIP_INFO_V2
{
    /*!
     * \ref LW_GPU_POWER_POLICY_RELATIONSHIP_TYPE_<xyz>
     */
    LW_GPU_POWER_POLICY_RELATIONSHIP_TYPE type;
    /*!
     * Index of POWER_POLICY to update.
     */
    LwU8 policyIdx;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[16];

    /*!
     * Type-specific information.
     */
    union
    {
        LW_GPU_POWER_POLICY_RELATIONSHIP_WEIGHT_INFO  weight;
        LW_GPU_POWER_POLICY_RELATIONSHIP_BALANCE_INFO balance;

        /*!
         * Reserving 48 bytes for future use w/o needing to add new structure
         * version.
         */
        LwU8  rsvd[48];
    } data;
} LW_GPU_POWER_POLICY_RELATIONSHIP_INFO_V2;

/*!
 * Used in \ref LwAPI_GPU_PowerPolicyGetInfo.  Structure representing the static
 * state information associated with the GPU's POWER_POLICY functionality.
 */
typedef struct _LW_GPU_POWER_POLICY_INFO_PARAMS_V1
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32  version;

    /*!
     * Mask of POWER_POLICY entries specified on this GPU.
     */
    LwU32 policyMask;
    /*!
     * Mask of POWER_POLICY_DOMGRP entries which are take policy actions
     * by setting Domain Group PERF_LIMITs.
     */
    LwU32 domGrpPolicyMask;
    /*!
     * Mask of POWER_POLICY_LIMIT entries which take policy actions by
     * requesting new limit values on other PWR_POLICY entries.
     */
    LwU32 limitPolicyMask;
    /*!
     * Mask of POWER_POLICY_RELATIONSHIP entries specified on this GPU.
     */
    LwU32 policyRelMask;

    /*!
     * Power Policy Table index for POWER_POLICY controlling Total Gpu Power
     * (TGP).  This is the hard limit for total GPU power which will always be
     * enforced by the RM power policy functionality.
     */
    LwU8  tgpPolicyIdx;
    /*!
     * Power Policy Table index for POWER_POLICY controlling Room Temperature
     * Power (RTP).  This is the soft limit for GPU power which will be
     * enforced down to the 3D Boost VPstate (aka "Base Clock" in the PWR
     * 2.0/SmartPower/GPU Boost literature).  This policy is not required to be
     * present on all GPUs.
     */
    LwU8  rtpPolicyIdx;

    /*!
     * Reserving 16 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[16];

    /*!
     * Array of POWER_POLICY entries.  Has valid indexes corresponding to the
     * bits set in \ref policyMask.
     */
    LW_GPU_POWER_POLICY_INFO_V1 policies[LW_GPU_POWER_POLICY_MAX_POLICIES_V1];
    /*!
     * Array of POWER_POLICY_RELAIONSHIP entries.  Has valid indexes
     * corresponding to the bits set in \ref policyRelMask.
     */
    LW_GPU_POWER_POLICY_RELATIONSHIP_INFO_V1
        policyRels[LW_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
} LW_GPU_POWER_POLICY_INFO_PARAMS_V1;

/*!
 * Used in \ref LwAPI_GPU_PowerPolicyGetInfo.  Structure representing the static
 * state information associated with the GPU's POWER_POLICY functionality.
 */
typedef struct _LW_GPU_POWER_POLICY_INFO_PARAMS_V2
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32  version;

    /*!
     * Mask of POWER_POLICY entries specified on this GPU.
     */
    LwU32 policyMask;
    /*!
     * Mask of POWER_POLICY_DOMGRP entries which are take policy actions
     * by setting Domain Group PERF_LIMITs.
     */
    LwU32 domGrpPolicyMask;
    /*!
     * Mask of POWER_POLICY_LIMIT entries which take policy actions by
     * requesting new limit values on other PWR_POLICY entries.
     */
    LwU32 limitPolicyMask;
    /*!
     * Mask of POWER_POLICY_RELATIONSHIP entries specified on this GPU.
     */
    LwU32 policyRelMask;

    /*!
     * Power Policy Table index for POWER_POLICY controlling Total Gpu Power
     * (TGP).  This is the hard limit for total GPU power which will always be
     * enforced by the RM power policy functionality.
     */
    LwU8  tgpPolicyIdx;
    /*!
     * Power Policy Table index for POWER_POLICY controlling Room Temperature
     * Power (RTP).  This is the soft limit for GPU power which will be
     * enforced down to the 3D Boost VPstate (aka "Base Clock" in the PWR
     * 2.0/SmartPower/GPU Boost literature).  This policy is not required to be
     * present on all GPUs.
     */
    LwU8  rtpPolicyIdx;

    /*!
     * Reserving 16 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[16];

    /*!
     * Array of POWER_POLICY entries.  Has valid indexes corresponding to the
     * bits set in \ref policyMask.
     */
    LW_GPU_POWER_POLICY_INFO_V2 policies[LW_GPU_POWER_POLICY_MAX_POLICIES_V1];
    /*!
     * Array of POWER_POLICY_RELAIONSHIP entries.  Has valid indexes
     * corresponding to the bits set in \ref policyRelMask.
     */
    LW_GPU_POWER_POLICY_RELATIONSHIP_INFO_V1
        policyRels[LW_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
} LW_GPU_POWER_POLICY_INFO_PARAMS_V2;

/*!
 * Used in \ref LwAPI_GPU_PowerPolicyGetInfo.  Structure representing the static
 * state information associated with the GPU's POWER_POLICY functionality.
 */
typedef struct _LW_GPU_POWER_POLICY_INFO_PARAMS_V3
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32 version;

    /*!
     * Mask of POWER_POLICY entries specified on this GPU.
     */
    LwU32 policyMask;
    /*!
     * Mask of POWER_POLICY_DOMGRP entries which are take policy actions
     * by setting Domain Group PERF_LIMITs.
     */
    LwU32 domGrpPolicyMask;
    /*!
     * Mask of POWER_POLICY_LIMIT entries which take policy actions by
     * requesting new limit values on other PWR_POLICY entries.
     */
    LwU32 limitPolicyMask;

    /*!
     * Mask of POWER_POLICY_RELATIONSHIP entries specified on this GPU.
     */
    LwU32 policyRelMask;

    /*!
     * Power Policy Table index for POWER_POLICY controlling Total Gpu Power
     * (TGP).  This is the hard limit for total GPU power which will always be
     * enforced by the RM power policy functionality.
     */
    LwU8  tgpPolicyIdx;
    /*!
     * Power Policy Table index for POWER_POLICY controlling Room Temperature
     * Power (RTP).  This is the soft limit for GPU power which will be
     * enforced down to the 3D Boost VPstate (aka "Base Clock" in the PWR
     * 2.0/SmartPower/GPU Boost literature).  This policy is not required to be
     * present on all GPUs.
     */
    LwU8  rtpPolicyIdx;

    /*!
     * Mask of POWER_POLICY_BALANCE entries specified on this GPU.
     */
    LwU32 balancePolicyMask;

    /*!
     * Reserving 32 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[32];

    /*!
     * Array of POWER_POLICY entries.  Has valid indexes corresponding to the
     * bits set in \ref policyMask.
     */
    LW_GPU_POWER_POLICY_INFO_V2 policies[LW_GPU_POWER_POLICY_MAX_POLICIES_V1];
    /*!
     * Array of POWER_POLICY_RELAIONSHIP entries.  Has valid indexes
     * corresponding to the bits set in \ref policyRelMask.
     */
    LW_GPU_POWER_POLICY_RELATIONSHIP_INFO_V2
        policyRels[LW_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
} LW_GPU_POWER_POLICY_INFO_PARAMS_V3;

#define LW_GPU_POWER_POLICY_INFO_PARAMS_VER_1   MAKE_LWAPI_VERSION(LW_GPU_POWER_POLICY_INFO_PARAMS_V1,1)
#define LW_GPU_POWER_POLICY_INFO_PARAMS_VER_2   MAKE_LWAPI_VERSION(LW_GPU_POWER_POLICY_INFO_PARAMS_V2,1)
#define LW_GPU_POWER_POLICY_INFO_PARAMS_VER_3   MAKE_LWAPI_VERSION(LW_GPU_POWER_POLICY_INFO_PARAMS_V3,1)
#define LW_GPU_POWER_POLICY_INFO_PARAMS_VER     LW_GPU_POWER_POLICY_INFO_PARAMS_VER_3

#define LW_GPU_POWER_POLICY_INFO_PARAMS         LW_GPU_POWER_POLICY_INFO_PARAMS_V3

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_PowerPolicyGetInfo()
//
//! DESCRIPTION: Retrieves information about the POWER_POLICY support on the
//!              GPU.
//!
//!              POWER_POLICY entries are limits (in current or power) which
//!              the RM/PMU POWER_POLICY functionality must try to enforce on
//!              given power rails via a specified mechanism.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 295.40
//!
//! \param [in]  hPhysicalGPU   GPU selection
//! \param [out] pPolicyInfo    Structure containing the description of POWER_POLICYs.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PowerPolicyGetInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_POWER_POLICY_INFO_PARAMS *pPolicyInfo);

//! \ingroup gpupower
//! @{

#define LW_GPU_POWER_POLICY_DOMAIN_GROUPS_LIMTS_MAX_DOMAIN_GROUPS              2
#define LW_GPU_POWER_POLICY_DOMAIN_GROUP_LIMIT_VALUE_DISABLED         0xFFFFFFFF

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_DOMGRP.  The set of domain group
 * limit values (lwrrently only maximums) that a POWER_POLICY_DOMGRP object
 * wishes to apply to the GPU.
 */
typedef struct
{
    /*!
     * Array of domain-group-specific limit values.  This array is indexed by
     * the domain group indexes.
     */
    LwU32 values[LW_GPU_POWER_POLICY_DOMAIN_GROUPS_LIMTS_MAX_DOMAIN_GROUPS];
} LW_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_V1, \ref
 * LW_GPU_POWER_POLICY_STATUS_MARCH_N, \ref
 * LW_GPU_POWER_POLICY_STATUS_MARCH_N_BA00.
 *
 * Structure representing the _NDIV-specific algorithm dyanmic state data.  This
 * is the current state of various algorithm input/output data for the last
 * evaluation of the algorithm.  This information is useful for debugging
 * algorithm behavior.
 */
typedef struct
{
    /*!
     * Current requested max NDIV coefficient value.
     */
    LwU8  ndivCoeff;
} LW_GPU_POWER_POLICY_STATUS_NDIV;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V1, \ref
 * LW_GPU_POWER_POLICY_STATUS_WORKLOAD_V2, \ref LW_GPU_POWER_POLICY_STATUS_V1,
 * \ref LW_GPU_POWER_POLICY_STATUS_V2.
 * Structure of state specific to the DOMGRP virtual/super POWER_POLICY.
 */
typedef struct
{
    /*!
     * The domain group limit values this POWER_POLICY_DOMGRP object wishes to
     * apply to GPU.
     */
    LW_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpLimits;
} LW_GPU_POWER_POLICY_STATUS_DOMGRP_V1;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V2, \ref
 * LW_GPU_POWER_POLICY_STATUS_WORKLOAD_V2, \ref LW_GPU_POWER_POLICY_STATUS_V3.
 * Structure of state specific to the DOMGRP virtual/super POWER_POLICY.
 */
typedef struct
{
    /*!
     * The domain group limit values this POWER_POLICY_DOMGRP object wishes to
     * apply to GPU.
     */
    LW_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpLimits;
    /*!
     * The domain group ceiling values which are determing the highest possible
     * clocks this this POWER_POLICY_DOMGRP object can apply to GPU.
     */
    LW_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpCeiling;

    /*!
     * Reserved space to allow extending super-class without affecting
     * implementing classes.
     */
    LwU8 rsvd[16];
} LW_GPU_POWER_POLICY_STATUS_DOMGRP_V2;

/*!
 * Macros encoding the actions/decisions the POWER_POLICY_BANG_BANG_VF controller
 * may make at each evaluation.
 *
 * _NONE - Current value is acceptable, so do not change the requested clock
 *     amount.
 * _CAP - Current value is above the limit, so VF values must be capped down one
 *     step (if available).
 * _UNCAP - Current value is <= the limit * uncapLimitRatio, so VF values may be
 *     uncaped one step (if available).
 */
#define LW_GPU_POWER_POLICY_BANG_BANG_VF_ACTION_NONE                  0x00000000
#define LW_GPU_POWER_POLICY_BANG_BANG_VF_ACTION_CAP                   0x00000001
#define LW_GPU_POWER_POLICY_BANG_BANG_VF_ACTION_UNCAP                 0x00000002

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_BANG_BANG_VF.  This structure
 * represents (pstate index, VF entry index) set which represents an operational
 * VF point.  This structure is represent both the current/input VF point and
 * the requested/output VF point for the _BANG_BANG_VF Power Policy.
 */
typedef struct
{
    /*!
     * Pstate index.  This is the index of the pstate within the VBIOS Perf
     * Table, not a pstate name/number - e.g. index 0 => P8, index 3 => P0.
     */
    LwU8 pstateIdx;
    /*!
     * VF Entry Index.  This is the index of the VF entry within the VBIOS VF
     * table.
     */
    LwU8 vfIdx;
} LW_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_INDEXES;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_V1.  Structure representing the
 * _BANG_BANG_VF-specific algorithm dyanmic state data.  This is the current
 * state of various algorithm input/output data for the last evaluation of the
 * algorithm.  This information is useful for debugging algorithm behavior.
 */
typedef struct
{
    /*!
     * Must always be first in structure.
     */
    LW_GPU_POWER_POLICY_STATUS_DOMGRP_V1 domGrp;

    /*!
     * Last action taken by the _BANG_BANG_VF algorithm.
     *
     * \ref LW_GPU_POWER_POLICY_BANG_BANG_VF_ACTION_<xyz>.
     */
    LwU8 action;
    /*!
     * Input VF point to the _BANG_BANG_VF algorithm for \ref action.
     */
    LW_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_INDEXES
        input;
    /*!
     * Output VF point of the _BANG_BANG_VF algorithm as decided by the \ref
     * action.
     */
    LW_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_INDEXES
        output;
} LW_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V1;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_V1.  Structure representing the
 * _BANG_BANG_VF-specific algorithm dyanmic state data.  This is the current
 * state of various algorithm input/output data for the last evaluation of the
 * algorithm.  This information is useful for debugging algorithm behavior.
 */
typedef struct
{
    /*!
     * Must always be first in structure.
     */
    LW_GPU_POWER_POLICY_STATUS_DOMGRP_V2 domGrp;

    /*!
     * Last action taken by the _BANG_BANG_VF algorithm.
     *
     * \ref LW_GPU_POWER_POLICY_BANG_BANG_VF_ACTION_<xyz>.
     */
    LwU8 action;
    /*!
     * Input VF point to the _BANG_BANG_VF algorithm for \ref action.
     */
    LW_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_INDEXES
        input;
    /*!
     * Output VF point of the _BANG_BANG_VF algorithm as decided by the \ref
     * action.
     */
    LW_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_INDEXES
        output;
} LW_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V2;

/*!
 * Macros encoding the actions/decisions the PWR_POLICY_MARCH controller
 * may make at each evaluation.
 *
 * _NONE - Current value is acceptable, so do not change the requested state.
 * _CAP - Current value is above the limit, so algorithm must cap down one
 *     step size (if available).
 * _UNCAP - Current value is <= the uncap limit (determined by hysteresis), so
 *     algorithm may uncap by one step size (if available).
 */
#define LW_GPU_POWER_POLICY_MARCH_ACTION_NONE                       0x00
#define LW_GPU_POWER_POLICY_MARCH_ACTION_CAP                        0x01
#define LW_GPU_POWER_POLICY_MARCH_ACTION_UNCAP                      0x02


/*!
 * Used in \ref GPU_POWER_POLICY_STATUS_MARCH.
 *
 * Structure representing _MARCH_BA00-specific algorithm dynamic state data.
 * This is the current state of various algorithm input/output data for the last
 * evaluation of the algorithm.  This information is useful for debugging
 * algorithm behavior.
 */
typedef struct
{
    /*!
     * Voltage value (uV) used for leakage power estimation and dynamic power
     * normalization.  Cached in object to be returned via @ref
     * pwrPolicyMarchQuery_BA00() for debugging.
     */
    LwU32 voltageuV;
    /*!
     * GPC2CLK frequency (MHz) used for BA plane fit.
     */
    LwU32 freqMHz;
    /*!
     * Last computed leakage power (mW) returned from @ref pLeakage.  Cached in
     * object to be returned via @ref pwrPolicyMarchQuery_BA00() for debugging.
     */
    LwU32 pwrLeakagemW;
    /*!
     * Last computed BA limit via @ref pwrPolicyMarchLimitGet_BA00() to be used
     * as marching policy limit.  Cached in object to be returned via @ref
     * pwrPolicyMarchQuery_BA00() for debugging.
     */
    LwU32 limitLwrrBA;
} LW_GPU_POWER_POLICY_STATUS_MARCH_BA00;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_MARCH_N, \ref
 * LW_GPU_POWER_POLICY_STATUS_MARCH_N_BA00, \ref
 * LW_GPU_POWER_POLICY_STATUS_MARCH_VF, \ref
 * LW_GPU_POWER_POLICY_STATUS_MARCH_VF_BA00.
 *
 * Structure representing the _MARCH-specific algorithm dyanmic state
 * data.  This is the current state of various algorithm input/output data for
 * the last evaluation of the algorithm.  This information is useful for
 * debugging algorithm behavior.
 */
typedef struct
{
    /*!
     * \ref LW_GPU_POWER_POLICY_TYPE
     */
    LW_GPU_POWER_POLICY_TYPE type;
    /*!
     * Current uncap limit - as callwlated by output of PWR_POLICY::limitLwrr and
     * PWR_POLICY_MARCH::hysteresis.
     */
    LwU32 uncapLimit;
    /*!
     * Last action taken by the _MARCH algorithm.
     *
     * @ref LW_GPU_POWER_POLICY_MARCH_ACTION_<xyz>
     */
    LwU8  action;

    /*!
     * Union of type-specific data.
     */
    union
    {
        LW_GPU_POWER_POLICY_STATUS_MARCH_BA00 ba00;
    } data;
} LW_GPU_POWER_POLICY_STATUS_MARCH;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_V1.
 *
 * Stucture representing MARCH_N-specific PWR_POLICY dynamic status.  This is
 * the current state of various algorithm input/output data for the last
 * evaluation of the algorithm.  This information is useful for debugging
 * algorithm behavior.
 */
typedef struct
{
    /*!
     * @copydoc LW_GPU_POWER_POLICY_STATUS_NDIV
     *
     * Must always be first in structure!
     */
    LW_GPU_POWER_POLICY_STATUS_NDIV  ndiv;
    /*!
     * Common state of the PWR_POLICY_MARCH algorithm.  Does not need to be at
     * any specific location in the sturcture.
     */
    LW_GPU_POWER_POLICY_STATUS_MARCH march;
} LW_GPU_POWER_POLICY_STATUS_MARCH_N;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_V1.
 *
 * This structure is deprecated, but kept for backward-compatibility.
 */
typedef LW_GPU_POWER_POLICY_STATUS_MARCH_N
    LW_GPU_POWER_POLICY_STATUS_MARCH_N_BA00;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_V1.
 *
 * Stucture representing MARCH_N-specific PWR_POLICY dynamic status.  This is
 * the current state of various algorithm input/output data for the last
 * evaluation of the algorithm.  This information is useful for debugging
 * algorithm behavior.
 */
typedef struct
{
    /*!
     * @copydoc LW_GPU_POWER_POLICY_STATUS_DOMGRP_V1
     *
     * Must always be first in structure!
     */
    LW_GPU_POWER_POLICY_STATUS_DOMGRP_V1 domGrp;
    /*!
     * Common state of the PWR_POLICY_MARCH algorithm.  Does not need to be at
     * any specific location in the sturcture.
     */
    LW_GPU_POWER_POLICY_STATUS_MARCH  march;
} LW_GPU_POWER_POLICY_STATUS_MARCH_VF_V1;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_V1.
 *
 * Stucture representing MARCH_N-specific PWR_POLICY dynamic status.  This is
 * the current state of various algorithm input/output data for the last
 * evaluation of the algorithm.  This information is useful for debugging
 * algorithm behavior.
 */
typedef struct
{
    /*!
     * @copydoc LW_GPU_POWER_POLICY_STATUS_DOMGRP_V2
     *
     * Must always be first in structure!
     */
    LW_GPU_POWER_POLICY_STATUS_DOMGRP_V2 domGrp;
    /*!
     * Common state of the PWR_POLICY_MARCH algorithm.  Does not need to be at
     * any specific location in the sturcture.
     */
    LW_GPU_POWER_POLICY_STATUS_MARCH  march;
} LW_GPU_POWER_POLICY_STATUS_MARCH_VF_V2;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_V1.
 *
 * This structure is deprecated, but kept for backward-compatibility.
 */
typedef LW_GPU_POWER_POLICY_STATUS_MARCH_VF_V1
    LW_GPU_POWER_POLICY_STATUS_MARCH_VF_BA00;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_WORKLOAD.
 *
 * This represents the current GPU state which is passed as input to PMU function
 * _pwrPolicyWorkloadComputeWorkload() to callwlate the current workload/active
 * capacitance (w).
 *
 *     w = (Ptotal - Pleakage) / (V^2 * f)
 */
typedef struct
{
    /*!
     * Estimated leakage power (mW).
     */
    LwU32 pwrLeakagemW;
    /*!
     * Frequency (MHz)
     */
    LwU32 freqMHz;
    /*!
     * Voltage^2 (mV^2).
     */
    LwU32 voltmV2;
} LW_GPU_POWER_POLICY_STATUS_WORKLOAD_WORK_INPUT;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_WORKLOAD.
 *
 * This represents a leakage and voltage combination for which the WORKLOAD
 * algorithrm should compute the highest possible frequency.  This structure is
 * passed as input to PMU function _pwrPolicyWorkloadVfEntryComputeClkMHz().
 *
 * The value returned from the PMU will represent the last callwlation for the
 * highest set of frequencies the WORKLOAD algorithm deems possible for the
 * given workload per PMU function _pwrPolicyWorkloadComputeClkMHz().
 */
typedef struct
{
    /*!
     * The filtered workload/active capacitance (w) which is used to determine
     * the target clocks.
     */
    LwU32 workloadmWperMHzmV2;
    /*!
     * Estimated leakage power (mW).
     */
    LwU32 pwrLeakagemW;
    /*!
     * Frequency (MHz)
     */
    LwU32 freqMaxMHz;
    /*!
     * Voltage^2 (mV^2).
     */
    LwU32 voltmV2;
    /*!
     * The current VF entry being evaluated.  This is purely for debugging, it
     * is not actually used in PMU function
     * _pwrPolicyWorkloadVfEntryComputeClkMHz().
     */
    LwU8  vfEntryIdx;
} LW_GPU_POWER_POLICY_STATUS_WORKLOAD_FREQ_INPUT;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_V1.  Stucture representing
 * WORKLOAD-specific POWER_POLICY dynamic status.
 */
typedef struct
{
    /*!
     * Must always be first in structure.
     */
    LW_GPU_POWER_POLICY_STATUS_DOMGRP_V1           domGrp;
    LW_GPU_POWER_POLICY_STATUS_WORKLOAD_WORK_INPUT work;
    LW_GPU_POWER_POLICY_STATUS_WORKLOAD_FREQ_INPUT freq;
    /*!
     * The current workload value for this iteration which will be fed into the
     * median filter.
     */
    LwU32 workloadmWperMHzmV2;
} LW_GPU_POWER_POLICY_STATUS_WORKLOAD_V1;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_V1.  Stucture representing
 * WORKLOAD-specific POWER_POLICY dynamic status.
 */
typedef struct
{
    /*!
     * Must always be first in structure.
     */
    LW_GPU_POWER_POLICY_STATUS_DOMGRP_V2           domGrp;
    LW_GPU_POWER_POLICY_STATUS_WORKLOAD_WORK_INPUT work;
    LW_GPU_POWER_POLICY_STATUS_WORKLOAD_FREQ_INPUT freq;
    /*!
     * The current workload value for this iteration which will be fed into the
     * median filter.
     */
    LwU32 workloadmWperMHzmV2;
} LW_GPU_POWER_POLICY_STATUS_WORKLOAD_V2;

#define LW_GPU_POWER_POLICY_STATUS_MAX_LIMIT_INPUTS                          0x4

/*!
 * Special POWER_POLICY index for \ref LW_GPU_POWER_POLICY_STATUS_LIMIT_INPUT
 * structure.  This is the policy value specified/desired by the RM PWR code.
 * This entry holds the default/desired value from the Power Policy Table and
 * any user/client-requested tweaks to the POWER_POLICY value.
 */
#define LW_GPU_POWER_POLICY_STATUS_LIMIT_INPUT_POLICY_IDX_RM                0xFF

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_LIMIT_INPUTS.  Structure representing
 * an input/requested POWER_POLICY limit value from other clients (other
 * POWER_POLICYs or the RM).  Each POWER_POLICY object arbitrates between its
 * requested values to apply the lowest value.
 */
typedef struct
{
    /*!
     * POWER_POLICY index for the client which requested this limit value.
     *
     * \note Special value LW_GPU_POWER_POLICY_STATUS_LIMIT_INPUT_POLICY_IDX_RM
     * is used to denote the value requested by the RM.
     */
    LwU8 pwrPolicyIdx;
    /*!
     * Limit value requested by the client.  In units as specified in @ref
     * LW_GPU_POWER_POLICY_INFO_V1::limitUnit.
     */
    LwU32 limitValue;
} LW_GPU_POWER_POLICY_STATUS_LIMIT_INPUT;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_V1.  Structure repesenting the
 * current set of active LW_GPU_POWER_POLICY_STATUS_LIMIT_INPUTs, by which
 * clients can request limit values for a given POWER_POLICY.  The POWER_POLICY
 * will arbitrate between all these entries (picking the lowest value) to
 * determine the current limit value.
 */
typedef struct
{
    /*!
     * Current number of active limits.  Will always be <= \ref
     * LW_GPU_POWER_POLICY_STATUS_MAX_LIMIT_INPUTS.
     */
    LwU8 numInputs;
    /*!
     * Array of LW_GPU_POWER_POLICY_STATUS_LIMIT_INPUT entries.  Has valid
     * indexes in the range of [0, \ref numInputs).
     */
    LW_GPU_POWER_POLICY_STATUS_LIMIT_INPUT
        inputs[LW_GPU_POWER_POLICY_STATUS_MAX_LIMIT_INPUTS];
} LW_GPU_POWER_POLICY_STATUS_LIMIT_INPUTS;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_V1.  Structure repesenting the
 * current set of active LW_GPU_POWER_POLICY_STATUS_LIMIT_INPUTs, by which
 * clients can request limit values for a given POWER_POLICY.  The POWER_POLICY
 * will arbitrate between all these entries (picking the lowest value) to
 * determine the current limit value.
 */
typedef struct _LW_GPU_POWER_POLICY_STATUS_HW_THRESHOLD
{
    /*!
     * violation counter number.
     */
    LwU32       violationCnt;
} LW_GPU_POWER_POLICY_STATUS_HW_THRESHOLD;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_V1.  Structure repesenting the
 * current set of active LW_GPU_POWER_POLICY_STATUS_LIMIT_INPUTs, by which
 * clients can request limit values for a given POWER_POLICY.  The POWER_POLICY
 * will arbitrate between all these entries (picking the lowest value) to
 * determine the current limit value.
 */
typedef struct _LW_GPU_POWER_POLICY_STATUS_VIOLATION_CONTROL
{
    /*!
     * HW_THRESHOLD specific data.
     */
    LW_GPU_POWER_POLICY_STATUS_HW_THRESHOLD hwThreshold;
    /*!
     * violation rate.
     */
    LwU32       violationRate;
    /*!
     * target power limit. Units in (milliwatt).
     */
    LwU32       targetPLimitmW;
} LW_GPU_POWER_POLICY_STATUS_VIOLATION_CONTROL;

/*!
 * Maximum number of PWR_POLICY_RELATIONSHIP_BALANCE objects which a
 * PWR_POLICY_BALANCE object can reference.  This value is used specify the
 * maximum array size possible for sorting buffer.
 */
#define LW_GPU_POWER_POLICY_STATUS_BALANCE_MAX_RELATIONSHIP_ENTRIES            4

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_BALANCE.
 *
 * Structure representing a POWER_POLICY_RELATIONSHIP_BALANCE object's dynamic
   state data within a POWER_POLICY_BALANCE object.
 */
typedef struct _LW_GPU_POWER_POLICY_STATUS_BALANCE_RELATIONSHIP_ENTRY
{
    /*!
     * Index of PWR_POLICY_RELATIONSHIP_BALANCE object corresponding to this entry.
     */
    LwU8  relIdx;
    /*!
     * Lower requested limit from either of the two PWR_POLICY objects to which
     * the corresponding PWR_POLICY_RELATIONSHIP_BALANCE object points.
     */
    LwU32 limitLower;
    /*!
     * Difference between lower and higher limits of the two PWR_POLICY objects
     * to which the corresponding PWR_POLICY_RELATIONSHIP_BALANCE object points.
     */
    LwU32 limitDiff;
} LW_GPU_POWER_POLICY_STATUS_BALANCE_RELATIONSHIP_ENTRY;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_V1.
 */
typedef struct _LW_GPU_POWER_POLICY_STATUS_BALANCE
{
    LW_GPU_POWER_POLICY_STATUS_BALANCE_RELATIONSHIP_ENTRY
        relEntries[LW_GPU_POWER_POLICY_STATUS_BALANCE_MAX_RELATIONSHIP_ENTRIES];
} LW_GPU_POWER_POLICY_STATUS_BALANCE;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_V1.
 */
typedef struct _LW_GPU_POWER_POLICY_STATUS_PROP_LIMIT
{
    /*!
     * Boolean indicating whether this PWR_POLICY_PROP_LIMIT object has been
     * dirtied by the @ref PWR_POLICY_BALANCE algorithm (via @ref
     * PWR_POLICY_RELATIONSHIP_BALANCE) and thus its capping request may be
     * inaclwrate.
     */
    LwU8 bBalanceDirty;
} LW_GPU_POWER_POLICY_STATUS_PROP_LIMIT;

/*!
 * Enumeration of actions the PWR_GEMINI controller can take in an iteration.
 *
 * _TO_SLAVE - One delta step shifted to the SLAVE GPU
 * _NONE - No action
 * _MASTER - One delta step shifted to the MASTER GPU
 */
#define LW_GPU_POWER_POLICY_GEMINI_ACTION_TO_SLAVE                            -1
#define LW_GPU_POWER_POLICY_GEMINI_ACTION_NONE                                 0
#define LW_GPU_POWER_POLICY_GEMINI_ACTION_TO_MASTER                            1

/*!
 * Structure representing the dynamic state of a PWR_POLICY_GEMINI object/GPU
 * within a PWR_GEMINI controller.
 */
typedef struct
{
    /*!
     * The average frequency (kHz) for the previous sampling iteration.
     */
    LwU32 freqAvgkHz;
} LW_GPU_POWER_POLICY_STATUS_GEMINI_CONTROLLER_GPU;

/*!
 * Structure representing the dynamic state of a PWR_GEMINI object.
 */
typedef struct
{
    /*!
     * Balancing action taken during the previous iteration.  Stored here so it
     * can returned via @ref LW2080_CTRL_CMD_PMGR_PWR_POLICY_GET_STATUS for
     * debugging.
     *
     * @ref LW_GPU_POWER_POLICY_GEMINI_ACTION_<xyz>
     */
    LwS8   action;

    /*!
     * Flag indicating whether the PWR_GEMINI algorithm is lwrrently enabled.
     */
    LwU8   bEnable;

    /*!
     * The limit delta value lwrrently shifted to the MASTER gpu.  The SLAVE gpu
     * delta is just this value negated.
     */
    LwS32  limitDelta;

    /*!
     * GPU-specific state.
     */
    LW_GPU_POWER_POLICY_STATUS_GEMINI_CONTROLLER_GPU
        gpus[LW_GPU_POWER_POLICY_GEMINI_MAX_GPUS];
} LW_GPU_POWER_POLICY_STATUS_GEMINI_CONTROLLER;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_V2.
 */
typedef struct _LW_GPU_POWER_POLICY_STATUS_GEMINI
{
    /*!
     * Status of the PWR_GEMINI object associated with this PWR_POLICY_GEMINI
     * object.
     */
    LW_GPU_POWER_POLICY_STATUS_GEMINI_CONTROLLER controller;
} LW_GPU_POWER_POLICY_STATUS_GEMINI;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_PARAMS_V1.  Structure of representing
 * the dynamic state associated with a POWER_POLICY entry.
 */
typedef struct
{
    /*!
     * LW_GPU_POWER_POLICY_TYPE_<xyz>.
     */
    LW_GPU_POWER_POLICY_TYPE type;

    /*!
     * Current limit value this POWER_POLICY object is enforcing.  This is the
     * arbitrated output (lowest) of all the
     * LW_GPU_POWER_POLICY_STATUS_LIMIT_INPUT entries specified in \ref
     * limitInputs.  Will always be within range of [\ref
     * LW_GPU_POWER_POLICY_INFO_V1::limitMin, \ref
     * LW_GPU_POWER_POLICY_INFO_V1::limitMax].
     */
    LwU32  limitLwrr;
    /*!
     * Current value retreived from the monitored POWER_CHANNEL.
     */
    LwU32  valueLwrr;

    /*!
     * Current state of this PWR_POLICY's set of
     * LW_GPU_POWER_POLICY_STATUS_LIMIT_INPUTs.
     */
    LW_GPU_POWER_POLICY_STATUS_LIMIT_INPUTS limitInputs;

    /*!
     * Reserving 16 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[16];

    /*!
     * Type-specific dynamic state.
     */
    union
    {
        LW_GPU_POWER_POLICY_STATUS_DOMGRP_V1            domGrp;
        LW_GPU_POWER_POLICY_STATUS_NDIV                 ndiv;
        LW_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V1      bangBangVf;
        LW_GPU_POWER_POLICY_STATUS_MARCH_N              marchN;
        LW_GPU_POWER_POLICY_STATUS_MARCH_N_BA00         marchNBA00;
        LW_GPU_POWER_POLICY_STATUS_MARCH_VF_V1          marchVF;
        LW_GPU_POWER_POLICY_STATUS_MARCH_VF_BA00        marchVFBA00;
        LW_GPU_POWER_POLICY_STATUS_WORKLOAD_V1          workload;
        LW_GPU_POWER_POLICY_STATUS_HW_THRESHOLD         hwThreshold;
        LW_GPU_POWER_POLICY_STATUS_VIOLATION_CONTROL    vControl;
    } data;
} LW_GPU_POWER_POLICY_STATUS_V1;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_PARAMS_V2. Structure of representing
 * the dynamic state associated with a POWER_POLICY entry.
 */
typedef struct
{
    /*!
     * LW_GPU_POWER_POLICY_TYPE_<xyz>.
     */
    LW_GPU_POWER_POLICY_TYPE type;

    /*!
     * Current limit value this POWER_POLICY object is enforcing.  This is the
     * arbitrated output (lowest) of all the
     * LW_GPU_POWER_POLICY_STATUS_LIMIT_INPUT entries specified in \ref
     * limitInputs.  Will always be within range of [\ref
     * LW_GPU_POWER_POLICY_INFO_V1::limitMin, \ref
     * LW_GPU_POWER_POLICY_INFO_V1::limitMax].
     */
    LwU32  limitLwrr;
    /*!
     * Current value retreived from the monitored POWER_CHANNEL.
     */
    LwU32  valueLwrr;

    /*!
     * Current state of this PWR_POLICY's set of
     * LW_GPU_POWER_POLICY_STATUS_LIMIT_INPUTs.
     */
    LW_GPU_POWER_POLICY_STATUS_LIMIT_INPUTS limitInputs;

    /*!
     * Delta which should be applied to arbitrated output of all limit values.
     * This balancing delta is adjusted via inter-GPU balancing algorithms which
     * are trying to optimize the power distribution to achieve maximal perf for
     * the given power limits.  Those algorithms will be transferring power
     * from one GPU to another behind the back of the user, so we don't want to
     * actually change the specified limit values or report this value back to
     * the user.
     */
    LwS32 limitDelta;

    /*!
     * Reserving 12 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[12];

    /*!
     * Type-specific dynamic state.
     */
    union
    {
        LW_GPU_POWER_POLICY_STATUS_DOMGRP_V1            domGrp;
        LW_GPU_POWER_POLICY_STATUS_NDIV                 ndiv;
        LW_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V1      bangBangVf;
        LW_GPU_POWER_POLICY_STATUS_MARCH_N              marchN;
        LW_GPU_POWER_POLICY_STATUS_MARCH_N_BA00         marchNBA00;
        LW_GPU_POWER_POLICY_STATUS_MARCH_VF_V1          marchVF;
        LW_GPU_POWER_POLICY_STATUS_MARCH_VF_BA00        marchVFBA00;
        LW_GPU_POWER_POLICY_STATUS_WORKLOAD_V1          workload;
        LW_GPU_POWER_POLICY_STATUS_HW_THRESHOLD         hwThreshold;
        LW_GPU_POWER_POLICY_STATUS_VIOLATION_CONTROL    vControl;
        LW_GPU_POWER_POLICY_STATUS_BALANCE              balance;
        LW_GPU_POWER_POLICY_STATUS_PROP_LIMIT           propLimit;
        LW_GPU_POWER_POLICY_STATUS_GEMINI               gemini;

        /*!
         * Reserving 48 bytes of space so can add new types without needing to
         * add a new version.
         */
        LwU8 rsvd[48];
    } data;
} LW_GPU_POWER_POLICY_STATUS_V2;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_PARAMS_V2. Structure of representing
 * the dynamic state associated with a POWER_POLICY entry.
 */
typedef struct
{
    /*!
     * LW_GPU_POWER_POLICY_TYPE_<xyz>.
     */
    LW_GPU_POWER_POLICY_TYPE type;

    /*!
     * Current limit value this POWER_POLICY object is enforcing.  This is the
     * arbitrated output (lowest) of all the
     * LW_GPU_POWER_POLICY_STATUS_LIMIT_INPUT entries specified in \ref
     * limitInputs.  Will always be within range of [\ref
     * LW_GPU_POWER_POLICY_INFO_V1::limitMin, \ref
     * LW_GPU_POWER_POLICY_INFO_V1::limitMax].
     */
    LwU32  limitLwrr;
    /*!
     * Current value retreived from the monitored POWER_CHANNEL.
     */
    LwU32  valueLwrr;

    /*!
     * Current state of this PWR_POLICY's set of
     * LW_GPU_POWER_POLICY_STATUS_LIMIT_INPUTs.
     */
    LW_GPU_POWER_POLICY_STATUS_LIMIT_INPUTS limitInputs;

    /*!
     * Delta which should be applied to arbitrated output of all limit values.
     * This balancing delta is adjusted via inter-GPU balancing algorithms which
     * are trying to optimize the power distribution to achieve maximal perf for
     * the given power limits.  Those algorithms will be transferring power
     * from one GPU to another behind the back of the user, so we don't want to
     * actually change the specified limit values or report this value back to
     * the user.
     */
    LwS32 limitDelta;
    /*!
     * The aclwmulated sum of differences between
     * the current power value and current policy limit.
     */
    LwS32   lwrrRunningDiff;
    /*!
     * The new callwlated power limit for all the future samples.
     */
    LwS32   lwrrIntegralLimit;

    /*!
     * Reserving 4 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[4];

    /*!
     * Type-specific dynamic state.
     */
    union
    {
        LW_GPU_POWER_POLICY_STATUS_DOMGRP_V2            domGrp;
        LW_GPU_POWER_POLICY_STATUS_NDIV                 ndiv;
        LW_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V2      bangBangVf;
        LW_GPU_POWER_POLICY_STATUS_MARCH_N              marchN;
        LW_GPU_POWER_POLICY_STATUS_MARCH_N_BA00         marchNBA00;
        LW_GPU_POWER_POLICY_STATUS_MARCH_VF_V2          marchVF;
        LW_GPU_POWER_POLICY_STATUS_MARCH_VF_BA00        marchVFBA00;
        LW_GPU_POWER_POLICY_STATUS_WORKLOAD_V2          workload;
        LW_GPU_POWER_POLICY_STATUS_HW_THRESHOLD         hwThreshold;
        LW_GPU_POWER_POLICY_STATUS_VIOLATION_CONTROL    vControl;
        LW_GPU_POWER_POLICY_STATUS_BALANCE              balance;
        LW_GPU_POWER_POLICY_STATUS_PROP_LIMIT           propLimit;
        LW_GPU_POWER_POLICY_STATUS_GEMINI               gemini;

       /*!
        * Reserving 48 bytes of space so can add new types without needing to
        * add a new version.
        */
        LwU8 rsvd[48];
    } data;
} LW_GPU_POWER_POLICY_STATUS_V3;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V1.
 *
 * Structure representing a PWR_POLICY_RELATIONSHIP_BALANCE object's dynamic
 * state.
 */
typedef struct _LW_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_PROP_LIMIT
{
    /*!
     * Boolean indicating whether this PWR_POLICY_PROP_LIMIT object has been
     * dirtied by the @ref PWR_POLICY_BALANCE algorithm (via @ref
     * PWR_POLICY_RELATIONSHIP_BALANCE) and thus its capping request may be
     * inaclwrate.
     */
    LwU8  bBalanceDirty;
    /*!
     * The input value (@ref PWR_POLICY::valueLwrr) of the
     * PWR_POLICY_PROP_LIMIT object when evaluation begins.
     */
    LwS32 valueOld;
    /*!
     * The updated input value (@ref PWR_POLICY::valueLwrr) of the
     * PWR_POLICY_PROP_LIMIT object after evaluation completes.
     */
    LwS32 valueNew;
    /*!
     * The requested limit (via @ref PWR_POLICY_RELATIONSHIP) of the
     * PWR_POLICY_PROP_LIMIT object when evaluation begins.
     */
    LwS32 limitRequestOld;
    /*!
     * The updated requested limit (via @ref PWR_POLICY_RELATIONSHIP) of the
     * PWR_POLICY_PROP_LIMIT object after evaluation completes.
     */
    LwS32 limitRequestNew;
} LW_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_PROP_LIMIT;

/*!
 * Macros defining the actions the PWR_POLICY_RELATIONSHIP_BALANCE object took
 * for the most recent iteration.
 *
 * _NONE - No action was taken to shift power.
 * _TO_PRI - Power was shifted to the primary PWR_POLICY_PROP_LIMIT object.
 * _TO_SEC - Power was shifted to the secondary PWR_POLICY_PROP_LIMIT object.
 */
#define LW_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_ACTION_NONE     0x0
#define LW_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_ACTION_TO_PRI   0x1
#define LW_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_ACTION_TO_SEC   0x2

/*!
 * Macros for indexes into @ref
 * LW_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE::propLimits[] array.
 *
 * _PRI - The primary policy index - i.e. PWR_POLICY_RELATIONSHIP::policyIdx
 * _SEC - The secondary policy index - i.e.
 *      PWR_POLICY_RELATIONSHIP_BALANCE::secPolicyIdx.
 */
#define LW_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_PROP_LIMIT_PRI  0x0
#define LW_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_PROP_LIMIT_SEC  0x1
#define LW_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_MAX_PROP_LIMITS 0x2

/*!
 * Used in \ref LW_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V1.
 */
typedef struct _LW_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE
{
    /*!
     * @ref LW2080_CTRL_PMGR_PWR_POLICY_RELATIONSHIP_STATUS_BALANCE_ACTION_<xyz>
     */
    LwS8  action;
    /*!
     * Current PWM percent driven out on the balancing circuit's GPIO.  Unitless
     * UFXP 16.16 value.
     */
    LwU32 pwmPctLwrr;
    /*!
     * Array of structures describing the dynamic state of both
     * PWR_POLICY_PROP_LIMIT objects.
     */
    LW_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_PROP_LIMIT
        propLimits[LW_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_MAX_PROP_LIMITS];
} LW_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_STATUS_PARAMS_V2  Structure of representing
 * the dynamic state associated with a POWER_POLICY_RELATIONSHIP entry.
 */
typedef struct
{
    /*!
     * LW_GPU_POWER_POLICY_RELATIONSHIP_TYPE_<xyz>.
     */
    LW_GPU_POWER_POLICY_RELATIONSHIP_TYPE type;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[16];

    /*!
     * Type-specific dynamic state.
     */
    union
    {
        LW_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE  balance;

        /*!
         * Reserving 48 bytes for future use w/o needing to add new structure
         * version.
         */
        LwU8 rsvd[48];
    } data;
} LW_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V1;

/*!
 * Used in \ref LwAPI_GPU_PowerPolicyGetStatus.  Structure representing the
 * dynamic status information associated with a set of POWER_POLICYs within the
 * GPU's POWER_POLICY functionality.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32  version;

    /*!
     * Mask of POWER_POLICY entries requested by the client.
     */
    LwU32 policyMask;

    /*!
     * The current arbitrated output domain group limit values the PMU
     * POWER_POLICY functionality is applying to the GPU.  The current arbitration
     * algorithm is to apply the minimum values of all PWR_POLICYs.  The RM
     * feeds this value into the PERF PERF_LIMIT infrastructure for clock
     * arbitration.
     */
    LW_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpLimits;

    /*!
     * Reserving 16 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[16];

    /*!
     * Array of POWER_POLICY entries.  Has valid indexes corresponding to
     * the bits set in \ref policyMask.
     */
    LW_GPU_POWER_POLICY_STATUS_V1 policies[LW_GPU_POWER_POLICY_MAX_POLICIES_V1];
} LW_GPU_POWER_POLICY_STATUS_PARAMS_V1;

/*!
 * Used in \ref LwAPI_GPU_PowerPolicyGetStatus.  Structure representing the
 * dynamic status information associated with a set of POWER_POLICYs within the
 * GPU's POWER_POLICY functionality.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32  version;

    /*!
     * Mask of POWER_POLICY entries requested by the client.
     */
    LwU32  policyMask;

    /*!
     * The current arbitrated output domain group limit values the PMU
     * POWER_POLICY functionality is applying to the GPU.  The current arbitration
     * algorithm is to apply the minimum values of all PWR_POLICYs.  The RM
     * feeds this value into the PERF PERF_LIMIT infrastructure for clock
     * arbitration.
     */
    LW_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpLimits;

    /*!
     * Mask of POWER_POLICY_RELATIONSHIP entries specified on this GPU.
     */
    LwU32  policyRelMask;

    /*!
     * Reserving 32 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[32];

    /*!
     * Array of POWER_POLICY entries.  Has valid indexes corresponding to
     * the bits set in \ref policyMask.
     */
    LW_GPU_POWER_POLICY_STATUS_V2 policies[LW_GPU_POWER_POLICY_MAX_POLICIES_V1];

    /*!
     * Array of POWER_POLICY_RELATIONSHIP entries.  Has valid indexes
     * corresponding to the bits set in \ref policyRelMask.
     */
    LW_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V1
        policyRels[LW_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
} LW_GPU_POWER_POLICY_STATUS_PARAMS_V2;

/*!
 * Used in \ref LwAPI_GPU_PowerPolicyGetStatus.  Structure representing the
 * dynamic status information associated with a set of POWER_POLICYs within the
 * GPU's POWER_POLICY functionality.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32  version;

    /*!
     * Mask of POWER_POLICY entries requested by the client.
     */
    LwU32  policyMask;

    /*!
     * The current arbitrated output domain group limit values the PMU
     * POWER_POLICY functionality is applying to the GPU.  The current arbitration
     * algorithm is to apply the minimum values of all PWR_POLICYs.  The RM
     * feeds this value into the PERF PERF_LIMIT infrastructure for clock
     * arbitration.
     */
    LW_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpLimits;

    /*!
     * Mask of POWER_POLICY_RELATIONSHIP entries specified on this GPU.
     */
    LwU32  policyRelMask;

    /*!
     * Reserving 32 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[32];

    /*!
     * Array of POWER_POLICY entries.  Has valid indexes corresponding to
     * the bits set in \ref policyMask.
     */
    LW_GPU_POWER_POLICY_STATUS_V3 policies[LW_GPU_POWER_POLICY_MAX_POLICIES_V1];

    /*!
     * Array of POWER_POLICY_RELATIONSHIP entries.  Has valid indexes
     * corresponding to the bits set in \ref policyRelMask.
     */
    LW_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V1
        policyRels[LW_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
} LW_GPU_POWER_POLICY_STATUS_PARAMS_V3;

#define LW_GPU_POWER_POLICY_STATUS_PARAMS_VER_1   MAKE_LWAPI_VERSION(LW_GPU_POWER_POLICY_STATUS_PARAMS_V1,1)
#define LW_GPU_POWER_POLICY_STATUS_PARAMS_VER_2   MAKE_LWAPI_VERSION(LW_GPU_POWER_POLICY_STATUS_PARAMS_V2,1)
#define LW_GPU_POWER_POLICY_STATUS_PARAMS_VER_3   MAKE_LWAPI_VERSION(LW_GPU_POWER_POLICY_STATUS_PARAMS_V3,1)
#define LW_GPU_POWER_POLICY_STATUS_PARAMS_VER     LW_GPU_POWER_POLICY_STATUS_PARAMS_VER_3

#define LW_GPU_POWER_POLICY_STATUS_PARAMS         LW_GPU_POWER_POLICY_STATUS_PARAMS_V2

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_PowerPolicyGetStatus()
//
//! DESCRIPTION:     Retrieves the current dynamic state of a set of POWER_POLICY
//!                  entries on the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version:  295.40
//!
//! \param [in]      hPhysicalGPU   GPU selection
//! \param [in/out]  pPolicyStatus  Structure containing the state of a set of POWER_POLICYs.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PowerPolicyGetStatus(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_POWER_POLICY_STATUS_PARAMS *pPolicyStatus);




//! \ingroup gpupower
//! @{

/*!
 */
typedef struct
{
    /*!
     * Ratio to by which scale clock changes up.
     *
     * Unsigned FXP 4.12 value.  Unitless.
     */
    LwU16  clkUpScale;
    /*!
     * Ratio to by which scale clock changes down.
     *
     * Unsigned FXP 4.12 value.  Unitless.
     */
    LwU16  clkDownScale;
    /*!
     * Size of the workload median filter.
     *
     * \Note This values has be deprecated in favor of \ref
     * LW_GPU_POWER_POLICY_WORKLOAD_INFO::medianFilterSize.  This value will no
     * longer be populated by \ref LwAPI_GPU_PowerPolicyGetControl() nor will it
     * have any functional impact when provided to \ref
     * LwAPI_GPU_PowerPolicySetControl().
     */
    LwU8   medianFilterSize;
} LW_GPU_POWER_POLICY_WORKLOAD_CONTROL;

/*!
 * Used in \ref LW_GPU_POWER_POLICY_CONTROL_PARAMS_V1.  Structure repsenting the
 * control/policy parameters of a POWER_POLICY entry.
 */
typedef struct
{
    /*!
     * LW_GPU_POWER_POLICY_TYPE_<xyz>.
     */
    LW_GPU_POWER_POLICY_TYPE type;

    /*!
     * Current limit value to enforce as requested by a client.  Must always be
     * within range of [\ref LW_GPU_POWER_POLICY_INFO_V1::limitMin, \ref
     * LW_GPU_POWER_POLICY_INFO_V1::limitMax].
     */
    LwU32  limitLwrr;

    /*!
     * Reserving 16 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[16];

    /*!
     * Type-specific data.
     */
    union
    {
        LW_GPU_POWER_POLICY_WORKLOAD_CONTROL workload;
        /*!
         * Reserving 16 bytes reserved for future use w/o needing to add new structure
         * version.
         */
        LwU8  rsvd[16];
    } data;
} LW_GPU_POWER_POLICY_CONTROL_V1;

/*!
 */
typedef struct
{
    /*!
     * Boolean indicating that the BALANCE relationship's PWM value should be
     * locked to a simulated value, overriding the behavior of the BALANCE
     * relationship controller.
     */
    LwU8  bPwmSim;
    /*!
     * The PWM value (specified as unsigned FXP 16.16) used to simulate.  This
     * value is only applied when @ref bPwmSim == LW_TRUE.
     */
    LwU32 pwmPctSim;
} LW_GPU_POWER_POLICY_RELATIONSHIP_CONTROL_BALANCE;

/*!
 */
typedef struct
{
    /*!
     * LW_GPU_POWER_POLICY_RELATIONSHIP_TYPE_<xyz>.
     */
    LW_GPU_POWER_POLICY_RELATIONSHIP_TYPE type;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[16];

    /*!
     * Type-specific dynamic state.
     */
    union
    {
        LW_GPU_POWER_POLICY_RELATIONSHIP_CONTROL_BALANCE balance;
        /*!
         * Reserving 48 bytes for future use w/o needing to add new structure
         * version.
         */
        LwU8 rsvd[48];
    } data;
} LW_GPU_POWER_POLICY_RELATIONSHIP_CONTROL_V1;

/*!
 * Used in \ref LwAPI_GPU_PowerPolicyGetControl, \ref LwAPI_GPU_PowerPolicySetControl.
 * Structure representing the control/policy parameters associated with a set of
 * POWER_POLICY entries in the GPU's POWER_POLICY power policy functionality.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32  version;

    /*!
     * Mask of POWER_POLICY entries requested by the client.
     */
    LwU32 policyMask;

    /*!
     * Reserving 16 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[16];

    /*!
     * Array of POWER_POLICY entries.  Has valid indexes corresponding to
     * the bits set in \ref policyMask.
     */
    LW_GPU_POWER_POLICY_CONTROL_V1 policies[LW_GPU_POWER_POLICY_MAX_POLICIES_V1];
} LW_GPU_POWER_POLICY_CONTROL_PARAMS_V1;

/*!
 * Used in \ref LwAPI_GPU_PowerPolicyGetControl, \ref LwAPI_GPU_PowerPolicySetControl.
 * Structure representing the control/policy parameters associated with a set of
 * POWER_POLICY entries in the GPU's POWER_POLICY power policy functionality.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32  version;

    /*!
     * Mask of POWER_POLICY entries requested by the client.
     */
    LwU32 policyMask;

    /*!
     * Mask of POWER_POLICY_RELATIONSHIP entries requested by the client.
     */
    LwU32 policyRelMask;

    /*!
     * Reserving 16 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    LwU8  rsvd[16];

    /*!
     * Array of POWER_POLICY entries.  Has valid indexes corresponding to
     * the bits set in \ref policyMask.
     */
    LW_GPU_POWER_POLICY_CONTROL_V1 policies[LW_GPU_POWER_POLICY_MAX_POLICIES_V1];

    /*!
     * Array of POWER_POLICY_RELATIONSHIP entries.  Has valid indexes corresponding to
     * the bits set in \ref policyMask.
     */
    LW_GPU_POWER_POLICY_RELATIONSHIP_CONTROL_V1
        policyRels[LW_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
} LW_GPU_POWER_POLICY_CONTROL_PARAMS_V2;

#define LW_GPU_POWER_POLICY_CONTROL_PARAMS_VER_1   MAKE_LWAPI_VERSION(LW_GPU_POWER_POLICY_CONTROL_PARAMS_V1,1)
#define LW_GPU_POWER_POLICY_CONTROL_PARAMS_VER_2   MAKE_LWAPI_VERSION(LW_GPU_POWER_POLICY_CONTROL_PARAMS_V2,1)
#define LW_GPU_POWER_POLICY_CONTROL_PARAMS_VER     LW_GPU_POWER_POLICY_CONTROL_PARAMS_VER_2

#define LW_GPU_POWER_POLICY_CONTROL_PARAMS         LW_GPU_POWER_POLICY_CONTROL_PARAMS_V2

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_PowerPolicyGetControl()
//
//! DESCRIPTION:     This function retrieves the current control/policy of a set
//!                  of POWER_POLICY entries in the RM/PMU's POWER_POLICY
//!                  functionality.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version:  295.40
//!
//! \param [in]      hPhysicalGPU    GPU selection
//! \param [in/out]  pPolicyControl
//!     Structure containing the current control/policy of a set of
//!     POWER_POLICY entries.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PowerPolicyGetControl(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_POWER_POLICY_CONTROL_PARAMS *pPolicyControl);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_PowerPolicySetControl()
//
//! DESCRIPTION:     This function requests the control/policy of a set
//!                  of POWER_POLICY entries in the RM/PMU's POWER_POLICY
//!                  functionality.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version:  295.40
//!
//! \param [in]      hPhysicalGPU    GPU selection
//! \param [in]      pPolicyControl
//!     Structure containing the requested control/policy of a set of
//!     POWER_POLICY entries.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_ILWALID_USER_PRIVILEGE       - The caller does not have administrative privileges
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PowerPolicySetControl(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_POWER_POLICY_CONTROL_PARAMS *pPolicyControl);



//! \addtogroup gpupower
//! @{

/*!
 * Enumeration of Power Topology Channels.  Unique identifiers for different
 * power topology channels of the GPU.
 */
typedef enum
{
    LW_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_ID_TOTAL_GPU_POWER,
    LW_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_ID_NORMALIZED_TOTAL_POWER,
} LW_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_ID;

#define LW_GPU_CLIENT_POWER_CHANNEL_NUM_CHANNELS_V1    4

/*!
 * Used in \ref LW_GPU_CLIENT_POWER_TOPOLOGY_INFO_V1.
 */
typedef struct
{
    /*!
     * Topology Channel ID.  Unique identifier for a channel.
     */
    LW_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_ID channelId;

} LW_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_INFO_V1;

/*!
 * Used in \ref LwAPI_GPU_ClientPowerTopologyGetInfo().
 *
 * Describes the power topology of the GPU, including the set of channels
 * which are monitored.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32  version;

    /*!
     * Indicates that this GPU supports Client Power Topology Interfaces.
     */
    LwU8   bSupported;

    /*!
     * Number of channels this GPU supports.
     */
    LwU8  numChannels;

    /*!
     * Array of static information for each Power Topology Channel.  This array
     * has a valid index ranging from 0 to numChannels - 1.
     */
    LW_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_INFO_V1
        channels[LW_GPU_CLIENT_POWER_CHANNEL_NUM_CHANNELS_V1];

} LW_GPU_CLIENT_POWER_TOPOLOGY_INFO_V1;

#define LW_GPU_CLIENT_POWER_TOPOLOGY_INFO_VER_1  MAKE_LWAPI_VERSION(LW_GPU_CLIENT_POWER_TOPOLOGY_INFO_V1,1)
#define LW_GPU_CLIENT_POWER_TOPOLOGY_INFO_VER    LW_GPU_CLIENT_POWER_TOPOLOGY_INFO_VER_1

#define LW_GPU_CLIENT_POWER_TOPOLOGY_INFO        LW_GPU_CLIENT_POWER_TOPOLOGY_INFO_V1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_ClientPowerTopologyGetInfo
//
//! DESCRIPTION: Accessor for static information describing the public GPU
//!              power topology and capabilities.
//!
//!              Describes the power topology on the GPU, including the set of
//!              channels which are monitored and regularity with which they are
//!              monitored.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 295
//!
//! \param [in]  hPhysicalGPU             GPU selection
//! \param [out] pClientPowerTopologyInfo Structure containing the description
//!                  of the GPU power topology and capabilities
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ClientPowerTopologyGetInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_CLIENT_POWER_TOPOLOGY_INFO *pClientPowerTopologyInfo);



//! \addtogroup gpupower
//! @{

/*!
 * Used in \ref LW_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_STATUS_V1
 * and \ref LW_GPU_CLIENT_POWER_POLICIES_POLICY_INFO_V1
 *
 * Describes single power value (reading or limit).
 */
typedef struct
{
    /*!
     * On output it denotes if power is also provided in [mW] units (absolute
     * power, available only on Lwdqro/Tesla).
     *
     * On input (when used within \ref LwAPI_GPU_ClientPowerPoliciesSetStatus)
     * it denotes if caller is trying to set limit using absolute power or
     * scaled power (percentage).
     */
    LwU32 bMilliWattValid:1;

    /*!
     * Reserved for future use.
     */
    LwU32 reserved:31;

    /*!
     * Power value in 0.001 [%] units (normalized to respective default TDP limit).
     */
    LwU32 mp;

    /*!
     * Power value in 1 [mW] units.
     */
    LwU32 mW;
} LW_GPU_CLIENT_POWER_READING_V1;

/*!
 * Used in \ref LW_GPU_CLIENT_POWER_TOPOLOGY_STATUS_V1.
 */
typedef struct
{
    /*!
     * Topology Channel ID.  Unique identifier for a channel.  Client will
     * specify this value if querying only certain channels.
     */
    LW_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_ID channelId;

    /*!
     * Latest power reading on specified channel.
     */
    LW_GPU_CLIENT_POWER_READING_V1 power;
} LW_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_STATUS_V1;

/*!
 * Used in \ref LwAPI_GPU_ClientPowerTopologyGetStatus().
 *
 * Retrieves the latest power readings (and other dynamic status) for a set of
 * topology channels.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32  version;

    /*!
     * Number of channels this GPU supports.  Caller sets this value to 0 to
     * specify that all supported channels should be queried.
     */
    LwU8  numChannels;

    /*!
     * Array of latest power readings (and other status) for each specified Power
     * Topology Channel.  Array has a valid index ranging form 0 to numChannels - 1.
     */
    LW_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_STATUS_V1
        channels[LW_GPU_CLIENT_POWER_CHANNEL_NUM_CHANNELS_V1];

} LW_GPU_CLIENT_POWER_TOPOLOGY_STATUS_V1;

#define LW_GPU_CLIENT_POWER_TOPOLOGY_STATUS_VER_1  MAKE_LWAPI_VERSION(LW_GPU_CLIENT_POWER_TOPOLOGY_STATUS_V1,1)
#define LW_GPU_CLIENT_POWER_TOPOLOGY_STATUS_VER    LW_GPU_CLIENT_POWER_TOPOLOGY_STATUS_VER_1

#define LW_GPU_CLIENT_POWER_TOPOLOGY_STATUS        LW_GPU_CLIENT_POWER_TOPOLOGY_STATUS_V1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_ClientPowerTopologyGetStatus
//
//! DESCRIPTION: Accessor for the public GPU power topology readings.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 295
//!
//! \param [in]    hPhysicalGPU               GPU selection
//! \param [inout] pClientPowerTopologyStatus Structure containing GPU power
//!                    topology readings.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ClientPowerTopologyGetStatus(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_CLIENT_POWER_TOPOLOGY_STATUS *pClientPowerTopologyStatus);



//! \addtogroup gpupower
//! @{

/*!
 * Enumeration of Power Policies.  Unique identifiers for different Power
 * Policies being enforced on the GPU.
 */
typedef enum
{
    LW_GPU_CLIENT_POWER_POLICIES_POLICY_TOTAL_GPU_POWER,
} LW_GPU_CLIENT_POWER_POLICIES_POLICY_ID;

#define LW_GPU_CLIENT_POWER_POLICIES_NUM_POLICIES_V1         4

/*!
 * Used in \ref LW_GPU_CLIENT_POWER_POLICIES_INFO_V1.
 */
typedef struct
{
    /*!
     * Policy ID.  Unique identifier for a policy.
     */
    LW_GPU_CLIENT_POWER_POLICIES_POLICY_ID policyId;

    /*!
     * Topology channel ID this policy is controlling.
     */
    LW_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_ID channelId;

    /*!
     * Minimum allowed power policy limit.
     */
    LW_GPU_CLIENT_POWER_READING_V1 powerLimitMin;

    /*!
     * Default power policy limit.
     */
    LW_GPU_CLIENT_POWER_READING_V1 powerLimitDefault;

    /*!
     * Maximum allowed power policy limit.
     */
    LW_GPU_CLIENT_POWER_READING_V1 powerLimitMax;
} LW_GPU_CLIENT_POWER_POLICIES_POLICY_INFO_V1;

/*!
 * Used in \ref LW_GPU_CLIENT_POWER_POLICIES_INFO_V1.
 *
 * Describes the set of Power Policies which are controlling GPU power
 * consumption.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32  version;

    /*!
     * Indicates that this GPU supports Client Power Policy Interfaces.
     */
    LwU8   bSupported;

    /*!
     * Number of Power Policies this GPU supports.
     */
    LwU8  numPolicies;

    /*!
     * Array of static information for each Power Policy.  Array has a valid
     * index ranging from 0 to numPolicies - 1.
     */
    LW_GPU_CLIENT_POWER_POLICIES_POLICY_INFO_V1
        policies[LW_GPU_CLIENT_POWER_POLICIES_NUM_POLICIES_V1];

} LW_GPU_CLIENT_POWER_POLICIES_INFO_V1;

#define LW_GPU_CLIENT_POWER_POLICIES_INFO_VER_1  MAKE_LWAPI_VERSION(LW_GPU_CLIENT_POWER_POLICIES_INFO_V1,1)
#define LW_GPU_CLIENT_POWER_POLICIES_INFO_VER    LW_GPU_CLIENT_POWER_POLICIES_INFO_VER_1

#define LW_GPU_CLIENT_POWER_POLICIES_INFO        LW_GPU_CLIENT_POWER_POLICIES_INFO_V1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_ClientPowerPoliciesGetInfo
//
//! DESCRIPTION: Accessor for static information describing the public GPU
//!              power policies which are controlling GPU power consumption.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 295
//!
//! \param [in]  hPhysicalGPU             GPU selection
//! \param [out] pClientPowerPoliciesInfo Structure containing the description
//!                  of the GPU power policies.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ClientPowerPoliciesGetInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_CLIENT_POWER_POLICIES_INFO *pClientPowerPoliciesInfo);





//! \addtogroup gpupower
//! @{

/*!
 * Used in \ref LW_GPU_CLIENT_POWER_POLICIES_STATUS_V1.
 */
typedef struct
{
    /*!
     * Policy ID.  Unique identifier for a policy.
     */
    LW_GPU_CLIENT_POWER_POLICIES_POLICY_ID policyId;

    /*!
     * Current power policy limit.
     */
    LW_GPU_CLIENT_POWER_READING_V1 powerLimit;

} LW_GPU_CLIENT_POWER_POLICIES_POLICY_STATUS_V1;

/*!
 * Used in \ref LW_GPU_CLIENT_POWER_POLICIES_STATUS_V1.
 *
 * Describes/specifies the current settings of a set of Power Policies which are
 * controlling GPU power consumption.
 */
typedef struct
{
    LwU32  version;

    /*!
     * Number of Power Policies specified in the policies array.  Caller sets
     * this value to 0 to specify that all policies should be queried.
     */
    LwU8  numPolicies;

    /*!
     * Array of current settings for each specified Power Policy.  This array
     * has a valid index ranging from 0 to numPolicies - 1.
     */
    LW_GPU_CLIENT_POWER_POLICIES_POLICY_STATUS_V1
        policies[LW_GPU_CLIENT_POWER_POLICIES_NUM_POLICIES_V1];

} LW_GPU_CLIENT_POWER_POLICIES_STATUS_V1;

#define LW_GPU_CLIENT_POWER_POLICIES_STATUS_VER_1  MAKE_LWAPI_VERSION(LW_GPU_CLIENT_POWER_POLICIES_STATUS_V1,1)
#define LW_GPU_CLIENT_POWER_POLICIES_STATUS_VER    LW_GPU_CLIENT_POWER_POLICIES_STATUS_VER_1

#define LW_GPU_CLIENT_POWER_POLICIES_STATUS        LW_GPU_CLIENT_POWER_POLICIES_STATUS_V1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_ClientPowerPoliciesGetStatus
//
//! DESCRIPTION: Accessor for current state of the public GPU power
//!              policies which are controlling GPU power consumption.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 295
//!
//! \param [in]  hPhysicalGPU               GPU selection
//! \param [out] pClientPowerPoliciesStatus Structure containing the current
//!                  state of a set of GPU power policies.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ClientPowerPoliciesGetStatus(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_CLIENT_POWER_POLICIES_STATUS *pClientPowerPoliciesStatus);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_ClientPowerPoliciesSetStatus
//
//! DESCRIPTION: Mutator for state of the public GPU power policies which
//!              are controlling GPU power consumption.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 295
//!
//! \param [in]  hPhysicalGPU               GPU selection
//! \param [out] pClientPowerPoliciesStatus Structure containing the requested
//!                  state of a set of GPU power policies.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ClientPowerPoliciesSetStatus(__in LwPhysicalGpuHandle hPhysicalGpu, __in LW_GPU_CLIENT_POWER_POLICIES_STATUS *pClientPowerPoliciesStatus);




//////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_QueryGpuCap
//
//! \fn LwAPI_QueryGpuCap(LwLogicalGpuHandle hLogicalGPU, LWAPI_GPU_CAP capToQuery, LwU32 *pVal)
//!   DESCRIPTION: This function gets capability information from a logical GPU.
//!   
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//! \param [in]  hLogicalGPU Logical GPU selection.
//! \param [in]  capToQuery  GPU cap to query
//! \param [out] pVal        Returned value
//!
//! \retval  LWAPI_OK                           Query succeeded.
//! \retval  LWAPI_ILWALID_ARGUMENT             pVal is NULL or capToQuery is invalid.
//! \retval  LWAPI_EXPECTED_LOGICAL_GPU_HANDLE  hLogicalGPU is not a valid handle.
//! \retval  LWAPI_HANDLE_ILWALIDATED           hLogicalGPU has been ilwalidated.
//! \retval  LWAPI_ERROR                        Miscellaneous error oclwrred.
//
//////////////////////////////////////////////////////////////////////////////


//! \ingroup gpu
//! Used in LwAPI_QueryGpuCap().
typedef enum 
{
    LWAPI_GPU_CAP_UNDEFINED                                    = 0,
    LWAPI_GPU_CAP_GAMMA_CORRECT_AA_SUPPORTED                   = 1,
    LWAPI_GPU_CAP_TRANSPARENCY_AA_SUPPORTED                    = 2,
    LWAPI_GPU_CAP_SLI_RENDERING_DISABLED_DUE_TO_INTERLACE_MODE = 3,
    LWAPI_GPU_CAP_STEREO_DIN_AVAILABLE                         = 4,
    LWAPI_GPU_CAP_STEREO_CAPS                                  = 5,
    LWAPI_GPU_CAP_STEREO_DEFAULT                               = 6,
    LWAPI_GPU_CAP_ROTATION_COMPATIBLE_STEREO_CAPS              = 7,
    LWAPI_GPU_CAP_ROTATION_COMPATIBLE_STEREO_DEFAULT           = 8,
    LWAPI_GPU_CAP_SWAPGROUP_FOR_ALL_APPS_SUPPORTED             = 9,
    LWAPI_GPU_CAP_DEEP_COLOR_CAPS                              = 10,
    LWAPI_GPU_CAP_COUNT
} LWAPI_GPU_CAP;


//! \ingroup gpu
//! Possible return value of queries to LWAPI_GPU_CAP_STEREO_CAPS and
//! LWAPI_GPU_CAP_STEREO_DEFAULT
typedef enum 
{
    LWAPI_GPU_CAP_STEREO_CAP_DIN_AVAILABLE                = 0x00000001,
    LWAPI_GPU_CAP_STEREO_CAP_VERTICAL_INTERLACED          = 0x00000002,
    LWAPI_GPU_CAP_STEREO_CAP_TWILWIEW                     = 0x00000004,
    LWAPI_GPU_CAP_STEREO_CAP_DDC_AVAILABLE                = 0x00000008,
    LWAPI_GPU_CAP_STEREO_CAP_COLOR_LINE                   = 0x00000010,
    LWAPI_GPU_CAP_STEREO_CAP_COLOR_INTERLEAVED            = 0x00000020,
    LWAPI_GPU_CAP_STEREO_CAP_ANAGLYPH                     = 0x00000040,
    LWAPI_GPU_CAP_STEREO_CAP_HORIZONTAL_INTERLACED        = 0x00000080,
    LWAPI_GPU_CAP_STEREO_CAP_SIDE_FIELD                   = 0x00000100,
    LWAPI_GPU_CAP_STEREO_CAP_SUB_FIELD                    = 0x00000200,
    LWAPI_GPU_CAP_STEREO_CAP_CHECKERBOARD                 = 0x00000400,
    LWAPI_GPU_CAP_STEREO_CAP_ILWERSE_CHECKERBOARD         = 0x00000800,
    LWAPI_GPU_CAP_STEREO_CAP_TRIDELITY_SL                 = 0x00001000,
    LWAPI_GPU_CAP_STEREO_CAP_TRIDELITY_MV                 = 0x00002000,
    LWAPI_GPU_CAP_STEREO_CAP_SEEFRONT                     = 0x00004000,
    LWAPI_GPU_CAP_STEREO_CAP_STEREO_MIRROR                = 0x00008000,
    LWAPI_GPU_CAP_STEREO_CAP_FRAME_SEQUENTIAL             = 0x00010000,
    LWAPI_GPU_CAP_STEREO_CAP_USB_EMITTER                  = 0x00020000,
    LWAPI_GPU_CAP_STEREO_CAP_PER_EYE_PAIR_FLIP            = 0x00040000,
    LWAPI_GPU_CAP_STEREO_CAP_PER_EYE_FLIP                 = 0x00080000,
} LWAPI_GPU_CAP_STEREO_CAP;


//! \ingroup gpu
//! Possible return value of queries to LWAPI_GPU_CAP_DEEP_COLOR_CAPS
typedef enum 
{
    LWAPI_GPU_CAP_DEEP_COLOR_CAP_SUPPORTED_BY_GPU          = 0x00000001,
    LWAPI_GPU_CAP_DEEP_COLOR_CAP_SUPPORTED_BY_DISPLAY      = 0x00000002,
    LWAPI_GPU_CAP_DEEP_COLOR_CAP_SUPPORTED_BY_DISPLAY_MODE = 0x00000004,
} LWAPI_GPU_CAP_DEEP_COLOR_CAP;


//! \ingroup gpu
LWAPI_INTERFACE LwAPI_QueryGpuCap(LwLogicalGpuHandle hLogicalGPU, LWAPI_GPU_CAP capToQuery, LwU32 *pVal);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_WorkstationFeatureSetup
//
//! \fn LwAPI_GPU_WorkstationFeatureSetup(LwPhysicalGpuHandle hPhysicalGpu, LwU32 featureEnableMask, LwU32 featureDisableMask)
//!   DESCRIPTION: This API configures the driver for a set of workstation features.
//!                The driver can allocate the memory resources accordingly.
//!
//! SUPPORTED OS:  Windows 7
//!
//!
//! \param [in]   hPhysicalGpu       Physical GPU Handle of the display adapter to be configured. GPU handles may be retrieved
//!                                  using LwAPI_EnumPhysicalGPUs. A value of NULL is permitted and applies the same operation
//!                                  to all GPU handles enumerated by LwAPI_EnumPhysicalGPUs.
//! \param [in]   featureEnableMask  Mask of features the caller requests to enable for use
//! \param [in]   featureDisableMask Mask of features the caller requests to disable 
//!
//!                As a general rule, features in the enable and disable masks are expected to be disjoint, although the disable 
//!                mask has precedence and a feature flagged in both masks will be disabled.
//!
//! \retval ::LWAPI_OK                            configuration request succeeded
//! \retval ::LWAPI_ERROR                         configuration request failed
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu is not a physical GPU handle.
//! \retval ::LWAPI_GPU_WORKSTATION_FEATURE_INCOMPLETE  requested feature set does not have all resources allocated for completeness.
//! \retval ::LWAPI_NO_IMPLEMENTATION             only implemented for Win7
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu 
typedef enum
{
    LWAPI_GPU_WORKSTATION_FEATURE_MASK_SWAPGROUP     = 0x00000001,
    LWAPI_GPU_WORKSTATION_FEATURE_MASK_STEREO        = 0x00000010,
    LWAPI_GPU_WORKSTATION_FEATURE_MASK_WARPING       = 0x00000100,
    LWAPI_GPU_WORKSTATION_FEATURE_MASK_PIXINTENSITY  = 0x00000200,
    LWAPI_GPU_WORKSTATION_FEATURE_MASK_GRAYSCALE     = 0x00000400,
    LWAPI_GPU_WORKSTATION_FEATURE_MASK_BPC10         = 0x00001000
} LWAPI_GPU_WORKSTATION_FEATURE_MASK;

//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_WorkstationFeatureSetup(__in LwPhysicalGpuHandle hPhysicalGpu, __in LwU32 featureEnableMask, __in LwU32 featureDisableMask);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_WorkstationFeatureQuery
//
//!   DESCRIPTION: This API queries the current set of workstation features.
//!
//! SUPPORTED OS:  Windows 7
//!
//!
//! \param [in]   hPhysicalGpu       Physical GPU Handle of the display adapter to be configured. GPU handles may be retrieved
//!                                  using LwAPI_EnumPhysicalGPUs. 
//! \param [out]  pConfiguredFeatureMask  Mask of features requested for use by client drivers
//! \param [out]  pConsistentFeatureMask  Mask of features that have all resources allocated for completeness.
//!
//! \retval ::LWAPI_OK                            configuration request succeeded
//! \retval ::LWAPI_ERROR                         configuration request failed
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu is not a physical GPU handle.
//! \retval ::LWAPI_NO_IMPLEMENTATION             only implemented for Win7
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_WorkstationFeatureQuery(__in LwPhysicalGpuHandle hPhysicalGpu, __out_opt LwU32 *pConfiguredFeatureMask, __out_opt LwU32 *pConsistentFeatureMask);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_WorkstationFeatureCommit
//
//!   DESCRIPTION: This API commits the configured workstation feature set to the kernel mode driver and validates resources to 
//!                promote the feature set to completeness.
//!
//! SUPPORTED OS:  Windows 7
//!
//!
//! \retval ::LWAPI_OK                            configuration request succeeded
//! \retval ::LWAPI_ERROR                         configuration request failed
//! \retval ::LWAPI_GPU_WORKSTATION_FEATURE_INCOMPLETE  not all resources for the configures feature set could be allocated for completeness.
//! \retval ::LWAPI_NO_IMPLEMENTATION             only implemented for Win7
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_WorkstationFeatureCommit();



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_LWPM_GetExportSetting
//
//!  This function returns the U32 value for the current LWPMAPI export
//!                setting.  This is usually stored in the registry and include
//!                info on if LWPMAPI is enabled, what the debug level is, etc.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \return LWAPI_ERROR or LWAPI_OK
//! \ingroup lwpmapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_LWPM_GetExportSetting(LwDisplayHandle hLwDisplay, LwU32 *pReturn);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAMES: LwAPI_LWPM_CreateGPUMapping
//                 LwAPI_LWPM_DestroyGPUMapping     
//                 LwAPI_LWPM_CreateSharedMemory
//                 LwAPI_LWPM_DestroySharedMemory
//                 LwAPI_LWPM_ReservePerfmonHW
//                 LwAPI_LWPM_ReleasePerfmonHW
//                 LwAPI_LWPM_SetPMTriggerInsert
//
//   DESCRIPTION: Used by LWPMAPI for setting up management of the data segment. Administrative rights are required.
//
// RETURN STATUS: LWAPI_ERROR or LWAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup lwpmapi
//! Used in all \ref lwpmapi
typedef struct 
{
    LwU32              version;    //!< Structure version, constructed from macro below
    LwU32              gpuCount;   //!< Number of mapped GPU memory spaces
    LwU64              hClient[LWAPI_MAX_PHYSICAL_GPUS];
    LwU64              hDevice[LWAPI_MAX_PHYSICAL_GPUS];
    void*             pMapping[LWAPI_MAX_PHYSICAL_GPUS];
} LW_LWPM_GPU_MAPPING;


//! \ingroup lwpmapi
//! Macro for constructing the version field of LW_LWPM_GPU_MAPPING
#define LW_LWPM_GPU_MAPPING_VER  MAKE_LWAPI_VERSION(LW_LWPM_GPU_MAPPING,1)


//! \ingroup lwpmapi 
typedef enum
{
    LW_LWPM_GPU_RELEASE_REQUEST = 0,  //!< release perfmon
    LW_LWPM_GPU_RESERVE_REQUEST,      //!< reserve perfmon 
}LW_LWPM_RESERVE_RELEASE_TYPE;

//! \ingroup lwpmapi
//! Used in LwAPI_LWPM_ReserveReleasePerfmonHW(). 
typedef struct
{
  LwU32                        version;    //!< Structure version
  LwU32                        gpuCount;   //!< Number of mapped GPU memory spaces
  LwPhysicalGpuHandle          hPhysicalGpus[LWAPI_MAX_PHYSICAL_GPUS];//!< Valid physical GPU handles
  LW_LWPM_RESERVE_RELEASE_TYPE requestType;//!< reserve/release request  
}LW_LWPM_GPU_PERFMON_MAPPING;


//! \ingroup lwpmapi
//! Macro for constructing the version field of LW_LWPM_PERFMON_MAPPING
#define LW_LWPM_GPU_PERFMON_MAPPING_VER MAKE_LWAPI_VERSION(LW_LWPM_GPU_PERFMON_MAPPING,1)




//! \addtogroup lwpmapi
//! These APIs are used by LWPMAPI for setting up management of the data segment. 
//! @{


//! SUPPORTED OS:  Windows XP and higher
//!
LWAPI_INTERFACE LwAPI_LWPM_CreateGPUMapping(LW_LWPM_GPU_MAPPING *pMapping);

//! SUPPORTED OS:  Windows XP and higher
//!
LWAPI_INTERFACE LwAPI_LWPM_DestroyGPUMapping(LW_LWPM_GPU_MAPPING *pMapping);

//! SUPPORTED OS:  Windows XP and higher
//!
LWAPI_INTERFACE LwAPI_LWPM_CreateSharedMemory();

//! SUPPORTED OS:  Windows XP and higher
//!
LWAPI_INTERFACE LwAPI_LWPM_DestroySharedMemory();

//! SUPPORTED OS:  Windows XP and higher
//!
LWAPI_INTERFACE LwAPI_LWPM_ReservePerfmonHW(LW_LWPM_GPU_MAPPING *pMapping);

//! SUPPORTED OS:  Windows XP and higher
//!
LWAPI_INTERFACE LwAPI_LWPM_ReleasePerfmonHW(LW_LWPM_GPU_MAPPING *pMapping);

//! SUPPORTED OS:  Windows XP and higher
//!
LWAPI_INTERFACE LwAPI_LWPM_SetPMTriggerInsert(LwDisplayHandle hLwDisplay, LwU32 value);
//! @}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_LWPM_ReserveReleasePerfmonHW
//
//! \code
//!   DESCRIPTION: to reserve or release perfmon on a gpu in multigpu
//!                environment on Lwca profile etc.Lwrrenly SLI support is 
//!                not provided it will return LWAPI_NOT_SUPPORTED
//!                if multigpu mode is enabled.
//!
//!   PARAMETERS:  pMapping(IN) : pointer to a structure variable of LW_LWPM_GPU_PERFMON_MAPPING
//!                
//!                
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: LWAPI_OK: query succeeded
//!                LWAPI_ILWALID_ARGUMENT: pMapping is NULL or gpuCount is not specified by user
//!                LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: handle passed is not a physical GPU handle.
//!                LWAPI_HANDLE_ILWALIDATED: hPhysicalGpu has been ilwalidated
//!                LWAPI_ILWALID_HANDLE: hPhysicalGpu is not a valid handle
//!                LWAPI_NOT_SUPPORTED: not supported configuration
//!                LWAPI_NO_IMPLEMENTATION:not implemented
//! \endcode
//! \ingroup lwpmapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_LWPM_ReserveReleasePerfmonHW(LW_LWPM_GPU_PERFMON_MAPPING *pMapping);





//! \ingroup gpu
typedef struct
{
    LwU32 version;    //!< Structure version, constructed from macro below
    LwU32 IsWrongThermSetup :1;
    LwU32 IsEngineeringSample :1;
    LwU32 reserved : 30;
}LW_MODE_RESTRICT_PARAMS;

//! \ingroup gpu
//! Macro for constructing the version field of ::LW_MODE_RESTRICT_PARAMS
#define LW_MODE_RESTRICT_PARAMS_VER  MAKE_LWAPI_VERSION(LW_MODE_RESTRICT_PARAMS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DIAG_ModeRestrictInfo
//
//! \code
//! DESCRIPTION: Returns the reason for system being in 800X600 mode.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: LWAPI_OK: now *pModeRestrict contains the reason for system being in 800x600 mode.
//!                LWAPI_ERROR:If any way call is not success.
//!                LWAPI_NOT_SUPPORTED:If any way call is not success.
//!                LWAPI_HANDLE_ILWALIDATED:If lwapi escape result handle is invalid.
//!                LWAPI_API_NOT_INTIALIZED:If LWAPI is not initialized.
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DIAG_ModeRestrictInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_MODE_RESTRICT_PARAMS *pModeRestrict);



//! \ingroup gpu
//! @{

//! Let the control panel retrieve info on the various streams
typedef enum {
    LWAPI_AELPG_OPCODE_GET_ELPGINFO  = 0,
    LWAPI_AELPG_OPCODE_DEPRECATED    = 1,
    LWAPI_AELPG_OPCODE_HOLDOFF_AELPG = 2,
    LWAPI_AELPG_OPCODE_GET_VIDEOELPGINFO = 3,
    LWAPI_AELPG_OPCODE_GET_ELPGSTATS      = 4,
    LWAPI_AELPG_OPCODE_GET_VIDEOELPGSTATS = 5,
    LWAPI_AELPG_OPCODE_GET_MSPGSTATS      = 6,
    LWAPI_AELPG_OPCODE_GET_AELPGINFO      = 7,
    LWAPI_AELPG_OPCODE_GET_AELPG1INFO     = 8,
    LWAPI_AELPG_OPCODE_SET_IDLE_THRESHOLD = 9,
}LWAPI_AELPG_OPCODE;

typedef struct _LWAPI_ELPG_INFO
{
    LwU8  initialized;
    LwU8  enabled;
    LwU8  aelpgEnabled;
    LwU32 idleThreshold;
    LwU32 postPowerupThreshold;
    LwU8  powerStateEngine;
    LwU32 gatingCount;
    LwU32 denyCount;
}LWAPI_ELPG_INFO;

typedef LWAPI_ELPG_INFO LWAPI_VIDEO_ELPG_INFO;

#define LWAPI_AELPG_HISTOGRAM_SIZE 16

typedef struct _LWAPI_AELPG_INFO
{
    LwU8  enabled;
    LwU8  active;
    LwU32 holdTimeInSec;
    LwU32 badDecisionCount;
    LwU32 idleFilter;
    LwU32 powerSaving;
    LwU8  histogramBin[LWAPI_AELPG_HISTOGRAM_SIZE];
}LWAPI_AELPG_INFO;

typedef struct _LWAPI_ELPG_STATS
{
    LwU32 gatingCount;
    LwU32 gatingTimeUs;
    LwU32 ungatingCount;
    LwU32 ungatingTimeUs;
    LwU32 avgEntryTimeUs;
    LwU32 avgExitTimeUs;
}LWAPI_ELPG_STATS;

typedef struct _LWAPI_AELPG_REQUEST
{
    LwU32                  version;            //!< (IN)  structure version
    LWAPI_AELPG_OPCODE     opCode;             //!< (IN)  opcode: getELPGInfo, getAElpgInfo, holdOffAELPG, getELPGStats
    union
    {
        LWAPI_ELPG_INFO    elpgInfo;           //!< (OUT) elpg info
        LWAPI_AELPG_INFO   aelpgInfo;          //!< (OUT) aelpg info
        LwU32              aelpgHoldTimeInSec; //!< (IN)  hold off aelpg for given number of seconds, only valid for opcode LWAPI_AELPG_OPCODE_HOLDOFF_AELPG
        LWAPI_ELPG_STATS   elpgStats;          //!< (OUT) elpg statistics
        LwU32              idleThreshold;      //!< (IN)  new ELPG threshold, only for opcode LWAPI_AELPG_OPCODE_SET_IDLE_THRESHOLD. Set to 0 to re-enable AELPG
    }data;
    LwU64 reserved;
} LWAPI_AELPG_REQUEST;

//! Macro for constructing the version field of ::LWAPI_AELPG_REQUEST
#define LWAPI_HANDLE_AELPG_VER  MAKE_LWAPI_VERSION(LWAPI_AELPG_REQUEST,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_HandleAELPG
//
//! \code
//!   DESCRIPTION: Get/Set (A)ELPG settings and statistics.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: LWAPI_OK
//!                LWAPI_ILWALID_ARGUMENT
//!                LWAPI_LWIDIA_DEVICE_NOT_FOUND
//!                LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE
//!                LWAPI_NOT_SUPPORTED
//!                LWAPI_INCOMPATIBLE_STRUCT_VERSION
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_HandleAELPG(LwPhysicalGpuHandle hPhysicalGpu, LWAPI_AELPG_REQUEST *pParms);

//! @}

/*!
 * Used in \ref LwAPI_GPU_HandlePSI
 * Lets the application retrive different data for PSI using these opcodes
 */
typedef enum _LWAPI_PSI_OPCODE{
    LWAPI_PSI_OPCODE_GET_PSISTAT      = 0,        //!< (IN) opcode to get PSI statisics
    LWAPI_PSI_SET_LWRRENT_MA          = 1,        //!< (IN) Sets PSI Single phase crossover current
    LWAPI_PSI_GET_SUPPORT             = 2,        //!< (IN) Gets Different support parameters for PSI
    LWAPI_PSI_GET_SLEEP_MA            = 3,        //!< (IN) Gets sleep current for PSI CTRL
    LWAPI_PSI_GET_OPTIMAL_MA          = 4,        //!< (IN) Gets the single phase crossover current
    LWAPI_PSI_CTRL_RESET_ENGAGE_COUNT = 5,        //!< (IN) Resets PSI engage count for the specified CTRL
    LWAPI_PSI_RESET_ENGAGE_COUNT      = 6,        //!< (IN) Resets all engage counters
}LWAPI_PSI_OPCODE;

/*!
 * Used in \ref LWAPI_PSI_REQUEST
 * Structure representing PSI support for power saving feature
 */
typedef struct _LWPSI_SUPPORT
{
    LwU32  elpgCoupled :1;      //!< (IN/OUT) true if ELPG coupled PSI is supported
    LwU32  mscgCoupled :1;      //!< (IN/OUT) true if MSCG coupled PSI is supported
    LwU32  gc4Coupled :1;       //!< (IN/OUT) true if GC4 coupled PSI is supported
    LwU32  gc5Coupled :1;       //!< (IN/OUT) true if GC5 coupled PSI is supported
    LwU32  psiSupported :1;     //!< (OUT) true if PSI is supported on the system
    LwU32  psiLwrrentaware :1;  //!< (OUT) true if current aware PSI is supported on the system
    LwU32  reserved:26;
}LWPSI_SUPPORT;

/*!
 * Used in \ref LWAPI_STAT
 * Structure representing PSI statistics for GR-ELPG power saving feature
 * Structure might be populated with more data in future
 *
 * psiCount : Denotes PSI engage count
 * iSleepmA : Denotes sleep current of power saving feature engaging PSI
 */
typedef struct _LWAPI_ELPG_STAT
{
    LwU32 psiCount;
    LwU32 iSleepmA;
}LWAPI_ELPG_STAT;

/*!
 * Used in \ref LWAPI_STAT
 * Structure representing PSI statistics for MSCG power saving feature
 * Structure might be populated with more data in future
 *
 * psiCount : Denotes PSI engage count
 * iSleepmA : Denotes sleep current of power saving feature engaging PSI
 */
typedef struct _LWAPI_MSCG_STAT
{
    LwU32 psiCount;
    LwU32 iSleepmA;
}LWAPI_MSCG_STAT;

/*!
 * Used in \ref LWAPI_STAT
 * Structure representing PSI statistics for GC4 power saving feature
 * Structure might be populated with more data in future
 *
 * psiCount : Denotes PSI engage count
 * iSleepmA : Denotes sleep current of power saving feature engaging PSI
 */
typedef struct _LWAPI_GC4_STAT
{
    LwU32 psiCount;
    LwU32 iSleepmA;
}LWAPI_GC4_STAT;

/*!
 * Used in \ref LWAPI_STAT
 * Structure representing PSI statistics for GC5 power saving feature
 * Structure might be populated with more data in future
 *
 * psiCount : Denotes PSI engage count
 * iSleepmA : Denotes sleep current of power saving feature engaging PSI
 */
typedef struct _LWAPI_GC5_STAT
{
    LwU32 psiCount;
    LwU32 iSleepmA;
}LWAPI_GC5_STAT;

typedef struct _LWPSI_STAT_V1
{
    union
    {
        LwU32 psiCount;
    }elpg;

    union
    {
        LwU32 psiCount;
    }mscg;

    union
    {
        LwU32 psiCount;
    }gc4;

    union
    {
        LwU32 psiCount;
    }gc5;
}LWPSI_STAT_V1;

/*!
 * Used in \ref LWAPI_PSI_REQUEST
 * Structure representing PSI statistics for powersaving features
 */
typedef struct _LWPSI_STAT
{
    LWAPI_ELPG_STAT  elpg;
    LWAPI_MSCG_STAT  mscg;
    LWAPI_GC4_STAT   gc4;
    LWAPI_GC5_STAT   gc5;
}LWPSI_STAT;

typedef struct _LWAPI_PSI_REQUEST_V1
{
    LwU32                  version;            //!< (IN)  structure version
    LWAPI_PSI_OPCODE       opCode;             //!< (IN)  opcode
    union
    {
        LwU32                  onePhaseLwrrentmA;       //!< (IN)
        LWPSI_STAT_V1          psiStat;                //!< (OUT)
        LWPSI_SUPPORT          psiSupport;             //!< (OUT)
    } data;
}LWAPI_PSI_REQUEST_V1;
/*!
 * Used in \ref LwAPI_GPU_HandlePSI
 * Structure describes all info related to PSI 
 */
typedef struct _LWAPI_PSI_REQUEST_V2
{
    LwU32                  version;            //!< (IN)  structure version
    LWAPI_PSI_OPCODE       opCode;             //!< (IN)  opcode
    LWPSI_SUPPORT          psiSupport;         //!< (IN/OUT)
    union
    {
        LwU32                  onePhaseLwrrentmA;       //!< (IN/OUT)
        LWPSI_STAT             psiStat;                //!< (OUT)
    } data;
}LWAPI_PSI_REQUEST_V2;

typedef LWAPI_PSI_REQUEST_V2 LWAPI_PSI_REQUEST;
//! Macro for constructing the version field of ::LWAPI_PSI_REQUEST
#define LWAPI_PSI_REQUEST_VER_1  MAKE_LWAPI_VERSION(LWAPI_PSI_REQUEST_V1, 1)
#define LWAPI_PSI_REQUEST_VER_2  MAKE_LWAPI_VERSION(LWAPI_PSI_REQUEST_V2, 2)

#define LWAPI_PSI_REQUEST_VER    LWAPI_PSI_REQUEST_VER_2

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_HandlePSI()
//
//! DESCRIPTION:     This function checks for PSI support, 
//!                  gets PSI statistics for power saving feature
//!                  as well as sets sleep current to change PSI behavior
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Version:  331
//!
//! \param [in]          hPhysicalGPU    GPU selection
//! \param [in,out]      LWAPI_PSI_REQUEST 
//!     Structure containing the requested data for PSI statistics, 
// !    support and onephase current
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_HandlePSI(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LWAPI_PSI_REQUEST *pParams);


//! \ingroup gpu
//! Used in LwAPI_GPU_GetNBSIParams().
#define LWAPI_MAX_NBSI_PARAM_SIZE 256

//! \ingroup gpu
//!  Constants for hive values defined for modules. \n
//! Used in LwAPI_GPU_GetNBSIParams().
typedef enum _LWAPI_BIOS_NBSI_MODULE_TYPES
{
    LWAPI_BIOS_NBSI_MODULE_GLOBAL=0,      //!< Global section contains version
    LWAPI_BIOS_NBSI_MODULE_RM ,
    LWAPI_BIOS_NBSI_MODULE_DD,             
    LWAPI_BIOS_NBSI_MODULE_VIDEO,         
    LWAPI_BIOS_NBSI_MODULE_CPL,            
    LWAPI_BIOS_NBSI_MODULE_D3D,            
    LWAPI_BIOS_NBSI_MODULE_OGL,
    LWAPI_BIOS_NBSI_PMU,           //!< PMU microcode
    LWAPI_BIOS_NBSI_MODE           //!< Modes
    } LWAPI_BIOS_NBSI_MODULE_TYPES; 



//! \ingroup gpu
//! Used in LwAPI_GPU_GetNBSIParams().
typedef enum _LWAPI_BIOS_NBSI_ERROR_CODES
{
    LWAPI_BIOS_GET_NBSI_SUCCESS         = 0x00000000,
    LWAPI_BIOS_GET_NBSI_OVERRIDE        = 0x00000001,
    LWAPI_BIOS_GET_NBSI_BAD_HASH        = 0xFFFFFFFA,
    LWAPI_BIOS_GET_NBSI_APITEST_SUCCESS = 0xFFFFFFFB,
    LWAPI_BIOS_GET_NBSI_BAD_TABLE       = 0xFFFFFFFC,
    LWAPI_BIOS_GET_NBSI_NO_TABLE        = 0xFFFFFFFD,
    LWAPI_BIOS_GET_NBSI_INCOMPLETE      = 0xFFFFFFFE,
    LWAPI_BIOS_GET_NBSI_NOT_FOUND       = 0xFFFFFFFF,
} LWAPI_BIOS_NBSI_ERROR_CODES;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetNBSIParams
//
//! DESCRIPTION: This function gives the NBSI parameter value and NBSI return code as output.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 170
//!
//! \param [in]      hPhysicalGpu   GPU selection.
//! \param [in]      key            ASCII value of key, to be used to identify parameter name/value.
//! \param [in]      val            ASCII value of Value, to be used to identify parameter name/value.
//! \param [in]      moduleId       Enum value of module to which this parameter setting belongs.
//! \param [out]     data           Data stored for the paramter(NBSI setting object).
//! \param [in,out]  psizeofdata    Maximum size of data(return value)is passed in. 
//!                                 If successful, this parameter contains the actual size of the output data.
//! \param [out]     pnbsiErrorCode Returns possible error values of NBSI. (See LWAPI_BIOS_NBSI_ERROR_CODES.)
//!
//! \retval          LWAPI_ILWALID_ARGUMENT              hPhysicalGpu or data is NULL
//! \retval          LWAPI_OK                           *data contains NBSI parameter value
//! \retval          LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found
//! \retval          LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetNBSIParams(LwPhysicalGpuHandle hPhysicalGpu, LwAPI_LongString key, LwAPI_LongString val, LWAPI_BIOS_NBSI_MODULE_TYPES moduleId, LwU8 data[LWAPI_MAX_NBSI_PARAM_SIZE], LwU32 *psizeofdata, LWAPI_BIOS_NBSI_ERROR_CODES *pnbsiErrorCode);






#ifndef ANY_SIZE_ARRAY
#define ANY_SIZE_ARRAY 127
#endif

//! \addtogroup gpu
//! @{

#define NBSIDIRHDRSTRING (LwU32) (('N'<<24)+('B'<<16)+('S'<<8)+'I')


// A directory of globs
#pragma pack(1)
//! A directory of NBSI globs 
typedef union _NBSI_DIRECTORY
{
    struct OLD_FORMAT                   //!< Original version for Beta
    {
        LwU8  numGlobs;                 //!< number of globs
        LwU8  dirVer;                   //!< dirVer
        LwU16 globType[1];              //!< NBSI_GLOB_TYPE (placeholder)
    } od;
    struct NEW_FORMAT                   //!< Shipping version
    {
        LwU32 nbsiHeaderString;         //!< header string NBSIDIRHDRSTRING
        LwU32 size;                     //!< size of entire directory
        LwU8  numGlobs;                 //!< number of globs
        LwU8  dirVer;                   //!< dirVer
        LwU16 globType[1];              //!< NBSI_GLOB_TYPE (placeholder
    } d;
} NBSI_DIRECTORY, *PNBSI_DIRECTORY;
#pragma pack()


#pragma pack(1)
typedef struct _NBSI_GEN_OBJ
{
    LwU64       sig;          //!< One-way Hash of the entire object
    // Hash from here -->
    LwU16       globType;     //!< NBSI_GLOB_TYPE
    LwU32       size;         //!< Total size of GLOB including Signature
    LwU16       majMilwer;    //!< Version of Generic Object in Maj:Min format
    // actual packed object data
    LwU8        objData[ANY_SIZE_ARRAY];
    // <-- to here
} NBSI_GEN_OBJ, *PNBSI_GEN_OBJ;
#pragma pack()


typedef enum _NBSI_TBL_SOURCES
{
    NBSI_TBL_SOURCE_BEST_FIT = 0,
    NBSI_TBL_SOURCE_REGISTRY = 1,
    NBSI_TBL_SOURCE_VBIOS    = 2,
    NBSI_TBL_SOURCE_I2C      = 4,
    NBSI_TBL_SOURCE_SBIOS    = 8,
    NBSI_TBL_SOURCE_ACPI     = 0x10
} NBSI_TBL_SOURCES, * PNBSI_TBL_SOURCES;


//! The number of NBSI_TBL_SOURCES entries (not including BEST FIT)
#define NBSI_TBL_SOURCE_MAX 5                    


#define nbsiobjtype(ch1,ch2) (LwU16) ((ch1<<8) + ch2)


//! NBSI glob types - used in LWAPI_GET_NBSI_OBJ, _NBSI_GEN_OBJ, _NBSI_DIRECTORY
typedef enum _NBSI_GLOB_TYPES
{
    NBSI_RSRVD_GLOB     = 0,                     //!< Reserved Glob type
    NBSI_DRIVER         = nbsiobjtype('D','R'),  //!< Driver Object
    NBSI_VBIOS          = nbsiobjtype('V','B'),  //!< VBIOS Object
    NBSI_HDCP           = nbsiobjtype('H','K'),  //!< HDCP Keys
    NBSI_HDD            = nbsiobjtype('H','D'),  //!< Storage Driver
    NBSI_NOLWOLATILE    = nbsiobjtype('N','V')   //!< CMOS settings
} NBSI_GLOB_TYPE, * PNBSI_GLOB_TYPE;


#define GLOB_TYPE_APITEST            0xffff     //!< Used to test the LWAPI interface
#define GLOB_TYPE_GET_NBSI_DIR       0xfffe     //!< Used to get entire dir, must specify globSource (see _LWAPI_GET_NBSI_OBJ)
#define GLOB_TYPE_GET_NBSI_ACPI_RAW  0xfffd     //!< Used when accessing ACPI via GET NBSI OBJ call. Used by tools.
#define NBSI_FUNC_SUPPORT            0          //!< Function for checking NBSI ACPI support


#define NBSI_SOURCE_LOC LwU16


#define LWAPI_MAX_GET_NBSI_OBJ_SIZE 4096


#define LWAPI_MAX_GET_MAX_GLOB_INDEX 15

//! NBSI object parameters - used in LwAPI_GPU_GetNBSIObj() \n
//! When globtype = GLOB_TYPE_GET_NBSI_ACPI_RAW the following parameter changes are in effect:
//! -(IN) globtype = GLOB_TYPE_GET_NBSI_ACPI_RAW
//! -(OUT) globSource = return status from the ACPI call.
//! -(IN) dataoffset = ACPI function number.
//! -(IN/OUT) inoutdata (instead of "data") = Data to or from the ACPI call (must be <= 4K!)
//! -(IN/OUT) pSizeOfData In = size of inoutdata, Out = size returned from the ACPI call.
typedef struct _LWAPI_GET_NBSI_OBJ
{
    LwU32 version;                              //!< (IN) Structure version obtained from the macro #LWAPI_GET_NBSI_OBJ_VER
    LwU16 globType;                             //!< (IN) The glob Type for the NBSI object to get.
    LwU8  globIndex;                            //!< (IN/OUT) IN: The glob Index for the object to get (0..15) 0=best fit, 1=1st instance, 2=2nd instance etc.)
                                                //!<         OUT: The actual index found for the specified object
    NBSI_SOURCE_LOC globSource;                 //!< (IN/OUT) IN: Source of directory to get glob from (0=normal search sequence, 1..x specific dir location).
                                                //!<         OUT: Actual directory source object was found at.
    LwU32 dataOffset;                           //!< (IN) Starting data offset within the NBSI object to return (when doing multiple calls... 0=beginning of object)
    LwU8  data[LWAPI_MAX_GET_NBSI_OBJ_SIZE];    //!< (OUT) Buffer to hold return data
    LwU32 pSizeOfData;                          //!< (IN/OUT) IN: Contains the size of the data buffer
                                                //!<         OUT: Contains the amount of the data buffer filled
    LwU32 totalObjSize;                         //!< (OUT) Total size of the entire object (may exceed pSizeOfData)
    LWAPI_BIOS_NBSI_ERROR_CODES pNbsiErrorCode; //!< (OUT) NBSI error values returned
} LWAPI_GET_NBSI_OBJ;



//! Macro for constructing the version field of LWAPI_GET_NBSI_OBJ
#define LWAPI_GET_NBSI_OBJ_VER  MAKE_LWAPI_VERSION(LWAPI_GET_NBSI_OBJ,1)

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetNBSIObj
//
//! DESCRIPTION: This function sends and retrieves generic notebook system information (NBSI) objects (GLOBs).
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 175
//!
//!  \param [in]      hPhysicalGpu      GPU selection.
//!  \param [in/out]  getNbsiObjParms   LWAPI_GET_NBSI_OBJ packet containing requested/returned NBSI object.
//!
//!  \retval ::LWAPI_ILWALID_ARGUMENT
//!  \retval ::LWAPI_OK  *data contains NBSI parameter value (including error code in pNbsiErrorCode on failure).
//!  \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND
//!  \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE
//!
//!  \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetNBSIObj(LwPhysicalGpuHandle hPhysicalGpu, LWAPI_GET_NBSI_OBJ * getNbsiObjParms);




//! \addtogroup gpu
//! Used in _LW_IMP_MODE.
//! @{
#define LW_IMP_INTERLACED                         0
#define LW_IMP_PROGRESSIVE                        1
#define LW_IMP_VERTICAL_TAPS1                     2
#define LW_IMP_VERTICAL_TAPS2                     3
#define LW_IMP_VERTICAL_TAPS3                     4
#define LW_IMP_VERTICAL_TAPS3_ADAPTIVE            5
#define LW_IMP_VERTICAL_TAPS5                     6
#define LW_IMP_HORIZONTAL_TAPS1                   7
#define LW_IMP_HORIZONTAL_TAPS2                   8
#define LW_IMP_HORIZONTAL_TAPS8                   9
#define LW_IMP_FORMAT_I8                          10
#define LW_IMP_FORMAT_VOID16                      11
#define LW_IMP_FORMAT_VOID32                      12
#define LW_IMP_FORMAT_RF16_GF16_BF16_AF16         13
#define LW_IMP_FORMAT_A8R8G8B8                    14
#define LW_IMP_FORMAT_A2B10G10R10                 15
#define LW_IMP_FORMAT_A8B8G8R8                    16
#define LW_IMP_FORMAT_R5G6B5                      17
#define LW_IMP_FORMAT_A1R5G5B5                    18
#define LW_IMP_SS_X1AA                            19
#define LW_IMP_SS_X4AA                            20
#define LW_IMP_BASE_USAGE_BOUNDS_USABLE_LWRRENT   21
#define LW_IMP_BASE_USAGE_BOUNDS_USABLE_NO        22
#define LW_IMP_BASE_USAGE_BOUNDS_USABLE_YES       23
#define LW_IMP_BASE_USAGE_BOUNDS_DEPTH_LWRRENT    24
#define LW_IMP_BASE_USAGE_BOUNDS_DEPTH_8          25
#define LW_IMP_BASE_USAGE_BOUNDS_DEPTH_16         26
#define LW_IMP_BASE_USAGE_BOUNDS_DEPTH_32         27
#define LW_IMP_BASE_USAGE_BOUNDS_DEPTH_64         28
#define LW_IMP_BASE_USAGE_BOUNDS_SS_LWRRENT       29
#define LW_IMP_BASE_USAGE_BOUNDS_SS_X1AA          30
#define LW_IMP_BASE_USAGE_BOUNDS_SS_X4AA          31
//! @}

//! \ingroup gpu
//! Used in LwAPI_IsModePossible(). 
typedef struct _LW_IMP_MODE
{
    LwU32 PixelClock;
    LwU32 RasterWidth;
    LwU32 RasterHeight;
    LwU32 RasterBlankStartX;
    LwU32 RasterBlankStartY;
    LwU32 RasterBlankEndX;
    LwU32 RasterBlankEndY;
    LwU32 RasterVertBlank2YStart;
    LwU32 RasterVertBlank2YEnd;
    LwU32 ViewportOutWidth;
    LwU32 ViewportOutHeight;
    LwU32 ViewportOutMinWidth;
    LwU32 ViewportOutMinHeight;
    LwU32 ViewportInWidth;
    LwU32 ViewportInHeight;

    LwU32 OverlayBpp;
        
    LwU32 Interlaced;

    struct
    {
        LwU32 VerticalTaps;
        LwU32 HorizontalTaps;
    } OutputScaler;

    struct
    {
        LwU32 Format;
        LwU32 SuperSample;
    } Params;

    struct
    {
        LwU32 Usable;
        LwU32 PixelDepth;
        LwU32 SuperSample;
    } BaseUsageBounds;
} LW_IMP_MODE;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Disp_ConstructIMPMode
//
//! \code
//! PARAMETERS:    pDispPath    (IN)  - Pointer to a display path
//!                pIMPMode     (OUT) - IMP version of display path
//!
//!
//!    FOR INTERNAL TOOL USE ONLY
//!
//!
//! SUPPORTED OS:  Windows Vista and higher,  Mac OS X
//!
//! DESCRIPTION:   This function will colwert the mode data from the
//!                pDispPath input to the display driver version of the
//!                IMP structure used for IsModePossible calls.
//!
//! RETURN STATUS:
//!                LWAPI_OK                  - completed request
//!                LWAPI_API_NOT_INITIALIZED - lwapi not initialized
//!                LWAPI_ERROR               - miscellaneous error oclwrred
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Disp_ConstructIMPMode(LW_DISP_PATH *pPath, LW_IMP_MODE *pIMPMode);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_IsModePossible
//
//! DESCRIPTION:  This function returns whether a given list of modes (one per head) are possible. 
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 173
//!
//! \param [in]   lwGPUHandle    GPU selection
//! \param [in]   mode           Array of modes; one per head
//! \param [in]   modeCount      Number of modes in the array
//! \param [out]  impResult      Boolean: zero=mode not possible, one=mode possible
//!
//! \retval       LWAPI_API_NOT_INTIALIZED  You must call LwAPI_Initialize first.
//! \retval       LWAPI_ERROR               One of three things went wrong:
//!                                          - modeCount is zero
//!                                          - A value in the LW_IMP_MODE structure is invalid
//!                                          - The RM control call failed
//! \retval       LWAPI_NO_IMPLEMENTATION   Only available for up to two heads.
//! \retval       LWAPI_OK                  impResult holds the return value.
//!
//! \ingroup gpu 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_IsModePossible(LwPhysicalGpuHandle lwGPUHandle, LW_IMP_MODE *mode, LwU32 modeCount, LwU8 *impResult);




//! \ingroup gpu
//! @{

#define LW_MAX_LINES_PER_IMP_LOG_ENTRY                     180
#define LW_FLAGS_CMDLINE_SHOW_IMPOSSIBLE_ENTRIES_ONLY      0x01
#define LW_FLAGS_CMDLINE_SHOW_POSSIBLE_ENTRIES_ONLY        0x02
#define LW_FLAGS_CMDLINE_READ_LAST_N_ENTRIES               0x04
#define LW_FLAGS_CMDLINE_RESET_IMP_LOG_ONLY                0x08

typedef struct _LW_IMP_LOG_ENTRY
{
    LwU32 lineCount;
    LwAPI_ShortString line[LW_MAX_LINES_PER_IMP_LOG_ENTRY];
} LW_IMP_LOG_ENTRY;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DIAG_GetIsModePossibleLog
//
//! \code
//! PARAMETERS:    lwGPUHandle(IN)          - GPU selection
//!                pTextLog(OUT)            - Array of IMP Log entries in text format
//!                pCount(IN/OUT)           - Number of IMP Log entries
//!                nCount(IN)               - Number of recent entries to return 
//!                flags(IN)                - Flags defining which entries to return
//!
//! DESCRIPTION:   When called with pTextLog = NULL, returns the number of IMP log entries in pCount.
//!                When called with a valid pointer in pTextLog and non zero value through pCount, returns the array of log entries
//!                based on the value of flags:
//!                flags = 0 : Return all entries 
//!                flags = 1 : Return impossible entries only
//!                            (LW_FLAGS_CMDLINE_SHOW_IMPOSSIBLE_ENTRIES_ONLY)
//!                flags = 2 : Return possible entries only
//!                            (LW_FLAGS_CMDLINE_SHOW_POSSIBLE_ENTRIES_ONLY)
//!                flags = 4 : Return last nCount entries
//!                            (LW_FLAGS_CMDLINE_READ_LAST_N_ENTRIES)
//!                flags = 5 : Return last nCount impossible entries only
//!                            (LW_FLAGS_CMDLINE_READ_LAST_N_ENTRIES | LW_FLAGS_CMDLINE_SHOW_IMPOSSIBLE_ENTRIES_ONLY)
//!                flags = 6 : Return last nCount possible entries only
//!                            (LW_FLAGS_CMDLINE_READ_LAST_N_ENTRIES | LW_FLAGS_CMDLINE_SHOW_POSSIBLE_ENTRIES_ONLY)
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: LWAPI_API_NOT_INTIALIZED: You must call LwAPI_Initialize first.
//!                LWAPI_ERROR:              miscellaneous error oclwrred
//!                LWAPI_NOT_SUPPORTED       this feature is not supported on this GPU
//!                LWAPI_OK:                 completed request.
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DIAG_GetIsModePossibleLog(LwPhysicalGpuHandle lwGPUHandle, LW_IMP_LOG_ENTRY *pTextLog, LwU32 *pCount, LwU32 nCount, LwU32 flags);

//! @}





//! \ingroup gpu
//! Used in _LW_DISPLAY_CRC_CONFIG.
typedef enum
{
    LW_DISPLAY_CRC_CONTROL_CHANNEL_CORE,
    LW_DISPLAY_CRC_CONTROL_CHANNEL_BASE,
    LW_DISPLAY_CRC_CONTROL_CHANNEL_OVERLAY,
    LW_DISPLAY_CRC_CONTROL_CHANNEL_COUNT     //!< always last 
} LW_DISPLAY_CRC_CONTROL_CHANNEL;


//! \addtogroup gpu
//! Used in _LW_DISPLAY_CRC_CONFIG.
//! @{
typedef LwU32 LW_DISPLAY_CRC_CONTROL;
#define LW_DISPLAY_CRC_CONTROL_EXPECT_BUFFER_COLLAPSE    (1 << 0)
#define LW_DISPLAY_CRC_CONTROL_TIMESTAMP_MODE            (1 << 1)
#define LW_DISPLAY_CRC_CONTROL_FLIP_LOCK_MODE            (1 << 2)
#define LW_DISPLAY_CRC_CONTROL_CRC_DURING_SNOOZE         (1 << 3)
#define LW_DISPLAY_CRC_CONTROL_LEGACY_COMPUTE            (1 << 4)
#define LW_DISPLAY_CRC_CONTROL_ACTIVE_RASTER             (1 << 5)
#define LW_DISPLAY_CRC_CONTROL_COMPLETE_RASTER           (1 << 6)
#define LW_DISPLAY_CRC_CONTROL_NON_ACTIVE_RASTER         (1 << 7)
//! @}


//! \ingroup gpu
//! Display CRC configuration - used in LwAPI_SetDisplayCrcConfig().
typedef struct _LW_DISPLAY_CRC_CONFIG
{
    LW_DISPLAY_CRC_CONTROL            crcControl;
    LW_DISPLAY_CRC_CONTROL_CHANNEL    controlChannel;  //!< See #LW_DISPLAY_CRC_CONTROL_CHANNEL.
} LW_DISPLAY_CRC_CONFIG;



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SetDisplayCrcConfig
//
//! DESCRIPTION:   This function configures and starts the CRC collection on the display 
//!                output of the requested GPU.
//!
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 177
//!
//!   \param [in] lwGPUHandle          GPU selection
//!   \param [in] displayOutputId      Display output ID - See \ref handles.
//!   \param [in] pDisplayCrcConfig    CRC configuration 
//!
//!   \retval     LWAPI_API_NOT_INTIALIZED   Must call LwAPI_Initialize first.
//!   \retval     LWAPI_ERROR  
//!   \retval     LWAPI_OK                   Successfully configured the CRC notifier.
//!
//!   \ingroup    gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetDisplayCrcConfig(LwPhysicalGpuHandle lwGPUHandle, LwU32 displayOutputId, LW_DISPLAY_CRC_CONFIG *pDisplayCrcConfig);


//! \addtogroup gpu
//! Used in _LW_DISPLAY_CRC_ENTRY.
//! @{
typedef LwU32 LW_DISPLAY_CRC_ENTRY_FLAG;
#define LW_DISPLAY_CRC_ENTRY_FLAG_TIMESTAMP_MODE        (1 << 0)
#define LW_DISPLAY_CRC_ENTRY_FLAG_HW_FLIP_LOCK_MODE      (1 << 1)
#define LW_DISPLAY_CRC_ENTRY_FLAG_PRESENT_INTERVAL_MET  (1 << 2)
//! @}


//! \ingroup gpu
//! Used in LwAPI_ReadDisplayCrcData().
typedef struct _LW_DISPLAY_CRC_ENTRY
{
    LW_DISPLAY_CRC_ENTRY_FLAG    flag;
    LwU32                        auditTimeStamp;
    LwU32                        tag;
    LwU32                        compositorCrc;
    LwU32                        primaryOutputCrc;
    LwU32                        secondaryOutputCrc;
} LW_DISPLAY_CRC_ENTRY;


//! \addtogroup gpu
//! Used in _LW_DISPLAY_CRC_DATA_STATUS.
//! @{ 
typedef LwU32 LW_DISPLAY_CRC_STATUS;
#define LW_DISPLAY_CRC_STATUS_DONE                      (1 << 0)
#define LW_DISPLAY_CRC_STATUS_OVERRUN                   (1 << 1)
#define LW_DISPLAY_CRC_STATUS_DSI_OVERFLOW              (1 << 2)
#define LW_DISPLAY_CRC_STATUS_COMPOSITOR_OVERFLOW       (1 << 3)
#define LW_DISPLAY_CRC_STATUS_PRIMARY_OUTPUT_OVERFLOW   (1 << 4)
#define LW_DISPLAY_CRC_STATUS_SECONDARY_OUTPUT_OVERFLOW (1 << 5)
#define LW_DISPLAY_CRC_STATUS_EXPECT_BUFFER_COLLAPSE    (1 << 6)
#define LW_DISPLAY_CRC_STATUS_BUSY                      (1 << 7)
//! @}


//! \ingroup gpu
//! Used in LwAPI_ReadDisplayCrcData().
typedef struct _LW_DISPLAY_CRC_DATA_STATUS
{
    LW_DISPLAY_CRC_STATUS   crcStatus;       //!< Status of the data read    
    LwU32                   readEntryCount;  //!< Number of read entries
} LW_DISPLAY_CRC_DATA_STATUS;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_ReadDisplayCrcData
//
//! DESCRIPTION:   Read one CRC entry from the output display of the requested GPU.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 177
//!
//!  \param [in]   lwGPUHandle       GPU selection
//!  \param [in]   displayOutputId   Display output selection - See \ref handles.
//!  \param [out]  pCrcEntryArray    CRC data entry
//!  \param [out]  pCrcDataStatus    CRC data status
//!  \param [out]  arrayEntryCount   
//!
//!  \retval       LWAPI_API_NOT_INTIALIZED  You must call LwAPI_Initialize first.
//!  \retval       LWAPI_ERROR 
//!  \retval       LWAPI_OK                  impResult holds the return value. See LwAPI_IsModePossible().
//!
//!  \ingroup      gpu  
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_ReadDisplayCrcData(LwPhysicalGpuHandle lwGPUHandle, LwU32 displayOutputId, LW_DISPLAY_CRC_DATA_STATUS *pCrcDataStatus, LW_DISPLAY_CRC_ENTRY *pCrcEntryArray, LwU32 arrayEntryCount);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_QueryActiveApps
//
//! DESCRIPTION:     Query all applications running on the specified GPU.
//!
//! \param [in]      hPhysicalGpu   Physical GPU Handle for which apps will be retrieved. To get the list of apps on all GPUs, pass LWAPI_DEFAULT_HANDLE.
//! \param [in,out]  apps           Empty structure passed as an input and upon successful exit, it contains list of apps.
//! \param [in,out]  total          Total number of apps lwrrently running.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS:
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_QueryActiveApps(LwPhysicalGpuHandle hPhysicalGpu, LW_3D_APP_INFO apps[LWAPI_MAX_3D_Apps] , LwU32 *total);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetPowerConnectorStatus
//                     
//! DESCRIPTION:     This API provides the number of external power connector(s) on the GPU board 
//!                  and their connection status.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 177
//!
//!  \param [in]    hPhysicalGpu            GPU selection.
//!  \param [out]   pConnectorCount         Number of the power connector(s) present on the GPU Board
//!  \param [out]   pConnectionAtBoot       Mask of the power connector(s) connected at the boot time
//!  \param [out]   pLwrrentConnection      Mask of the power connector(s) connected lwrrently
//! 
//!  \retval        LWAPI_OK                           - Completed request
//!  \retval        LWAPI_ERROR                        - Miscellaneous error oclwrred
//!  \retval        LWAPI_HANDLE_ILWALIDATED           - handle passed has been ilwalidated (see user guide)
//!  \retval        LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!
//!  \ingroup       gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPowerConnectorStatus(LwPhysicalGpuHandle hPhysicalGpu, LwU32 *pConnectorCount, LwU32 *pConnectionAtBoot, LwU32 *pLwrrentConnection);



//! \ingroup gpu
//! @{

typedef enum
{
    LW_GPU_NETLIST_REV0 = 0x00000012,
    LW_GPU_NETLIST_REV1 = 0x00000013
} LW_GPU_NETLIST_REV;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetNetlistIdentifier
//
//! \code
//! PARAMETERS:      hPhysicalGpu(IN) - GPU selection.
//!                  revIndex(IN)     - Rev index to specify the emulation register.
//!                  pValue(OUT)      - Pointer to a variable to get the netlist data value from rev index passed. 
//!                     
//! DESCRIPTION:     This API gets the netlist data values from emulation registers.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! HOW TO USE:      LW_GPU_NETLIST_REV index= LW_GPU_NETLIST_REV0 or LW_GPU_NETLIST_REV1;
//!                  ret = LwAPI_GPU_GetNetlistIdentifier(hPhysicalGpu, index, &Value);  
//!                  On call success:
//!                  ValReg would contain the netlist data value corresponding to the index passed   
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_NOT_SUPPORTED - functionality not supported 
//!                  LWAPI_ILWALID_HANDLE - physical GPU not found
//!                  LWAPI_ILWALID_ARGUMENT - invalid arugument passed
//!                  LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!                  LWAPI_API_NOT_INITIALIZED - lwapi not initialized
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetNetlistIdentifier(LwPhysicalGpuHandle lwGPUHandle, LW_GPU_NETLIST_REV revIndex, LwU32 *pValue);

//! @}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: LwAPI_GPU_GetPstateLimitsInfo
//
//! \fn 
//! DESCRIPTION:   This API retrieves the list of p-state limiting factors for the specified physical GPU.
//!                      - numLimits is the number of limiting factors returned.
//!
//!                For each limiting factor:
//!                      - limitId is a unique identifier for each limiting factor.
//!                      - limitType is a flag that indicates how the limit is applied (minimum, maximum or both).
//! 
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 175
//!
//! \param [in]   hPhysicalGpu      GPU selection
//! \param [out]  pLimitsInfo       Pointer to the list of p-state limiting factors.

//! \retval    LWAPI_OK                            Completed request
//! \retval    LWAPI_ERROR                         Miscellaneous error oclwrred
//! \retval    LWAPI_ILWALID_ARGUMENT              pDynamicPstatesInfo is NULL
//! \retval    LWAPI_HANDLE_ILWALIDATED            Handle passed has been ilwalidated (see user guide)
//! \retval    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle
//! \retval    LWAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the INFO struct is not supported
//
///////////////////////////////////////////////////////////////////////////////


//! \addtogroup gpupstate
//! @{

//! Used in LW_GPU_PSTATE_LIMITS_INFO.
#define LWAPI_MAX_PSTATE_LIMITS                 64

//
// Any new values must be added to the end
//
//! Performance state limit IDs. Used in LW_GPU_PSTATE_LIMIT_INFO and LW_GPU_PSTATE_LIMIT_STATUS. (limitId)
typedef enum
{
    LWAPI_PSTATE_LIMIT_PERFMON,
    LWAPI_PSTATE_LIMIT_NO_CLIENT,
    LWAPI_PSTATE_LIMIT_SCREEN_SAVER,
    LWAPI_PSTATE_LIMIT_NO_HIRES,
    LWAPI_PSTATE_LIMIT_OS_LEVEL,
    LWAPI_PSTATE_LIMIT_SPDIFF_GLITCH,
    LWAPI_PSTATE_LIMIT_DISPLAY_GLITCH,
    LWAPI_PSTATE_LIMIT_UNLOAD_DRIVER,
    LWAPI_PSTATE_LIMIT_POWERMIZER,
    LWAPI_PSTATE_LIMIT_STRESSTEST_FAILURE,
    LWAPI_PSTATE_LIMIT_RC_ERROR,
    LWAPI_PSTATE_LIMIT_MIN_FAN_LEVEL,
    LWAPI_PSTATE_LIMIT_MCLK_CLONE,
    LWAPI_PSTATE_LIMIT_OVERLAY,
    LWAPI_PSTATE_LIMIT_HIGHRES,
    LWAPI_PSTATE_LIMIT_BANDWIDTHFACTOR,
    LWAPI_PSTATE_LIMIT_HD_FRAMEDROP_WAR,
    LWAPI_PSTATE_LIMIT_ISMODEPOSSIBLE,
    LWAPI_PSTATE_LIMIT_HYBRID,
    LWAPI_PSTATE_LIMIT_ILWALID_SYSCON,
    LWAPI_PSTATE_LIMIT_STRESSTEST_SETUP,
    LWAPI_PSTATE_LIMIT_FORCED,
    LWAPI_PSTATE_LIMIT_FORCED_DACPERFTEST,
    LWAPI_PSTATE_LIMIT_FORCED_ACSHMOO,
    LWAPI_PSTATE_LIMIT_FORCED_STRESSTEST,
    LWAPI_PSTATE_LIMIT_POWERMIZER_HARD,
    LWAPI_PSTATE_LIMIT_THERMAL,
    LWAPI_PSTATE_LIMIT_SYSPERF,
    LWAPI_PSTATE_LIMIT_PWR_SUPPLY_CAPACITY,
    LWAPI_PSTATE_LIMIT_SW_BATTPOWER,
    LWAPI_PSTATE_LIMIT_EXT_PERF_CONTROL,
    LWAPI_PSTATE_LIMIT_MXM_ACPOWER,
    LWAPI_PSTATE_LIMIT_AUX_POWER,
    LWAPI_PSTATE_LIMIT_SHORT_VBLANK,
    LWAPI_PSTATE_LIMIT_POWER_BALANCE,
    LWAPI_PSTATE_LIMIT_BANDWIDTH_HCLONE,
    LWAPI_PSTATE_LIMIT_AUX_PWR_STATE,
} LWAPI_PSTATE_LIMIT;

//! Performance state limit type - undefined. Used in LW_GPU_PSTATE_LIMIT_INFO. 
#define LWAPI_PSTATE_LIMIT_UNDEFINED            0xff

//! Performance state limit type - minimum. Used in LW_GPU_PSTATE_LIMIT_INFO.
#define LWAPI_PSTATE_LIMIT_TYPE_MIN             1

//! Performance state limit type - maximumm. Used in LW_GPU_PSTATE_LIMIT_INFO
#define LWAPI_PSTATE_LIMIT_TYPE_MAX             2

//! Performance state limit type - minimum/maximum. Used in LW_GPU_PSTATE_LIMIT_INFO
#define LWAPI_PSTATE_LIMIT_TYPE_BOTH            3


//! Used in LW_GPU_PSTATE_LIMITS_INFO.
typedef struct
{
    LwU8        limitId;      //!< The unique ID that identifies the limiting factor
    LwU8        limitType;    //!< Flag that indicates how the limit is applied - as a minimum, a maximum, or both.
} LW_GPU_PSTATE_LIMIT_INFO;


//! Used in LwAPI_GPU_GetPstateLimitsInfo90.
typedef struct 
{
    LwU32       version;        //!< Structure version
    LwU32       numLimits;      //!< The number of limiting factors
    LW_GPU_PSTATE_LIMIT_INFO    limitInfoList[LWAPI_MAX_PSTATE_LIMITS];        
} LW_GPU_PSTATE_LIMITS_INFO;


//! Used in LW_GPU_PSTATE_LIMITS_INFO.
#define LW_GPU_PSTATE_LIMITS_INFO_VER MAKE_LWAPI_VERSION(LW_GPU_PSTATE_LIMITS_INFO,1)


//! @}


//! \ingroup   gpupstate
LWAPI_INTERFACE LwAPI_GPU_GetPstateLimitsInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_PSTATE_LIMITS_INFO *pLimitsInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: LwAPI_GPU_GetPstateActiveLimits
//
//! \fn LwAPI_GPU_GetPstateActiveLimits(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_PSTATE_ACTIVE_LIMITS *pActiveLimits)
//! DESCRIPTION:   This API retrieves the list of active p-state limiting factors for the specified physical GPU.
//!                - numLimits is the number of limiting factors returned.
//!                For each limiting factor:
//!                - limitId is a unique ID that identifies the limiting factor.
//!                - pstate is the limit set for the p-state limiting factor.
//! 
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 175
//!
//! \param [in]  hPhysicalGpu   GPU selection
//! \param [out] pActiveLimits  Pointer to the list of active p-state limiting factors.
//!
//! \retval    LWAPI_OK                            Completed request
//! \retval    LWAPI_ERROR                         Miscellaneous error has oclwrred.
//! \retval    LWAPI_ILWALID_ARGUMENT              pDynamicPstatesInfo is NULL.
//! \retval    LWAPI_HANDLE_ILWALIDATED            Handle passed has been ilwalidated (see user guide).
//! \retval    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//! \retval    LWAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the INFO struct is not supported.
//
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup gpupstate
//! @{


//! Used in LW_GPU_PSTATE_ACTIVE_LIMITS.
typedef struct
{
    LwU8        limitId;  //!< Unique ID that identifies the limiting factor
    LwU8        pstate;   //!< The p-state limit that is set for the limiting factor.
} LW_GPU_PSTATE_LIMIT_STATUS;


//! Used in LwAPI_GPU_GetPstateActiveLimits().
typedef struct 
{
    LwU32       version;        //!< Structure version
    LwU32       numLimits;      //!< The number of limiting factors
    LW_GPU_PSTATE_LIMIT_STATUS    limitStatusList[LWAPI_MAX_PSTATE_LIMITS];        
} LW_GPU_PSTATE_ACTIVE_LIMITS;


//! Used in LW_GPU_PSTATE_ACTIVE_LIMITS.
#define LW_GPU_PSTATE_ACTIVE_LIMITS_VER MAKE_LWAPI_VERSION(LW_GPU_PSTATE_ACTIVE_LIMITS,1)

//! @}


//! \ingroup   gpupstate
LWAPI_INTERFACE LwAPI_GPU_GetPstateActiveLimits(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_PSTATE_ACTIVE_LIMITS *pActiveLimits);


//! \addtogroup gpupstate
//! @{


//! Performance limit ids - generic limit entries which can be used to
//! set limits via pstates, frequencies, virtual pstates, etc.
//!
//! Used in the various LwAPI_GPU_PerfLimit<xyz>() APIs below (limitId).
typedef enum _LW_GPU_PERF_LIMIT_ID
{
    LWAPI_PERF_LIMIT_ID_PERFMON             = 0x00000000,
    LWAPI_PERF_LIMIT_ID_NO_CLIENT,
    LWAPI_PERF_LIMIT_ID_SCREEN_SAVER,
    LWAPI_PERF_LIMIT_ID_NO_HIRES,
    LWAPI_PERF_LIMIT_ID_OS_LEVEL,
    LWAPI_PERF_LIMIT_ID_SPDIFF_GLITCH,
    LWAPI_PERF_LIMIT_ID_DISPLAY_GLITCH,
    LWAPI_PERF_LIMIT_ID_UNLOAD_DRIVER,
    LWAPI_PERF_LIMIT_ID_POWERMIZER,
    LWAPI_PERF_LIMIT_ID_STRESSTEST_FAILURE,
    LWAPI_PERF_LIMIT_ID_RC_ERROR,
    LWAPI_PERF_LIMIT_ID_MIN_FAN_LEVEL,
    LWAPI_PERF_LIMIT_ID_MCLK_CLONE,
    LWAPI_PERF_LIMIT_ID_OVERLAY,
    LWAPI_PERF_LIMIT_ID_HIGHRES,
    LWAPI_PERF_LIMIT_ID_BANDWIDTHFACTOR,
    LWAPI_PERF_LIMIT_ID_HD_FRAMEDROP_WAR,
    LWAPI_PERF_LIMIT_ID_ISMODEPOSSIBLE,
    LWAPI_PERF_LIMIT_ID_STRESSTEST_SETUP,
    LWAPI_PERF_LIMIT_ID_FORCED,
    LWAPI_PERF_LIMIT_ID_FORCED_DACPERFTEST,
    LWAPI_PERF_LIMIT_ID_FORCED_STRESSTEST,
    LWAPI_PERF_LIMIT_ID_POWERMIZER_HARD,
    LWAPI_PERF_LIMIT_ID_THERMAL,
    LWAPI_PERF_LIMIT_ID_SYSPERF,
    LWAPI_PERF_LIMIT_ID_PWR_SUPPLY_CAPACITY,
    LWAPI_PERF_LIMIT_ID_SW_BATTPOWER,
    LWAPI_PERF_LIMIT_ID_EXT_PERF_CONTROL,
    LWAPI_PERF_LIMIT_ID_MXM_ACPOWER,
    LWAPI_PERF_LIMIT_ID_AUX_POWER,
    LWAPI_PERF_LIMIT_ID_3D_WAR,
    LWAPI_PERF_LIMIT_ID_DEEP_IDLE,
    LWAPI_PERF_LIMIT_ID_CLIENT_SOFT,
    LWAPI_PERF_LIMIT_ID_CLIENT_HARD,
    LWAPI_PERF_LIMIT_ID_OVERCLOCK,
    LWAPI_PERF_LIMIT_ID_FORCED_LINKTRAIN,
    LWAPI_PERF_LIMIT_ID_POWER_BALANCE,
    LWAPI_PERF_LIMIT_ID_BUG_535734,
    LWAPI_PERF_LIMIT_ID_BOOST,
    LWAPI_PERF_LIMIT_ID_PM_DYNAMIC,
    LWAPI_PERF_LIMIT_ID_MODS_RULES,
    LWAPI_PERF_LIMIT_ID_EXCEPT_VIDEO,
    LWAPI_PERF_LIMIT_ID_SDI_INPUT_CAPTURE,
    LWAPI_PERF_LIMIT_ID_BANDWIDTH_HCLONE,
    LWAPI_PERF_LIMIT_ID_VPS_DISPLAY,
    LWAPI_PERF_LIMIT_ID_VPS,
    LWAPI_PERF_LIMIT_ID_CANOAS_MODE,
    LWAPI_PERF_LIMIT_ID_BUG_660789,
    LWAPI_PERF_LIMIT_ID_P1020_WAR,
    LWAPI_PERF_LIMIT_ID_LOCKED_DRIVER,
    LWAPI_PERF_LIMIT_ID_PMU_OVERRIDE,
    LWAPI_PERF_LIMIT_ID_CLIENT_0_MAX,
    LWAPI_PERF_LIMIT_ID_CLIENT_0_MIN,
    LWAPI_PERF_LIMIT_ID_CLIENT_1_MAX,
    LWAPI_PERF_LIMIT_ID_CLIENT_1_MIN,
    LWAPI_PERF_LIMIT_ID_CLIENT_2_MAX,
    LWAPI_PERF_LIMIT_ID_CLIENT_2_MIN,
    LWAPI_PERF_LIMIT_ID_PERFMON_GROUP_1,
    LWAPI_PERF_LIMIT_ID_PERFMON_GROUP_2,
    LWAPI_PERF_LIMIT_ID_PERFMON_GROUP_3,
    LWAPI_PERF_LIMIT_ID_RATED_TDP,
    LWAPI_PERF_LIMIT_ID_VDT_OVERVOLTAGE,
    LWAPI_PERF_LIMIT_ID_VDT_RELIABILITY,
    LWAPI_PERF_LIMIT_ID_PMU_DOM_GRP_1,
    LWAPI_PERF_LIMIT_ID_AUX_PWR_STATE,
    LWAPI_PERF_LIMIT_ID_PERFORMANCE_CAP,
    LWAPI_PERF_LIMIT_ID_THERM_POLICY_DOM_GRP_0,
    LWAPI_PERF_LIMIT_ID_THERM_POLICY_DOM_GRP_1,
    LWAPI_PERF_LIMIT_ID_VDT_RELIABILITY_ALT,
    LWAPI_PERF_LIMIT_ID_PERFORMANCE_CAP1,
    LWAPI_PERF_LIMIT_ID_RATED_TDP_MIN,
    LWAPI_PERF_LIMIT_ID_INTERNAL_CLIENT_0_MAX,
    LWAPI_PERF_LIMIT_ID_INTERNAL_CLIENT_0_MIN,
    LWAPI_PERF_LIMIT_ID_INTERNAL_CLIENT_1_MAX,
    LWAPI_PERF_LIMIT_ID_INTERNAL_CLIENT_1_MIN,
    LWAPI_PERF_LIMIT_ID_THERM_POLICY_LWVDD,
    LWAPI_PERF_LIMIT_ID_SLI_GPU_BOOST_DOM_GRP_0,
    LWAPI_PERF_LIMIT_ID_SLI_GPU_BOOST_DOM_GRP_1,
    LWAPI_PERF_LIMIT_ID_ISMODEPOSSIBLE_DISP,
    LWAPI_PERF_LIMIT_ID_LWDA_MAX,
    LWAPI_PERF_LIMIT_ID_LAST,                              //!< Must always be last actual limit id
    LWAPI_PERF_LIMIT_ID_MAX_LIMITS          = 0x00000100,  //!< Maximum number of lw_GPU_PERF_LIMITs.  Cannot change this number without changing structure version.
    LWAPI_PERF_LIMIT_ID_UNKNOWN             = 0xFFFFFFFF,  //!< Special value for an unknown limit id
} LW_GPU_PERF_LIMIT_ID;

//! Maximum length of the name string (szName) returned with each
//! LW_GPU_PERF_LIMIT_INFO structure below.
#define LW_GPU_PERF_LIMIT_INFO_NAME_MAX_LENGTH_V1                            32

//! Used in \ref LW_GPU_PERF_LIMIT_INFO.  Flags to represent the following
//! configurations:
//!
//! _MIN
//!     This PERF_LIMIT is a minimum bound.  This flag is not mutually exclusive with
//!     the _MAX flag, if both are set then the PERF_LIMIT locks to the specified
//!     value.
//! _MAX
//!    This PERF_LIMIT is a maximum bound.  This flag is not mutually exclusive with
//!     the _MIN flag, if both are set then the PERF_LIMIT locks to the specified
//!     value.
#define LW_GPU_PERF_LIMIT_INFO_FLAGS_MIN                                     0x1
#define LW_GPU_PERF_LIMIT_INFO_FLAGS_MAX                                     0x2

//! Used in \ref LW_GPU_PERF_LIMITS_INFO_V1.  Describes the static information
//! corresponding to a PERF_LIMIT - such as its string name and direction
//! (min/max).
typedef struct
{
    /*!
     * LW_GPU_PERF_LIMIT_ID for this PERF_LIMIT.
     */
    LW_GPU_PERF_LIMIT_ID limitId;
    /*!
     * Internal RMCTRL id for this PERF_LIMIT - LW2080_CTRL_PERF_LIMIT_<xyz>.
     */
    LwU32                rmLimitId;
    /*!
     * LW_GPU_PERF_LIMIT_INFO_FLAGS_<xyz>
     */
    LwU32                flags;
    /*!
     * Priority of this input - higher number ~ higher priority.
     */
    LwU32                priority;
    /*!
     * User-friendly string name for PERF_LIMIT.
     */
    char                 szName[LW_GPU_PERF_LIMIT_INFO_NAME_MAX_LENGTH_V1];
} LW_GPU_PERF_LIMIT_INFO_V1;

//! Used in \ref LwAPI_GPU_PerfLimitsGetInfo().  Stucture representing the
//! static information for a set of PERF_LIMITs.
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32                     version;
    /*!
     * Flags - lwrrently reserved.
     */
    LwU32                     flags;
    /*!
     * Number of limits specified in the limits array.  Caller sets this value
     * to 0 to specify that all limits should be queried.
     */
    LwU32                     numLimits;
    /*!
     * Array of PERF_LIMIT info entries.  This array has a valid index ranging
     * from 0 to numLimits - 1.
     */
    LW_GPU_PERF_LIMIT_INFO_V1 limits[LWAPI_PERF_LIMIT_ID_MAX_LIMITS];
} LW_GPU_PERF_LIMITS_INFO_V1;

typedef LW_GPU_PERF_LIMITS_INFO_V1 LW_GPU_PERF_LIMITS_INFO;

//! Macro for constructing the version field of LW_GPU_PERF_LIMITS_INFO_V1
#define LW_GPU_PERF_LIMITS_INFO_VER1  MAKE_LWAPI_VERSION(LW_GPU_PERF_LIMITS_INFO_V1,1)

//! Macro for constructing the version field of LW_GPU_PERF_LIMITS
#define LW_GPU_PERF_LIMITS_INFO_VER   LW_GPU_PERF_LIMITS_INFO_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_PerfLimitsGetInfo
//
//! DESCRIPTION:     This function retrieves the static information associated
//!                  with a set of PERF_LIMITs - generic limits on
//!                  performance/clocks as specified by pstate, clock
//!                  domain/frequency, fstate, etc.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 285
//!
//! \param [in]      hPhysicalGPU  GPU selection
//! \param [out]     pLimits       Structure containing the description of a set of PERF_LIMITs.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PerfLimitsGetInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_PERF_LIMITS_INFO *pLimits);

//! @}



//! \addtogroup gpupstate
//! @{

//! Used in \ref LW_GPU_PERF_LIMIT_STATUS_INPUT_V1.  Specifies the type of input
//! value specified to a PERF_LIMIT - pstate, clock domain/frequency, etc.
typedef enum _LW_GPU_PERF_LIMIT_STATUS_INPUT_TYPE
{
    LWAPI_PERF_LIMIT_STATUS_INPUT_TYPE_DISABLED    = 0x00000000,
    LWAPI_PERF_LIMIT_STATUS_INPUT_TYPE_PSTATE,
    LWAPI_PERF_LIMIT_STATUS_INPUT_TYPE_FREQ,
    LWAPI_PERF_LIMIT_STATUS_INPUT_TYPE_VPSTATE,
    LWAPI_PERF_LIMIT_STATUS_INPUT_TYPE_VOLTAGE,                  //!< Now depreciated for _EX version
    LWAPI_PERF_LIMIT_STATUS_INPUT_TYPE_VOLTAGE_EX,
    LWAPI_PERF_LIMIT_STATUS_INPUT_TYPE_UNSUPPORTED = 0xFFFFFFFF, //!< Should always be last
} LW_GPU_PERF_LIMIT_STATUS_INPUT_TYPE;

//! Used in \ref LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V1.  Data specific to the
//! _PSTATE PERF_LIMIT input type.
typedef struct
{
    /*!
     * Flags - lwrrently reserved.
     */
    LwU32                 flags;
    /*!
     * Pstate ID at which to apply the limitiation.
     */
    LW_GPU_PERF_PSTATE_ID pstateId;
} LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_PSTATE;

//! Used in \ref LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V1.  Data specific to the
//! _FREQ PERF_LIMIT input type.
typedef struct
{
    /*!
     * Flags - lwrrently reserved.
     */
    LwU32                  flags;
    /*!
     * Clock frequency at which to apply the limit.
     */
    LwU32                  freqKHz;
    /*!
     * Clock domain on which to apply the limit.
     */
    LW_GPU_CLOCK_DOMAIN_ID domainId;
} LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_FREQ;

//! Used in \ref LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V1.  Data specific to the
//! _VPSTATE PERF_LIMIT input type.
typedef struct
{
    /*!
     * Flags - lwrrently reserved.
     */
    LwU32                  flags;
    /*!
     * vP-state at which to apply the limit.
     */
    LwU32                  vpstate;
} LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VPSTATE;

//! Used in \ref LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V2.  Data specific to the
//! _VOLTAGE PERF_LIMIT input type.
typedef struct
{
    /*!
     * Domain group index specified as input.
     */
    LwU32                         domGrpIdx;
    /*!
     * ID of the voltage domain
     */
    LW_GPU_PERF_VOLTAGE_DOMAIN_ID domainId;
    /*!
     * Flags - bit 0 indicates that mvolt is evaluated from VDT
     */
    LwU32                         flags;
    /*!
     * Voltage in uV.
     */
    LwU32                         voltageuV;
} LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE;

//! Used in \ref LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V3.  Data specific to the
//! _VOLTAGE PERF_LIMIT_EX input type.
typedef struct
{
    /*!
     * Domain group index specified as input.
     */
    LwU32                               domGrpIdx;
    /*!
     * Voltage data.
     */
    LW_GPU_PSTATE20_VOLTAGE_ENTRY_V1    volt;
} LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE_EX;

//! Used in \ref LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V4.  Data specific to the
//! _VOLTAGE PERF_LIMIT_EX input type.
typedef struct
{
    /*!
     * Decoupled clock domain ID which this PERF_LIMIT is limiting.
     * LWAPI_GPU_CLOCK_DOMAIN_UNDEFINED is used for P-state limits.
     */
    LW_GPU_CLOCK_DOMAIN_ID              decoupledClockId;
    /*!
     * Voltage data.
     */
    LW_GPU_PSTATE20_VOLTAGE_ENTRY_V1    volt;
} LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE_EX2;

//! Used in \ref LW_GPU_PERF_LIMIT_STATUS_INPUT_V1.  Union of type-specific
//! input data.
typedef union
{
    /*!
     * Pstate type-specific data.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_PSTATE pstate;
    /*!
     * Clock domain/frequency type-specific data.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_FREQ   freq;
    /*!
     * vP-state type-specific data.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VPSTATE vpstate;
} LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V1;

//! Used in \ref LW_GPU_PERF_LIMIT_STATUS_INPUT_V2.  Union of type-specific
//! input data.
typedef union
{
    /*!
     * Pstate type-specific data.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_PSTATE pstate;
    /*!
     * Clock domain/frequency type-specific data.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_FREQ   freq;
    /*!
     * vP-state type-specific data.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VPSTATE vpstate;
    /*!
    * Voltage type-specific data.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE volt;
} LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V2;

//! Used in \ref LW_GPU_PERF_LIMIT_STATUS_INPUT_V3.  Union of type-specific
//! input data.
typedef union
{
    /*!
     * Pstate type-specific data.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_PSTATE     pstate;
    /*!
     * Clock domain/frequency type-specific data.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_FREQ       freq;
    /*!
     * vP-state type-specific data.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VPSTATE    vpstate;
    /*!
    * Voltage type-specific data.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE    volt;
    /*!
    * Extended Voltage type-specific data.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE_EX voltEx;
} LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V3;

//! Used in \ref LW_GPU_PERF_LIMIT_STATUS_INPUT_V4.  Union of type-specific
//! input data.
typedef union
{
    /*!
     * Pstate type-specific data.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_PSTATE      pstate;
    /*!
     * Clock domain/frequency type-specific data.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_FREQ        freq;
    /*!
     * vP-state type-specific data.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VPSTATE     vpstate;
    /*!
    * Extended Voltage type-specific data.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE_EX2 voltEx;
} LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V4;

//! Used in \ref LW_GPU_PERF_LIMIT_STATUS_V1.  Structure representing the input
//! specified to configure the PERF_LIMIT.
typedef struct
{
    /*!
     * Flags - lwrrently reserved.
     */
    LwU32                                  flags;
    /*!
     * The type of data used to specify the PERF_LIMIT.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_TYPE    type;
    /*!
     * Type-specific data used to specify the PERF_LIMIT.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V1 data;
} LW_GPU_PERF_LIMIT_STATUS_INPUT_V1;

//! Used in \ref LW_GPU_PERF_LIMIT_STATUS_V2.  Structure representing the input
//! specified to configure the PERF_LIMIT.
typedef struct
{
    /*!
     * Flags - lwrrently reserved.
     */
    LwU32                                  flags;
    /*!
     * The type of data used to specify the PERF_LIMIT.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_TYPE    type;
    /*!
     * Type-specific data used to specify the PERF_LIMIT.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V2 data;
} LW_GPU_PERF_LIMIT_STATUS_INPUT_V2;

//! Used in \ref LW_GPU_PERF_LIMIT_STATUS_V3.  Structure representing the input
//! specified to configure the PERF_LIMIT.
typedef struct
{
    /*!
     * Flags - lwrrently reserved.
     */
    LwU32                                  flags;
    /*!
     * The type of data used to specify the PERF_LIMIT.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_TYPE    type;
    /*!
     * Type-specific data used to specify the PERF_LIMIT.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V3 data;
} LW_GPU_PERF_LIMIT_STATUS_INPUT_V3;

//! Used in \ref LW_GPU_PERF_LIMIT_STATUS_V4.  Structure representing the input
//! specified to configure the PERF_LIMIT.
typedef struct
{
    /*!
     * Flags - lwrrently reserved. Must be set to 0.
     */
    LwU32                                  flags;
    /*!
     * The type of data used to specify the PERF_LIMIT.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_TYPE    type;
    /*!
     * Type-specific data used to specify the PERF_LIMIT.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V4 data;
} LW_GPU_PERF_LIMIT_STATUS_INPUT_V4;

//! Used in \ref LW_GPU_PERF_LIMIT_STATUS_V1.  Structure representing the output
//! of the PERF_LIMIT corresponding to the input supplied.  This is all internal
//! RM domain group information representing how the RM is enforcing this
//! policy.
typedef struct
{
    /*!
     * Flags - lwrrently reserved.
     */
    LwU32 flags;
    /*!
     * Boolean indicating whether the PERF_LIMIT is lwrrently enabled.
     */
    LwU8  bEnabled;
    /*!
     * Internal RM index of the domain group which this PERF_LIMIT is limiting.
     */
    LwU32 domainGroupIdx;
    /*!
     * Domain-group-specific value to which this PERF_LIMIT is limiting.
     */
    LwU32 value;
} LW_GPU_PERF_LIMIT_STATUS_OUTPUT_V1;

//! Used in \ref LW_GPU_PERF_LIMIT_STATUS_V4.  Structure representing the output
//! of the PERF_LIMIT corresponding to the input supplied.  This is all internal
//! RM information representing how the RM is enforcing this policy.
typedef struct
{
    /*!
     * Flags - lwrrently reserved. Must be set to 0.
     */
    LwU32                  flags;
    /*!
     * Boolean indicating whether the PERF_LIMIT is lwrrently enabled.
     */
    LwU8                   bEnabled;
    /*!
     * Decoupled clock domain ID which this PERF_LIMIT is limiting.
     * LWAPI_GPU_CLOCK_DOMAIN_UNDEFINED is used for P-state limits.
     */
    LW_GPU_CLOCK_DOMAIN_ID decoupledClockId;
    /*!
     * Internal frequency or P-state value to which this PERF_LIMIT is limiting.
     */
    LwU32                  value;
} LW_GPU_PERF_LIMIT_STATUS_OUTPUT_V4;

//! Used in \ref LW_GPU_PERF_LIMITS_STATUS_V1.  Structure representing the
//! current (or desired) status/settings of a PERF_LIMIT.  Can be used for both
//! an accessor and mutator for a PERF_LIMIT.
typedef struct
{
    /*!
     * LW_GPU_PERF_LIMIT_ID for this PERF_LIMIT.
     */
    LW_GPU_PERF_LIMIT_ID               limitId;
    /*!
     * Internal RM id for this PERF_LIMIT - LW2080_CTRL_PERF_LIMIT_<xyz>
     */
    LwU32                              rmLimitId;
    /*!
     * Flags - lwrrently reserved.
     */
    LwU32                              flags;
    /*!
     * PERF_LIMIT input parameters.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_V1  input;
    /*!
     * PERF_LIMIT output parameters.
     */
    LW_GPU_PERF_LIMIT_STATUS_OUTPUT_V1 output;
} LW_GPU_PERF_LIMIT_STATUS_V1;

//! Used in \ref LW_GPU_PERF_LIMITS_STATUS_V2.  Structure representing the
//! current (or desired) status/settings of a PERF_LIMIT.  Can be used for both
//! an accessor and mutator for a PERF_LIMIT.
typedef struct
{
    /*!
     * LW_GPU_PERF_LIMIT_ID for this PERF_LIMIT.
     */
    LW_GPU_PERF_LIMIT_ID               limitId;
    /*!
     * Internal RM id for this PERF_LIMIT - LW2080_CTRL_PERF_LIMIT_<xyz>
     */
    LwU32                              rmLimitId;
    /*!
     * Flags - lwrrently reserved.
     */
    LwU32                              flags;
    /*!
     * PERF_LIMIT input parameters.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_V2  input;
    /*!
     * PERF_LIMIT output parameters.
     */
    LW_GPU_PERF_LIMIT_STATUS_OUTPUT_V1 output;
} LW_GPU_PERF_LIMIT_STATUS_V2;

//! Used in \ref LW_GPU_PERF_LIMITS_STATUS_V3.  Structure representing the
//! current (or desired) status/settings of a PERF_LIMIT.  Can be used for both
//! an accessor and mutator for a PERF_LIMIT.
typedef struct
{
    /*!
     * LW_GPU_PERF_LIMIT_ID for this PERF_LIMIT.
     */
    LW_GPU_PERF_LIMIT_ID               limitId;
    /*!
     * Internal RM id for this PERF_LIMIT - LW2080_CTRL_PERF_LIMIT_<xyz>
     */
    LwU32                              rmLimitId;
    /*!
     * Flags - lwrrently reserved.
     */
    LwU32                              flags;
    /*!
     * PERF_LIMIT input parameters.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_V3  input;
    /*!
     * PERF_LIMIT output parameters.
     */
    LW_GPU_PERF_LIMIT_STATUS_OUTPUT_V1 output;
} LW_GPU_PERF_LIMIT_STATUS_V3;

//! Used in \ref LW_GPU_PERF_LIMITS_STATUS_V4.  Structure representing the
//! current (or desired) status/settings of a PERF_LIMIT.  Can be used for both
//! an accessor and mutator for a PERF_LIMIT.
typedef struct
{
    /*!
     * LW_GPU_PERF_LIMIT_ID for this PERF_LIMIT.
     */
    LW_GPU_PERF_LIMIT_ID               limitId;
    /*!
     * Internal RM id for this PERF_LIMIT - LW2080_CTRL_PERF_LIMIT_<xyz>
     */
    LwU32                              rmLimitId;
    /*!
     * Flags - lwrrently reserved.
     */
    LwU32                              flags;
    /*!
     * PERF_LIMIT input parameters.
     */
    LW_GPU_PERF_LIMIT_STATUS_INPUT_V4  input;
    /*!
     * PERF_LIMIT output parameters.
     */
    LW_GPU_PERF_LIMIT_STATUS_OUTPUT_V4 output;
} LW_GPU_PERF_LIMIT_STATUS_V4;

//! Used in \ref LwAPI_GPU_PerfLimitsGetStatus().  Structure represents a
//! requested set of PERF_LIMITs for which to query or set current
//! status/settings.
typedef struct
{
    /*!
     * Structure version.  Must always be frist.
     */
    LwU32                       version;
    /*!
     * Flags - lwrrently reserved.
     */
    LwU32                       flags;
    /*!
     * Number of limits specified in the limits array.  Caller sets this value
     * to 0 to specify that all limits should be queried.
     */
    LwU32                       numLimits;
    /*!
     * Array of PERF_LIMIT status entries.  This array has a valid index ranging
     * from 0 to numLimits - 1.
     */
    LW_GPU_PERF_LIMIT_STATUS_V1 limits[LWAPI_PERF_LIMIT_ID_MAX_LIMITS];
} LW_GPU_PERF_LIMITS_STATUS_V1;

//! Used in \ref LwAPI_GPU_PerfLimitsGetStatus().  Structure represents a
//! requested set of PERF_LIMITs for which to query or set current
//! status/settings.
typedef struct
{
    /*!
     * Structure version.  Must always be first.
     */
    LwU32                       version;
    /*!
     * Flags - lwrrently reserved.
     */
    LwU32                       flags;
    /*!
     * Number of limits specified in the limits array.  Caller sets this value
     * to 0 to specify that all limits should be queried.
     */
    LwU32                       numLimits;
    /*!
     * Array of PERF_LIMIT status entries.  This array has a valid index ranging
     * from 0 to numLimits - 1.
     */
    LW_GPU_PERF_LIMIT_STATUS_V2 limits[LWAPI_PERF_LIMIT_ID_MAX_LIMITS];
} LW_GPU_PERF_LIMITS_STATUS_V2;

//! Used in \ref LwAPI_GPU_PerfLimitsSetStatus().  Structure represents a
//! requested set of PERF_LIMITs for which to query or set current
//! status/settings.
typedef struct
{
    /*!
     * Structure version.  Must always be first.
     */
    LwU32                       version;
    /*!
     * Flags - lwrrently reserved.
     */
    LwU32                       flags;
    /*!
     * Number of limits specified in the limits array.  Caller sets this value
     * to 0 to specify that all limits should be queried.
     */
    LwU32                       numLimits;
    /*!
     * Array of PERF_LIMIT status entries.  This array has a valid index ranging
     * from 0 to numLimits - 1.
     */
    LW_GPU_PERF_LIMIT_STATUS_V3 limits[LWAPI_PERF_LIMIT_ID_MAX_LIMITS];
} LW_GPU_PERF_LIMITS_STATUS_V3;

//! Used in \ref LwAPI_GPU_PerfLimitsSetStatus().  Structure represents a
//! requested set of PERF_LIMITs for which to query or set current
//! status/settings.
typedef struct
{
    /*!
     * Structure version.  Must always be first.
     */
    LwU32                       version;
    /*!
     * Flags - lwrrently reserved.
     */
    LwU32                       flags;
    /*!
     * Number of limits specified in the limits array.  Caller sets this value
     * to 0 to specify that all limits should be queried.
     */
    LwU32                       numLimits;
    /*!
     * Array of PERF_LIMIT status entries.  This array has a valid index ranging
     * from 0 to numLimits - 1.
     */
    LW_GPU_PERF_LIMIT_STATUS_V4 limits[LWAPI_PERF_LIMIT_ID_MAX_LIMITS];
} LW_GPU_PERF_LIMITS_STATUS_V4;

typedef LW_GPU_PERF_LIMITS_STATUS_V4 LW_GPU_PERF_LIMITS_STATUS;

//! Macro for constructing the version field of LW_GPU_PERF_LIMITS_STATUS_V1
#define LW_GPU_PERF_LIMITS_STATUS_VER1  MAKE_LWAPI_VERSION(LW_GPU_PERF_LIMITS_STATUS_V1,1)
#define LW_GPU_PERF_LIMITS_STATUS_VER2  MAKE_LWAPI_VERSION(LW_GPU_PERF_LIMITS_STATUS_V2,2)
#define LW_GPU_PERF_LIMITS_STATUS_VER3  MAKE_LWAPI_VERSION(LW_GPU_PERF_LIMITS_STATUS_V3,3)
#define LW_GPU_PERF_LIMITS_STATUS_VER4  MAKE_LWAPI_VERSION(LW_GPU_PERF_LIMITS_STATUS_V4,4)

//! Macro for constructing the version field of LW_GPU_PERF_LIMITS
#define LW_GPU_PERF_LIMITS_STATUS_VER   LW_GPU_PERF_LIMITS_STATUS_VER4

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_PerfLimitsGetStatus
//
//! DESCRIPTION:     This function retrieves the current status/settings
//!                  associated with a set of PERF_LIMITs.  This includes both
//!                  the input which was used to configure the PERF_LIMIT, as
//!                  well as output internal RM domain group settings which are
//!                  being applied as policy.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 285
//!
//! \param [in]      hPhysicalGPU  GPU selection
//! \param [out]     pLimits       Structure containing the status of a set of PERF_LIMITs.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PerfLimitsGetStatus(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_PERF_LIMITS_STATUS *pLimits);

//! @}



//! \addtogroup gpupstate
//! @{

//! Used in various Perf Client Limit APIs below.  Unique IDs corresponding to a
//! set of Perf Client Limits exposed to allow users to set limits on their current
//! clocks.
typedef enum _LW_PERF_CLIENT_LIMIT_ID
{
    LWAPI_PERF_CLIENT_LIMIT_0_MAX      = 0x00000000,       //!< Client limit 0 maximum limit - Recommended for use with PROCESSOR/GRAPHICS clock
    LWAPI_PERF_CLIENT_LIMIT_0_MIN,                         //!< Client limit 0 minimim limit - Recommended for use with PROCESSOR/GRAPHICS clock
    LWAPI_PERF_CLIENT_LIMIT_1_MAX,                         //!< Client limit 1 maximum limit - Recommended for use with MEMORY clock
    LWAPI_PERF_CLIENT_LIMIT_1_MIN,                         //!< Client limit 1 minimim limit - Recommended for use with MEMORY clock
    LWAPI_PERF_CLIENT_LIMIT_2_MAX,                         //!< Client limit 2 maximum limit - Recommended for use with PSTATE
    LWAPI_PERF_CLIENT_LIMIT_2_MIN,                         //!< Client limit 2 minimim limit - Recommended for use with PSTATE
    LWAPI_PERF_CLIENT_LIMIT_MAX_LIMITS = 0x00000020,       //!< Maximum number of supported client limits - cannot change this without changing structure version.
} LW_GPU_PERF_CLIENT_LIMIT_ID;

//! Type of data corresponding to a Perf Client Limit.
typedef enum _LW_PERF_CLIENT_LIMIT_TYPE
{
    LWAPI_PERF_CLIENT_LIMIT_TYPE_DISABLED = 0x00000000,
    LWAPI_PERF_CLIENT_LIMIT_TYPE_PSTATE,
    LWAPI_PERF_CLIENT_LIMIT_TYPE_FREQ,
} LW_GPU_PERF_CLIENT_LIMIT_TYPE;

//! Used in \ref LW_GPU_PERF_CLIENT_LIMIT_DATA_V1.  Data specific to the _PSTATE
//! Perf Client Limit type.
typedef struct
{
    /*!
     * Flags - lwrrently reserved.
     */
    LwU32                 flags;
    /*!
     * Pstate ID at which to apply the limitiation.
     */
    LW_GPU_PERF_PSTATE_ID pstateId;
} LW_GPU_PERF_CLIENT_LIMIT_DATA_PSTATE;

//! Used in \ref LW_GPU_PERF_CLIENT_LIMIT_DATA_V1.  Data specific to the _FREQ
//! Perf Client Limit type.
typedef struct
{
    /*!
     * Flags - lwrrently reserved.
     */
    LwU32                  flags;
    /*!
     * Clock frequency at which to apply the limit.
     */
    LwU32                  freqKHz;
    /*!
     * Clock domain on which to apply the limit.
     */
    LW_GPU_PUBLIC_CLOCK_ID domainId;
} LW_GPU_PERF_CLIENT_LIMIT_DATA_FREQ;

//! Used in \ref LW_GPU_PERF_CLIENT_LIMIT_V1.  Union of type-specific input
//! data.
typedef union
{
    /*!
     * Pstate type-specific data.
     */
    LW_GPU_PERF_CLIENT_LIMIT_DATA_PSTATE pstate;
    /*!
     * Clock domain/frequency type-specific data.
     */
    LW_GPU_PERF_CLIENT_LIMIT_DATA_FREQ   freq;
} LW_GPU_PERF_CLIENT_LIMIT_DATA_V1;

//! Used in \ref LW_GPU_PERF_CLIENT_LIMITS_V1.  Structure representing the
//! current or desired status/settings of a Perf Client Limit.
typedef struct
{
    /*!
     * LW_GPU_PERF_CLIENT_LIMIT_ID for this Perf Client Limit.
     */
    LW_GPU_PERF_CLIENT_LIMIT_ID      limitId;
    /*!
     * Flags - lwrrently reserved.
     */
    LwU32                            flags;
    /*!
     * The type of data used to specify this Perf Client Limit.
     */
    LW_GPU_PERF_CLIENT_LIMIT_TYPE    type;
    /*!
     * Type-specific data used to specify this Perf Client Limit.
     */
    LW_GPU_PERF_CLIENT_LIMIT_DATA_V1 data;
} LW_GPU_PERF_CLIENT_LIMIT_V1;

//! Used in \ref LW_GPU_PERF_CLIENT_LIMITS.  Flags to represent the following
//! configurations:
//!
//! _ASYNC
//!     Apply new Perf Client Limits to HW asynchronously, not blocking
//!     returning from this call for values to be applied.  Only applicable to
//!     \ref LwAPI_GPU_PerfClientLimitsSetStatus().
#define LW_GPU_PERF_CLIENT_LIMITS_FLAGS_ASYNC     0x1

//! Used in \ref LwAPI_GPU_PerfClientLimitsGetStatus() and
//! \ref LwAPI_GPU_PerfClientLimitsSetStatus().  Structure representing the
//! current or desired status/settings of a set of Perf Client Limits.
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    LwU32                       version;
    /*!
     * LW_GPU_PERF_CLIENT_LIMITS_FLAGS_<xyz>
     */
    LwU32                       flags;
    /*!
     * Number of limits specified in the limits array.  Caller sets this value
     * to 0 to specify that all limits should be queried.
     */
    LwU32                       numLimits;
    /*!
     * Array of Perf Client Limit status entries.  This array has a valid index
     * ranging from 0 to numLimits - 1.
     */
    LW_GPU_PERF_CLIENT_LIMIT_V1 limits[LWAPI_PERF_CLIENT_LIMIT_MAX_LIMITS];
} LW_GPU_PERF_CLIENT_LIMITS_V1;

typedef LW_GPU_PERF_CLIENT_LIMITS_V1 LW_GPU_PERF_CLIENT_LIMITS;

//! Macro for constructing the version field of LW_GPU_PERF_CLIENT_LIMITS_V1
#define LW_GPU_PERF_CLIENT_LIMITS_VER1  MAKE_LWAPI_VERSION(LW_GPU_PERF_CLIENT_LIMITS_V1,1)

//! Macro for constructing the version field of LW_GPU_PERF_CLIENT_LIMITS
#define LW_GPU_PERF_CLIENT_LIMITS_VER   LW_GPU_PERF_CLIENT_LIMITS_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_PerfClientLimitsGetStatus
//
//! DESCRIPTION:     This function retrieves the current status/settings
//!                  associated with a set of Perf Client Limits.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 285
//!
//! \param [in]      hPhysicalGPU  GPU selection
//! \param [out]     pLimits       Structure containing the current status of a
//!                                set of Perf Client Limits.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PerfClientLimitsGetStatus(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_PERF_CLIENT_LIMITS *pLimits);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_PerfClientLimitsSetStatus
//
//! DESCRIPTION:     This function sets the status/settings
//!                  associated with a set of Perf Client Limits.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 285
//!
//! \param [in]      hPhysicalGPU  GPU selection
//! \param [out]     pLimits       Structure containing the desired status of a
//!                                set of Perf Client Limits.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PerfClientLimitsSetStatus(__in LwPhysicalGpuHandle hPhysicalGpu, __in  LW_GPU_PERF_CLIENT_LIMITS *pLimits);

//! @}


//! \addtogroup gpupstate
//! @{

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_PerfLimitsSetStatus
//
//! DESCRIPTION:     This function sets the status/settings
//!                  associated with a set of Perf Client Limits.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 295
//!
//! \param [in]      hPhysicalGPU  GPU selection
//! \param [out]     pLimits       Structure containing the desired status of a
//!                                set of Perf Client Limits.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_ILWALID_USER_PRIVILEGE - The caller does not have administrative privileges
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_PerfLimitsSetStatus(__in LwPhysicalGpuHandle hPhysicalGpu, __in  LW_GPU_PERF_LIMITS_STATUS *pLimits);

//! @}





//! \ingroup gpugpio
//! Used in LW_GPU_GPIO_LEGAL_PINS.
#define LWAPI_GPIO_SIZE_QUERY_ARRAY 0x00000020


//! \ingroup gpugpio
//! Used in LW_GPU_GPIO_PIN_DATA.
typedef enum 
{
    LWAPI_GPIO_DIRECTION_INPUT,
    LWAPI_GPIO_DIRECTION_OUTPUT
} LWAPI_GPIO_DIRECTION;


//! \ingroup gpugpio
//! Used in LwAPI_GPU_GPIOQueryLegalPins().
typedef struct
{
    LwU32         version;
    LwU32         gpioPinCount;
    LwU32         gpioLegalPins[LWAPI_GPIO_SIZE_QUERY_ARRAY];
} LW_GPU_GPIO_LEGAL_PINS;


//! \ingroup gpugpio
//! Macro for generating the version for structure LW_GPU_GPIO_LEGAL_PINS
#define LW_GPU_GPIO_LEGAL_PINS_VER MAKE_LWAPI_VERSION(LW_GPU_GPIO_LEGAL_PINS,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GPIOQueryLegalPins
//
//! DESCRIPTION:   This function returns the number of available GPIO customer asyncrw instances.
//!
//! HOW TO USE:    
//!                - LW_GPU_GPIO_LEGAL_PINS gpioLegalPins = {0};       
//!                - gpioLegalPins.version = LW_GPU_GPIO_LEGAL_PINS_VER;
//!                - ret = LwAPI_GPU_GPIOQueryLegalPins(hPhysicalGpu, &gpioLegalPins); 
//!
//!                On call success:
//!                - The gpioLegalPins.gpioPinCount would contain some integer (for example, on some G96 GPUs it contains 3)  
//!                - The gpioLegalPins.gpioLegalPins array would contain some values (for example, on some G96 GPUs it contains 0xd, 0xe & 0xf, others
//!                  0) to be used in LwAPI_GPU_GPIOReadFromPin() & LwAPI_GPU_GPIOWriteToPin() calls.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 175
//! 
//!  \param [in]   hPhysicalGpu        GPU selection.
//!  \param [out]  pgpioLegalPins      Pointer to a versioned structure to get the number of the pin(s) associated with the 
//!                                    LWSTOMER_ASYNCRW functions and an array of size LWAPI_GPIO_SIZE_QUERY_ARRAY in 
//!                                    which the legal pin numbers are retrieved. These legal pin numbers are to be used
//!                                    while performing read and write operations on the GPIO port.                 
//!                 
//!  \retval ::LWAPI_OK      
//!  \retval ::LWAPI_ERROR            
//!  \retval ::LWAPI_ILWALID_HANDLE   physical GPU not found
//!  \retval ::LWAPI_HANDLE_ILWALIDATED 
//!  \retval ::LWAPI_NOT_SUPPORTED 
//!  \retval ::LWAPI_ILWALID_ARGUMENT 
//!  \retval ::LWAPI_API_NOT_INITIALIZED 
//!  \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION 
//!
//!  \ingroup gpugpio 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GPIOQueryLegalPins(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_GPIO_LEGAL_PINS *pgpioLegalPins);


//! ingroup gpugpio
//! Contains GPIO pin, data, and data direction - used in LwAPI_GPU_GPIOReadFromPin() and LwAPI_GPU_GPIOWriteToPin()
typedef struct
{
    LwU32         version;
    LwU32         gpioPinNumber;
    LwU32         gpioDataReadWrite;
    LWAPI_GPIO_DIRECTION         gpioDirection;
} LW_GPU_GPIO_PIN_DATA;


//! \ingroup gpugpio
//! Macro for generating the version of structure LW_GPU_GPIO_PIN_DATA
#define LW_GPU_GPIO_PIN_DATA_VER MAKE_LWAPI_VERSION(LW_GPU_GPIO_PIN_DATA,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GPIOReadFromPin
//
//! DESCRIPTION:  This function reads the data from the specified GPIO pin.
//!
//! HOW TO USE:    First make a LwAPI_GPU_GPIOQueryLegalPins() call. 
//!                - LW_GPU_GPIO_PIN_DATA gpioReadPin = {0};
//!                - gpioReadPin.version = LW_GPU_GPIO_PIN_DATA_VER;
//!                - gpioReadPingpioDirection = LWAPI_GPIO_DIRECTION_INPUT;
//!                - gpioReadPin.gpioPinNumber = any legal pin data from gpioLegalPins array after successful call to LwAPI_GPU_GPIOQueryLegalPins() 
//!                - ret = LwAPI_GPU_GPIOReadFromPin(hPhysicalGpu, &gpioReadPin);
//!
//!                On call success:
//!                - The gpioReadPingpioDataReadWrite would contain the data value read (0 or 1) from the specified pin.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 175
//!
//!  \param [in]  hPhysicalGpu   GPU selection.
//!  \param       pgpioReadPin   Pointer to a versioned structure to pass the GPIO pin number from which the data is
//!                              to be read, the GPIO direction and the variable in which the data is collected.
//!                              The gpioPinNumber parameter is selected from pgpioLegalPins array by calling 
//!                              LwAPI_GPU_GPIOQueryLegalPins().   
//!
//!  \retval ::LWAPI_OK 
//!  \retval ::LWAPI_ERROR 
//!  \retval ::LWAPI_ILWALID_HANDLE 
//!  \retval ::LWAPI_HANDLE_ILWALIDATED
//!  \retval ::LWAPI_ILWALID_ARGUMENT 
//!  \retval ::LWAPI_API_NOT_INITIALIZED
//!  \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION 
//!  \ingroup gpugpio   
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GPIOReadFromPin(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_GPIO_PIN_DATA *pgpioReadPin);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GPIOWriteToPin
//
//! DESCRIPTION:   This function writes data to the specified GPIO pin.
//!
//! HOW TO USE:    First make LwAPI_GPU_GPIOQueryLegalPins() call. 
//!                - LW_GPU_GPIO_PIN_DATA gpioWritePin = {0};
//!                - gpioWritePin.version = LW_GPU_GPIO_PIN_DATA_VER;
//!                - gpioWritePingpioDirection = LWAPI_GPIO_DIRECTION_OUTPUT;
//!                - gpioWritePingpioReadPin.gpioPinNumber = any legal pin data from gpioLegalPins array after successful call to LwAPI_GPU_GPIOQueryLegalPins() 
//!                - gpioWritePin.gpioDataReadWrite = any bit value (0 or 1)
//!                - ret = LwAPI_GPU_GPIOReadFromPin(hPhysicalGpu, &gpioReadPin);
//!
//!                On call success:
//!                - The gpioWritePingpioDataReadWrite value (0 or 1) is written to the specified pin.    
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 175
//!
//! \param [in]  hPhysicalGpu(IN)    GPU selection.
//! \param       pgpioWritePin       Pointer to a versioned structure to pass gpio pin number to which the data is
//!                                  to be written, the GPIO direction and the data value. The gpioPinNumber parameter
//!                                  is selected from pgpioLegalPins array by calling LwAPI_GPU_GPIOQueryLegalPins.   
//! 
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_ILWALID_HANDLE 
//! \retval ::LWAPI_HANDLE_ILWALIDATED
//! \retval ::LWAPI_ILWALID_ARGUMENT 
//! \retval ::LWAPI_API_NOT_INITIALIZED
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION 
//!
//! \ingroup gpugpio                 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GPIOWriteToPin(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_GPIO_PIN_DATA *pgpioWritePin);




/////////////////////////////////////////////////////////////////////////////// 
// 
// FUNCTION NAME: LwAPI_GPU_GetHDCPSupportStatus 
//
//! \fn LwAPI_GPU_GetHDCPSupportStatus(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_GET_HDCP_SUPPORT_STATUS *pGetHDCPSupportStatus)
//! DESCRIPTION: This function returns a GPU's HDCP support status. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 175
//!
//!  \retval ::LWAPI_OK 
//!  \retval ::LWAPI_ERROR 
//!  \retval ::LWAPI_ILWALID_ARGUMENT 
//!  \retval ::LWAPI_HANDLE_ILWALIDATED 
//!  \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE 
//!  \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION 
// 
////////////////////////////////////////////////////////////////////////////////
    

//! \addtogroup gpu
//! @{


//! HDCP fuse states - used in LW_GPU_GET_HDCP_SUPPORT_STATUS
typedef enum _LW_GPU_HDCP_FUSE_STATE
{
    LW_GPU_HDCP_FUSE_STATE_UNKNOWN  = 0,
    LW_GPU_HDCP_FUSE_STATE_DISABLED = 1,
    LW_GPU_HDCP_FUSE_STATE_ENABLED  = 2,
} LW_GPU_HDCP_FUSE_STATE;


//! HDCP key sources - used in LW_GPU_GET_HDCP_SUPPORT_STATUS
typedef enum _LW_GPU_HDCP_KEY_SOURCE
{
    LW_GPU_HDCP_KEY_SOURCE_UNKNOWN    = 0,
    LW_GPU_HDCP_KEY_SOURCE_NONE       = 1,
    LW_GPU_HDCP_KEY_SOURCE_CRYPTO_ROM = 2,
    LW_GPU_HDCP_KEY_SOURCE_SBIOS      = 3,
    LW_GPU_HDCP_KEY_SOURCE_I2C_ROM    = 4,
    LW_GPU_HDCP_KEY_SOURCE_FUSES      = 5,
} LW_GPU_HDCP_KEY_SOURCE;


//! HDCP key source states - used in LW_GPU_GET_HDCP_SUPPORT_STATUS
typedef enum _LW_GPU_HDCP_KEY_SOURCE_STATE
{
    LW_GPU_HDCP_KEY_SOURCE_STATE_UNKNOWN = 0,
    LW_GPU_HDCP_KEY_SOURCE_STATE_ABSENT  = 1,
    LW_GPU_HDCP_KEY_SOURCE_STATE_PRESENT = 2,
} LW_GPU_HDCP_KEY_SOURCE_STATE;


//! HDPC support status - used in LwAPI_GPU_GetHDCPSupportStatus()
typedef struct 
{
    LwU32                        version;               //! Structure version constucted by macro #LW_GPU_GET_HDCP_SUPPORT_STATUS
    LW_GPU_HDCP_FUSE_STATE       hdcpFuseState;         //! GPU's HDCP fuse state
    LW_GPU_HDCP_KEY_SOURCE       hdcpKeySource;         //! GPU's HDCP key source
    LW_GPU_HDCP_KEY_SOURCE_STATE hdcpKeySourceState;    //! GPU's HDCP key source state    
} LW_GPU_GET_HDCP_SUPPORT_STATUS;


//! Macro for constructing the version for structure LW_GPU_GET_HDCP_SUPPORT_STATUS
#define LW_GPU_GET_HDCP_SUPPORT_STATUS_VER MAKE_LWAPI_VERSION(LW_GPU_GET_HDCP_SUPPORT_STATUS,1)


//! @}


//!  \ingroup gpu 
LWAPI_INTERFACE LwAPI_GPU_GetHDCPSupportStatus(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_GET_HDCP_SUPPORT_STATUS *pGetHDCPSupportStatus);




//! \ingroup gpu
//! Used in LwAPI_GetHdcpHdmiDiagnostics().
typedef struct
{
    LwU32 version;                          //!< Structure version

    //! HDCP diagnostic information
    struct
    {
        LwU32 bGpuCapable              : 1; //!< GPU is HDCP-capable (no errors detected, everything present)
        LwU32 bGpuFusePresent          : 1; //!< GPU HDCP fuse register set

        LwU32 bDfpCapable              : 1; //!< Display is HDCP-capable
        LwU32 bDfpAllowed              : 1; //!< VBIOS allows HDCP on display
        LwU32 bDfpDualLink             : 1; //!< Is attach point dual-link capable

        LwU32 bRomError                : 1; //!< HDCP hardware detected an error with the rom
        LwU32 bDownstreamChecksumError : 1; //!< Set if hardware reports that its checksum BIST of its downstream HDCP keys failed

        LW_HDCP_PACKET packet;              //!< HDCP packet of information:
                                            //!< Only the following parts of the HDCP packet are populated:
                                            //!< - bStatus, hdcpStatus, cS, kP, aN, aKsv, dKsv, vP, mP, numBKSVs,
                                            //!< - bKsvList (bKsv, first 1 or 2 indices of bKsvList).
                                            //!< Use the packet.flFlags property to check which fields are valid/invalid.
    } hdcp;

    //! HDMI diagnostic information for display
    struct
    {
        LwU32 bGpuCapable              : 1; //!< GPU is HDMI capable (indicates fuses are set)

        LwU32 bDfpCapable              : 1; //!< Display is HDMI capable
        LwU32 bDfpAllowed              : 1; //!< VBIOS allows HDMI on display
        LwU32 bDfpDualLink             : 1; //!< Is display dual-link capable
    } hdmi;

} LW_HDCP_HDMI_DIAGNOSTICS;


//! \ingroup gpu
//! Macro for constructing the version field for LW_GET_HDCP_HDMI_DIAGNOSTICS.
#define LW_GET_HDCP_HDMI_DIAGNOSTICS_VER MAKE_LWAPI_VERSION(LW_HDCP_HDMI_DIAGNOSTICS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetHdcpHdmiDiagnostics
//
//!  DESCRIPTION: This API returns diagnostic information on display HDCP and HDMI capabilities.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \retval ::LWAPI_OK                            completed request
//! \retval ::LWAPI_ERROR                         miscellaneous error oclwrred
//! \retval ::LWAPI_ILWALID_ARGUMENT              pGetGpuHdcpSupportStatus is NULL
//! \retval ::LWAPI_HANDLE_ILWALIDATED            handle passed has been ilwalidated (see user guide)
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  handle passed is not a physical GPU handle
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION   the version of the INFO struct is not supported
//! \retval ::LWAPI_EXPECTED_DIGITAL_FLAT_PANEL   outputId is not associated with digital flat panel.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetHdcpHdmiDiagnostics(LwPhysicalGpuHandle hPhysicalGpu, LwU32 displayId, LW_HDCP_HDMI_DIAGNOSTICS *pHdcpHdmiDiagnostics);






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetACPIIdFromOutputId
//
//! \code
//! PARAMETERS:      hPhysicalGpu(IN)        - GPU selection.
//!                  pOutputId(IN)           - pointer to the array of OutputIds with max size 16
//!                  uOutputIdCount(IN)      - Number of OutputIds in the OutputId array
//!                  pACPIid(OUT)            - pointer to the array of ACPIIds with max size 16
//!                   
//! DESCRIPTION: Returns corresponding ACPI Ids for the given Display OutputIds
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!                  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetACPIIdFromOutputId(LwPhysicalGpuHandle hPhysicalGpu, LwU32 pOutputId[LWAPI_MAX_ACPI_IDS], LwU32 uOutputIdCount, LwU32 pACPIid[LWAPI_MAX_ACPI_IDS] );

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetOutputIdFromACPIId
//
//! \code
//! PARAMETERS:      hPhysicalGpu(IN)        - GPU selection.
//!                  pACPIid(IN)             - pointer to the array of ACPIIds with max size 16
//!                  uACPIidCount(IN)        - Number of ACPIids in the ACPIId array
//!                  pOutputId(OUT)          - pointer to the array of OutputIds with max size 16
//!
//! DESCRIPTION: Returns corresponding ACPIId for the given Display OutputId
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!                  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetOutputIdFromACPIId(LwPhysicalGpuHandle hPhysicalGpu, LwU32 pACPIid[LWAPI_MAX_ACPI_IDS], LwU32 uACPIidCount, LwU32 pOutputId[LWAPI_MAX_ACPI_IDS]);



//! \ingroup sysdps
//! Used in LwAPI_SYS_GetDisplayPowerSavingState() and LwAPI_SYS_SetDisplayPowerSavingState().
typedef enum
{
    LW_DISPLAY_POWER_SAVING_NOT_SUPPORTED = -1,
    LW_DISPLAY_POWER_SAVING_DISABLED = 0,
    LW_DISPLAY_POWER_SAVING_ENABLED = 1
} LW_DISPLAY_POWER_SAVING;

///////////////////////////////////////////////////////////////////////////////
//
// Notes about Display Power Saving feature :
//
// This feature works only on LVDS panels and requires that to be active.
// The feature is system specific and can be controlled independent
// of whether the LVDS panel is active.
//
// To control the lwDPS through LWAPI interface, the following registry value
// has to be added:
// only for internal use - DWORD lwDPSSettings = 0x786002B in the same location where BINARY RMGpuId exists.
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_SYS_GetDisplayPowerSavingState
//
//! DESCRIPTION:    This API queries the current Display Power Saving state.
//!
//! HOW TO USE:     
//!                 - LW_DISPLAY_POWER_SAVING State;
//!                 - ret = LwAPI_SYS_GetDisplayPowerSavingState(&State);
//!                 - On call success:
//!                 - State would either be LW_DISPLAY_POWER_SAVING_ENABLED or LW_DISPLAY_POWER_SAVING_DISABLED
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param  pState  Pointer to LW_DISPLAY_POWER_SAVING variable receiving Power Saving State
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_NOT_SUPPORTED       Display Power Saving feature is not available on the target hardware,
//! \retval ::LWAPI_ILWALID_ARGUMENT 
//! \retval ::LWAPI_API_NOT_INTIALIZED 
//! \retval ::LWAPI_HANDLE_ILWALIDATED 
//!
//! \ingroup sysdps
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetDisplayPowerSavingState(LW_DISPLAY_POWER_SAVING *pState);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_SYS_SetDisplayPowerSavingState
//
//! DESCRIPTION:    This API sets the current Display Power Saving state.
//!
//! HOW TO USE:     
//!                 - LW_DISPLAY_POWER_SAVING State = either LW_DISPLAY_POWER_SAVING_ENABLED or LW_DISPLAY_POWER_SAVING_DISABLED;
//!                 - ret = LwAPI_SYS_SetDisplayPowerSavingState(State);
//!                 - On call success:
//!                 - Display Power Saving feature would be enabled or disabled
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param   State  LW_DISPLAY_POWER_SAVING_DISABLED or LW_DISPLAY_POWER_SAVING_ENABLED
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_NOT_SUPPORTED  Display Power Saving feature is not available on the target hardware
//! \retval ::LWAPI_ILWALID_ARGUMENT 
//! \retval ::LWAPI_API_NOT_INTIALIZED 
//! \retval ::LWAPI_HANDLE_ILWALIDATED 
//!
//! \ingroup sysdps
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_SetDisplayPowerSavingState(LW_DISPLAY_POWER_SAVING State);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetSupportedSLIViews
//! DESCRIPTION:     This API, based on the connected state obtained from LwAPI_GPU_GetConnectedSLIOutputs(),
//!                  enumerates the supported LWPU display views when SLI is active.
//!                  If SLI is not active then this API returns all the supported lwiew modes. \n
//!                  Note : If a client make the call using a GPU handle with no 
//!                         connected monitors, then this API returns ::LWAPI_NOT_SUPPORTED.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//! 
//! \param [in]     hPhysicalGpu  GPU selection
//! \param [out]    pTargetViews  Array of supported views. Can be NULL to retrieve the pViewCount first.
//! \param [in,out] pViewCount    Count of supported views.
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_ILWALID_ARGUMENT 
//! \retval ::LWAPI_NOT_SUPPORTED 
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetSupportedSLIViews(LwPhysicalGpuHandle hPhysicalGpu, LW_TARGET_VIEW_MODE pTargetViews[LWAPI_MAX_VIEW_MODES], LwU32 *pViewCount);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_SetTopologyFolwsDisplayAndView
//! DESCRIPTION:     This API works on the active display GPU and lets the calling application switch
//!                  the focus display. It accepts path information to specify single, Clone or Dualview. \n
//!                  Note : If SLI is not active then this API returns ::LWAPI_NO_ACTIVE_SLI_TOPOLOGY.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     hLogicalGPU              Active logical gpu topology containing more than one physical gpus.
//! \param [in]     folwsDisplayOutputId     Connected display output Id on the target GPU which should be folwsed.
//! \param [in]     pPathInfo                Pointer to LW_VIEW_PATH_INFO, specifying device properties in this view.
//!                                          The first device entry in the array is the physical primary.
//!                                          The device entry with the lowest source ID is the desktop primary.
//! \param [in]     displayView              Display view selected from LW_TARGET_VIEW_MODE.
//!
//! \retval ::LWAPI_OK  
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_ILWALID_ARGUMENT 
//! \retval ::LWAPI_NO_ACTIVE_SLI_TOPOLOGY  SLI is not active on this device.
//!
//! \ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetTopologyFolwsDisplayAndView(LwLogicalGpuHandle hLogicalGPU, LwU32 folwsDisplayOutputId, LW_DISPLAY_PATH_INFO *pPathInfo, LW_TARGET_VIEW_MODE displayView);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetDriverModel
//
//! DESCRIPTION: This API sets the driver model(pDriverModel) corresponding to the specified GPU.
//!              - Win7: For G84 GPUs and higher  0x00001100 (corresponds to WDDM 1.1)
//!              - Win7: For all other GPUs       0x00001000 (corresponds to WDDM 1.0)
//!              - Windows Vista: All GPUs        0x00001000 (corresponds to WDDM 1.0)
//!              - WindowsXP:                     Not Supported
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     hPhysicalGpu      GPU selection.
//! \param [out]    pDriverModel      pointer to the Driver Model
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_HANDLE_ILWALIDATED 
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE 
//! \retval ::LWAPI_ILWALID_ARGUMENT 
//! \retval ::LWAPI_ILWALID_HANDLE 
//! \retval ::LWAPI_API_NOT_INTIALIZED 
//! \retval ::LWAPI_NOT_SUPPORTED   Only for Win7 & Vista
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetDriverModel(LwPhysicalGpuHandle hPhysicalGpu, LwU32* pDriverModel);





//! \addtogroup gpulwda
//! @{

//! defgroup lwcomp_gpu_top LWPU Compute GPU Topology Flags
//! @{   
#define LW_COMPUTE_GPU_TOPOLOGY_PHYSICS_CAPABLE            LW_BIT(0)   //!< This is Read only GPU flag - Physics capable GPU.
#define LW_COMPUTE_GPU_TOPOLOGY_PHYSICS_ENABLE            LW_BIT(1)   //!< This is Read/Write GPU flag - indicates GPU is already enabled for physics.
                                                                    //! Application can use this flag to request physics to be enabled on this GPU.
                                                                    //! No ENABLE flag indicates DISABLE Physics on this GPU.
#define LW_COMPUTE_GPU_TOPOLOGY_PHYSICS_DEDICATED        LW_BIT(2)   //!< This is Read only GPU flag - Physics enabled GPU which is *dedicated* for physics indicates
                                                                    //! this compute capable GPU was automatically made usable for Physx on LWCA.
#define LW_COMPUTE_GPU_TOPOLOGY_PHYSICS_RECOMMENDED     LW_BIT(3)   //!< This is Read only GPU flag - Physics GPU which is recommended by the driver.                                                          
#define LW_COMPUTE_GPU_TOPOLOGY_LWDA_AVAILABLE            LW_BIT(4)   //!<This is Read only GPU flag-GPU is capable and !disabled and  it is in IDM if needed. This is useful to LWCA client apps. 


#define LW_COMPUTE_GPU_PRIVATE_MASK                        0xFFFF0000  
#define LW_COMPUTE_GPU_TOPOLOGY_LWDA_CAPABLE            LW_BIT(16)  //!< This is Read only GPU flag - GPU physically can do compute regardless of IDM state or disabled state 
#define LW_COMPUTE_GPU_TOPOLOGY_LWDA_DISABLED            LW_BIT(17)  //!< This is Read only GPU flag - GPU is Disabled for LWCA apps via SRS 825
#define LW_COMPUTE_GPU_TOPOLOGY_IDM_ENABLED                LW_BIT(18)  //!< This is Read only GPU flag - No longer used
#define LW_COMPUTE_GPU_TOPOLOGY_IDM_ACTIVE                LW_BIT(19)  //!< This is Read only GPU flag - No longer used
#define LW_COMPUTE_GPU_TOPOLOGY_LWDA_HYBRID_DISABLED    LW_BIT(20)  //!< This is Read only GPU flag - LWCA is unavailable on this GPU while in the current hybrid mode
#define LW_COMPUTE_GPU_TOPOLOGY_PHYSICS_AVAILABLE       LW_BIT(21)  //!< This is Read only GPU flag - PhysX is able to use this GPU (PhysX is installed, etc) 

//! @}


//! Used in LwAPI_GPU_LwdaEnumComputeCapableGpus(), LwAPI_GPU_PhysxSetState(), and LwAPI_GPU_PhysxQueryRecommendedState().
typedef struct
{
    LwU32 version;  //!< Structure version
    LwU32 gpuCount; //!< Total number of compute-capable GPUs

    struct
    {
        LwPhysicalGpuHandle  hPhysicalGpu;      //!< Compute-capable physical GPU handle
        LwU32                flags;             //!< One or more flags from \ref lwcomp_gpu_top

    } computeGpus[LWAPI_MAX_GPU_PER_TOPOLOGY];  //!< Array of compute-capable physical GPUs.

} LW_COMPUTE_GPU_TOPOLOGY_V1;


typedef struct _LW_COMPUTE_GPU
{
     LwPhysicalGpuHandle  hPhysicalGpu;      //!< Compute-capable physical GPU handle
     LwU32                flags;             //!< One or more flags from \ref lwcomp_gpu_top

} LW_COMPUTE_GPU;

typedef struct _LW_COMPUTE_GPU_TOPOLOGY_V2
{
    LwU32 version;  //!< Structure version
    LwU32 gpuCount; //!< Size of array
    LW_COMPUTE_GPU *computeGpus;  //!< Array of compute-capable physical GPUs (allocate memory of size of Physical gpucount of system).

} LW_COMPUTE_GPU_TOPOLOGY_V2;

//! Macro for constructing the version field of LW_COMPUTE_GPU_TOPOLOGY
#define LW_COMPUTE_GPU_TOPOLOGY_VER1  MAKE_LWAPI_VERSION(LW_COMPUTE_GPU_TOPOLOGY_V1,1)

#define LW_COMPUTE_GPU_TOPOLOGY_VER  MAKE_LWAPI_VERSION(LW_COMPUTE_GPU_TOPOLOGY_V2,2)
typedef LW_COMPUTE_GPU_TOPOLOGY_V2 LW_COMPUTE_GPU_TOPOLOGY;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_GPU_LwdaEnumComputeCapableGpus
//
//! DESCRIPTION:   This API enumerates one or more compute-capable GPUs.
//!                Compute-capable GPUs are not necessarily GPUs that are usable with LWCA. Applications can make a GPU "compute-capable" by:
//!                  - Enabling PhysX using LwAPI_GPU_PhysxSetState() OR
//!                  - Enabling at least one display using LwAPI_CreateDisplayFromUnAttachedDisplay() on the unattached display handle for the compute GPU
//!
//! \deprecated  Do not use this function - it is deprecated in release 319. Instead, use LwAPI_LWDA_EnumComputeCapableByTopology.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [out]      pPhysicsTopo  An array of compute-capable GPUs.
//!
//! \retval ::LWAPI_OK     Completed request. The gpuCount indicates if one or more compute-capable GPUs are 
//!                        found. gpuCount >= 1 if atleast one compute-capable GPU is found.
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  Structure version is not supported, initialize to LW_COMPUTE_GPU_TOPOLOGY_VER.
//! \retval ::LWAPI_ERROR                        Enumeration of the GPUs failed. Make sure at least one LWPU GPU exists in the system.
//!
//! \ingroup gpulwda
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 319. Instead, use LwAPI_LWDA_EnumComputeCapableByTopology.")
LWAPI_INTERFACE LwAPI_GPU_LwdaEnumComputeCapableGpus(__inout LW_COMPUTE_GPU_TOPOLOGY *pComputeTopo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_LWDA_EnumComputeCapableByTopology
//
//! DESCRIPTION:    This API needs both GPU topology and display topology, since our recommendation include which displays are lit and which display is the GDI primary.
//!                 Because SLI state affects how the final display topology look like, it is assumed predicted display topology will be provided
//!
//!                 NOTE: It is two pass API
//!                       Pass1: Call with computeGpus set to NULL to get gpuCount size
//!                       Pass2: Allocate memory to computeGpus of size gpuCount to get the info
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param[IN/OUT]  computeTopo    -  An array of compute capable gpus.
//! \param[IN]      gpuTopology    -  An array of LW_GPU_VALID_GPU_TOPOLOGIES
//! \param[IN]      pathInfoCount  -  Number of elements in pathInfo array
//! \param[IN]      pathInfo       -  The pathInfo must only contain the source and target mappings ,as well as sourcemodeinfo.
//!
//! \return         This API can return any of the error codes enumerated in
//!                 #LwAPI_Status.  If there are return error codes with specific
//!                 meaning for this API, they are listed below.
//! \endcode
//! \ingroup gpulwda
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_LWDA_EnumComputeCapableByTopology(__inout LW_COMPUTE_GPU_TOPOLOGY *computeTopo, __in_opt LW_GPU_VALID_GPU_TOPOLOGIES *gpuTopology, __in LwU32 pathInfoCount, __in_opt LW_DISPLAYCONFIG_PATH_INFO *pathInfo );






//! \ingroup gpudeepidle
//! @{


//! Used in LwAPI_GPU_GetDeepIdleState() and LwAPI_GPU_SetDeepIdleState().
typedef enum 
{ 
    LW_DEEP_IDLE_NOT_SUPPORTED = -1, 
    LW_DEEP_IDLE_DISABLE      = 0, 
    LW_DEEP_IDLE_ENABLE       = 1 
} LW_DEEP_IDLE_STATE;



///////////////////////////////////////////////////////////////////////////////
//
// Notes about GPU Deep Idle feature :
//
// This feature lwrrently works only in simulation mode on G9x via a registry key.
// In the simulation mode, the clocks will be lowered but there won't be a true
// "deep idle" state.
//
// To control the GPU Deep Idle through LWAPI interface, the following registry value
// has to be added:
// only for internal use - DWORD DeepIdleSim = 0 (disable simulation) or 1 (enable simulation)
//                                             in the location where RmGpuId for dGPU exists.   
// 
/////////////////////////////////////////////////////////////////////////////// 

//! SUPPORTED OS:  Windows XP and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_GPU_GetDeepIdleState
//
//! \code
//! PARAMETERS:     hLogicalGpu(IN) - logical GPU selection
//!                 pState(OUT) - Pointer to LW_DEEP_IDLE_STATE variable receiving GPU Deep Idle State
//!
//! DESCRIPTION:    This API queries the current GPU Deep Idle state
//!
//!
//! HOW TO USE:     LW_DEEP_IDLE_STATE State;
//!                 ret = LwAPI_GPU_GetDeepIdleState(hLogicalGpu, &State);
//!                 On call success:
//!                 State would either be LW_DEEP_IDLE_ENABLE or LW_DEEP_IDLE_DISABLE 
//! 
//! RETURN STATUS: 
//!                 LWAPI_OK - completed request
//!                 LWAPI_ERROR - miscellaneous error oclwrred
//!                 LWAPI_NOT_SUPPORTED - GPU Deep Idle feature is not available on the target hardware
//!                 LWAPI_ILWALID_HANDLE - logical GPU not found
//!                 LWAPI_ILWALID_ARGUMENT - invalid argument passed
//!                 LWAPI_API_NOT_INTIALIZED - lwapi not initialized
//!                 LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!                 LWAPI_EXPECTED_LOGICAL_GPU_HANDLE - handle passed is not a logical GPU handle  
//! \endcode 
/////////////////////////////////////////////////////////////////////////////// 
LWAPI_INTERFACE LwAPI_GPU_GetDeepIdleState(LwLogicalGpuHandle hLogicalGpu, LW_DEEP_IDLE_STATE *pState);

//! SUPPORTED OS:  Windows XP and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_GPU_SetDeepIdleState
//
//! \code
//! PARAMETERS:     hLogicalGpu(IN) - logical GPU selection
//!                 pState(IN) - LW_DEEP_IDLE_STATE variable inidicating the state to be set
//!
//! DESCRIPTION:    This API sets the GPU Deep Idle state
//!
//! HOW TO USE:     LW_DEEP_IDLE State = either LW_DEEP_IDLE_ENABLE or LW_DEEP_IDLE_DISABLE;
//!                 ret = LwAPI_GPU_SetDeepIdleState(hLogicalGpu, State);
//!                 On call success:
//!                 GPU Deep Idle feature would either be enabled or disabled
//!
//! RETURN STATUS:
//!                 LWAPI_OK - completed request
//!                 LWAPI_ERROR - miscellaneous error oclwrred
//!                 LWAPI_NOT_SUPPORTED - GPU Deep Idle feature is not available on the target hardware
//!                 LWAPI_ILWALID_HANDLE - logical GPU not found
//!                 LWAPI_ILWALID_ARGUMENT - invalid argument passed
//!                 LWAPI_API_NOT_INTIALIZED - lwapi not initialized
//!                 LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!                 LWAPI_EXPECTED_LOGICAL_GPU_HANDLE - handle passed is not a logical GPU handle 
//! \endcode 
/////////////////////////////////////////////////////////////////////////////// 
LWAPI_INTERFACE LwAPI_GPU_SetDeepIdleState(LwLogicalGpuHandle hLogicalGpu, LW_DEEP_IDLE_STATE State);

//! @}



//! SUPPORTED OS:  Windows Vista and higher
//!

//! \ingroup gpudeepidle
//! @{

typedef enum 
{ 
    LW_DEEP_IDLE_STATISTICS_MODE_NH,    //!< No heads
    LW_DEEP_IDLE_STATISTICS_MODE_VE,    //!< Vblank extended
    LW_DEEP_IDLE_STATISTICS_MODE_SSC,   //!< SSC Mode
    LW_DEEP_IDLE_STATISTICS_MODE_FO     //!< FB Off
} LW_DEEP_IDLE_STATISTICS_MODE;

typedef struct
{
    LwU32   version;                    //!< Structure version
    LwU32   attempts;                   //!< Number of attempts made to enter Deep Idle
    LwU32   entries;                    //!< Number of successful entries into Deep Idle
    LwU32   exits;                      //!< Number of exits out of Deep Idle
    LwU32   time;                       //!< Amount of time in microseconds spent in Deep Idle
    LwU32   maxEntryLatency;            //!< maximum latency (in microseconds) for entering Deep Idle
    LwU32   maxExitLatency;             //!< maximum latency (in microseconds) for exiting Deep Idle
    LwU32   veFrames;                   //!< number of frames spent in Deep Idle (VE mode only)
    LwU32   veVblankExits;              //!< number of Deep Idle exits due to end of vblank (VE mode only)
    LwU32   veDeepL1Exits;              //!< number of Deep Idle exits due to Deep L1 exit (VE mode only)
} LW_DEEP_IDLE_STATISTICS;

//! Macro for constructing the version field of ::LW_DEEP_IDLE_STATISTICS
#define LW_DEEP_IDLE_STATISTICS_VER MAKE_LWAPI_VERSION(LW_DEEP_IDLE_STATISTICS,1)

/////////////////////////////////////////////////////////////////////////////// 
// 
// FUNCTION NAME:  LwAPI_GPU_SetDeepIdleStatisticsMode
//
//! \code
//! PARAMETERS:     hPhysicalGpu(IN) - GPU selection
//!                 Mode(IN)         - LW_DEEP_IDLE_STATISTICS_MODE variable indicating which flavor of Deep Idle for which to collect information
//!                 bReset(IN)       - Boolean indicating whether or not all current statistics for the specified mode should be reset to 0
//!
//! DESCRIPTION:    This API returns statistics about GPU Deep Idle activity
//!
//! HOW TO USE:     When gathering Deep Idle statistics, call this function first to specify
//!                 the Deep Idle flavor of interest and clear previous statistics if desired.
//!
//! RETURN STATUS:
//!                 LWAPI_OK - completed request
//!                 LWAPI_ERROR - miscellaneous error oclwrred
//!                 LWAPI_NOT_SUPPORTED - GPU Deep Idle feature is not available on the target hardware
//!                 LWAPI_ILWALID_HANDLE - logical GPU not found
//!                 LWAPI_ILWALID_ARGUMENT - invalid argument passed
//!                 LWAPI_API_NOT_INTIALIZED - lwapi not initialized
//!                 LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!                 LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE- hPhysicalGpu is not a physical GPU handle.
//! \endcode
/////////////////////////////////////////////////////////////////////////////// 
LWAPI_INTERFACE LwAPI_GPU_SetDeepIdleStatisticsMode(LwPhysicalGpuHandle hPhysicalGpu, LW_DEEP_IDLE_STATISTICS_MODE Mode, LwU32 bReset);

//! SUPPORTED OS:  Windows Vista and higher
//!
/////////////////////////////////////////////////////////////////////////////// 
// 
// FUNCTION NAME:  LwAPI_GPU_GetDeepIdleStatistics
//
//! \code
//! PARAMETERS:     hPhysicalGpu(IN) - GPU selection
//!                 pStatistics(OUT) - LW_DEEP_IDLE_STATISTICS variable containing Deep Idle activity information
//!
//! DESCRIPTION:    This API returns statistics about GPU Deep Idle activity
//!
//! HOW TO USE:     Call this function to get the current statistics information for the Deep Idle
//!                 flavor that was specified in the call to LwAPI_GPU_SetDeepIdleStatisticsMode.
//!
//! RETURN STATUS:
//!                 LWAPI_OK - completed request
//!                 LWAPI_ERROR - miscellaneous error oclwrred
//!                 LWAPI_NOT_SUPPORTED - GPU Deep Idle feature is not available on the target hardware
//!                 LWAPI_ILWALID_HANDLE - logical GPU not found
//!                 LWAPI_ILWALID_ARGUMENT - invalid argument passed
//!                 LWAPI_API_NOT_INTIALIZED - lwapi not initialized
//!                 LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!                 LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE- hPhysicalGpu is not a physical GPU handle.
//! \endcode
/////////////////////////////////////////////////////////////////////////////// 
LWAPI_INTERFACE LwAPI_GPU_GetDeepIdleStatistics(LwPhysicalGpuHandle hPhysicalGpu, LW_DEEP_IDLE_STATISTICS *pStatistics);

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetTachReading
//
//!   DESCRIPTION: This API retrieves the fan speed tachometer reading for the specified physical GPU.
//!
//!   HOW TO USE:   
//!                 - LwU32 Value = 0;
//!                 - ret = LwAPI_GPU_GetTachReading(hPhysicalGpu, &Value);  
//!                 - On call success:
//!                 - Value contains the tachometer reading
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \param [in]    hPhysicalGpu   GPU selection.
//! \param [out]   pValue         Pointer to a variable to get the tachometer reading
//!
//! \retval ::LWAPI_OK - completed request
//! \retval ::LWAPI_ERROR - miscellaneous error oclwrred
//! \retval ::LWAPI_NOT_SUPPORTED - functionality not supported 
//! \retval ::LWAPI_API_NOT_INTIALIZED - lwapi not initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT - invalid argument passed
//! \retval ::LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!
//! \ingroup gpucooler
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetTachReading(LwPhysicalGpuHandle hPhysicalGPU, LwU32 *pValue);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetThermalTable
//
//! \fn LwAPI_GPU_GetThermalTable(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_THERMAL_TABLE *pThermalTable)
//! \code
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! DESCRIPTION:     Returns the list of thermal table entries for this GPU.
//!                      ttVersion - version of thermal table 
//!                      numEntries - number of thermal table entries returned
//!
//!
//! RETURN STATUS: 
//!    LWAPI_OK - completed request, *pTable contains the thermal table entries
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_NOT_SUPPORTED - not available on the target hardware
//!    LWAPI_ILWALID_ARGUMENT - pThermalTable is NULL
//!    LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    LWAPI_INCOMPATIBLE_STRUCT_VERSION - LW_THERMAL_TABLE structure version mismatch
//! \endcode
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gputhermal
#define LWAPI_GPU_THERMAL_TABLE_MAX_ENTRIES (256)

//! \ingroup gputhermal
typedef struct
{
    LwU32   version;            //!< Structure version
    LwU32   flags;              //!< call with 0, reserved for future extensions 
    LwU32   ttVersion;
    LwU32   numEntries;
    LwU32   entryList[LWAPI_GPU_THERMAL_TABLE_MAX_ENTRIES];
} LW_GPU_THERMAL_TABLE;

//! \ingroup gputhermal
//! Macro for constructing the version field of ::LW_GPU_THERMAL_TABLE
#define LW_GPU_THERMAL_TABLE_VER MAKE_LWAPI_VERSION(LW_GPU_THERMAL_TABLE,1)

//! \ingroup gputhermal
LWAPI_INTERFACE LwAPI_GPU_GetThermalTable(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_THERMAL_TABLE *pThermalTable);




//! \ingroup gpucooler
//! @{

typedef enum
{
    LW_FAN_SENSE_NOTSUPPORTED = 0, //!< fan sense not supported
    LW_FAN_SENSE_SUPPORTED = 1,    //!< fan sense supported
} LW_FAN_SENSE;

typedef struct
{
    LwU32   version;
    LwU32   coolerCount;
    LW_FAN_SENSE   supportFlag[LWAPI_MAX_COOLERS_PER_GPU];
} LW_GPU_FAN_SPIN_SENSE;

//! Macro for constructing the version field of ::LW_GPU_FAN_SPIN_SENSE
#define LW_GPU_FAN_SPIN_SENSE_VER MAKE_LWAPI_VERSION(LW_GPU_FAN_SPIN_SENSE, 1)

//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME : LwAPI_GPU_QueryFanSpinSenseSupport
//
//! \code  
//! PARAMETERS    : hPhysicalGpu(IN)       - GPU selection 
//!                 coolerIndexRequest(IN) - Index of the cooler (0 to LWAPI_MAX_COOLERS_PER_GPU-1) to retrieve info if 
//!                                          any particular is of interest otherwise to retrieve info for all the cooler,
//!                                          set coolerIndex to LWAPI_COOLER_TARGET_ALL.                                           
//!                 pSpinSense(OUT)        - Pointer to the versioned structure LW_GPU_FAN_SPIN_SENSE in which the 
//!                                          total count of the coolers associated with the GPU and their individual
//!                                          fan spin sense support flags are retrieved.
//!
//! DESCRIPTION   : This function will return the fan spin sense info for a particular or all the coolers associated with a GPU.
//!
//! HOW TO USE    : LW_GPU_FAN_SPIN_SENSE spinSense = {0};
//!                 coolerIndexRequest = LWAPI_COOLER_TARGET_ALL;
//!                 spinSense.version = LW_GPU_FAN_SPIN_SENSE_VER;
//!                 ret = LwAPI_GPU_QueryFanSpinSenseSupport(hPhysicalGpu, &spinSense);
//!                 on call success:
//!                 spinSense.count indicates the number of coolers associated with the GPU.
//!                 spinSense.supportFlag array would contain the flag(1 = supported, 0 = not) for each of the 
//!                 coolers associated with the GPU.                  
//!                 
//! RETURN STATUS:
//!                 LWAPI_OK - completed request
//!                 LWAPI_ERROR - miscellaneous error oclwrred
//!                 LWAPI_NOT_SUPPORTED - this feature is not supported on this GPU
//!                 LWAPI_ILWALID_HANDLE - physical GPU not found
//!                 LWAPI_ILWALID_ARGUMENT - invalid arugument passed
//!                 LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!                 LWAPI_API_NOT_INITIALIZED - lwapi not initialized
//!                 LWAPI_INCOMPATIBLE_STRUCT_VERSION - structure passed not initialized with proper version data
//! \endcode
///////////////////////////////////////////////////////////////////////////////    
LWAPI_INTERFACE LwAPI_GPU_QueryFanSpinSenseSupport(LwPhysicalGpuHandle hPhysicalGpu, LwU32 coolerIndexRequest, LW_GPU_FAN_SPIN_SENSE *pSpinSense);

//! @}




///////////////////////////////////////////////////////////////////////////////
//             
// FUNCTION NAME: LwAPI_GPU_CreateStringHashFromPhysicalGpu
//
//! \code
//! PARAMETERS:    hPhysicalGpu (IN)   - GPU selection.
//!                nSize (IN)          - size of pre-allocated string
//!                szHash (OUT)        - pointer to pre-allocated string array.
//!                                      If a value is written to the array it
//!                                      will be NULL-terminated.
//!                  
//! SUPPORTED OS:  Windows XP
//!
//! DESCRIPTION:   This function creates a string hash that represents a
//!                given physical GPU for the purpose of controlling which
//!                GPU is used as the OpenGL multimon-buffer master GPU.
//!
//! HOW TO USE:    The string is stored in the app profile.  Later, when
//!                an OGL app starts up, LwAPI_GPU_ColwertStringHashToPhysicalGpu
//!                colwerts the string back into a GPU handle.
//!                     
//! RETURN STATUS: 
//!                LWAPI_OK - completed request
//!                LWAPI_ERROR - miscellaneous error oclwrred
//!                LWAPI_ILWALID_ARGUMENT - invalid input parameter
//!                LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - hPhysicalGpu is not a physical GPU handle.
//!                LWAPI_STRING_TOO_SMALL - szHash is too small because the hash'd string exceeds (nSize+1) characters
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_CreateStringHashFromPhysicalGpu(LwPhysicalGpuHandle hPhysicalGpu, LwU32 nSize, LwAPI_String szHash);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_ColwertStringHashToPhysicalGpu
//
//! \code
//! PARAMETERS:    szHash (OUT)        - pointer to null-terminated string hash
//!                hPhysicalGpu (OUT)  - GPU selection
//!                  
//! SUPPORTED OS:  Windows XP
//!
//! DESCRIPTION:   This function colwerts to a physical GPU handle from a
//!                string hash that was created by
//!                LwAPI_GPU_CreateStringHashFromPhysicalGpu.  If the exact GPU
//!                is not present then the "best match" GPU will be selected.
//!
//! RETURN STATUS: 
//!                LWAPI_OK - completed request
//!                LWAPI_ERROR - miscellaneous error oclwrred
//!                LWAPI_ILWALID_ARGUMENT - invalid input parameter
//!                LWAPI_MATCHING_DEVICE_NOT_FOUND - none of the present devices are a close-enough match to szHash
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ColwertStringHashToPhysicalGpu(LwAPI_String szHash, LwPhysicalGpuHandle hPhysicalGpu);





///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GPU_QueryDPTopology
//
//
//! DESCRIPTION:  This API returns the DPMST topology information for a given connector.
//! HOW TO USE:   
//!           -# For each PhysicalGpu, make a call to get the connected displayId's using LwAPI_GPU_GetConnectedDisplayIds()
//!           -# If we found any DPMST connector for the particular displayId, then try to do the step3
//!           -# To find, number of nodes available under one displayId of DPMST topology use LwAPI_GPU_QueryDPTopology() bypassing pNodes as NULL
//!           -# On success allocate memory for pNodes based on pNumOfNodes returned and call LwAPI_GPU_QueryDPTopology() to get the nodes' details
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     displayId   This is the displayId of the DPMST connector to which the topology is rooted.
//! \param [in,out] pNodes      Pointer to an array of LW_DP_NODE_INFO structures, where each entry represents one node on the DPMST topology
//! \param [in,out] pNumOfNodes When pNodes is NULL, this is treated as out parameter, and if the function successfully returns, will hold the 
//!                             total number of nodes in the DPMST topology.
//!                             When pNodes in NOT NULL, this is treated as both IN and OUT parameter. 
//!                             On the input path, this will hold the total size of the array that pNodes is pointing to.
//!                             On the output path, this will hold the actual number of nodes in the DPMST topology. If this actual 
//!                             value is greater than the input value, the API will return LWAPI_INSUFFICIENT_BUFFER.
//!
//! 
//! \retval ::LWAPI_INSUFFICIENT_BUFFER  When the actual number of nodes in the topology exceed the number of elements allocated for pNodes. 
//! \retval ::LWAPI_DPMST_CHANGED        The DPMST topology has changed midway while fetching the details. Please retry again.
//! 
//! \ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_QueryDPTopology(__in LwU32 displayId, __inout_ecount_full_opt(*pNumOfNodes) LW_DP_NODE_INFO* pNodes, __inout LwU32* pNumOfNodes);




#define MAX_PCLK_RANGES 10

//! \addtogroup gpuclock
//! @{

//! Used in LW_SET_PCLK and LW_GET_PCLK.
typedef struct
{
    LwU32           uMaxPixClk;                         //!< Maximum Upper Frequency
    LwU32           uMinPixClk;                         //!< Minimum Upper Frequency
} LW_PCLK_RANGE;


//! Used in LwAPI_GPU_GetPixelClockRange().
typedef struct
{
    LwU32           uOrgPixelClock;                     //!< Original Frequency in Hz
    LwU32           uLwrrPixelClock;                    //!< Frequency in Hz
    LwU32           uLwrrSpreadSpectrum;                //!< Spread Spectrum Range in Hz
    LW_PCLK_RANGE   uFineAdjustBounds;                  //!< Optional: Upper/Lower bounds
                                                        //!< If not present then only 
                                                        //!< course adjustment is supported. 
    LW_PCLK_RANGE   uCourseAdjustBounds;                //!< Timing Shift Upper/Lower
} LW_GET_PCLK;


//! Used in LwAPI_GPU_SetPixelClockRange().
typedef struct
{
    LW_PCLK_RANGE   uAllowedRanges[MAX_PCLK_RANGES];    //!< Allowed List
    LW_PCLK_RANGE   uDisallowedRanges[MAX_PCLK_RANGES]; //!< Disallowed List
} LW_SET_PCLK;


//! @}


///////////////////////////////////////////////////////////////////////////////
//
// GPS (previously known as OptimusBoost) APIs
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_GPS_GetPowerSteeringStatus
//! \fn            LwAPI_GPS_GetPowerSteeringStatus(__out LW_GPS_PS_STATUS *pPowerSteeringStatus)
//!
//! DESCRIPTION:   This API retrieves the current power steering status.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[out]    pPowerSteeringStatus
//!                    0 = Power steering disabled
//!                    1 = PowerSteering enabled
//!                    2 = not supported on this platform
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                If there are return error codes with specific meaning for this API, 
//!                they are listed below.
//!
//! \retval        LWAPI_OK - completed request
//! \retval        LWAPI_ERROR - miscellaneous error oclwrred
//! \retval        LWAPI_NOT_SUPPORTED - GPS feature is not available on the target hardware
//! \retval        LWAPI_ILWALID_ARGUMENT - invalid argument passed
//! \retval        LWAPI_API_NOT_INTIALIZED - lwapi not initialized
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup lwpmapi 
typedef enum {
    LW_GPS_PS_DISABLED      = 0,
    LW_GPS_PS_ENABLED       = 1,
    LW_GPS_PS_NOT_SUPPORTED = 2
} LW_GPS_PS_STATUS;

//! \ingroup lwpmapi 
LWAPI_INTERFACE LwAPI_GPS_GetPowerSteeringStatus(__out LW_GPS_PS_STATUS *pPowerSteeringStatus);   


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPS_SetPowerSteeringStatus
//
//! DESCRIPTION:     This API enables or disables GPS power steering.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//!\ param[in]       PowerSteeringStatus
//!                      0 = Power steering disabled
//!                      1 = PowerSteering enabled
//!                      any other value - not invalid
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                If there are return error codes with specific meaning for this API, 
//!                they are listed below.
//!
//! \retval        LWAPI_OK - completed request
//! \retval        LWAPI_ERROR - miscellaneous error oclwrred
//! \retval        LWAPI_NOT_SUPPORTED - GPS feature is not available on the target hardware
//! \retval        LWAPI_ILWALID_ARGUMENT - invalid argument passed
//! \retval        LWAPI_API_NOT_INTIALIZED - lwapi not initialized
//!
//! \ingroup lwpmapi 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPS_SetPowerSteeringStatus(__in LW_GPS_PS_STATUS PowerSteeringStatus);   


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPS_GetFrmData
//! \fn              LwAPI_GPS_GetFrmData(__inout LW_GPS_GET_FRM_DATA *pFrmData)
//
//! DESCRIPTION:     This API will fetch FRM related parameters.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param[out]    frmSampleData - Contains frame specific data.
//! \param[out]    nextSampleNumber - Sample number contain sample number on which next
//!                frame data is entered. Also with this we get to know till what point 
//!                array is filled.
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                If there are return error codes with specific meaning for this API, 
//!                they are listed below.
//!
//! \retval        LWAPI_OK - completed request
//! \retval        LWAPI_NOT_SUPPORTED - GPS feature is not available on the target hardware
//!
//! \ingroup lwpmapi 
///////////////////////////////////////////////////////////////////////////////
//! \ingroup lwpmapi   
// This size should be in sync with size of buffer in RM. 
#define MAX_GPS_FRM_BUFFER_SIZE   64

typedef struct _LW_GPS_GET_FRM_DATA_NODE
{
    LwU16 frameTime;
    LwU16 renderTime;
    LwU16 targetTime;
    LwU8  clientID;
    LwU8  sampleNumber;
} LW_GPS_GET_FRM_DATA_NODE;

//! \ingroup lwpmapi
typedef struct _LW_GPS_GET_FRM_DATA
{
    LwU32   version;                             //!< Version of this structure
    LwU8  nextSampleNumber;                      //!< contain sample number on which next frame data will entered.
    LW_GPS_GET_FRM_DATA_NODE frmSampleData[MAX_GPS_FRM_BUFFER_SIZE];

} LW_GPS_GET_FRM_DATA_V1;

//! \ingroup lwpmapi 
typedef LW_GPS_GET_FRM_DATA_V1      LW_GPS_GET_FRM_DATA;

//! \ingroup lwpmapi
#define LW_GPS_GET_FRM_DATA_VER_1   MAKE_LWAPI_VERSION(LW_GPS_GET_FRM_DATA,1)

//! \ingroup lwpmapi
#define LW_GPS_GET_FRM_DATA_VER     LW_GPS_GET_FRM_DATA_VER_1

LWAPI_INTERFACE LwAPI_GPS_GetFrmData(__inout LW_GPS_GET_FRM_DATA *pFrmData); 


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPS_SetVPStateCap 
//
//! DESCRIPTION:    This API sets the Virtual P state cap
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//! \param[in]     newCap - Requested New Virtual P State Cap
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                If there are return error codes with specific meaning for this API, 
//!                they are listed below.
//!
//! \retval        LWAPI_OK - completed request
//! \retval        LWAPI_ERROR - miscellaneous error oclwrred
//! \retval        LWAPI_NOT_SUPPORTED - GPS is not available on the target hardware
//! \retval        LWAPI_ILWALID_ARGUMENT - invalid argument passed
//! \retval        LWAPI_API_NOT_INTIALIZED - lwapi not initialized
//!
//! \ingroup lwpmapi 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPS_SetVPStateCap(__in LwPhysicalGpuHandle hPhysicalGpu,
                                        __in LwU32 newCap); 


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_GPS_GetVPStateCap 
//
//! DESCRIPTION:   This API retrieves the current Virtual P State Cap.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[out]    pLwrCap - Current Virtual P State Cap
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                If there are return error codes with specific meaning for this API, 
//!                they are listed below.
//!
//! \retval        LWAPI_OK - completed request
//! \retval        LWAPI_ERROR - miscellaneous error oclwrred
//! \retval        LWAPI_NOT_SUPPORTED - GPS feature is not available on the target hardware
//! \retval        LWAPI_ILWALID_ARGUMENT - invalid argument passed
//! \retval        LWAPI_API_NOT_INTIALIZED - lwapi not initialized
//!
//! \ingroup lwpmapi 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPS_GetVPStateCap(__in  LwPhysicalGpuHandle hPhysicalGpu,
                                        __out LwU32 *pLwrCap);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_GPS_GetThermalLimit 
//! \fn            LwAPI_GPS_GetThermalLimit(__inout LW_GPS_GET_THERMAL_LIMIT_PARM *pParams)
//!
//! DESCRIPTION:   This API retrieves the information on the limit for the requested sensor.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[in/out]  pParams -- pointer to parameter block
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                If there are return error codes with specific meaning for this API, 
//!                they are listed below.
//!
//! \retval        LWAPI_OK - completed request
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup lwpmapi 
typedef enum {
    LW_GPS_SENSOR_INDEX_TGPU_LIMIT             =  9,
    LW_GPS_SENSOR_INDEX_PDTS_LIMIT             = 10,
    LW_GPS_SENSOR_INDEX_SFAN_LIMIT             = 11,
    LW_GPS_SENSOR_INDEX_SKNT_LIMIT             = 12,
    LW_GPS_SENSOR_INDEX_CPUE_LIMIT             = 13,
    LW_GPS_SENSOR_INDEX_TMP1_LIMIT             = 14,
    LW_GPS_SENSOR_INDEX_TMP2_LIMIT             = 15
} LW_GPS_SENSOR_INDEX;

//! \ingroup lwpmapi 
typedef enum {
    LW_GPS_THERM_LIMIT_SRC_USER_LIMITED        = 1,
    LW_GPS_THERM_LIMIT_SRC_SBIOS_LIMITED       = 2,
    LW_GPS_THERM_LIMIT_SRC_SBIOS_UNLIMITED     = 3,
    LW_GPS_THERM_LIMIT_SRC_SBIOS_NOT_SUPPORTED = 4,
    LW_GPS_THERM_LIMIT_SRC_USER_DISABLED       = 5
} LW_GPS_THERM_LIMIT_SRC;

//! \ingroup lwpmapi
#define LW_GPS_THERM_LIMIT_SBIOS_LIMITED         0
//! \ingroup lwpmapi
#define LW_GPS_THERM_LIMIT_NOT_LIMITED           1

//! \ingroup lwpmapi 
typedef struct _LW_GPS_GET_THERMAL_LIMIT_PARM {

    // IN
    LwU32   version;                       //!< Version of this structure
    LW_GPS_SENSOR_INDEX sensorIndex;       //!< Id of the sensor to retrieve the current thermal limit from.
                                           //!<     refer to enum LW_GPS_SENSOR_INDEX above.
    
    
    // OUT
    LwU32                   limit;         //!< 0 = no limit
                                           //!< any other value -- current thermal limit.
    LwU32                   lowerBound;    //!< Minimum value permitted for thermal limit.
    LwU32                   upperBound;    //!< Maximim value permitted for thermal limit.
    LW_GPS_THERM_LIMIT_SRC  limitSource;   //!< specifies what is determining the limit for the specified sensor.
                                           //!<     refer to enum LW_GPS_THERM_LIMIT_SRC above.
} LW_GPS_GET_THERMAL_LIMIT_PARM_V1;

//! \ingroup lwpmapi 
typedef LW_GPS_GET_THERMAL_LIMIT_PARM_V1      LW_GPS_GET_THERMAL_LIMIT_PARM;
//! \ingroup lwpmapi 
#define LW_GPS_GET_THERMAL_LIMIT_PARM_VER_1   MAKE_LWAPI_VERSION(LW_GPS_GET_THERMAL_LIMIT_PARM_V1,1)
//! \ingroup lwpmapi 
#define LW_GPS_GET_THERMAL_LIMIT_PARM_VER     LW_GPS_GET_THERMAL_LIMIT_PARM_VER_1

//! \ingroup lwpmapi 
LWAPI_INTERFACE LwAPI_GPS_GetThermalLimit(__inout LW_GPS_GET_THERMAL_LIMIT_PARM *pParams);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPS_SetThermalLimit 
//! \fn             LwAPI_GPS_SetThermalLimit(__in LW_GPS_SET_THERMAL_LIMIT_PARM *pParams)
//!
//! DESCRIPTION:    This API sets the thermal limit for the specified sensor.
//!
//! \since Release: 290
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[in,out]  pParams -- pointer to parameter block
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                If there are return error codes with specific meaning for this API, 
//!                they are listed below.
//!
//! \retval        LWAPI_OK - completed request
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup lwpmapi 
typedef struct _LW_GPS_SET_THERMAL_LIMIT_PARM {

    // IN
    LwU32   version;                   //!< Version of this structure
    LW_GPS_SENSOR_INDEX sensorIndex;   //!< Id of the sensor whose limit we are setting.
                                       //!<     refer to enum LW_GPS_SENSOR_INDEX above.
    LwU32    newLimit;                 //!< the new limit to apply to the sensor.
    
    // OUT
                                    
} LW_GPS_SET_THERMAL_LIMIT_PARM_V1;

//! \ingroup lwpmapi 
typedef LW_GPS_SET_THERMAL_LIMIT_PARM_V1      LW_GPS_SET_THERMAL_LIMIT_PARM;
//! \ingroup lwpmapi 
#define LW_GPS_SET_THERMAL_LIMIT_PARM_VER_1   MAKE_LWAPI_VERSION(LW_GPS_SET_THERMAL_LIMIT_PARM_V1,1)
//! \ingroup lwpmapi 
#define LW_GPS_SET_THERMAL_LIMIT_PARM_VER     LW_GPS_SET_THERMAL_LIMIT_PARM_VER_1

//! \ingroup lwpmapi 
LWAPI_INTERFACE LwAPI_GPS_SetThermalLimit(__in LW_GPS_SET_THERMAL_LIMIT_PARM *pParams);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPS_Ctrl 
//! \fn             LwAPI_GPS_Ctrl(__inout LW_GPS_CTRL_PARM *pParams)
//!
//! DESCRIPTION:    This API provides control functions for GPS.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[in]     cmd      -- indicates which control command to execute
//! \param[in]     input[]  -- input for the specified command, exact nature of the data is dependent on the command.
//! \param[out]    result[] -- result for the specified command, exact nature of the data is dependent on the command.
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. 
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup lwpmapi 
typedef enum {
    LwGpsGetPowerSteeringStatus         =  0,     //!<   result[0] -- current power stearing status.
    LwGpsSetPowerSteeringStatus         =  1,     //!<   input[0]  -- new power steering value.
    LwGpsGetThermLimit                  =  2,     //!<   input[0]  -- sensor id.
                                                  //!<   result[0] -- current limit.
                                                  //!<   result[1] -- min limit value.
                                                  //!<   result[2] -- max limit value.
                                                  //!<   result[3] -- limit source.
    LwGpsSetThermLimit                  =  3,     //!<   input[0]  -- sensor id.
                                                  //!<   input[1]  -- new limit.
    LwGpsGetTempCtrlDownNDelta          =  4,     //!<   input[0]  -- sensor id.
                                                  //!<   result[0] -- current delta.
    LwGpsSetTempCtrlDownNDelta          =  5,     //!<   input[0]  -- sensor id.
                                                  //!<   input[1]  -- new delta.
    LwGpsGetTempCtrlHoldDelta           =  6,     //!<   input[0]  -- sensor id.
                                                  //!<   result[0] -- current delta.
    LwGpsSetTempCtrlHoldDelta           =  7,     //!<   input[0]  -- sensor id.
                                                  //!<   input[1]  -- new delta.
    LwGpsGetTempCtrlUpDelta             =  8,     //!<   input[0]  -- sensor id.
                                                  //!<   result[0] -- current delta.
    LwGpsSetTempCtrlUpDelta             =  9,     //!<   input[0]  -- sensor id.
                                                  //!<   input[1]  -- new delta.
    LwGpsGetTempCtrlEngageDelta         = 10,     //!<   input[0]  -- sensor id.
                                                  //!<   result[0] -- current delta.
    LwGpsSetTempCtrlEngageDelta         = 11,     //!<   input[0]  -- sensor id.
                                                  //!<   input[1]  -- new delta.
    LwGpsGetTempCtrlDisengageDelta      = 12,     //!<   input[0]  -- sensor id.
                                                  //!<   result[0] -- current delta.
    LwGpsSetTempCtrlDisengageDelta      = 13,     //!<   input[0]  -- sensor id.
                                                  //!<   input[1]  -- new delta.
    LwGpuGetEngadgeThresholdUp          = 14,     //!<   result[0] -- current engage threshold.
    LwGpuSetEngadgeThresholdUp          = 15,     //!<   input[0]  -- new engage threshold.
    LwGpuGetDisengageThresholdDown      = 16,     //!<   result[0] -- current disengage threshold.
    LwGpuSetDisengageThresholdDown      = 17,     //!<   input[0]  -- new disengage threshold.
    LwCpuGetHystHigh                    = 18,     //!<   result[0] -- current hysterisis upper limit.
    LwCpuSetHystHigh                    = 19,     //!<   input[0]  -- new hysterisis upper limit.
    LwCpuGetHystLow                     = 20,     //!<   result[0] -- current  hysterisis lower limit.
    LwCpuSetHystLow                     = 21,     //!<   input[0]  -- new hysterisis lower limit.
    LwGpsGetTempCtrl                    = 22,     //!<   result[0] -- current temp ctrl setting.
    LwGpsSetTempCtrl                    = 23,     //!<   input[0]  -- new temp ctrl setting.
    LwCpuGetUtilAvgNum                  = 24,     //!<   result[0] -- current number of samples to average.
    LwCpuSetUtilAvgNum                  = 25,     //!<   input[0]  -- new number of samples to average.
    LwGpsGetPerfCounter                 = 26,     //!<   input[0]  -- counter id being requested.
                                                  //!<   input[1]  -- next expected poll cycle in ms (0 = not expecting to poll).
                                                  //!<   result[0] -- current value for requested counter.
    LwGpsCallAcpi                       = 27,     //!<   input[0]  -- ACPI Command
                                                  //!<   input[1]  -- ACPI Command input parameter
                                                  //!<   result[0] -- ACPI command response 1
                                                  //!<   result[1] -- ACPI command response 2
    LwGpsSetIGpuTurbo                   = 28      //!<   input[0]  -- new igpu turbo state (bool for enabled/disabled)
} LW_GPS_CTRL_CMD;

//! \ingroup lwpmapi 
typedef struct _LW_GPS_CTRL_PARM_V1
{
    // IN
    LwU32   version;                   //!< Version of this structure
    LW_GPS_CTRL_CMD cmd;               //!< the command the GPS control system should execute
                                       //!<     refer to enum LW_GPS_CTRL_CMD above.
    LwS32    input[2];                 //!< the input to use for the command specified in cmd.
    
    // OUT
    LwS32    result[4];                //!< the result/output from exelwting the specified command.
                                    
} LW_GPS_CTRL_PARM_V1;

//! \ingroup lwpmapi 
typedef LW_GPS_CTRL_PARM_V1      LW_GPS_CTRL_PARM;
//! \ingroup lwpmapi 
#define LW_GPS_CTRL_PARM_VER_1   MAKE_LWAPI_VERSION(LW_GPS_CTRL_PARM_V1,1)
//! \ingroup lwpmapi 
#define LW_GPS_CTRL_PARM_VER     LW_GPS_CTRL_PARM_VER_1
LWAPI_INTERFACE LwAPI_GPS_Ctrl(__inout LW_GPS_CTRL_PARM *pParams);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPS_CallACPI 
//! \fn             LwAPI_GPS_CallACPI(__inout LW_GPS_ACPI_PARM *pParams)
//!
//! DESCRIPTION:    This API calls the specified ACPI command for testing purposes.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[in]     cmd      -- indicates which control command to execute
//! \param[in]     input[]  -- input for the specified command, exact nature of the data is dependent on the command.
//! \param[out]    result[] -- result for the specified command, exact nature of the data is dependent on the command.
//!                            number of entries in array result depends on the size of struct PSS_ENTRY and value of ACPI_PSS_ENTRY_MAX.
//!                            while the former is 6 LwU32 long, the later is 32. 
//!                            thus, MAX_GPS_ACPI_RESULT_BUFFER cannot be smaller than 192
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. 
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup lwpmapi 
#define MAX_GPS_ACPI_RESULT_BUFFER  192

//! \ingroup lwpmapi 
typedef struct _LW_GPS_ACPI_PARM_V1
{
    // IN
    LwU32   version;                             //!< Version of this structure
    LwU32   cmd;                                 //!< the ACPI command the GPS control system should execute -
                                                 //!<     refer to GPS spec.
    LwU32   input;                               //!< the input to use for the command specified in cmd.
    
    // OUT
    LwU32   resultSz;                            //!< size of the result buffer for the specified command.
    LwU32   result[MAX_GPS_ACPI_RESULT_BUFFER];  //!< the result/output from exelwting the specified command.

} LW_GPS_ACPI_PARM_V1;

//! \ingroup lwpmapi 
typedef LW_GPS_ACPI_PARM_V1      LW_GPS_ACPI_PARM;

//! \ingroup lwpmapi 
#define LW_GPS_ACPI_PARM_VER_1   MAKE_LWAPI_VERSION(LW_GPS_ACPI_PARM_V1,1)

//! \ingroup lwpmapi 
#define LW_GPS_ACPI_PARM_VER     LW_GPS_ACPI_PARM_VER_1

//! \ingroup lwpmapi 
LWAPI_INTERFACE LwAPI_GPS_CallACPI(__inout LW_GPS_ACPI_PARM *pParams);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPS_GetPerfSensors
//! \fn             LwAPI_GPS_GetPerfSensors(__inout LW_GPS_PERFSENSORS_PARM *pParams)
//!
//! \since Release: 290
//!
//! DESCRIPTION:    This API returns various counters that indicate the state of GPS, Thermal controller, and power steering
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[in,out]  pParams -- pointer to parameter block
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. 
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup lwpmapi 
//! @{


#define GPS_PSC_PS_TC_DYNAMIC_SENSOR_BLOCK 0
#define GPS_PSC_PS_TC_CPU_UTIL_SENSOR_BLOCK 2
#define GPS_PSC_ACPI_SENSOR_BLOCK 3

typedef enum {
    GPS_PSC_SB0_PS_SID           =      0,   //!< Power Steering Sample Id
    GPS_PSC_SB0_PS_ENABLE        =      1,   //!< Power steering enabled
    GPS_PSC_SB0_CPU_PSTATE_CAP   =      5,   //!< CPU PState Cap
    GPS_PSC_SB0_CPU_TSTATE_CAP   =      7,   //!< CPU TState Cap
    GPS_PSC_SB0_GPU_UTIL         =      9,   //!< GPU Utilization
    GPS_PSC_SB0_GPU_TEMP         =     15,   //!< current GPU temp
    GPS_PSC_SB0_TC_TRGT_TEMP     =     16,   //!< Thermal Controller Target temp
    GPS_PSC_SB0_PM1_STATE_AVAIL  =     18,   //!< PM1 availability
    GPS_PSC_SB0_TDP_IDX          =     19,   //!< TDP PState index
    GPS_PSC_SB0_GPU_VPSTATE      =     24,   //!< current GPU VPState
    GPS_PSC_SB0_GPU_VPSTATE_CAP  =     25,   //!< GPU VPState Cap
    GPS_PSC_SB0_TGPU_LWRR_VALUE  =     26,   //!< current GPU temp
} GPS_PSC_SB0_INDEX;
//! @}

//! \ingroup lwpmapi 
typedef struct _LW_GPS_GET_PERF_SENSOR_COUNTERS_PARAM_V1 {

    // IN
    LwU32    version;                   //!< Version of this structure
    LwU32    objHndl;                   //!< object handle
    LwU16    blockId;                   //!< Id of the BLock to return
    LwU32    nextExpectedSampleTime;    //!< a relative time period in ms
                                        //!< indicating when the 
                                        //!< application next expects to 
                                        //!< sample the counters. This is 
                                        //!< used as a hint to try to 
                                        //!< optimize the collection of 
                                        //!< the sensor data to minimize 
                                        //!< overhead when the function is 
                                        //!< called again. If it is not 
                                        //!< known when the next expected 
                                        //!< sampling will be done, or you 
                                        //!< do not expect to do any more 
                                        //!< sampling a value of 0 should 
                                        //!< be used. (other values may 
                                        //!< result in extra sensor 
                                        //!< sampling)

    LwU32    countersReq;               //!< Bitmap of counters within       
                                        //!< specified block to return

    // OUT
    LwU32    countersReturned;          //!< Bitmap of counters populated 
                                        //!< within the returned block
    LwU32    counterBlock[32];          //!< Returned counters. Counters 
                                        //!< not indicated as returned in
                                        //!< the CountersReturned bitmap
                                        //!< are undefined

} LW_GPS_GET_PERF_SENSOR_COUNTERS_PARAM_V1;

//! \ingroup lwpmapi 
typedef LW_GPS_GET_PERF_SENSOR_COUNTERS_PARAM_V1      LW_GPS_GET_PERF_SENSOR_COUNTERS_PARAM;
//! \ingroup lwpmapi 
#define LW_GPS_GET_PERF_SENSOR_COUNTERS_PARAM_VER_1   MAKE_LWAPI_VERSION(LW_GPS_GET_PERF_SENSOR_COUNTERS_PARAM_V1,1)
//! \ingroup lwpmapi 
#define LW_GPS_GET_PERF_SENSOR_COUNTERS_PARAM_VER     LW_GPS_GET_PERF_SENSOR_COUNTERS_PARAM_VER_1

//! \ingroup lwpmapi 
LWAPI_INTERFACE LwAPI_GPS_GetPerfSensors(__inout LW_GPS_GET_PERF_SENSOR_COUNTERS_PARAM *pParams);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPS_GetPerfSensorsInternal
//! \fn             LwAPI_GPS_GetPerfSensorsInternal(__inout LW_GPS_PERFSENSORS_PARM *pParams)
//!
//! \since Release: 290
//!
//! DESCRIPTION:    This API is identical to the LwAPI_GPS_GetPerfSensors, except it is private, and returns an extended set of counters.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[in]     objHndl  -- handle for object that may be required to get sensorData -- lwrrently not used.
//! \param[in]     blockId  -- Id for the block of 32 counters to be retrieved.
//! \param[in]     nextExpectedSampleTime -- the time in ms indicating when the next expected call
//!                for the sensor block will be made. This is used as a hint for scheduling future
//!                reads of the sensors. Set to 0 if this is unknown, or no next call is expected.
//! \param[in]     countersReq -- a bitmask indicating which counters within the block are being requested.
//! \param[out]    countersReturned -- a bitmask indicating which counters have been returned.
//! \param[out]    counterBlock -- an array of 32 counters containing the counters 
//!                indicated in the countersReturned parameter.
//
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. 
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup lwpmapi 
//! @{
typedef enum {
    GPS_PSC_EXT_SB0_PS_SID                =  0,   //!< Power Steering Sample Id
    GPS_PSC_EXT_SB0_PS_ENABLE             =  1,   //!< Power steering enabled
    GPS_PSC_EXT_SB0_CPU_TEMP              =  2,   //!< current CPU temp
    GPS_PSC_EXT_SB0_PS_CPU_CORE_UTIL_MAX  =  3,   //!< CPU utilization of busiest core
    GPS_PSC_EXT_SB0_CPU_PSTATE            =  4,   //!< current CPU PState
    GPS_PSC_EXT_SB0_CPU_PSTATE_CAP        =  5,   //!< CPU PState Cap
    GPS_PSC_EXT_SB0_CPU_TSTATE            =  6,   //!< current CPU TState
    GPS_PSC_EXT_SB0_CPU_TSTATE_CAP        =  7,   //!< CPU TState Cap
    GPS_PSC_EXT_SB0_PPC_LIMIT             =  8,   //!< current programmed PPC Limit
    GPS_PSC_EXT_SB0_GPU_UTIL              =  9,   //!< GPU Utilization
    GPS_PSC_EXT_SB0_GPU_CORE_UTIL         = 10,   //!< GPU Core utilization
    GPS_PSC_EXT_SB0_GPU_FB_UTIL           = 11,   //!< Frame buffer Utilization
    GPS_PSC_EXT_SB0_GPU_VIDEO_UTIL        = 12,   //!< Video utilization
    GPS_PSC_EXT_SB0_TC_SID                = 13,   //!< Thermal controller sample Id
    GPS_PSC_EXT_SB0_TC_ENABLE             = 14,   //!< Thermal controller enabled
    GPS_PSC_EXT_SB0_GPU_TEMP              = 15,   //!< current GPU temp
    GPS_PSC_EXT_SB0_TC_TRGT_TEMP          = 16,   //!< Thermal Controller Target temp
    GPS_PSC_EXT_SB0_PM1_SID               = 17,   //!< PM1 Sample Id
    GPS_PSC_EXT_SB0_PM1_STATE_AVAIL       = 18,   //!< PM1 availability
    GPS_PSC_EXT_SB0_TDP_IDX               = 19,   //!< TDP PState index
    GPS_PSC_EXT_SB0_MS_SID                = 20,   //!< Misc Sample Id
    GPS_PSC_EXT_SB0_IGP_TURBO_STATUS      = 21,   //!< IGP Turbo enabled
    GPS_PSC_EXT_SB0_GPU_GPC_CLK           = 22,   //!< current GPC clock
    GPS_PSC_EXT_SB0_GPU_LWDD              = 23,   //!< 
    GPS_PSC_EXT_SB0_GPU_FSTATE            = 24,   //!< current GPU FState
    GPS_PSC_EXT_SB0_GPU_FSTATE_CAP        = 25,   //!< GPU FState Cap
    GPS_PSC_EXT_SB0_TGPU_LWRR_VALUE       = 26,   //!< current GPU temp
    GPS_PSC_EXT_SB0_PS_APERF_CPU_FREQ     = 28,   //!< CPU Freq as reported via aperf
    GPS_PSC_EXT_SB0_PS_MSR_CPU_FREQ       = 29,   //!< CPU Freq as reported via MSR
    GPS_PSC_EXT_SB0_PS_EXP_CPU_FREQ       = 30,   //!< CPU Freq as reported via Pstate tbl
} GPS_PSC_EXT_SB0_INDEX;

typedef enum {
    GPS_PSC_EXT_SB1_PS_SID                =  0,   //!< Power Steering Sample Id
    GPS_PSC_EXT_SB1_PS_SAMPLE_PERIOD_MS   =  1,   //!< Power steering polling interval
    GPS_PSC_EXT_SB1_PS_ENGAGE_TEMP_DELTA  =  2,   //!< Power steering engage temp delta
    GPS_PSC_EXT_SB1_PS_CPU_MIN_FREQ_MHZ   =  3,   //!< Power steering Min CPU freq
    GPS_PSC_EXT_SB1_PS_CPU_MAX_FREQ_MHZ   =  4,   //!< Power steering Max CPU freq
    GPS_PSC_EXT_SB1_PS_CPU_HYST_HIGH      =  5,   //!< Power steering upper hysteresis limit
    GPS_PSC_EXT_SB1_PS_CPU_HYST_LOW       =  6,   //!< Power steering lower hysteresis limit
    GPS_PSC_EXT_SB1_PS_CPU_C0_CORE_THRESH =  7,   //!< Power steering CPU utilization Threshold
    GPS_PSC_EXT_SB1_PS_CPU_UTIL_AVG_NUM   =  8,   //!< Power steering number of utilization samples to average
    GPS_PSC_EXT_SB1_TC_SID                = 12,   //!< Thermal Controller Sample Id
    GPS_PSC_EXT_SB1_TC_SAMPLE_PERIOD_MS   = 13,   //!< Thermal Controller polling interval
    GPS_PSC_EXT_SB1_TC_ENGAGE_TEMP        = 14,   //!< Thermal Controller engage temp
    GPS_PSC_EXT_SB1_TC_DISENGAGE_TEMP     = 15,   //!< Thermal Controller disengage temp
    GPS_PSC_EXT_SB1_TC_DOWN_N_THRESH      = 16,   //!< Thermal Controller Down N Threshold
    GPS_PSC_EXT_SB1_TC_HOLD_THRESH        = 17,   //!< Thermal Controller Hold Threshold
    GPS_PSC_EXT_SB1_TC_UP_THRESH          = 18,   //!< Thermal Controller Up Threshold
} GPS_PSC_EXT_SB1_INDEX;

typedef enum {
    GPS_PSC_EXT_SB3_TGPU_LWRR_VALUE       =  0,   //!< PShareStatus current GPU temp
    GPS_PSC_EXT_SB3_PDTS_LWRR_VALUE       =  1,   //!< PShareStatus current CPU temp
    GPS_PSC_EXT_SB3_SFAN_LWRR_VALUE       =  2,   //!< PShareStatus current fan speed
    GPS_PSC_EXT_SB3_SKNT_LWRR_VALUE       =  3,   //!< PShareStatus current skin temp
    GPS_PSC_EXT_SB3_CPUE_LWRR_VALUE       =  4,   //!< PShareStatus current CPU energy
    GPS_PSC_EXT_SB3_TMP1_LWRR_VALUE       =  5,   //!< PShareStatus current tmp 1 counter
    GPS_PSC_EXT_SB3_TMP2_LWRR_VALUE       =  6,   //!< PShareStatus current tmp 2 counter
    GPS_PSC_EXT_SB3_TGPU_LIMIT            =  8,   //!< PShareStatus GPU temp limit
    GPS_PSC_EXT_SB3_PDTS_LIMIT            =  9,   //!< PShareStatus CPU temp limit
    GPS_PSC_EXT_SB3_FAN_LIMIT             = 10,   //!< PShareStatus fan speed limit
    GPS_PSC_EXT_SB3_SKNT_LIMIT            = 11,   //!< PShareStatus skin temp limit
    GPS_PSC_EXT_SB3_CPUE_LIMIT            = 12,   //!< PShareStatus CPU energy limit
    GPS_PSC_EXT_SB3_TMP1_LIMIT            = 13,   //!< PShareStatus tmp 1 counter limit
    GPS_PSC_EXT_SB3_TMP2_LIMIT            = 14,   //!< PShareStatus tmp 2 counter limit
    GPS_PSC_EXT_SB3_TGPU_PERIOD           = 16,   //!< PShareStatus GPU temp min sample interval
    GPS_PSC_EXT_SB3_PDTS_PERIOD           = 17,   //!< PShareStatus CPU temp min sample interval
    GPS_PSC_EXT_SB3_SFAN_PERIOD           = 18,   //!< PShareStatus fan speed min sample interval
    GPS_PSC_EXT_SB3_SKNT_PERIOD           = 19,   //!< PShareStatus skin temp min sample interval
    GPS_PSC_EXT_SB3_CPUE_PERIOD           = 20,   //!< PShareStatus CPU energy min sample interval
    GPS_PSC_EXT_SB3_TMP1_PERIOD           = 21,   //!< PShareStatus tmp 1 counter min sample interval
    GPS_PSC_EXT_SB3_TMP2_PERIOD           = 22,   //!< PShareStatus tmp 2 counter min sample interval
    GPS_PSC_EXT_SB3_AVAIL_SENSOR_MSK      = 24,   //!< PShareStatus sensor available mask
    GPS_PSC_EXT_SB3_IGP_TURBO_STATUS      = 25,   //!< IGP Turbo enabled
    GPS_PSC_EXT_SB3_CPU_CORE_COUNT        = 26,   //!< CPU logical core count
    GPS_PSC_EXT_SB3_CPU_CORE_UTIL_MAX     = 27,   //!< CPU Utilization of busiest core.
} GPS_PSC_EXT_SB3_INDEX;
//! @}

//! \ingroup lwpmapi 
LWAPI_INTERFACE LwAPI_GPS_GetPerfSensorsInternal(__inout LW_GPS_GET_PERF_SENSOR_COUNTERS_PARAM *pParams);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPS_GetPM1Available
//! \fn             LwAPI_GPS_GetPM1Available(__out LwU32 *pAvailable)
//!
//! \since Release: 290
//!
//! DESCRIPTION:    This API retrieves the current PM1 availability
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[out]    pAvailable -- a boolean indicating if PM1 is available
//
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. 
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup lwpmapi 
LWAPI_INTERFACE LwAPI_GPS_GetPM1Available(__out LwU32 *pAvailable);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPS_SetPM1Available
//! \fn             LwAPI_GPS_SetPM1Available(__in LwU32 Available)
//!
//! \since Release: 290
//!
//! DESCRIPTION:    This API attempts to set the current PM1 availability
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[out]    Available -- a boolean indicating if PM1 should be made available
//
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. 
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup lwpmapi 
LWAPI_INTERFACE LwAPI_GPS_SetPM1Available(__in LwU32 Available);



//! \ingroup lwpmapi
//! @{
typedef struct
{
    LwU32  version;         //!< Version of the structure.
    LwU32  enabled:1;       //!< Enable/disable GPS WEB.
    LwU32  reserved:31;     //!< Reserved for future use. Must be set to 0.
    LwU32  frameTimeUs;     //!< frame time in microseconds for FRL.
} LW_GPS_WEB_INFO_V1;

typedef LW_GPS_WEB_INFO_V1      LW_GPS_WEB_INFO;
#define LW_GPS_WEB_INFO_VER1    MAKE_LWAPI_VERSION(LW_GPS_WEB_INFO_V1,1)
#define LW_GPS_WEB_INFO_VER     LW_GPS_WEB_INFO_VER1
//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPS_SetWebInfo
//!
//! DESCRIPTION:    This API sets GPS Workload Energy Balancer (WEB) settings.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[in]      pInfo -- GPS WEB settings, see LW_GPS_WEB_INFO
//
//! \return         This API can return any of the error codes enumerated in #LwAPI_Status. 
//!
//! \ingroup lwpmapi
///////////////////////////////////////////////////////////////////////////////

//! \ingroup lwpmapi 
LWAPI_INTERFACE LwAPI_GPS_SetWebInfo(__in LW_GPS_WEB_INFO *pInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetPixelClockRange
//
//! DESCRIPTION:   This API retrieves the current pixel clock settings from the driver.
//!
//!                  NOTE 1: use hPhysicalGpu=NULL and outputId=0 to specify the
//!                  first internal panel.
//!
//!                  NOTE 2: the outputId must refer to an internal panel
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    hPhysicalGpu    GPU selection
//! \param [in]    outputId        Display output id
//! \param [out]   pTimings        Current pixel clock settings
//!
//! 
//! \retval ::LWAPI_OK                   completed request
//! \retval ::LWAPI_API_NOT_INITIALIZED  LWAPI not initialized
//! \retval ::LWAPI_ERROR                miscellaneous error oclwrred
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPixelClockRange(LwPhysicalGpuHandle hPhysicalGpu, LwU32 outputId, LW_GET_PCLK *pTimings);


typedef struct
{
    LwU32           version;

    // the public interface
    LW_GET_PCLK     publicPclkInfo;

    // the private interface
    LwU32           uLwrrMeasuredPixelClock;            // pixel clock retrieved from h/w clock counters in Hz
} LW_GET_PCLK_INTERNAL_V1;

typedef LW_GET_PCLK_INTERNAL_V1 LW_GET_PCLK_INTERNAL;
#define LW_GET_PCLK_INTERNAL_VER1  MAKE_LWAPI_VERSION(LW_GET_PCLK_INTERNAL_V1,1)
#define LW_GET_PCLK_INTERNAL_VER   LW_GET_PCLK_INTERNAL_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetPixelClockRangeInternal
//
//! DESCRIPTION:   This API retrieves the current pixel clock settings from the driver
//!                along with private information found only in the LW_GET_PCLK_INTERNAL structure.  
//!
//!                  NOTE 1: The Display ID must refer to an internal panel.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    displayId       Display ID
//! \param [out]   pPclkInfo       Current pixel clock settings
//!
//! 
//! \retval ::LWAPI_OK                   completed request
//! \retval ::LWAPI_API_NOT_INITIALIZED  LWAPI not initialized
//! \retval ::LWAPI_ERROR                miscellaneous error oclwrred
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPixelClockRangeInternal(LwU32 displayId, LW_GET_PCLK_INTERNAL *pPclkInfo);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_SetPixelClockRange
//
//! DESCRIPTION:   This API passes allowed and disallowed pixel clock values to the 
//!                driver.  If the driver finds a potential timing, it sets the modes 
//!                to this timing.
//!
//!                  NOTE: use hPhysicalGpu=NULL and outputId=0 to specify the
//!                  first internal panel.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    hPhysicalGpu    GPU selection
//! \param [in]    outputId        Display output id
//! \param [in]    pTimings         Allowed and disallowed pixel clock ranges
//!
//! 
//! \retval ::LWAPI_OK                   completed request
//! \retval ::LWAPI_API_NOT_INITIALIZED  LWAPI not initialized
//! \retval ::LWAPI_ERROR                miscellaneous error oclwrred
//! \retval ::LWAPI_ILWALID_ARGUMENT     no suitable pixel clock was found
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetPixelClockRange(LwPhysicalGpuHandle hPhysicalGpu, LwU32 outputId, LW_SET_PCLK *pTimings);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetECCStatusInfo
//
//! \fn LwAPI_GPU_GetECCStatusInfo(LwPhysicalGpuHandle hPhysicalGpu, 
//!                                           LW_GPU_ECC_STATUS_INFO *pECCStatusInfo);
//! DESCRIPTION:     This function returns ECC memory status information.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \param [in]      hPhysicalGpu      A handle identifying the physical GPU for which ECC 
//!                                    status information is to be retrieved.
//! \param [out]     pECCStatusInfo    A pointer to an ECC status structure.
//! 
//! \retval ::LWAPI_OK                  The request was completed successfully.
//! \retval ::LWAPI_ERROR               An unknown error oclwrred.
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE The provided GPU handle is not a physical GPU handle.
//! \retval ::LWAPI_ILWALID_HANDLE      The provided GPU handle is invalid.
//! \retval ::LWAPI_HANDLE_ILWALIDATED  The provided GPU handle is no longer valid.
//! \retval ::LWAPI_ILWALID_POINTER     An invalid argument pointer was provided.
//! \retval ::LWAPI_NOT_SUPPORTED       The request is not supported.
//! \retval ::LWAPI_API_NOT_INTIALIZED  LwAPI was not yet initialized.
//
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup gpuecc
//! Used in LW_GPU_ECC_STATUS_INFO.
typedef enum _LW_ECC_CONFIGURATION
{
    LW_ECC_CONFIGURATION_NOT_SUPPORTED = 0,
    LW_ECC_CONFIGURATION_DEFERRED,           //!< Changes require a POST to take effect
    LW_ECC_CONFIGURATION_IMMEDIATE,          //!< Changes can optionally be made to take effect immediately
} LW_ECC_CONFIGURATION;

//! \ingroup gpuecc
//! Used in LwAPI_GPU_GetECCStatusInfo().
typedef struct
{
    LwU32                 version;               //!< Structure version
    LwU32                 isSupported : 1;       //!< ECC memory feature support
    LW_ECC_CONFIGURATION  configurationOptions;  //!< Supported ECC memory feature configuration options
    LwU32                 isEnabled : 1;         //!< Active ECC memory setting
} LW_GPU_ECC_STATUS_INFO;

//! \ingroup gpuecc
//! Macro for constructing the version field of LW_GPU_ECC_STATUS_INFO
#define LW_GPU_ECC_STATUS_INFO_VER MAKE_LWAPI_VERSION(LW_GPU_ECC_STATUS_INFO,1)

//! \ingroup gpuecc
LWAPI_INTERFACE LwAPI_GPU_GetECCStatusInfo(LwPhysicalGpuHandle hPhysicalGpu, 
                                           LW_GPU_ECC_STATUS_INFO *pECCStatusInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetECCErrorInfo
//
//! \fn LwAPI_GPU_GetECCErrorInfo(LwPhysicalGpuHandle hPhysicalGpu, 
//!                                          LW_GPU_ECC_ERROR_INFO *pECCErrorInfo);
//!
//! DESCRIPTION:     This function returns ECC memory error information.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \param [in]      hPhysicalGpu  A handle identifying the physical GPU for
//!                                which ECC error information is to be
//!                                retrieved.
//! \param [out]     pECCErrorInfo A pointer to an ECC error structure.
//! 
//! \retval ::LWAPI_OK  The request was completed successfully.
//! \retval ::LWAPI_ERROR  An unknown error oclwrred.
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  The provided GPU handle is not a physical GPU handle.
//! \retval ::LWAPI_ILWALID_ARGUMENT  incorrect param value
//! \retval ::LWAPI_ILWALID_POINTER  An invalid argument pointer was provided.
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  structure version is not supported, initialize to LW_GPU_ECC_ERROR_INFO_VER.
//! \retval ::LWAPI_HANDLE_ILWALIDATED  The provided GPU handle is no longer valid.
//! \retval ::LWAPI_NOT_SUPPORTED  The request is not supported.
//! \retval ::LWAPI_API_NOT_INTIALIZED  LwAPI was not yet initialized.
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup gpuecc
//! Used in LwAPI_GPU_GetECCErrorInfo()/
typedef struct
{
    LwU32   version;             //!< Structure version
    struct {
        LwU64  singleBitErrors;  //!< Number of single-bit ECC errors detected since last boot
        LwU64  doubleBitErrors;  //!< Number of double-bit ECC errors detected since last boot
    } current;
    struct {
        LwU64  singleBitErrors;  //!< Number of single-bit ECC errors detected since last counter reset
        LwU64  doubleBitErrors;  //!< Number of double-bit ECC errors detected since last counter reset
    } aggregate;
} LW_GPU_ECC_ERROR_INFO;

//! \ingroup gpuecc
//! Macro for constructing the version field of LW_GPU_ECC_ERROR_INFO
#define LW_GPU_ECC_ERROR_INFO_VER MAKE_LWAPI_VERSION(LW_GPU_ECC_ERROR_INFO,1)

//! \ingroup gpuecc
LWAPI_INTERFACE LwAPI_GPU_GetECCErrorInfo(LwPhysicalGpuHandle hPhysicalGpu, 
                                          LW_GPU_ECC_ERROR_INFO *pECCErrorInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetECCErrorInfoEx
//
//! \fn LwAPI_GPU_GetECCErrorInfoEx(LwPhysicalGpuHandle hPhysicalGpu, LWAPI_GPU_ECC_STATUS_FLAGS_TYPE filter, 
//!                                          LW_GPU_ECC_ERROR_INFO *pECCErrorInfo)
//! \code
//! PARAMETERS:      hPhysicalGpu (IN) - A handle identifying the physical GPU for
//!                                      which ECC error information is to be
//!                                      retrieved.
//!                            filter (IN) - A LWAPI_GPU_ECC_STATUS_FLAGS_TYPE value indicating the choice of filter to be applied
//!                  pECCErrorInfo (OUT) - A pointer to an ECC error structure.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! DESCRIPTION:     This function returns ECC memory error information.
//!
//! RETURN STATUS: 
//!    LWAPI_OK - The request was completed successfully.
//!    LWAPI_ERROR - An unknown error oclwrred.
//!    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - The provided GPU handle is not a physical GPU handle.
//!    LWAPI_ILWALID_ARGUMENT - incorrect param value
//!    LWAPI_ILWALID_POINTER - An invalid argument pointer was provided.
//!    LWAPI_INCOMPATIBLE_STRUCT_VERSION - structure version is not supported, initialize to LW_GPU_ECC_ERROR_INFO_VER.
//!    LWAPI_HANDLE_ILWALIDATED - The provided GPU handle is no longer valid.
//!    LWAPI_NOT_SUPPORTED - The request is not supported.
//!    LWAPI_API_NOT_INTIALIZED - LwAPI was not yet initialized.
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpuecc
typedef enum _LWAPI_GPU_ECC_STATUS_FLAGS_TYPE
{
    LWAPI_GPU_ECC_STATUS_FLAGS_TYPE_FILTERED    = 0x00000000,    //!< This is the default and the only value that can be passed from the public LwAPI_GPU_GetECCErrorInfo api
    LWAPI_GPU_ECC_STATUS_FLAGS_TYPE_RAW            = 0x00000001    //!< All errors as they are obtained from the hardware itself, unfiltered.
    
} LWAPI_GPU_ECC_STATUS_FLAGS_TYPE;

//! \ingroup gpuecc
LWAPI_INTERFACE LwAPI_GPU_GetECCErrorInfoEx(LwPhysicalGpuHandle hPhysicalGpu, LWAPI_GPU_ECC_STATUS_FLAGS_TYPE filter, 
                                          LW_GPU_ECC_ERROR_INFO *pECCErrorInfo);






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_ResetECCErrorInfo
//
//! DESCRIPTION:     This function resets ECC memory error counters.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \param [in]     hPhysicalGpu     A handle identifying the physical GPU for
//!                                  which ECC error information is to be
//!                                  cleared.
//! \param [in]     bResetLwrrent    Reset the current ECC error counters.
//! \param [in]     bResetAggregate  Reset the aggregate ECC error counters.
//! 
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_ILWALID_USER_PRIVILEGE       - The caller does not have administrative privileges
//!
//! \ingroup gpuecc
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ResetECCErrorInfo(LwPhysicalGpuHandle hPhysicalGpu, LwU8 bResetLwrrent,
                                            LwU8 bResetAggregate);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetECCConfigurationInfo
//
//! \fn LwAPI_GPU_GetECCConfigurationInfo(LwPhysicalGpuHandle hPhysicalGpu, 
//!                             LW_GPU_ECC_CONFIGURATION_INFO *pECCConfigurationInfo);
//! DESCRIPTION:     This function returns ECC memory configuration information.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \param [in]      hPhysicalGpu  A handle identifying the physical GPU for
//!                                which ECC configuration information
//!                               is to be retrieved.
//! \param [out]     pECCConfigurationInfo  A pointer to an ECC 
//!                                                configuration structure.
//! 
//! \retval ::LWAPI_OK  The request was completed successfully.
//! \retval ::LWAPI_ERROR  An unknown error oclwrred.
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE  The provided GPU handle is not a physical GPU handle.
//! \retval ::LWAPI_ILWALID_HANDLE  The provided GPU handle is invalid.
//! \retval ::LWAPI_HANDLE_ILWALIDATED  The provided GPU handle is no longer valid.
//! \retval ::LWAPI_ILWALID_POINTER  An invalid argument pointer was provided.
//! \retval ::LWAPI_NOT_SUPPORTED  The request is not supported.
//! \retval ::LWAPI_API_NOT_INTIALIZED  LwAPI was not yet initialized.
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpuecc
//! Used in LwAPI_GPU_GetECCConfigurationInfo(). 
typedef struct
{
    LwU32  version;                 //! Structure version
    LwU32  isEnabled : 1;           //! Current ECC configuration stored in non-volatile memory
    LwU32  isEnabledByDefault : 1;  //! Factory default ECC configuration (static)
} LW_GPU_ECC_CONFIGURATION_INFO;

//! \ingroup gpuecc
//! Macro for consstructing the verion field of LW_GPU_ECC_CONFIGURATION_INFO
#define LW_GPU_ECC_CONFIGURATION_INFO_VER MAKE_LWAPI_VERSION(LW_GPU_ECC_CONFIGURATION_INFO,1)

//! \ingroup gpuecc
LWAPI_INTERFACE LwAPI_GPU_GetECCConfigurationInfo(LwPhysicalGpuHandle hPhysicalGpu, 
                                                  LW_GPU_ECC_CONFIGURATION_INFO *pECCConfigurationInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_SetECCConfiguration
//
//! DESCRIPTION:     This function updates the ECC memory configuration setting.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \param [in]      hPhysicalGpu    A handle identifying the physical GPU for
//!                                  which to update the ECC configuration
//!                                  setting.
//! \param [in]      bEnable         The new ECC configuration setting.
//! \param [in]      bEnableImmediately   Request that the new setting take effect immediately.
//! 
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_ILWALID_CONFIGURATION  - Possibly SLI is enabled. Disable SLI and retry.
//! \retval ::LWAPI_ILWALID_USER_PRIVILEGE - The caller does not have administrative privileges
//!
//! \ingroup gpuecc
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetECCConfiguration(LwPhysicalGpuHandle hPhysicalGpu, LwU8 bEnable,
                                              LwU8 bEnableImmediately);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_InjectECCErrors
//
//! \code
//! PARAMETERS:      hPhysicalGpu (IN) - A handle identifying the physical GPU for
//!                                      which to inject ECC errors.
//!                  singleBitErrors (IN) - The number of single-bit ECC errors
//!                                         to inject.
//!                  doubleBitErrors (IN) - The number of double-bit ECC errors
//!                                         to inject.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:     This function injects artificial ECC errors into the ECC error
//!                  history maintained by the RM.
//!
//! RETURN STATUS: 
//!    LWAPI_OK - The request was completed successfully.
//!    LWAPI_ERROR - An unknown error oclwrred.
//!    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - The provided GPU handle is not a physical GPU handle.
//!    LWAPI_ILWALID_HANDLE - The provided GPU handle is invalid.
//!    LWAPI_HANDLE_ILWALIDATED - The provided GPU handle is no longer valid.
//!    LWAPI_NOT_SUPPORTED - The request is not supported.
//!    LWAPI_API_NOT_INTIALIZED - LwAPI was not yet initialized.
//! \endcode
//! \ingroup gpuecc
///////////////////////////////////////////////////////////////////////////////

LWAPI_INTERFACE LwAPI_GPU_InjectECCErrors(LwPhysicalGpuHandle hPhysicalGpu,
                                          LwU64 singleBitErrors, LwU64 doubleBitErrors);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_LWDA_PhysxSetState
//
//! \code
//! DESCRIPTION:    This function enables GPU-acceleration for PhysX on a 
//!                 given GPU, or switches PhysX over to the CPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:     hPhysicalGpu(IN)      - The physical GPU of a GPU which 
//!                                         will do the PhysX acceleration, 
//!                                         or if NULL, switch to using CPU.
//!
//! RETURN STATUS: 
//!    LWAPI_OK                           - completed request. The gpuCount indicates if one or more physics capable GPU got enabled for physics.
//!    LWAPI_ERROR                        - Unable to update the Physx driver state. Install the Physx driver component.
//!    LWAPI_ILWALID_ARGUMENT             - Invalid gpuCount or no physx GPU enabled in pPhysicsTopo passed into this API.
//!    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - hPhysicalGpu is not a physical GPU handle.
//!    LWAPI_NOT_SUPPORTED                - The GPU selected is not PhysX-capable, or a compatible version of PhysX is not installed.
//! \endcode
//! \ingroup gpulwda
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_LWDA_PhysxSetState(LwPhysicalGpuHandle hPhysicalGpu);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_GPU_GetMaxSourceCount
//
//! \code
//! DESCRIPTION:    This function retrieves the maximum number of sources that
//!                 the given hardware, GPU and driver is capable of driving, 
//!                 regardless of SLI or IDM states.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:     hPhysicalGpu(IN)      - Handle to a physical GPU
//!                 maxSourceCount(OUT)   - The number of sources drivable
//!
//! RETURN STATUS: 
//!    LWAPI_OK                           - completed request. 
//!    LWAPI_ERROR                        - miscellaneous error oclwrred
//!    LWAPI_ILWALID_ARGUMENT             - Invalid input parameter
//!    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - hPhysicalGpu is not a physical GPU handle.
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetMaxSourceCount(LwPhysicalGpuHandle hPhysicalGpu, LwU32* maxSourceCount);




//! \ingroup gpulwda
typedef struct
{
                LwU32 version;                        //!< version field

                LwU32 lwdaAccessible : 1;             //!< GPU is LWCA accessible, able to be communicated with for LWCA rendering
                LwU32 lwdaCapable : 1;                //!< GPU is LWCA capable, meets minimum requirements
                LwU32 lwdaDisabled : 1;               //!< LWCA is disabled by profile
                LwU32 lwdaBlockedHybrid : 1;          //!< LWCA is unavailable on this GPU while in the current hybrid mode
                LwU32 lwdaReserved : 4;               //!< Reserved for future LWCA flags

                LwU32 physxAvailable : 1;             //!< PhysX is able to use this GPU (PhysX is installed, etc)
                LwU32 physxCapable : 1;               //!< Board meets minimum hardware requirements for PhysX to function
                LwU32 physxEnabled : 1;               //!< PhysX is current selected for this GPU
                LwU32 physxReserved : 5;              //!< Reserved for future PhysX flags

                LwU32 idmEnabled : 1;                 //!< No longer applicable, will always return 0.
                LwU32 idmActive : 1;                  //!< No longer applicable, will always return 0.
                LwU32 reserved : 14;                  //!< Reserved, must be 0
} LW_GPU_COMPUTE_CAPS;

//! Macro for constructing the version field of LW_GPU_COMPUTE_CAPS 
#define LW_GPU_COMPUTE_CAPS_VER             MAKE_LWAPI_VERSION(LW_GPU_COMPUTE_CAPS, 1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_GPU_QueryComputeCaps
//
//! \code
//! DESCRIPTION:    This API enumerates one or more GPUs to report LWCA and PhysX caps for all physical GPUs  
//!                 This API will support new capability like lwca capability,lwca accessibility,lwca disability of physical gpu along with 
//!                 physx capability ,physx is enabled on a physical gpu which is already addressed by LwAPI_GPU_LwdaEnumComputeCapableGpus. 
//!                 It will *NOT* support a concept of PhsyX recommended  
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:     hPhysicalGpu(IN):handle to physical gpu
//!                 pComputeCaps(OUT):list of gpu LWCA/Physx caps
//!
//! RETURN STATUS: 
//!    LWAPI_OK                          - Success gpu LWCA/Physx caps are reported properly                                          
//!    LWAPI_INCOMPATIBLE_STRUCT_VERSION - structure version is not supported, initialize to LW_GPU_COMPUTE_CAPS_VER.
//!    LWAPI_ERROR                       - Enumeration of the GPU caps failed. 
//!
//! \endcode
//! \ingroup gpulwda
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_QueryComputeCaps(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_COMPUTE_CAPS* pComputeCaps);  



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GPU_QueryGpuFlags
//
//! \fn LwAPI_GPU_QueryGpuFlags(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_FLAGS *pGpuFlags)
//! \code
//! DESCRIPTION:   Returns the GPU flags for this GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! PARAMETERS:    hPhysicalGpu(IN)  : The handle of the GPU we query the flags for.
//!                pGpuFlags(OUT)    : This structure contains the GPU flags.
//! RETURN STATUS:
//!                 LWAPI_OK - completed request
//!                  LWAPI_API_NOT_INTIALIZED - LWAPI not initialized
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter.
//!                  LWAPI_ILWALID_HANDLE -Invalid hPhysicalGpu handle
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! ingroup gpu
typedef struct
{
    LwU32 version;                      //!< [00:31] Structure version

    LwU32 bIsInUse:1;                   //!< [32:32] There are client references to the GPU in the form of device class instantiations.
    LwU32 bIsLinkedToSliDevice:1;       //!< [33:33] The GPU is linked into an active SLI device.
    LwU32 bIsSysconConnected:1;         //!< [34:34] The GPU is associated with a system controller.
    LwU32 bIsMobile:1;                  //!< [35:35] The GPU is a mobile GPU.
    LwU32 bIsBootMaster:1;              //!< [36:36] The GPU is the boot master GPU.
    LwU32 bIsQuadro:1;                  //!< [37:37] The GPU is a Lwdqro
    LwU32 bIsHackedDevId:1;             //!< [38:38] Obsolete
    LwU32 bIsPanAndScanSupported:1;     //!< [39:39] Whether Pan And Scan is supported on this GPU.
    LwU32 bIsCloneToFitSupported:1;     //!< [40:40] Whether Clone To Fit is supported on this GPU.
    LwU32 bIsVRRSupported:1;            //!< [40:40] Whether variable refreshRate is supported on this GPU.
    LwU32 reserved:22;                  //!< [41:63] reserved
} LW_GPU_FLAGS_V1;

//! ingroup gpu
typedef LW_GPU_FLAGS_V1 LW_GPU_FLAGS;

//! ingroup gpu
#define LW_GPU_FLAGS_VER_1 MAKE_LWAPI_VERSION(LW_GPU_FLAGS_V1,1)

//! ingroup gpu
#define LW_GPU_FLAGS_VER   LW_GPU_FLAGS_VER_1

//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_QueryGpuFlags(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_FLAGS *pGpuFlags);





//! \ingroup gpu
//! @{

//! Enum for Event IDs
typedef enum
{
    LW_EVENT_TYPE_NONE = 0,
    LW_EVENT_TYPE_FAN_SPEED_CHANGE = 1,
    LW_EVENT_TYPE_THERMAL_CHANGE = 2,
} LW_EVENT_TYPE;

typedef enum
{
    UNKNOWN_LEVEL  = 0,
    NORMAL_LEVEL   = 1,
    WARNING_LEVEL  = 2, 
    CRITICAL_LEVEL = 3,
} LW_EVENT_LEVEL;

//! Callback for thermal
typedef void (__cdecl *LWAPI_CALLBACK_THERMALEVENT)(LwPhysicalGpuHandle gpuHandle, LW_EVENT_LEVEL thermalLevel, void *callbackParam);

//! Callback for fan speed
typedef void (__cdecl *LWAPI_CALLBACK_FANSPEEDEVENT)(LwPhysicalGpuHandle gpuHandle, LW_EVENT_LEVEL fanSpeedLevel, void *callbackParam);

//! Core LW_EVENT_REGISTER_CALLBACK structure declaration
typedef struct
{
    LwU32                 version;          //!< version field to ensure minimum version compatibility
    LW_EVENT_TYPE         eventId;          //!< ID of the event being sent
    void                  *callbackParam;   //!< This value will be passed back to the callback function when an event oclwrs
    union
    {
        LWAPI_CALLBACK_THERMALEVENT  lwThermalCallback;   //!< Callback function pointer for thermal                               
        LWAPI_CALLBACK_FANSPEEDEVENT lwFanSpeedCallback;  //!< Callback function pointer for fanSpeed
        
    }lwCallBackFunc;
    
} LW_EVENT_REGISTER_CALLBACK, *PLW_EVENT_REGISTER_CALLBACK;

//! Macro for constructing the version field of ::LW_EVENT_REGISTER_CALLBACK
#define LW_EVENT_REGISTER_CALLBACK_VERSION        MAKE_LWAPI_VERSION(LW_EVENT_REGISTER_CALLBACK,1);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Event_RegisterCallback
//
//! DESCRIPTION:   This API registers the process for events. This API should be called for each eventcallback.
//!                The handle returned to the client will be common across all eventCallbacks.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  eventCallback  Pointer to LW_EVENT_REGISTER_CALLBACK structure to call
//!                             on new events
//! \param [out] phClient       Handle to client for use with 
//!                             unregister function
//!
//! \retval ::LWAPI_OK - completed request
//! \retval ::LWAPI_API_NOT_INTIALIZED - LwAPI not initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT - Invalid argument
//! \retval ::LWAPI_ERROR - miscellaneous error oclwrred
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Event_RegisterCallback(PLW_EVENT_REGISTER_CALLBACK eventCallback,
                                             LwEventHandle* phClient);
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Event_UnregisterCallback
//
//! DESCRIPTION:   This API unregister an event handle. 
//!                This API should be called only once per process(irrespective of the number of callbacks registered).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]    hClient  Handle associated with this listeners
//!                         event queue. Same as returned from
//!                         LwAPI_Event_RegisterCallback().
//!
//! \retval ::LWAPI_OK - completed request
//! \retval ::LWAPI_API_NOT_INTIALIZED - LwAPI not initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT - Invalid argument
//! \retval ::LWAPI_ERROR - miscellaneous error oclwrred
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Event_UnregisterCallback(LwEventHandle hClient);



/////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetLwrrentThermalLevel
//
//
//! DESCRIPTION:   This API returns the current Level (Normal, Medium or 
//!                Critical) of the thermal sensor.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \param [in]    lwGPUHandle       Physical GPU handle.
//! \param [out]   pThermalLevel     Returns Thermal Level. 
//!
//! \retval ::LWAPI_OK                                 - Success
//! \retval ::LWAPI_API_NOT_INTIALIZED                 - LwAPI not initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT                   - Invalid argument
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE       - Invalid GPU handle
//! \retval ::LWAPI_NOT_SUPPORTED                      - API not supported
//! \retval ::LWAPI_ERROR                              - miscellaneous error oclwrred
//!
//! \ingroup gputhermal
/////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetLwrrentThermalLevel(LwPhysicalGpuHandle lwGPUHandle, LW_EVENT_LEVEL *pThermalLevel);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_GPU_GetLwrrentFanSpeedLevel
//
//! DESCRIPTION:   This API returns the current fan speed Level (Normal, Medium or 
//!                Critical).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \param [in]   lwGPUHandle     Physical GPU handle.
//! \param [out]  pFanSpeedLevel  Returns fan speed Level. 
//!
//! \retval ::LWAPI_OK                                 Success
//! \retval ::LWAPI_API_NOT_INTIALIZED                 LwAPI not initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT                   Invalid argument
//! \retval ::LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE       Invalid GPU handle
//! \retval ::LWAPI_NOT_SUPPORTED                      API not supported
//! \retval ::LWAPI_ERROR                              Miscellaneous error oclwrred
//!
//! \ingroup gpucooler
/////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetLwrrentFanSpeedLevel(LwPhysicalGpuHandle lwGPUHandle, LW_EVENT_LEVEL *pFanSpeedLevel);




typedef struct 
{
    LwU32 version;                    // Version of the structure.
    
    LwU32              boardID;       // Board Id.
    LwAPI_ShortString  chipSKU;       // SKU of the chip.
    LwAPI_ShortString  chipSKUMod;    // SKU Modifier.
    LwAPI_ShortString  project;       // Project(Board) number.
    LwAPI_ShortString  projectSKU;    // Project(Board) SKU number.
    LwAPI_ShortString  cdp;           // Collaborative Design Project Number. 
} LW_GPU_SKU_INFO_V1;

typedef LW_GPU_SKU_INFO_V1     LW_GPU_SKU_INFO;

#define LW_GPU_SKU_INFO_VER1   MAKE_LWAPI_VERSION(LW_GPU_SKU_INFO_V1, 1)
#define LW_GPU_SKU_INFO_VER    LW_GPU_SKU_INFO_VER1

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GPU_GetSKUInfo
//
//! DESCRIPTION:     This API returns the SKU information for the specified GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \param [in]      hPhysicalGpu(IN)  : The handle of the GPU for the which caller wants the SKU info.
//! \param [out]     pGpuSKUInfo(OUT)  : This structure contains the GPU SKU information.
//! 
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_ILWALID_USER_PRIVILEGE       - The caller does not have administrative privileges
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetSKUInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_GPU_SKU_INFO *pGpuSKUInfo);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GPU_GetBrandType
//
//! \fn LwAPI_GPU_GetBrandType(LwPhysicalGpuHandle physicalGpu, LW_GPU_BRAND_TYPE *gpuBrandType)
//! \code
//! DESCRIPTION:     Returns the Brand type for the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! DESCRIPTION:     This API, when called with a valid physical gpu handle as Input, lets caller know the Brand type of that Gpu.
//!
//! PARAMETERS:      physicalGpu(IN)   : The handle of the GPU for the which caller wants to get the Brand Type.
//!                  gpuBrandType(OUT) : The brand type for the GPU ; one of the values from enum LW_GPU_BRAND_TYPE.
//!
//! RETURN STATUS:
//!                  LWAPI_OK                           : Completed the request. *gpuBrandType contains the GPU Brand Type.
//!                  LWAPI_ERROR                        : Miscellaneous error oclwrred.
//!                  LWAPI_API_NOT_INITIALIZED          : LWAPI not initialized.
//!                  LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE : Invalid Gpu handle.
//!                  LWAPI_ILWALID_POINTER              : Invalid gpuBrandType pointer
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
typedef enum
{
    LW_GPU_BRAND_TYPE_UNKNOWN    = 0,
    LW_GPU_BRAND_TYPE_GEFORCE    = 1,
    LW_GPU_BRAND_TYPE_QUADRO     = 2,
    LW_GPU_BRAND_TYPE_QUADRO_AD  = 3,
    LW_GPU_BRAND_TYPE_QUADRO_LWS = 4,
    LW_GPU_BRAND_TYPE_LWIDIA_LWS = 5,
    LW_GPU_BRAND_TYPE_TESLA      = 6,
    LW_GPU_BRAND_TYPE_TESLA_Q    = 7,
}LW_GPU_BRAND_TYPE;


//! \ingroup gpu
LWAPI_INTERFACE LwAPI_GPU_GetBrandType(LwPhysicalGpuHandle physicalGpu, LW_GPU_BRAND_TYPE *gpuBrandType);



//! \ingroup gpu
typedef struct
{
    LwU32  version;              //!< version of this structure
    LwU32  width;                //!< width of the input texture
    LwU32  height;               //!< height of the input texture
    float* blendingTexture;      //!< array of floating values building an intensity RGB texture
} LW_SCANOUT_INTENSITY_DATA_V1;

//! \ingroup gpu
typedef struct
{
    LwU32  version;              //!< version of this structure
    LwU32  width;                //!< width of the input texture
    LwU32  height;               //!< height of the input texture
    float* blendingTexture;      //!< array of floating values building an intensity RGB texture
    float* offsetTexture;        //!< array of floating values building an offset texture
    LwU32  offsetTexChannels;    //!< number of channels per pixel in the offset texture
} LW_SCANOUT_INTENSITY_DATA_V2;

typedef LW_SCANOUT_INTENSITY_DATA_V2 LW_SCANOUT_INTENSITY_DATA;

//! \ingroup gpu
#define LW_SCANOUT_INTENSITY_DATA_VER1    MAKE_LWAPI_VERSION(LW_SCANOUT_INTENSITY_DATA_V1, 1)
#define LW_SCANOUT_INTENSITY_DATA_VER2    MAKE_LWAPI_VERSION(LW_SCANOUT_INTENSITY_DATA_V2, 2)
#define LW_SCANOUT_INTENSITY_DATA_VER      LW_SCANOUT_INTENSITY_DATA_VER2

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_GPU_SetScanoutIntensity
//
//!   DESCRIPTION: This API enables and sets up per-pixel intensity feature on the specified display.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]   displayId              combined physical display and GPU identifier of the display to apply the intensity control.
//! \param [in]   scanoutIntensityData   the intensity texture info.
//! \param [out]  pbSticky(OUT)           indicates whether the settings will be kept over a reboot.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT Invalid input parameters.
//! \retval ::LWAPI_API_NOT_INITIALIZED LwAPI not initialized.
//! \retval ::LWAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs
//! \retval ::LWAPI_ILWALID_ARGUMENT Invalid input data.
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION LW_SCANOUT_INTENSITY_DATA structure version mismatch.
//! \retval ::LWAPI_OK Feature enabled.
//! \retval ::LWAPI_ERROR Miscellaneous error oclwrred.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetScanoutIntensity(LwU32 displayId, LW_SCANOUT_INTENSITY_DATA* scanoutIntensityData, int *pbSticky);


//! \ingroup gpu
typedef struct _LW_SCANOUT_INTENSITY_STATE_DATA
{
    LwU32  version;                                 //!< version of this structure
    LwU32  bEnabled;                                //!< intensity is enabled or not
} LW_SCANOUT_INTENSITY_STATE_DATA;

//! \ingroup gpu
#define LW_SCANOUT_INTENSITY_STATE_VER    MAKE_LWAPI_VERSION(LW_SCANOUT_INTENSITY_STATE_DATA, 1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_GPU_GetScanoutIntensityState
//
//!   DESCRIPTION: This API queries current state of the intensity feature on the specified display.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     displayId                       combined physical display and GPU identifier of the display to query the configuration.
//! \param [in,out] scanoutIntensityStateData       intensity state data.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT Invalid input parameters.
//! \retval ::LWAPI_API_NOT_INITIALIZED LwAPI not initialized.
//! \retval ::LWAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs.
//! \retval ::LWAPI_OK Feature enabled.
//! \retval ::LWAPI_ERROR Miscellaneous error oclwrred.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetScanoutIntensityState(__in LwU32 displayId, __inout LW_SCANOUT_INTENSITY_STATE_DATA* scanoutIntensityStateData);


//! \ingroup gpu
typedef enum
{
    LW_GPU_WARPING_VERTICE_FORMAT_TRIANGLESTRIP_XYUVRQ = 0,
    LW_GPU_WARPING_VERTICE_FORMAT_TRIANGLES_XYUVRQ     = 1,
} LW_GPU_WARPING_VERTICE_FORMAT;

//! \ingroup gpu
typedef struct
{
    LwU32  version;                                 //!< version of this structure
    float* vertices;                                //!< width of the input texture
    LW_GPU_WARPING_VERTICE_FORMAT vertexFormat;     //!< format of the input vertices
    int    numVertices;                             //!< number of the input vertices
    LwSBox* textureRect;                            //!< rectangle in desktop coordinates describing the source area for the warping
} LW_SCANOUT_WARPING_DATA;

//! \ingroup gpu
#define LW_SCANOUT_WARPING_VER    MAKE_LWAPI_VERSION(LW_SCANOUT_WARPING_DATA, 1)


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_GPU_SetScanoutWarping
//
//!   DESCRIPTION: This API enables and sets up the warping feature on the specified display.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]    displayId               Combined physical display and GPU identifier of the display to apply the intensity control
//! \param [in]    scanoutWarpingData      The warping data info
//! \param [out]   pbSticky                Indicates whether the settings will be kept over a reboot.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT Invalid input parameters.
//! \retval ::LWAPI_API_NOT_INITIALIZED LwAPI not initialized.
//! \retval ::LWAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs
//! \retval ::LWAPI_ILWALID_ARGUMENT Invalid input data.
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION LW_SCANOUT_INTENSITY_DATA structure version mismatch.
//! \retval ::LWAPI_OK Feature enabled.
//! \retval ::LWAPI_ERROR Miscellaneous error oclwrred.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////

LWAPI_INTERFACE LwAPI_GPU_SetScanoutWarping(LwU32 displayId, LW_SCANOUT_WARPING_DATA* scanoutWarpingData, int* piMaxNumVertices, int* pbSticky);


//! \ingroup gpu
typedef struct _LW_SCANOUT_WARPING_STATE_DATA
{
    LwU32  version;                                  //!< version of this structure
    LwU32  bEnabled;                                 //!< warping is enabled or not
} LW_SCANOUT_WARPING_STATE_DATA;

//! \ingroup gpu
#define LW_SCANOUT_WARPING_STATE_VER    MAKE_LWAPI_VERSION(LW_SCANOUT_WARPING_STATE_DATA, 1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_GPU_GetScanoutWarpingState
//
//!   DESCRIPTION: This API queries current state of the warping feature on the specified display.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     displayId                      combined physical display and GPU identifier of the display to query the configuration.
//! \param [in,out] scanoutWarpingStateData        warping state data.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT Invalid input parameters.
//! \retval ::LWAPI_API_NOT_INITIALIZED LwAPI not initialized.
//! \retval ::LWAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs.
//! \retval ::LWAPI_OK Feature enabled.
//! \retval ::LWAPI_ERROR Miscellaneous error oclwrred.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetScanoutWarpingState(__in LwU32 displayId, __inout LW_SCANOUT_WARPING_STATE_DATA* scanoutWarpingStateData);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_GPU_GetScanoutConfiguration
//
//!   DESCRIPTION: This API queries the desktop and scanout portion of the specified display.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     displayId          combined physical display and GPU identifier of the display to query the configuration.
//! \param [in,out] desktopRect        desktop area of the display in desktop coordinates.
//! \param [in,out] scanoutRect        scanout area of the display relative to desktopRect.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT Invalid input parameters.
//! \retval ::LWAPI_API_NOT_INITIALIZED LwAPI not initialized.
//! \retval ::LWAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs.
//! \retval ::LWAPI_OK Feature enabled.
//! \retval ::LWAPI_ERROR Miscellaneous error oclwrred.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetScanoutConfiguration(LwU32 displayId, LwSBox* desktopRect, LwSBox* scanoutRect);



//! \ingroup gpu
//! Used in LwAPI_GPU_GetScanoutConfigurationEx().
typedef struct _LW_SCANOUT_INFORMATION
{
    LwU32      version;                 //!< Structure version, needs to be initialized with LW_SCANOUT_INFORMATION_VER.

    LwSBox     sourceDesktopRect;       //!< Operating system display device rect in desktop coordinates displayId is scanning out from.
    LwSBox     sourceViewportRect;      //!< Area inside the sourceDesktopRect which is scanned out to the display.
    LwSBox     targetViewportRect;      //!< Area inside the rect described by targetDisplayWidth/Height sourceViewportRect is scanned out to.
    LwU32      targetDisplayWidth;      //!< Horizontal size of the active resolution scanned out to the display.
    LwU32      targetDisplayHeight;     //!< Vertical size of the active resolution scanned out to the display.
    LwU32      cloneImportance;         //!< If targets are cloned views of the sourceDesktopRect the cloned targets have an imporantce assigned (0:primary,1 secondary,...).
    LW_ROTATE  sourceToTargetRotation;  //!< Rotation performed between the sourceViewportRect and the targetViewportRect.
} LW_SCANOUT_INFORMATION;

#define LW_SCANOUT_INFORMATION_VER  MAKE_LWAPI_VERSION(LW_SCANOUT_INFORMATION,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_GPU_GetScanoutConfigurationEx
//
//!   DESCRIPTION: This API queries the desktop and scanout portion of the specified display.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//! \since Release: 331
//!
//! \param [in]     displayId            combined physical display and GPU identifier of the display to query the configuration.
//! \param [in,out] pScanoutInformation  desktop area to displayId mapping information.
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetScanoutConfigurationEx(__in LwU32 displayId, __inout LW_SCANOUT_INFORMATION *pScanoutInformation);


//! SUPPORTED OS:  Windows 7 and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetAdapterIdFromPhysicalGpu
//
//!   DESCRIPTION: This API returns the OS-AdapterID from physicalGpu Handle. OS-AdapterID
//!                is the Adapter ID that is used by Win7 CCD APIs.
//!
//! \param [in]    hPhysicalGpu   PhysicalGpu Handle
//! \param [out]   pOSAdapterId   Returns OS-AdapterId, it is typed as void * to
//!                               avoid dependency with windows.h. User must type cast it to LUID.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT pOSAdapterId is NULL; hPhysicalGpu is invalid
//! \retval ::LWAPI_OK *pOSAdapterId contains valid data.
//! \retval ::LWAPI_NOT_SUPPORTED  This API is not supported on the system.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetAdapterIdFromPhysicalGpu(LwPhysicalGpuHandle hPhysicalGpu, void *pOSAdapterId);


//! Used in LwAPI_GPU_GetPerfDecreaseInfo.
//! Bit masks for knowing the exact reason for performance decrease
typedef enum _LWAPI_GPU_PERF_DECREASE
{
    LW_GPU_PERF_DECREASE_NONE                        = 0,          //!< No Slowdown detected
    LW_GPU_PERF_DECREASE_REASON_THERMAL_PROTECTION   = 0x00000001, //!< Thermal slowdown/shutdown/POR thermal protection
    LW_GPU_PERF_DECREASE_REASON_POWER_CONTROL        = 0x00000002, //!< Power capping / pstate cap 
    LW_GPU_PERF_DECREASE_REASON_AC_BATT              = 0x00000004, //!< AC->BATT event
    LW_GPU_PERF_DECREASE_REASON_API_TRIGGERED        = 0x00000008, //!< API triggered slowdown
    LW_GPU_PERF_DECREASE_REASON_INSUFFICIENT_POWER   = 0x00000010, //!< Power connector missing
    LW_GPU_PERF_DECREASE_REASON_UNKNOWN              = 0x80000000, //!< Unknown reason
} LWAPI_GPU_PERF_DECREASE;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetPerfDecreaseInfo
//
//! DESCRIPTION:   This function retrieves - in LwU32 variable - reasons for the current performance decrease.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! \param [in]      hPhysicalGPU    (IN)    - GPU for which performance decrease is to be evaluated.
//! \param [out]  pPerfDecrInfo    (OUT)    - Pointer to a LwU32 variable containing performance decrease info
//!
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPerfDecreaseInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LwU32 *pPerfDecrInfo);


//! \ingroup gpu 
typedef struct
{
    LwU32                version;                                //!< The structure version.
    LwU32               thermalMask;                             //!< [out] contains bitmasked value from one or more LWAPI_GPU_PERF_DECREASE enums
    LwU32               pstateMask;                                //!< [out] contains bitmasked value from one or more LWAPI_GPU_PERF_DECREASE enums
} LW_PERF_DECREASE_INFO_V1;

//! \ingroup gpu 
typedef LW_PERF_DECREASE_INFO_V1    LW_PERF_DECREASE_INFO;

//! \ingroup gpu
#define LW_PERF_DECREASE_INFO_VER1  MAKE_LWAPI_VERSION(LW_PERF_DECREASE_INFO_V1,1)

//! \ingroup gpu
#define LW_PERF_DECREASE_INFO_VER   LW_PERF_DECREASE_INFO_VER1


//! Used in LwAPI_GPU_GetPerfDecreaseInfo_Internal.
//! Bit masks for knowing the exact reason for Performance decrease
typedef enum _LWAPI_PVT_GPU_PERF_DECREASE
{
    LW_PVT_GPU_PERF_DECREASE_NONE                        = 0,          //!< No Slowdown detected
    LW_PVT_GPU_PERF_DECREASE_REASON_THERMAL_SHUTDOWN     = 0x00000001, //!< System slowdown/shutdown
    LW_PVT_GPU_PERF_DECREASE_REASON_THERMAL_PROTECTION   = 0x00000002, //!< POR thermal protection
    LW_PVT_GPU_PERF_DECREASE_REASON_AVERAGE_POWER        = 0x00000004, //!< Power capping - Slow/Pstate cap
    LW_PVT_GPU_PERF_DECREASE_REASON_PEAK_POWER           = 0x00000008, //!< Power capping - Moderately Fast.
    LW_PVT_GPU_PERF_DECREASE_REASON_INSUFFICIENT_POWER   = 0x00000010, //!< Power connector missing
    LW_PVT_GPU_PERF_DECREASE_REASON_AC_BATT              = 0x00000020, //!< AC->BATT event
    LW_PVT_GPU_PERF_DECREASE_REASON_API_TRIGGERED        = 0x00000040, //!< API triggered slowdown
    LW_PVT_GPU_PERF_DECREASE_REASON_UNKNOWN              = 0x80000000, //!< Unknown reason
} LWAPI_PVT_GPU_PERF_DECREASE;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetPerfDecreaseInfo_Internal
//
//! DESCRIPTION:   This function retrieves - in the form of two masks - reasons for the current perf decrease.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! \param [in]      hPhysicalGPU    (IN)    - GPU for which performance decrease is to be evaluated.
//! \param [out]  pPerfInfo        (OUT)    - Pointer to a structure containing performance decrease info
//!
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPerfDecreaseInfo_Internal(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_PERF_DECREASE_INFO *pPerfInfo);


//! \ingroup gpu
typedef enum _LW_GPU_ILLUMINATION_ATTRIB
{
    LW_GPU_IA_LOGO_BRIGHTNESS  = 0,
    LW_GPU_IA_SLI_BRIGHTNESS   = 1,
} LW_GPU_ILLUMINATION_ATTRIB;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_QueryIlluminationSupport
//
//! \fn LwAPI_GPU_QueryIlluminationSupport(__inout  LW_GPU_QUERY_ILLUMINATION_SUPPORT_PARM *pIlluminationSupportInfo)
//! DESCRIPTION:   This function reports if the specified illumination attribute is supported.
//!
//! \note Only a single GPU can manage an given attribute on a given HW element,
//!       regardless of how many are attatched. I.E. only one GPU will be used to control
//!       the brightness of the LED on an SLI bridge, regardless of how many are physicaly attached.
//!       You should enumerate thru the GPUs with this call to determine which GPU is managing the attribute.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \since Version: 300.05
//!
//! \param [in]  hPhysicalGpu        Physical GPU handle
//! \param       Attribute           An enumeration value specifying the Illumination attribute to be querried
//! \param [out] pSupported          A boolean indicating if the attribute is supported.
//! 
//! \return See \ref lwapistatus for the list of possible return values.
//
//////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu                 
typedef struct _LW_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1 {

    // IN
    LwU32   version;                        //!< Version of this structure
    LwPhysicalGpuHandle hPhysicalGpu;       //!< The handle of the GPU that you are checking for the specified attribute.
                                            //!< note that this is the GPU that is managing the attribute.
                                            //!< Only a single GPU can manage an given attribute on a given HW element,
                                            //!< regardless of how many are attatched.
                                            //!< I.E. only one GPU will be used to control the brightness of the LED on an SLI bridge,
                                            //!< regardless of how many are physicaly attached.
                                            //!< You enumerate thru the GPUs with this call to determine which GPU is managing the attribute.
    LW_GPU_ILLUMINATION_ATTRIB Attribute;   //!< An enumeration value specifying the Illumination attribute to be querried.
                                            //!<     refer to enum \ref LW_GPU_ILLUMINATION_ATTRIB.
    
    // OUT
    LwU32    bSupported;                    //!< A boolean indicating if the attribute is supported.
                                    
} LW_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1;

//! \ingroup gpu 
typedef LW_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1      LW_GPU_QUERY_ILLUMINATION_SUPPORT_PARM;
//! \ingroup gpu 
#define LW_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_VER_1   MAKE_LWAPI_VERSION(LW_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1,1)
//! \ingroup gpu 
#define LW_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_VER     LW_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_VER_1

//! \ingroup gpu 
LWAPI_INTERFACE LwAPI_GPU_QueryIlluminationSupport(__inout LW_GPU_QUERY_ILLUMINATION_SUPPORT_PARM *pIlluminationSupportInfo);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetIllumination
//
//! \fn LwAPI_GPU_GetIllumination(LW_GPU_GET_ILLUMINATION_PARM *pIlluminationInfo)
//! DESCRIPTION:   This function reports value of the specified illumination attribute.
//!
//! \note Only a single GPU can manage an given attribute on a given HW element,
//!       regardless of how many are attatched. I.E. only one GPU will be used to control
//!       the brightness of the LED on an SLI bridge, regardless of how many are physicaly attached.
//!       You should enumerate thru the GPUs with the \ref LwAPI_GPU_QueryIlluminationSupport call to
//!       determine which GPU is managing the attribute.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \since Version: 300.05
//!
//! \param [in]  hPhysicalGpu        Physical GPU handle
//! \param       Attribute           An enumeration value specifying the Illumination attribute to be querried
//! \param [out] Value               A DWORD containing the current value for the specified attribute.
//!                                  This is specified as a percentage of the full range of the attribute
//!                                  (0-100; 0 = off, 100 = full brightness)
//! 
//! \return See \ref lwapistatus for the list of possible return values. Return values of special interest are:
//!             LWAPI_ILWALID_ARGUMENT The specified attibute is not known to the driver.
//!             LWAPI_NOT_SUPPORTED:   The specified attribute is not supported on the specified GPU
//
//////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu                 
typedef struct _LW_GPU_GET_ILLUMINATION_PARM_V1 {

    // IN
    LwU32   version;                        //!< Version of this structure
    LwPhysicalGpuHandle hPhysicalGpu;       //!< The handle of the GPU that you are checking for the specified attribute.
                                            //!< Note that this is the GPU that is managing the attribute.
                                            //!< Only a single GPU can manage an given attribute on a given HW element,
                                            //!< regardless of how many are attatched.
                                            //!< I.E. only one GPU will be used to control the brightness of the LED on an SLI bridge,
                                            //!< regardless of how many are physicaly attached.
                                            //!< You enumerate thru the GPUs with this call to determine which GPU is managing the attribute.
    LW_GPU_ILLUMINATION_ATTRIB Attribute;   //!< An enumeration value specifying the Illumination attribute to be querried.
                                            //!< refer to enum \ref LW_GPU_ILLUMINATION_ATTRIB.
    
    // OUT
    LwU32    Value;                         //!< A DWORD that will contain the current value of the specified attribute.
                                            //! This is specified as a percentage of the full range of the attribute
                                            //! (0-100; 0 = off, 100 = full brightness)
                                    
} LW_GPU_GET_ILLUMINATION_PARM_V1;

//! \ingroup gpu 
typedef LW_GPU_GET_ILLUMINATION_PARM_V1      LW_GPU_GET_ILLUMINATION_PARM;
//! \ingroup gpu 
#define LW_GPU_GET_ILLUMINATION_PARM_VER_1   MAKE_LWAPI_VERSION(LW_GPU_GET_ILLUMINATION_PARM_V1,1)
//! \ingroup gpu 
#define LW_GPU_GET_ILLUMINATION_PARM_VER     LW_GPU_GET_ILLUMINATION_PARM_VER_1

//! \ingroup gpu 
LWAPI_INTERFACE LwAPI_GPU_GetIllumination(LW_GPU_GET_ILLUMINATION_PARM *pIlluminationInfo);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_SetIllumination
//
//! \fn LwAPI_GPU_SetIllumination(LW_GPU_SET_ILLUMINATION_PARM *pIlluminationInfo)
//! DESCRIPTION:   This function sets the value of the specified illumination attribute.
//!
//! \note Only a single GPU can manage an given attribute on a given HW element,
//!       regardless of how many are attatched. I.E. only one GPU will be used to control
//!       the brightness of the LED on an SLI bridge, regardless of how many are physicaly attached.
//!       You should enumerate thru the GPUs with the \ref LwAPI_GPU_QueryIlluminationSupport call to
//!       determine which GPU is managing the attribute.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \since Version: 300.05
//!
//! \param [in]  hPhysicalGpu        Physical GPU handle
//! \param       Attribute           An enumeration value specifying the Illumination attribute to be set
//! \param       Value               The new value for the specified attribute.
//!                                  This should be specified as a percentage of the full range of the attribute
//!                                  (0-100; 0 = off, 100 = full brightness)
//!                                  If a value is specified outside this range, LWAPI_ILWALID_ARGUMENT will be returned.
//! 
//! \return See \ref lwapistatus for the list of possible return values. Return values of special interest are:
//!             LWAPI_ILWALID_ARGUMENT  The specified attibute is not known to the driver, or the specified value is out of range.
//!             LWAPI_NOT_SUPPORTED     The specified attribute is not supported on the specified GPU.
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu                
typedef struct _LW_GPU_SET_ILLUMINATION_PARM_V1 {

    // IN
    LwU32   version;                        //!< Version of this structure
    LwPhysicalGpuHandle hPhysicalGpu;       //!< The handle of the GPU that you are checking for the specified attribute.
                                            //!< Note that this is the GPU that is managing the attribute.
                                            //!< Only a single GPU can manage an given attribute on a given HW element,
                                            //!< regardless of how many are attatched.
                                            //!< I.E. only one GPU will be used to control the brightness of the LED on an SLI bridge,
                                            //!< regardless of how many are physicaly attached.
                                            //!< You enumerate thru the GPUs with this call to determine which GPU is managing the attribute.
    LW_GPU_ILLUMINATION_ATTRIB Attribute;   //!< An enumeration value specifying the Illumination attribute to be querried.
                                            //!< refer to enum \ref LW_GPU_ILLUMINATION_ATTRIB.
    LwU32    Value;                         //!< A DWORD containing the new value for the specified attribute.
                                            //!< This should be specified as a percentage of the full range of the attribute
                                            //!< (0-100; 0 = off, 100 = full brightness)
                                            //!< If a value is specified outside this range, LWAPI_ILWALID_ARGUMENT will be returned.
    
    // OUT
                                    
} LW_GPU_SET_ILLUMINATION_PARM_V1;

//! \ingroup gpu 
typedef LW_GPU_SET_ILLUMINATION_PARM_V1      LW_GPU_SET_ILLUMINATION_PARM;
//! \ingroup gpu 
#define LW_GPU_SET_ILLUMINATION_PARM_VER_1   MAKE_LWAPI_VERSION(LW_GPU_SET_ILLUMINATION_PARM_V1,1)
//! \ingroup gpu 
#define LW_GPU_SET_ILLUMINATION_PARM_VER     LW_GPU_SET_ILLUMINATION_PARM_VER_1

//! \ingroup gpu 
LWAPI_INTERFACE LwAPI_GPU_SetIllumination(LW_GPU_SET_ILLUMINATION_PARM *pIlluminationInfo);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_VCD_GetThermalInfo
//
//!   DESCRIPTION: This API returns thermal information from the Visual Computing Device.
//!                One or more LWAPI_THERMAL_TARGET_VCD target thermal information can be retrieved (See::LW_THERMAL_TARGET).
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \param [in]   lwComputingHandle  The enumerated Visual Computing Device handle retrieved from LwAPI_EnumVisualComputingDevices().
//! \param [out]  pThermalSettings   Contains the Visual Computing Device thermal information returned in pThermalSettings.
//!                                  pThermalSettings->version has to be set to LW_GPU_THERMAL_SETTINGS_VER for the API to succeed.
//!                                  One or more LWAPI_THERMAL_TARGET_VCD target thermal information can be retrieved.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT          lwComputingHandle or pThermalSettings is NULL
//! \retval ::LWAPI_OK                        Information successfully in pThermalSettings.
//! \retval ::LWAPI_ERROR
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any Visual Computing Device.
//!
//! \ingroup viscompapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VCD_GetThermalInfo(LwVisualComputingDeviceHandle lwComputingHandle, LW_GPU_THERMAL_SETTINGS *pThermalSettings);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_VCD_GetCoolerSettings
//
//!   DESCRIPTION: This API returns cooler information from the Visual Computing Device.
//!                One or more LWAPI_COOLER_TARGET_VCD target cooler settings can be retrieved (See ::LWAPI_COOLER_TARGET).
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \param [in]    lwComputingHandle  The enumerated Visual Computing Device handle retrieved from LwAPI_EnumVisualComputingDevices().
//! \param [out]   pCoolerInfo        The Visual Computing Device cooler information returned in pCoolerInfo.
//!                                   pCoolerInfo->version has to be set to LW_GPU_GETCOOLER_SETTINGS_VER for the API to succeed.
//! \param [out]   requestedFanLevel  Percent of cooling capacity requested by the internal fan controller.
//!                                   This is typically a function of exhaust temperature and/or chip temperature.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT         lwComputingHandle or pCoolerInfo is NULL
//! \retval ::LWAPI_OK                       Information successfully in pCoolerInfo.
//! \retval ::LWAPI_ERROR
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any Visual Computing Device.
//!
//! \ingroup viscompapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VCD_GetCoolerSettings(LwVisualComputingDeviceHandle lwComputingHandle, LW_GPU_GETCOOLER_SETTINGS *pCoolerInfo, LwU32 * pRequestedFanLevel);


//! \ingroup sysgeneral
//! Used in LwAPI_SYS_ACPI_GetValues(). 
typedef struct
{
    LwU32 version;                      //!< input: Structure version, must always be LW_ACPI_METHOD_DATA_SET_VER
    LwU16 bufferSize;                   //!< input/output: Size of valid data in the buffer
    LwU8 buffer[LW_MXM_BLOCK_SIZE];     //!< input/output: Data buffer
} LW_ACPI_METHOD_DATA_SET_V1;


//! \ingroup sysgeneral
//! Used in LW_ACPI_METHOD_DATA_SET.
//! @{ 
typedef LW_ACPI_METHOD_DATA_SET_V1      LW_ACPI_METHOD_DATA_SET;
#define LW_ACPI_METHOD_DATA_SET_VER1    MAKE_LWAPI_VERSION(LW_ACPI_METHOD_DATA_SET, 1)
#define LW_ACPI_METHOD_DATA_SET_VER     LW_ACPI_METHOD_DATA_SET_VER1
//! @}


//! \ingroup sysgeneral
//! Used in LwAPI_SYS_ACPI_GetValues(). 
typedef enum _LW_ACPI_METHOD_ID
{
    LWAPI_ACPI_METHOD_MXM2X_MXMI = 0,       //!< MXM 2.x: Return Spec Support Level
    LWAPI_ACPI_METHOD_MXM2X_MXMS,           //!< MXM 2.x: Return the MXM Structure (SIS)
    LWAPI_ACPI_METHOD_DSM_MXM3X_MXSS,       //!< MXM 3.x: Supported Sub-Functions
    LWAPI_ACPI_METHOD_DSM_MXM3X_MXMI,       //!< MXM 3.x: Platform MXM Capabilities
    LWAPI_ACPI_METHOD_DSM_MXM3X_MXMS,       //!< MXM 3.x: Get the MXM Structure (SIS)
    LWAPI_ACPI_METHOD_DSM_MXM3X_MXPP,       //!< MXM 3.x: Get/Set Platform Policies
    LWAPI_ACPI_METHOD_DSM_MXM3X_MXDP,       //!< MXM 3.x: Get/Set Display Config
    LWAPI_ACPI_METHOD_DSM_MXM3X_MDTL,       //!< MXM 3.x: Get Display Toggle List
    LWAPI_ACPI_METHOD_DSM_MXM3X_MXCB,       //!< MXM 3.x: Query/Call System Callbacks
    LWAPI_ACPI_METHOD_DOD,                  //!< Get DOD ID List
    LWAPI_ACPI_METHOD_MXMX,                 //!< Select Display Data Channel
    LWAPI_ACPI_METHOD_MXDS,                 //!< Select Display Output Channel
    LWAPI_ACPI_METHOD_DSM_MXM3X_EVENTLIST,  //!< MXM 3.x: Get flexible notifiers list
    LWAPI_ACPI_METHOD_DSM_GPS,              //!< GPS Supported Sub-Functions
    LWAPI_ACPI_METHOD_DSM_JT,               //!< JT Supported Sub-Functions

    // MUST BE THE LAST ONE!!!  Don't add any new ID after this!!!
    LWAPI_ACPI_NUM_SUPPORTED_METHODS        //!< # of ACPI methods exported to LWAPI
} LW_ACPI_METHOD_ID;



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_SYS_ACPI_GetValues
//
//!   DESCRIPTION: This API exelwtes Advanced Configuration and Power Interface (ACPI) methods and gets returned data.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \param [in]    hPhysicalGpu    GPU selection.
//! \param [in]    acpiMethod      ACPI method ID.
//! \param [out]   pBuf            Contains one or more data returned by the ACPI
//!
//! \retval  :: RETURN STATUS: LWAPI_OK: exelwtion succeeded
//! \retval  ::    LWAPI_NOT_SUPPORTED: queried ACPI method is NOT supported
//! \retval  ::                 LWAPI_ILWALID_ARGUMENT: method ID not recognized
//! \retval  ::                 LWAPI_ERROR: failed to retrieve supported info
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_ACPI_GetValues(__in LwPhysicalGpuHandle hPhysicalGpu, __in LW_ACPI_METHOD_ID acpiMethod, __inout LW_ACPI_METHOD_DATA_SET *pBuf);



///////////////////////////////////////////////////////////////////////////////
// POWERMIZER APIs
//
// Provides the ability to Limit PowerMizer's Maximum Performance.
// Grants access on Adaptive Clocking turn on and off.
// PowerMizer can be either Soft Limited or Hard Limited.
// Soft Limit can be exceeded by the adaptive systems in the GPU if there is a need.
// Hard Limit cannot be exceeded even if there is a need to exceed this limit.
//
//////////////////////////////////////////////////////////////////////////////

//! \ingroup powermizerapi
//! Used in LwAPI_GPU_GetPowerMizerInfo() and LwAPI_GPU_GetPowerMizerInfo()
typedef enum _LW_LEVEL_INFO
{
    LWAPI_PWR_MZR_HARD_LIMIT_MAX           = 0x00000001,       //!< Power Mizer Maximum Performance for Hard limit
    LWAPI_PWR_MZR_HARD_LIMIT_BAL           = 0x00000002,       //!< Power Mizer Balanced Performance for Hard limit
    LWAPI_PWR_MZR_MAX_BATT                 = 0x00000003,       //!< Power Mizer Maximum Battery Performance
    LWAPI_PWR_MZR_SOFT_LIMIT_MAX           = 0x00000004,       //!< Power mizer Maximum performance for Soft limit
    LWAPI_PWR_MZR_SOFT_LIMIT_BAL           = 0x00000005,       //!< Power mizer Balanced performance for Soft limit
    LWAPI_ADC_OFF                          = 0x00000006,       //!< Adaptive Clocking Disable
    LWAPI_ADC_ON                           = 0x00000007,       //!< Adaptive Clocking Enable
} LW_LEVEL_INFO;


//! \ingroup powermizerapi
//! Used in LwAPI_GPU_GetPowerMizerInfo() and LwAPI_GPU_GetPowerMizerInfo()
typedef enum _LW_PWR_SOURCE_INFO
{
    LWAPI_PWR_SOURCE_AC                                 = 0x00000001,       //!<  Power source AC
    LWAPI_PWR_SOURCE_BATT                               = 0x00000002,       //!<  Power source Battery
} LW_PWR_SOURCE_INFO;

//! \ingroup powermizerapi
//! Used in LwAPI_GPU_GetPowerMizerInfo() and LwAPI_GPU_GetPowerMizerInfo()
typedef enum _LW_SELECT_INFO
{
    LWAPI_INDEX_PWR_MZR_HARD                            = 0x00000001,       //!<  To set/get PowerMizer Hard limits. Hard Limits modifies the hardware limits. 
    LWAPI_INDEX_PWR_MZR_SOFT                            = 0x00000002,       //!<  To set/get PowerMizer Soft limits. Soft Limits sets the application preference and could be exceeded upto Hard limits if required by the system.
    LWAPI_INDEX_ADC                                     = 0x00000003,       //!<  To set/get Adaptive Clocking parameters where the driver automatically selects the limits. 
} LW_SELECT_INFO;


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:    LwAPI_GPU_GetPowerMizerInfo
//
//!  This function gets 
//!              - the PowerMizer Maximum Limit for both Battery or AC 
//!              - the Adaptive Clocking status for Battery or AC 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \param [in]  hPhysicalGPU         GPU selection.
//! \param [in]  powerSourceInfo      Power source selection with one of the values from ::LW_PWR_SOURCE_INFO.
//! \param [in]  select               PowerMizer type selection with one of the values from ::LW_SELECT_INFO.
//! \param [out] pLevelInfo           Pointer to return value 
//!
//!  
//! \retval  LWAPI_OK                 Completed request
//! \retval  LWAPI_NOT_SUPPORTED      Power Mizer Not supported.
//! \retval  LWAPI_ERROR              Invalid return to API.
//! \ingroup powermizerapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPowerMizerInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_PWR_SOURCE_INFO powerSourceInfo,
                                          LW_SELECT_INFO select, LW_LEVEL_INFO *pLevelInfo);
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:    LwAPI_GPU_SetPowerMizerInfo
//
//!  This function sets 
//!              - the PowerMizer Maximum Limit for both Battery and/or AC 
//!              - the Adaptive Clocking status for Battery or AC  
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \param [in]  hPhysicalGpu              GPU selection.
//! \param [in]  powerSourceInfo           Power source selection with one of the values from ::LW_PWR_SOURCE_INFO.
//! \param [in]  select                    PowerMizer type selection with one of the values from ::LW_SELECT_INFO.
//! \param [out] levelInfo                 Level that has to be set on PwrMzr /Adaptive clocking 
//!
//! \retval      LWAPI_OK                  Completed request
//! \retval      LWAPI_NOT_SUPPORTED       PowerMizer not supported
//! \retval      LWAPI_ILWALID_ARGUMENT    Invalid arguments
//!
//! \ingroup     powermizerapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetPowerMizerInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_PWR_SOURCE_INFO powerSourceInfo, 
                                            LW_SELECT_INFO select, LW_LEVEL_INFO levelInfo);


//! \ingroup gpu
typedef enum _LW_VIRTUALIZATION_MODE
{
    LW_VIRTUALIZATION_MODE_NONE = 0,
    LW_VIRTUALIZATION_MODE_NMOS = 1,
    LW_VIRTUALIZATION_MODE_VGX  = 2
} LW_VIRTUALIZATION_MODE;

//! \ingroup gpu
typedef struct _LW_GPU_VIRTUALIZATION_INFO
{
    LwU32                    version;                      //!< Structure version

    LW_VIRTUALIZATION_MODE   virtualizationMode;           //!< one of LW_VIRTUALIZATION_MODE.
    LwU32                    reserved;                     //!< reserved for future use. Should be set to ZERO.
} LW_GPU_VIRTUALIZATION_INFO_V1;

//! \ingroup gpu
typedef LW_GPU_VIRTUALIZATION_INFO_V1     LW_GPU_VIRTUALIZATION_INFO;

//! \ingroup gpu
#define LW_GPU_VIRTUALIZATION_INFO_VER1   MAKE_LWAPI_VERSION(LW_GPU_VIRTUALIZATION_INFO_V1,1)

//! \ingroup gpu
#define LW_GPU_VIRTUALIZATION_INFO_VER    LW_GPU_VIRTUALIZATION_INFO_VER1


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetVirtualizationInfo
//
//!   DESCRIPTION: This API returns virtualization information of the system
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out] pVirtualizationInfo         Pointer to LW_GPU_VIRTUALIZATION_INFO structure. 
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetVirtualizationInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_VIRTUALIZATION_INFO *pVirtualizationInfo);



//! \ingroup gpu
//! @{

typedef enum _LW_GPU_POWER_STATE
{
    LW_GPU_POWER_STATE_ERROR   =  0,
    LW_GPU_POWER_STATE_ON,
    LW_GPU_POWER_STATE_GOLD,
    LW_GPU_POWER_STATE_EXITING_GOLD,
    LW_GPU_POWER_STATE_ENTERING_GOLD,
    LW_GPU_POWER_STATE_WAITING_FOR_SVC,
    LW_GPU_POWER_STATE_GC6,
    LW_GPU_POWER_STATE_EXITING_GC6,
    LW_GPU_POWER_STATE_ENTERING_GC6,
} LW_GPU_POWER_STATE;

#define LW_GPU_STATE_CHANGE_LOG_COUNT 32

typedef struct _LW_GPU_GC6_STATISTICS 
{
    LwU32 version;  //!<LW_GPU_GC6_STATISTICS struct version
    
    LwU32 GC6TimeoutValue;   
    LwU32 GC6TransitionCount;
    
    LwU32 minTimeInGC6Ms;
    LwU32 maxTimeInGC6Ms;
    LwU32 avgTimeInGC6Ms;
    LwU32 totTimeInGC6Ms;
    
    LwU32 minTimeEnteringGC6Ms;
    LwU32 maxTimeEnteringGC6Ms;
    LwU32 avgTimeEnteringGC6Ms;
    LwU32 totTimeEnteringGC6Ms;
    
    LwU32 minTimeExitingGC6Ms;
    LwU32 maxTimeExitingGC6Ms;
    LwU32 avgTimeExitingGC6Ms;
    LwU32 totTimeExitingGC6Ms;
    
    LwU64 clearTime;     //!< The time stats were last cleared
    LwU64 lwrrentTime;   
    LwU32 timeIncrement;
    
    LwS32 GC6Histogram[LW_GPU_STATE_CHANGE_LOG_COUNT];
    LwS32 enteringGC6Histogram[LW_GPU_STATE_CHANGE_LOG_COUNT];
    LwS32 exitingGC6Histogram[LW_GPU_STATE_CHANGE_LOG_COUNT];

}LW_GPU_GC6_STATISTICS_V1;
    
#define LW_GPU_GC6_STATISTICS_VER1   MAKE_LWAPI_VERSION(LW_GPU_GC6_STATISTICS_V1,1)

typedef struct _LW_GPU_GC6_STATISTICS_V2 
{
    LwU32 version;  //!<LW_GPU_GC6_STATISTICS struct version
    
    LwU32 GC6TimeoutValue;   
    LwU32 GC6TransitionCount;
    
    LwU32 minTimeInGC6Ms;
    LwU32 maxTimeInGC6Ms;
    LwU32 avgTimeInGC6Ms;
    LwU32 totTimeInGC6Ms;
    
    LwU32 minTimeEnteringGC6Ms;
    LwU32 maxTimeEnteringGC6Ms;
    LwU32 avgTimeEnteringGC6Ms;
    LwU32 totTimeEnteringGC6Ms;
    
    LwU32 minTimeExitingGC6Ms;
    LwU32 maxTimeExitingGC6Ms;
    LwU32 avgTimeExitingGC6Ms;
    LwU32 totTimeExitingGC6Ms;
    
    LwU64 clearTime;     //!< The time stats were last cleared
    LwU64 lwrrentTime;   
    LwU32 timeIncrement;

    LwS32 GC6Histogram[LW_GPU_STATE_CHANGE_LOG_COUNT];
    LwS32 enteringGC6Histogram[LW_GPU_STATE_CHANGE_LOG_COUNT];
    LwS32 exitingGC6Histogram[LW_GPU_STATE_CHANGE_LOG_COUNT];

    LW_GPU_POWER_STATE state;

}LW_GPU_GC6_STATISTICS_V2;

#define LW_GPU_GC6_STATISTICS_VER2   MAKE_LWAPI_VERSION(LW_GPU_GC6_STATISTICS_V2,2)

typedef struct _LW_GPU_GC6_STATISTICS_V3 
{
    LwU32 version;  //!<LW_GPU_GC6_STATISTICS struct version
    
    LwU32 GC6TimeoutValue;   
    LwU32 GC6TransitionCount;
    
    LwU32 minTimeInGC6Ms;
    LwU32 maxTimeInGC6Ms;
    LwU32 avgTimeInGC6Ms;
    LwU32 totTimeInGC6Ms;
    
    LwU32 minTimeEnteringGC6Ms;
    LwU32 maxTimeEnteringGC6Ms;
    LwU32 avgTimeEnteringGC6Ms;
    LwU32 totTimeEnteringGC6Ms;
    
    LwU32 minTimeExitingGC6Ms;
    LwU32 maxTimeExitingGC6Ms;
    LwU32 avgTimeExitingGC6Ms;
    LwU32 totTimeExitingGC6Ms;
    
    LwU64 clearTime;     //!< The time stats were last cleared
    LwU64 lwrrentTime;   
    LwU32 timeIncrement;

    LwS32 GC6Histogram[LW_GPU_STATE_CHANGE_LOG_COUNT];
    LwS32 enteringGC6Histogram[LW_GPU_STATE_CHANGE_LOG_COUNT];
    LwS32 exitingGC6Histogram[LW_GPU_STATE_CHANGE_LOG_COUNT];

    LW_GPU_POWER_STATE state;
    
    LwU32 maxTimeEnteringGC6RM;
    LwU32 minTimeEnteringGC6RM;
    LwU32 totTimeEnteringGC6RM;
    
    LwU32 maxTimeExitingGC6RM;
    LwU32 minTimeExitingGC6RM;
    LwU32 totTimeExitingGC6RM;
    
    LwU32 maxStateLoadGC6;
    LwU32 minStateLoadGC6;
    LwU32 totStateLoadGC6;
    
    LwU32 maxStateUnloadGC6;
    LwU32 minStateUnloadGC6;
    LwU32 totStateUnloadGC6;
    
    LwU32 maxPowerOnTimeGC6;
    LwU32 minPowerOnTimeGC6;
    LwU32 totPowerOnTimeGC6;
    
    LwU32 maxPowerOffTimeGC6;
    LwU32 minPowerOffTimeGC6;
    LwU32 totPowerOffTimeGC6;
    
    LwU32 maxSCIPowerOnTimeGC6;
    LwU32 minSCIPowerOnTimeGC6;
    LwU32 totSCIPowerOnTimeGC6;
    
    LwU32 maxSCIPowerOffTimeGC6;
    LwU32 minSCIPowerOffTimeGC6;
    LwU32 totSCIPowerOffTimeGC6;
    
    LwU32 maxDevinitTimeGC6;
    LwU32 minDevinitTimeGC6;
    LwU32 totDevinitTimeGC6;
    
    LwU32 maxPMUBootstrapTimeGC6;
    LwU32 minPMUBootstrapTimeGC6;
    LwU32 totPMUBootstrapTimeGC6;

}LW_GPU_GC6_STATISTICS_V3;

#define LW_GPU_GC6_STATISTICS_VER3   MAKE_LWAPI_VERSION(LW_GPU_GC6_STATISTICS_V3,3)

typedef LW_GPU_GC6_STATISTICS_V3     LW_GPU_GC6_STATISTICS;

#define LW_GPU_GC6_STATISTICS_VER    LW_GPU_GC6_STATISTICS_VER3


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetGC6Statistics
//
//! DESCRIPTION:    This API call is used to get the Graphics C-state6 statistics from the Driver.
//!                 If call succeeds,  "pGpuGC6Stats" points to the GC6 Statistics.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     hPhysicalGpu  - Physical GPU Handle. 
//! \param [out]    pGpuGC6Stats  - Pointer to the LW_GPU_GC6_STATISTICS data. 
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetGC6Statistics(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_GC6_STATISTICS *pGpuGC6Stats);

//! @}


//! \ingroup gpu
//! @{

typedef enum _LW_GPU_GC6_CONTROL_OP
{
    CLEAR_STATS         = 0,
    SET_STATS_ENABLED,
    SET_STATS_DISABLED,
    IS_GC6_SUPPORTED,
    IS_GC6_ENABLED,
} LW_GPU_GC6_CONTROL_OP;

typedef enum _LW_GPU_GC6_CONTROL_STATUS
{
    SUCCESS             = 0,
    FEATURE_DISABLED,
    CANNOT_ENABLE_STATS,
    STATS_DISABLED,
    FAILED,
} LW_GPU_GC6_CONTROL_STATUS;

typedef struct _LW_GPU_GC6_CONTROL
{
    LwU32                      version;       //!<LW_GPU_GC6_CONTROL struct version
    LW_GPU_GC6_CONTROL_OP      controlOp;     //!<Structure specifies control operation to be performed
    LW_GPU_GC6_CONTROL_STATUS  controlStatus; //!<Enum to signal status to the caller
}LW_GPU_GC6_CONTROL_V1;

#define LW_GPU_GC6_CONTROL_VER1   MAKE_LWAPI_VERSION(LW_GPU_GC6_CONTROL_V1,1)

typedef LW_GPU_GC6_CONTROL_V1     LW_GPU_GC6_CONTROL;

#define LW_GPU_GC6_CONTROL_VER    LW_GPU_GC6_CONTROL_VER1


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GC6Control
//
//! DESCRIPTION:    This API call is used to control Certain statistics related features of GC6
//!                 If call succeeds,  "pGpuGC6Control" points to the GC6 Control Feature Return Status.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     hPhysicalGpu    - Physical GPU Handle. 
//! \param [out]    pGpuGC6Control  - Pointer to the LW_GPU_GC6_CONTROL data. 
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GC6Control(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_GC6_CONTROL *pGpuGC6Control);

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_ForceGC6Exit
//
//! DESCRIPTION:     This API call disables GC6.                  
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     hPhysicalGpu  - Physical GPU Handle. 
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ForceGC6Exit(__in LwPhysicalGpuHandle hPhysicalGpu);




//! \ingroup gpu
typedef struct _LW_REF_COUNT_ACCESS_PARAM_V1
{
    LwU32                     version;              //!< version info
    LwU8                      incrementRefCount: 1; //!< Setting this field will increment the reference count
    LwU8                      reserved: 7;          //!< Must be 0
}LW_REF_COUNT_ACCESS_PARAM_V1;

//! \ingroup gpu
typedef LW_REF_COUNT_ACCESS_PARAM_V1       LW_REF_COUNT_ACCESS_PARAM;
//! \ingroup gpu
#define LW_REF_COUNT_ACCESS_PARAM_VER_1    MAKE_LWAPI_VERSION(LW_REF_COUNT_ACCESS_PARAM_V1,1)
//! \ingroup gpu
#define LW_REF_COUNT_ACCESS_PARAM_VER     LW_REF_COUNT_ACCESS_PARAM_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:     LwAPI_GPU_AccessRefCount
//
//! DESCRIPTION:      This API causes the system to increment or decrement Jefferson Technology/coproc reference count. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]        hPhysicalGpu       - Handle for Physical GPU Handle for which the reference Count is accessed. Added only for future use. 
//! \param [in]        pRefCountParams    - In Pointer to the LW_REF_COUNT_ACCESS_PARAM
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup gpu   
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_AccessRefCount(__in LwPhysicalGpuHandle hPhysicalGpu, __in LW_REF_COUNT_ACCESS_PARAM* pRefCountParams);


//! \ingroup gpu
typedef struct _LW_PCIE_LTR_INFO_V1
{
    LwU32                     version;                      //!< version info

    LwU8                      bLtrRegkeyOverride :1;        //!< Boolean to check if LTR SW is disabled via regkey. Output only.
    LwU8                      bRootPortLtrSupported :1;     //!< Boolean to check if LTR supported is advertised by Root Port. Output only.
    LwU8                      bGpuLtrSupported :1;          //!< Boolean to check if LTR supported is advertised by GPU. Output only.
    LwU8                      reserved :5;                  //!< Reserved.
    LwU16                     snoopLatencyValue;            //!< Maximum Tolerable Snoop Latency Value. Input/Output.
    LwU8                      snoopLatencyScale;            //!< Maximum Tolerable Snoop Latency Scale. Input/Output.
    LwU16                     noSnoopLatencyValue;          //!< Maximum Tolerable No Snoop Latency Value. Input/Output.
    LwU8                      noSnoopLatencyScale;          //!< Maximum Tolerable No Snoop Latency Scale. Input/Output.
} LW_PCIE_LTR_INFO_V1;

//! \ingroup gpu
typedef LW_PCIE_LTR_INFO_V1       LW_PCIE_LTR_INFO;
//! \ingroup gpu
#define LW_PCIE_LTR_INFO_VER_1    MAKE_LWAPI_VERSION(LW_PCIE_LTR_INFO_V1,1)
//! \ingroup gpu
#define LW_PCIE_LTR_INFO_VER      LW_PCIE_LTR_INFO_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:     LwAPI_GPU_GetPCIELtrInfo
//
//! DESCRIPTION:      This API gets the current Latency Tolerance Reporting latency values. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]        hPhysicalGpu       - Handle for Physical GPU Handle for which we want the LTR values. 
//! \param [out]       pPexLtrInfo        - In Pointer to the LW_PCIE_LTR_INFO
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup gpu   
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPCIELtrInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_PCIE_LTR_INFO* pPexLtrInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:     LwAPI_GPU_SetPCIELtrInfo
//
//! DESCRIPTION:      This API sets the PEX Latency Tolerance Reporting value to be sent to the Root Port. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]        hPhysicalGpu       - Handle for Physical GPU Handle for which the LTR values should be set. 
//! \param [in]        pPexLtrInfo        - In Pointer to the LW_PCIE_LTR_INFO
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup gpu   
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetPCIELtrInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __in LW_PCIE_LTR_INFO* pPexLtrInfo);


typedef enum _LW_UEFI_IMAGE_PRESENCE
{
    LW_UEFI_IMAGE_YES = 0,                              //!< "Yes"- There is a usable UEFI image in the rom. 
    LW_UEFI_IMAGE_NO,                                   //!< "No"- There is no UEFI image in the ROM file. 
    LW_UEFI_IMAGE_NO_HIDDEN,                            //!< "No (hidden)"- There is a UEFI image in the rom file, but it is after an image which has Last Indicator set to 1. 
    LW_UEFI_IMAGE_PLACEHOLDER                           //!< "Placeholder"- There is a dummy UEFI placeholder which can later be updated to a valid UEFI image. 
}LW_UEFI_IMAGE_PRESENCE;

typedef struct _LW_UEFI_INFO_V1
{
    LwU32                   version;

    LW_UEFI_IMAGE_PRESENCE  UEFIPresence;               //!< Indicates the presence of a UEFI image in the ROM.
    LwU8                    isUEFIused;                 //!< 1 indicates UEFI mode and 0 indicates the legacy mode.
    LwU32                   UEFI_GOP_Version;           //!< UEFI(Unified Extensible Firmware Interface) GOP (Graphics Output Protocol) driver's Version.
    LwU32                   changelist;                 //!< Changelist number.
    LwAPI_ShortString       signerIdentity;             //!< UEFI image signer's identity.
    LwAPI_ShortString       date;                       //!< Date, in the mmddyyyy format, when the changelist was committed.
}LW_UEFI_INFO_V1;

typedef LW_UEFI_INFO_V1         LW_UEFI_INFO;           //!< Lwrrently used version
#define LW_UEFI_INFO_VER1       MAKE_LWAPI_VERSION(LW_UEFI_INFO_V1,1)
#define LW_UEFI_INFO_VER        LW_UEFI_INFO_VER1

///////////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_GPU_GetUEFIInfo
//
//! DESCRIPTION: This API gets information about the UEFI(Unified Extensible Firmware Interface) 
//!				 image for the specified GPU.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     hPhysicalGpu    - (LwPhysicalGpuHandle) Specifies the GPU whose image is to be read.
//!	       [inout]  uefiInfo        - (LW_UEFI_INFO) Contains information extracted from the UEFI image.
//!
//!
//! \return : This API can return any of the error codes enumerated in #LwAPI_Status. 
//!  If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
////////////////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetUEFIInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_UEFI_INFO *uefiInfo);


//! \ingroup gpulwda

//! Used in LwAPI_GPU_GetComputePrecisionInfo() and LwAPI_GPU_SetComputePrecision().
typedef enum 
{ 
    LW_SINGLE_PRECISION          = 0, 
    LW_DOUBLE_PRECISION          = 1 
} LW_COMPUTE_PRECISION;

typedef struct _LW_COMPUTE_PRECISION_INFO_V1
{
    LwU32 version;
    
    LW_COMPUTE_PRECISION     maxSupportedPrecision;    //!< Indicates the max compute precision the GPU is capable of.
    LW_COMPUTE_PRECISION     lwrrPrecision;            //!< The current compute precision set on the GPU. 
}LW_COMPUTE_PRECISION_INFO_V1;

typedef LW_COMPUTE_PRECISION_INFO_V1        LW_COMPUTE_PRECISION_INFO;    //!< Lwrrently used version
#define LW_COMPUTE_PRECISION_INFO_VER1      MAKE_LWAPI_VERSION(LW_COMPUTE_PRECISION_INFO_V1,1)
#define LW_COMPUTE_PRECISION_INFO_VER       LW_COMPUTE_PRECISION_INFO_VER1

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:  LwAPI_GPU_GetComputePrecisionInfo
//
//! DESCRIPTION:   This API gets the compute precision information of the specified GPU.
//
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      hPhysicalGpu            - (LwPhysicalGpuHandle) Specifies the GPU, for which we want to query the precision information.
//!        [inout]   computePrecisionInfo    - (LW_COMPUTE_PRECISION_INFO) Contains the compute precision information of the GPU, whose handle is passed. 
//!
//! \return : This API can return any of the error codes enumerated in #LwAPI_Status. 
//!  If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup gpulwda
////////////////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetComputePrecisionInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_COMPUTE_PRECISION_INFO *computePrecisionInfo);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:  LwAPI_GPU_SetComputePrecision
//
//! DESCRIPTION:   This API is used to change the compute precision on the specified GPU. If the GPU, whose physical handle is passed,
//!                is part of a SLI group then this call will set the passed compute precision value for all the compute precision capable GPUs 
//!                in that SLI group.
//
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]    hPhysicalGpu        - (LwPhysicalGpuHandle) Specifies the GPU for which we want to change the compute precision.
//!	       [in]    computePrecision    - (LW_COMPUTE_PRECISION) Contains the compute precision value to be set. Valid states that can be
//!                passed as inputs are LW_SINGLE_PRECISION and LW_DOUBLE_PRECISION.
//!
//! \return : This API can return any of the error codes enumerated in #LwAPI_Status. 
//!  If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup gpulwda
////////////////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetComputePrecision(__in LwPhysicalGpuHandle hPhysicalGpu, __in LW_COMPUTE_PRECISION computePrecision);

//! \ingroup gpu

#define LW_GPU_INFOROM_IMAGE_VERSION_LEN 16

typedef struct _LW_INFOROM_IMAGE_INFO_V1
{
    LwU32   version;
    
    LwU8    InfoROM_image_version[LW_GPU_INFOROM_IMAGE_VERSION_LEN];        //!< This parameter returns the version of the InfoROM image as a NULL-terminated character
                                                                            //!< string of the form "XXXX.XXXX.XX.XX" where each 'X' is an integer character.
}LW_INFOROM_IMAGE_INFO_V1;

typedef LW_INFOROM_IMAGE_INFO_V1            LW_INFOROM_IMAGE_INFO;          //!< Lwrrently used version
#define LW_INFOROM_IMAGE_INFO_VER1          MAKE_LWAPI_VERSION(LW_INFOROM_IMAGE_INFO_V1,1)
#define LW_INFOROM_IMAGE_INFO_VER           LW_INFOROM_IMAGE_INFO_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetInfoROMData
//
//!   DESCRIPTION: This API returns data parsed from the InfoROM image.The inforom is a small,
//!                persistent store of configuration and state data for the GPU. All inforom
//!                version fields are numerical.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in,out] pImageData 
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetInfoROMData(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_INFOROM_IMAGE_INFO *pInfoROMInfo);

//! \ingroup gpu

typedef enum _LW_GPU_OPTIMIZATION_MODE
{
    LW_GPU_OPTIMIZATION_MODE_NONE           = 0,
    LW_GPU_OPTIMIZATION_MODE_DEFAULT        = 1,
    LW_GPU_OPTIMIZATION_MODE_COMPUTE        = 2,
    LW_GPU_OPTIMIZATION_MODE_SPARSE_TEXTURE = 3,
}LW_GPU_OPTIMIZATION_MODE;

typedef struct _LW_GPU_GET_OPTIMIZATION_DATA_V1
{
    LwU32 version;

    LwPhysicalGpuHandle      hPhysicalGpu; 
    LW_GPU_OPTIMIZATION_MODE defaultOptimizationMode; //!< Default optimization mode for the GPU.
    LW_GPU_OPTIMIZATION_MODE lwrrentOptimizationMode; //!< Lwrrently applied optimization mode for the GPU.
}LW_GPU_GET_OPTIMIZATION_DATA_V1;

typedef LW_GPU_GET_OPTIMIZATION_DATA_V1          LW_GPU_GET_OPTIMIZATION_DATA;
#define LW_GPU_GET_OPTIMIZATION_DATA_VER1        MAKE_LWAPI_VERSION(LW_GPU_GET_OPTIMIZATION_DATA_V1, 1)
#define LW_GPU_GET_OPTIMIZATION_DATA_VER         LW_GPU_GET_OPTIMIZATION_DATA_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetOptimizationData
//
//!   DESCRIPTION: This API returns GPU optimization data for all the supported GPUs in the system. This API is supported on Vista & above and on Lwdqro GPUs.
//
//! USAGE:         Sequence of calls which caller should make to get the information.
//!                1. First call LwAPI_GPU_GetOptimizationData() with gpuOptimizationData as NULL to get the count.
//!                2. Allocate memory for GPU optimization data (LW_GPU_GET_OPTIMIZATION_DATA) array depending on the value of count.
//!                3. Call LwAPI_GPU_GetOptimizationData() again with the pointer to the memory allocated to get the 
//!                   GPU optimization data for all the supported GPUs in the system.
//!                   
//!                Note : 
//!                1. count should never be NULL, else the API will fail with LWAPI_ILWALID_POINTER.
//!                2. If the memory allocated is less than what is required to return all the timings, this API will return the
//!                   amount of information which can fit in user provided buffer and API will return LWAPI_INSUFFICIENT_BUFFER.
//!                3. Caller can allocate and pass in large enough buffer in the first call itself to avoid calling the API multiple
//!                   times to get the count then the actual data.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [inout] gpuOptimizationData - Pointer to the array of LW_GPU_GET_OPTIMIZATION_DATA structure.
//!        [inout] count               - Number of elements in the gpuOptimizationData array. This would be equal to the the number 
//!                                      of GPUs supporting optimization. 
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetOptimizationData(__inout_ecount_part_opt(*count, *count) LW_GPU_GET_OPTIMIZATION_DATA *gpuOptimizationData, __inout LwU32 *count);

//! \ingroup gpu

typedef struct _LW_GPU_SET_OPTIMIZATION_DATA_V1
{
    LwU32   version;

    LwPhysicalGpuHandle      hPhysicalGpu; 
    LW_GPU_OPTIMIZATION_MODE setOptimizationMode;
}LW_GPU_SET_OPTIMIZATION_DATA_V1;

typedef LW_GPU_SET_OPTIMIZATION_DATA_V1          LW_GPU_SET_OPTIMIZATION_DATA;
#define LW_GPU_SET_OPTIMIZATION_DATA_VER1        MAKE_LWAPI_VERSION(LW_GPU_SET_OPTIMIZATION_DATA_V1, 1)
#define LW_GPU_SET_OPTIMIZATION_DATA_VER         LW_GPU_SET_OPTIMIZATION_DATA_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_SetOptimizationData
//
//!   DESCRIPTION: This API sets the GPU optimization data for GPUs specified by caller. This API is supported on Vista & above and on Lwdqro GPUs.
//
//!   Notes : 
//!           1. If any of the GPU specified in gpuOptimizationData is part of any SLI group, the settings will get set for all the GPUs in the SLI group,
//!              even if the GPUs are not specified in the input. Callers can also pass in all the GPUs in the SLI group, but its not necessary.
//!           2. This API will also reload the driver on the specified GPUs, once the optimization data is set properly on all specified GPUs.
//!           3. If more than one GPUs of a SLI group are specified, optimization modes (setOptimizationMode) for all them should match, otherwise the 
//!              the return LWAPI_ILWALID_ARGUMENT error.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    gpuOptimizationData - Pointer to the array of LW_GPU_SET_OPTIMIZATION_DATA structure.
//!        [in]    count               - Number of elements in the gpuOptimizationData array. 
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetOptimizationData(__in_ecount(count) LW_GPU_SET_OPTIMIZATION_DATA *gpuOptimizationData, __in LwU32 count);

//! \ingroup gpufan
//! @{

#define LW_GPU_FAN_COOLER_MAX_COOLERS_V1 32

/*!
 * Enumeration of fan cooler types.
 */
typedef enum _LW_GPU_FAN_COOLER_TYPE
{
    LW_GPU_FAN_COOLER_TYPE_ACTIVE,
    LW_GPU_FAN_COOLER_TYPE_ACTIVE_PWM,
    LW_GPU_FAN_COOLER_TYPE_ACTIVE_PWM_TACH_CORR,
} LW_GPU_FAN_COOLER_TYPE;

/*!
 * Enumeration of fan cooler control unit type.
 */
typedef enum _LW_GPU_FAN_COOLER_CONTROL_UNIT_TYPE
{
    LW_GPU_FAN_COOLER_CONTROL_UNIT_TYPE_NONE,
    LW_GPU_FAN_COOLER_CONTROL_UNIT_TYPE_PWM,
    LW_GPU_FAN_COOLER_CONTROL_UNIT_TYPE_RPM,
} LW_GPU_FAN_COOLER_CONTROL_UNIT_TYPE;

/*!
 * Used in \ref LW_GPU_FAN_COOLER_INFO_V1
 * Describes the static information of fan cooler type ACTIVE.
 */
typedef struct _LW_GPU_FAN_COOLER_INFO_DATA_ACTIVE
{
    /*!
     * Tachometer GPIO Function.
     */
    LwU32   gpioFuncTach;

    /*!
     * Tachometer Rate (PPR).
     */
    LwU8    tachRate;

    /*!
     * Tachometer is present and supported.
     * Supported: 1, Unsupported: 0.
     */
    LwU32   bTachSupported : 1;

    /*!
     * Reserved bits.
     */
    LwU32   rsvd : 31;

    /*!
     * Control unit used (by policy) to drive this cooler as
     * \ref LW_GPU_FAN_COOLER_CONTROL_UNIT_TYPE
     */
    LW_GPU_FAN_COOLER_CONTROL_UNIT_TYPE    controlUnit;
} LW_GPU_FAN_COOLER_INFO_DATA_ACTIVE;

/*!
 * Used in \ref LW_GPU_FAN_COOLER_INFO_V1
 * Describes the static information of fan cooler type ACTIVE_PWM.
 */
typedef struct _LW_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM
{
    /*!
     * LW_GPU_FAN_COOLER_INFO_DATA_ACTIVE super class.
     * This should always be the first member!
     */
    LW_GPU_FAN_COOLER_INFO_DATA_ACTIVE active;

    /*!
     * Fan GPIO Function.
     */
    LwU32  gpioFuncFan;

    /*!
     * PWM frequency. Units: Hz
     */
    LwU32  freq;
} LW_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM;

/*!
 * Used in \ref LW_GPU_FAN_COOLER_INFO_V1
 * Describes the static information of fan cooler type ACTIVE_PWM_TACH_CORR.
 */
typedef struct _LW_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM_TACH_CORR
{
    /*!
     * LW_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM super class.
     * This should always be the first member!
     */
    LW_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM activePwm;
} LW_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM_TACH_CORR;

/*!
 * Used in \ref LW_GPU_FAN_COOLER_INFO_PARAMS_V1.
 * Describes the static information of fan coolers
 */
typedef struct _LW_GPU_FAN_COOLER_INFO_V1
{
    /*!
     * Fan cooler type.
     */
    LW_GPU_FAN_COOLER_TYPE type;

    /*!
     * Reserved bytes for possible future extension of this struct.
     */
    LwU8                   rsvd[32];

    /*!
     * Union of fan cooler info data. Interpreted as per
     * @ref LW_GPU_FAN_COOLER_INFO_V1::type
     */
    union
    {
        //
        // Need to be careful when add/expanding types in this union. If any type
        // exceeds sizeof(rsvd) then rsvd has failed its purpose.
        //
        LW_GPU_FAN_COOLER_INFO_DATA_ACTIVE                active;
        LW_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM            activePwm;
        LW_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM_TACH_CORR  activePwmTachCorr;
        /*!
         * Reserved bytes for possible future extension of this struct.
         */
        LwU8               rsvd[32];
    } data;

} LW_GPU_FAN_COOLER_INFO_V1;

/*!
 * Used in \ref LwAPI_GPU_FanCoolerGetInfo.
 * Describes the fan coolers and their static info available on the given GPU.
 */
typedef struct _LW_GPU_FAN_COOLER_INFO_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first member.
     */
    LwU32                     version;

    /*!
     * Mask of entries corresponding to available \ref LW_GPU_FAN_COOLER_TYPE.
     */
    LwU32                     coolerMask;

    /*!
     * Reserved bytes for possible future extension of this struct.
     */
    LwU8                      rsvd[32];

    /*!
     * Array of fan cooler entries. Index in array corresponds to set bits in 
     * \ref LW_GPU_FAN_COOLER_INFO_PARAMS_V1::coolerMask.
     */
    LW_GPU_FAN_COOLER_INFO_V1 coolers[LW_GPU_FAN_COOLER_MAX_COOLERS_V1];
} LW_GPU_FAN_COOLER_INFO_PARAMS_V1;

#define LW_GPU_FAN_COOLER_INFO_PARAMS_VER_1 MAKE_LWAPI_VERSION(LW_GPU_FAN_COOLER_INFO_PARAMS_V1, 1)
#define LW_GPU_FAN_COOLER_INFO_PARAMS_VER   LW_GPU_FAN_COOLER_INFO_PARAMS_VER_1
typedef LW_GPU_FAN_COOLER_INFO_PARAMS_V1    LW_GPU_FAN_COOLER_INFO_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_FanCoolerGetInfo
//
//! DESCRIPTION:  This API returns static information about fan coolers on the
//!               given GPU.
//
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 319.xx
//! \param [in]  hPhysicalGpu    The physical GPU handle
//! \param [out] pFanCoolerInfo  Pointer to structure containing static
//!                              information about fan coolers.
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status.
//!          If there are return error codes with specific meaning for this API,
//!          they are listed below.
//! \ingroup gpufan
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_FanCoolerGetInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_FAN_COOLER_INFO_PARAMS *pFanCoolerInfo);

//! \ingroup gpufan
//! @{

/*!
 * Used in \ref LW_GPU_FAN_COOLER_STATUS_V1
 * Describes the status of fan cooler type ACTIVE.
 */
typedef struct _LW_GPU_FAN_COOLER_STATUS_DATA_ACTIVE
{
    /*!
     * Current RPM.
     */
    LwU32 rpmLwrr;

    /*!
     * Minimum fan level, as UFXP percentage (computed from driving RPM or PWM
     * value normalized to max).
     * Format: Unsigned Fixed Point Integer 16.16
     */
    LwU32 levelMin;

    /*!
     * Maximum fan level, as UFXP percentage (computed from driving RPM or PWM
     * value normalized to max. Between 0.0 to 1.0).
     * Format: Unsigned Fixed Point Integer 16.16
     */
    LwU32 levelMax;

    /*!
     * Current (dynamic) fan level, as UFXP percentage (computed from driving
     * RPM or PWM value normalized to max).
     * Format: Unsigned Fixed Point Integer 16.16
     */
    LwU32 levelLwrrent;

    /*!
     * Target (lwrrently requested, static) fan level, as UFXP percentage
     * (computed from driving RPM or PWM value normalized to max).
     * Format: Unsigned Fixed Point Integer 16.16
     */
    LwU32 levelTarget;
} LW_GPU_FAN_COOLER_STATUS_DATA_ACTIVE;

/*!
 * Used in \ref LW_GPU_FAN_COOLER_STATUS_V1
 * Describes the status  of fan cooler type ACTIVE_PWM.
 */
typedef struct _LW_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM
{
    /*!
     * LW_GPU_FAN_COOLER_STATUS_DATA_ACTIVE super class.
     * This should always be the first member!
     */
    LW_GPU_FAN_COOLER_STATUS_DATA_ACTIVE   active;

    /*!
     * Current Electrical Fan Speed (%).
     * Format: Unsigned Fixed Point Integer 16.16
     */
    LwU32                                  pwmLwrr;
} LW_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM;

/*!
 * Used in \ref LW_GPU_FAN_COOLER_STATUS_V1
 * Describes the status of fan cooler type ACTIVE_PWM_TACH_CORR.
 */
typedef struct _LW_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_TACH_CORR
{
    /*!
     * LW_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM super class.
     * This should always be the first member!
     */
    LW_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM   activePwm;

    /*!
     * Last RPM reading used for tach correction.
     */
    LwU32                                      rpmLast;

    /*!
     * Target RPM requested by tach correction.
     */
    LwU32                                      rpmTarget;
} LW_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_TACH_CORR;


/*!
 * Used in \ref LW_GPU_FAN_COOLER_STATUS_PARAMS_V1.
 * Describes the status of fan coolers
 */
typedef struct _LW_GPU_FAN_COOLER_STATUS_V1
{
    /*!
     * Fan cooler type.
     */
    LW_GPU_FAN_COOLER_TYPE type;

    /*!
     * Reserved bytes for possible future extension of this struct.
     */
    LwU8                   rsvd[32];

    /*!
     * Union of fan cooler status data. Interpreted as per
     * @ref LW_GPU_FAN_COOLER_STATUS_V1::type
     */
    union
    {
        //
        // Need to be careful when add/expanding types in this union. If any type
        // exceeds sizeof(rsvd) then rsvd has failed its purpose.
        //
        LW_GPU_FAN_COOLER_STATUS_DATA_ACTIVE                active;
        LW_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM            activePwm;
        LW_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_TACH_CORR  activePwmTachCorr;
        /*!
         * Reserved bytes for possible future extension of this struct.
         */
        LwU8               rsvd[32];
    } data;
} LW_GPU_FAN_COOLER_STATUS_V1;

/*!
 * Used in \ref LwAPI_GPU_FanCoolerGetStatus.
 * Describes the fan coolers status available on the given GPU.
 */
typedef struct _LW_GPU_FAN_COOLER_STATUS_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first member.
     */
    LwU32                       version;

    /*!
     * Mask of entries corresponding to available @ref LW_GPU_FAN_COOLER_TYPE
     * requested by client.
     */
    LwU32                       coolerMask;

    /*!
     * Reserved bytes for possible future extension of this struct.
     */
    LwU8                        rsvd[32];

    /*!
     * Array of fan cooler entries. Index in array corresponds to set bits in 
     * \ref LW_GPU_FAN_COOLER_STATUS_PARAMS_V1::coolerMask.
     */
    LW_GPU_FAN_COOLER_STATUS_V1 coolers[LW_GPU_FAN_COOLER_MAX_COOLERS_V1];
} LW_GPU_FAN_COOLER_STATUS_PARAMS_V1;

#define LW_GPU_FAN_COOLER_STATUS_PARAMS_VER_1 MAKE_LWAPI_VERSION(LW_GPU_FAN_COOLER_STATUS_PARAMS_V1, 1)
#define LW_GPU_FAN_COOLER_STATUS_PARAMS_VER   LW_GPU_FAN_COOLER_STATUS_PARAMS_VER_1
typedef LW_GPU_FAN_COOLER_STATUS_PARAMS_V1    LW_GPU_FAN_COOLER_STATUS_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_FanCoolerGetStatus
//
//! DESCRIPTION:  This API returns status of fan coolers on the
//!               given GPU.
//
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 319.xx
//! \param [in]  hPhysicalGpu      The physical GPU handle
//! \param [out] pFanCoolerStatus  Pointer to structure containing status
//!                                information about fan coolers.
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status.
//!          If there are return error codes with specific meaning for this API,
//!          they are listed below.
//! \ingroup gpufan
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_FanCoolerGetStatus(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_FAN_COOLER_STATUS_PARAMS *pFanCoolerStatus);

//! \ingroup gpufan
//! @{

/*!
 * Used in \ref LW_GPU_FAN_COOLER_CONTROL_V1
 * Describes the status of fan cooler type ACTIVE.
 */
typedef struct _LW_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE
{
    /*!
     * Minimum RPM.
     */
    LwU32 rpmMin;

    /*!
     * Acoustic Maximum RPM.
     */
    LwU32 rpmMax;

    /*!
     * Reflects the state of fan level (normalized %) override.
     * Active: 1, Inactive: 0
     *
     * Level override has highest priority since it was selected that
     * the parent classes has precedence over children.
     */
    LwU32                                  bLevelSimActive : 1;

    /*!
     * Reserved bits.
     */
    LwU32                                  rsvd : 31;

    /*!
     * Override value for fan level (normalized %).
     * Applicable only when \ref bLevelSimActive == 1.
     * Format: Unsigned Fixed Point Integer 16.16
     */
    LwU32                                  levelSim;
} LW_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE;

/*!
 * Used in \ref LW_GPU_FAN_COOLER_CONTROL_V1
 * Describes the status  of fan cooler type ACTIVE_PWM.
 */
typedef struct _LW_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM
{
    /*!
     * LW_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE super class.
     * This should always be the first member!
     */
    LW_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE  active;

    /*!
     * Electrical Minimum Fan Speed (%).
     * Format: Unsigned Fixed Point Integer 16.16
     */
    LwU32                                  pwmMin;

    /*!
     * Electrical Maximum Fan Speed (%).
     * Format: Unsigned Fixed Point Integer 16.16
     */
    LwU32                                  pwmMax;

    /*!
     * Reflects the state of Electrical Fan Speed (PWM) override.
     * Active: 1, Inactive: 0
     *
     * PWM override has lower priority than parent's class level override since
     * it was selected that the parent classes has precedence over children.
     */
    LwU32                                  bPwmSimActive : 1;

    /*!
     * Reserved bits.
     */
    LwU32                                  rsvd : 31;

    /*!
     * Override value for Electrical Fan Speed (%).
     * Applicable only when \ref bPwmSimActive == 1.
     * Format: Unsigned Fixed Point Integer 16.16
     */
    LwU32                                  pwmSim;

} LW_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM;

/*!
 * Used in \ref LW_GPU_FAN_COOLER_CONTROL_V1
 * Describes the status of fan cooler type ACTIVE_PWM_TACH_CORR.
 */
typedef struct _LW_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_TACH_CORR
{
    /*!
     * LW_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM super class.
     * This should always be the first member!
     */
    LW_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM  activePwm;

    /*!
     * Tachometer Feedback Proportional Gain. Fixed point uint (0.16)
     * Format: Signed Fixed Point Integer 16.16
     */
    LwS32                                      propGain;

    /*!
     * Reflects the state of RPM override.
     * Active: 1, Inactive: 0
     *
     * RPM override has lower priority than both level and PWM overrides since
     * it was selected that the parent classes has precedence over children.
     */
    LwU32                                      bRpmSimActive : 1;

    /*!
     * Reserved bits.
     */
    LwU32                                      rsvd : 31;

    /*!
     * Override value for RPM settings.
     * Applicable only when \ref bRpmSimActive == 1.
     */
    LwU32                                      rpmSim;
} LW_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_TACH_CORR;

/*!
 * Used in \ref LW_GPU_FAN_COOLER_CONTROL_PARAMS_V1.
 * Describes the control data of fan coolers
 */
typedef struct _LW_GPU_FAN_COOLER_CONTROL_V1
{
    /*!
     * Fan cooler type.
     */
    LW_GPU_FAN_COOLER_TYPE type;

    /*!
     * Reserved bytes for possible future extension of this struct.
     */
    LwU8                   rsvd[32];

    /*!
     * Union of fan cooler status data. Interpreted as per
     * \ref LW_GPU_FAN_COOLER_CONTROL_V1::type
     */
    union
    {
        //
        // Need to be careful when add/expanding types in this union. If any type
        // exceeds sizeof(rsvd) then rsvd has failed its purpose.
        //
        LW_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE                active;
        LW_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM            activePwm;
        LW_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_TACH_CORR  activePwmTachCorr;
        /*!
         * Reserved bytes for possible future extension of this struct.
         */
        LwU8               rsvd[32];
    } data;
} LW_GPU_FAN_COOLER_CONTROL_V1;

/*!
 * Used in \ref LwAPI_GPU_FanCoolerGetControl.
 * Describes the fan coolers' control data available on the given GPU.
 */
typedef struct _LW_GPU_FAN_COOLER_CONTROL_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first member.
     */
    LwU32                       version;

    /*!
     * Mask of entries corresponding to available @ref LW_GPU_FAN_COOLER_TYPE
     * requested by client.
     */
    LwU32                       coolerMask;

    /*!
     * Bit field specifying the set of values to retrieve
     * - default (1)
     * - lwrrently active (0).
     */
    LwU32                       retrieveDefault : 1;
    LwU32                       reservedField : 31;

    /*!
     * Reserved bytes for possible future extension of this struct.
     */
    LwU8                        rsvd[32];

    /*!
     * Array of fan cooler entries. Index in array corresponds to set bits in 
     * @ref LW_GPU_FAN_COOLER_CONTROL_PARAMS_V1::coolerMask.
     */
    LW_GPU_FAN_COOLER_CONTROL_V1 coolers[LW_GPU_FAN_COOLER_MAX_COOLERS_V1];
} LW_GPU_FAN_COOLER_CONTROL_PARAMS_V1;

#define LW_GPU_FAN_COOLER_CONTROL_PARAMS_VER_1 MAKE_LWAPI_VERSION(LW_GPU_FAN_COOLER_CONTROL_PARAMS_V1, 1)
#define LW_GPU_FAN_COOLER_CONTROL_PARAMS_VER   LW_GPU_FAN_COOLER_CONTROL_PARAMS_VER_1
typedef LW_GPU_FAN_COOLER_CONTROL_PARAMS_V1    LW_GPU_FAN_COOLER_CONTROL_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_FanCoolerGetControl
//
//! DESCRIPTION:  This API returns control information of fan coolers on the
//!               given GPU.
//
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 319.xx
//! \param [in]  hPhysicalGpu      The physical GPU handle
//! \param [out] pFanCoolerControl Pointer to structure containing control
//!                                information about fan coolers.
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status.
//!          If there are return error codes with specific meaning for this API,
//!          they are listed below.
//! \ingroup gpufan
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_FanCoolerGetControl(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_FAN_COOLER_CONTROL_PARAMS *pFanCoolerControl);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_FanCoolerSetControl
//
//! DESCRIPTION:  This API sets control information of fan coolers on the
//!               given GPU.
//
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 319.xx
//! \param [in]  hPhysicalGpu      The physical GPU handle
//! \param [in] pFanCoolerControl Pointer to structure containing control
//!                                information about fan coolers.
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status.
//!          If there are return error codes with specific meaning for this API,
//!          they are listed below.
//! \ingroup gpufan
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_FanCoolerSetControl(__in LwPhysicalGpuHandle hPhysicalGpu, __in LW_GPU_FAN_COOLER_CONTROL_PARAMS *pFanCoolerControl);

//! \ingroup gpufan
//! @{

#define LW_GPU_FAN_POLICY_MAX_POLICIES_V1      32

/*!
 * Enumeration of Fan Policies. Unique identifiers for different Fan
 * Policies being enforced on the GPU.
 */
typedef enum _LW_GPU_FAN_POLICY_TYPE
{
    LW_GPU_FAN_POLICY_TYPE_IIR_TJ_FIXED_DUAL_SLOPE_PWM  = 0x00000000,
} LW_GPU_FAN_POLICY_TYPE;

/*!
 * Used in \ref LW_GPU_FAN_POLICY_INFO_V1. Structure representing 
 * static information associated with a IIR_TJ_FIXED_DUAL_SLOPE_PWM.
 */
typedef struct _LW_GPU_FAN_POLICY_INFO_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM
{
    /*!
     * Policy control selection.
     */
    LwU8  bUsePwm;
} LW_GPU_FAN_POLICY_INFO_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM;

/*!
 * Used in \ref LW_GPU_FAN_POLICIY_INFO_PARAMS_V1. Structure of static
 * information describing a FAN_POLICY, which specifies a fan policy to
 * enforce on the GPU.
 */
typedef struct _LW_GPU_FAN_POLICY_INFO_V1
{
    /*!
     * Fan policy type.
     */
    LW_GPU_FAN_POLICY_TYPE type;

    /*!
     * Index into the Fan Cooler Table.
     */
    LwU8 fanCoolerIndex;

    /*!
     * Sampling period. Units: milliseconds.
     */
    LwU16 fanSamplingPeriodms;

    /*!
     * Reserve bytes, so can add to the structure later w/o needed to add a new version.
     */
    LwU8 rsvd[32];

    /*!
     * Union of type-specific data. Interpreted based on \ref type value.
     */
    union
    {
        /*!
         * IIR_TJ_FIXED_DUAL_SLOPE_PWM FAN_POLICY
         */
        LW_GPU_FAN_POLICY_INFO_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM fanIIRTFDSP;

        /*!
        * Reserve bytes, so can add to the structure later w/o needed to add a new version.
        */
        LwU8 rsvd[32];
    }data;
} LW_GPU_FAN_POLICY_INFO_V1;

/*!
 * Used in \ref LwAPI_GPU_FanPolicyGetInfo.
 *
 * Describes the set of Fan Policies which are controlling GPU Fan.
 */
typedef struct _LW_GPU_FAN_POLICIY_INFO_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first.
     */
    LwU32 version;

    /*!
     * Mask of FAN_POLICY entries specified on this GPU.
     */
    LwU32 policyMask;

    /*!
     * Reserve bytes, so can add to the structure later w/o needed to add a new version.
     */
    LwU8 rsvd[32];

    /*!
     * Array of FAN_POLICY entries.  Has valid indexes corresponding to
     * the bits set in \ref policyMask.
     */
    LW_GPU_FAN_POLICY_INFO_V1
        policies[LW_GPU_FAN_POLICY_MAX_POLICIES_V1];
} LW_GPU_FAN_POLICIY_INFO_PARAMS_V1;

#define LW_GPU_FAN_POLICY_INFO_PARAMS_VER_1 MAKE_LWAPI_VERSION(LW_GPU_FAN_POLICIY_INFO_PARAMS_V1,1)
#define LW_GPU_FAN_POLICY_INFO_PARAMS_VER   LW_GPU_FAN_POLICY_INFO_PARAMS_VER_1

typedef LW_GPU_FAN_POLICIY_INFO_PARAMS_V1   LW_GPU_FAN_POLICY_INFO_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_FanPolicyGetInfo()
//
//! DESCRIPTION: Retrieves information about the FAN_POLICY support on the
//!              GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 319
//!
//! \param [in]  hPhysicalGPU   GPU selection
//! \param [out] pFanPolicyInfo Structure containing the description of FAN_POLICYs.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpufan
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_FanPolicyGetInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_FAN_POLICY_INFO_PARAMS *pFanPolicyInfo);

//! \ingroup gpufan
//! @{

/*!
 * Used in \ref LW_GPU_FAN_POLICY_STATUS_V1. Structure representing the 
 * dynamic state associated with a IIR_TJ_FIXED_DUAL_SLOPE_PWM FAN_POLICY.
 */
typedef struct _LW_GPU_FAN_POLICY_STATUS_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM
{
    /*!
     * Current Short Term Average Temperature (C).
     * Format: Signed Fixed Point Integer 10.22
     */
    LwS32  fanTjAvgShortTerm;

    /*!
     * Current Long Term Average Temperature (C).
     * Format: Signed Fixed Point Integer 10.22
     */
    LwS32  fanTjAvgLongTerm;

    /*!
     * Target PWM (in percents), used when @ref INFO::bUsePwm is set.
     * Format: Unsigned Fixed Point Integer 16.16.
     */
    LwU32  targetPwm;

    /*!
     * Target RPM, used when @ref INFO::bUsePwm is not set.
     */
    LwU32  targetRpm;
} LW_GPU_FAN_POLICY_STATUS_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM;

/*!
 * Used in \ref LW_GPU_FAN_POLICY_STATUS_PARAMS_V1. Structure representing 
 * the dynamic state of FAN_POLICY.
 */
typedef struct _LW_GPU_FAN_POLICY_STATUS_V1
{
    /*!
     * Fan policy type.
     */
    LW_GPU_FAN_POLICY_TYPE type;

    /*!
     *Reserve bytes, so can add to the structure later w/o needed to add a new version.
     */
    LwU8  rsvd[32];

    /*!
     * Union of type-specific data. Interpreted based on \ref type value.
     */
    union
    {
        /*!
         * IIR_TJ_FIXED_DUAL_SLOPE_PWM FAN_POLICY
         */
        LW_GPU_FAN_POLICY_STATUS_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM  fanIIRTFDSP;

        /*!
         *Reserve bytes, so can add to the structure later w/o needed to add a new version.
        */
        LwU8  rsvd[24];
    }data;
} LW_GPU_FAN_POLICY_STATUS_V1;

/*!
 * Used in \ref LwAPI_GPU_FanPolicyGetStatus.
 *
 * Describes/specifies the current status of Fan Policies which
 * are controlling GPU fan.
 */
typedef struct _LW_GPU_FAN_POLICY_STATUS_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first.
     */
    LwU32 version;

    /*!
     * Mask of FAN_POLICY entries requested by the client.
     */
    LwU32 policyMask;

    /*!
     * Reserve bytes, so can add to the structure later w/o needed to add a new version.
     */
    LwU8  rsvd[32];

    /*!
     * Array of FAN_POLICY entries. Has valid indexes corresponding to
     * the bits set in \ref policyMask.
     */
    LW_GPU_FAN_POLICY_STATUS_V1
        policies[LW_GPU_FAN_POLICY_MAX_POLICIES_V1];
} LW_GPU_FAN_POLICY_STATUS_PARAMS_V1;

#define LW_GPU_FAN_POLICY_STATUS_PARAMS_VER_1 MAKE_LWAPI_VERSION(LW_GPU_FAN_POLICY_STATUS_PARAMS_V1,1)
#define LW_GPU_FAN_POLICY_STATUS_PARAMS_VER   LW_GPU_FAN_POLICY_STATUS_PARAMS_VER_1

typedef LW_GPU_FAN_POLICY_STATUS_PARAMS_V1    LW_GPU_FAN_POLICY_STATUS_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_FanPolicyGetStatus()
//
//! DESCRIPTION:     Retrieves the current dynamic state of a set of FAN_POLICY
//!                  entries on the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version:  319
//!
//! \param [in]      hPhysicalGPU       GPU selection
//! \param [in/out]  pFanPoliciesStatus Structure containing the state of a set of FAN_POLICYs.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpufan
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_FanPolicyGetStatus(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_FAN_POLICY_STATUS_PARAMS *pFanPoliciesStatus);

//! \ingroup gpufan
//! @{

#define LW_GPU_FAN_POLICY_IIR_TJ_FIXED_DUAL_SLOPE_PWM_FAN_LWRVE_PTS     3

/*!
 * Structure representing the control parameters associated with a
 * IIR_TJ_FIXED_DUAL_SLOPE_PWM FAN_POLICY.
 */
typedef struct _LW_GPU_FAN_POLICY_CONTROL_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM
{
    /*!
     * Minimum IIR Gain.
     * Format: Signed Fixed Point Integer 16.16
     */
    LwS32       fanIIRGainMin;

    /*!
     * Maximum IIR Gain.
     * Format: Signed Fixed Point Integer 16.16
     */
    LwS32       fanIIRGainMax;

    /*!
     * Short Term IIR Gain.
     * Format: Signed Fixed Point Integer 16.16
     */
    LwS32       fanIIRGainShortTerm;

    /*!
     * IIR Filter Power.
     */
    LwU8        fanIIRFilterPower;

    /*!
     * IIR Long Term Sampling Ratio.
     */
    LwU8        fanIIRLongTermSamplingRatio;

    /*!
     * IIR Filter Lower Width (C). Units: 1/256 C.
     * Format: Signed Fixed Point Integer 24.8
     */
    LwS32       fanIIRFilterWidthUpper;

    /*!
     * IIR Filter Upper Width (C). Units: 1/256 C.
     * Format: Signed Fixed Point Integer 24.8
     */
    LwS32       fanIIRFilterWidthLower;

    struct
    {
        /*!
         * Tj Fan Lwrve Point (C). Units: 1/256 C.
         * Format: Signed Fixed Point Integer 24.8
         */
        LwS32   fanTj;

        /*!
         * PWM Fan Lwrve Point. Units: percent.
         * Format: Unsigned Fixed Point Integer 16.16
         */
        LwU32   fanPwm;

        /*!
         * RPM Fan Lwrve Point.
         */
        LwU32   fanRpm;
    } fanLwrvePts[LW_GPU_FAN_POLICY_IIR_TJ_FIXED_DUAL_SLOPE_PWM_FAN_LWRVE_PTS];
} LW_GPU_FAN_POLICY_CONTROL_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM;

/*!
 * Used in \ref LW_GPU_FAN_POLICY_CONTROL_PARAMS_V1.  Structure repsenting the
 * control/policy parameters of a FAN_POLICY entry.
 */
typedef struct _LW_GPU_FAN_POLICY_CONTROL_V1
{
    /*!
     * LW_GPU_FAN_POLICY_TYPE_<xyz>.
     */
    LW_GPU_FAN_POLICY_TYPE type;

    /*!
     * Reserve bytes, so can add to the structure later w/o needed to add a new version
     */
    LwU8  rsvd[32];

     /*!
     * Union of type-specific data. Interpreted based on \ref type value.
     */
    union
    {
        /*!
         * IIR_TJ_FIXED_DUAL_SLOPE_PWM FAN_POLICY
         */
        LW_GPU_FAN_POLICY_CONTROL_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM  fanIIRTFDSP;

        /*!
         * Reserve bytes, so can add to the structure later w/o needed to add a new version
        */ 
        LwU8  rsvd[80];
    }data;
} LW_GPU_FAN_POLICY_CONTROL_V1;

/*!
 * Used in \ref LwAPI_GPU_FanPolicyGetControl, \ref LwAPI_GPU_FanPolicySetControl.
 * Structure representing the control/policy parameters associated with a set of
 * FAN_POLICY entries in the GPU's FAN_POLICY.
 */
typedef struct _LW_GPU_FAN_POLICY_CONTROL_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first.
     */
    LwU32 version;

     /*!
     * Mask of FAN_POLICY entries requested by the client.
     */
    LwU32 policyMask;

    /*!
     * Bit field specifying the set of values to retrieve
     * - default (1)
     * - lwrrently active (0).
     */
    LwU32                       retrieveDefault : 1;
    LwU32                       reservedField : 31;

    /*!
     * Reserve 32 bytes, so can add to the structure later w/o needed to add a new version.
     */
    LwU8  rsvd[32];

    /*!
     * Array of FAN_POLICY entries.  Has valid indexes corresponding to
     * the bits set in \ref policyMask.
     */
    LW_GPU_FAN_POLICY_CONTROL_V1
        policies[LW_GPU_FAN_POLICY_MAX_POLICIES_V1];
} LW_GPU_FAN_POLICY_CONTROL_PARAMS_V1;

#define LW_GPU_FAN_POLICY_CONTROL_PARAMS_VER_1  MAKE_LWAPI_VERSION(LW_GPU_FAN_POLICY_CONTROL_PARAMS_V1,1)
#define LW_GPU_FAN_POLICY_CONTROL_PARAMS_VER    LW_GPU_FAN_POLICY_CONTROL_PARAMS_VER_1

typedef LW_GPU_FAN_POLICY_CONTROL_PARAMS_V1     LW_GPU_FAN_POLICY_CONTROL_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_FanPolicyGetControl()
//
//! DESCRIPTION:     This function retrieves the current control/policy of a set
//!                  of FAN_POLICY entries in the RM's FAN_POLICY
//!                  functionality.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version:  319
//!
//! \param [in]      hPhysicalGPU    GPU selection
//! \param [in/out]  pFanPolicyControl
//!     Structure containing the current control/policy of a set of
//!     FAN_POLICY entries.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpufan
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_FanPolicyGetControl(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_FAN_POLICY_CONTROL_PARAMS *pFanPolicyControl);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_FanPolicySetControl()
//
//! DESCRIPTION:     This function requests the control/policy of a set
//!                  of FAN_POLICY entries in the RM's FAN_POLICY
//!                  functionality.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version:  319
//!
//! \param [in]      hPhysicalGPU    GPU selection
//! \param [in]      pFanPolicyControl
//!     Structure containing the requested control/policy of a set of
//!     FAN_POLICY entries.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpufan
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_FanPolicySetControl(__in LwPhysicalGpuHandle hPhysicalGpu, __in LW_GPU_FAN_POLICY_CONTROL_PARAMS *pFanPolicyControl);

//! \ingroup gpufan
//! @{

#define LW_GPU_FAN_TEST_MAX_TESTS_V1    32

/*!
 * Enumeration of Fan Tests. Unique identifiers for different Fan
 * Tests for Fan 2.0.
 */
typedef enum _LW_GPU_FAN_TEST_TYPE
{
    LW_GPU_FAN_TEST_TYPE_ILWALID       = 0x00000000,
    LW_GPU_FAN_TEST_TYPE_COOLER_SANITY = 0x00000001,
} LW_GPU_FAN_TEST_TYPE;

/*!
 * Used in \ref LW_GPU_FAN_TEST_INFO_V1. Structure representing 
 * static information associated with a COOLER_SANITY type.
 */
typedef struct _LW_GPU_FAN_TEST_INFO_DATA_COOLER_SANITY
{
    /*!
     * Fan Cooler table index.
     */
    LwU8    coolerTableIdx;

    /*!
     * Error tolerance in percentage.
     */
    LwU8    measurementTolerancePct;

    /*!
     * Colwergence Time in millisecond.
     */
    LwU16   colwergenceTimems;
} LW_GPU_FAN_TEST_INFO_DATA_COOLER_SANITY;

/*!
 * Used in \ref LW_GPU_FAN_TEST_INFO_PARAMS_V1. Structure of static
 * information describing a FAN_TEST, which is used for Fan 2.0 testing.
 */
typedef struct _LW_GPU_FAN_TEST_INFO_V1
{
    /*!
     * Fan Test type.
     */
    LW_GPU_FAN_TEST_TYPE type;

    /*!
     * Reserve bytes, so can add to the structure later w/o needed to add a new version.
     */
    LwU8 rsvd[32];

    /*!
     * Union of type-specific data. Interpreted based on \ref type value.
     */
    union
    {
        /*!
         * COOLER_SANITY test.
         */
        LW_GPU_FAN_TEST_INFO_DATA_COOLER_SANITY coolerSanity;

        /*!
        * Reserve bytes, so can add to the structure later w/o needed to add a new version.
        */
        LwU8 rsvd[32];
    }data;
} LW_GPU_FAN_TEST_INFO_V1;

/*!
 * Used in \ref LwAPI_GPU_FanTestGetInfo.
 *
 * Describes the set of Fan Tests which are used for test Fan 2.0
 */
typedef struct _LW_GPU_FAN_TEST_INFO_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first.
     */
    LwU32 version;

    /*!
     * Mask of FAN_TEST entries.
     */
    LwU32 testMask;

    /*!
     * Reserve bytes, so can add to the structure later w/o needed to add a new version.
     */
    LwU8 rsvd[32];

    /*!
     * Array of FAN_TEST entries.  Has valid indexes corresponding to
     * the bits set in \ref testMask.
     */
    LW_GPU_FAN_TEST_INFO_V1
        test[LW_GPU_FAN_TEST_MAX_TESTS_V1];
} LW_GPU_FAN_TEST_INFO_PARAMS_V1;

#define LW_GPU_FAN_TEST_INFO_PARAMS_VER_1   MAKE_LWAPI_VERSION(LW_GPU_FAN_TEST_INFO_PARAMS_V1,1)
#define LW_GPU_FAN_TEST_INFO_PARAMS_VER     LW_GPU_FAN_TEST_INFO_PARAMS_VER_1

typedef LW_GPU_FAN_TEST_INFO_PARAMS_V1      LW_GPU_FAN_TEST_INFO_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_FanTestGetInfo()
//
//! DESCRIPTION: Retrieves information about the FAN_TEST that are supported
//!              for Fan 2.0.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 319
//!
//! \param [in]  hPhysicalGPU   GPU selection
//! \param [out] pFanTestInfo   Structure containing the description of FAN_TESTs.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpufan
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_FanTestGetInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_FAN_TEST_INFO_PARAMS *pFanTestInfo);

//! \ingroup gputhermal
//! @{

#define LW_GPU_THERMAL_THERM_DEVICE_MAX_V1              32

/*!
 * Enumeration of Device class.
 */
typedef enum _LW_GPU_THERMAL_THERM_DEVICE_CLASS
{
    LW_GPU_THERMAL_THERM_DEVICE_CLASS_ILWALID      =   0x00,
    LW_GPU_THERMAL_THERM_DEVICE_CLASS_GPU_TSENSE   =   0x01,
    LW_GPU_THERMAL_THERM_DEVICE_CLASS_I2C_ADM1032  =   0x41,
    LW_GPU_THERMAL_THERM_DEVICE_CLASS_I2C_MAX6649  =   0x43,
    LW_GPU_THERMAL_THERM_DEVICE_CLASS_I2C_TMP411   =   0x44,
    LW_GPU_THERMAL_THERM_DEVICE_CLASS_I2C_ADT7461  =   0x45    
} LW_GPU_THERMAL_THERM_DEVICE_CLASS;

/*!
 * Structure of static information specific to I2C devices.
 */
typedef struct _LW_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C
{
    /*!
     * Specifies the I2C Device Index in the DCB I2C Devices Table.
     */
    LwU8        i2cDevIdx;
} LW_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C;

/*!
 * Structure of static information specific to I2C ADT7461 device.
 */
typedef struct _LW_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_ADT7461
{
    /*!
     * I2C Device information.
     */
     LW_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C   i2c;
} LW_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_ADT7461;

/*!
 * Structure of static information specific to I2C TMP411 device.
 */
typedef struct _LW_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_TMP411
{
    /*!
     * I2C Device information.
     */
     LW_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C   i2c;
} LW_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_TMP411;

/*!
 * Structure of static information specific to I2C MAX6649 device.
 */
typedef struct _LW_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_MAX6649
{
    /*!
     * I2C Device information.
     */
     LW_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C   i2c;
} LW_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_MAX6649;

/*!
 * Structure of static information specific to I2C ADM1032 device.
 */
typedef struct _LW_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_ADM1032
{
    /*!
     * I2C Device information.
     */
     LW_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C   i2c;
} LW_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_ADM1032;

/*!
 * Used in \ref LW_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_V1. Structure of static
 * information describing a THERM_DEVICE, which specifies a thermal device to
 * enforce on the GPU.
 */
typedef struct _LW_GPU_THERMAL_THERM_DEVICE_INFO_V1
{
    /*!
     * Thermal device class.
     */
    LW_GPU_THERMAL_THERM_DEVICE_CLASS devClass;

    /*!
     * Reserve 32 bytes, so can add to the structure later w/o 
     * needed to add a new version.
     */
    LwU8                              rsvd[32];

    /*!
     * Union of type-specific data. Interpreted based on 
     * \ref devClass value.
     */
    union
    {
        /*!
         * THERMAL_DEVICE_CLASS
         */        
        LW_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_ADM1032 adm1032;
        LW_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_MAX6649 max6649;
        LW_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_TMP411  tmp411;
        LW_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_ADT7461 adt7461;

        /*!
         * Reserve 16 bytes, so can add to the structure later w/o needed 
         * to add a new version.
         */
        LwU8 rsvd[16];
    } data;
} LW_GPU_THERMAL_THERM_DEVICE_INFO_V1;

/*!
 * Used in \ref LwAPI_GPU_ThermDeviceGetInfo.
 *
 * Describes the set of Therm Device which are controlling GPU.
 */
typedef struct _LW_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first.
     */
    LwU32 version;

    /*!
     * Mask of THERM_DEVICE entries specified on this GPU.
     */
    LwU32 deviceMask;

    /*!
     * Reserve 32 bytes, so can add to the structure later w/o 
     * needed to add a new version.
     */
    LwU8 rsvd[32];

    /*!
     * Array of THERM_DEVICE entries.  Has valid indexes corresponding to
     * the bits set in \ref deviceMask.
     */
    LW_GPU_THERMAL_THERM_DEVICE_INFO_V1
        device[LW_GPU_THERMAL_THERM_DEVICE_MAX_V1];
} LW_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_V1;

#define LW_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_VER_1 MAKE_LWAPI_VERSION(LW_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_V1,1)
#define LW_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_VER   LW_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_VER_1

typedef LW_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_V1    LW_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_ThermDeviceGetInfo()
//
//! DESCRIPTION: Retrieves information about the THERM_DEVICE support on the
//!              GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 331
//!
//! \param [in]  hPhysicalGPU   GPU selection
//! \param [out] pThermDeviceInfo Structure containing the description of THERM_DEVICEs.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ThermDeviceGetInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS *pThermDeviceInfo);

//! \ingroup gputhermal
//! @{

#define LW_GPU_THERMAL_THERM_CHANNEL_TYPE_MAX_TYPE_V1       0x05

/*!
 * Enumeration of Thermal Channel Classes
 */
typedef enum _LW_GPU_THERMAL_CHANNEL_CLASS
{
    LW_GPU_THERMAL_THERM_CHANNEL_CLASS_ILWALID = 0x00,
    LW_GPU_THERMAL_THERM_CHANNEL_CLASS_DEVICE
} LW_GPU_THERMAL_THERM_CHANNEL_CLASS;

/*!
 * Enumeration of Thernmal Channel. Unique identifiers for different Thermal
 * Channel being enforced on the GPU.
 */
typedef enum _LW_GPU_THERMAL_THERM_CHANNEL_TYPE
{
    LW_GPU_THERMAL_THERM_CHANNEL_TYPE_GPU_AVG = 0x00,
    LW_GPU_THERMAL_THERM_CHANNEL_TYPE_GPU_MAX,
    LW_GPU_THERMAL_THERM_CHANNEL_TYPE_BOARD,
    LW_GPU_THERMAL_THERM_CHANNEL_TYPE_MEMORY,
    LW_GPU_THERMAL_THERM_CHANNEL_TYPE_PWR_SUPPLY
} LW_GPU_THERMAL_THERM_CHANNEL_TYPE;

/*!
 * Enumeration of Channel's Relative Location.
 */
typedef enum _LW_GPU_THERMAL_THERM_CHANNEL_REL_LOC
{
    LW_GPU_THERMAL_THERM_CHANNEL_REL_LOC_INT = 0x00,
    LW_GPU_THERMAL_THERM_CHANNEL_REL_LOC_EXT
} LW_GPU_THERMAL_THERM_CHANNEL_REL_LOC;

/*!
 * Enumeration of Channel's target GPU.
 */
typedef enum _LW_GPU_THERMAL_THERM_CHANNEL_TGT_GPU
{
    LW_GPU_THERMAL_THERM_CHANNEL_TGT_GPU_0 = 0x00,
    LW_GPU_THERMAL_THERM_CHANNEL_TGT_GPU_1,
    LW_GPU_THERMAL_THERM_CHANNEL_TGT_GPU_2,
    LW_GPU_THERMAL_THERM_CHANNEL_TGT_GPU_3
} LW_GPU_THERMAL_THERM_CHANNEL_TGT_GPU;

/*!
 * Structure representing the attributes specific to THERM_CHANNEL_DEVICE.
 */
typedef struct _LW_GPU_THERMAL_THERM_CHANNEL_INFO_DATA_DEVICE
{
    /*!
     * Index into the Thermal Device Table for the THERM_DEVICE from which this
     * THERM_CHANNEL should query temperature value.
     */
    LwU8    thermDevIdx;

    /*!
     * Provider index to query temperature value.
     */
    LwU8    thermDevProvIdx;
} LW_GPU_THERMAL_THERM_CHANNEL_INFO_DATA_DEVICE;

/*!
 * Used in \ref LW_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_V1. Structure of static
 * information describing a THERM_CHANNEL, which specifies a thermal channel to
 * enforce on the GPU.
 */
typedef struct _LW_GPU_THERMAL_THERM_CHANNEL_INFO_V1
{
    /*!
     * Thermal Channel class.
     */
    LW_GPU_THERMAL_THERM_CHANNEL_CLASS   chClass;

    /*!
     * Thermal Channel type.
     */
    LW_GPU_THERMAL_THERM_CHANNEL_TYPE    chType;

    /*!
     * Thermal Channel type.
     */
    LW_GPU_THERMAL_THERM_CHANNEL_REL_LOC relLoc;

    /*!
     * Thermal Channel type.
     */
    LW_GPU_THERMAL_THERM_CHANNEL_TGT_GPU tgtGPU;

    /*!
     * Temperature scaling, this value is in SFXP24_8 format.
     */
    LwS32                                scaling;

    /*!
     * Temperature offset, this value is in SFXP24_8 format.
     */
    LwS32                                offset;

    /*!
     * Minimum temperature for a channel, this value is in SFXP24_8 format.
     */ 
    LwS32                                minTemp;

    /*!
     * Maximum temperature for a channel, this value is in SFXP24_8 format.
     */
    LwS32                                maxTemp;

    /*!
     * Temp sim capability of the channel.
     */
    LwU8                                 bIsTempSimSupported;

    /*!
     * @ref LW2080_CTRL_THERMAL_THERM_CHANNEL_FLAGS_CHANNEL_<xyz>.
     */
    LwU8                                 flags;

    /*!
     * Reserve 32 bytes, so can add to the structure later w/o 
     * needed to add a new version.
     */
    LwU8                                 rsvd[32];

    /*!
     * Union of type-specific data. Interpreted based on 
     * \ref chClass value.
     */
    union
    {
        /*!
         * DEVICE class data
         */
        LW_GPU_THERMAL_THERM_CHANNEL_INFO_DATA_DEVICE device;

        /*!
        * Reserve 16 bytes, so can add to the structure later w/o needed 
        * to add a new version.
        */
        LwU8 rsvd[16];
    } data;
} LW_GPU_THERMAL_THERM_CHANNEL_INFO_V1;

/*!
 * Used in \ref LwAPI_GPU_ThermChannelGetInfo.
 *
 * Describes the set of Therm Channel which are controlling GPU channel.
 */
typedef struct _LW_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first.
     */
    LwU32 version;

    /*!
     * Mask of THERM_CHANNEL entries specified on this GPU.
     */
    LwU32 channelMask;

    /*!
     * Reserve 32 bytes, so can add to the structure later w/o 
     * needed to add a new version.
     */
    LwU8 rsvd[32];

    /*!
     * Array of THERM_CHANNEL entries.  Has valid indexes corresponding to
     * the bits set in \ref channelMask.
     */
    LW_GPU_THERMAL_THERM_CHANNEL_INFO_V1
        channel[LW_GPU_THERMAL_THERM_CHANNEL_TYPE_MAX_TYPE_V1];
} LW_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_V1;

#define LW_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_VER_1 MAKE_LWAPI_VERSION(LW_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_V1,1)
#define LW_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_VER   LW_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_VER_1

typedef LW_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_V1    LW_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_ThermChannelGetInfo()
//
//! DESCRIPTION: Retrieves information about the THERM_CHANNEL support on the
//!              GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 331
//!
//! \param [in]  hPhysicalGPU   GPU selection
//! \param [out] pThermChannelInfo Structure containing the description of THERM_CHANNELs.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ThermChannelGetInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS *pThermChannelInfo);

//! \ingroup gputhermal
//! @{

/*!
 * Used in \ref LW_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_V1. Structure  
 * representing the dynamic state of THERM_CHANNEL.
 */
typedef struct _LW_GPU_THERMAL_THERM_CHANNEL_STATUS_V1
{
    /*!
     * Current temperature of the channel, this value is in SFXP24_8 format.
     */
    LwS32   lwrrentTemp;
} LW_GPU_THERMAL_THERM_CHANNEL_STATUS_V1;

/*!
 * Used in \ref LwAPI_GPU_ThermChannelGetStatus.
 *
 * Describes/specifies the current status of Therm Channel which
 * are controlling GPU channel.
 */
typedef struct _LW_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first.
     */
    LwU32 version;

    /*!
     * Mask of THERM_CHANNEL entries requested by the client.
     */
    LwU32 channelMask;

    /*!
     * Reserve 32 bytes, so can add to the structure later w/o needed 
     * to add a new version.
     */
    LwU8  rsvd[32];

    /*!
     * Array of THERM_CHANNEL entries. Has valid indexes corresponding to
     * the bits set in \ref channelMask.
     */
    LW_GPU_THERMAL_THERM_CHANNEL_STATUS_V1
        channel[LW_GPU_THERMAL_THERM_CHANNEL_TYPE_MAX_TYPE_V1];
} LW_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_V1;

#define LW_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_VER_1 MAKE_LWAPI_VERSION(LW_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_V1,1)
#define LW_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_VER   LW_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_VER_1

typedef LW_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_V1    LW_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_ThermChannelGetStatus()
//
//! DESCRIPTION:     Retrieves the current dynamic state of a set of THERM_CHANNEL
//!                  entries on the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version:  331
//!
//! \param [in]      hPhysicalGPU       GPU selection
//! \param [in/out]  pThermChannelStatus Structure containing the state of a set of THERM_CHANNELs.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ThermChannelGetStatus(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS *pThermChannelStatus);

//! \ingroup gputhermal
//! @{

/*!
 * Used in \ref LW_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_V1.
 * Structure repsenting the control/channel parameters of a 
 * THERM_CHANNEL entry.
 */
typedef struct _LW_GPU_THERMAL_THERM_CHANNEL_CONTROL_V1
{
    /*!
     * Reflects the state of current temperature override.
     */
    LwU8    bTempSimEnable;

    /*!
     * Override the current temperature.
     * Applicable only when @ref bTempSimEnable == LW_TRUE.
     * This value is in SFXP24_8 format.
     */
    LwS32   targetTemp;

    /*!
     * Reserve 32 bytes, so can add to the structure later w/o needed to add a new version
     */
    LwU8    rsvd[32];

} LW_GPU_THERMAL_THERM_CHANNEL_CONTROL_V1;

/*!
 * Used in \ref LwAPI_GPU_ThermChannelGetControl/LwAPI_GPU_ThermChannelSetControl. 
 * Structure representing the control/channel parameters associated with a  
 * set of THERM_CHANNEL entries in the GPU's THERM_CHANNEL.
 */
typedef struct _LW_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first.
     */
    LwU32   version;

     /*!
     * Mask of THERM_CHANNEL entries requested by the client.
     */
    LwU32   channelMask;

    /*!
     * Reserve 32 bytes, so can add to the structure later w/o needed 
     * to add a new version.
     */
    LwU8    rsvd[32];

    /*!
     * Array of THERM_CHANNEL entries.  Has valid indexes corresponding to
     * the bits set in \ref channelMask.
     */
    LW_GPU_THERMAL_THERM_CHANNEL_CONTROL_V1
        channel[LW_GPU_THERMAL_THERM_CHANNEL_TYPE_MAX_TYPE_V1];
} LW_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_V1;

#define LW_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_VER_1  MAKE_LWAPI_VERSION(LW_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_V1,1)
#define LW_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_VER    LW_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_VER_1

typedef LW_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_V1     LW_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_ThermChannelGetControl()
//
//! DESCRIPTION:     This function retrieves the current control/channel of a set
//!                  of THERM_CHANNEL entries in the RM's THERM_CHANNEL
//!                  functionality.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version:  331
//!
//! \param [in]      hPhysicalGPU    GPU selection
//! \param [in/out]  pThermChannelControl
//!     Structure containing the current control/channel of a set of
//!     THERM_CHANNEL entries.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ThermChannelGetControl(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS *pThermChannelControl);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_ThermChannelSetControl()
//
//! DESCRIPTION:     This function requests the control/channel of a set
//!                  of THERM_CHANNEL entries in the RM's THERM_CHANNEL
//!                  functionality.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version:  331
//!
//! \param [in]      hPhysicalGPU    GPU selection
//! \param [in]      pThermChannelControl
//!     Structure containing the requested control/channel of a set of
//!     THERM_CHANNEL entries.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_ThermChannelSetControl(__in LwPhysicalGpuHandle hPhysicalGpu, __in LW_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS *pThermChannelControl);



#define LWAPI_PMGR_VOLTAGE_REQUEST_CLIENT_PSTATE                      0x00
#define LWAPI_PMGR_VOLTAGE_REQUEST_CLIENT_GPC2CLK                     0x01
#define LWAPI_PMGR_VOLTAGE_REQUEST_CLIENT_PEX                         0x02
#define LWAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DP_HBR2_WAR_SOR0            0x03
#define LWAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DP_HBR2_WAR_SOR1            0x04
#define LWAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DP_HBR2_WAR_SOR2            0x05
#define LWAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DP_HBR2_WAR_SOR3            0x06
#define LWAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DP_HBR2_WAR_SOR(i)          (LWAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DP_HBR2_WAR_SOR0 + (i))
#define LWAPI_PMGR_VOLTAGE_REQUEST_CLIENT_EXISTING                    0xFF

#define LWAPI_PMGR_VOLTAGE_REQUEST_CLIENT_NUM_CLIENTS                 (LWAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DP_HBR2_WAR_SOR3 + 1)

typedef struct _LW_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_V1
{
    LwU32 version;

    LwS32 globalVoltageOffsetuV;  //!< Global voltage offset to be applied to final arbitrated target voltage.
                                  //!< This offset will be applied to the output of all clients' requests to the arbiter. 
                                  //!< This alters the value of the final arbitrated voltage.
    LwS32 clientVoltageOffsetsuV[LWAPI_PMGR_VOLTAGE_REQUEST_CLIENT_NUM_CLIENTS];
                                  //!< Array of voltage offsets per client, to be applied per client target voltage in uV. 
                                  //!< Each client gets its offset added to the output of all of its requests to the arbiter. 
                                  //!< This alters the value of the target voltage of only that client for which it is specified. 
}LW_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_V1;

#define LW_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_VER1     MAKE_LWAPI_VERSION(LW_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_V1, 1)
#define LW_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_VER      LW_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_VER1

typedef LW_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_V1       LW_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_GetPMGRVoltageRequestArbiterValues()
//
//! DESCRIPTION:     This function retrieves the voltage request arbiter values.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Version:  340
//!
//! \param [in]      hPhysicalGPU                 GPU selection
//! \param [in]      pVoltageRequestArbiterData   Pointer to the structure containing the data.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status.  If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetPMGRVoltageRequestArbiterValues(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA *pVoltageRequestArbiterData);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    LwAPI_GPU_SetPMGRVoltageRequestArbiterValues()
//
//! DESCRIPTION:     This function sets the voltage request arbiter values.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Version:  340
//!
//! \param [in]      hPhysicalGPU                 GPU selection
//! \param [in]      pVoltageRequestArbiterData   Pointer to the structure containing the data.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status.  If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetPMGRVoltageRequestArbiterValues(__in LwPhysicalGpuHandle hPhysicalGpu, __in LW_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA *pVoltageRequestArbiterData);


typedef enum _LW_VBIOS_SOURCE_TYPE
{
    LW_VBIOS_SRC_TYPE_UNSET                           = 0x00,
    LW_VBIOS_SRC_TYPE_NOT_FOUND                       = 0x01,
    LW_VBIOS_SRC_TYPE_REGISTRY                        = 0x02,
    LW_VBIOS_SRC_TYPE_SW                              = 0x03,
    LW_VBIOS_SRC_TYPE_GPUMGR_CACHE                    = 0x04,
    LW_VBIOS_SRC_TYPE_INSTANCE_MEMORY                 = 0x05,
    LW_VBIOS_SRC_TYPE_ACPI_ROM                        = 0x06,
    LW_VBIOS_SRC_TYPE_ROM                             = 0x07,
    LW_VBIOS_SRC_TYPE_SBIOS                           = 0x08
} LW_VBIOS_SOURCE_TYPE;

#define LW_BIOS_MAX_SUBIMAGES                           0x08

typedef struct _LW_VBIOS_SOURCE_INFO
{
    LwU8    status;

    LwU8    nImages;
    LwU8    bLastImage[LW_BIOS_MAX_SUBIMAGES];
    LwU32   offset[LW_BIOS_MAX_SUBIMAGES];
    LwU32   imageLength[LW_BIOS_MAX_SUBIMAGES];

    LwU32   superImageLength;
    LwU32   romSig;
    LwU32   pciDataSig;
} LW_VBIOS_SOURCE_INFO;

typedef struct _LW_VBIOS_EXTRACTION_INFO_V1
{
    LwU32   version;            //!< Structure version

    LW_VBIOS_SOURCE_TYPE      source;              //!< Source for the VBIOS image.
    LW_VBIOS_SOURCE_INFO      srcInfoReg;          //!< State for the registry.
    LW_VBIOS_SOURCE_INFO      srcInfoCachedVbios;  //!< State for the VBIOS cache
    LW_VBIOS_SOURCE_INFO      srcInfoInstanceMem;  //!< State for instance memory
    LW_VBIOS_SOURCE_INFO      srcInfoRom;          //!< State for the ROM.
    LW_VBIOS_SOURCE_INFO      srcInfoAcpiRom;      //!< State for the ACPI ROM.
    LW_VBIOS_SOURCE_INFO      srcInfoSbios;        //!< State for the SBIOS.
    LW_VBIOS_INFO_STATUS      statusExpansionRom;  //!< State of extraction for the expansion ROM.
} LW_VBIOS_EXTRACTION_INFO_V1;

typedef LW_VBIOS_EXTRACTION_INFO_V1    LW_VBIOS_EXTRACTION_INFO;

#define LW_VBIOS_EXTRACTION_INFO_VER1  MAKE_LWAPI_VERSION(LW_VBIOS_EXTRACTION_INFO_V1,1)
#define LW_VBIOS_EXTRACTION_INFO_VER   LW_VBIOS_EXTRACTION_INFO_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetVbiosExtractionInfo
//
//!  This function returns the VBIOS extraction information from this GPU.
//!
//! \param [in]      hPhysicalGPU                GPU selection
//! \param [out]     pLwapiVbiosExtractionInfo   VBIOS Extraction Info object retrieved from RM
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 340
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetVbiosExtractionInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_VBIOS_EXTRACTION_INFO *pLwapiVbiosExtractionInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetVbiosStatusString
//
//! DESCRIPTION: Colwerts an VBIOS status code into a string
//!
//! \param [in]      status (IN ) - A valid LW_VBIOS_INFO_STATUS status code
//! \param [out]     szDesc (OUT) - The corresponding error code string
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 340
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetVbiosStatusString(__in LW_VBIOS_INFO_STATUS status, __out LwAPI_ShortString szDesc);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_EnumLwidiaDisplayHandle
//
//! This function returns the handle of the LWPU display specified by the enum 
//!                index (thisEnum). The client should keep enumerating until it
//!                returns LWAPI_END_ENUMERATION.
//!
//!                Note: Display handles can get ilwalidated on a modeset, so the calling applications need to
//!                renum the handles after every modeset.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \param [in]  thisEnum      The index of the LWPU display.   
//! \param [out] pLwDispHandle Pointer to the LWPU display handle.
//!
//! \retval LWAPI_ILWALID_ARGUMENT        Either the handle pointer is NULL or enum index too big
//! \retval LWAPI_OK                      Return a valid LwDisplayHandle based on the enum index
//! \retval LWAPI_LWIDIA_DEVICE_NOT_FOUND No LWPU device found in the system
//! \retval LWAPI_END_ENUMERATION         No more display device to enumerate
//! \ingroup disphandle
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_EnumLwidiaDisplayHandle(LwU32 thisEnum, LwDisplayHandle *pLwDispHandle);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_EnumLwidiaUnAttachedDisplayHandle
//
//! This function returns the handle of the LWPU unattached display specified by the enum 
//!                index (thisEnum). The client should keep enumerating until it
//!                returns error.
//!                Note: Display handles can get ilwalidated on a modeset, so the calling applications need to
//!                renum the handles after every modeset.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \param [in]  thisEnum                  The index of the LWPU display.
//! \param [out] pLwUnAttachedDispHandle   Pointer to the LWPU display handle of the unattached display.
//!
//! \retval LWAPI_ILWALID_ARGUMENT         Either the handle pointer is NULL or enum index too big
//! \retval LWAPI_OK                       Return a valid LwDisplayHandle based on the enum index
//! \retval LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU device found in the system
//! \retval LWAPI_END_ENUMERATION          No more display device to enumerate.
//! \ingroup disphandle
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_EnumLwidiaUnAttachedDisplayHandle(LwU32 thisEnum, LwUnAttachedDisplayHandle *pLwUnAttachedDispHandle);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_CreateDisplayFromUnAttachedDisplay
//
//! This function colwerts the unattached display handle to an active attached display handle.
//!
//! At least one GPU must be present in the system and running an LWPU display driver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \retval LWAPI_ILWALID_ARGUMENT         hLwUnAttachedDisp is not valid or pLwDisplay is NULL.
//! \retval LWAPI_OK                       One or more handles were returned
//! \retval LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_CreateDisplayFromUnAttachedDisplay(LwUnAttachedDisplayHandle hLwUnAttachedDisp, LwDisplayHandle *pLwDisplay);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetAssociatedLWidiaDisplayHandle
//
//!  This function returns the handle of the LWPU display that is associated
//!  with the given display "name" (such as "\\.\DISPLAY1").
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \retval LWAPI_ILWALID_ARGUMENT         Either argument is NULL
//! \retval LWAPI_OK                      *pLwDispHandle is now valid
//! \retval LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU device maps to that display name
//! \ingroup disphandle
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetAssociatedLwidiaDisplayHandle(const char *szDisplayName, LwDisplayHandle *pLwDispHandle);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DISP_GetAssociatedUnAttachedLwidiaDisplayHandle
//
//!   DESCRIPTION: This function returns the handle of an unattached LWPU display that is 
//!                associated with the given display name (such as "\\DISPLAY1"). 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT          Either argument is NULL.
//! \retval ::LWAPI_OK                       *pLwUnAttachedDispHandle is now valid.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND   No LWPU device maps to that display name.
//!
//! \ingroup disphandle
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetAssociatedUnAttachedLwidiaDisplayHandle(const char *szDisplayName, LwUnAttachedDisplayHandle *pLwUnAttachedDispHandle);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetAssociatedLWidiaDisplayName
//
//!  For a given LWPU display handle, this function returns a string (such as "\\.\DISPLAY1") to identify the display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \retval LWAPI_ILWALID_ARGUMENT          Either argument is NULL
//! \retval LWAPI_OK                       *pLwDispHandle is now valid
//! \retval LWAPI_LWIDIA_DEVICE_NOT_FOUND   No LWPU device maps to that display name
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetAssociatedLwidiaDisplayName(LwDisplayHandle LwDispHandle, LwAPI_ShortString szDisplayName);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetUnAttachedAssociatedDisplayName
//
//!  This function returns the display name given, for example, "\\DISPLAY1", using the unattached LWPU display handle
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \retval LWAPI_ILWALID_ARGUMENT          Either argument is NULL
//! \retval LWAPI_OK                       *pLwDispHandle is now valid
//! \retval LWAPI_LWIDIA_DEVICE_NOT_FOUND   No LWPU device maps to that display name
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetUnAttachedAssociatedDisplayName(LwUnAttachedDisplayHandle hLwUnAttachedDisp, LwAPI_ShortString szDisplayName);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_EnableHWLwrsor
//
//!  This function enables hardware cursor support
//!
//! SUPPORTED OS:  Windows XP
//!
//!  
//!
//! \since Release: 80
//!
//! \return LWAPI_ERROR or LWAPI_OK
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_EnableHWLwrsor(LwDisplayHandle hLwDisplay);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DisableHWLwrsor
//
//! This function disables hardware cursor support
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 80
//!
//! \return  LWAPI_ERROR or LWAPI_OK
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DisableHWLwrsor(LwDisplayHandle hLwDisplay);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetVBlankCounter
//
//!  This function gets the V-blank counter
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \return LWAPI_ERROR or LWAPI_OK
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetVBlankCounter(LwDisplayHandle hLwDisplay, LwU32 *pCounter);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:  LwAPI_SetRefreshRateOverride
//
//!  This function overrides the refresh rate on the given display/outputsMask.
//!  The new refresh rate can be applied right away in this API call or deferred to be applied with the
//!  next OS modeset. The override is good for only one modeset (regardless whether it's deferred or immediate).
//!               
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 80
//!
//!  \param [in] hLwDisplay    The LWPU display handle. It can be LWAPI_DEFAULT_HANDLE or a handle
//!                           enumerated from LwAPI_EnumLWidiaDisplayHandle().
//!  \param [in] outputsMask  A set of bits that identify all target outputs which are associated with the LWPU 
//!                           display handle to apply the refresh rate override. When SLI is enabled, the
//!                           outputsMask only applies to the GPU that is driving the display output.
//!  \param [in] refreshRate  The override value. "0.0" means cancel the override.
//!  \param [in] bSetDeferred 
//!              - "0": Apply the refresh rate override immediately in this API call.\p
//!              - "1": Apply refresh rate at the next OS modeset.
//!
//!  \retval  LWAPI_ILWALID_ARGUMENT hLwDisplay or outputsMask is invalid
//!  \retval  LWAPI_OK               The refresh rate override is correct set
//!  \retval  LWAPI_ERROR            The operation failed
//!  \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetRefreshRateOverride(LwDisplayHandle hLwDisplay, LwU32 outputsMask, float refreshRate, LwU32 bSetDeferred);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetAssociatedDisplayOutputId
//
//! This function gets the active outputId associated with the display handle.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 90
//!
//! \param [in]  hLwDisplay  LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [out] outputId    The active display output ID associated with the selected display handle hLwDisplay.
//!                          The outputid will have only one bit set. In the case of Clone or Span mode, this will indicate the
//!                          display outputId of the primary display that the GPU is driving. See \ref handles.
//!
//! \retval  LWAPI_OK                      Call successful.
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND No LWPU GPU driving a display was found.
//! \retval  LWAPI_EXPECTED_DISPLAY_HANDLE hLwDisplay is not a valid display handle.
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetAssociatedDisplayOutputId(LwDisplayHandle hLwDisplay, LwU32 *pOutputId);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetAssociatedDisplayOutputIdEx
//
//!   DESCRIPTION: This API gets the active outputId associated with the display handle.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]  hLwDisplay   LWPU Display selection. It can be ::LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [out] outputId     The active display output ID associated with the selected display handle hLwDisplay.
//!                           The outputid will have only one bit set. In case of clone or span mode this indicates the display
//!                           outputId of the primary display that the GPU is driving.
//! \param [out] gpuId)       The gpu ID of the physical GPU associated with the selected display handle hLwDisplay.
//!
//! \retval ::LWAPI_OK                       Call successful.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found.
//! \retval ::LWAPI_EXPECTED_DISPLAY_HANDLE  hLwDisplay is not a valid display handle.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetAssociatedDisplayOutputIdEx(LwDisplayHandle hLwDisplay, LwU32 *pOutputId, LwU32 *pGpuId);







//! \ingroup dispcontrol
//! Used in LwAPI_GetDisplayPortInfo().
typedef struct
{
    LwU32               version;                     //!< Structure version
    LwU32               dpcd_ver;                    //!< DPCD version of the monitor
    LW_DP_LINK_RATE     maxLinkRate;                 //!< Maximum supported link rate
    LW_DP_LANE_COUNT    maxLaneCount;                //!< Maximum supported lane count
    LW_DP_LINK_RATE     lwrLinkRate;                 //!< Current link rate
    LW_DP_LANE_COUNT    lwrLaneCount;                //!< Current lane count
    LW_DP_COLOR_FORMAT  colorFormat;                 //!< Current color format
    LW_DP_DYNAMIC_RANGE dynamicRange;                //!< Dynamic range
    LW_DP_COLORIMETRY   colorimetry;                 //!< Ignored in RGB space
    LW_DP_BPC           bpc;                         //!< Current bit-per-component;
    LwU32               isDp                   : 1;  //!< If the monitor is driven by a DisplayPort 
    LwU32               isInternalDp           : 1;  //!< If the monitor is driven by an LW Dp transmitter
    LwU32               isColorCtrlSupported   : 1;  //!< If the color format change is supported
    LwU32               is6BPCSupported        : 1;  //!< If 6 bpc is supported
    LwU32               is8BPCSupported        : 1;  //!< If 8 bpc is supported    
    LwU32               is10BPCSupported       : 1;  //!< If 10 bpc is supported
    LwU32               is12BPCSupported       : 1;  //!< If 12 bpc is supported        
    LwU32               is16BPCSupported       : 1;  //!< If 16 bpc is supported
    LwU32               isYCrCb422Supported    : 1;  //!< If YCrCb422 is supported                                                  
    LwU32               isYCrCb444Supported    : 1;  //!< If YCrCb444 is supported
    
 } LW_DISPLAY_PORT_INFO; 

//! Macro for constructing the version field of LW_DISPLAY_PORT_INFO.
#define LW_DISPLAY_PORT_INFO_VER  MAKE_LWAPI_VERSION(LW_DISPLAY_PORT_INFO,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GetDisplayPortInfo
//
//! \fn LwAPI_GetDisplayPortInfo(__in_opt LwDisplayHandle hLwDisplay, __in LwU32 outputId, __inout LW_DISPLAY_PORT_INFO *pInfo)
//! DESCRIPTION:     This function returns the current DisplayPort-related information on the specified device (monitor).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//! \param [in]     hvDisplay     LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//!                               This parameter is ignored when the outputId is a LwAPI displayId.
//! \param [in]     outputId      This can either be the connection bit mask or the LwAPI displayId. When the legacy connection bit mask is passed, 
//!                               it should have exactly 1 bit set to indicate a single display. If it's "0" then the default outputId from 
//!                               LwAPI_GetAssociatedDisplayOutputId() will be used. See \ref handles.
//! \param [out]    pInfo         The DisplayPort information
//!
//! \retval         LWAPI_OK                Completed request
//! \retval         LWAPI_ERROR             Miscellaneous error oclwrred
//! \retval         LWAPI_ILWALID_ARGUMENT  Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
//! \ingroup        dispcontrol
LWAPI_INTERFACE LwAPI_GetDisplayPortInfo(__in_opt LwDisplayHandle hLwDisplay, __in LwU32 outputId, __inout LW_DISPLAY_PORT_INFO *pInfo);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SetDisplayPort
//
//! \fn LwAPI_SetDisplayPort(LwDisplayHandle hLwDisplay, LwU32 outputId, LW_DISPLAY_PORT_CONFIG *pCfg)
//! DESCRIPTION:     This function sets up DisplayPort-related configurations.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release:   165
//!
//! \param [in]       hLwDisplay  LWPU display handle. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated from
//!                               LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]       outputId    This display output ID, when it's "0" it means the default outputId generated from the return of
//!                               LwAPI_GetAssociatedDisplayOutputId(). See \ref handles.
//! \param [in]       pCfg        The display port config structure. If pCfg is NULL, it means to use the driver's default value to setup.
//!
//! \retval           LWAPI_OK                Completed request
//! \retval           LWAPI_ERROR             Miscellaneous error oclwrred
//! \retval           LWAPI_ILWALID_ARGUMENT  Invalid input parameter
///////////////////////////////////////////////////////////////////////////////


//! \ingroup dispcontrol
//! DisplayPort configuration settings - used in LwAPI_SetDisplayPort().
typedef struct
{
    LwU32               version;                     //!< Structure version - 2 is the latest
    LW_DP_LINK_RATE     linkRate;                    //!< Link rate
    LW_DP_LANE_COUNT    laneCount;                   //!< Lane count
    LW_DP_COLOR_FORMAT  colorFormat;                 //!< Color format to set
    LW_DP_DYNAMIC_RANGE dynamicRange;                //!< Dynamic range
    LW_DP_COLORIMETRY   colorimetry;                 //!< Ignored in RGB space
    LW_DP_BPC           bpc;                         //!< Bit-per-component
    LwU32               isHPD               : 1;     //!< If the control panel is making this call due to HPD
    LwU32               isSetDeferred       : 1;     //!< Requires an OS modeset to finalize the setup if set
    LwU32               isChromaLpfOff      : 1;     //!< Force the chroma low_pass_filter to be off
    LwU32               isDitherOff         : 1;     //!< Force to turn off dither
    LwU32               testLinkTrain       : 1;     //!< If testing mode, skip validation
    LwU32               testColorChange     : 1;     //!< If testing mode, skip validation

} LW_DISPLAY_PORT_CONFIG;

//! \addtogroup dispcontrol
//! @{
//! Macro for constructing the version field of LW_DISPLAY_PORT_CONFIG
#define LW_DISPLAY_PORT_CONFIG_VER   MAKE_LWAPI_VERSION(LW_DISPLAY_PORT_CONFIG,2)
//! Macro for constructing the version field of LW_DISPLAY_PORT_CONFIG
#define LW_DISPLAY_PORT_CONFIG_VER_1 MAKE_LWAPI_VERSION(LW_DISPLAY_PORT_CONFIG,1)
//! Macro for constructing the version field of LW_DISPLAY_PORT_CONFIG
#define LW_DISPLAY_PORT_CONFIG_VER_2 MAKE_LWAPI_VERSION(LW_DISPLAY_PORT_CONFIG,2)
//! @}


//! \ingroup          dispcontrol
LWAPI_INTERFACE LwAPI_SetDisplayPort(LwDisplayHandle hLwDisplay, LwU32 outputId, LW_DISPLAY_PORT_CONFIG *pCfg);







//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GetHDMISupportInfo
//
//! \fn LwAPI_GetHDMISupportInfo(__in_opt LwDisplayHandle hLwDisplay, __in LwU32 outputId, __inout LW_HDMI_SUPPORT_INFO *pInfo)
//!   This API returns the current infoframe data on the specified device(monitor).
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 95
//!
//! \param [in]  hvDisplay  LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//!                         This parameter is ignored when the outputId is a LwAPI displayId.
//! \param [in]  outputId   This can either be the connection bit mask or the LwAPI displayId. When the legacy connection bit mask is passed, 
//!                         it should have exactly 1 bit set to indicate a single display. If it's "0" then the default outputId from 
//!                         LwAPI_GetAssociatedDisplayOutputId() will be used. See \ref handles.
//! \param [out] pInfo      The monitor and GPU's HDMI support info
//!
//! \retval  LWAPI_OK                Completed request
//! \retval  LWAPI_ERROR             Miscellaneous error oclwrred
//! \retval  LWAPI_ILWALID_ARGUMENT  Invalid input parameter.
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dispcontrol
//! Used in LwAPI_GetHDMISupportInfo().
typedef struct
{
    LwU32      version;                     //!< Structure version
    LwU32      isGpuHDMICapable       : 1;  //!< If the GPU can handle HDMI
    LwU32      isMonUnderscanCapable  : 1;  //!< If the monitor supports underscan
    LwU32      isMonBasicAudioCapable : 1;  //!< If the monitor supports basic audio
    LwU32      isMonYCbCr444Capable   : 1;  //!< If YCbCr 4:4:4 is supported
    LwU32      isMonYCbCr422Capable   : 1;  //!< If YCbCr 4:2:2 is supported
    LwU32      isMonxvYCC601Capable   : 1;  //!< If xvYCC 601 is supported
    LwU32      isMonxvYCC709Capable   : 1;  //!< If xvYCC 709 is supported
    LwU32      isMonHDMI              : 1;  //!< If the monitor is HDMI (with IEEE's HDMI registry ID)
    LwU32      EDID861ExtRev;               //!< Revision number of the EDID 861 extension
 } LW_HDMI_SUPPORT_INFO; 


//! \ingroup dispcontrol
#define LW_HDMI_SUPPORT_INFO_VER  MAKE_LWAPI_VERSION(LW_HDMI_SUPPORT_INFO,1)



//! \ingroup dispcontrol
LWAPI_INTERFACE LwAPI_GetHDMISupportInfo(__in_opt LwDisplayHandle hLwDisplay, __in LwU32 outputId, __inout LW_HDMI_SUPPORT_INFO *pInfo);



//! \ingroup dispcontrol
//! @{

#define LWAPI_HDMI_STEREO_MAX_MODES 256 

//! See ::LW_HDMI_STEREO_MODE.
typedef enum 
{
    LW_HDMI_STEREO_3D_NONE                = 0x00,
    LW_STEREO_LWISION,
    LW_HDMI_STEREO_3D_FRAME_PACKING,
    LW_HDMI_STEREO_3D_FRAME_PACKING_INT,
    LW_HDMI_STEREO_3D_LINE_ALT,
    LW_HDMI_STEREO_3D_SIDE_BY_SIDE_FULL,
    LW_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_HORIZONTAIL_ODD_LEFT_ODD_RIGHT,
    LW_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_HORIZONTAIL_ODD_LEFT_EVEN_RIGHT,
    LW_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_HORIZONTAIL_EVEN_LEFT_ODD_RIGHT,
    LW_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_HORIZONTAIL_EVEN_LEFT_EVEN_RIGHT,
    LW_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_QUINLWX_ODD_LEFT_ODD_RIGHT,
    LW_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_QUINLWX_ODD_LEFT_EVEN_RIGHT,
    LW_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_QUINLWX_EVEN_LEFT_ODD_RIGHT,
    LW_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_QUINLWX_EVEN_LEFT_EVEN_RIGHT,
    LW_HDMI_STEREO_3D_FIELD_ALT,
    LW_HDMI_STEREO_3D_L_DEPTH,
    LW_HDMI_STEREO_3D_L_DEPTH_GFX,
    LW_HDMI_STEREO_3D_TOP_BOTTOM,
    LW_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_HORIZONTAIL,
    LW_HDMI_STEREO_3D_ANY                 = 0xff,

} LW_HDMI_STEREO_TYPE;

//! See ::LW_HDMI_STEREO_MODES_LIST_V1.
typedef struct
{
    LwU16 HVisible;                     //!< Horizontal visible (size of single visible surface)
    LwU16 VVisible;                     //!< Vertical visible   (size of single visible surface)
    LwU16 HActive;                      //!< Horizontal active  (active frame size - i.e. both right & left surfaces, plus any padding)
    LwU16 VActive ;                     //!< Vertical active    (active frame size - i.e. both right & left surfaces, plus any padding)
    LwU16 VActiveSpace[2];              //!< Vertical active space

    LwU16   rr;                         //!< The refresh rate

    LW_HDMI_STEREO_TYPE stereoType;     //!< HDMI Stereo type

} LW_HDMI_STEREO_MODE;

//! See LwAPI_DISP_EnumHDMIStereoModes().
typedef struct
{
    // IN
    LwU32    version;             //!< structure version
    LwU32    displayId;           //!< (IN)Monitor Identifier. Retrieved from LwAPI_SYS_GetDisplayIdFromGpuAndOutputId
    LwU16    enumIndex;           //!< (IN)mode index 0 = 1st HDMI stereo mode
    LwU16    count;               //!< (IN)the max number of modes to return
    LwU32    width;               //!< (IN)visible desktop width, only required when bMatchDimension is true to do optional resolution filtering
    LwU32    height;              //!< (IN)visible desktop height, only required when bMatchDimension is true to do optional resolution filtering
    LwU32    refreshRate;         //!< (IN)desktop refresh rate, only required when bMatchRR is true to do optional refreshrate filtering
    LwU32    bMatchDimension : 1; //!< (IN)if true, return modes that match specified dimensions (height/width)
    LwU32    bMatchRR : 1;        //!< (IN)if true, return modes that match specified refresh rates
    LwU32    bPassThroughMode:1;  //!< (IN)if true, return pass-through capable modes. If false, return modeset capable modes
    LwU32    reserved : 29;       //!< reserved. Must be 0
    // OUT
    LwU16   numberOfModes;        //!< (OUT)number of modes returned
    LW_HDMI_STEREO_MODE modeList[LWAPI_HDMI_STEREO_MAX_MODES];    //!<(OUT) mode list

} LW_HDMI_STEREO_MODES_LIST_V1;

typedef LW_HDMI_STEREO_MODES_LIST_V1 LW_HDMI_STEREO_MODES_LIST;
#define LW_HDMI_STEREO_MODES_LIST_VER1  MAKE_LWAPI_VERSION(LW_HDMI_STEREO_MODES_LIST_V1,1)
#define LW_HDMI_STEREO_MODES_LIST_VER    LW_HDMI_STEREO_MODES_LIST_VER1

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_EnumHDMIStereoModes
//
//! DESCRIPTION:     This API returns HDMI stereo modes supported by the specified monitor with indices between [enumIndex, enumIndex+count].
//!                  numberOfModes returned would be min(count, number of stereo modes available for the monitor).
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out]   pHDMIStereoModes  As input, it contains displayID and enumIndex. After successful return, it contains the HDMI stereo mode list.
//!                  
//! \retval ::LWAPI_OK                             Completed request
//! \retval ::LWAPI_END_ENUMERATION                No more entries
//! \retval ::LWAPI_ERROR                          Miscellaneous error oclwrred
//! \retval ::LWAPI_ILWALID_ARGUMENT               Invalid input parameter.
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION    LW_HDMI_STEREO_MODES_LIST structure version mismatch. see pHDMIStereoModes->version.
//! \retval ::LWAPI_ID_OUT_OF_RANGE                Incorrect displayId.
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_EnumHDMIStereoModes(LW_HDMI_STEREO_MODES_LIST *pHDMIStereoModes);

//! @}


//! \ingroup dispcontrol
typedef struct
{
    // IN
    LwU32    version;            //!< structure version
    LW_HDMI_STEREO_TYPE type;    //!< HDMI stereo type. This is for pass-through modes only, returned by LwAPI_DISP_EnumHDMIStereoModes by passing bPassThroughMode true
                                 //!< It can be enabled when it is already in 3D mode as the result of a modeset/dynamic engage and that 3D mode(Height/width/refreshrate) must be supported
                                 //!< Use LW_HDMI_STEREO_3D_NONE to disable
    LwU32    reserved;           //!< reserved

} LW_HDMI_STEREO_SETTINGS_V1;

//! \ingroup dispcontrol
typedef LW_HDMI_STEREO_SETTINGS_V1     LW_HDMI_STEREO_SETTINGS;

//! \ingroup dispcontrol
#define LW_HDMI_STEREO_SETTINGS_VER1   MAKE_LWAPI_VERSION(LW_HDMI_STEREO_SETTINGS_V1,1)

//! \ingroup dispcontrol
#define LW_HDMI_STEREO_SETTINGS_VER    LW_HDMI_STEREO_SETTINGS_VER1

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_SetHDMIStereoSettings
//
//! DESCRIPTION:     This API applies the HDMI stereo settings.
//!                  Lwrrently it is used to set pass-through HDMI modes by specifying LW_HDMI_STEREO_TYPE.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      displayId           Monitor Identifier
//! \param [in]      hdmiStereoSettings  LW_HDMI_STEREO_SETTINGS that needs to be applied
//!
//! \retval ::LWAPI_OK  completed request
//! \retval ::LWAPI_ERROR  miscellaneous error oclwrred
//! \retval ::LWAPI_ILWALID_ARGUMENT  Invalid input parameter.
//! \retval ::LWAPI_ID_OUT_OF_RANGE  Incorrect displayId.
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  if LW_HDMI_STEREO_SETTINGS structure version mismatches.
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_SetHDMIStereoSettings(LwU32 displayId, LW_HDMI_STEREO_SETTINGS *hdmiStereoSettings);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_GetHDMIStereoSettings
//
//! DESCRIPTION:     This API returns the current HDMI stereo settings.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in]      displayId           Monitor Identifier
//! \param [in]      hdmiStereoSettings  LW_HDMI_STEREO_SETTINGS -it contains current applied settings on successful return of API
//!
//! \retval ::LWAPI_OK  completed request
//! \retval ::LWAPI_ERROR  miscellaneous error oclwrred
//! \retval ::LWAPI_ILWALID_ARGUMENT  Invalid input parameter.
//! \retval ::LWAPI_ILWALID_POINTER   An invalid pointer was passed as an argument (probably NULL).
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  if LW_HDMI_STEREO_SETTINGS structure version mismatches.
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetHDMIStereoSettings(LwU32 displayId, LW_HDMI_STEREO_SETTINGS *hdmiStereoSettings);









//! \ingroup dispcontrol
//! Use in LwAPI_GetInfoFrame(), LwAPI_SetInfoFrame(), LwAPI_GetInfoFrameState(), and LwAPI_SetInfoFrameState().
typedef enum _LW_INFOFRAME_TYPE
{
    LW_INFOFRAME_TYPE_AVI   = 2,
    LW_INFOFRAME_TYPE_SPD   = 3,
    LW_INFOFRAME_TYPE_AUDIO = 4,
    LW_INFOFRAME_TYPE_MS    = 5,
} LW_INFOFRAME_TYPE;


//! Used in \ref LW_INFOFRAME
//! \ingroup dispcontrol
typedef struct
{
    LwU8 type;
    LwU8 version;
    LwU8 length;
} LW_INFOFRAME_HEADER;

//! Since this is for Windows OS so far, we use this bit little endian definition
//! to handle the translation.
//! Used in \ref LW_INFOFRAME
//! \ingroup dispcontrol
typedef struct
{
    // byte 1
    LwU8 channelCount     : 3;
    LwU8 rsvd_bits_byte1  : 1;
    LwU8 codingType       : 4;

    // byte 2
    LwU8 sampleSize       : 2;
    LwU8 sampleRate       : 3;
    LwU8 rsvd_bits_byte2  : 3;

    // byte 3
    LwU8 codingExtensionType  : 5;
    LwU8 rsvd_bits_byte3      : 3;


    // byte 4
    LwU8  speakerPlacement;

    // byte 5
    LwU8 lfePlaybackLevel     : 2;
    LwU8 rsvd_bits_byte5      : 1;
    LwU8 levelShift           : 4;
    LwU8 downmixInhibit       : 1;

    // byte 6~10
    LwU8 rsvd_byte6;
    LwU8 rsvd_byte7;
    LwU8 rsvd_byte8;
    LwU8 rsvd_byte9;
    LwU8 rsvd_byte10;

}LW_AUDIO_INFOFRAME;


//! Used in \ref LW_INFOFRAME
//! \ingroup dispcontrol
typedef struct
{
    // byte 1
    LwU8 scanInfo                : 2;
    LwU8 barInfo                 : 2;
    LwU8 activeFormatInfoPresent : 1;
    LwU8 colorSpace              : 2;
    LwU8 rsvd_bits_byte1         : 1;

    // byte 2
    LwU8 activeFormatAspectRatio : 4;
    LwU8 picAspectRatio          : 2;
    LwU8 colorimetry             : 2;

    // byte 3
    LwU8 nonuniformScaling       : 2;
    LwU8 rgbQuantizationRange    : 2;
    LwU8 extendedColorimetry     : 3;
    LwU8 itContent               : 1;

    // byte 4
    LwU8 vic                     : 7;
    LwU8 rsvd_bits_byte4         : 1;

    // byte 5
    LwU8 pixelRepeat             : 4;
    LwU8 contentTypes            : 2;
    LwU8 yccQuantizationRange    : 2;

    // byte 6~13 
    LwU8 topBarLow;
    LwU8 topBarHigh;
    LwU8 bottomBarLow;
    LwU8 bottomBarHigh;
    LwU8 leftBarLow;
    LwU8 leftBarHigh;
    LwU8 rightBarLow;
    LwU8 rightBarHigh;

} LW_VIDEO_INFOFRAME;

//! \ingroup dispcontrol
//! \sa LwAPI_GetInfoFrame(); LwAPI_SetInfoFrame
typedef struct
{
    LW_INFOFRAME_HEADER    header;
    union
    {
        LW_AUDIO_INFOFRAME audio;
        LW_VIDEO_INFOFRAME video;
    }u;
} LW_INFOFRAME;

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_GetInfoFrame
//
//! DESCRIPTION: This API returns the current infoframe data on the specified device(monitor).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [in] hLwDisplay      LWPU Display selection. It can be #LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in] displayId       If Display Id is passed then hLwDisplay need not be specified. 
//!                             If output Id is passed then hLwDisplay needs to be specified. 
//!                             If the value passed is "0" then the default outputId from LwAPI_GetAssociatedDisplayOutputId() will be used. See \ref handles.
//! \param [in] type            The type of infoframe to get. See LW_INFOFRAME_TYPE .
//! \param [out] pInfoFrame     Pointer to the The infoframe data.
//!
//! \return    This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetInfoFrame(__in LwDisplayHandle hLwDisplay, __in LwU32 displayId, __in LW_INFOFRAME_TYPE type, __out LW_INFOFRAME *pInfoFrame);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_SetInfoFrame
//
//! DESCRIPTION: This API returns the current infoframe data on the specified device(monitor).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [in]  hLwDisplay     LWPU Display selection. It can be #LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in] displayId       If Display Id is passed then hLwDisplay need not be specified. 
//!                             If output Id is passed then hLwDisplay needs to be specified. 
//!                             If the value passed is "0" then the default outputId from LwAPI_GetAssociatedDisplayOutputId() will be used. See \ref handles.
//! \param [in]  type           The type of infoframe to set. See LW_INFOFRAME_TYPE .
//! \param [in]  pInfoFrame     Pointer to the The infoframe data. NULL means reset to the default value.
//!
//! \return    This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetInfoFrame(__in LwDisplayHandle hLwDisplay, __in LwU32 displayId, __in LW_INFOFRAME_TYPE type, __in LW_INFOFRAME *pInfoFrame);



//! ingroup dispcontrol
//! Used in LwAPI_SetInfoFrameState() and LwAPI_GetInfoFrameState().
typedef struct _LW_INFOFRAME_STATE
{
    LwU32 bDisabled    :    1;       //!< Enable or disable the infoframe when "bDriverCtrl" is 0.
    LwU32 bDriverCtrl  :    1;       //!< If set, let the driver control the infoframe state and ignore "bDisabled".
    LwU32 reserved     :   30;

} LW_INFOFRAME_STATE;

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SetInfoFrameState
//
//! DESCRIPTION:    This API disables or enables the sending of infoframe packets. Lwrrently, this is supported for audio packets only.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 177
//!
//! \param [in] hLwDisplay   LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in] displayId    If Display Id is passed then hLwDisplay need not be specified. 
//!                          If output Id is passed then hLwDisplay needs to be specified. 
//!                          If the value passed is "0" then the default outputId from LwAPI_GetAssociatedDisplayOutputId() will be used. See \ref handles.
//! \param [in] type         The type of infoframe to set
//! \param [in] state        state of infoframe to set
//!
//! \return    This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetInfoFrameState(__in LwDisplayHandle hLwDisplay, __in LwU32 displayId, __in LW_INFOFRAME_TYPE type, __in LW_INFOFRAME_STATE *pState);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GetInfoFrameState
//
//! DESCRIPTION:    This API gets the state of the infoframe. Lwrrently, this is supported for audio packets only.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 177
//!
//! \param [in]     hLwDisplay  LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]     displayId   If Display Id is passed then hLwDisplay need not be specified. 
//!                             If output Id is passed then hLwDisplay needs to be specified. 
//!                             If the value passed is "0" then the default outputId from LwAPI_GetAssociatedDisplayOutputId() will be used. See \ref handles.
//! \param [in]     type        The type of infoframe of which to get the state
//! \param [out]    state       State of the infoframe
//!
//! \return    This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetInfoFrameState(__in LwDisplayHandle hLwDisplay, __in LwU32 displayId, __in LW_INFOFRAME_TYPE type, __out LW_INFOFRAME_STATE *pState);


//! \ingroup dispcontrol
//! Used in LwAPI_GetInfoFrameStatePvt().
typedef struct _LW_INFOFRAME_STATE_PVT
{
    LW_INFOFRAME_STATE  state;
    LwU32 bInHDMIBlackList :    1;   //!< Ready only. Indicates if the monitor is in the driver's HDMI black list.
    LwU32 reserved         :   31;
} LW_INFOFRAME_STATE_PVT;


//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dispcontrol
LWAPI_INTERFACE LwAPI_GetInfoFrameStatePvt(__in LwDisplayHandle hLwDisplay, __in LwU32 displayId, __in LW_INFOFRAME_TYPE type, __out LW_INFOFRAME_STATE_PVT *pState);


//! \ingroup dispcontrol

typedef enum
{
    LW_INFOFRAME_CMD_GET_DEFAULT = 0,     //!< Returns the fields in the infoframe with values set by the manufacturer - LWPU/OEM.
    LW_INFOFRAME_CMD_RESET,               //!< Sets the fields in the infoframe to auto, and infoframe to the default infoframe for use in a set.    
    LW_INFOFRAME_CMD_GET,                 //!< Get the current infoframe state.
    LW_INFOFRAME_CMD_SET,                 //!< Set the current infoframe state (flushed to the monitor), the values are one time and do not persist.
    LW_INFOFRAME_CMD_GET_OVERRIDE,        //!< Get the override infoframe state, non-override fields will be set to value = AUTO, overridden fields will have the current override values.
    LW_INFOFRAME_CMD_SET_OVERRIDE,        //!< Set the override infoframe state, non-override fields will be set to value = AUTO, other values indicate override; persist across modeset/reboot
    LW_INFOFRAME_CMD_GET_PROPERTY,        //!< get properties associated with infoframe (each of the infoframe type will have properties)
    LW_INFOFRAME_CMD_SET_PROPERTY,        //!< set properties associated with infoframe
} LW_INFOFRAME_CMD;


typedef enum
{
    LW_INFOFRAME_PROPERTY_MODE_AUTO           = 0, //!< Driver determines whether to send infoframes.
    LW_INFOFRAME_PROPERTY_MODE_ENABLE,             //!< Driver always sends infoframe.
    LW_INFOFRAME_PROPERTY_MODE_DISABLE,            //!< Driver never sends infoframe.
    LW_INFOFRAME_PROPERTY_MODE_ALLOW_OVERRIDE,     //!< Driver only sends infoframe when client requests it via infoframe escape call.
} LW_INFOFRAME_PROPERTY_MODE;


//! Returns whether the current monitor is in blacklist or force this monitor to be in blacklist.
typedef enum
{
    LW_INFOFRAME_PROPERTY_BLACKLIST_FALSE = 0,
    LW_INFOFRAME_PROPERTY_BLACKLIST_TRUE,
} LW_INFOFRAME_PROPERTY_BLACKLIST;

typedef struct
{
    LwU32 mode      :  4;
    LwU32 blackList :  2;
    LwU32 reserved  : 10;
    LwU32 version   :  8;
    LwU32 length    :  8;
} LW_INFOFRAME_PROPERTY;

//! Byte1 related
typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_NODATA    = 0,
    LW_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_OVERSCAN,
    LW_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_UNDERSCAN,
    LW_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_FUTURE,
    LW_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_AUTO      = 7
} LW_INFOFRAME_FIELD_VALUE_AVI_SCANINFO;


typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AVI_BARDATA_NOT_PRESENT         = 0,
    LW_INFOFRAME_FIELD_VALUE_AVI_BARDATA_VERTICAL_PRESENT,
    LW_INFOFRAME_FIELD_VALUE_AVI_BARDATA_HORIZONTAL_PRESENT,
    LW_INFOFRAME_FIELD_VALUE_AVI_BARDATA_BOTH_PRESENT,
    LW_INFOFRAME_FIELD_VALUE_AVI_BARDATA_AUTO                = 7
} LW_INFOFRAME_FIELD_VALUE_AVI_BARDATA;

typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AVI_AFI_ABSENT   = 0,
    LW_INFOFRAME_FIELD_VALUE_AVI_AFI_PRESENT,
    LW_INFOFRAME_FIELD_VALUE_AVI_AFI_AUTO     = 3
} LW_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO;


typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_RGB      = 0,
    LW_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_YCbCr422,
    LW_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_YCbCr444,
    LW_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_FUTURE,
    LW_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_AUTO     = 7
} LW_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT;

typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AVI_F17_FALSE = 0,
    LW_INFOFRAME_FIELD_VALUE_AVI_F17_TRUE,
    LW_INFOFRAME_FIELD_VALUE_AVI_F17_AUTO = 3
} LW_INFOFRAME_FIELD_VALUE_AVI_F17;

//! Byte2 related
typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NO_AFD           = 0,
    LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE01,
    LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE02,
    LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE03,
    LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_LETTERBOX_GT16x9,
    LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE05,
    LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE06,
    LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE07,
    LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_EQUAL_CODEDFRAME = 8,
    LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_CENTER_4x3,
    LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_CENTER_16x9,
    LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_CENTER_14x9,
    LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE12,
    LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_4x3_ON_14x9,
    LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_16x9_ON_14x9,
    LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_16x9_ON_4x3,
    LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_AUTO             = 31,
} LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION;


typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_NO_DATA = 0,
    LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_4x3,
    LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_16x9,
    LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_FUTURE,
    LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_AUTO    = 7
} LW_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME;

typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_NO_DATA                   = 0,
    LW_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_SMPTE_170M,
    LW_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_ITUR_BT709,
    LW_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_USE_EXTENDED_COLORIMETRY,
    LW_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_AUTO                      = 7
} LW_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY;

//! Byte 3 related
typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_NO_DATA    = 0,
    LW_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_HORIZONTAL,
    LW_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_VERTICAL,
    LW_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_BOTH,
    LW_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_AUTO       = 7
} LW_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING;

typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_DEFAULT       = 0,
    LW_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_LIMITED_RANGE,
    LW_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_FULL_RANGE,
    LW_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_RESERVED,
    LW_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_AUTO          = 7
} LW_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION;

typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_XVYCC601     = 0,
    LW_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_XVYCC709,
    LW_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_SYCC601,
    LW_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_ADOBEYCC601,
    LW_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_ADOBERGB,
    LW_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_RESERVED05,
    LW_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_RESERVED06,
    LW_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_RESERVED07,
    LW_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_AUTO         = 15
} LW_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY;

typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AVI_ITC_VIDEO_CONTENT = 0,
    LW_INFOFRAME_FIELD_VALUE_AVI_ITC_ITCONTENT,
    LW_INFOFRAME_FIELD_VALUE_AVI_ITC_AUTO          = 3
} LW_INFOFRAME_FIELD_VALUE_AVI_ITC;

//! Byte 4 related
typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NONE = 0,
    LW_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X02,
    LW_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X03,
    LW_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X04,
    LW_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X05,
    LW_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X06,
    LW_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X07,
    LW_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X08,
    LW_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X09,
    LW_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X10,
    LW_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED10,
    LW_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED11,
    LW_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED12,
    LW_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED13,
    LW_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED14,
    LW_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED15,
    LW_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_AUTO         = 31
} LW_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION;


typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_GRAPHICS = 0,
    LW_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_PHOTO,
    LW_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_CINEMA,
    LW_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_GAME,
    LW_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_AUTO     = 7
} LW_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE;

typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_LIMITED_RANGE = 0,
    LW_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_FULL_RANGE,
    LW_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_RESERVED02,
    LW_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_RESERVED03,
    LW_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_AUTO          = 7
} LW_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION;

//! Adding an Auto bit to each field
typedef struct
{
    LwU32 vic                     : 8;
    LwU32 pixelRepeat             : 5;
    LwU32 colorSpace              : 3;
    LwU32 colorimetry             : 3;
    LwU32 extendedColorimetry     : 4;
    LwU32 rgbQuantizationRange    : 3;
    LwU32 yccQuantizationRange    : 3;
    LwU32 itContent               : 2;
    LwU32 contentTypes            : 3;
    LwU32 scanInfo                : 3;
    LwU32 activeFormatInfoPresent : 2;
    LwU32 activeFormatAspectRatio : 5;
    LwU32 picAspectRatio          : 3;
    LwU32 nonuniformScaling       : 3;
    LwU32 barInfo                 : 3;    
    LwU32 top_bar                 : 17;
    LwU32 bottom_bar              : 17;
    LwU32 left_bar                : 17;
    LwU32 right_bar               : 17;
    LwU32 Future17                : 2;
    LwU32 Future47                : 2;
} LW_INFOFRAME_VIDEO;

//! Byte 1 related
typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_IN_HEADER = 0,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_2,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_3,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_4,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_5,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_6,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_7,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_8,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_AUTO      = 15
} LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT;

typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_IN_HEADER                  = 0,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_PCM,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_AC3,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MPEG1,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MP3,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MPEG2,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_AACLC,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DTS,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_ATRAC,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DSD,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_EAC3,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DTSHD,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MLP,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DST,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_WMAPRO,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_USE_CODING_EXTENSION_TYPE,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_AUTO                      = 31
} LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE;

//! Byte 2 related
typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_IN_HEADER = 0,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_16BITS,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_20BITS,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_24BITS,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_AUTO      = 7
} LW_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE;

typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_IN_HEADER = 0,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_32000HZ,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_44100HZ,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_48000HZ,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_88200KHZ,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_96000KHZ,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_176400KHZ,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_192000KHZ,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_AUTO      = 15
} LW_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY;



//! Byte 3 related
typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_USE_CODING_TYPE = 0,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_HEAAC,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_HEAACV2,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_MPEGSURROUND,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE04,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE05,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE06,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE07,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE08,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE09,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE10,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE11,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE12,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE13,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE14,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE15,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE16,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE17,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE18,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE19,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE20,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE21,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE22,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE23,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE24,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE25,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE26,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE27,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE28,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE29,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE30,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE31,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_AUTO           = 63
} LW_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE;


//! Byte 4 related
typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_X_X_FR_FL           =0,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_X_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_FC_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_FC_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_X_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_X_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_FC_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_FC_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_X_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_X_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_FC_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_FC_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_X_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_X_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_FC_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_FC_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_X_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_X_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_FC_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_FC_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_X_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_X_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_FC_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_FC_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_X_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_X_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_FC_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_FC_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_X_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_X_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_FC_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_FC_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_FCH_RR_RL_FC_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_FCH_RR_RL_FC_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_X_RR_RL_FC_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_X_RR_RL_FC_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_X_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_X_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_X_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_X_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_RC_RR_RL_FC_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_RC_RR_RL_FC_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FCH_RC_RR_RL_FC_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FCH_RC_RR_RL_FC_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_FCH_RR_RL_FC_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_FCH_RR_RL_FC_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_FC_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_FC_LFE_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_FC_X_FR_FL,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_FC_LFE_FR_FL  = 0X31,
    // all other values should default to auto
    LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_AUTO                        = 0x1FF
} LW_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION;

//! Byte 5 related
typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_NO_DATA    = 0,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_0DB,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_PLUS10DB,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_RESERVED03,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_AUTO       = 7
} LW_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL;

typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_0DB  = 0,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_1DB,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_2DB,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_3DB,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_4DB,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_5DB,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_6DB,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_7DB,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_8DB,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_9DB,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_10DB,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_11DB,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_12DB,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_13DB,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_14DB,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_15DB,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_AUTO = 31
} LW_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES;


typedef enum
{
    LW_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_PERMITTED  = 0,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_PROHIBITED,
    LW_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_AUTO       = 3
} LW_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX;

typedef struct
{
    LwU32 codingType          : 5;
    LwU32 codingExtensionType : 6;
    LwU32 sampleSize          : 3;
    LwU32 sampleRate          : 4;
    LwU32 channelCount        : 4;
    LwU32 speakerPlacement    : 9;
    LwU32 downmixInhibit      : 2;
    LwU32 lfePlaybackLevel    : 3;
    LwU32 levelShift          : 5; 
    LwU32 Future12            : 2;
    LwU32 Future2x            : 4;
    LwU32 Future3x            : 4;
    LwU32 Future52            : 2;
    LwU32 Future6             : 9;
    LwU32 Future7             : 9;
    LwU32 Future8             : 9;
    LwU32 Future9             : 9;
    LwU32 Future10            : 9;
} LW_INFOFRAME_AUDIO;

typedef struct
{
    LwU32 version; //!< version of this structure
    LwU16 size;    //!< size of this structure
    LwU8  cmd;     //!< The actions to perform from LW_INFOFRAME_CMD
    LwU8  type;    //!< type of infoframe
    
    union
    {
        LW_INFOFRAME_PROPERTY     property;  //!< This is LWPU-specific and corresponds to the property cmds and associated infoframe.
        LW_INFOFRAME_AUDIO        audio;
        LW_INFOFRAME_VIDEO        video;
    } infoframe;
} LW_INFOFRAME_DATA;

//! Macro for constructing the version field of ::LW_INFOFRAME_DATA
#define LW_INFOFRAME_DATA_VER   MAKE_LWAPI_VERSION(LW_INFOFRAME_DATA,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Disp_InfoFrameControl
//
//! DESCRIPTION:     This API controls the InfoFrame values.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     displayId         Monitor Identifier
//! \param [in,out] pInfoframeData    Contains data corresponding to InfoFrame
//!                  
//! \return    This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Disp_InfoFrameControl(__in LwU32 displayId, __inout LW_INFOFRAME_DATA *pInfoframeData);






//! \ingroup dispcontrol
//! @{
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Disp_ColorControl
//
//! \fn LwAPI_Disp_ColorControl(LwU32 displayId, LW_COLOR_DATA *pColorData)
//! DESCRIPTION:    This API controls the Color values.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     displayId         Monitor Identifier
//! \param [in,out] pColorData        Contains data corresponding to color information
//!                  
//! \return  RETURN STATUS:
//! ::LWAPI_OK,  
//! ::LWAPI_ERROR, 
//! ::LWAPI_ILWALID_ARGUMENT
//
///////////////////////////////////////////////////////////////////////////////

typedef enum
{
    LW_COLOR_CMD_GET                 = 1,
    LW_COLOR_CMD_SET,
    LW_COLOR_CMD_IS_SUPPORTED_COLOR,
    LW_COLOR_CMD_GET_DEFAULT
} LW_COLOR_CMD;

//!  See Table 14 of CEA-861E.  Not all of this is supported by the GPU.
typedef enum
{
    LW_COLOR_FORMAT_RGB             = 0,
    LW_COLOR_FORMAT_YUV422,
    LW_COLOR_FORMAT_YUV444,
    LW_COLOR_FORMAT_DEFAULT         = 0xFE,
    LW_COLOR_FORMAT_AUTO            = 0xFF
} LW_COLOR_FORMAT;



typedef enum
{
    LW_COLOR_COLORIMETRY_RGB             = 0,
    LW_COLOR_COLORIMETRY_YCC601,
    LW_COLOR_COLORIMETRY_YCC709,
    LW_COLOR_COLORIMETRY_XVYCC601,
    LW_COLOR_COLORIMETRY_XVYCC709,
    LW_COLOR_COLORIMETRY_SYCC601,
    LW_COLOR_COLORIMETRY_ADOBEYCC601,
    LW_COLOR_COLORIMETRY_ADOBERGB,
    LW_COLOR_COLORIMETRY_DEFAULT         = 0xFE,
    LW_COLOR_COLORIMETRY_AUTO            = 0xFF
} LW_COLOR_COLORIMETRY;

typedef struct
{
    LwU32 version; //!< Version of this structure
    LwU16 size;    //!< Size of this structure
    LwU8  cmd;
    struct
    {
        LwU8  colorFormat;
        LwU8  colorimetry;
    } data;
} LW_COLOR_DATA;

LWAPI_INTERFACE LwAPI_Disp_ColorControl(LwU32 displayId, LW_COLOR_DATA *pColorData);

//! Macro for constructing the version field of ::LW_COLOR_DATA
#define LW_COLOR_DATA_VER   MAKE_LWAPI_VERSION(LW_COLOR_DATA,1)

//! @}


//! \ingroup dispcontrol
//! @{
 
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_GetVirtualModeData
//
//! \fn LwAPI_DISP_GetVirtualModeData(LwU32 displayId, LW_VIRTUALMODE_DATA *virtualModeData)
//! DESCRIPTION:     This API lets the caller get state information related to
//!                  virtual mode.  See LwAPI_DISP_OverrideDisplayModeList().
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      displayId        Display ID of display to override the
//!                                            mode list. Retrieved from 
//!                                            LwAPI_SYS_GetDisplayIdFromGpuAndOutputId().
//! \param [in,out]  virtualModeData  The type of information to retrieve
//!
//! \return 
//! ::LWAPI_OK,  
//! ::LWAPI_API_NOT_INTIALIZED,  
//! ::LWAPI_ERROR,  
//! ::LWAPI_ILWALID_ARGUMENT
//
///////////////////////////////////////////////////////////////////////////////
typedef enum
{
    LW_VIRTUALMODE_CMD_GET_INFO = 1,
} LW_VIRTUALMODE_CMD;

typedef struct
{
    LwU32 isCapableOfVirtualMode : 1;  //!< Set to 1 if system is capable of supporting virtual mode
    LwU32 isIlwirtualMode        : 1;  //!< Set to 1 if system is lwrrently in virtual mode; 0, otherwise
    LwU32 reserved               : 30;
} LW_VIRTUALMODE_INFO;

typedef struct
{
    LwU32               version;
    LW_VIRTUALMODE_CMD  cmd;
    union
    {
        LW_VIRTUALMODE_INFO virtualModeInfo;
    } data;
} LW_VIRTUALMODE_DATA;

//! Macro for constructing the version field of ::LW_VIRTUALMODE_DATA
#define LW_VIRTUALMODE_DATA_VER   MAKE_LWAPI_VERSION(LW_VIRTUALMODE_DATA,1)

LWAPI_INTERFACE LwAPI_DISP_GetVirtualModeData(LwU32 displayId, LW_VIRTUALMODE_DATA *virtualModeData);

//! @}




//! \ingroup dispcontrol
//! @{
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_OverrideDisplayModeList
//
//! \fn LwAPI_DISP_OverrideDisplayModeList(LwU32 displayId, LwU32 modeCount, LW_DISPLAY_MODE_INFO* modeList, LwU32 enableOutput)
//! DESCRIPTION:     This API lets the caller override the Display Mode List.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]       displayId     Display ID of display to override the
//!                                 mode list. Retrieved from 
//!                                 LwAPI_SYS_GetDisplayIdFromGpuAndOutputId().
//! \param [in]       modeCount     Number of supplied elements in modeList - 
//!                                 passing in 0 will disable mode list override.
//! \param [in]       modeList      Array of LW_DISPLAY_MODE_INFO elements. Pass
//!                                 in NULL with modeCount is 0.
//! \param [in]       enableOutput  when set allows monitor output; must be 0
//!                                 if modeCount is 0.
//!
//! \return 
//! ::LWAPI_OK,  
//! ::LWAPI_API_NOT_INTIALIZED,  
//! ::LWAPI_ERROR,  
//! ::LWAPI_ILWALID_ARGUMENT 
//
///////////////////////////////////////////////////////////////////////////////


typedef struct _LW_DISPLAY_MODE_INFO
{
    LwU32    version;
    LwU32    width;
    LwU32    height;
    LwU32    depth;
    LwU32    refreshRate1K;         //!< Refresh rate * 1000
    LwU32    preferred      :  1;   //!< Set to true if a preferred mode, false for non-preferred
    LwU32    reserved       : 31;
} LW_DISPLAY_MODE_INFO;

//! Macro for contructing the version field of ::LW_DISPLAY_MODE_INFO
#define LW_DISPLAY_MODE_INFO_VER   MAKE_LWAPI_VERSION(LW_DISPLAY_MODE_INFO,1)

LWAPI_INTERFACE LwAPI_DISP_OverrideDisplayModeList(LwU32 displayId, LwU32 modeCount, LW_DISPLAY_MODE_INFO* modeList, LwU32 enableOutput);

//! @}



//! \ingroup dispcontrol
//! Used in LwAPI_GetDVCInfo()
typedef struct
{
    LwU32   version;            //!< [IN] Version info  
    LwU32   lwrrentLevel;       //!< [OUT] The current DVC level
    LwU32   minLevel;           //!< [OUT] Minimim range level
    LwU32   maxLevel;           //!< [OUT] Maximum range level
} LW_DISPLAY_DVC_INFO;

//! \ingroup dispcontrol
#define LW_DISPLAY_DVC_INFO_VER  MAKE_LWAPI_VERSION(LW_DISPLAY_DVC_INFO,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetDVCInfo
//
//! This function retrieves the Digital Vibrance Control (DVC) information of the selected display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [in]  hLwDisplay  LWPU Display selection. It can be #LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]  outputId    One of the selected outputId retrieved from LwAPI_GPU_GetActiveOutputs() or LwAPI_GetView(), to identify the target 
//!                          output in case multiple targets are associated with the selected hLwDisplay. 
//!                          Can be NULL to pick the display output ID associated with hLwDisplay. See \ref handles.
//! \param [out] pDVCInfo    The returned DVC information.
//!
//! \retval  LWAPI_OK                           Call successful.
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND      No LWPU GPU driving a display was found.
//! \retval  LWAPI_EXPECTED_DISPLAY_HANDLE      hLwDisplay is not a valid display handle.
//! \retval  LWAPI_ILWALID_ARGUMENT             pDVCInfo is NULL.
//! \retval  LWAPI_INCOMPATIBLE_STRUCT_VERSION  The version of the LW_DISPLAY_DVC_INFO struct is not supported
//! \retval  LWAPI_NOT_SUPPORTED                DVC feature is not supported on the selected GPU
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetDVCInfo(LwDisplayHandle hLwDisplay, LwU32 outputId, LW_DISPLAY_DVC_INFO *pDVCInfo);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SetDVCLevel
//
//!  This function sets the DVC level for the selected display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [in]  hLwDisplay      LWPU Display selection. It can be #LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]  outputId        One of the selected outputId retrieved from LwAPI_GPU_GetActiveOutputs() or LwAPI_GetView(), to identify the target 
//!                              output in case multiple targets are associated with the selected hLwDisplay.
//!                              Can be NULL to pick the display output id associated with hLwDisplay. See \ref handles.
//! \param [out] level           The new level to apply. Value should be within the range of min and max.
//!
//! \retval  LWAPI_OK                       Call successful.
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found.
//! \retval  LWAPI_EXPECTED_DISPLAY_HANDLE  hLwDisplay is not a valid display handle.
//! \retval  LWAPI_NOT_SUPPORTED            DVC is not supported on the selected GPU
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetDVCLevel(LwDisplayHandle hLwDisplay, LwU32 outputId, LwU32 level);



//! \ingroup dispcontrol
//! Used in LwAPI_GetDVCInfoEx() and LwAPI_SetDVCLevelEx()
typedef struct
{
    LwU32   version;            //!< IN version info  
    LwS32   lwrrentLevel;       //!< OUT current DVC level
    LwS32   minLevel;           //!< OUT min range level
    LwS32   maxLevel;           //!< OUT max range level
    LwS32   defaultLevel;       //!< OUT default DVC level
} LW_DISPLAY_DVC_INFO_EX;

//! \ingroup dispcontrol
//! Macro for constucting the version field of LW_DISPLAY_DVC_INFO_EX
#define LW_DISPLAY_DVC_INFO_EX_VER  MAKE_LWAPI_VERSION(LW_DISPLAY_DVC_INFO_EX,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetDVCInfoEx
//
//!   DESCRIPTION: This API retrieves the Digital Vibrance Control(DVC) information of the selected display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]  hLwDisplay   LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]  outputId     One of the selected outputId retrieved from LwAPI_GPU_GetActiveOutputs() or LwAPI_GetView(), to identify the target
//!                           output in case multiple targets are associated with the selected hLwDisplay.
//!                           Can be NULL to pick the display output ID associated with hLwDisplay.
//! \param [out] pDVCInfo     The returned DVC information.
//!
//! \retval ::LWAPI_OK: call successful.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND: no LWPU GPU driving a display was found.
//! \retval ::LWAPI_EXPECTED_DISPLAY_HANDLE: hLwDisplay is not a valid display handle.
//! \retval ::LWAPI_ILWALID_ARGUMENT: pDVCInfo is NULL.
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the LW_DISPLAY_DVC_INFO struct is not supported
//! \retval ::LWAPI_NOT_SUPPORTED - DVC feature is not supported on the selected GPU
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetDVCInfoEx(LwDisplayHandle hLwDisplay, LwU32 outputId, LW_DISPLAY_DVC_INFO_EX *pDVCInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SetDVCLevelEx
//
//!   DESCRIPTION: This API sets the DVC level for the selected display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in] hLwDisplay  LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in] outputId    One of the selected outputId retrieved from LwAPI_GPU_GetActiveOutputs() or LwAPI_GetView(), to identify the target
//!                         output in case multiple targets are associated with the selected hLwDisplay.
//!                         Can be NULL to pick the display output ID associated with hLwDisplay.
//! \param [in] dvcInfo     The new DVC to apply. This structure can be accessed by GetDVCInfo() API.
//!
//! \retval ::LWAPI_OK                       Call successful.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found.
//! \retval ::LWAPI_EXPECTED_DISPLAY_HANDLE  hLwDisplay is not a valid display handle.
//! \retval ::LWAPI_NOT_SUPPORTED            DVC is not supported on the selected GPU
//!
//! \ingroup dispcontrol 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetDVCLevelEx(LwDisplayHandle hLwDisplay, LwU32 outputId, LW_DISPLAY_DVC_INFO_EX *pDVCInfo);


//! \ingroup dispcontrol
//! Used in LwAPI_GetHUEInfo()
typedef struct
{
    LwU32   version;            //!< IN Version info
    LwU32   lwrrentHueAngle;    //!< OUT Current HUE Angle. Typically between 0 - 360 degrees
    LwU32   defaultHueAngle;    //!< OUT Default HUE Angle
} LW_DISPLAY_HUE_INFO;

//! \ingroup dispcontrol
//! Macro for constructing the version field of LW_DISPLAY_HUE_INFO 
#define LW_DISPLAY_HUE_INFO_VER  MAKE_LWAPI_VERSION(LW_DISPLAY_HUE_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetHUEInfo
//
//!   DESCRIPTION: This API retrieves the HUE information of the selected display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in] hLwDisplay   LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in] outputId     One of the selected outputId retrieved from LwAPI_GPU_GetActiveOutputs() or LwAPI_GetView(), to identify the target 
//!                          output in case multiple targets are associated with the selected hLwDisplay.
//!                          Can be NULL to pick the display output id associated with hLwDisplay.
//! \param [out] pHUEInfo    The returned HUE information.
//!
//! \retval ::LWAPI_OK                        Call successful.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND   No LWpu GPU driving a display was found.
//! \retval ::LWAPI_EXPECTED_DISPLAY_HANDLE   hLwDisplay is not a valid display handle.
//! \retval ::LWAPI_ILWALID_ARGUMENT          pHUEInfo is NULL.
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  The version of the LW_DISPLAY_HUE_INFO struct is not supported
//! \retval ::LWAPI_NOT_SUPPORTED             HUE feature is not supported on the selected GPU
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetHUEInfo(LwDisplayHandle hLwDisplay, LwU32 outputId, LW_DISPLAY_HUE_INFO *pHUEInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SetHUEAngle
//
//!  DESCRIPTION: This API sets the HUE level for the selected display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]  hLwDisplay  LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]  outputId    One of the selected outputId retrieved from LwAPI_GPU_GetActiveOutputs() or LwAPI_GetView(), to identify the target 
//!                          output in case multiple targets are associated with the selected hLwDisplay.
//!                          Can be NULL to pick the display output ID associated with hLwDisplay.
//! \param [in]  level       The new level to apply. Value should be within the range of minimum and maximum.
//!
//! \retval ::LWAPI_OK                        Call successful.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND   No LWpu GPU driving a display was found.
//! \retval ::LWAPI_EXPECTED_DISPLAY_HANDLE   hLwDisplay is not a valid display handle.
//! \retval ::LWAPI_NOT_SUPPORTED             HUE feature is not supported on the selected GPU.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetHUEAngle(LwDisplayHandle hLwDisplay, LwU32 outputId, LwU32 hueAngle);





//! \ingroup dispcontrol
//! Used in LwAPI_GetImageSharpeningInfo()
typedef struct
{
    LwU32   version;            //!< IN version info
    LwU32   lwrrentLevel;       //!< OUT current Image Sharpening level
    LwU32   minLevel;           //!< OUT min range level
    LwU32   maxLevel;           //!< OUT max range level
} LW_DISPLAY_IMAGE_SHARPENING_INFO;

//! \ingroup dispcontrol
#define LW_DISPLAY_IMAGE_SHARPENING_INFO_VER  MAKE_LWAPI_VERSION(LW_DISPLAY_IMAGE_SHARPENING_INFO,1)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetImageSharpeningInfo
//
//!  This function retrieves the Image Sharpening information of the selected display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [in]  hLwDisplay            LWPU Display selection. It can be #LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]  outputId              One of the selected outputId retrieved from LwAPI_GPU_GetActiveOutputs() or LwAPI_GetView(), to identify the target 
//!                                    output in case multiple targets are associated with the selected hLwDisplay.
//!                                    Can be NULL to pick the display output id associated with hLwDisplay. See \ref handles.
//! \param [out] pImageSharpeningInfo  The returned Image Sharpening information.
//!
//! \retval  LWAPI_OK: call successful.
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND      No LWPU GPU driving a display was found.
//! \retval  LWAPI_EXPECTED_DISPLAY_HANDLE      hLwDisplay is not a valid display handle.
//! \retval  LWAPI_ILWALID_ARGUMENT             pImageSharpeningInfo is NULL.
//! \retval  LWAPI_INCOMPATIBLE_STRUCT_VERSION  The version of the LW_DISPLAY_IMAGE_SHARPENING_INFO struct is not supported
//! \retval  LWAPI_NOT_SUPPORTED                Image Sharpening is not supported on the selected GPU
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetImageSharpeningInfo(LwDisplayHandle hLwDisplay, LwU32 outputId, LW_DISPLAY_IMAGE_SHARPENING_INFO *pImageSharpeningInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SetImageSharpeningLevel
//
//!  This function sets the Image Sharpening level for the selected display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [in]   hLwDisplay  LWPU Display selection. It can be #LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]   outputId    One of the selected outputId retrieved from LwAPI_GPU_GetActiveOutputs() or LwAPI_GetView(), to identify the target 
//!                           output in case multiple targets are associated with the selected hLwDisplay. 
//!                           Can be NULL to pick the display output id associated with hLwDisplay. See \ref handles.
//! \param [in]   level       The new level to apply. Value should be within the range of min and max.
//!
//! \retval  LWAPI_OK                       Call successful.
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found.
//! \retval  LWAPI_EXPECTED_DISPLAY_HANDLE  hLwDisplay is not a valid display handle.
//! \retval  LWAPI_NOT_SUPPORTED            Image Sharpening is not supported on the selected GPU
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetImageSharpeningLevel(LwDisplayHandle hLwDisplay, LwU32 outputId, LwU32 level);







//! \ingroup tvapi
//! Use in LwAPI_SetTVEncoderControls() and LwAPI_GetTVEncoderControls().
typedef struct
{
    LwU32   version;                //!< [IN] Version info  

    struct
    {
        LwU32   defaultLevel;       //!< [OUT] Default level
        LwU32   lwrrentLevel;       //!< [IN/OUT] Current level
        LwU32   minLevel;           //!< [OUT] Minimum range level
        LwU32   maxLevel;           //!< [OUT] Maximum range level
    }   flicker, saturation;

} LW_TV_ENCODER_CONTROLS;

//! \ingroup tvapi
#define LW_TV_ENCODER_CONTROLS_VER  MAKE_LWAPI_VERSION(LW_TV_ENCODER_CONTROLS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetTVEncoderControls
//
//!   DESCRIPTION: This function retrieves the flicker and saturation levels for the selected TV.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//!
//!  \param [in]   hLwDisplay      LWPU Display selection. It can be #LWAPI_DEFAULT_HANDLE or 
//!                                a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//!  \param [in]   outputId        One of the selected outputId retrieved from LwAPI_GPU_GetActiveOutputs() or 
//!                                LwAPI_GetView(), to identify the target output in case multiple targets are 
//!                                associated with the selected hLwDisplay. 
//!                                Can be NULL to pick the display output ID associated with hLwDisplay. See \ref handles.
//!  \param [out]  pTvEncoderInfo  The returned TV encoder controls and its levels. See \ref LW_TV_ENCODER_CONTROLS.
//! 
//!  \note If maxLevel and minLevel are both zero then that control is not supported on this GPU and should not be used.
//!
//!  \retval  LWAPI_OK                            Call successful.
//!  \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//!  \retval  LWAPI_EXPECTED_DISPLAY_HANDLE       hLwDisplay is not a valid display handle.
//!  \retval  LWAPI_ILWALID_ARGUMENT              pTvEncoderInfo is NULL.
//!  \retval  LWAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the LW_TV_ENCODER_CONTROLS struct is not supported.
//!  \retval  LWAPI_NOT_SUPPORTED                 TV or this API is not supported on the selected GPU.
//!
//!  \ingroup tvapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetTVEncoderControls(LwDisplayHandle hLwDisplay, LwU32 outputId, LW_TV_ENCODER_CONTROLS *pTvEncoderInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SetTVEncoderControls
//
//!   DESCRIPTION: This function sets the flicker and saturation levels for the selected TV.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//!  \param [in]   hLwDisplay      LWPU Display selection. It can be #LWAPI_DEFAULT_HANDLE or 
//!                                a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//!  \param [in]   outputId        One of the selected outputId retrieved from LwAPI_GPU_GetActiveOutputs() or 
//!                                LwAPI_GetView(), to identify the target output in case multiple targets are 
//!                                associated with the selected hLwDisplay. See \ref handles.
//!                                Can be NULL to pick the display output ID associated with hLwDisplay.
//!  \param [in]   pTvEncoderInfo  The selected TV encoder controls and its levels that are applied. See \ref LW_TV_ENCODER_CONTROLS.
//!
//!  \retval  LWAPI_OK                            Call successful.
//!  \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND       No LWPU GPU driving a display was found.
//!  \retval  LWAPI_EXPECTED_DISPLAY_HANDLE       hLwDisplay is not a valid display handle.
//!  \retval  LWAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the LW_TV_ENCODER_CONTROLS struct is not supported.
//!  \retval  LWAPI_NOT_SUPPORTED                 TV or this API is not supported on the selected GPU.
//!
//!  \ingroup tvapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetTVEncoderControls(LwDisplayHandle hLwDisplay, LwU32 outputId, LW_TV_ENCODER_CONTROLS *pTvEncoderInfo);

//! \ingroup tvapi
//! Used in LwAPI_SetTVOutputBorderColor() and LwAPI_GetTVOutputBorderColor().
typedef enum
{ 
    LW_TV_BORDER_COLOR_BLACK    = 0,
    LW_TV_BORDER_COLOR_GREY     = 1,
} LW_TV_BORDER_COLOR;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetTVOutputBorderColor
//
//!   DESCRIPTION: This function retrieves the color of the TV border.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//!   \param [in]  hLwDisplay     LWPU Display selection. It can be #LWAPI_DEFAULT_HANDLE or 
//!                               a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//!   \param [in]  outputId       One of the selected outputId retrieved from LwAPI_GPU_GetActiveOutputs() or 
//!                               LwAPI_GetView(), to identify the target output in case multiple targets are 
//!                               associated with the selected hLwDisplay.
//!                               Can be NULL to pick the display output ID associated with hLwDisplay. See \ref handles.
//!   \param [out] pBorderColor   The returned TV border color.
//!
//!   \retval   LWAPI_OK                       Call successful.
//!   \retval   LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found.
//!   \retval   LWAPI_EXPECTED_DISPLAY_HANDLE  hLwDisplay is not a valid display handle.
//!   \retval   LWAPI_ILWALID_ARGUMENT         pBorderColor is NULL.
//!   \retval   LWAPI_NOT_SUPPORTED            TV or this API is not supported on the selected GPU.
//!
//!   \ingroup tvapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetTVOutputBorderColor(LwDisplayHandle hLwDisplay, LwU32 outputId, LW_TV_BORDER_COLOR *pBorderColor);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SetTVOutputBorderColor
//
//!   DESCRIPTION: This function sets the color of the TV border.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//!
//!   \param [in]  hLwDisplay     LWPU Display selection. It can be #LWAPI_DEFAULT_HANDLE or 
//!                               a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//!   \param [in]  outputId       One of the selected outputId retrieved from LwAPI_GPU_GetActiveOutputs or 
//!                               LwAPI_GetView, to identify the target output in case multiple targets are 
//!                               associated with the selected hLwDisplay. See \ref handles.
//!                               Can be NULL to pick the display output ID associated with hLwDisplay.
//!   \param [in]  pBorderColor   The TV border color to set.
//!
//!   \retval   LWAPI_OK                       Call successful.
//!   \retval   LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found.
//!   \retval   LWAPI_EXPECTED_DISPLAY_HANDLE  hLwDisplay is not a valid display handle.
//!   \retval   LWAPI_NOT_SUPPORTED            TV or this API is not supported on the selected GPU.
//!
//!   \ingroup tvapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetTVOutputBorderColor(LwDisplayHandle hLwDisplay, LwU32 outputId, LW_TV_BORDER_COLOR borderColor);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetDisplayPosition
//
//!   DESCRIPTION: This function retrieves the display position of the associated analog display.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//!
//!   \param [in]  hLwDisplay     LWPU Display selection. It can be #LWAPI_DEFAULT_HANDLE or 
//!                               a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//!   \param [in]  outputId       One of the selected outputId retrieved from LwAPI_GPU_GetActiveOutputs or 
//!                               LwAPI_GetView, to identify the target output in case multiple targets are 
//!                               associated with the selected hLwDisplay. See \ref handles.
//!                               Can be NULL to pick the display output ID associated with hLwDisplay.
//!   \param [out] pXOffset       The returned display position x-offset.  
//!   \param [out] pYOffset       The returned display position y-offset.
//!
//!   \retval   LWAPI_OK                       Call successful.
//!   \retval   LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found.
//!   \retval   LWAPI_EXPECTED_DISPLAY_HANDLE  hLwDisplay is not a valid display handle.
//!   \retval   LWAPI_ILWALID_ARGUMENT         pXOffset or pYOffset is NULL.
//!   \retval   LWAPI_NOT_SUPPORTED            This API is not supported.
//!   \retval   LWAPI_EXPECTED_ANALOG_DISPLAY  The selected display is not an analog display.
//!
//!   \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetDisplayPosition(LwDisplayHandle hLwDisplay, LwU32 outputId, LwU32 *pXOffset, LwU32 *pYOffset);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SetDisplayPosition
//
//!   DESCRIPTION: This function sets the display position of the associated analog display.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//!
//!   \param [in]  hLwDisplay     LWPU Display selection. It can be #LWAPI_DEFAULT_HANDLE or 
//!                               a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//!   \param [in]  outputId       One of the selected outputId retrieved from LwAPI_GPU_GetActiveOutputs or 
//!                               LwAPI_GetView, to identify the target output in case multiple targets are 
//!                               associated with the selected hLwDisplay. See \ref handles.
//!                               Can be NULL to pick the display output ID associated with hLwDisplay.
//!   \param [in]  XOffset        The set display position x-offset.  
//!   \param [in]  YOffset        The set display position y-offset.
//!
//!   \retval   LWAPI_OK                       Call successful.
//!   \retval   LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found.
//!   \retval   LWAPI_EXPECTED_DISPLAY_HANDLE  hLwDisplay is not a valid display handle.
//!   \retval   LWAPI_NOT_SUPPORTED            This API is not supported.
//!   \retval   LWAPI_EXPECTED_ANALOG_DISPLAY  The selected display is not an analog display.
//!
//!   \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetDisplayPosition(LwDisplayHandle hLwDisplay, LwU32 outputId, LwU32 xOffset, LwU32 yOffset);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_RmConfigGet
//
//!    This is a TEMPORARY implementation of the resource manager configGet for LDDM.
//!    This escape is meant for use by swak only.  Please contact 
//!    sw-lwapi if you wish to use this interface.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! Earliest supported ForceWare version: 82.61
//!
//! \return  LWAPI_ERROR or LWAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_RmConfigGet(LwDisplayHandle hLwDisplay,LwU32 opcode,LwU32 *pValue);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetGFAHandle()
//
//!   DESCRIPTION: Used by driver security tools.  Not for export outside LWPU.
//!                Contact Andrei Osnovich regarding this API.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \return LWAPI_ERROR or LWAPI_OK
//!
//! 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetGFAHandle(void **GFAHandle);





///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GetDisplaySettings
//
//!  This function retrieves the target display arrangement for a selected display source.
//!  \note Display PATH with this API is limited to a single GPU. DUALVIEW across GPUs will be returned as STANDARD VIEW. 
//!        Use LwAPI_SYS_GetDisplayTopologies() to query views across GPUs.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \param [in]   hLwDisplay      LWPU Display selection \n
//!                               #LWAPI_DEFAULT_HANDLE is not allowed, it must be a handle enumerated with LwAPI_EnumLWidiaDisplayHandle().
//! \param [out]  pPaths          Detailed target display arrangement for clone, span, and edge blending display modes.
//! \param [out]  pathCount       Count of targets for the selected display source.
//!
//! \return    This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \retval    LWAPI_DEVICE_BUSY       -   ModeSet has not yet completed. Please wait and call it again.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetDisplaySettings(LwDisplayHandle hLwDisplay, LW_DISP_PATH *pPaths, LwU32 *pPathCount);

//! \ingroup dispcontrol
//! Used in LwAPI_DISP_GetTiming().
typedef struct
{
    LwU32                   isInterlaced   : 4;  //!< To retrieve interlaced/progressive timing
    LwU32                   reserved0      : 12;
    union
    {
        LwU32               tvFormat       : 8;  //!< The actual analog HD/SDTV format. Used when the timing type is 
                                                 //!  LW_TIMING_OVERRIDE_ANALOG_TV and width==height==rr==0.
        LwU32               ceaId          : 8;  //!< The EIA/CEA 861B/D predefined short timing descriptor ID. 
                                                 //!  Used when the timing type is LW_TIMING_OVERRIDE_EIA861
                                                 //!  and width==height==rr==0.
        LwU32               lwPsfId        : 8;  //!< The LW predefined PsF format Id. 
                                                 //!  Used when the timing type is LW_TIMING_OVERRIDE_LW_PREDEFINED.
    };
    LwU32                   scaling        : 8;  //!< Define preferred scaling
}LW_TIMING_FLAG;

//! \ingroup dispcontrol
//! Used in LwAPI_DISP_GetTiming().
typedef struct _LW_TIMING_INPUT
{
    LwU32 version;                      //!< (IN)     structure version
    
    LwU32 width;                        //!< Visible horizontal size
    LwU32 height;                       //!< Visible vertical size 
    float rr;                           //!< Timing refresh rate

    LW_TIMING_FLAG flag;                //!< Flag containing additional info for timing callwlation.
    
    LW_TIMING_OVERRIDE type;            //!< Timing type(formula) to use for callwlating the timing
}LW_TIMING_INPUT;

#define LW_TIMING_INPUT_VER   MAKE_LWAPI_VERSION(LW_TIMING_INPUT,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GetTiming
//
//! \fn LwAPI_GetTiming(LwDisplayHandle hLwDisplay, LwU32 width, LwU32 height, float rr, LW_TIMING_FLAG flag, LwU32 outputId,
//! DESCRIPTION:  This function callwlates the timing from the visible width/height/refresh-rate and timing type info.
//!
//! \deprecated  Do not use this function - it is deprecated in release 313. Instead, use LwAPI_DISP_GetTiming.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]   hLwDisplay  LWPU Display selection \n
//!                           #LWAPI_DEFAULT_HANDLE is not allowed, it has to be a handle enumerated with LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]   width       Visible horizontal size
//! \param [in]   height      Visible vertical size 
//! \param [in]   rr          Timing refresh rate 
//! \param [in]   flag        Flag containing additional info for timing callwlation.
//! \param [in]   outputId    The monitor Id(mask) - only used to get the EDID timing or custom timing or LW policy related timing. See \ref handles.
//!                           (LW_TIMING_OVERRIDE_AUTO).
//! \param [in]   type        Timing type(formula) to use for callwlating the timing
//! \param [out]  pT          Pointer to the LW_TIMING structure 
//!
//! \retval                 LWAPI_OK                Completed request
//! \retval                 LWAPI_ERROR             Miscellaneous error oclwrred
//! \retval                 LWAPI_ILWALID_ARGUMENT  Invalid input parameter.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup dispcontrol
//! @{

//! Get CEA format (digital TV format) from LW_TIMING(::etc.status)
#define LW_GET_CEA_FORMAT(n) (((n)&0x3F800000)>>23)     

//! Get the analog TV format from LW_TIMING(::etc.status)
#define LW_GET_ANALOG_TV_FORMAT(n) ((((n)&0x0FF00)==0x1100||((n)&0x0FF00)==0x1200)?((n)&0x0FF):0)   

//! Check if the timing(LW_TIMING::etc.status) is an analog TV format
#define LW_IS_ANALOG_TV_FORMAT(n)  ((((n)&0x0FF00)==0x1100||((n)&0x0FF00)==0x1200)?1:0)    

//! @}

//! \ingroup dispcontrol 
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 313. Instead, use LwAPI_DISP_GetTiming.")
LWAPI_INTERFACE LwAPI_GetTiming(LwDisplayHandle hLwDisplay, LwU32 width, LwU32 height, float rr, LW_TIMING_FLAG flag, LwU32 outputId, LW_TIMING_OVERRIDE type, LW_TIMING *pT); 

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_GetTiming
//
//! DESCRIPTION:  This function callwlates the timing from the visible width/height/refresh-rate and timing type info.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 313  
//!
//!
//! \param [in]   displayId     Display ID of the display.
//! \param [in]   timingInput   Inputs used for callwlating the timing.
//! \param [out]  pTiming       Pointer to the LW_TIMING structure. 
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetTiming( __in LwU32 displayId,__in LW_TIMING_INPUT *timingInput, __out LW_TIMING *pTiming); 



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_GetMonitorCapabilities
//
//! \fn LwAPI_DISP_GetMonitorCapabilities(LwU32 displayId, LW_MONITOR_CAPABILITIES *pMonitorCapabilities)
//! DESCRIPTION:     This API returns the Monitor capabilities 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      displayId                Monitor Identifier
//! \param [out]     pMonitorCapabilities     The monitor support info
//!
//! \return ::LWAPI_OK, 
//!         ::LWAPI_ERROR, 
//!         ::LWAPI_ILWALID_ARGUMENT
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dispcontrol
//! @{


//! HDMI-related and extended CAPs
typedef enum
{
    // hdmi related caps
    LW_MONITOR_CAPS_TYPE_HDMI_VSDB = 0x1000,
    LW_MONITOR_CAPS_TYPE_HDMI_VCDB = 0x1001,
    // backend caps
    LW_MONITOR_CAPS_TYPE_GENERIC   = 0x1002,
} LW_MONITOR_CAPS_TYPE;



typedef struct _LW_MONITOR_CAPS_VCDB
{
    LwU8    quantizationRangeYcc         : 1;
    LwU8    quantizationRangeRgb         : 1;
    LwU8    scanInfoPreferredVideoFormat : 2;
    LwU8    scanInfoITVideoFormats       : 2;
    LwU8    scanInfoCEVideoFormats       : 2;
} LW_MONITOR_CAPS_VCDB;


//! See LwAPI_DISP_GetMonitorCapabilities().
typedef struct _LW_MONITOR_CAPS_VSDB
{
    // byte 1
    LwU8    sourcePhysicalAddressB         : 4; //!< Byte 1
    LwU8    sourcePhysicalAddressA         : 4; //!< Byte 1
    // byte 2
    LwU8    sourcePhysicalAddressD         : 4; //!< Byte 2
    LwU8    sourcePhysicalAddressC         : 4; //!< Byte 2
    // byte 3
    LwU8    supportDualDviOperation        : 1; //!< Byte 3
    LwU8    reserved6                      : 2; //!< Byte 3
    LwU8    supportDeepColorYCbCr444       : 1; //!< Byte 3
    LwU8    supportDeepColor30bits         : 1; //!< Byte 3
    LwU8    supportDeepColor36bits         : 1; //!< Byte 3
    LwU8    supportDeepColor48bits         : 1; //!< Byte 3
    LwU8    supportAI                      : 1; //!< Byte 3 
    // byte 4
    LwU8    maxTmdsClock;  //!< Bye 4
    // byte 5
    LwU8    cnc0SupportGraphicsTextContent : 1; //!< Byte 5
    LwU8    cnc1SupportPhotoContent        : 1; //!< Byte 5
    LwU8    cnc2SupportCinemaContent       : 1; //!< Byte 5
    LwU8    cnc3SupportGameContent         : 1; //!< Byte 5
    LwU8    reserved8                      : 1; //!< Byte 5
    LwU8    hasVicEntries                  : 1; //!< Byte 5
    LwU8    hasInterlacedLatencyField      : 1; //!< Byte 5
    LwU8    hasLatencyField                : 1; //!< Byte 5    
    // byte 6
    LwU8    videoLatency; //!< Byte 6
    // byte 7
    LwU8    audioLatency; //!< Byte 7
    // byte 8
    LwU8    interlacedVideoLatency; //!< Byte 8
    // byte 9
    LwU8    interlacedAudioLatency; //!< Byte 9
    // byte 10
    LwU8    reserved13                     : 7; //!< Byte 10
    LwU8    has3dEntries                   : 1; //!< Byte 10   
    // byte 11
    LwU8    hdmi3dLength                   : 5; //!< Byte 11
    LwU8    hdmiVicLength                  : 3; //!< Byte 11
    // Remaining bytes
    LwU8    hdmi_vic[7];  //!< Keeping maximum length for 3 bits
    LwU8    hdmi_3d[31];  //!< Keeping maximum length for 5 bits 
} LW_MONITOR_CAPS_VSDB;

typedef struct _LW_MONITOR_CAPS_GENERIC
{
    LwU8    supportVRR         : 1;  //!< monitor supports variable refresh rate. Valid for LW_MONITOR_CAPS_TYPE_GENERIC only. 
    LwU8    reserved           : 7;
} LW_MONITOR_CAPS_GENERIC;


//! See LwAPI_DISP_GetMonitorCapabilities().
typedef struct _LW_MONITOR_CAPABILITIES
{
    LwU32    version;
    LwU16    size;
    LwU32    infoType;
    LwU32    connectorType;        //!< Out: VGA, TV, DVI, HDMI, DP
    LwU8     bIsValidInfo : 1;     //!< Boolean : Returns invalid if requested info is not present such as VCDB not present
    union {
        LW_MONITOR_CAPS_VSDB  vsdb;
        LW_MONITOR_CAPS_VCDB  vcdb;
        LW_MONITOR_CAPS_GENERIC caps;
    } data;
} LW_MONITOR_CAPABILITIES;

//! Macro for constructing the version field of ::LW_MONITOR_CAPABILITIES
#define LW_MONITOR_CAPABILITIES_VER   MAKE_LWAPI_VERSION(LW_MONITOR_CAPABILITIES,1)

//! @}

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dispcontrol
LWAPI_INTERFACE LwAPI_DISP_GetMonitorCapabilities(__in LwU32 displayId, __inout LW_MONITOR_CAPABILITIES *pMonitorCapabilities);

//! \ingroup dispcontrol
typedef struct _LW_MONITOR_COLOR_DATA
{
    LwU32                   version;            
// We are only supporting DP monitors for now. We need to extend this to HDMI panels as well
    LW_DP_COLOR_FORMAT      colorFormat;        //!< One of the supported color formats
    LW_DP_BPC               backendBitDepths;   //!< One of the supported bit depths
} LW_MONITOR_COLOR_CAPS_V1;

typedef LW_MONITOR_COLOR_CAPS_V1 LW_MONITOR_COLOR_CAPS;

//! \ingroup dispcontrol
#define LW_MONITOR_COLOR_CAPS_VER1   MAKE_LWAPI_VERSION(LW_MONITOR_COLOR_CAPS_V1,1)
#define LW_MONITOR_COLOR_CAPS_VER    LW_MONITOR_COLOR_CAPS_VER1

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_GetMonitorColorCapabilities
//
//! DESCRIPTION:    This API returns all the color formats and bit depth values supported by a given DP monitor. 
//!
//! USAGE:         Sequence of calls which caller should make to get the information.
//!                1. First call LwAPI_DISP_GetMonitorColorCapabilities() with pMonitorColorCapabilities as NULL to get the count.
//!                2. Allocate memory for color caps(LW_MONITOR_COLOR_CAPS) array.
//!                3. Call LwAPI_DISP_GetMonitorColorCapabilities() again with the pointer to the memory allocated to get all the 
//!                   color capabilities.
//!                   
//!                Note : 
//!                1. pColorCapsCount should never be NULL, else the API will fail with LWAPI_ILWALID_ARGUMENT.
//!                2. *pColorCapsCount returned from the API will always be the actual count in any/every call.
//!                3. Memory size to be allocated should be (*pColorCapsCount * sizeof(LW_MONITOR_COLOR_CAPS)).
//!                4. If the memory allocated is less than what is required to return all the timings, this API will return the
//!                   amount of information which can fit in user provided buffer and API will return LWAPI_INSUFFICIENT_BUFFER.
//!                5. If the caller specifies a greater value for *pColorCapsCount in second call to LwAPI_DISP_GetMonitorColorCapabilities()
//!                   than what was returned from first call, the API will return only the actual number of elements in the color
//!                   capabilities array and the extra buffer will remain unused.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      displayId                  Monitor Identifier
//! \param [in, out] pMonitorColorCapabilities  The monitor color capabilities information
//! \param [in, out] pColorCapsCount            - During input, the number of elements allocated for the pMonitorColorCapabilities pointer
//!                                             - During output, the actual number of color data elements the monitor supports
//!
//! \return    This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \retval         LWAPI_INSUFFICIENT_BUFFER   The input buffer size is not sufficient to hold the total contents. In this case
//!                                             *pColorCapsCount will hold the required amount of elements.
//! \retval         LWAPI_ILWALID_DISPLAY_ID    The input monitor is either not connected or is not a DP panel.
//!
//! \ingroup dispcontrol
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetMonitorColorCapabilities(__in LwU32 displayId, __inout_ecount_part_opt(*pColorCapsCount, *pColorCapsCount) LW_MONITOR_COLOR_CAPS *pMonitorColorCapabilities, __inout LwU32 *pColorCapsCount);

//! \ingroup dispcontrol
//! Used in LwAPI_DISP_EnumLwstomDisplay() and LwAPI_DISP_TryLwstomDisplay().
typedef struct
{
    LwU32                   version;
    
    // the source mode information
    LwU32                   width;             //!< Source surface(source mode) width
    LwU32                   height;            //!< Source surface(source mode) height
    LwU32                   depth;             //!< Source surface color depth."0" means all 8/16/32bpp
    LW_FORMAT               colorFormat;       //!< Color format (optional)
  
    LW_VIEWPORTF            srcPartition;      //!< For multimon support, should be set to (0,0,1.0,1.0) for now.
  
    float                   xRatio;            //!< Horizontal scaling ratio
    float                   yRatio;            //!< Vertical scaling ratio
                                                             
    LW_TIMING               timing;            //!< Timing used to program TMDS/DAC/LVDS/HDMI/TVEncoder, etc.
    LwU32                   hwModeSetOnly : 1; //!< If set, it means a hardware modeset without OS update
    
}LW_LWSTOM_DISPLAY; 

//! \ingroup dispcontrol
//! Used in LW_LWSTOM_DISPLAY.
#define LW_LWSTOM_DISPLAY_VER  MAKE_LWAPI_VERSION(LW_LWSTOM_DISPLAY,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_EnumLwstomDisplay
//
//! \fn LwAPI_EnumLwstomDisplay(LwDisplayHandle hLwDisplay, LwU32 index, LwU32 outputId, LW_LWSTOM_DISPLAY *pC)
//! DESCRIPTION:     This function enumerates the custom displays.
//!
//! \deprecated  Do not use this function - it is deprecated in release 313. Instead, use LwAPI_DISP_EnumLwstomDisplay.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]      hLwDisplay  LWPU Display selection \n 
//!                              #LWAPI_DEFAULT_HANDLE is not allowed. It must be a handle enumerated with LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]      index       Enum index
//! \param [in]      outputId    Monitor Id to which the custom display configuration should be obtained.
//!                              "-1" is to enum all custom display configurations. See \ref handles.
//! \param [out]     pC          Pointer to the LW_LWSTOM_DISPLAY structure 
//!
//! \retval          LWAPI_OK                Completed request
//! \retval          LWAPI_ERROR             Miscellaneous error oclwrred
//! \retval          LWAPI_ILWALID_ARGUMENT  Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dispcontrol 
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 313. Instead, use LwAPI_DISP_EnumLwstomDisplay.")
LWAPI_INTERFACE LwAPI_EnumLwstomDisplay(LwDisplayHandle hLwDisplay, LwU32 index, LwU32 outputId, LW_LWSTOM_DISPLAY *pC); 








///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_TryLwstomDisplay
//
//! DESCRIPTION:    This API is a wrapper function of LwAPI_SetDisplaySettings() to set up a custom display without saving the configuration.
//!
//! \note
//!  All the members of srcPartition, present in LW_LWSTOM_DISPLAY structure, should have their range in (0.0,1.0).
//!  In clone mode the timings can applied to both the target monitors but only one target at a time. \n
//!  For the secondary target the applied timings works under the following conditions:
//!  - If the secondary monitor EDID supports the selected timing, OR
//!  - If the selected custom timings can be scaled by the secondary monitor for the selected source resolution on the primary, OR
//!  - If the selected custom timings matches the existing source resolution on the primary.
//!
//! \deprecated  Do not use this function - it is deprecated in release 313. Instead, use LwAPI_DISP_TryLwstomDisplay.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]    hLwDisplay     LWPU Display selection \n
//!                               #LWAPI_DEFAULT_HANDLE is not allowed, it must be a handle enumerated with LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]    pDispOutId     Array of the target monitor output IDs - See \ref handles.
//! \param [in]    pLwstDisp      Pointer to the LW_LWSTOM_DISPLAY structure
//! \param [in]    count          Total number of the incoming LW_LWSTOM_DISPLAY structure. This is for the multi-head support.
//! \param [in]    hwModeSetOnly  Option to let the user flush the timing without OS update
//!
//! \retval        LWAPI_OK                           Completed request
//! \retval        LWAPI_ERROR                        Miscellaneous error oclwrred
//! \retval        LWAPI_ILWALID_ARGUMENT             Invalid input parameter.
//! \retval        LWAPI_NO_IMPLEMENTATION            Not implemented.
//! \retval        LWAPI_INCOMPATIBLE_STRUCT_VERSION  The version of LW_LWSTOM_DISPLAY is not supported.
//! 
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 313. Instead, use LwAPI_DISP_TryLwstomDisplay.")
LWAPI_INTERFACE LwAPI_TryLwstomDisplay(LwDisplayHandle hLwDisplay, LwU32 *pDispOutputId, LW_LWSTOM_DISPLAY *pLwstDisp, LwU32 count, LwU32 hwModeSetOnly);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_RevertLwstomDisplayTrial
//
//! DESCRIPTION:    This API is used to restore the old display configuration before LwAPI_TryLwstomDisplay() was called. This function
//!                 must be called only after a custom display configuration is tested on the hardware, using LwAPI_TryLwstomDisplay(),  
//!                 otherwise no action is taken.
//!                 This API is not supported under Windows XP, in which case it returns LWAPI_NO_IMPLEMENTATION.
//!
//! \deprecated  Do not use this function - it is deprecated in release 313. Instead, use LwAPI_DISP_RevertLwstomDisplayTrial.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]    hLwDisplay   LWPU Display selection
//!                             #LWAPI_DEFAULT_HANDLE is not allowed, it must be a handle enumerated with LwAPI_EnumLWidiaDisplayHandle().
//!
//! \retval        LWAPI_OK                Completed request
//! \retval        LWAPI_ERROR             Miscellaneous error oclwrred
//! \retval        LWAPI_ILWALID_ARGUMENT  Invalid input parameter.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 313. Instead, use LwAPI_DISP_RevertLwstomDisplayTrial.")
LWAPI_INTERFACE LwAPI_RevertLwstomDisplayTrial(LwDisplayHandle hLwDisplay);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DeleteLwstomDisplay
//
//! DESCRIPTION:    This function deletes the index-specified custom display configuration from the registry.
//!
//! \deprecated  Do not use this function - it is deprecated in release 313. Instead, use LwAPI_DISP_DeleteLwstomDisplay.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]     hLwDisplay       LWPU Display selection \n
//!                                  #LWAPI_DEFAULT_HANDLE is not allowed. It must be a handle enumerated with LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]     displayOutputId  Display ID on which the underscan configuration is to be applied. It must be a legal display Id (one bit set)
//!                                  -"0" is allowed, and indicates the default display used by the hLwDisplay handle.
//!                                  -"-1" is allowed, and indicates that the "index" is the absolute index and not a displayOutputId-related
//!                                   index - the index of the custom display
//!
//! \retval                   LWAPI_OK - completed request
//! \retval                   LWAPI_ERROR - miscellaneous error oclwrred
//! \retval                   LWAPI_ILWALID_ARGUMENT: Invalid input parameter.
//!
//! \ingroup dispcontrol 
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 313. Instead, use LwAPI_DISP_DeleteLwstomDisplay.")
LWAPI_INTERFACE LwAPI_DeleteLwstomDisplay(LwDisplayHandle hLwDisplay, LwU32 displayOutputId, LwU32 index); 

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SaveLwstomDisplay
//
//! DESCRIPTION:    This function saves the current hardware display configuration on the specified output ID as a custom display configuration.
//!                 This function should be called right after LwAPI_TryLwstomDisplay() to save the custom display from the current
//!                 hardware context. This function will not do anything if the custom display configuration is not tested on the hardware.
//!
//! \deprecated  Do not use this function - it is deprecated in release 313. Instead, use LwAPI_DISP_SaveLwstomDisplay.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]     hLwDisplay          LWPU Display selection \n
//!                                     LWAPI_DEFAULT_HANDLE not allowed, it has to be a handle enumerated with LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]     isThisOutputIdOnly  If set, the saved custom display will only be applied on the monitor with the same outputId (see \ref handles).
//! \param [in]     isThisMonitorIdOnly If set, the saved custom display will only be applied on the monitor with the same EDID ID or 
//!                                     the same TV connector in case of analog TV.
//!
//! \retval         LWAPI_OK                Completed request
//! \retval         LWAPI_ERROR             Miscellaneous error oclwrred
//! \retval         LWAPI_ILWALID_ARGUMENT  Invalid input parameter.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 313. Instead, use LwAPI_DISP_SaveLwstomDisplay.")
LWAPI_INTERFACE LwAPI_SaveLwstomDisplay(LwDisplayHandle hLwDisplay, LwU32 isThisOutputIdOnly, LwU32 isThisMonitorIdOnly);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_EnumLwstomDisplay
//
//! DESCRIPTION:   This API enumerates the custom timing specified by the enum index. 
//!                The client should keep enumerating until it returns LWAPI_END_ENUMERATION.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 313 
//!
//! \param [in]     displayId   Dispaly ID of the display.
//! \param [in]     index       Enum index
//! \param [inout]  pLwstDisp   Pointer to the LW_LWSTOM_DISPLAY structure 
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//! \retval        LWAPI_ILWALID_DISPLAY_ID:   Custom Timing is not supported on the Display, whose display id is passed
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_EnumLwstomDisplay( __in LwU32 displayId, __in LwU32 index, __inout LW_LWSTOM_DISPLAY *pLwstDisp);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_TryLwstomDisplay
//
//! DESCRIPTION:    This API is used to set up a custom display without saving the configuration on multiple displays.
//!
//! \note
//!  All the members of srcPartition, present in LW_LWSTOM_DISPLAY structure, should have their range in (0.0,1.0).
//!  In clone mode the timings can applied to both the target monitors but only one target at a time. \n
//!  For the secondary target the applied timings works under the following conditions:
//!  - If the secondary monitor EDID supports the selected timing, OR
//!  - If the selected custom timings can be scaled by the secondary monitor for the selected source resolution on the primary, OR
//!  - If the selected custom timings matches the existing source resolution on the primary.
//!  Setting up a custom display on non-active but connected monitors is supported only for Win7 and above.
//!
//! SUPPORTED OS:  Windows XP,  Windows 7 and higher
//!
//!
//! \since Release: 313   
//!
//!                               
//! \param [in]    pDisplayIds    Array of the target display Dispaly IDs - See \ref handles.
//! \param [in]    count          Total number of the incoming Display IDs and corresponding LW_LWSTOM_DISPLAY structure. This is for the multi-head support.
//! \param [in]    pLwstDisp      Pointer to the LW_LWSTOM_DISPLAY structure array.
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//! \retval        LWAPI_ILWALID_DISPLAY_ID:   Custom Timing is not supported on the Display, whose display id is passed
//! 
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_TryLwstomDisplay( __in_ecount(count) LwU32 *pDisplayIds, __in LwU32 count, __in_ecount(count) LW_LWSTOM_DISPLAY *pLwstDisp);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_DeleteLwstomDisplay
//
//! DESCRIPTION:    This function deletes the custom display configuration, specified from the registry for  all the displays whose display IDs are passed.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 313 
//!
//!
//! \param [in]     pDisplayIds    Array of Dispaly IDs on which custom display configuration is to be saved.
//! \param [in]     count          Total number of the incoming Dispaly IDs. This is for the multi-head support.
//! \param [in]     pLwstDisp      Pointer to the LW_LWSTOM_DISPLAY structure
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//! \retval        LWAPI_ILWALID_DISPLAY_ID:   Custom Timing is not supported on the Display, whose display id is passed
//!
//! \ingroup dispcontrol 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_DeleteLwstomDisplay( __in_ecount(count) LwU32 *pDisplayIds, __in LwU32 count, __in LW_LWSTOM_DISPLAY *pLwstDisp);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_SaveLwstomDisplay
//
//! DESCRIPTION:    This function saves the current hardware display configuration on the specified Display IDs as a custom display configuration.
//!                 This function should be called right after LwAPI_DISP_TryLwstomDisplay() to save the custom display from the current
//!                 hardware context. This function will not do anything if the custom display configuration is not tested on the hardware.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 313 
//!
//!
//! \param [in]     pDisplayIds         Array of Dispaly IDs on which custom display configuration is to be saved.
//! \param [in]     count               Total number of the incoming Dispaly IDs. This is for the multi-head support.
//! \param [in]     isThisOutputIdOnly  If set, the saved custom display will only be applied on the monitor with the same outputId (see \ref handles).
//! \param [in]     isThisMonitorIdOnly If set, the saved custom display will only be applied on the monitor with the same EDID ID or 
//!                                     the same TV connector in case of analog TV.
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//! \retval        LWAPI_ILWALID_DISPLAY_ID:   Custom Timing is not supported on the Display, whose display id is passed
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_SaveLwstomDisplay( __in_ecount(count) LwU32 *pDisplayIds, __in LwU32 count, __in LwU32 isThisOutputIdOnly, __in LwU32 isThisMonitorIdOnly);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_RevertLwstomDisplayTrial
//
//! DESCRIPTION:    This API is used to restore the display configuration, that was changed by calling LwAPI_DISP_TryLwstomDisplay(). This function
//!                 must be called only after a custom display configuration is tested on the hardware, using LwAPI_DISP_TryLwstomDisplay(),  
//!                 otherwise no action is taken. On Vista, LwAPI_DISP_RevertLwstomDisplayTrial should be called with an active display that  
//!                 was affected during the LwAPI_DISP_TryLwstomDisplay() call, per GPU. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 313  
//!
//!
//! \param [in]    pDisplayIds   Pointer to display Id, of an active display. 
//! \param [in]    count         Total number of incoming Display IDs. For future use only. Lwrrently it is expected to be passed as 1.
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_RevertLwstomDisplayTrial( __in_ecount(count) LwU32* pDisplayIds, __in LwU32 count);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_QueryUnderscanCap
//
//! \fn LwAPI_QueryUnderscanCap(LwDisplayHandle hLwDisplay, LwU32 displayOutputId, LW_UNDERSCAN_CAP* cap)
//!  DESCRIPTION:  This function gets the maximum underscan/overscan ratio and the supported underscan type(s).
//! 
//! <b> Supported Underscan Options for GPU and Display Outputs</b>
//! <table cellspacing="2" cellpadding="2" border="1">
//! <tr>
//!     <th>GPU</th>
//!     <th>Display Output</th>
//!     <th>Available Underscan Options</th>
//! </tr>
//! <tr>
//!     <td>GeForce8/post-GeForce8 </td>
//!     <td>CRT/TV/DFP/HDMI </td>
//!     <td>Source and scaler underscan</td>
//! </tr>
//! <tr>
//!     <td>GeForce7/pre-GeForce7</td>
//!     <td>TV/DFP/HDMI </td>
//!     <td>Source underscan only</td>
//! </tr>
//! <tr>
//!     <td>GeForce7/pre-GeForce7</td>
//!     <td>CRT  </td>
//!     <td>No underscan option yet</td>
//! </tr>
//! </table>
//!
//! <b> EDID Checking Behavior</b>
//! <table cellspacing="2" cellpadding="2" border="1">
//! <tr>
//!     <th>supportMonitorIdMatch</th>
//!     <th>supportDisplayOutputIdMatch</th>
//!     <th>Behavior</th>
//! </tr>
//! <tr>
//!     <td>0</td>
//!    <td>0</td>
//!     <td>No EDID check, apply to all devices (not recommended).</td>
//! </tr>
//! <tr>
//!     <td>0</td>
//!     <td>1</td>
//!     <td>No EDID check, apply to a specified device only (the old WinXP style).</td>
//! </tr>
//! <tr>
//!     <td>1</td>
//!     <td>0</td>
//!     <td>Apply to the specified EDID regardless of the device mask.</td>
//! </tr>
//! <tr>
//!     <td>1</td>
//!     <td>1</td>
//!     <td>Apply to the specified EDID on a specified device.</td>
//! </tr>
//! </table>
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//! \param [in]    hLwDisplay       LWPU Display selection \n
//!                                 #LWAPI_DEFAULT_HANDLE is not allowed. It must be a handle enumerated with LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]    displayOutputId  The display ID on which to apply the underscan configuration. 
//!                                 It must be a legal display ID (one bit set). \n
//!                                 "0" is allowed, indicating the default display used by the hLwDisplay handle. See \ref handles.
//! \param [out]   cap              The pointer to the LW_UNDERSCAN_CAP structure
//!
//! \retval  LWAPI_OK                Completed request
//! \retval  LWAPI_ERROR             Miscellaneous error oclwrred
//! \retval  LWAPI_ILWALID_ARGUMENT  Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dispcontrol
//! Used in LwAPI_QueryUnderscanCap().
typedef struct
{
    LwU32 version;                           //!< Structure version
    
    float xRatioMin;                         //!< The supported min horizontal underscan ratio (e.g. 0.75 ~ 1.25 etc)
    float xRatioMax;                         //!< The supported max horizontal underscan ratio
    float yRatioMin;                         //!< The supported min vertical underscan ratio (e.g. 0.75 ~ 1.25)
    float yRatioMax;                         //!< The supported max vertical underscan ratio
    
    LwU32 supportSourceUnderscan       : 1;  //!< Indicate if source underscan is supported.
    LwU32 supportScalerUnderscan       : 1;  //!< Indicate if the scaler-based underscan is supported.
    LwU32 supportMonitorIdMatch        : 1;  //!< Indicate if the underscan configuration can be set for the monitors with the same EDID.
    LwU32 supportDisplayOutputIdMatch  : 1;  //!< Indicate if the underscan configuration can be set for monitors connected to the same display output ID.
    LwU32 supportXYIndependentCtrl     : 1;  //!< Indicate if we can independently control in the X and Y direction.
//! \code
//! Note 1: 
//!------------------------+--------------------+------------------------------------------------
//!          GPU           |    DisplayOutput   |  Available Underscan option
//!------------------------+--------------------+------------------------------------------------
//! GeForce8/post-GeForce8 |   CRT/TV/DFP/HDMI  |  source and scaler underscan
//! GeForce7/pre-GeForce7  |      TV/DFP/HDMI   |  source under only, the API will automatically
//!                        |                    |  fall back if scaler underscan is specified
//! GeForce7/pre-GeForce7  |         CRT        |  no underscan option yet, the API will return  
//!                        |                    |  failure
//!------------------------+--------------------+-------------------------------------------------
//!
//! Note 2:
//!-------------------+-----------------------------+-------------------------------------------
//! supportEdidMatch  | supportDisplayOutputIdMatch |                        behavior
//!-------------------+-----------------------------+---------------------------------------------
//!       0           |        0                    |  no EDID check, apply to all devices 
//!                   |                             | (not recommended)
//!       0           |        1                    |  no EDID check, apply to a specified device 
//!                   |                             |  only (the old XP style)
//!       1           |        0                    |  apply to the specified Edid regardless of   
//!                   |                             |  the device mask (new)
//!       1           |        1                    |  apply to the specified Edid on a specified
//!                   |                             |  device (new)
//!-------------------+-----------------------------+---------------------------------------------
//! \endcode
    LwU32 isSourceUnderscanRecommended : 1;  //!< Indicate if source underscan is recommended under the current display context.
    LwU32 isScalerUnderscanRecommended : 1;  //!< Indicate if the scaler based underscan is recommended under the current display context.
} LW_UNDERSCAN_CAP;


//! \ingroup dispcontrol
//! Macro for constructing the version field of LW_UNDERSCAN_CAP
#define LW_UNDERSCAN_CAP_VER  MAKE_LWAPI_VERSION(LW_UNDERSCAN_CAP,1)


//! \ingroup dispcontrol
LWAPI_INTERFACE LwAPI_QueryUnderscanCap(LwDisplayHandle hLwDisplay, LwU32 displayOutputId, LW_UNDERSCAN_CAP* cap);


//! \ingroup dispcontrol
//! @{

typedef enum LW_LWRSOR_SIZE
{
    LW_LWRSOR_SIZE_64  = 64,
    LW_LWRSOR_SIZE_128 = 128,
    LW_LWRSOR_SIZE_256 = 256
} LW_LWRSOR_SIZE;

typedef struct
{
    LwU32           version;                           //!< Structure version

    LwU32           targetId;                          //!< Target Id of the display
    LW_LWRSOR_SIZE  lwrsorSize;                        //!< Size in pixels of the cursor to be set
    LwU32           hwLwrsorEnable : 1;                //!< Flag to enable or disable the cursor
    LwU32           reserved : 31;                     //!< Reserved. Should be initialized to 0
} LW_LWRSOR_STATE_V1;

typedef LW_LWRSOR_STATE_V1 LW_LWRSOR_STATE;

#define LW_LWRSOR_STATE_VER_1 MAKE_LWAPI_VERSION(LW_LWRSOR_STATE_V1,1)

#define LW_LWRSOR_STATE_VER   LW_LWRSOR_STATE_VER_1


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_DISP_SetLwrsorState
//
//! DESCRIPTION:    This function sets the hardware cursor size and enables/disables the cursor.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      lwrsorState                   - The pointer for the input structure containing the cursor state info.
//!                                                   
//! \param [in]      hLwDisplay                    - LWPU Display selection 
//!
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//!              Error codes specific to this API are described below.
//!              (None)
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_SetLwrsorState(__in LwDisplayHandle hLwDisplay, __in LW_LWRSOR_STATE* lwrsorState);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_DISP_GetLwrsorState
//
//! DESCRIPTION:    This function gets the information regarding the hardware cursor size and whether the cursor is enabled/disabled.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out]      lwrsorState                - The pointer for the input structure containing the cursor state info.
//!                                 
//! \param [in]          hLwDisplay                 - LWPU Display selection 
//!
//!
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//!              Error codes specific to this API are described below.
//!              (None)
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetLwrsorState(__in LwDisplayHandle hLwDisplay, __inout LW_LWRSOR_STATE* lwrsorState);

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_EnumUnderscanConfig
//
//! \fn LwAPI_EnumUnderscanConfig(LwDisplayHandle hLwDisplay, LwU32 displayOutputId, LwU32 index, LW_UNDERSCAN_CONFIG* config)
//! DESCRIPTION:    This function enumerates the user-lwstomized underscan configurations on the given device.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//!
//!  \param [in]    hLwDisplay         LWPU Display selection \n 
//!                                    #LWAPI_DEFAULT_HANDLE is not allowed - it must be a handle enumerated with
//!                                    LwAPI_EnumLWidiaDisplayHandle().
//!
//!  \param [in]    displayOutputId  The display ID to which the underscan configuration applies. See \ref handles.
//!                                  It must be a legal display ID (one bit set). 
//!                                  - Use "0" to specify the default display used by the hLwDisplay handle.
//!                                  - Use "-1" to enumerate all saved underscan configurations regardless of
//!                                    the target display
//!
//!   \param [in]   index            The regular the enum index. 
//!                                  - Use "-1"(0xFFFFFFFF) to enumerate the current active underscan config on 
//!                                    the display uniquely indicated by displayOutId
//!
//!   \param [out]  config             The output pointer for the API to populate the underscan config info.
//!                                    See \ref LW_UNDERSCAN_CONFIG.
//!
//!   \retval       LWAPI_OK                Completed request
//!   \retval       LWAPI_ERROR             Miscellaneous error oclwrred
//!   \retval       LWAPI_ILWALID_ARGUMENT  Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dispcontrol
//! @{
//! Used in LwAPI_EnumUnderscanConfig().
typedef struct
{
    LwU32 version;                           //!< Structure version
    
    float xRatio;                            //!< Horizontal underscan ratio
    float yRatio;                            //!< Vertical undercan ratio \n
                                             //! The API may modify the client passed in config due to the
                                             //! hardware restrictions. For example, the xRatio/yRatio may be
                                             //! fine tuned so that they're aligned on a certain number
                                             //! because of the tiled memory restriction. Also "isSrlwnderscan" 
                                             //! may also be changed if the hardware can't do backend underscan.

    LwU32 nativeWidth;                       //!< Width of the native mode
    LwU32 nativeHeight;                      //!< Height of the native mode
    LwU32 nativeRR;                          //!< Refresh rate of the native mode
    LwU32 isInterlaced                 : 1;  //!< Whether native timing is interlaced or not
    
    LwU32 isScalerUnderscan            : 1;  //!< Scaler-based underscan or sourcedbased underscan
    LwU32 isOnThisMonitorOnly          : 1;  //!< Whether this config is applied only to this specific monitor (EDID)
    LwU32 isOnThisDisplayOutputIdOnly  : 1;  //!< Whether this underscan configuration is applied only to this display output ID
    LwU32 isEnabled                    : 1;  //!< whether this underscan config is enabled or not.

    LwU32 reserved                     : 27;
} LW_UNDERSCAN_CONFIG;

#define LW_UNDERSCAN_CONFIG_VER1  MAKE_LWAPI_VERSION(LW_UNDERSCAN_CONFIG,1)
#define LW_UNDERSCAN_CONFIG_VER2  MAKE_LWAPI_VERSION(LW_UNDERSCAN_CONFIG,2)
#define LW_UNDERSCAN_CONFIG_VER   LW_UNDERSCAN_CONFIG_VER2

//! @}


//!   \ingroup      dispcontrol
LWAPI_INTERFACE LwAPI_EnumUnderscanConfig(LwDisplayHandle hLwDisplay, LwU32 displayOutputId, LwU32 index, LW_UNDERSCAN_CONFIG* config);


//!   \ingroup      dispcontrol
#define LWAPI_INDEX_LWRRENT_ENTRY  -1

//!   \ingroup      dispcontrol
#define LWAPI_INDEX_ALL_ENTRIES    -2

//!   \ingroup      dispcontrol
#define LWAPI_INDEX_UNINITIALIZED  -3

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DeleteUnderscanConfig
//
//! DESCRIPTION:    This function deletes the specified underscan configuration entry.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//!
//! \param [in]     hLwDisplay       LWPU Display selection \n
//!                                  #LWAPI_DEFAULT_HANDLE is not allowed, it must be a handle enumerated with LwAPI_EnumLWidiaDisplayHandle().
//!
//! \param [in]     displayOutputId  The display ID to which the underscan config is applied. See \ref handles.
//!                                  It must be a legal display Id (one bit set)
//!                                  - Use "0" to specify the default display used by the hLwDisplay handle.
//!                                  - Use "-1" to indicate that "index" is the absolute index and not
//!                                    displayOutputId related
//!
//! \param [in]      index           The config index enumerated from LwAPI_EnumUnderScanConfig
//!                                  - Use "-1" for the current active underscan config being applied on
//!                                    the specified display output ID.
//!
//! \retval          LWAPI_OK                        Completed request
//! \retval          LWAPI_ERROR                     Miscellaneous error oclwrred
//! \retval          LWAPI_ILWALID_ARGUMENT          Invalid input parameter.
//! \retval          LWAPI_UNKNOWN_UNDERSCAN_CONFIG  The current active underscan config is from an unknown source 
//!                                                  and can't be deleted.
//!
//! \ingroup         dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DeleteUnderscanConfig(LwDisplayHandle hLwDisplay, LwU32 displayOutputId, LwU32 index);





///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SetUnderscanConfig
//
//! DESCRIPTION:    This function adds and sets a custom underscan configuration on the given device.  
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//!
//! \param [in]      hLwDisplay       LWPU Display selection. #LWAPI_DEFAULT_HANDLE is not allowed, 
//!                                   it must be a handle enumerated with LwAPI_EnumLWidiaDisplayHandle().
//!
//! \param [in]      displayOutputId  The display Id on which the underscan config is to apply. See \ref handles.
//!                                   It must be a legal display ID (one bit set).
//!                                   - Use "0" to indicate the default display used by the hLwDisplay handle.
//!                                     NOTE: 0xFFFFFFFF(-1) is not allowed in LwAPI_SetUnderScanConfig()
//!
//! \param [in,out]  config           The underscan config to set. See \ref LW_UNDERSCAN_CONFIG.
//! \param [in]      setDeferred      
//!                                   - "0": Apply the setup immediately.
//!                                   - "1": Apply refresh at the next OS modeset.
//!
//! \retval       LWAPI_OK                 Completed request
//! \retval       LWAPI_ERROR              Miscellaneous error oclwrred
//! \retval       LWAPI_ILWALID_ARGUMENT   Invalid input parameter
//!
//! \ingroup      dispcontrol 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetUnderscanConfig(LwDisplayHandle hLwDisplay, LwU32 displayOutputId, LW_UNDERSCAN_CONFIG* config, LwU32 setDeferred);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_EnableUnderscanConfig
//
//! DESCRIPTION:     Enables one or all of the already created underscan/overscan configs.
//!                  If one of the underscan/overscan configs being enabled has same timing as lwrrently applied timing,
//!                  this api will switch to that config.
//!                  If a source config is available, it will apply that. Otherwise, scalar config will be applied.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      displayId(IN) - Display on which the caller wants to enable the underscan config. 
//!                                  Retrieved from LwAPI_SYS_GetDisplayIdFromGpuAndOutputId().
//!
//!                  index(IN)     - This index specifies which underscan config to enable.
//!                                  This config index should be enumerated from LwAPI_EnumUnderScanConfig().
//!                                  If LWAPI_INDEX_ALL_ENTRIES(-2) is passed, it enables all the underscan config's created for the display.
//!
//! RETURN STATUS:
//!                  LWAPI_OK                      - Completed request.
//!                  LWAPI_ERROR                   - Miscellaneous error oclwrred.
//!                  LWAPI_ID_OUT_OF_RANGE         - Incorrect display ID.
//!                  LWAPI_ILWALID_ARGUMENT        - Invalid index.
//!                  LWAPI_NO_IMPLEMENTATION       - LWAPI is not implemented. Only supported on Vista and above.
//!                  LWAPI_API_NOT_INTIALIZED      - LWAPI not initialized.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_EnableUnderscanConfig(LwU32 displayId, LwU32 index);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_DisableUnderscanConfig
//
//! DESCRIPTION:     Disables one or all of the already created underscan/overscan configs.
//!                  If lwrrently applied underscan/overscan is being disabled,
//!                  this api will change the mode to the max width heigth available for the timing, keeping the timing unchanged.        
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      displayId(IN) - Display on which caller wants to disable the underscan config. 
//!                                  Retrieved from LwAPI_SYS_GetDisplayIdFromGpuAndOutputId().
//!
//!                  index(IN)     - This index specifies which underscan config to disable.
//!                                  This config index should be enumerated from LwAPI_EnumUnderScanConfig().
//!                                  If LWAPI_INDEX_ALL_ENTRIES(-2) is passed, disables all the underscan config's created for the display.
//!
//! RETURN STATUS:
//!                  LWAPI_OK                      - Completed request.
//!                  LWAPI_ERROR                   - Miscellaneous error oclwrred.
//!                  LWAPI_ID_OUT_OF_RANGE         - Incorrect display ID.
//!                  LWAPI_ILWALID_ARGUMENT        - Invalid index.
//!                  LWAPI_NO_IMPLEMENTATION       - LWAPI is not implemented. Only supported on Vista and above.
//!                  LWAPI_API_NOT_INTIALIZED      - LWAPI not initialized.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_DisableUnderscanConfig(LwU32 displayId, LwU32 index);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_GetViewPortInfo
//
//! \fn LwAPI_DISP_GetViewPortInfo(__in LwU32 displayId, __inout LW_VIEW_PORT_INFO *viewPortInfo)
//! DESCRIPTION:    This function gets the view port information of an active display from the display driver.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]  displayId - Display id.
//! \param [out] viewPort  - Pointer to the LW_VIEW_PORT_INFO structure. Should not be NULL in any case.
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dispcontrol
//! View Port Information.

typedef struct 
{
    LwU32 x;    //!<  x-coordinate of the viewport top-left point
    LwU32 y;    //!<  y-coordinate of the viewport top-left point
    LwU32 w;    //!<  Width of the viewport
    LwU32 h;    //!<  Height of the viewport
} LWAPI_VIEWPORT;

typedef struct _LW_VIEW_PORT_INFO_V1
{
    LwU32          version;                //!< Structure version

    LWAPI_VIEWPORT viewPort;
    LwU32          viewPortLockState : 1;  //!< 0 means unlock/unlocked and 1 means lock/locked.
    LwU32          reserved          : 31; //!< Reserved. Should be 0.
} LW_VIEW_PORT_INFO_V1;

typedef struct _LW_VIEW_PORT_INFO_V2
{
    LwU32          version;                //!< Structure version

    LWAPI_VIEWPORT viewPort;
    LwU32          viewPortLockState : 1;  //!< 0 means unlock/unlocked and 1 means lock/locked.
    LwU32          reserved          : 31; //!< Reserved. Should be 0.
    LwU32          zoomValue;              //!< Zoom value is the zoom percentage multiplied by 1000 to take care of the decimal percentage values.
} LW_VIEW_PORT_INFO_V2;

typedef LW_VIEW_PORT_INFO_V2    LW_VIEW_PORT_INFO;

#define LW_VIEW_PORT_INFO_VER1  MAKE_LWAPI_VERSION(LW_VIEW_PORT_INFO_V1, 1)
#define LW_VIEW_PORT_INFO_VER2  MAKE_LWAPI_VERSION(LW_VIEW_PORT_INFO_V2, 2)
#define LW_VIEW_PORT_INFO_VER   LW_VIEW_PORT_INFO_VER2

//! \ingroup dispcontrol
LWAPI_INTERFACE LwAPI_DISP_GetViewPortInfo(__in LwU32 displayId, __inout LW_VIEW_PORT_INFO *viewPortInfo);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_SetViewPortInfo
//
//! DESCRIPTION:    This function sends the view port information for an active display to the display driver.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in] displayId - Display id.
//! \param [in] viewPort  - Pointer to the LW_VIEW_PORT_INFO structure. Should not be NULL in any case.
//! \param [in] setFlags  - Set of LW_VIEW_PORT_INFO_SET_* flag values mentioned below.
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
///////////////////////////////////////////////////////////////////////////////

#define LW_VIEW_PORT_INFO_SET_VIEWPORT   0x00000001
#define LW_VIEW_PORT_INFO_SET_LOCK_STATE 0x00000002
#define LW_VIEW_PORT_INFO_SET_ZOOM       0x00000004

//! \ingroup dispcontrol
LWAPI_INTERFACE LwAPI_DISP_SetViewPortInfo(__in LwU32 displayId, __in LW_VIEW_PORT_INFO *viewPortInfo, __in LwU32 setFlags);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_GetFeatureConfig
//
//! \fn LwAPI_DISP_GetFeatureConfig(__in LwU32 displayId, __inout LW_DISPLAY_FEATURE_CONFIG *pDisplayFeatureConfig)
//! DESCRIPTION:     This function returns the current display feature configuration.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] displayId             - Display id.
//! \param [in] pDisplayFeatureConfig - Pointer to the LW_DISPLAY_FEATURE_CONFIG structure. Should not be NULL in any case.
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dispcontrol
//! Information of the features.

typedef struct _LW_DISPLAY_FEATURE_CONFIG
{
    LwU32 version;                           //!< Structure version
    
    LwU32 isPanAndScanEnabled : 1;           //!< Current pan and scan state of the display.
    LwU32 reserved            : 31;          //!< Reserved.
} LW_DISPLAY_FEATURE_CONFIG_V1;

#define LW_DISPLAY_FEATURE_CONFIG_VER1  MAKE_LWAPI_VERSION(LW_DISPLAY_FEATURE_CONFIG_V1, 1)
#define LW_DISPLAY_FEATURE_CONFIG_VER   LW_DISPLAY_FEATURE_CONFIG_VER1

typedef LW_DISPLAY_FEATURE_CONFIG_V1    LW_DISPLAY_FEATURE_CONFIG;

//! \ingroup dispcontrol
LWAPI_INTERFACE LwAPI_DISP_GetFeatureConfig(__in LwU32 displayId, __inout LW_DISPLAY_FEATURE_CONFIG *pDisplayFeatureConfig);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GetDisplayFeatureConfig
//
//! \fn LwAPI_GetDisplayFeatureConfig(LwDisplayHandle hLwDisplay, LW_DISPLAY_FEATURE* pFeature)
//! DESCRIPTION:     This function returns the current display feature configuration.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]      hLwDisplay   LWPU Display selection \n
//!                                #LWAPI_DEFAULT_HANDLE is not allowed, it must be a handle enumerated with LwAPI_EnumLWidiaDisplayHandle().
//! \param [in,out]   feature      Pointer to LW_DISPLAY_FEATURE structure to retrieve the current feature configuration.
//! 
//! \retval           LWAPI_OK                Completed request
//! \retval           LWAPI_ERROR             Miscellaneous error oclwrred
//! \retval           LWAPI_ILWALID_ARGUMENT  Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dispcontrol
//! Used in LwAPI_GetDisplayFeatureConfig() and LwAPI_SetDisplayFeatureConfig().
typedef struct _LW_DISPLAY_FEATURE
{
    LwU32      enableScalerUnderscan  : 1;          //!< Enable/disable HDTV scaler-based resizing.
    LwU32      enableCEoverHDMI       : 1;          //!< Enable/disable the feature to force CE timings over HDMI.
                                                    //!< If this feature is enabled, then CE timings will only be used for HDMI displays.
    LwU32      reservedOEM            : 1;          //!< Reserved bit for OEM configuration
    LwU32      isDriverCtrlCEoverHDMI : 1;          //!< if == 1, the feature "Force CE timing over HDMI" is dynamically controlled by the driver so
                                                    //!< it's selectively enabled/disabled based on internal driver policy.
                                                    //!< if == 0, this feature is statically controlled by the application. 
    LwU32      reserved               : 28;

} LW_DISPLAY_FEATURE; 


//! \ingroup dispcontrol
LWAPI_INTERFACE LwAPI_GetDisplayFeatureConfig(LwDisplayHandle hLwDisplay, LW_DISPLAY_FEATURE* pFeature);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SetDisplayFeatureConfig
//
//! DESCRIPTION:    This sets the display feature configuration.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]     hLwDisplay  LWPU Display selection \n
//!                 #LWAPI_DEFAULT_HANDLE is not allowed, it must be a handle enumerated with LwAPI_EnumLWidiaDisplayHandle().
//! \param [in,out] feature     Copy of LW_DISPLAY_FEATURE structure to set up the new feature configuration
//! 
//! \retval         ::LWAPI_OK                
//! \retval         ::LWAPI_ERROR             
//! \retval         ::LWAPI_ILWALID_ARGUMENT  
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetDisplayFeatureConfig(LwDisplayHandle hLwDisplay, LW_DISPLAY_FEATURE feature);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GetDisplayFeatureConfigDefaults
//
//! DESCRIPTION:     This function returns the default display feature configuration.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 177
//!
//!  \param [in]     hLwDisplay   LWPU display selection.  \n
//!                  #LWAPI_DEFAULT_HANDLE is not allowed, it must be a handle enumerated with LwAPI_EnumLWidiaDisplayHandle().
//!  \param [in,out] feature      A copy of the LW_DISPLAY_FEATURE structure to set up the default feature configuration
//! 
//!  \retval ::LWAPI_OK             
//!  \retval ::LWAPI_ERROR           
//!  \retval ::LWAPI_ILWALID_ARGUMENT 
//!
//!  \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetDisplayFeatureConfigDefaults(LwDisplayHandle hLwDisplay, LW_DISPLAY_FEATURE* pFeature);







///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GetView
//
//! This API lets caller retrieve the target display arrangement for selected source display handle.
//! \note Display PATH with this API is limited to single GPU. DUALVIEW across GPUs will be returned as STANDARD VIEW. 
//!       Use LwAPI_SYS_GetDisplayTopologies() to query views across GPUs.
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use LwAPI_DISP_GetDisplayConfig.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 85
//!
//!  \param [in]     hLwDisplay             LWPU Display selection. It can be #LWAPI_DEFAULT_HANDLE or a handle enumerated from 
//!                                         LwAPI_EnumLWidiaDisplayHandle().
//!  \param [out]    pTargets               User allocated storage to retrieve an array of  LW_VIEW_TARGET_INFO. Can be NULL to retrieve 
//!                                         the targetCount.
//!  \param [in,out] targetMaskCount        Count of target device mask specified in pTargetMask.
//!  \param [out]    targetView             Target view selected from LW_TARGET_VIEW_MODE.
//!
//!  \retval         LWAPI_OK               Completed request
//!  \retval         LWAPI_ERROR            Miscellaneous error oclwrred
//!  \retval         LWAPI_ILWALID_ARGUMENT Invalid input parameter.
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use LwAPI_DISP_GetDisplayConfig.")
LWAPI_INTERFACE LwAPI_GetView(LwDisplayHandle hLwDisplay, LW_VIEW_TARGET_INFO *pTargets, LwU32 *pTargetMaskCount, LW_TARGET_VIEW_MODE *pTargetView);







///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GetViewEx
//
//! DESCRIPTION:    This API lets caller retrieve the target display arrangement for selected source display handle.
//!                 \note Display PATH with this API is limited to single GPU. DUALVIEW across GPUs will be returned as STANDARD VIEW. 
//!                       Use LwAPI_SYS_GetDisplayTopologies() to query views across GPUs.
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use LwAPI_DISP_GetDisplayConfig.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//!
//! \param [in]     hLwDisplay       LWPU Display selection. #LWAPI_DEFAULT_HANDLE is not allowed, it has to be a handle enumerated with
//!                                  LwAPI_EnumLWidiaDisplayHandle().
//! \param [in,out] pPathInfo        Count field should be set to LWAPI_MAX_DISPLAY_PATH. Can be NULL to retrieve just the pathCount.
//! \param [in,out] pPathCount       Number of elements in array pPathInfo->path.
//! \param [out]    pTargetViewMode  Display view selected from LW_TARGET_VIEW_MODE.
//!
//! \retval         LWAPI_OK                      Completed request
//! \retval         LWAPI_API_NOT_INTIALIZED      LWAPI not initialized
//! \retval         LWAPI_ERROR                   Miscellaneous error oclwrred
//! \retval         LWAPI_ILWALID_ARGUMENT        Invalid input parameter.
//! \retval         LWAPI_EXPECTED_DISPLAY_HANDLE hLwDisplay is not a valid display handle.
//! 
//! \ingroup dispcontrol   
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use LwAPI_DISP_GetDisplayConfig.")
LWAPI_INTERFACE LwAPI_GetViewEx(LwDisplayHandle hLwDisplay, LW_DISPLAY_PATH_INFO *pPathInfo, LwU32 *pPathCount, LW_TARGET_VIEW_MODE *pTargetViewMode);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GetSupportedViews
//
//!  This API lets caller enumerate all the supported LWPU display views - lwiew and Dualview modes.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 85
//!
//!  \param [in]     hLwDisplay             LWPU Display selection. It can be #LWAPI_DEFAULT_HANDLE or a handle enumerated from
//!                                         LwAPI_EnumLWidiaDisplayHandle().
//!  \param [out]    pTargetViews           Array of supported views. Can be NULL to retrieve the pViewCount first.
//!  \param [in,out] pViewCount             Count of supported views.
//!
//!  \retval         LWAPI_OK               Completed request
//!  \retval         LWAPI_ERROR            Miscellaneous error oclwrred
//!  \retval         LWAPI_ILWALID_ARGUMENT Invalid input parameter.
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetSupportedViews(LwDisplayHandle hLwDisplay, LW_TARGET_VIEW_MODE *pTargetViews, LwU32 *pViewCount);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GetSupportedViewsEx
//
//! DESCRIPTION:     This API lets caller enumerate all the supported LWPU display views - lwiew and DualView modes.
//!                  Same as LwAPI_GetSupportedViews() except it takes a flag to return cached or uncached connections.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      hLwDisplay      LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [out]     pTargetViews    Array of supported views. Can be NULL to retrieve the pViewCount first.
//! \param [in,out]  pViewCount      Count of supported views.
//! \param [in]      flag            Uncached (re-scanned) connected devices or cached connected devices
//!
//! \retval ::LWAPI_OK                completed request
//! \retval ::LWAPI_ERROR             miscellaneous error oclwrred
//! \retval ::LWAPI_ILWALID_ARGUMENT  Invalid input parameter.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetSupportedViewsEx(LwDisplayHandle hLwDisplay, LW_TARGET_VIEW_MODE *pTargetViews, LwU32 *pViewCount, LwU32 flag);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SetViewExInternal
//
//! The description and usage is the same as LwAPI_SetViewEx(). Used only in Sedona. This API does not check for the inhibit state.
//! \note Display PATH with this API is limited to single GPU. DUALVIEW across GPUs cannot be enabled with this API. 
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use LwAPI_DISP_SetDisplayConfig.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use LwAPI_DISP_SetDisplayConfig.")
LWAPI_INTERFACE LwAPI_SetViewExInternal(LwDisplayHandle hLwDisplay, LW_DISPLAY_PATH_INFO *pPathInfo, LW_TARGET_VIEW_MODE displayView);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_DISP_IsFullscreenAppRunning
//
//!   DESCRIPTION:  This API queries whether the application is running in full-screen mode or not.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 185
//!
//! \param [in] hLwDisplay      LWPU Display selection. LWAPI_DEFAULT_HANDLE is not allowed, it has to be a handle enumerated with LwAPI_EnumLWidiaDisplayHandle().
//! \param [in] pFullScreenApp  Pointer to pFullScreenApp.
//!                                 
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND 
//! \retval ::LWAPI_EXPECTED_DISPLAY_HANDLE    hLwDisplay is not a valid display handle.
//! \retval ::LWAPI_ILWALID_ARGUMENT           pFullScreenApp is NULL.
//! \retval ::LWAPI_NO_IMPLEMENTATION  
//! \retval ::LWAPI_ERROR  
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_IsFullscreenAppRunning(LwDisplayHandle hLwDisplay, LwU32 *pFullScreenApp);











///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_SetHDMIAudioStreamMute
//
//! \fn LwAPI_SetHDMIAudioStreamMute(LwDisplayHandle hLwDisplay, LwU32 outputId, LW_HDMI_AUDIO_INFO* pLwHdmiAudioInfo)
//! DESCRIPTION:   This API signals the driver to turn mute ON or OFF on the HDMI audio stream.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \param [in]    hLwDisplay        LWPU Display selection. It can be #LWAPI_DEFAULT_HANDLE or a handle enumerated 
//!                                  from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]    outputId          The display output ID for the HDMI display. If it's "0", then the default 
//!                                  outputId from LwAPI_GetAssociatedDisplayOutputId() will be used. See \ref handles.
//! \param [in]    pLwHdmiAudioInfo  Pointer to LW_HDMI_AUDIO_INFO which contains the audio stream mute value for the HDMI display. 
//!
//! \retval        LWAPI_OK                Completed request
//! \retval        LWAPI_NOT_SUPPORTED     Display output ID is for non-active HDMI display.
//! \retval        LWAPI_ERROR             Miscellaneous error oclwrred.
//! \retval        LWAPI_ILWALID_ARGUMENT  Invalid input parameter.
///////////////////////////////////////////////////////////////////////////////


//! \ingroup dispcontrol
//! HDMI Audio Stream Mute \n
//! Used in LW_HDMI_AUDIO_INFO
typedef enum _LW_HDMI_AUDIO_STREAM_MUTE_STATUS
{
    LW_SET_HDMI_AUDIO_STREAM_MUTE_OFF  = 0x00, //!< Set mute Off
    LW_SET_HDMI_AUDIO_STREAM_MUTE_ON   = 0x01, //!< Set mute On
} LW_HDMI_AUDIO_STREAM_MUTE_STATUS;



//!  \ingroup dispcontrol
//!  Used in LwAPI_SetHDMIAudioStreamMute()
typedef struct 
{
    LwU32 version;
    LW_HDMI_AUDIO_STREAM_MUTE_STATUS lwHdmiAudioMute; //!< See LW_HDMI_AUDIO_STREAM_MUTE_STATUS documentation.  
} LW_HDMI_AUDIO_INFO;
 

//! \ingroup dispcontrol
#define LW_HDMI_AUDIO_INFO_VER  MAKE_LWAPI_VERSION(LW_HDMI_AUDIO_INFO,1)


//! \ingroup       dispcontrol        
LWAPI_INTERFACE LwAPI_SetHDMIAudioStreamMute(LwDisplayHandle hLwDisplay, LwU32 outputId, LW_HDMI_AUDIO_INFO* pLwHdmiAudioInfo);








//! \ingroup dispcontrol
//! See _LW_DPCD_PARAMS.
#define LWAPI_DPCD_MAX_DATA_SIZE 16

//! \ingroup dispcontrol 
//! Used in _LW_DPCD_PARAMS.
typedef enum _LW_DPCD_CMD
{
    LW_DP_AUXCH_CMD_REQ_TYPE_WRITE = 0,             //!< DisplayPort Aux Channel write
    LW_DP_AUXCH_CMD_REQ_TYPE_READ,                  //!< DisplayPort Aux Channel read    
    LW_DP_AUXCH_CMD_REQ_TYPE_I2C_WRITE,             //!< I2C write request
    LW_DP_AUXCH_CMD_REQ_TYPE_I2C_READ,              //!< I2C read request
    LW_DP_AUXCH_CMD_REQ_TYPE_I2C_WRITE_STATUS,      //!< I2C write status request
    LW_DP_AUXCH_CMD_REQ_TYPE_MOT_I2C_WRITE,         //!< I2C write request in the middle of the transaction     
    LW_DP_AUXCH_CMD_REQ_TYPE_MOT_I2C_READ           //!< I2C read request in the middle of the transaction 

} LW_DPCD_CMD;

//! \ingroup dispcontrol
//! Used in _LW_DPCD_PARAMS.
typedef enum _LW_DPCD_REPLY_TYPE
{
    LW_DP_AUXCH_REPLYTYPE_ACK = 0,                  //!< For write: transaction completed and all data bytes are written.
                                                    //!< For read: ACK indicates it is ready for another read request.
    LW_DP_AUXCH_REPLYTYPE_NACK,                     //!< For write: the first return size bytes have been written.
                                                    //!< For read: there is no requested data for the read request transaction.
    LW_DP_AUXCH_REPLYTYPE_DEFER,                    //!< Not ready for the write/read request and client should retry later.    
    LW_DP_AUXCH_REPLYTYPE_TIMEOUT = 0xFF            //!< The receiver did not respond within the time-out period defined in the DisplayPort 1.1a specification.
} LW_DPCD_REPLY_TYPE;

//! \ingroup discontrol
//! Used in LwAPI_Disp_DpAuxChannelControl().
typedef struct _LW_DPCD_PARAMS_V1
{
    LwU32                version;                        //!< Structure version
    LwU32                displayId;                      //!< LwAPI displayId of the DisplayPort 
    LW_DPCD_CMD          cmd;                            //!< See ::_LW_DPCD_CMD
    LwU32                addr;                           //!< Address for read/write
    LwU8                 data[LWAPI_DPCD_MAX_DATA_SIZE]; //!< Data for the read/write command
    LwU32                size;                           //!< Number of bytes to read/write. The input size value should be indexed from 0. Returns
                                                         //!  the total number of data bytes successfully read/written, indexed from 1.
    LW_DPCD_REPLY_TYPE   replyType;                      //!< See ::_LW_DPCD_REPLY_TYPE
} LW_DPCD_PARAMS_V1;

//! \ingroup discontrol
//! Used in LwAPI_Disp_DpAuxChannelControl().
typedef struct _LW_DPCD_PARAMS_V2
{
    LwU32                version;                        //!< Structure version
    LwU32                displayId;                      //!< IN - LwAPI displayId of the DisplayPort
    LW_DPCD_CMD          cmd;                            //!< IN - See ::_LW_DPCD_CMD
    LwU32                addr;                           //!< IN - Address for read/write
    LwU8                 data[LWAPI_DPCD_MAX_DATA_SIZE]; //!< IN/OUT - Data for the read/write command
    LwU32                size;                           //!< IN/OUT - Number of bytes to read/write. The input size value should be indexed from 0. Returns
                                                         //!  the total number of data bytes successfully read/written, indexed from 1.
    LW_DPCD_REPLY_TYPE   replyType;                      //!< OUT - See ::_LW_DPCD_REPLY_TYPE
    LW_DP_ADDRESS        auxAddress;                     //!< IN - The AUX address that is associated with the device in a multi stream topology
                                                         //!< When this is set, the above displayId should be set to the root connector on which 
                                                         //!< the multi stream topology is hosted. When the displayId of a sink device is set in 
                                                         //!< the above field, this auxAddress input will be ignored
} LW_DPCD_PARAMS_V2;

//! \ingroup discontrol
//! Macro for constructing the version field of _LW_DPCD_PARAMS
#define LW_DPCD_PARAMS_VER1  MAKE_LWAPI_VERSION(LW_DPCD_PARAMS_V1, 1)
#define LW_DPCD_PARAMS_VER2  MAKE_LWAPI_VERSION(LW_DPCD_PARAMS_V2, 2)
#define LW_DPCD_PARAMS_VER  LW_DPCD_PARAMS_VER2

typedef LW_DPCD_PARAMS_V2   LW_DPCD_PARAMS;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Disp_DpAuxChannelControl
//
//! DESCRIPTION:  This API read/writes to the DisplayPort Aux Channel 
//!               The DisplayPort display needs to be active for this LwAPI call.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]     hLwDisplay   Display handle associated with the attached DisplayPort monitor
//! \param [in,out] pDpcdParams  Pointer to _LW_DPCD_PARAMS structure for input/output parameters
//! \param [in]     reserved     Reserved for future use.
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Disp_DpAuxChannelControl(__in LwDisplayHandle hLwDisplay, __inout LW_DPCD_PARAMS *pDpcdParams, __in LwU32 reserved);



//! \ingroup dispcontrol
typedef enum _LW_DP_TESTPATTERN_DATA
{
    LW_DP_TESTPATTERN_DATA_NONE,
    LW_DP_TESTPATTERN_DATA_D10_2,
    LW_DP_TESTPATTERN_DATA_SERMP,
    LW_DP_TESTPATTERN_DATA_PRBS_7,
    LW_DP_TESTPATTERN_DATA_CSTM,
    LW_DP_TESTPATTERN_DATA_HBR2COMPLIANCE
} LW_DP_TESTPATTERN_DATA;

//! This structure specifies the 80 bit DP CSTM Test Pattern data
//! \ingroup dispcontrol
typedef struct _LW_DP_TESTPATTERN_CSTM
{
    LwU32 lower;            //!< specifies bits 31:0
    LwU32 middle;           //!< specifies bits 63:32
    LwU32 upper;            //!< specifies bits 79:64
} LW_DP_TESTPATTERN_CSTM;

//! \ingroup dispcontrol
typedef struct _LW_DP_TESTPATTERN
{
    LwU32                                   version;            //!< structure version

    LwU32                                   rootDisplayId;      //!< LwAPI displayID of the root DP connector (IN)
    LW_DP_TESTPATTERN_DATA                  testPattern;        //!< Testpattern on the displayport (IN/OUT depending on the get/set)
    LW_DP_TESTPATTERN_CSTM                  cstmTestPattern;    //!< If the test pattern is of type CSTM, then this holds the data (IN/OUT depending on the get/set)
    LwU32                                   isHBR2  : 1;        //!< Specifies if this is for HBR2 compliance test (IN)
    LwU32                                   laneMask: 8;        //!< Each bit corresponds to a lane i.e. bit 0 => lane 0, bit 1 => lane 1 etc (IN)
    LwU32                                   reserved: 23;       //!< Should be set to ZERO

} LW_DP_TESTPATTERN_V1;

#define LW_DP_TESTPATTERN_VER1  MAKE_LWAPI_VERSION(LW_DP_TESTPATTERN_V1,1)
#define LW_DP_TESTPATTERN_VER   LW_DP_TESTPATTERN_VER1

typedef LW_DP_TESTPATTERN_V1    LW_DP_TESTPATTERN;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Disp_DP_SetTestPattern
//
//!   DESCRIPTION: This API sets the Physical Test Pattern on the DisplayPort.
//!                Test patterns that can lwrrently be set are defined by LW_DP_TESTPATTERN_DATA 
//!                To stop the test pattern, a test pattern of LW_DP_TESTPATTERN_DATA_NONE needs to be set.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] pDpTestPattern  Pointer to LW_DP_TESTPATTERN structure
//!
//! \return     This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!             specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Disp_DP_SetTestPattern(__in LW_DP_TESTPATTERN *pDpTestPattern);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Disp_DP_GetTestPattern
//
//!   DESCRIPTION: This API gets the Physical Test Pattern on the DisplayPort.
//!                Test patterns that are lwrrently supported are defined by LW_DP_TESTPATTERN_DATA 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out] pDpTestPattern  Pointer to LW_DP_TESTPATTERN structure
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Disp_DP_GetTestPattern(__inout LW_DP_TESTPATTERN *pDpTestPattern);


//! \ingroup dispcontrol
#define LW_DP_MAX_LANES 4
typedef enum 
{
    LW_DP_PREEMPHASIS_LEVEL_NONE,        //!< No-preemphais for this lane.
    LW_DP_PREEMPHASIS_LEVEL_1,           //!< Preemphasis set to 3.5 dB.
    LW_DP_PREEMPHASIS_LEVEL_2,           //!< Preemphasis set to 6.0 dB.
    LW_DP_PREEMPHASIS_LEVEL_3            //!< Preemphasis set to 9.5 dB.
} LW_DP_PREEMPHASIS_LEVEL;

//! \ingroup dispcontrol
typedef enum 
{
    LW_DP_DRIVE_LWRRENT_LEVEL_0,        //!< Drive current level set to 8 mA
    LW_DP_DRIVE_LWRRENT_LEVEL_1,        //!< Drive current level set to 12 mA
    LW_DP_DRIVE_LWRRENT_LEVEL_2,        //!< Drive current level set to 16 mA
    LW_DP_DRIVE_LWRRENT_LEVEL_3         //!< Drive current level set to 24 mA
} LW_DP_DRIVE_LWRRENT_LEVEL;

//! \ingroup dispcontrol
typedef struct _LW_DP_LANE_DATA
{
    LW_DP_PREEMPHASIS_LEVEL     preEmphasisLevel;
    LW_DP_DRIVE_LWRRENT_LEVEL   driveLwrrent;
} LW_DP_LANE_DATA;

//! \ingroup dispcontrol
typedef struct _LW_DP_LANE_CONFIG
{
    LwU32                   version;                   //!< structure version

    LwU32                   rootDisplayId;             //!< displayID of the root DP connector (IN)
    LwU32                   numLanes;                  //!< Number of DP lanes    (IN/OUT depending on the get/set)
    LW_DP_LANE_DATA         data[LW_DP_MAX_LANES];     //!< Lane data i.e. preemphasis & drive current (IN/OUT depending on the get/set)
} LW_DP_LANE_CONFIG_V1;

#define LW_DP_LANE_CONFIG_VER1  MAKE_LWAPI_VERSION(LW_DP_LANE_CONFIG_V1,1)
#define LW_DP_LANE_CONFIG_VER   LW_DP_LANE_CONFIG_VER1

typedef LW_DP_LANE_CONFIG_V1    LW_DP_LANE_CONFIG;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Disp_DP_SetLaneConfig
//
//!   DESCRIPTION: This API sets the Pre-Emphasis/DriveLwrrent Level for 
//!                each lane on the DisplayPort.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] pDpLaneConfig  Pointer to LW_DP_LANE_CONFIG structure
//!
//! \return     This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!             specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Disp_DP_SetLaneConfig(__in LW_DP_LANE_CONFIG *pDpLaneConfig);







///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Disp_DP_GetLaneConfig
//
//!   DESCRIPTION: This API gets the Pre-Emphasis/DriveLwrrent Level for 
//!                each lane on the DisplayPort.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] pDpLaneConfig  Pointer to LW_DP_LANE_CONFIG structure
//!
//! \return     This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!             specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Disp_DP_GetLaneConfig(__inout LW_DP_LANE_CONFIG *pDpLaneConfig);



//! \ingroup dispcontrol
//! Used in LW_DP_LINK_CONFIG
typedef enum _LW_DP_LINK_CONFIG_CMD
{
    LW_DP_LINK_CONFIG_CMD_GET = 0,         //!< get the current link configuration
    LW_DP_LINK_CONFIG_CMD_SET              //!< set the Link Configuration

}LW_DP_LINK_CONFIG_CMD;

//! \ingroup dispcontrol
//! Used in LwAPI_DISP_DP_LinkConfiguration().
typedef struct _LW_DP_LINK_CONFIG_V1
{
    LwU32                   version;                   //!< (IN)     structure version
    LwU32                   rootDisplayId;             //!< (IN)     displayID of the root DP connector
    LW_DP_LINK_CONFIG_CMD   cmd;                       //!< (IN)     see :: _LW_DP_LINK_CONFIG_CMD
    LwU8                    useDefaults;               //!< (IN)     Valid for _CMD_SET only.
                                                       //!<          1: Let the driver pick the default link config based on current resolution/bpc settings.
                                                       //!<             The fields below are ignored if this is set to true.
                                                       //!<          0: Use the input settings specified below.
    LW_DP_LINK_RATE         linkRate;                  //!< (IN/OUT) _CMD_GET : current link rate;  _CMD_SET : the new link rate
    LwU32                   laneCount;                 //!< (IN/OUT) _CMD_GET : current lane count; _CMD_SET : the new lane count 
    LwU32                   forceLinkConfig:1;         //!< (IN)     Force the change even if it cannot support the bandwidth requirements of current display modes.
                                                       //!<          Valid for _CMD_SET only.
    LwU32                   forceRGDivMode: 1;         //!< (IN)     Force the hardware into RG Div mode - used for testing only. Valid for _CMD_SET only.
    LwU32                   reserved:       30;        //!<          should be set to zero
}LW_DP_LINK_CONFIG_V1;

#define LW_DP_LINK_CONFIG_VER1  MAKE_LWAPI_VERSION(LW_DP_LINK_CONFIG_V1,1)
#define LW_DP_LINK_CONFIG_VER   LW_DP_LINK_CONFIG_VER1

typedef LW_DP_LINK_CONFIG_V1    LW_DP_LINK_CONFIG;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DISP_DP_LinkConfiguration
//
//!  DESCRIPTION: This API gets or sets the Link Configuration for the link
//!               associated with the connector specified by the rootDisplayId.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out] pLwDpLinkConfig  Pointer to the LW_DP_LINK_CONFIG structure.
//!
//! \return     This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!             specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_DP_LinkConfiguration(__inout LW_DP_LINK_CONFIG *pLwDpLinkConfig);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Diag_DPCD
//
//!  DESCRIPTION: This function makes a control call to the resource manager to set/get DPCD.
//!
//! \deprecated  Do not use this function - it is deprecated in release 295. Instead, use LwAPI_Disp_DpAuxChannelControl.
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 170
//!
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_OK
//! \retval ::LWAPI_NOT_SUPPORTED
//! \retval ::LWAPI_ILWALID_ARGUMENT
//! \retval ::LWAPI_API_NOT_INTIALIZED
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 295. Instead, use LwAPI_Disp_DpAuxChannelControl.")
LWAPI_INTERFACE LwAPI_Diag_DPCD(LwPhysicalGpuHandle lwGPUHandle, void *pDpcdParams, LwU32 size);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Diag_DP_TestPattern
//
//!   DESCRIPTION: This function makes a control call to resource manager to set/get(set if BOOL variable 
//!                set is 1, get otherwise) Physical Test Pattern on the DisplayPort. \n
//!                Test patterns that can lwrrently be set include PRBS, D10.2, and 
//!                Symbol Error Rate Measurement(SERM). To stop the test pattern,
//!                a test pattern of "None" needs to be set.
//!
//! \deprecated  Do not use this function - it is deprecated in release 295. Instead, use following functions: LwAPI_Disp_DP_SetTestPattern, LwAPI_Disp_DP_GetTestPattern.
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 170
//!
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_OK
//! \retval ::LWAPI_NOT_SUPPORTED
//! \retval ::LWAPI_ILWALID_ARGUMENT
//! \retval ::LWAPI_API_NOT_INTIALIZED
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 295. Instead, use following functions: LwAPI_Disp_DP_SetTestPattern, LwAPI_Disp_DP_GetTestPattern.")
LWAPI_INTERFACE LwAPI_Diag_DP_TestPattern(LwPhysicalGpuHandle lwGPUHandle, LwU32 set, void *pTestPatternParams, LwU32 size);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Diag_DP_VideoInfo
//
//!   DESCRIPTION: This function makes a control call to RM to set/get(set if BOOL variable set
//!                is 1, get otherwise) the color format on the DisplayPort. \n
//!                Color format includes the bits per component value(6, 8, 10, 12, 16), 
//!                the color space being used (RGB, YCbCr4:2:2, YCbCr4:4:4), 
//!                the dynamic range (VESA, CEA), and the  colorimetry (ITU 601/709).
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 170
//!
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_OK
//! \retval ::LWAPI_NOT_SUPPORTED
//! \retval ::LWAPI_ILWALID_ARGUMENT
//! \retval ::LWAPI_API_NOT_INTIALIZED
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Diag_DP_VideoInfo(LwPhysicalGpuHandle lwGPUHandle, LwU32 set, void *pVideoInfoParams, LwU32 size);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Diag_DP_LaneData
//
//!   DESCRIPTION: This function makes an RM control call to set/get(set if BOOL variable set
//!                is 1, get otherwise) the Pre-Emphasis/DriveLwrrent Level for 
//!                each lane on the DisplayPort.
//!
//! \deprecated  Do not use this function - it is deprecated in release 295. Instead, use following functions: LwAPI_Disp_DP_SetLaneConfig, LwAPI_Disp_DP_GetLaneConfig.
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 170
//!
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_OK
//! \retval ::LWAPI_NOT_SUPPORTED
//! \retval ::LWAPI_ILWALID_ARGUMENT
//! \retval ::LWAPI_API_NOT_INTIALIZED
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 295. Instead, use following functions: LwAPI_Disp_DP_SetLaneConfig, LwAPI_Disp_DP_GetLaneConfig.")
LWAPI_INTERFACE LwAPI_Diag_DP_LaneData(LwPhysicalGpuHandle lwGPUHandle, LwU32 set, void *pLaneDataParams, LwU32 size);






//! \ingroup hybridapi
//! Used in LW_HYBRID_OUTPUTS_INFO.
typedef struct
{
    LwU32               GPUId;          //!< dGPU ID
    LwU32               Devicemask;     //!< Display mask
} LW_HYBRID_GPU_INFO;


//! \ingroup hybridapi
//! Used in LwAPI_GetHybridConnectedOutputs().
typedef struct
{
    LwU32               version;           //!< Structure version
    LwU32               GPUCount;          //!< Number of GPU Info structures
    LW_HYBRID_GPU_INFO  GPUs[LWAPI_MAX_PHYSICAL_GPUS];
}LW_HYBRID_OUTPUTS_INFO;


//! \ingroup hybridapi
//! Macro for constructing the version field of LW_HYBRID_OUTPUTS_INFO
#define LW_HYBRID_OUTPUTS_INFO_VER  MAKE_LWAPI_VERSION(LW_HYBRID_OUTPUTS_INFO,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_GetHybridConnectedOutputs
//
//! DESCRIPTION:    This API returns information about the Hybrid GPUs - dGPU ID and connected device mask array.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \retval   ::LWAPI_OK 
//! \retval   ::LWAPI_ERROR 
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE     LwAPI_GetHybridConnectedOutputs(LW_HYBRID_OUTPUTS_INFO *dGPUInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_GetHybridEDID
//
//! DESCRIPTION:    This API returns the EDID for the specified dGPU and display output on a hybrid system.
//
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \retval   ::LWAPI_OK 
//! \retval   ::LWAPI_ERROR 
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE     LwAPI_GetHybridEDID(LwU32 GPUId, LwU32 displayOutputId, LW_EDID *pEDID);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SendHybridMessage
//
//! \fn LwAPI_SendHybridMessage(LW_HYBRID_MESSAGE msgType, LwU32 param)
//! DESCRIPTION:    This API sends a Hybrid message to lwsvc.
//!
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 173
//!
//! \param [in]     msgType    message type
//! \param [in]     param      message param
//! 
//! \retval         LWAPI_OK                 Completed request
//! \retval         LWAPI_ERROR              Miscellaneous error oclwrred
//! \retval         LWAPI_ILWALID_ARGUMENT   Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup hybridapi
//! Used in LwAPI_SendHybridMessage().
typedef enum _LW_HYBRID_MESSAGE
{
    LW_HYBRID_MESSAGE_D3D_ATTACH           = 0x00,
    LW_HYBRID_MESSAGE_OGL_ATTACH           = 0x01,
    LW_HYBRID_MESSAGE_PROCESS_ATTACH       = 0x02,
    LW_HYBRID_MESSAGE_PROCESS_DETACH       = 0x03,
    LW_HYBRID_MESSAGE_POWER_SETTING        = 0x04,
    LW_HYBRID_MESSAGE_POWER_SOURCE         = 0x05,
    LW_HYBRID_MESSAGE_DISPLAY_SETTING      = 0x06,
    LW_HYBRID_MESSAGE_DOCKING              = 0x07,
    LW_HYBRID_MESSAGE_THERMAL              = 0x08,
    LW_HYBRID_MESSAGE_SETHYBRIDMODE        = 0x09,
} LW_HYBRID_MESSAGE;



//! \ingroup hybridapi
LWAPI_INTERFACE LwAPI_SendHybridMessage(LW_HYBRID_MESSAGE msgType, LwU32 param);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SetHybridMode
//
//! \fn LwAPI_SetHybridMode(LW_HYBRID_MODE mode)
//! DESCRIPTION: This API sets Hybrid mode. Supported on Vista and higher.
//!              Applications calling this API are required to run in elevated mode. 
//!              This API can be called from a system service to derive the elevated context of the System service. 
//!              \note Non-migratable applications that are running can prevent a successful transition.
//!              To query non-migratable applications use LwAPI_QueryNonMigratableApps().
//!
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 173
//!
//! \param [in]     mode     hybrid mode; see ::LW_HYBRID_MODE
//!
//! \retval         LWAPI_OK                 Completed request
//! \retval         LWAPI_ERROR              Miscellaneous error oclwrred
//! \retval         LWAPI_ILWALID_ARGUMENT   Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup hybridapi
//! Used in LwAPI_SetHybridMode(), LwAPI_GetHybridMode(), and LwAPI_SetHybridModeEx().
typedef enum _LW_HYBRID_MODE
{
    LW_HYBRID_MODE_IGPU                 = 0x00,  //!< Integrated GPU
    LW_HYBRID_MODE_DGPU                 = 0x01,  //!< Discrete GPU
    LW_HYBRID_MODE_MULTI_ADAPTER        = 0x02,  //!< Multiple adapters
    LW_HYBRID_MODE_ILWALID              = 0x03,  //!< Invalid mode
    LW_HYBRID_MODE_DGPU_WARMUP          = 0x04,
    LW_HYBRID_MODE_DGPU_DEEP_IDLE       = 0x05,
    LW_HYBRID_MODE_INSTALL              = 0x06,
    LW_HYBRID_MODE_ADAPTIVE             = 0x07, //!< This mode is only applicable for GetSwitchSettings.
} LW_HYBRID_MODE;



//! \ingroup hybridapi
LWAPI_INTERFACE LwAPI_SetHybridMode(LW_HYBRID_MODE mode);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GetHybridMode
//
//! DESCRIPTION:    This function gets the current Hybrid mode. Supported on Vista and higher.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 173
//!
//! \param [out]    pMode     hybrid mode; see ::LW_HYBRID_MODE
//!
//! \retval         LWAPI_OK                 Completed request
//! \retval         LWAPI_ERROR              Miscellaneous error oclwrred
//! \retval         LWAPI_ILWALID_ARGUMENT   Invalid input parameter
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetHybridMode(LW_HYBRID_MODE *pMode);







//! \ingroup hybridapi
//! Reference: Hybrid Spec 3.0 DSM Function HYBRIDCAPS bit 28:27
typedef enum _LW_HYBRID_SWITCH_METHOD
{
    LW_HYBRID_SWITCH_METHOD_NONE                = 0x00, //!< None of physical selector available 
                                    //!< (no hotkey, no physical button/switch, etc.)
    LW_HYBRID_SWITCH_METHOD_UNKNOWN                = 0x01, //!< Uses unspecified means to pass required state via 
                                    //!< POLICYSELECT, or other API
    LW_HYBRID_SWITCH_METHOD_HOTKEY                = 0x02,  
    LW_HYBRID_SWITCH_METHOD_PHYSICAL_SWITCH            = 0x03,
} LW_HYBRID_SWITCH_METHOD;


//! \ingroup hybridapi
typedef struct
{
    LW_HYBRID_SWITCH_METHOD method;
    LwU32                    numberOfWays;    
} LW_HYBRID_TRANSITION_METHOD;







///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GetHybridSwitchStatus
//
//! DESCRIPTION:     This API gets the current Hybrid Switch Status (Hybrid mode).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [out]   pMode      Hybrid mode
//!
//! \retval  ::LWAPI_OK 
//! \retval  ::LWAPI_ERROR 
//! \retval  ::LWAPI_ILWALID_ARGUMENT 
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetHybridSwitchStatus(LW_HYBRID_MODE *pMode);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GetHybridInfo
//
//! \fn LwAPI_GetHybridInfo(LW_HYBRID_INFO *pHybridInfo)
//! DESCRIPTION:     This API queries the valid hybrid modes and the hybrid status. Supported on Vista and higher.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 173
//!
//! \param [in]    pHybridInfo             The hybrid information structure
//!
//! \retval        LWAPI_OK                Completed request
//! \retval        LWAPI_ERROR             Miscellaneous error oclwrred
//! \retval        LWAPI_ILWALID_ARGUMENT  Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup hybridapi
//! Used in LwAPI_GetHybridInfo().
typedef struct
{
    LwU32 version;                          //!< The structure version
    LwU32 validHybridModes;                 //!< ::LW_HYBRID_VALID_MODES mask
    LwU32 hybridStatus;                     //!< ::LW_HYBRID_STATUS mask
} LW_HYBRID_INFO_v1;



//! \ingroup hybridapi
//! Used in LwAPI_GetHybridInfo().
typedef struct
{
    LwU32 version;                          //!< The structure version
    LwU32 validHybridModes;                 //!< ::LW_HYBRID_VALID_MODES mask
    LwU32 hybridStatus;                     //!< ::LW_HYBRID_STATUS mask
    LwU32 hybridDefaultGPU;                 //!< ::LW_GPU_TYPE: default GPU in the current mode
    LwU32 hybridUIState;                    //!< ::LW_HYBRID_STATE : what is the UI icon showing
    LwU32 hybridDriverState;                //!< ::LW_HYBRID_STATE : what state is the driver in
    LwU32 bIsHybridPerfSliSupported:1;      //!< Boolean: 0 = not supported, 1 = supported;
    LwU32 bIsHybridMCP:1;                   //!< Boolean: true if this is an MCP board.
    LwU32 bIsHybridMobileSystem:1;          //!< Boolean: true if a mobile hybrid system
    LwU32 transferNodeType;                 //!< ::LW_HYBRID_TRANSFER_NODE
} LW_HYBRID_INFO_v2;



//! \ingroup hybridapi
//! Used in LwAPI_GetHybridInfo().
typedef struct
{
    LwU32 version;                          //!< The structure version
    LwU32 validHybridModes;                 //!< ::LW_HYBRID_VALID_MODES mask
    LwU32 hybridStatus;                     //!< ::LW_HYBRID_STATUS mask
    LwU32 hybridDefaultGPU;                 //!< ::LW_GPU_TYPE: default GPU in the current mode
    LwU32 hybridUIState;                    //!< ::LW_HYBRID_STATE : what is the UI icon showing
    LwU32 hybridDriverState;                //!< ::LW_HYBRID_STATE : what state is the driver in
    LwU32 bIsHybridPerfSliSupported:1;      //!< Boolean: 0 = not supported, 1 = supported;
    LwU32 bIsHybridMCP:1;                   //!< Boolean: TRUE if this is an MCP board.
    LwU32 bIsHybridMobileSystem:1;          //!< Boolean: TRUE if this is a notebook hybrid system
    LwU32 transferNodeType;                 //!< ::LW_HYBRID_TRANSFER_NODE
    LwU8  showHybridUI;                     //!< (boolean) show the hybrid UI
} LW_HYBRID_INFO_v3;


//! \ingroup hybridapi
//! Used in LwAPI_GetHybridInfo().
typedef struct
{
    LwU32 version;                          //!< The structure version
    LwU32 validHybridModes;                 //!< ::LW_HYBRID_VALID_MODES mask
    LwU32 hybridStatus;                     //!< ::LW_HYBRID_STATUS mask
    LwU32 hybridDefaultGPU;                 //!< ::LW_GPU_TYPE: default GPU in the current mode
    LwU32 hybridUIState;                    //!< ::LW_HYBRID_STATE : what is the UI icon showing
    LwU32 hybridDriverState;                //!< ::LW_HYBRID_STATE : what state is the driver in
    LwU32 bIsHybridPerfSliSupported:1;      //!< Boolean: 0 = not supported, 1 = supported;
    LwU32 bIsHybridMCP:1;                   //!< Boolean: TRUE if this is an MCP board.
    LwU32 bIsHybridMobileSystem:1;          //!< Boolean: TRUE if a notebook hybrid system
    LwU32 transferNodeType;                 //!< ::LW_HYBRID_TRANSFER_NODE
    LwU8  showHybridUI;                     //!< (boolean) show the hybrid UI
    LW_HYBRID_TRANSITION_METHOD transMethod; //!< Method each system uses to transition  
} LW_HYBRID_INFO;





//! \addtogroup hybridapi
//! @{

//! Macro for determining the version field of LW_HYBRID_INFO_v1
#define LW_HYBRID_INFO_VER_1        MAKE_LWAPI_VERSION(LW_HYBRID_INFO_v1, 1)

//! Macro for determining the version field of LW_HYBRID_INFO_v2
#define LW_HYBRID_INFO_VER_2        MAKE_LWAPI_VERSION(LW_HYBRID_INFO_v2, 2)

//! Macro for determining the version field of LW_HYBRID_INFO_v3
#define LW_HYBRID_INFO_VER_3        MAKE_LWAPI_VERSION(LW_HYBRID_INFO_v3, 3)

//! Macro for determining the version field of LW_HYBRID_INFO
#define LW_HYBRID_INFO_VER          MAKE_LWAPI_VERSION(LW_HYBRID_INFO   , 4)

//! @}


//! \ingroup hybridapi
//! Used in LW_HYBRID_INFO, LW_HYBRID_INFO_V1, and LW_HYBRID_INFO_V2.
typedef enum 
{
    LW_HYBRID_STATUS_OK                     = 0x00000000,
    LW_HYBRID_STATUS_CHIPSET_NOT_SUPPORTED  = 0x00000001,
    LW_HYBRID_STATUS_MGPU_NOT_SUPPORTED     = 0x00000002,
    LW_HYBRID_STATUS_DGPU_NOT_SUPPORTED     = 0x00000004,
    LW_HYBRID_STATUS_NO_ASYNC_DMA_ENGINE    = 0x00000008,
    LW_HYBRID_STATUS_SBIOS_NOT_CONFIGURED   = 0x00000010,
    LW_HYBRID_STATUS_DGPUS_NOT_IDENTICAL    = 0x00000020,
    LW_HYBRID_STATUS_ILWALID_GPU_COUNT      = 0x00000040,
    LW_HYBRID_STATUS_DGPU_DEEP_IDLE_NOT_SUPPORTED = 0x00000080
} LW_HYBRID_STATUS;


//! \ingroup hybridapi
//! Used in LW_HYBRID_INFO, LW_HYBRID_INFO_V1, and LW_HYBRID_INFO_V2.
typedef enum 
{
    LW_HYBRID_VALID_MODE_NONE               = 0x00000000,
    LW_HYBRID_VALID_MODE_POWER              = 0x00000001,
    LW_HYBRID_VALID_MODE_PERF               = 0x00000002,
    LW_HYBRID_VALID_MODE_PERFSLI            = 0x00000004,
    LW_HYBRID_VALID_MODE_MULTI_ADAPTER      = 0x00000008,
    LW_HYBRID_VALID_MODE_POWER_DEEP_IDLE    = 0x00000010
} LW_HYBRID_VALID_MODES;


//! \ingroup hybridapi
//! Used in LW_HYBRID_INFO and LW_HYBRID_INFO_v2.
typedef enum _LW_HYBRID_TRANSFER_NODE
{
    LW_HYBRID_TRANSFER_NODE_3D            = 0x00000000,
    LW_HYBRID_TRANSFER_NODE_CIPHER        = 0x00000001,
    LW_HYBRID_TRANSFER_NODE_VP            = 0x00000002,
    LW_HYBRID_TRANSFER_NODE_DMACOPY0      = 0x00000003,
    LW_HYBRID_TRANSFER_NODE_DMACOPY1      = 0x00000004,
    LW_HYBRID_TRANSFER_NODE_UNKNOWN       = 0xFFFFFFFF
} LW_HYBRID_TRANSFER_NODE;


//! \ingroup hybridapi
//! Used in LW_HYBRID_INFO, LW_HYBRID_INFO_V1, and LW_HYBRID_INFO_V2.
typedef enum _LW_HYBRID_STATE
{
    LW_HYBRID_STATE_POWER              = 0x00000000,
    LW_HYBRID_STATE_PERF               = 0x00000001,
    LW_HYBRID_STATE_MULTI_ADAPTER      = 0x00000002,
    LW_HYBRID_STATE_ILWALID            = 0xFFFFFFFF,
} LW_HYBRID_STATE;



//! \ingroup hybridapi
LWAPI_INTERFACE LwAPI_GetHybridInfo(LW_HYBRID_INFO *pHybridInfo);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Coproc_GetCoprocStatus
//
//! \fn LwAPI_Coproc_GetCoprocStatus(LwU32 *pCoprocStatus, LW_COPROC_STATE* pCoprocState)
//! DESCRIPTION:     This API queries the the coproc status and state. 
//!                  Supported on Vista and higher.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out]      pCoprocStatus  The coproc status
//! \param [in,out]      pCoprocState   The coproc state
//!
//! \retval ::LWAPI_OK              Completed request
//! \retval ::LWAPI_NOT_SUPPORTED   This feature is not supported on Windows XP
//! \retval ::LWAPI_API_NOT_INTIALIZED  You must call LwAPI_Initialize first
//! \retval ::LWAPI_ERROR               Miscellaneous error oclwrred
//! \retval ::LWAPI_ILWALID_ARGUMENT    Invalid input parameter
///////////////////////////////////////////////////////////////////////////////

//! \ingroup coprocapi
//! Used in LwAPI_Coproc_GetCoprocStatus().
typedef enum _LW_COPROC_STATUS
{
    LW_COPROC_STATUS_OK                        = 0x00000000,
    LW_COPROC_STATUS_CHIPSET_NOT_SUPPORTED     = 0x00000001,
    LW_COPROC_STATUS_MGPU_NOT_SUPPORTED        = 0x00000002,
    LW_COPROC_STATUS_DGPU_NOT_SUPPORTED        = 0x00000004,
    LW_COPROC_STATUS_ILWALID_GPU_COUNT         = 0x00000008,
    LW_COPROC_STATUS_DISABLED_BY_REG_KEY       = 0x00000010,
    LW_COPROC_STATUS_DGPU_POSTING_DEVICE       = 0x00000020,
    LW_COPROC_STATUS_DISABLED_BY_HYBRID        = 0x00000040,
    LW_COPROC_STATUS_OS_NOT_SUPPORTED          = 0x00000080,
    LW_COPROC_STATUS_SBIOS_NOT_CONFIGURED      = 0x00000100,
    LW_COPROC_STATUS_DGPU_NOT_SUPPORTED_BY_MSHYBRID = 0x00000200,
    LW_COPROC_STATUS_TRANSCODE_ONLY_NOT_SUPPORTED   = 0x00000400,
} LW_COPROC_STATUS;

typedef enum _LW_COPROC_PROBLEM_TYPE
{
    LW_COPROC_PROBLEM_MISC               =  0x00000001, 
    LW_COPROC_PROBLEM_DISABLED           =  0x00000002, 
    LW_COPROC_PROBLEM_DDI_ACQUIRE        =  0x00000004, 
    LW_COPROC_PROBLEM_BUS_SCAN           =  0x00000008, 
    LW_COPROC_PROBLEM_POWER_EVENT        =  0x00000010, 
    LW_COPROC_PROBLEM_PS_RULE            =  0x00000020, 
    LW_COPROC_PROBLEM_ACPI               =  0x00000040, 
    LW_COPROC_PROBLEM_DEVICE             =  0x00000080, 
    LW_COPROC_PROBLEM_OUTSTANDING_LOCK   =  0x00000100, 
    LW_COPROC_PROBLEM_CPUVISIBLE_SURFACE =  0x00000200, 
    LW_COPROC_PROBLEM_SRLESS_MONITOR     =  0x00000400, 
    LW_COPROC_PROBLEM_AUDIO_MONITOR      =  0x00000800, 
    LW_COPROC_PROBLEM_FLIP               =  0x00001000, 
    LW_COPROC_PROBLEM_CMD_BUF            =  0x00002000,
    LW_COPROC_PROBLEM_DEFERRED_WORK      =  0x00004000,
    LW_COPROC_PROBLEM_SR_INACTIVE        =  0x00008000,
} LW_COPROC_PROBLEM_TYPE;

//! \ingroup coprocapi
//! Used in LwAPI_Coproc_GetCoprocStatus().
typedef enum _LW_COPROC_STATE
{
    LW_COPROC_STATE_DGPU_GOLD              = 0x00000000,
    LW_COPROC_STATE_DGPU_ON                = 0x00000001,
    LW_COPROC_STATE_DGPU_GC6               = 0x00000002,
} LW_COPROC_STATE;

//! \ingroup coprocapi
//! Used in LwAPI_Coproc_GetCoprocInfo().

//! JT flags represent the JT GPU capabilities.
typedef enum _LW_JT_FLAGS
{
    LW_JT_FLAGS_NONE                        = 0x00000000,
    LW_JT_FLAGS_GC6_ENABLED                 = 0x00000001,
    LW_JT_FLAGS_SUPPORTS_GC6_TDR            = 0x00000002,
} LW_JT_FLAGS;

//! \ingroup coprocapi
LWAPI_INTERFACE LwAPI_Coproc_GetCoprocStatus(LwU32 *pCoprocStatus, LW_COPROC_STATE* pCoprocState);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Coproc_GetCoprocInfo
//
//! \fn LwAPI_Coproc_GetCoprocInfo(LW_COPROC_INFO *pCoprocInfo)
//!
//! DESCRIPTION:     This API queries the the copoc status. Supported on Vista and higher.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      pCoprocInfo (IN)     - the coproc info structure
//!
//! RETURN STATUS:
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup coprocapi
typedef struct
{
    LwU32 version;                      //!< the structure version
    LwU32 coprocStatusMask;             //!< LW_COPROC_STATUS mask
    LwU32 coprocFlags;                  //!< LW_COPROC_FLAGS mask
    LwU32 totalReferenceCount;          //!< Sum of references keeping the GPU powered up.
    LwU32 deviceCount;                  //!< Devices created on GPU
    LwU32 allocationCount;              //!< Allocations created on GPU
    LwU32 activeEntryPointCount;        //!< Active calls into the KMD.
    LwU32 timeInLwrrentStateMs;         //!< in ms
    LwU32 timeInLastStateMs;            //!< in ms
    LwU8  lwrrentState;                 //!< State LW_COPROC_STATE
    LwU8  lastState;                    //!< State LW_COPROC_STATE
} LW_COPROC_INFO_V1;

typedef struct
{
    LwU32 version;                      //!< the structure version
    LwU32 coprocStatusMask;             //!< LW_COPROC_STATUS mask
    LwU32 coprocFlags;                  //!< LW_COPROC_FLAGS mask
    LwU32 totalReferenceCount;          //!< Sum of references keeping the GPU powered up.
    LwU32 deviceCount;                  //!< Devices created on GPU
    LwU32 allocationCount;              //!< Allocations created on GPU
    LwU32 activeEntryPointCount;        //!< Active calls into the KMD.
    LwU32 timeInLwrrentStateMs;         //!< in ms
    LwU32 timeInLastStateMs;            //!< in ms
    LwU8  lwrrentState;                 //!< State LW_COPROC_STATE
    LwU8  lastState;                    //!< State LW_COPROC_STATE
    LwU32 goldMask;                     //!< bitfield of the reasons Gold is not active from LW_COPROC_REF_TYPE
    LwU32 GC6Mask;                      //!< bitfield of the reasons GC6 is not active from LW_COPROC_REF_TYPE
    LwU32 JTFlags;                      //!< JT State LW_JT_FLAGS_

} LW_COPROC_INFO_V2;



//! \ingroup coprocapi
//! Macro for constructingthe version field of ::LW_COPROC_INFO

typedef LW_COPROC_INFO_V2 LW_COPROC_INFO;

#define LW_COPROC_INFO_VER_1  MAKE_LWAPI_VERSION(LW_COPROC_INFO_V1,1)
#define LW_COPROC_INFO_VER_2  MAKE_LWAPI_VERSION(LW_COPROC_INFO_V2,2)
#define LW_COPROC_INFO_VER    LW_COPROC_INFO_VER_2

//! \ingroup coprocapi
typedef enum _LW_COPROC_FLAGS
{
    LW_COPROC_FLAGS_NONE                          = 0x00000000,
    LW_COPROC_FLAGS_MONITOR_FOUND                 = 0x00000001,
    LW_COPROC_FLAGS_TIMER_SCHEDULED               = 0x00000002,
    LW_COPROC_FLAGS_GOLD_ON_HYBRID                = 0x00000004, 
    LW_COPROC_FLAGS_CHECK_SBIOS_COOKIE            = 0x00000008,
    LW_COPROC_FLAGS_SBIOS_NOT_CONFIGURED          = 0x00000010,
    LW_COPROC_FLAGS_IGPU_MODE_ONLY                = 0x00000020,   //!< Indicates whether IGPU is forced
    LW_COPROC_FLAGS_HDMI_AUDIO_DYNAMIC            = 0x00000040,
    LW_COPROC_FLAGS_FORCE_GPU_SWITCH_AVAILABLE    = 0x00000080,   //!< Indicates whether we are providing the Force GPU switch feature
    LW_COPROC_FLAGS_FORCE_OPTIMUS                 = 0x00000100,   //!< Indicates that we have to set Optimus mode and override FORCE_IGPU \ FORCE_DGPU if set.
    LW_COPROC_FLAGS_REQUIRED_SBIOS_COOKIE         = 0x00000200,   //!< Indicates whether SBIOS cookie is required
    LW_COPROC_FLAGS_DGPU_MODE_ONLY                = 0x00000400,   //!< Indicates whether DGPU is forced
    LW_COPROC_FLAGS_ENABLE_FRAMERATE_LIMITER      = 0x00000800,   //!< Indicates if FRL is permitted
    LW_COPROC_FLAGS_FWD_OPTIMUS                   = 0x00001000,   //!< Indicates if we should support forward (normal) optimus
    LW_COPROC_FLAGS_TRANSCODE                     = 0x00002000,   //!< Indicates if we should support limited reverse optimus for transcode
    LW_COPROC_FLAGS_GPU_SOLDERED_ON_MB            = 0x00004000,   //!< Indicates whether DGPU motherboard soldered or not. 
    LW_COPROC_FLAGS_MS_HYBRID                     = 0x00008000,   //!< Indicates whether it is MS-Hybrid. 
} LW_COPROC_FLAGS;

//! \ingroup coprocapi
LWAPI_INTERFACE LwAPI_Coproc_GetCoprocInfo(__inout LW_COPROC_INFO *pCoprocInfo);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Coproc_SetCoprocInfoFlags
//
//! DESCRIPTION:     This API sets values in the coproc info flags.
//!                  The mask that can be changed is LW_COPROC_FLAGS_IGPU_MODE_ONLY
//!                  Passing in 0 unsets LW_COPROC_FLAGS_IGPU_MODE_ONLY in LW_COPROC_INFO.coprocFlags
//!                  Passing LW_COPROC_FLAGS_IGPU_MODE_ONLY sets LW_COPROC_FLAGS_IGPU_MODE_ONLY 
//!                  in LW_COPROC_INFO.coprocFlags
//!                  All other masks are left untouched.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      LwU32 (IN)     - the mask to be set
//!
//! RETURN STATUS:
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup coprocapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Coproc_SetCoprocInfoFlags(LwU32 coprocInfoFlags);



//! \ingroup coprocapi
typedef struct 
{
    LwU32  version;
    LwU32  is_IGPU_MODE_ONLY : 1;   //!< Indicates if the IGPU_MODE_ONLY flag is set or needs to be set
    LwU32  is_DGPU_MODE_ONLY : 1;   //!< Indicates if the DGPU_MODE_ONLY flag is set or needs to be set
    LwU32  reserved          : 30;  //!< Should be set to ZERO
} LW_COPROC_FLAGS_EX;

//! \ingroup coprocapi
#define LW_COPROC_FLAGS_EX_VER          MAKE_LWAPI_VERSION(LW_COPROC_FLAGS_EX, 1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Coproc_SetCoprocInfoFlagsEx
//
//! DESCRIPTION:     This API sets the coproc info flags.
//!
//! \param [in]      coprocInfoExFlags  pointer to the LW_COPROC_FLAGS_EX indicating the mask to be set
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::LWAPI_OK                  completed request
//! \retval ::LWAPI_ERROR               miscellaneous error oclwrred
//! \retval ::LWAPI_ILWALID_POINTER     null input parameter
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION
//!
//! \ingroup coprocapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Coproc_SetCoprocInfoFlagsEx(LW_COPROC_FLAGS_EX* coprocInfoExFlags);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Coproc_GetCoprocInfoFlagsEx
//
//! DESCRIPTION:     This API gets the coproc info flags.
//!
//! \param [out]     coprocInfoExFlags   pointer to the LW_COPROC_FLAGS_EX indicating the mask to get
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::LWAPI_OK                  completed request
//! \retval ::LWAPI_ERROR               miscellaneous error oclwrred
//! \retval ::LWAPI_ILWALID_POINTER     null input parameter
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION
//!
//! \ingroup coprocapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Coproc_GetCoprocInfoFlagsEx(LW_COPROC_FLAGS_EX* coprocInfoExFlags);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Coproc_NotifyCoprocPowerState
//
//! \fn LwAPI_Coproc_NotifyCoprocPowerState(LwU32 IsSafetoPowerOff, LwU64 SequenceNumber, LwU32 *pStatus)
//!
//! DESCRIPTION:     This API tells driver that now it is safe to power off dGPU since No running Application is using the coproc.
//!                  
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      IsSafetoPowerOff (IN)     - decides if it is safe to power off the dGPU. TRUE to turn off dGPU.
//!                    SequenceNumber (IN)       - In response to event with matching sequence number
//!                  pStatus(OUT)              - returns the status if powering off dGPU has started.
//!
//! RETURN STATUS:
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup coprocapi
typedef enum
{
    LW_COPROC_POWER_OFF_MODE_UNSAFE = 0,
    LW_COPROC_POWER_OFF_MODE_GPU_OFF = 1,
    LW_COPROC_POWER_OFF_MODE_HDA_REMOVE = 0xff10,
} LW_COPROC_POWER_OFF_MODE;


//! \ingroup coprocapi
LWAPI_INTERFACE LwAPI_Coproc_NotifyCoprocPowerState(LwU32 IsSafetoPowerOff, LwU64 SequenceNumber, LwU32 *pStatus);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Coproc_GetApplicationCoprocInfo
//
//! \fn LwAPI_Coproc_GetApplicationCoprocInfo(LW_COPROC_APP_INFO *pCoprocAppInfo)
//! DESCRIPTION:     This API queries the the coproc status for the application
//!                  running in the current process.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   pCoprocAppInfo   The coproc application info structure
//!
//! \retval ::LWAPI_OK - completed request
//! \retval ::LWAPI_ERROR - miscellaneous error oclwrred
//! \retval ::LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//! \retval ::LWAPI_NOT_SUPPORTED - function is not supported in this platform
//! \retval ::LWAPI_API_NOT_INTIALIZED 
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION 
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup coprocapi
//! Used in LwAPI_Coproc_GetApplicationCoprocInfo().
typedef struct
{
    LwU32 version;                      //!< the structure version
    LwU32 appStatus;            //!< the application status  
} LW_COPROC_APP_INFO;

//! \ingroup coprocapi
//! Macro for onstructing the version field of LW_COPROC_APP_INFO
#define LW_COPROC_APP_INFO_VER          MAKE_LWAPI_VERSION(LW_COPROC_APP_INFO, 1)

//! \ingroup coprocapi
//! See .LW_COPROC_APP_INFO
typedef enum
{
    LW_COPROC_APP_STATUS_ENABLED           = 0x00000000, //!< coproc mode has been enabled
    LW_COPROC_APP_STATUS_DISABLED          = 0x00000001, //!< copro mode has been disabled.
} LW_COPROC_APP_STATUS;

//! \ingroup coprocapi
LWAPI_INTERFACE LwAPI_Coproc_GetApplicationCoprocInfo(LW_COPROC_APP_INFO *pCoprocAppInfo);




//! \ingroup coprocapi
//! @{

#define LW_COPROC_STATE_CHANGE_LOG_COUNT       32

typedef enum _LW_COPROC_POWER_STATE 
{
    LW_COPROC_POWER_STATE_ERROR = 0,
    LW_COPROC_POWER_STATE_ON,
    LW_COPROC_POWER_STATE_GOLD,
    LW_COPROC_POWER_STATE_EXITING_GOLD,
    LW_COPROC_POWER_STATE_ENTERING_GOLD,
    LW_COPROC_POWER_STATE_WAITING_FOR_SVC,
    LW_COPROC_POWER_STATE_GC6,
    LW_COPROC_POWER_STATE_EXITING_GC6,
    LW_COPROC_POWER_STATE_ENTERING_GC6,
} LW_COPROC_POWER_STATE;

typedef struct _LW_COPROC_STATE_CHANGE_ENTRY 
{
    LwU64                      timeStampMicroseconds;
    LW_COPROC_POWER_STATE      coprocPowerState;
    LwU32                      coprocReason;       //!<This variable is not implemented as yet in the driver.
                                                   //!< As of now , we shall always return 0 for this variable.

} LW_COPROC_STATE_CHANGE_ENTRY;


typedef struct _LW_COPROC_GET_GOLD_STATISTICS 
{
    LwU32 version;  //!<LW_COPROC_GOLD_STATISTICS struct version
    
    LwU32 dwGoldTimeoutValue;   
    LwU32 dwGoldTransitionCount;
    LwU32 dwMinTimeInGoldMs;
    LwU32 dwMaxTimeInGoldMs;
    LwU32 dwAvgTimeInGoldMs;
    LwU32 dwMinTimeEnteringGoldMs;
    LwU32 dwMaxTimeEnteringGoldMs;
    LwU32 dwAvgTimeEnteringGoldMs;
    LwU32 dwMinTimeExitingGoldMs;
    LwU32 dwMaxTimeExitingGoldMs;
    LwU32 dwAvgTimeExitingGoldMs;
    
    // Entry 0 is most recent
    LW_COPROC_STATE_CHANGE_ENTRY stateChangeLog[LW_COPROC_STATE_CHANGE_LOG_COUNT];

}LW_COPROC_GOLD_STATISTICS;
    
//! Macro for constructing the version field of ::LW_COPROC_GOLD_STATISTICS     
#define LW_COPROC_GOLD_STATISTICS_VER  MAKE_LWAPI_VERSION(LW_COPROC_GOLD_STATISTICS,1)



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Coproc_GetGoldStatistics
//
//! PARAMETERS:        bClearStatistics (IN) - if set, clears all the statistics.
//!                  pCoprocGoldStats (OUT) - Pointer to the LW_COPROC_GOLD_STATISTICS data. 
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! DESCRIPTION:     This API call is used to get the GOLD Stats from the Driver.
//!                  If call succeeds,  "pCoprocGoldStats" points to the Gold Statistics.
//!
//!
//! RETURN STATUS:
//!    LWAPI_OK - completed request
//!    LWAPI_INCOMPATIBLE_STRUCT_VERSION - LW_COPROC_GOLD_STATISTICS structure version mismatch.
//!    LWAPI_ERROR - miscellaneous error oclwrred.
//!    LWAPI_ILWALID_POINTER - NULL argument passed.
//!    LWAPI_NOT_SUPPORTED - call is not supported.
//!    LWAPI_API_NOT_INTIALIZED - LwAPI not initialized.
//!      LWAPI_ILWALID_ARGUMENT - Invalid Argument.
//
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Coproc_GetGoldStatistics(LwU32 bClearStatistics, LW_COPROC_GOLD_STATISTICS *pCoprocGoldStats);

//! @}


//! \ingroup coprocapi
typedef enum _LW_COPROC_HYSTERESIS_TYPE
{
    LW_COPROC_HYSTERESIS_GOLD,
    LW_COPROC_HYSTERESIS_GC6,
    LW_COPROC_HYSTERESIS_ALL,
    LW_COPROC_HYSTERESIS_NONE,
    
} LW_COPROC_HYSTERESIS_TYPE;

//! \ingroup coprocapi
typedef struct _LW_COPROC_HYSTERESIS
{
    LwU32 version;
    
    LW_COPROC_HYSTERESIS_TYPE type; 
    LwU32 goldIdleTimeoutMs;
    LwU32 GC6IdleTimeoutMs;
    
} LW_COPROC_HYSTERESIS_V1;

typedef LW_COPROC_HYSTERESIS_V1     LW_COPROC_HYSTERESIS;

#define LW_COPROC_HYSTERESIS_VER1   MAKE_LWAPI_VERSION(LW_COPROC_HYSTERESIS_V1,1)

#define LW_COPROC_HYSTERESIS_VER    LW_COPROC_HYSTERESIS_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Coproc_SetHysteresis
//
//! DESCRIPTION:    This API allows setting hysteresis values for Gold and GC6
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in,out]     pCoprocSetHysteresis  - Pointer to LW_COPROC_HYSTERESIS structure. 
//!                                            The input value in LW_COPROC_TYPE indicates which threshold to set.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup coprocapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Coproc_SetHysteresis(__inout LW_COPROC_HYSTERESIS *pCoprocSetHysteresis);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Coproc_GetHysteresis
//
//! DESCRIPTION:    This API gets hysteresis values for Gold and GC6
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in,out]     pCoprocGetHystersis  - Pointer to LW_COPROC_HYSTERESIS structure. 
//!                                            The input value in LW_COPROC_TYPE indicates which of the threshold returned value is valid.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup coprocapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Coproc_GetHysteresis(__inout LW_COPROC_HYSTERESIS *pCoprocGetHysteresis);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Hybrid_ControlDriverHDABus
//
//!   DESCRIPTION: Disable/Enable the Driver of HDMI Audio Bus
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:     stateChange (IN) - TRUE to enable the HDMI AudioBus driver, FALSE to disable it 
//! RETURN STATUS:  LWAPI_OK - completed request
//!                 LWAPI_ERROR - miscellaneous error oclwrred
//!                 LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//!            LWAPI_NOT_SUPPORTED - function is not supported in this platform
//!            LWAPI_API_NOT_INTIALIZED - You must call LwAPI_Initialize first
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Hybrid_ControlDriverHDABus(LwU32 stateChange);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Hybrid_ControlDriverHDA
//
//!   DESCRIPTION: Disable/Enable the Driver of HDMI Audio
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:     stateChange (IN) - TRUE to enable the HDMI Audio-driver, FALSE to disable it 
//! RETURN STATUS:  LWAPI_OK - completed request
//!                 LWAPI_ERROR - miscellaneous error oclwrred
//!                 LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//!            LWAPI_NOT_SUPPORTED - function is not supported in this platform
//!            LWAPI_API_NOT_INTIALIZED - You must call LwAPI_Initialize first
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Hybrid_ControlDriverHDA(LwU32 stateChange);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetHybridStatusString
//
//!   DESCRIPTION: This function colwerts a Hybrid status into a null terminated string.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 173
//!
//! \return  A null terminated string (always, never NULL)
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetHybridStatusString(LwU32 nr,LwAPI_String szDesc);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetHybridModesString
//
//!   DESCRIPTION: This function colwerts a Hybrid mode into a null terminated string.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 173
//!
//! \return  A null terminated string (always, never NULL)
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetHybridModesString(LwU32 nr,LwAPI_String szDesc);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Coproc_GetCoprocStatusString
//
//!   DESCRIPTION: colwerts an Coproc status into a null terminated string
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \return null terminated string (always, never NULL)
//!
//! \ingroup coprocapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Coproc_GetCoprocStatusString(LwU32 nr,LwAPI_String szDesc);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Coproc_GetCoprocFlagsString
//
//!   DESCRIPTION: colwerts an Coproc status into a null terminated string
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \return null terminated string (always, never NULL)
//!
//! \ingroup coprocapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Coproc_GetCoprocFlagsString(LwU32 nr,LwAPI_String szDesc);






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_LightWeightDGPU
//
//!   DESCRIPTION: This API wakes up the dGPU and loads the LWPU driver for Intel Hybrid systems.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \retval ::LWAPI_OK    
//! \retval ::LWAPI_ERROR  
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_LightWeightDGPU(LwU32 flags);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_HybridIGPUHeadsControl
//
//!   DESCRIPTION: This API requests the Hybrid Interposer to hide or unhide iGPU heads.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \retval ::LWAPI_OK    
//! \retval ::LWAPI_ERROR  
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_HybridIGPUHeadsControl(LwU8 bHide);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_QueryHybridIGPUHeadsControl
//
//!   DESCRIPTION: This API queries the Hybrid Interposer iGPU hide-heads state.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \retval ::LWAPI_OK    
//! \retval ::LWAPI_ERROR  
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_QueryHybridIGPUHeadsControl(LwU8 *pbHide);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_IsIntelHybrid
//
//! PARAMETERS:      IsIntel(IN/OUT)          - boolean: zero=Not a Intel Hybrid System, one=Intel Hybrid System
//! DESCRIPTION:     This API determines whether running system is Intel Hybrid or not
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_IsIntelHybrid(LwU8 *IsIntel);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Hybrid_SetDGPUPowerState
//
//! \fn LwAPI_Hybrid_SetDGPUPowerState(LW_HYBRID_POWERSTATE powerState)
//!
//! DESCRIPTION: This API sets the dGPU Power State on a hybrid system. 
//!         Supported on Vista and higher.
//!              App calling this API is required to run in elevated mode. 
//!              When called, this will change the power state of all dGPUs in
//!              the system.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      powerState(IN)     - Requested power state for dGPUs
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup hybridapi
typedef enum _LW_HYBRID_POWERSTATE
{
    LW_HYBRID_POWERSTATE_OFF       = 0x00,
    LW_HYBRID_POWERSTATE_ON        = 0x01,
    LW_HYBRID_POWERSTATE_DEEPIDLE  = 0x02, 
} LW_HYBRID_POWERSTATE;

//! \ingroup hybridapi
LWAPI_INTERFACE LwAPI_Hybrid_SetDGPUPowerState(LW_HYBRID_POWERSTATE powerState);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Hybrid_GetDGPUPowerState
//
//! DESCRIPTION:     This API gets current dGPU Power State. 
//!                  Supported on Vista and higher.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      pPowerState(OUT)     - Power State
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Hybrid_GetDGPUPowerState(LW_HYBRID_POWERSTATE *pPowerState);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Hybrid_StartTransition
//
//! DESCRIPTION: This API notifies the driver to start a hybrid transition
//!         Supported on Vista and higher.
//!              App calling this API is required to run in elevated mode. 
//!              This call is called after the dGPUs are powered up, but before
//!              the DGPU drivers are enabled.
//!              If this call succeeds, an LwAPI_Hybrid_StopTransition() must
//!              be called, regardless of success or failure.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      mode(IN)     - Requested mode for transition
//!                  phTransition(OUT) - Handle used to address this transition
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Hybrid_StartTransition(LW_HYBRID_MODE mode, LwTransitionHandle* phTransition);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Hybrid_StopTransition
//
//! DESCRIPTION: This API notifies the driver to stop a hybrid transition
//!         Supported on Vista and higher.
//!              App calling this API is required to run in elevated mode. 
//!              This call is called after the drivers are stable, but
//!              not necessarily powered off.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      hTransition(IN) - Handle returned from LwAPI_Hybrid_StartTransition
//!                  mode(IN)     - Final mode which was accepted
//!                                 This might be different than the 
//!                                 StartTransition mode, since a failure
//!                                 could result in falling back
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Hybrid_StopTransition(LwTransitionHandle hTransition, LW_HYBRID_MODE mode);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Hybrid_SetDGPUDriverState
//
//! \fn LwAPI_Hybrid_SetDGPUDriverState(LwTransitionHandle hTransition, LW_HYBRID_DRIVERSTATE driverState)
//!
//! DESCRIPTION:     This API sets the current dGPU Driver State
//!                  Supported on Vista and higher.
//!                  NOTE: If the driver is lwrrently yellow-banged, and the
//!                  request is to start the driver, a stop will be called 
//!                  first to clear the driver failure.
//!                  This call is made after a successful StartTransition
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      hTransition(IN) - Handle returned from LwAPI_Hybrid_StartTransition
//!                  driverState(IN) - Requested driver state
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup hybridapi
typedef enum _LW_HYBRID_DRIVERSTATE
{
    LW_HYBRID_DRIVERSTATE_UNKNOWN   = 0x00,
    LW_HYBRID_DRIVERSTATE_DISABLED  = 0x01,
    LW_HYBRID_DRIVERSTATE_ENABLED   = 0x02,
    LW_HYBRID_DRIVERSTATE_PROBLEM   = 0x03,
    LW_HYBRID_DRIVERSTATE_STARTING  = 0x04,
} LW_HYBRID_DRIVERSTATE;

//! \ingroup hybridapi
LWAPI_INTERFACE LwAPI_Hybrid_SetDGPUDriverState(LwTransitionHandle hTransition, LW_HYBRID_DRIVERSTATE driverState);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Hybrid_GetDGPUDriverState
//
//! DESCRIPTION:     This API gets the current dGPU Driver State
//!                  Supported on Vista and higher.
//!                  NOTE: If the driver is lwrrently yellow-banged, and the
//!                  request is to start the driver, a stop will be called 
//!                  first to clear the driver failure.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      hTransition(IN) - Handle returned from LwAPI_Hybrid_StartTransition
//!                  pDriverState(OUT) - Current driver state
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Hybrid_GetDGPUDriverState(LwTransitionHandle hTransition, LW_HYBRID_DRIVERSTATE* pDriverState);







///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Hybrid_StartDisplaySwitch
//
//! DESCRIPTION: This API notifies the driver to prepare to switch the display
//!         Supported on Vista and higher.
//!              App calling this API is required to run in elevated mode. 
//!              This call is called after the dGPUs drivers are enabled, but
//!              before calls to ChangeDisplaySettingsEx
//!              If this call succeeds, an LwAPI_Hybrid_StopDisplaySwitch() 
//!              must be called, regardless of success or failure.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      hTransition(IN) - Handle returned from LwAPI_Hybrid_StartTransition
//!                  mode(IN)     - Requested mode for transition
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Hybrid_StartDisplaySwitch(LwTransitionHandle hTransition, LW_HYBRID_MODE mode);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Hybrid_StopDisplaySwitch
//
//! DESCRIPTION: This API notifies the driver that display switching is done
//!         Supported on Vista and higher.
//!              App calling this API is required to run in elevated mode. 
//!              This call is called after an attempt to move the active display
//!              to the new hybrid display. The requested mode may differ if
//!              a failure was encountered during the switching of displays.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      hTransition(IN) - Handle returned from LwAPI_Hybrid_StartTransition
//!                  mode(IN)     - Final mode which was accepted
//!                                 This might be different than the 
//!                                 StartTransition mode, since a failure
//!                                 could result in falling back
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Hybrid_StopDisplaySwitch(LwTransitionHandle hTransition, LW_HYBRID_MODE mode);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Hybrid_GetMirroredDisplays
//
//! DESCRIPTION:     This API gets the display mirrors for power and perf.
//!                  Supported on Vista and higher.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      hTransition(IN) - Handle returned from LwAPI_Hybrid_StartTransition
//!                  pMirroredHeadIDs(OUT) - Array of LWAPI_MAX_HEADS_PER_GPU
//!                                          elements which holds the mirror
//!                                          IDs for a configuration
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Hybrid_GetMirroredDisplays(LwTransitionHandle hTransition, 

                                                 LwU32* pMirroredHeadIDs);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Hybrid_SwapDisplays
//
//! DESCRIPTION:     This API swaps the current active displays from one adapter
//!                  to the other. This should not be used with multi-adapter.
//!                  Supported on Vista and higher.
//!                  Mode is used to verify the proper display direction
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      hTransition(IN) - Handle returned from LwAPI_Hybrid_StartTransition
//!                  mode(IN)     - Requested mode for transition
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Hybrid_SwapDisplays(LwTransitionHandle hTransition, LW_HYBRID_MODE mode);





// FUNCTION NAME:   LwAPI_Hybrid_SetDisplayMUX
//
//! DESCRIPTION:     This API sets the active display MUX, used on systems with
//!                  either Intel Hybrid, or MCP controlled by a MUX.
//!                  Supported on Vista and higher.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      hTransition(IN) - Handle returned from LwAPI_Hybrid_StartTransition
//!                  mode(IN) - Must be either LW_HYBRID_MODE_IGPU or 
//!                             LW_HYBRID_MODE_DGPU
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Hybrid_SetDisplayMUX(LwTransitionHandle hTransition, LW_HYBRID_MODE mode);

//! \addtogroup hybridapi
//! @{

//! Basic Flow Diagram of SetHybridMode(LW_HYBRID_MODE_DGPU)
//! \code
//!  LwAPI_Hybrid_SetDGPUPowerState(LW_HYBRID_POWERSTATE_ON);
//!  LwAPI_Hybrid_StartTransition(LW_HYBRID_MODE_DGPU);
//!  LwAPI_Hybrid_SetDGPUDriverState(LW_HYBRID_DRIVERSTATE_ENABLED);
//!  LwAPI_Hybrid_StartDisplaySwitch(LW_HYBRID_MODE_DGPU);
//!  LwAPI_Hybrid_SwapDisplays(LW_HYBRID_MODE_DGPU);
//!  LwAPI_Hybrid_StopDisplaySwitch(LW_HYBRID_MODE_DGPU);
//!  LwAPI_Hybrid_StopTransition(LW_HYBRID_MODE_DGPU);
//! \endcode

//! Basic Flow Diagram of SetHybridMode(LW_HYBRID_MODE_IGPU)
//! \code
//!  LwAPI_Hybrid_StartTransition(LW_HYBRID_MODE_IGPU);
//!  LwAPI_Hybrid_StartDisplaySwitch(LW_HYBRID_MODE_IGPU);
//!  LwAPI_Hybrid_SwapDisplays(LW_HYBRID_MODE_IGPU);
//!  LwAPI_Hybrid_StopDisplaySwitch(LW_HYBRID_MODE_IGPU);
//!  LwAPI_Hybrid_SetDGPUDriverState(LW_HYBRID_DRIVERSTATE_DISABLED);
//!  LwAPI_Hybrid_StopTransition(LW_HYBRID_MODE_IGPU);
//!  LwAPI_Hybrid_SetDGPUPowerState(LW_HYBRID_POWERSTATE_OFF);
//! \endcode

//! Basic Flow Diagram of SetHybridMode(LW_HYBRID_MODE_MULTI_ADAPTER)
//! \code
//!  LwAPI_Hybrid_SetDGPUPowerState(LW_HYBRID_POWERSTATE_ON);
//!  LwAPI_Hybrid_StartTransition(LW_HYBRID_MODE_MULTI_ADAPTER);
//!  LwAPI_Hybrid_SetDGPUDriverState(LW_HYBRID_DRIVERSTATE_ENABLED);
//!  LwAPI_Hybrid_StopTransition(LW_HYBRID_MODE_MULTI_ADAPTER);
//! \endcode

//! @}




//! \ingroup hybridiapi
#define LW_MAX_HYBRID_ACPI_IDS      16      //!< Based on LW_MAX_DOD_ACPI_IDS as per spec limit

//! \ingroup hybridiapi
typedef struct
{
    LwU32                   acpiId;
    LwU32                   intelId;
    LwU32                   displayId;          //!< Not yet supported
    LwPhysicalGpuHandle     physicalGpu;        //!< Not yet supported
    LwU32                   outputId;
} LW_HYBRID_INTEL_DEVICE_MAP_ENTRY;

//! \ingroup hybridiapi
typedef struct
{
    LwU32 version;
    LwU32 count;
    LW_HYBRID_INTEL_DEVICE_MAP_ENTRY maps[LW_MAX_HYBRID_ACPI_IDS];
} LW_HYBRID_INTEL_DEVICE_MAP;

//! \ingroup hybridiapi
//! Macro for constructingthe version field of LW_HYBRID_INTEL_DEVICE_MAP
#define LW_HYBRID_INTEL_DEVICE_MAP_VER          MAKE_LWAPI_VERSION(LW_HYBRID_INTEL_DEVICE_MAP, 1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Hybrid_GetIntelDeviceMap
//
//! DESCRIPTION:     This API gets the mapping table for all the IDs for an
//!                  Intel Hybrid system. The system must have booted to 
//!                  LW_HYBRID_MODE_DGPU at least once before this call will
//!                  succeed.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      pMap(IN/OUT) - Pointer to the LW_HYBRID_INTEL_DEVICE_MAP
//!                                 structure, which will be filled with the
//!                                 proper data.
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//!                  LWAPI_DATA_NOT_FOUND - System must have been to DGPU mode
//!                                         before calling this API
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Hybrid_GetIntelDeviceMap(LW_HYBRID_INTEL_DEVICE_MAP* pMap);






//! \ingroup hybridapi
typedef struct
{
  LwU32 version;    //!< Structure version
  LwAPI_LongString   appName;
  LwAPI_LongString   friendlyName;
}LW_HYBRID_APP_INFO;

//! \ingroup hybridapi
//! Macro for constructing the version field of LW_HYBRID_APP_INFO 
#define LW_HYBRID_APP_INFO_VER  MAKE_LWAPI_VERSION(LW_HYBRID_APP_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Hybrid_QueryUnblockedNonMigratableApps
//
//! DESCRIPTION:     This API queries the user white-list applications for Hybrid transition.
//!
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out]     apps     Empty structure passed as an input and upon successfull exit, it contains list of Unblocked(user white-list) applications.
//! \param [in,out]     total    Total number of applications returned from the white list.
//!
//! \retval ::LWAPI_OK                 completed request.
//! \retval ::LWAPI_ERROR              miscellaneous error oclwrred.
//! \retval ::LWAPI_ILWALID_ARGUMENT   invalid input parameter.
//! \retval ::LWAPI_NO_IMPLEMENTATION  not implemented.
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Hybrid_QueryUnblockedNonMigratableApps(LW_HYBRID_APP_INFO apps[LWAPI_MAX_3D_Apps] , LwU32 *total);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Hybrid_QueryBlockedMigratableApps
//
//! DESCRIPTION:     This API queries the user black-list applications for Hybrid transition.
//!
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out]     apps     Empty structure passed as an input and upon successfull exit, it contains list of Unblocked(user black-list) applications..
//! \param [in,out]     total    Total number of applications returned from the black list.
//!
//! \retval ::LWAPI_OK                 completed request.
//! \retval ::LWAPI_ERROR              miscellaneous error oclwrred.
//! \retval ::LWAPI_ILWALID_ARGUMENT   invalid input parameter.
//! \retval ::LWAPI_NO_IMPLEMENTATION  not implemented.
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Hybrid_QueryBlockedMigratableApps(LW_HYBRID_APP_INFO apps[LWAPI_MAX_3D_Apps] , LwU32 *total);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Hybrid_SetAppMigrationState
//
//! DESCRIPTION:     This API overrides the pre-determined application migration state.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     app  Application exelwtable name that is to be blocked, unblocked, reset or removed
//! \param [in]     flag Decides on the block, unblock, reset or remove operation. \n
//!                      block =0, unblock =1, reset =2, remove =3
//!
//! \retval ::LWAPI_OK  completed request.
//! \retval ::LWAPI_ERROR  miscellaneous error oclwrred.
//! \retval ::LWAPI_ILWALID_ARGUMENT  invalid input parameter.
//! \retval ::LWAPI_SET_NOT_ALLOWED  the application list override is not allowed.  
//! \retval ::LWAPI_NO_IMPLEMENTATION  not implemented.
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Hybrid_SetAppMigrationState(LW_HYBRID_APP_INFO app , LwU32 flag);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Hybrid_IsAppMigrationStateChangeable
//
//! DESCRIPTION:     This API queries if an application's migration state can be changed by the user.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      app      Application exelwtable name which user is querying about
//! \param [out]     allowed  Change in migration state of app is allowed or not. \n
//!                           not_allowed =0, allowed =1
//!
//! \retval ::LWAPI_OK  completed request.
//! \retval ::LWAPI_ERROR  miscellaneous error oclwrred.
//! \retval ::LWAPI_ILWALID_ARGUMENT  invalid input parameter.
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Hybrid_IsAppMigrationStateChangeable(LW_HYBRID_APP_INFO app , LwU32 *allowed);



//! \ingroup hybridapi
//! Declaration for the possible use of LWAPI flags
//! @{
#define LW_SET_HYBRID_MODE_DEFER_NON_MIGRATABLE_APP_SHUTDOWN    0x00000001 //!< Calling application will control the shutdown of non-migratable applications holding hw resources
#define LWAPI_ADAPTIVE_POLICY_ON                 0x00000002 //!< Set the hybrid mode to turn on adaptive mode
//! @}


 
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SetHybridModeEx
//
//! DESCRIPTION:     This API will support elevated transition if the application does not run in elevated mode.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 173
//!
//!  \param [in]    mode      The hybrid mode - see LW_HYBRID_MODE.
//!  \param [in]    flags     Flags that indicate additional control - see ::LW_SET_HYBRID_MODE_FLAGS.
//!
//!  \retval        LWAPI_OK                Completed request
//!  \retval        LWAPI_ERROR             Miscellaneous error oclwrred
//!  \retval        LWAPI_ILWALID_ARGUMENT  Invalid input parameter
//!
//!  \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetHybridModeEx(LW_HYBRID_MODE mode, LwU32 flags);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_InitHybridMicroController
//
//!   DESCRIPTION: This API initializes the hybrid micro-controller
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 175
//! 
//! \retval    LWAPI_OK      Completed request
//! \retval    LWAPI_ERROR   Miscellaneous error oclwrred
//!
//! \ingroup   hybridapi 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_InitHybridMicroController();







///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_CreateUnAttachedDisplayFromDisplay
//
//! DESCRIPTION:     This API unattaches an active display if it is not the GDI primary display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//! 
//! \param [in]       hLwDisplay                   Active display handle
//! \param [out]      pLwUnAttachedDisp            Pointer to the unattached display handle
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_ILWALID_ARGUMENT 
//! \retval ::LWAPI_EXPECTED_DISPLAY_HANDLE 
//! \retval ::LWAPI_EXPECTED_NON_PRIMARY_DISPLAY_HANDLE  The GDI primary handle passed
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_CreateUnAttachedDisplayFromDisplay(LwDisplayHandle hLwDisplay, LwUnAttachedDisplayHandle *pLwUnAttachedDisp);






//
// LW_GET_SCALING_CAPS
//
// Interface structure used in LwAPI_GetScalingCaps call.
//
// This LwAPI_GetScalingCaps returns scaling capability info for the specified display device
//




//! \ingroup dispcontrol
//! Used in LwAPI_GetScalingCaps(), which returns scaling capability information for the specified display device. 
typedef struct 
{
    LwU32   version;                                      //!< Structure version
    LwU32   isGPUScalingAvailable                   : 1;  //!< If the GPU scaling mode available
    LwU32   isGPUFixedAspectRatioScalingAvailable   : 1;  //!< If the GPU Fixed-Aspect ratio scaling mode available
    LwU32   isMonitorScalingAvailable               : 1;  //!< If the monitor scaling mode available
    LwU32   isCenterScalingAvailable                : 1;  //!< If center scaling mode available
} LW_GET_SCALING_CAPS_V1;

//! \ingroup dispcontrol
typedef struct 
{
    LwU32      version;
    union // if Force GPU - Full Screen scaling available.
    {
        LwU32  isGPUScalingAvailable                  : 1;
        LwU32  isGPUScalingToNative                   : 1;
    };
    union // if Force GPU - Aspect Ratio scaling available.
    {
        LwU32  isGPUFixedAspectRatioScalingAvailable  : 1;
        LwU32  isGPUScalingToAspectScanoutToNative    : 1;
    };
    union // if Balanced - Full Screen scaling available.
    {
        LwU32  isMonitorScalingAvailable              : 1;
        LwU32  isGPUScalingToClosest                  : 1;
    };
    union // if Force GPU - Centered scaling available.
    {
        LwU32  isCenterScalingAvailable               : 1;
        LwU32  isGPUScanoutToNative                   : 1;
    };
    LwU32      isGPUScalingToAspectScanoutToClosest   : 1;  //!< if Balanced - Aspect Ratio scaling available.
    LwU32      isGPUScanoutToClosest                  : 1;  //!< if Balanced - Centered scaling available.
    LwU32      reserved                               : 30;
     
    LW_SCALING defaultScaling; //!< Default scaling setting for the display.
    LW_SCALING lwrrentScaling; //!< Lwrrently applied scaling setting for the display.
} LW_GET_SCALING_CAPS_V2;

//! \ingroup dispcontrol
typedef LW_GET_SCALING_CAPS_V2     LW_GET_SCALING_CAPS;



//! \ingroup dispcontrol
//! @{
#define LW_GET_SCALING_CAPS_VER1   MAKE_LWAPI_VERSION(LW_GET_SCALING_CAPS_V1,1)
#define LW_GET_SCALING_CAPS_VER2   MAKE_LWAPI_VERSION(LW_GET_SCALING_CAPS_V2,2)
#define LW_GET_SCALING_CAPS_VER    LW_GET_SCALING_CAPS_VER2
//! @}





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetScalingCaps
//
//! DESCRIPTION:   This API returns all the scaling Caps for the specified display. Each member is used to disable the corresponding scaling feature. 
//!                - If the value of the member is true, the caller does not care. 
//!                - If the value of the member is false, the caller has to set the corresponding scaling option disabled. 
//!
//!                Note: LwAPI_GetScalingCaps() at present only supports "Monitor Scaling caps".
//!                Other scaling caps are not implemented by the display driver.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]   hLwDisplay    LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]   outputId      The active display output ID associated with the selected display handle hLwDisplay.
//!                             The outputid will have only one bit set. In case of Clone or Span modes, this will indicate the display
//!                             outputId of the primary display that the GPU is driving.
//! \param [out]  pScalingCaps  Pointer to structure LW_GET_SCALING_CAPS. Returns various scaling caps for a given displayId. 
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_API_NOT_INTIALIZED 
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND      No LWPU GPU driving a display was found.
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  Structure version is not supported, initialize to LW_GET_SCALING_CAPS_VER.
//! \retval ::LWAPI_EXPECTED_DISPLAY_HANDLE      hLwDisplay is not a valid display handle.
//! \retval ::LWAPI_ILWALID_ARGUMENT             outputId is zero.
//! \retval ::LWAPI_ILWALID_HANDLE               Invalid Display handle.
//! \retval ::LWAPI_ERROR 
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetScalingCaps(LwDisplayHandle hLwDisplay, LwU32 outputId, LW_GET_SCALING_CAPS *pScalingCaps);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DISP_GetScalingCaps
//
//! PARAMETERS:    displayId(IN)     - LWPU Display ID. It is the value returned from LwAPI_SYS_GetDisplayIdFromGpuAndOutputId()
//!                pScalingCaps(OUT) - Pointer to struct LW_GET_SCALING_CAPS. Returns various scaling caps for a given displayId.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION:   Returns all the scaling Caps of given display. 
//!                This API can also be used to get the scaling caps for an inactive connected display.
//!
//! RETURN STATUS: LWAPI_OK                          - Call successful.
//!                LWAPI_ERROR                       - Miscellenous errors.
//!                LWAPI_ILWALID_POINTER             - Invalid pointer pScalingCaps.
//!                LWAPI_ILWALID_ARGUMENT            - If display Id passed is invalid.
//!                LWAPI_API_NOT_INTIALIZED          - LWAPI not initialized.
//!                LWAPI_LWIDIA_DEVICE_NOT_FOUND     - No LWPU GPU driving a display was found.
//!                LWAPI_INCOMPATIBLE_STRUCT_VERSION - Structure version is not supported, initialize to LW_GET_SCALING_CAPS_VER.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetScalingCaps(LwU32 displayId, LW_GET_SCALING_CAPS *pScalingCaps);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetHybridControllerInfo
//
//! \fn LwAPI_GPU_GetHybridControllerInfo(LwPhysicalGpuHandle hPhysicalGpu, 
//!                                                  LW_GPU_HYBRID_CONTROLLER_INFO *pHybridControllerInfo)
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:     Returns the hybrid controller information
//!                      present - true if the hybrid controller is present
//!                      fwVersion - firmware version of the hybrid controller. 
//!                                  Firmware version is zero if the hybrid controller is not present.
//!
//!
//! RETURN STATUS: 
//!    LWAPI_OK - completed request, *pTable contains the thermal table entries
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_ILWALID_ARGUMENT - pHybridCOntrollerInfo is NULL
//!    LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup hybridapi
typedef struct
{
    LwU32   version;            //! Structure version
    LwU32   present;
    LwU32   fwVersion;
} LW_GPU_HYBRID_CONTROLLER_INFO;


//! \ingroup hybridapi
//! Macro for constructingthe version field of ::LW_GPU_HYBRID_CONTROLLER_INFO
#define LW_GPU_HYBRID_CONTROLLER_INFO_VER MAKE_LWAPI_VERSION(LW_GPU_HYBRID_CONTROLLER_INFO,1)

//! \ingroup hybridapi
LWAPI_INTERFACE LwAPI_GPU_GetHybridControllerInfo(LwPhysicalGpuHandle hPhysicalGpu, 
                                                  LW_GPU_HYBRID_CONTROLLER_INFO *pHybridControllerInfo);




//! \ingroup dispcontrol
typedef struct
{
    LwU32   version;

    LwU32   width;
    LwU32   height;
    LwU32   depth;
    LwU32   refresh;
    LwU32   format;
    LwU32   interlaced;
} LWAPI_DISPLAY_MODE;

//! SUPPORTED OS:  Windows XP and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME : LwAPI_Disp_EnumerateDisplayModes
//
//! PARAMETERS    : hLwDisplay (IN)          - LWPU display handle
//!                 modeIndex  (IN)          - index for desired mode
//!                 mode       (OUT)         - display mode at modeIndex of driver table
//!
//! DESCRIPTION   : Enumerate the entire mode table in the driver.
//!
//! HOW TO USE    : Call repeatedly with increasing modeIndex until LWAPI_END_ENUMERATION returns
//!                 
//! RETURN STATUS:
//!                 LWAPI_OK                      - completed request
//!                 LWAPI_ERROR                   - miscellaneous error oclwrred
//!                 LWAPI_API_NOT_INTIALIZED      - must initialize first
//!                 LWAPI_EXPECTED_DISPLAY_HANDLE - invalid hLwDisplay
//!                 LWAPI_END_ENUMERATION         - modeIndex is greater than the number of modes in the driver table
//!
//! \ingroup dispcontrol 
///////////////////////////////////////////////////////////////////////////////    
LWAPI_INTERFACE LwAPI_Disp_EnumerateDisplayModes(LwDisplayHandle hLwDisplay, LwU32 modeIndex, LWAPI_DISPLAY_MODE *mode);



#define LW_MAX_PROTECTED_VIDEO_SESSIONS 8

typedef enum _LW_PROTECTED_VIDEO_SESSION_TYPE
{
    LW_VIDEO_SESSION_COPP = 0,
    LW_VIDEO_SESSION_OPM  = 1
}LW_PROTECTED_VIDEO_SESSION_TYPE;

typedef struct _LWAPI_PROTECTED_VIDEO_SESSION_INFO
{
    LwU32                              version;                                       //!< (IN) version info
    LwU32                              dwNumProtSessions;                             //!< number of protected sessions
    LW_PROTECTED_VIDEO_SESSION_TYPE    sessionType[LW_MAX_PROTECTED_VIDEO_SESSIONS];  //!< SessionType COPP/OPM associated with each session
} LWAPI_PROTECTED_VIDEO_SESSION_INFO;

//! Macro for constructing the version field of ::_LWAPI_PROTECTED_VIDEO_SESSION_INFO
#define LWAPI_PROTECTED_VIDEO_SESSION_INFO_VER  MAKE_LWAPI_VERSION(LWAPI_PROTECTED_VIDEO_SESSION_INFO,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Video_GetProtectedVideoSessionInfo
//
//! DESCRIPTION: Returns information on the number of protected Video sessions and their semantics COPP/OPM so far
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS:
//!                LWAPI_OK    - completed request
//!                LWAPI_ERROR - miscellaneous error oclwrred
//
//////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Video_GetProtectedVideoSessionInfo(LWAPI_PROTECTED_VIDEO_SESSION_INFO *pProtVideoSessionInfo); 

//! @}



//! SUPPORTED OS:  Windows XP and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_DISP_GetDisplayIdByDisplayName
//
//! DESCRIPTION:     This API retrieves the Display Id of a given display by
//!                  display name. The display must be active to retrieve the
//!                  displayId. In the case of clone mode or Surround gaming,
//!                  the primary or top-left display will be returned.
//!
//! \param [in]     displayName  Name of display (Eg: "\\DISPLAY1" to
//!                              retrieve the displayId for.
//! \param [out]    displayId    Display ID of the requested display.
//!
//! retval ::LWAPI_OK:                          Capabilties have been returned.
//! retval ::LWAPI_ILWALID_ARGUMENT:            One or more args passed in are invalid.
//! retval ::LWAPI_API_NOT_INTIALIZED:          The LwAPI API needs to be initialized first
//! retval ::LWAPI_NO_IMPLEMENTATION:           This entrypoint not available
//! retval ::LWAPI_ERROR:                       Miscellaneous error oclwrred
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetDisplayIdByDisplayName(const char *displayName, LwU32* displayId);



//! SUPPORTED OS:  Windows XP and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_DISP_GetGDIPrimaryDisplayId
//
//! DESCRIPTION:     This API returns the Display ID of the GDI Primary.
//!
//! \param [out]     displayId   Display ID of the GDI Primary display.
//!
//! \retval ::LWAPI_OK:                          Capabilties have been returned.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND:     GDI Primary not on an LWPU GPU.
//! \retval ::LWAPI_ILWALID_ARGUMENT:            One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INTIALIZED:          The LwAPI API needs to be initialized first
//! \retval ::LWAPI_NO_IMPLEMENTATION:           This entrypoint not available
//! \retval ::LWAPI_ERROR:                       Miscellaneous error oclwrred
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetGDIPrimaryDisplayId(LwU32* displayId);


//! \ingroup dispcontrol
typedef enum {
    LW_SR_ENTRY_METHOD_UNSUPPORTED = 0, 
    LW_SR_ENTRY_METHOD_INBAND,              //!< SR Entry request is sent by reverting hsync polarity (LVDS) or sending infoframe (eDP)
    LW_SR_ENTRY_METHOD_SIDEBAND,            //!< SR Entry request is sent by writing to I2C slave (LVDS)/Aux (eDP) address.
} LW_SR_ENTRY_METHOD_ENUM;

//! \ingroup dispcontrol
typedef struct _LW_SR_ENTRY_PARAM_V1
{
    LwU32                      version;                                               //!< (IN)version info
    LwU32                      displayId;
    LW_SR_ENTRY_METHOD_ENUM    entryMethod;                                           //!< The entry method used for entering SR mode
}LW_SR_ENTRY_PARAM_V1;

//! \ingroup dispcontrol
typedef LW_SR_ENTRY_PARAM_V1      LW_SR_ENTRY_PARAM;
//! \ingroup dispcontrol 
#define LW_SR_ENTRY_PARAM_VER_1   MAKE_LWAPI_VERSION(LW_SR_ENTRY_PARAM_V1,1)
//! \ingroup dispcontrol
#define LW_SR_ENTRY_PARAM_VER     LW_SR_ENTRY_PARAM_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_DISP_EnterSparseSelfRefreshPanel
//
//! DESCRIPTION:     This API causes the panel to enter self refresh mode. Self Refresh
//!                  mode means the panel caches the frame GPU sends into its local frame buffer
//!                  and scans out from its buffer instead of from GPU. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pSrEntryParams    - Pointer to the LW_SR_ENTRY data
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_OK:                          Completed request
//! \retval ::LWAPI_ILWALID_DISPLAY_ID:          Incorrect display ID
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_EnterSparseSelfRefreshPanel(__in LW_SR_ENTRY_PARAM* pSrEntryParams);


//! \ingroup dispcontrol
typedef enum {
    LW_SR_EXIT_METHOD_UNSUPPORTED = 0, 
    LW_SR_EXIT_METHOD_INBAND,           //!< Self refresh panel (SRP) exit request is sent by reverting hsync polarity (LVDS) 
                                        //!< or sending infoframe (eDP)
    LW_SR_EXIT_METHOD_SIDEBAND,         //!< SRP exit request is sent by writing to I2C slave (LVDS)/Aux (eDP) address.
} LW_SR_EXIT_METHOD_ENUM;

//! \ingroup dispcontrol
typedef enum {
    LW_SR_RESYNC_METHOD_UNSUPPORTED = 0, 
    LW_SR_RESYNC_METHOD_SLIDING_SYNC,            //!< GPU and SRP both slide its timing such that its vblank overlap.
    LW_SR_RESYNC_METHOD_FRAMELOCK,               //!< SRP sends framelock to GPU so that it resets its scanout to 0,0
    LW_SR_RESYNC_METHOD_BLANK_STRETCH,           //!< SRP stretch the vblank to resync
} LW_SR_RESYNC_METHOD_ENUM;

//! \ingroup dispcontrol
typedef struct _LW_SR_EXIT_PARAM_V1
{
    LwU32                     version;            //!< (IN)version info
    LwU32                     displayId;
    LW_SR_EXIT_METHOD_ENUM    exitMethod;         //!< The exit method used for exiting SR mode
    LW_SR_RESYNC_METHOD_ENUM  resyncMethod;       //!< The resync method between GPU and panel
    LwU32                     resyncDelay : 2;    //!< The resync delay between GPU and panel. Unit is # of frames
    LwU32                     reserved    : 30;
}LW_SR_EXIT_PARAM_V1;

//! \ingroup dispcontrol
typedef LW_SR_EXIT_PARAM_V1      LW_SR_EXIT_PARAM;
//! \ingroup dispcontrol 
#define LW_SR_EXIT_PARAM_VER_1   MAKE_LWAPI_VERSION(LW_SR_EXIT_PARAM_V1,1)
//! \ingroup dispcontrol
#define LW_SR_EXIT_PARAM_VER     LW_SR_EXIT_PARAM_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_DISP_ExitSparseSelfRefreshPanel
//
//! DESCRIPTION:     This API causes the panel to exit self refresh mode. Self Refresh
//!                  mode means the panel caches the frame GPU sends into its local frame buffers
//!                  and scans out from its buffer instead of from GPU. When GPU exits from
//!                  self refresh mode, GPU gets back the control for scanout from panel.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in]     pSrExitParams    - In Pointer to the LW_SR_EXIT data
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_OK:                          Completed request
//! \retval ::LWAPI_ILWALID_DISPLAY_ID:          Incorrect display ID
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_ExitSparseSelfRefreshPanel(__in LW_SR_EXIT_PARAM* pSrExitParams);


//! \ingroup dispcontrol
typedef struct _LW_SR_STATE_PARAM_V1
{
    LwU32   version;     //!< (IN)version info
    LwU32   displayId;
    LwU32   status;      //!< The SRC controller status

}LW_SR_STATE_PARAM_V1;

//! \ingroup dispcontrol
typedef LW_SR_STATE_PARAM_V1      LW_SR_STATE_PARAM;
//! \ingroup dispcontrol 
#define LW_SR_STATE_PARAM_VER_1   MAKE_LWAPI_VERSION(LW_SR_STATE_PARAM_V1,1)
//! \ingroup dispcontrol
#define LW_SR_STATE_PARAM_VER     LW_SR_STATE_PARAM_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_DISP_GetSelfRefreshPanelStatus
//
//! DESCRIPTION:     This API gets the self refresh panel status register value.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [inout]   pSrStatus       - Out Pointer to the LW_SR_STATE data
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_OK:                          Completed request
//! \retval ::LWAPI_ILWALID_DISPLAY_ID:          Incorrect display ID
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetSelfRefreshPanelStatus(__inout LW_SR_STATE_PARAM* pSrStatus);


//! \ingroup dispcontrol
typedef struct _LW_BURST_SR_ENTRY_PARAM_V1
{
    LwU32                       version;               //!< version info
    LwU32                       displayId;
    LW_SR_ENTRY_METHOD_ENUM     entryMethod;
    LwU32                       extraVFPExtension;     //!< For burst mode, the timing is recallwlated based on max pclk (min of max pclk of panel, GPU, and SRC).
                                                       //!< Therefore, current clk (max pclk) >= pclk used previously. To maintain the same refresh rate, we 
                                                       //!< make the vblank, especially vertical front porch longer. But, sometimes we want to experiment with more
                                                       //!< VFP extension, such as the case of resuming from GPU sleep. 
                                                       //!< Extra vertical front porch timing extension on top of VFP extension resulted from max pclk callwlation.
                                                       //!< Unit is percentage.
    LwU32                       resyncDelay : 2;       //!< The resync delay between GPU and panel. Unit is # of frames
    LwU32                       reserved    : 30;    
}LW_BURST_SR_ENTRY_PARAM_V1;

//! \ingroup dispcontrol
typedef LW_BURST_SR_ENTRY_PARAM_V1      LW_BURST_SR_ENTRY_PARAM;
//! \ingroup dispcontrol 
#define LW_BURST_SR_ENTRY_PARAM_VER_1   MAKE_LWAPI_VERSION(LW_BURST_SR_ENTRY_PARAM_V1,1)
//! \ingroup dispcontrol
#define LW_BURST_SR_ENTRY_PARAM_VER     LW_BURST_SR_ENTRY_PARAM_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_DISP_EnterBurstSelfRefresh
//
//! DESCRIPTION:      This API gets into burst self refresh. Once entered into burst SR, panel 
//!                   stays in self refresh. Scanout is controlled by panel once it enters burst self refresh until
//!                   burst exit is called or panel is reset.
//!                      Another re-entry will cause the panel to recache the frame.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in]       pBurstSREntry   - In Pointer to the LW_BURST_SR_ENTRY data
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_OK:                          Completed request
//! \retval ::LWAPI_ILWALID_DISPLAY_ID:          Incorrect display ID
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_EnterBurstSelfRefresh(__in LW_BURST_SR_ENTRY_PARAM* pBurstSREntry);


//! \ingroup dispcontrol
typedef struct _LW_BURST_SR_EXIT_PARAM_V1
{
    LwU32                     version;            //!< (IN)version info
    LwU32                     displayId;
    LW_SR_EXIT_METHOD_ENUM    exitMethod;
    LwU32                     resyncDelay : 2;    //!< The resync delay between GPU and panel. Unit is # of frames
    LwU32                     reserved    : 30;
}LW_BURST_SR_EXIT_PARAM_V1;

//! \ingroup dispcontrol
typedef LW_BURST_SR_EXIT_PARAM_V1      LW_BURST_SR_EXIT_PARAM;
//! \ingroup dispcontrol 
#define LW_BURST_SR_EXIT_PARAM_VER_1   MAKE_LWAPI_VERSION(LW_BURST_SR_EXIT_PARAM_V1,1)
//! \ingroup dispcontrol
#define LW_BURST_SR_EXIT_PARAM_VER     LW_BURST_SR_EXIT_PARAM_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_DISP_ExitBurstSelfRefresh
//
//! DESCRIPTION:    This API causes the panel to exit burst self refresh. 
//!                 The scanout control is handed back to GPU from panel.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in]     pBurstSRExit    - In Pointer to the LW_BURST_SR_EXIT data
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_OK:                          Completed request
//! \retval ::LWAPI_ILWALID_DISPLAY_ID:          Incorrect display ID
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_ExitBurstSelfRefresh(__in LW_BURST_SR_EXIT_PARAM* pBurstSRExit);


//! \ingroup dispcontrol
typedef struct _LW_BUFFERED_SR_ENTRY_PARAM_V1
{
    LwU32                      version;              //!< (IN)version info
    LwU32                      displayId;
    LW_SR_ENTRY_METHOD_ENUM    entryMethod;
    LwU32                      GPUFramePeriodScale;  //!< Buffered mode means GPU pclk is running faster than 
                                                     //!< the panel pclk by GPUFramePeriodScale times. 
                                                     //!< Note: Because we want to make sure GPU and panel frame time is 
                                                     //!< exactly lining up, this means GPU vertical front porch is longer 
                                                     //!< by GPUFramePeriodScale times than panel vertical front porch. 
    LwU32                      resyncDelay : 2;      //!< The resync delay between GPU and panel. Unit is # of frames
    LwU32                      reserved    : 30;
}LW_BUFFERED_SR_ENTRY_PARAM_V1;

//! \ingroup dispcontrol
typedef LW_BUFFERED_SR_ENTRY_PARAM_V1      LW_BUFFERED_SR_ENTRY_PARAM;
//! \ingroup dispcontrol 
#define LW_BUFFERED_SR_ENTRY_PARAM_VER_1   MAKE_LWAPI_VERSION(LW_BUFFERED_SR_ENTRY_PARAM_V1,1)
//! \ingroup dispcontrol
#define LW_BUFFERED_SR_ENTRY_PARAM_VER     LW_BUFFERED_SR_ENTRY_PARAM_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_DISP_EnterBufferedSelfRefresh
//
//! DESCRIPTION:    This API causes the panel to enter buffered SR
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in]        pBufferedSREntry - In Pointer to the LW_BUFFERED_SR_ENTRY data
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_OK:                          Completed request
//! \retval ::LWAPI_ILWALID_DISPLAY_ID:          Incorrect display ID
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_EnterBufferedSelfRefresh(__in LW_BUFFERED_SR_ENTRY_PARAM* pBufferedSREntry);


//! \ingroup dispcontrol
typedef struct _LW_BUFFERED_SR_EXIT_PARAM_V1
{
    LwU32                     version;             //!< version info
    LwU32                     displayId;
    LW_SR_EXIT_METHOD_ENUM    exitMethod;
    LW_SR_RESYNC_METHOD_ENUM  resyncMethod;
    LwU32                     resyncDelay : 2;    //!< The resync delay between GPU and panel. Unit is # of frames
    LwU32                     reserved    : 30;
}LW_BUFFERED_SR_EXIT_PARAM_V1;

//! \ingroup dispcontrol
typedef LW_BUFFERED_SR_EXIT_PARAM_V1      LW_BUFFERED_SR_EXIT_PARAM;
//! \ingroup dispcontrol 
#define LW_BUFFERED_SR_EXIT_PARAM_VER_1   MAKE_LWAPI_VERSION(LW_BUFFERED_SR_EXIT_PARAM_V1,1)
//! \ingroup dispcontrol
#define LW_BUFFERED_SR_EXIT_PARAM_VER     LW_BUFFERED_SR_EXIT_PARAM_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_DISP_ExitBufferedSelfRefresh
//
//! DESCRIPTION:      This API causes the panel to exit buffered self refresh. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in]        pBufferedSRExit    - In Pointer to the LW_BUFFERED_SR_EXIT data
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_OK:                          Completed request
//! \retval ::LWAPI_ILWALID_DISPLAY_ID:          Incorrect display ID
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_ExitBufferedSelfRefresh(__in LW_BUFFERED_SR_EXIT_PARAM* pBufferedSRExit);



//! \ingroup dispcontrol
typedef struct _LW_LATENCY_STATS
{
    LwU32           min;
    LwU32           max;
    LwU32           average;
}LW_RANGE_STATS;

typedef struct _LW_DISPLAY_SELFREFRESH_STATS
{
    LwU32                   version;             //!< [IN]  Structure version.
    LwU32                   displayId;           //!< [In]  DisplayId of the display.
    LwU32                   totalTime;           //!< [OUT] Total time in milisec for PSR.
    LwU32                   numberOfCycles;      //!< [OUT] Number of PSR cycles (enter + exit).
    LW_RANGE_STATS          resyncLatency;       //!< [OUT] PSR exit triggered to framelock arrival (min/max/average).
    LW_RANGE_STATS          enterLatency;        //!< [OUT] PSR enter triggered to enter done IRQ (min/max/average).
    LW_RANGE_STATS          exitLatency;         //!< [OUT] PSR exit triggered to exit done IRQ (min/max/average).
} LW_DISPLAY_SELFREFRESH_STATS_V1; 

//! \ingroup dispcontrol
typedef LW_DISPLAY_SELFREFRESH_STATS_V1   LW_DISPLAY_SELFREFRESH_STATS;
//! \ingroup dispcontrol 
#define LW_DISPLAY_SELFREFRESH_STATS_VER_1   MAKE_LWAPI_VERSION(LW_DISPLAY_SELFREFRESH_STATS_V1,1)
//! \ingroup dispcontrol
#define LW_DISPLAY_SELFREFRESH_STATS_VER     LW_DISPLAY_SELFREFRESH_STATS_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_DISP_GetSelfRefreshStats
//
//! DESCRIPTION:      This API retrieve panel self refresh (PSR) stats.
//!                   NOTE: All times are in miliseconds
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in]        pSRStats    - In Pointer to the LW_DISPLAY_PANEL_SR_STATUS data
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_OK:                          Completed request
//! \retval ::LWAPI_ILWALID_DISPLAY_ID:          Incorrect display ID
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetSelfRefreshStats(__inout LW_DISPLAY_SELFREFRESH_STATS* pSRStats);


///////////////////////////////////////////////////////////////////////////////
// Clustering APIs
///////////////////////////////////////////////////////////////////////////////

// This category is intentionally added before the #ifdef. The #endif should also be in the same scope
#ifndef LW_CLUSTER_STRUCTS_DEFINED
#define LW_CLUSTER_STRUCTS_DEFINED

//! \addtogroup clusterapi
//! @{
typedef struct _LW_TILE_INFO_V1
{
     LwU32                              version;                //!< Only element 0 must be properly set
     LwU32                              displayId;              //!< this is a unique identifier for display
     LwU32                              locationX;              //!< Physical row position of display in tiles. starts from 0.
     LwU32                              locationY;              //!< Physical column position of display in tiles. starts from 0.
} LW_TILE_INFO_V1;


typedef LW_TILE_INFO_V1       LW_TILE_INFO;

#define LW_TILE_INFO_VER1     MAKE_LWAPI_VERSION(LW_TILE_INFO_V1,1)
#define LW_TILE_INFO_VER      LW_TILE_INFO_VER1

//! PIVOT structure that stores the configuration information of a cluster
typedef struct _LW_PIVOT_V1
{
    LwU32               version;
  
    LW_TIMING           timing;             //!<  The backend timing
    LW_DP_COLOR_FORMAT  colorFormat;        //!<  The color format enum specifier: (RGB/YCbCr422/YCbCr444)
    LW_DP_BPC           backendBitDepth;    //!<  The backend bit-per-component enum specifier: (6,8,10,12, or 16 bits per component)
} LW_PIVOT_V1;

typedef LW_PIVOT_V1       LW_PIVOT;

#define LW_PIVOT_VER1     MAKE_LWAPI_VERSION(LW_PIVOT_V1,1)
#define LW_PIVOT_VER      LW_PIVOT_VER1

//! Enum values for representing the types of the cluster
typedef enum _LW_CLUSTER_TYPE
{
    LW_CLUSTER_TYPE_UNKNOWN = 0,              //!<  Unknown cluster type 
    LW_CLUSTER_TYPE_DP_STREAM_CLONE = 1,      //!<  DisplayPort 1.2 stream cloning cluster
    LW_CLUSTER_TYPE_MOSAIC_SPAN = 2,          //!<  Mosaic Display Cluster
    LW_CLUSTER_TYPE_TILE = 3,                 //!<  Tile Display Cluster
    
} LW_CLUSTER_TYPE;

//! Enum values for representing the states of the cluster
typedef enum _LW_CLUSTER_STATE
{
    LW_CLUSTER_STATE_UNKNOWN   = 0,//!< Unknown state
    LW_CLUSTER_STATE_DISABLED,     //!< A cluster has not been defined yet or is disabled by the user
    LW_CLUSTER_STATE_ENABLED,      //!< Enabled. The cluster may or may not be empty. If the node count is ZERO, the cluster is in DORMANT state, else in ACTIVE state
    LW_CLUSTER_STATE_DELETE,       //!< This flag should be used in LwAPI_GPU_SetupClusterTopology() to delete an existing cluster.
} LW_CLUSTER_STATE;

//! Enum values for representing the discovery mode of the cluster
typedef enum _LW_CLUSTER_DISCOVERY_MODE
{
    LW_CLUSTER_DISCOVERY_MODE_UNKNOWN  = 0,  //!<  Unknown mode type
    LW_CLUSTER_DISCOVERY_MODE_MANUAL,        //!<  The client is responsible for adding/deleting nodes from the cluster. This mode is lwrrently not supported yet.
    LW_CLUSTER_DISCOVERY_MODE_AUTO           //!<  The driver is responsible for adding/deleting nodes from the cluster based on its internal policy
    
} LW_CLUSTER_DISCOVERY_MODE;

#define LW_DEFAULT_CLUSTER_PRIORITY   0       //!<  The driver will assign priority to a given cluster 

typedef struct _LW_CLUSTER_V1
{
    LwU32                       version;
    LwU32                       id;                 //!<  ID that uniquely identifies a cluster. This is a read-only value and is generated by the display driver while setting up the cluster.
    LwU32                       displayId;          //!<  Read only value. This field will be populated while enumerating existing clusters or during creating a new cluster.
    LwU32                       priority;           //!<  Priority of the cluster, 1 being the highest possible priority. The driver will assign a default priority during  
                                                    //!<  setting up the cluster and during creation, this needs to be initialized to LW_DEFAULT_CLUSTER_PRIORITY. 
  
    LW_PIVOT                    pivot;              //!<  The pivot configuration of this cluster
    LW_CLUSTER_TYPE             type;               //!<  The type of cluster (DP1.2 Stream cloning cluster, etc)
    LW_CLUSTER_DISCOVERY_MODE   discoveryMode;      //!<  The nodes' discovery policy
    LW_CLUSTER_STATE            state;              //!<  The current state of the cluster
    LwU32                       numOfNodeEntries;   //!<  The number of nodes in the cluster
    union // The possible types of NODES will be part of this union. The type of nodes will be based on the value of type (LW_CLUSTER_TYPE_ENUM)
    {
      LW_DP_NODE_INFO*          pDPNodeEntries;     //!<  The list of DP1.2 nodes in the cluster
      LW_TILE_INFO*        pTileEntries;       //!<  The list of tile displays in the cluster for LW_CLUSTER_TYPE_TILE
      // When new cluster types are defined, corresponding node types will be added to this union
    };

    LwU32                       isCEDevice      : 1; //!< If at least one of the device in the cluster is CE device, then the cluster will be marked as CE device
                                                     //!< This is a read-only value and is set by DD while setting up the cluster.
    LwU32                       isAudioCapable  : 1; //!< If there exists at least one audio capable device in the cluster  
                                                     //!< This is a read-only value and is set by DD while setting up the cluster.
    LwU32                       reserved        : 30;//!< Should be zero
  
} LW_CLUSTER_V1;

typedef LW_CLUSTER_V1   LW_CLUSTER;

#define LW_CLUSTER_VER1    MAKE_LWAPI_VERSION(LW_CLUSTER_V1,1)
#define LW_CLUSTER_VER     LW_CLUSTER_VER1


//! @}

// This category is intentionally added before the #endif. The #ifdef should also be in the same scope
#endif LW_CLUSTER_STRUCTS_DEFINED

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GPU_EnumClusterTopologies
//
//! DESCRIPTION: This API enumerates the clusters associated with a physical connector. Use this API to either enumerate all the 
//!              possible cluster topologies on the physical connector for a given Pivot configuration or 
//!              to enumerate all the clusters that were created/defined on the physical connector. The client 
//!              should keep enumerating until LWAPI_END_ENUMERATION is returned.
//!
//!  - To enumerate the possible clusters for a given configuration, set pPivot to the configuration needed.
//!  - To enumerate the current clusters that are defined on the connector, set pPivot to NULL.
//!                
//!  To enumerate the possible clusters for a given configuration:
//!    # Set the pPivot value to the desired configuration.
//!    # Set the following fields of the LW_CLUSTER structure :
//!      1. discoveryMode to LW_CLUSTER_DISCOVERY_MODE_AUTO.
//!      2. type to one of the LW_CLUSTER_TYPE enum values.
//!    # Starting with ZERO for thisENUM, repeatedly call LwAPI_GPU_EnumClusterTopologies in a loop, while incrementing thisENUM 
//!       for each iteration until LWAPI_END_ENUMERATION is returned.
//!    # For each iteration, call LwAPI_GPU_EnumClusterTopologies twice (see the note below), first to get the cluster details including the number
//!       of nodes in the cluster, and then to retrieve the complete node list.
//!    # During the first call, set the corresponding node's pointer to NULL. If the call succeeds, 
//!       the numOfNodeEntries value will have the node count for the cluster.
//!    # Allocate memory based on numOfNodeEntries and set the pointer for the nodes list and call LwAPI_GPU_EnumClusterTopologies
//!       again to fetch the complete node topology.
//!
//!  To enumerate the clusters defined on a given connector:
//!    # Follow the same steps as above, except set pPivot to NULL.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     rootDisplayId     For LW_CLUSTER_TYPE_DP_STREAM_CLONE, this is the displayId of the connector to which the topology is rooted.
//!                                   For LW_CLUSTER_TYPE_TILE, by passing any displayId of GPU, all Tile cluster of that GPU can be enumerated.
//! \param [in]     pPivot            This is the pivot that defines the cluster parameters. If this is NULL, then this call translates into
//!                                   enumerating the existing clusters.
//! \param [in]     thisEnum          Index of cluster whose topology is requested 
//! \param [in,out] pClusterTopology  Pointer to a LW_CLUSTER structure
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_END_ENUMERATION     - no more clusters to enumerate.
//! \retval ::LWAPI_INSUFFICIENT_BUFFER - the number of nodes allocated for pClusterTopology->pDPNodeEntries is insufficient. 
//!                                       The actual nodes' count is returned in pClusterTopology->numOfNodeEntries.
//!
//! \ingroup clusterapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_EnumClusterTopologies(__in LwU32 rootDisplayId, __in_opt LW_PIVOT* pPivot, __in LwU32 thisEnum, __inout LW_CLUSTER* pClusterTopology);


//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GPU_SetupClusterTopology
//
//! DESCRIPTION:  This API sets up - or re-configures - a cluster on the physical connector identified by the passed in rootDisplayId.
//!               The pivot within the LW_CLUSTER structure holds the configuration information of the target cluster. 
//!               A node cannot belong to more than 1 cluster at any given point of time. The pivot configuration, combined 
//!               with the list of nodes in the cluster, uniquely describes a cluster.
//!
//!
//!  This API can be used to set up a completely new cluster and also to re-configure any existing cluster. The clusterId parameter is 
//!  used to distinguish between both the scenarios. When this parameter is set to NULL, this API reconfigures an existing cluster, otherwise
//!  it sets up a new cluster.  Note that, if a cluster has been created on a connector with the discovery mode set to 
//!  LW_CLUSTER_DISCOVERY_MODE_AUTO, then no more clusters can be set up on the same connector until the auto mode cluster is torn down.  
//!  
//! ============================================================================================================
//!
//!  <b> Setting up a new cluster </b>
//!
//!  
//!  \param [in] rootDisplayId   This is the displayId of the physical connector on which the cluster is to be defined.
//!
//!  The client should fill the following member variables in the LW_CLUSTER structure
//!  \param [in] pClusterTopology::pivot  The configuration of the cluster to be set up. 
//!                                       This is only used when discoveryMode = LW_CLUSTER_DISCOVERY_MODE_AUTO.
//!                                       When discoveryMode = LW_CLUSTER_DISCOVERY_MODE_MANUAL, 
//!                                       the driver will decide the best pivot configuration possible
//!                                       for the given list of monitors. 
//!                                       In this mode, if there is no common configuration possible, this API will fail
//!                                       with LWAPI_CLUSTER_NODES_MISMATCH error.
//!                 
//!  NOTE: Lwrrently interlaced timing is not supported and when pivot.timing.interlaced is set to '1', this API will fail with LWAPI_SET_NOT_ALLOWED.
//!
//!
//!  \param [in]  pClusterTopology::type  The type of cluster
//!  \param [in]  pClusterTopology::discoveryMode     The nodes' inclusion and exclusion policy. Lwrrently only LW_CLUSTER_DISCOVERY_MODE_AUTO is supported.
//!                                       When discoveryMode = LW_CLUSTER_DISCOVERY_MODE_AUTO, the numOfNodeEntries 
//!                                       should be 0 and pDPNodeEntries should be NULL.
//!                                       When discoveryMode = LW_CLUSTER_DISCOVERY_MODE_MANUAL, 
//!                                       - if the numOfNodeEntries > 0, then pDPNodeEntries cannot be NULL.
//!                                       - if the numOfNodeEntries == 0, then pDPNodeEntries should be NULL. In this 
//!                                         case a empty cluster will be set up and the cluster state will be set to 
//!                                         LW_CLUSTER_STATE_DORMANT.
//!  \param [in/out]  pClusterTopology::numOfNodeEntries  The number of nodes in the cluster
//!                                       ([in] Valid only when discoveryMode = LW_CLUSTER_DISCOVERY_MODE_MANUAL)
//!                                       ([out] Valid only when discoveryMode = LW_CLUSTER_DISCOVERY_MODE_AUTO)        
//!  \param [in]  pClusterTopology::pDPNodeEntries    The list of nodes in the cluster 
//!                                       (Valid only when discoveryMode = LW_CLUSTER_DISCOVERY_MODE_MANUAL)
//!
//!  All other variables of the LW_CLUSTER struct are ignored and should be set to ZERO.
//!
//!  \param [out] clusterId                The id of the cluster that gets created if the call is successful. 
//!               
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//!
//!  \retval ::LWAPI_CLUSTER_ALREADY_EXISTS - Another cluster with the same configuration or whose discovery mode is 
//!                                           LW_CLUSTER_DISCOVERY_MODE_AUTO is already created on this connector.
//!  \retval ::LWAPI_SET_NOT_ALLOWED        - The combination of the input is not allowed or is not lwrrently supported.
//!
//! ======================================================================================================================  
//!             
//!  <b> Configuring an existing cluster </b>
//!
//!  \param [in] rootDisplayId    This is the displayId of the physical connector on which the cluster is already defined.
//!
//!  The client should fill the following variables in the LW_CLUSTER structure:
//!  \param [in]  LW_CLUSTER::id           The id of the cluster that was generated during creation.  
//!  \param [in]  LW_CLUSTER::priority     To keep the priority unchanged, set this to LW_DEFAULT_CLUSTER_PRIORITY. 
//!                                        To alter the existing priority, set this to the desired value (non-zero) and if the priority
//!                                        already exists, it slides the priority down of every item = or >. 
//!                                        So if you insert priority 1, it becomes the highest, and everyone else slides down the line.
//!  \param [in] LW_CLUSTER::discoveryMode  The discovery mode of an existing cluster cannot be changed. 
//!                                        The value set here will be used in tandem with the nodes' list to alter the nodes in the existing cluster. 
//!                                        The only valid values in this scenario are LW_CLUSTER_DISCOVERY_MODE_UNKNOWN and LW_CLUSTER_DISCOVERY_MODE_MANUAL.
//!                       Use LW_CLUSTER_DISCOVERY_MODE_UNKNOWN when no change is required in the nodes' list. 
//!                       Use LW_CLUSTER_DISCOVERY_MODE_MANUAL, when altering the nodes in the cluster. Note that modifying the nodes 
//!                       list is only possible when the cluster itself was created with LW_CLUSTER_DISCOVERY_MODE_MANUAL
//!                       in the first place. 
//!  \param [in] LW_CLUSTER::numOfNodeEntries  The number of nodes in the cluster 
//!                                        (Valid only when discoveryMode = LW_CLUSTER_DISCOVERY_MODE_MANUAL)
//!  \param [in] LW_CLUSTER::pDPNodeEntries    The list of nodes in the cluster 
//!                                        (Valid only when discoveryMode = LW_CLUSTER_DISCOVERY_MODE_MANUAL)
//!  \param [in] LW_CLUSTER::state         - LW_CLUSTER_STATE_DISABLED : to disable an exisiting cluster.
//!                                        - LW_CLUSTER_STATE_ENABLED  : to enable an exisiting disabled cluster.
//!                                        - LW_CLUSTER_STATE_DELETE   : to delete an exisiting cluster.
//!       
//!    All other variables of the LW_CLUSTER struct are ignored and should be set to ZERO.
//!
//!  \param [out]clusterId                Not set by the callee. Clients should not use this and should be passing NULL. 
//!               
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup clusterapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetupClusterTopology(__in LwU32 rootDisplayId, __inout LW_CLUSTER* pClusterTopology, __out_opt LwU32* clusterId);


//! \ingroup gpu
//! @{

typedef enum _LW_IMP_MODE_STRUCTURE
{
    LW_IMP_MODE_INTERLACED = 0,
    LW_IMP_MODE_PROGRESSIVE,               
} LW_IMP_MODE_TYPE;

typedef enum _LW_IMP_VERTICAL_TAPS
{
    LW_IMP_MODE_VERTICAL_TAPS1 = 0,
    LW_IMP_MODE_VERTICAL_TAPS2,
    LW_IMP_MODE_VERTICAL_TAPS3,
    LW_IMP_MODE_VERTICAL_TAPS3_ADAPTIVE,
    LW_IMP_MODE_VERTICAL_TAPS5,                   
} LW_IMP_VERTICAL_TAPS;

typedef enum _LW_IMP_HORIZONTAL_TAPS
{
    LW_IMP_MODE_HORIZONTAL_TAPS1 = 0,
    LW_IMP_MODE_HORIZONTAL_TAPS2,
    LW_IMP_MODE_HORIZONTAL_TAPS8,      
} LW_IMP_HORIZONTAL_TAPS;

typedef enum _LW_IMP_FORMAT
{
    LW_IMP_MODE_FORMAT_I8 = 0,
    LW_IMP_MODE_FORMAT_VOID16,
    LW_IMP_MODE_FORMAT_VOID32,
    LW_IMP_MODE_FORMAT_RF16_GF16_BF16_AF16,
    LW_IMP_MODE_FORMAT_A8R8G8B8,
    LW_IMP_MODE_FORMAT_A2B10G10R10,
    LW_IMP_MODE_FORMAT_A8B8G8R8,
    LW_IMP_MODE_FORMAT_R5G6B5,
    LW_IMP_MODE_FORMAT_A1R5G5B5
} LW_IMP_FORMAT;

typedef enum _LW_IMP_SUPERSAMPLE
{
    LW_IMP_MODE_SS_X1AA = 0,
    LW_IMP_MODE_SS_X4AA,               
} LW_IMP_SUPERSAMPLE;

typedef enum _LW_IMP_BASE_USAGE_BOUNDS_USABLE
{
    LW_IMP_MODE_BASE_USAGE_BOUNDS_USABLE_LWRRENT = 0,
    LW_IMP_MODE_BASE_USAGE_BOUNDS_USABLE_NO,
    LW_IMP_MODE_BASE_USAGE_BOUNDS_USABLE_YES,
} LW_IMP_BASE_USAGE_BOUNDS_USABLE;

typedef enum _LW_IMP_BASE_USAGE_BOUNDS_DEPTH
{
    LW_IMP_MODE_BASE_USAGE_BOUNDS_DEPTH_LWRRENT = 0,
    LW_IMP_MODE_BASE_USAGE_BOUNDS_DEPTH_8,
    LW_IMP_MODE_BASE_USAGE_BOUNDS_DEPTH_16,
    LW_IMP_MODE_BASE_USAGE_BOUNDS_DEPTH_32,
    LW_IMP_MODE_BASE_USAGE_BOUNDS_DEPTH_64,
} LW_IMP_BASE_USAGE_BOUNDS_DEPTH;

typedef enum _LW_IMP_BASE_USAGE_BOUNDS_SS
{
    LW_IMP_MODE_BASE_USAGE_BOUNDS_SS_LWRRENT = 0,
    LW_IMP_MODE_BASE_USAGE_BOUNDS_SS_X1AA,
    LW_IMP_MODE_BASE_USAGE_BOUNDS_SS_X4AA,
} LW_IMP_BASE_USAGE_BOUNDS_SS;

typedef enum _LW_IMP_BASE_USAGE_BOUNDS_LUT
{
    LW_IMP_MODE_BASE_USAGE_BOUNDS_BASE_LUT_USAGE_NONE = 0,
    LW_IMP_MODE_BASE_USAGE_BOUNDS_BASE_LUT_USAGE_257,             
    LW_IMP_MODE_BASE_USAGE_BOUNDS_BASE_LUT_USAGE_1025,
} LW_IMP_BASE_USAGE_BOUNDS_BASE_LUT;

typedef enum _LW_IMP_BASE_USAGE_BOUNDS_OUTPUT_LUT
{
    LW_IMP_MODE_BASE_USAGE_BOUNDS_OUTPUT_LUT_USAGE_NONE = 0,
    LW_IMP_MODE_BASE_USAGE_BOUNDS_OUTPUT_LUT_USAGE_257,             
    LW_IMP_MODE_BASE_USAGE_BOUNDS_OUTPUT_LUT_USAGE_1025,
} LW_IMP_BASE_USAGE_BOUNDS_OUTPUT_LUT;

typedef enum _LW_IMP_OVERLAY_USAGE_BOUNDS_USABLE
{
    LW_IMP_MODE_OVERLAY_USAGE_BOUNDS_USABLE_USE_LWRRENT = 0,
    LW_IMP_MODE_OVERLAY_USAGE_BOUNDS_USABLE_NO,
    LW_IMP_MODE_OVERLAY_USAGE_BOUNDS_USABLE_YES,
} LW_IMP_OVERLAY_USAGE_BOUNDS_USABLE;

typedef enum _LW_IMP_OVERLAY_USAGE_BOUNDS_DEPTH
{
    LW_IMP_MODE_OVERLAY_USAGE_BOUNDS_PIXEL_DEPTH_USE_LWRRENT = 0,
    LW_IMP_MODE_OVERLAY_USAGE_BOUNDS_PIXEL_DEPTH_16,
    LW_IMP_MODE_OVERLAY_USAGE_BOUNDS_PIXEL_DEPTH_32,
    LW_IMP_MODE_OVERLAY_USAGE_BOUNDS_PIXEL_DEPTH_64,
} LW_IMP_OVERLAY_USAGE_BOUNDS_DEPTH;

typedef enum _LW_IMP_OVERLAY_USAGE_BOUNDS_OUTPUT_LUT
{
    LW_IMP_MODE_OVERLAY_USAGE_BOUNDS_OVERLAY_LUT_USAGE_NONE = 0,
    LW_IMP_MODE_OVERLAY_USAGE_BOUNDS_OVERLAY_LUT_USAGE_257,             
    LW_IMP_MODE_OVERLAY_USAGE_BOUNDS_OVERLAY_LUT_USAGE_1025,
} LW_IMP_OVERLAY_USAGE_BOUNDS_OUTPUT_LUT;

typedef enum _LW_IMP_BASE_LUT_LO_MODE
{
    LW_IMP_MODE_BASE_LUT_LO_MODE_LORES = 0,
    LW_IMP_MODE_BASE_LUT_LO_MODE_HIRES,
    LW_IMP_MODE_BASE_LUT_LO_MODE_INDEX_1025_UNITY_RANGE,
    LW_IMP_MODE_BASE_LUT_LO_MODE_INTERPOLATE_1025_UNITY_RANGE,
    LW_IMP_MODE_BASE_LUT_LO_MODE_INTERPOLATE_1025_XRBIAS_RANGE,
    LW_IMP_MODE_BASE_LUT_LO_MODE_INTERPOLATE_1025_XVYCC_RANGE,
    LW_IMP_MODE_BASE_LUT_LO_MODE_INTERPOLATE_257_UNITY_RANGE,
    LW_IMP_MODE_BASE_LUT_LO_MODE_INTERPOLATE_257_LEGACY_RANGE,
} LW_IMP_BASE_LUT_LO_MODE;

typedef enum _LW_IMP_OUTPUT_LUT_LO_MODE
{
    LW_IMP_MODE_OUTPUT_LUT_LO_MODE_LORES = 0,
    LW_IMP_MODE_OUTPUT_LUT_LO_MODE_HIRES,
    LW_IMP_MODE_OUTPUT_LUT_LO_MODE_INDEX_1025_UNITY_RANGE,
    LW_IMP_MODE_OUTPUT_LUT_LO_MODE_INTERPOLATE_1025_UNITY_RANGE,
    LW_IMP_MODE_OUTPUT_LUT_LO_MODE_INTERPOLATE_1025_XRBIAS_RANGE,
    LW_IMP_MODE_OUTPUT_LUT_LO_MODE_INTERPOLATE_1025_XVYCC_RANGE,
    LW_IMP_MODE_OUTPUT_LUT_LO_MODE_INTERPOLATE_257_UNITY_RANGE,
    LW_IMP_MODE_OUTPUT_LUT_LO_MODE_INTERPOLATE_257_LEGACY_RANGE,
} LW_IMP_OUTPUT_LUT_LO_MODE;

typedef enum _LW_IMP_OUTPUT_RESOURCE_PIXEL_DEPTH
{
    LW_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_DEFAULT = 0,
    LW_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_16_422,           
    LW_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_18_444,           
    LW_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_20_422,           
    LW_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_24_422,          
    LW_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_24_444,           
    LW_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_30_444,           
    LW_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_32_422,          
    LW_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_36_444,         
    LW_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_48_444,          
} LW_IMP_OUTPUT_RESOURCE_PIXEL_DEPTH;

typedef enum _LW_IMP_PIXEL_REPLICATE_MODE
{
    LW_IMP_MODE_PIXEL_REPLICATE_MODE_OFF = 0,
    LW_IMP_MODE_PIXEL_REPLICATE_MODE_X2,
    LW_IMP_MODE_PIXEL_REPLICATE_MODE_X4,
}LW_IMP_PIXEL_REPLICATE_MODE;

typedef enum _LW_IMP_REQUESTED_OPERATION
{
    LW_IMP_MODE_REQUESTED_OPERATION_QUERY = 0,
    LW_IMP_MODE_REQUESTED_OPERATION_PRE_MODESET,
    LW_IMP_MODE_REQUESTED_OPERATION_POST_MODESET,
    LW_IMP_MODE_REQUESTED_OPERATION_QUERY_USE_SC,
    LW_IMP_MODE_REQUESTED_OPERATION_PRE_MODESET_USE_SC,
    LW_IMP_MODE_REQUESTED_OPERATION_POST_MODESET_USE_SC,
    LW_IMP_MODE_REQUESTED_OPERATION_COMPUTE_DMI_DURATION,
// This argument is for VERIF and INTERNAL use only
    LW_IMP_MODE_REQUESTED_OPERATION_SUPERVISOR,
}LW_IMP_REQUESTED_OPERATION;

typedef enum _LW_IMP_POSSIBLE_PSTATES
{
    LW_IMP_MODE_POSSIBLE_PSTATES_UNDEFINED = 0,
    LW_IMP_MODE_POSSIBLE_PSTATES_P0,
    LW_IMP_MODE_POSSIBLE_PSTATES_P1,
    LW_IMP_MODE_POSSIBLE_PSTATES_P2,
    LW_IMP_MODE_POSSIBLE_PSTATES_P3,
    LW_IMP_MODE_POSSIBLE_PSTATES_P8,
    LW_IMP_MODE_POSSIBLE_PSTATES_P10,
    LW_IMP_MODE_POSSIBLE_PSTATES_P12,
    LW_IMP_MODE_POSSIBLE_PSTATES_P15,
    LW_IMP_MODE_POSSIBLE_PSTATES_MAX = 8,
}LW_IMP_POSSIBLE_PSTATES;

typedef struct _LW_IMP_MODE_EX_V1
{
    LwU32 version;
    LwU32 displayId; 
    LwU32 isHeadActive :1;
    LwU32 isPossible :1;
    LwU32 reserved :30;

    struct
    {
         LwU32 frequency;
         LwU32 adj1000Div1001;
    } PixelClock;

    struct
    {    
         LwU32 width;
         LwU32 height;
    } RasterSize;

    struct
    {
         LwU32 x;
         LwU32 y;
    } RasterBlankStart;

    struct
    {   
         LwU32 x;
         LwU32 y;
    } RasterBlankEnd;

    struct
    {    
         LwU32 yStart;
         LwU32 yEnd;
    } RasterVertBlank2;
    
    struct
    {
         LwU32 width;
         LwU32 height;
    } ViewportSizeOut;

    struct
    {
         LwU32 width;
         LwU32 height;
    } ViewportSizeOutMin;

    struct
    {
         LwU32 width;
         LwU32 height;
    } ViewportSizeOutMax;

    struct
    { 
         LwU32 width;
         LwU32 height;
    } ViewportSizeIn;
        
    struct
    {
         LW_IMP_MODE_TYPE structure;
    } Control;
   
    struct
    {
         LW_IMP_VERTICAL_TAPS verticalTaps;
         LW_IMP_HORIZONTAL_TAPS horizontalTaps;
         LwU32 force422 :1;
         LwU32 reserved :31;
    } OutputScaler;
    
    struct
    {
         LW_IMP_FORMAT format;
         LW_IMP_SUPERSAMPLE superSample;
    } ChannelParams;

    struct
    {    
         LW_IMP_BASE_USAGE_BOUNDS_USABLE usable;
         LW_IMP_BASE_USAGE_BOUNDS_DEPTH pixelDepth;
         LW_IMP_BASE_USAGE_BOUNDS_SS superSample;
         LW_IMP_BASE_USAGE_BOUNDS_BASE_LUT baseLutUsage;
         LW_IMP_BASE_USAGE_BOUNDS_OUTPUT_LUT outputLutUsage;
    } BaseUsageBounds;
      
    struct
    {
         LW_IMP_OVERLAY_USAGE_BOUNDS_USABLE usable;
         LW_IMP_OVERLAY_USAGE_BOUNDS_DEPTH pixelDepth;
         LW_IMP_OVERLAY_USAGE_BOUNDS_OUTPUT_LUT overlayLutUsage;
    } OverlayUsageBounds;

    struct
    {
         LwU32 enable :1;
         LwU32 reserved :31;
         LW_IMP_BASE_LUT_LO_MODE       mode;
    } BaseLutLo;
       
    struct
    {
         LwU32 enable :1;
         LwU32 reserved :31;
         LW_IMP_OUTPUT_LUT_LO_MODE       mode;
    } OutputLutLo;

    LW_IMP_OUTPUT_RESOURCE_PIXEL_DEPTH outputResourcePixelDepthBPP;
     
    struct
    {
        LwU32 owner;
        LwU32 protocol;
    } Dac;

    struct
    {
        LwU32 owner;
        LwU32 protocol;
        LW_IMP_PIXEL_REPLICATE_MODE pixelReplicateMode;
    } Sor;

    struct
    {
        LwU32 owner;
        LwU32 protocol;
    } Pior;

    LW_IMP_REQUESTED_OPERATION requestedOperation;

    LwU32 duration;

    LW_IMP_POSSIBLE_PSTATES minPState;
        
} LW_IMP_MODE_EX_V1;
 
typedef LW_IMP_MODE_EX_V1 LW_IMP_MODE_EX;

#define LW_IMP_MODE_EX_VER_1 MAKE_LWAPI_VERSION(LW_IMP_MODE_EX_V1,1)

#define LW_IMP_MODE_EX_VER   LW_IMP_MODE_EX_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Disp_ConstructIMPModeEx
//
//! DESCRIPTION:   This function will colwert the mode data from the
//!                pPathInfo input to the display driver version of the
//!                IMP structure used for IsModePossible calls.
//!
//! PARAMETERS:    pPathInfo    (IN)  - Pointer to a display path Info
//!                pathCount    (IN)  - Count of displayConfig paths
//!                pIMPMode     (OUT) - IMP version of display path
//!                modeCount    (IN/OUT)  - Count of IMPmode paths
//!
//!    FOR INTERNAL TOOL USE ONLY
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!  USAGE:     The caller might have to call this two times to fetch all the required configuration details as follows: \n 
//!             First  Pass: Caller should Call LwAPI_Disp_ConstructIMPModeEx() with pIMPMode set to NULL to fetch correct modeCount depending on the pPathInfo and pathCount passed. 
//!             Second Pass: Allocate memory for pIMPMode with respect to the number of modeCount(from First Pass) to fetch the correct Mode information.
//!
//! RETURN STATUS:
//!              This API can return any of the error codes enumerated in #LwAPI_Status. 
//!              Error codes specific to this API are described below.
//!              (None)
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Disp_ConstructIMPModeEx(__in_ecount(pathCount) LW_DISPLAYCONFIG_PATH_INFO* pPathInfo, __in LwU32 pathCount, __inout_ecount(*modeCount) LW_IMP_MODE_EX* pIMPMode, __inout LwU32* modeCount);

//! @}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_GetDisplayConfig
//
//! DESCRIPTION:     This API lets caller retrieve the current global display
//!                  configuration.
//!       USAGE:     The caller might have to call this three times to fetch all the required configuration details as follows:
//!                  First  Pass: Caller should Call LwAPI_DISP_GetDisplayConfig() with pathInfo set to NULL to fetch pathInfoCount.
//!                  Second Pass: Allocate memory for pathInfo with respect to the number of pathInfoCount(from First Pass) to fetch 
//!                               targetInfoCount. If sourceModeInfo is needed allocate memory or it can be initialized to NULL.
//!             Third  Pass(Optional, only required if target information is required): Allocate memory for targetInfo with respect 
//!                               to number of targetInfoCount(from Second Pass).               
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out]  pathInfoCount    Number of elements in pathInfo array, returns number of valid topologies, this cannot be null.
//! \param [in,out]  pathInfo         Array of path information
//!
//! \return    This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \retval    LWAPI_ILWALID_ARGUMENT  -   Invalid input parameter. Following can be the reason for this return value:
//!                                        -# pathInfoCount is NULL.
//!                                        -# *pathInfoCount is 0 and pathInfo is not NULL.
//!                                        -# *pathInfoCount is not 0 and pathInfo is NULL.
//! \retval    LWAPI_DEVICE_BUSY       -   ModeSet has not yet completed. Please wait and call it again.
//!                                       
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetDisplayConfig(__inout LwU32 *pathInfoCount, __out_ecount_full_opt(*pathInfoCount) LW_DISPLAYCONFIG_PATH_INFO *pathInfo);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_SetDisplayConfig
//
//
//! DESCRIPTION:     This API lets caller apply a global display configuration
//!                  across multiple GPUs.
//!
//!                  If all sourceIds are zero, then LwAPI will pick up sourceId's based on the following criteria :
//!                  - If user provides sourceModeInfo then we are trying to assign 0th sourceId always to GDIPrimary. 
//!                     This is needed since active windows always moves along with 0th sourceId.
//!                  - For rest of the paths, we are incrementally assigning the sourceId per adapter basis.
//!                  - If user doesn't provide sourceModeInfo then LWAPI just picks up some default sourceId's in incremental order.
//!                  Note : LWAPI will not intelligently choose the sourceIDs for any configs that does not need a modeset.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pathInfoCount   Number of supplied elements in pathInfo
//! \param [in]      pathInfo        Array of path information
//! \param [in]      flags           Flags for applying settings
//! 
//! \retval ::LWAPI_OK - completed request
//! \retval ::LWAPI_API_NOT_INTIALIZED - LWAPI not initialized
//! \retval ::LWAPI_ERROR - miscellaneous error oclwrred
//! \retval ::LWAPI_ILWALID_ARGUMENT - Invalid input parameter.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_SetDisplayConfig(__in LwU32 pathInfoCount, __in_ecount(pathInfoCount) LW_DISPLAYCONFIG_PATH_INFO* pathInfo, __in LwU32 flags);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Hybrid_SetHybridModeAndDisplayConfig
//
//! DESCRIPTION:     This request will set the hybrid mode, and attempt to 
//!                  apply the display settings after the transition. If the 
//!                  requested settings cannot be applied, a default path will 
//!                  be applied, and status will return LWAPI_PATH_IGNORED.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      mode(IN)     - hybrid mode
//!                  pathInfoCount(IN) - Number of supplied elements in pathInfo
//!                  pathInfo(IN) - Array of path information
//!                  flags(IN) - Flags for applying settings
//!
//! RETURN STATUS:
//!                  LWAPI_OK - completed request
//!                  LWAPI_API_NOT_INTIALIZED - LWAPI not initialized
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter.
//!                  LWAPI_PATH_IGNORED - The transition was successful, but
//!                                           the requested path could not
//!                                           be applied.
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Hybrid_SetHybridModeAndDisplayConfig(LW_HYBRID_MODE mode, LwU32 pathInfoCount, LW_DISPLAYCONFIG_PATH_INFO* pathInfo, LwU32 flags);








//! \ingroup dispcontrol
//! @{


typedef struct _LW_TV_CLASSIFICATION_TYPE
{
    LwU32 isPC      : 1;    //!< supports at least one PC timing, as defined by the VESA specification
    LwU32 isSDTV    : 1;    //!< supports at least one SDTV timing (720x480i or 720x576i)   
    LwU32 isEDTV    : 1;    //!< supports at least one EDTV timing (720x480p or 720x576p)
    LwU32 isHDTV    : 1;    //!< supports at least one HDTV timing (1920x1080i or 1280x720p or above)
    LwU32 reserved  : 28;
} LW_TV_CLASSIFICATION_TYPE;

typedef struct _LW_TV_CLASSIFICATION
{
    LwU32 version;
    // the TV classification based on the combination of the display's EDID (if it 
    // has a valid one)connector, and bandwidth of the display link as determined 
    // by the display driver
    LW_TV_CLASSIFICATION_TYPE identifiedAs;       
    
    // the TV classification based on the modes supported by the entire hardware &
    // software stack, including modes added by an operating system or end user 
    // which are not present in the EDID
    LW_TV_CLASSIFICATION_TYPE treatedAs;    
} LW_TV_CLASSIFICATION;

//! Macro for constructing the version field of ::_LW_TV_CLASSIFICATION
#define LW_TV_CLASSIFICATION_VER  MAKE_LWAPI_VERSION(LW_TV_CLASSIFICATION,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_GetTvClassification
//
//! DESCRIPTION:     Given a display Id, this API returns the monitor's TV 
//!                  classifications based on the monitor's EDID or connector 
//!                  type and customer's usage.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      displayId(IN) - LWPU Display ID. It is the value 
//!                                  returned from 
//!                                  LwAPI_SYS_GetDisplayIdFromGpuAndOutputId()
//!                  pTvClass(OUT) - Pointer to struct LW_TV_CLASSIFICATION. 
//!                                  Returns various TV Classification for a 
//!                                  given displayId.
//!
//! RETURN STATUS:
//!                  LWAPI_OK - *pTvClass has a LW_TV_CLASSIFICATION value
//!                  LWAPI_API_NOT_INTIALIZED - LWAPI not initialized
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter.
//!                  LWAPI_INCOMPATIBLE_STRUCT_VERSION - Incompatible structure version
//!                  LWAPI_LWIDIA_DEVICE_NOT_FOUND - The display specified by displayId is not connected
//!                  LWAPI_ID_OUT_OF_RANGE - The DisplayId corresponds to a 
//!                                          display which is not within the
//!                                          normal outputId range.
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetTvClassification(LwU32 displayId, LW_TV_CLASSIFICATION *pTvClass);

//! @}







//! \ingroup dispcontrol
//! @{

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_GetSourceModeSet
//
//! \fn LwAPI_DISP_GetSourceModeSet(__in LW_DISPLAY_TOPOLOGY        *pTopology,                                     
//!
//! DESCRIPTION:     This API lets caller retrieve the source mode set corresponding to a particular path on a given VidPn topology.
//!                  Pass NULL for pSourceModeSet to obtain the number of source mode that will be returned.
//! 
//!                  NOTE: For performance consideration, each call to query size of the source mode set should immediately be followed by
//!                        a call to retrieve the source mode set. That is, avoid calling this API with alternating pathIndex.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      pTopolgy(IN)                - Representing the required VidPN topology for which source mode set is to be enumerated.
//!                                                Pinning a source mode on any path is being ignored at the present, in the future, 
//!                                                they may be used to evaluate the IMP condition of the source mode set returned.
//!                  pathIndex(IN)               - Index to pTopology for the required VidPN path containing the source id
//!                  pSourceModeSet(IN/OUT)      - The array of source mode that will be returned
//!                                                Set version to current LW_DISPLAY_SOURCE_MODE struct for least the first element
//!                  pSourceModeCount(IN/OUT)    - IN: The number of source mode allocated in pSourceModeSet
//!                                              - OUT: The number of source mode returned
//!                  bIsFilteringIlwalidMode(IN) - Defaulting to false. TRUE if and only if caller wants only valid source mode in the output
//!
//! RETURN STATUS:
//!                  LWAPI_OK                    - completed request
//!                  LWAPI_NO_IMPLEMENTATION     - This interface is only supported by Windows Vista and above
//!                  LWAPI_ERROR                 - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT      - Invalid input parameter.
//!                  LWAPI_OUT_OF_MEMORY         - Not enough memory to allocate internal cached source mode table
//
///////////////////////////////////////////////////////////////////////////////

typedef enum
{  
    LW_DISPLAY_SOURCE_FILTER_NONE                               = 0,
    LW_DISPLAY_SOURCE_FILTER_DUPLICATE                          = 1,
    LW_DISPLAY_SOURCE_FILTER_1400x1050                          = 2,
    LW_DISPLAY_SOURCE_FILTER_ILWALID                            = 3,
    LW_DISPLAY_SOURCE_FILTER_CRT_NO_EDID_MATCH                  = 4,
    LW_DISPLAY_SOURCE_FILTER_DFPTV_TOO_LARGE_PRIMARY            = 5,
    LW_DISPLAY_SOURCE_FILTER_DFPTV_TOO_LARGE_CLONE              = 6,
    LW_DISPLAY_SOURCE_FILTER_DFPTV_UNDERSCAN                    = 7,
    LW_DISPLAY_SOURCE_FILTER_DFPTV_TOO_LARGE_NO_EDID            = 8,
    LW_DISPLAY_SOURCE_FILTER_HDTV_TOO_LARGE                     = 9,
    LW_DISPLAY_SOURCE_FILTER_SDTV_TOO_LARGE                     = 10,
    LW_DISPLAY_SOURCE_FILTER_DFP_CLONE_UNDERSCAN                = 11,
    LW_DISPLAY_SOURCE_FILTER_DFP_CLONE_TOO_LARGE                = 12,
    LW_DISPLAY_SOURCE_FILTER_LOGIC_SCALING                      = 13,
    LW_DISPLAY_SOURCE_FILTER_UNRECOGNIZED                       = 14,
    LW_DISPLAY_SOURCE_FILTER_ES_GPU                             = 15,
    LW_DISPLAY_SOURCE_FILTER_DFPTV_NOT_CE_FOR_HDMI              = 16,
    LW_DISPLAY_SOURCE_FILTER_HYBRID_EXCEEDED_MAX_LIMIT          = 17,
    LW_DISPLAY_SOURCE_FILTER_HYBRID_INTERPOSER                  = 18,
    LW_DISPLAY_SOURCE_FILTER_MCP7X_IMP_WAR                      = 19,
    LW_DISPLAY_SOURCE_FILTER_R_AND_T                            = 20,
    LW_DISPLAY_SOURCE_FILTER_VIDPN_TARGET_COMBINATION           = 21,   //!< invalid when specified in the source/target context of VidPn
    LW_DISPLAY_SOURCE_FILTER_COPROC_RESOLUTION_LIMITER          = 22,
    LW_DISPLAY_SOURCE_FILTER_MOSAIC_COMPAT_MISMATCH             = 23,
    LW_DISPLAY_SOURCE_FILTER_HCLONE_SOURCE_MISMATCH             = 24,
    LW_DISPLAY_SOURCE_FILTER_IMP_CHECK_WITH_CVT                 = 25,
    LW_DISPLAY_SOURCE_FILTER_IMP_CHECK_WITH_CVT_RB              = 26,
    LW_DISPLAY_SOURCE_FILTER_GRAYSCALE_ILWALID                  = 27,
    LW_DISPLAY_SOURCE_FILTER_SIZE_LIMIT_EXCEEDED                = 28,
    LW_DISPLAY_SOURCE_FILTER_MOSAIC_OS_ADDED_MODE               = 29,
    LW_DISPLAY_SOURCE_FILTER_BAR1_SIZE_LIMIT_EXCEEDED           = 30,
    LW_DISPLAY_SOURCE_FILTER_DP_INSUFFICIENT_LINK_BW            = 31,
    LW_DISPLAY_SOURCE_FILTER_IMP_MULTIHEAD                      = 32,
    LW_DISPLAY_SOURCE_FILTER_TEGRA_LIMITED_SCALING_CLONE        = 33,
    LW_DISPLAY_SOURCE_FILTER_MIRACAST                           = 34,
    LW_DISPLAY_SOURCE_FILTER_STITCHED_DISPLAY_SCALING_CLONE     = 35,
} LW_DISPLAY_SOURCE_FILTER;


typedef struct
{    
    LwU32 hybridList            :1; 
    LwU32 nbsi                  :1; 
    LwU32 infStandard           :1; //!< from registry key LW_Modes
    LwU32 infLwstom             :1; //!< from registry key LW_LwstModes
    LwU32 hdtv                  :1; //!< from registry key LW_HDTVModes
    LwU32 fallbackLwmode        :1; //!< from hardcoded lwmode string
    LwU32 fallbackHdtv          :1; //!< from hardcoded hdtv mode string
    LwU32 underscan             :1; //!< from custom underscan
    LwU32 custom                :1; //!< from custom timing
    LwU32 osAdditionalMode      :1; //!< additional mode added by OS in win7
    LwU32 nativeRotation        :1; 
    LwU32 hSpan                 :1;
    LwU32 vSpan                 :1;
    LwU32 edid                  :1; //!< Mode was added from EDID, but detailed origins information could not be obtained
    LwU32 edidNativeRefreshRate :1; //!< Mode added because EDID indciates a native RR different than the INF mode
    LwU32 edidDTD               :1; //!< EDID detailed timing from base block
    LwU32 edidSTD               :1; //!< EDID standard timing from base block
    LwU32 edidEST               :1; //!< EDID established timing from base block
    LwU32 edidCVT               :1; //!< EDID defined CVT timing (EDID 1.4)
    LwU32 edid861ST             :1; //!< EDID CEA861 extension block
    LwU32 edidExtDTD            :1; //!< EDID detailed timing from extension block
    LwU32 edidExtVTB            :1; //!< EDID defined VTB extension timing
    LwU32 defaultUnderscan      :1; //!< from default underscan
    LwU32 hyperSampling         :1; //!< from hyper sampling 
    LwU32 reserved              :8;

} LW_DISPLAY_SOURCE_ORIGIN;

typedef struct 
{
    LwU32 identity          : 1;  //!< Capability for displaying content with no rotation.
    LwU32 rotation90        : 1;  //!< Capability for displaying content that is rotated 90 degrees.
    LwU32 rotation180       : 1;  //!< Capability for displaying content that is rotated 180 degrees.
    LwU32 rotation270       : 1;  //!< Capability for displaying content that is rotated 270 degrees.
    LwU32 reserved          : 28;
  
} LW_DISPLAY_ROTATE_CAPABILITY;

typedef struct
{
    LwU32                                           version;       //!< Structure version
    LW_RESOLUTION                                   resolution;    //!< Source mode resolution in Width * Height, including information on color depth
    LW_FORMAT                                       colorFormat;   //!< Color format information
    LW_DISPLAY_ROTATE_CAPABILITY                    rotation;      //!< Rotation capability of source mode
    LW_DISPLAY_SOURCE_FILTER                        filteredOutBy; //!< whether this source mode has been filtered out and for what reason
    LW_DISPLAY_SOURCE_ORIGIN                        origin;        //!< Using LW_DISPLAY_SOURCE_ORIGIN_MASK
  
} LW_DISPLAY_SOURCE_MODE;

//! Macro for constructing the version field of ::LW_DISPLAY_SOURCE_MODE
#define LW_DISPLAY_SOURCE_MODE_VER          MAKE_LWAPI_VERSION(LW_DISPLAY_SOURCE_MODE,1)


#define LWAPI_MAX_PATH_PER_TOPOLOGY             8

typedef struct
{   
    LwU32               version;       //!< Structure version
    
    // Set of VidPn path making up the topology.
    // The displays specified on these path must all belong to the same logical GPU
    struct
    {
        LwU32                   srcID;                  //!< ID of the VidPn source surface
        LwU32                   displayID;              //!< display id of the VidPn target
        LwU32                   importanceOrdinal;      //!< importance ordinal (lower value = higher importance) of the VidPn target in case of clone mode
        LW_DISPLAY_SOURCE_MODE  pinnedSourceMode;       //!< A pinned source mode on the current path. Note that GetSourceModeSet will ignore this as of now.
        
    } path [LWAPI_MAX_PATH_PER_TOPOLOGY];
    
    LwU32               pathCount;              //!< number of valid path
    
} LW_DISPLAY_TOPOLOGY_V1;

typedef struct
{
    LwU32               version;       // Structure version

    //! Set of VidPn path making up the topology.
    //! The displays specified on these path must all belong to the same logical GPU
    //! The paths must be sorted such that lowest srcID is first.
    //! For HCLONE topologies, the logical GPU contains both the NonLWIDIA GPU and the LWPU GPU. 
    //! This allows for (valid GPU heads * 2[number of GPUs in logical GPU]) paths.
    //! For now, we support a single NonLWIDIA GPU and a single LWPU dGPU for HCLONE topologies.So normally this will be 4 paths
    //! The path count is not to exceed LWAPI_MAX_PATH_PER_TOPOLOGY.
    struct
    {
        LwU32                   srcID;                  //!< ID of the VidPn source surface
        union 
        {
            LwU32       targetId; //!< same as in SDC() and QDC() for non LWPU display. This will be used when isNonLWIDIA is 1.
            LwU32       displayID; //!< LWPU display ID only for LWPU displays. This will be used when isNonLWIDIA is 0.
        };
        LwU32                   importanceOrdinal;      //!< importance ordinal (lower value = higher importance) of the VidPn target in case of clone mode
        LW_DISPLAY_SOURCE_MODE  pinnedSourceMode;       //!< A pinned source mode on the current path. Note that GetSourceModeSet will ignore this as of now.
        LwU32                   isNonLWIDIA :1; //!< True for non-LWPU GPU and False for LWPU GPU. We assume there is only one non-LWPU iGPU in the system.
                                                //!< Lwrrently applies to Hclone config only
        LwU32                   isAttachedToDesktop :1;//!<True for path attached to desktop (lwrrently path index 0 and until primary path is different from attached one).
                                                       //!< Lwrrently applies to Hclone config only
        LwU32                   isPanAndScanTarget  :1;//!< Whether this target will have Pan and Scan enabled. Valid only when the target is 
                                                       //!< secondary display in clone topology.
        LwU32                   reserved :29;   //!< reserved
    } path [LWAPI_MAX_PATH_PER_TOPOLOGY];

    LwU32               pathCount;              //!< number of valid path

} LW_DISPLAY_TOPOLOGY_V2;

typedef LW_DISPLAY_TOPOLOGY_V2       LW_DISPLAY_TOPOLOGY;
#define LW_DISPLAY_TOPOLOGY_VER1     MAKE_LWAPI_VERSION(LW_DISPLAY_TOPOLOGY_V1,1)
#define LW_DISPLAY_TOPOLOGY_VER2     MAKE_LWAPI_VERSION(LW_DISPLAY_TOPOLOGY_V2,2)
#define LW_DISPLAY_TOPOLOGY_VER      LW_DISPLAY_TOPOLOGY_VER2


LWAPI_INTERFACE LwAPI_DISP_GetSourceModeSet(__in LW_DISPLAY_TOPOLOGY        *pTopology,
                                            __in LwU32                     pathIndex,
                                            __inout_ecount_part_opt(*pSourceModeCount, *pSourceModeCount) LW_DISPLAY_SOURCE_MODE   *pSourceModeSet,
                                            __inout LwU32                   *pSourceModeCount,
                                            __in LwU8                       bIsFilteringIlwalidMode);
                                             
//! @}



//! \ingroup dispcontrol
typedef struct
{
    //! numerator / denominator gives the refresh rate in Hz
    LwU32   numerator;
    LwU32   denominator;

} LW_DISPLAY_REFRESH_RATE;





//! \ingroup dispcontrol
//! @{


typedef struct
{   
    LwU32 gvo                   : 1;
    LwU32 sdtv                  : 1; 
    LwU32 lenovoSlowRefreshRate : 1;  
    LwU32 virtualMode           : 1;  
    LwU32 hybridList            : 1; 
    LwU32 nbsi                  : 1; 
    LwU32 infStandard           : 1; //!< from registry key LW_Modes
    LwU32 infLwstom             : 1; //!< from registry key LW_LwstModes
    LwU32 hdtv                  : 1; //!< from registry key LW_HDTVModes
    LwU32 fallbackLwmode        : 1; //!< from hardcoded lwmode string
    LwU32 fallbackHdtv          : 1; //!< from hardcoded hdtv mode string
    LwU32 underscan             : 1;
    LwU32 custom                : 1; //!< from custom timing
    LwU32 osAdditionalMode      : 1; //!< additional mode added by OS in win7
    LwU32 nativeRotation        : 1; 
    LwU32 hSpan                 : 1;
    LwU32 vSpan                 : 1;
    LwU32 edid                  : 1; //!< Mode was added from EDID, but detailed origins information could not be obtained
    LwU32 edidNativeRefreshRate : 1; //!< Mode added because EDID indciates a native RR different than the INF mode
    LwU32 edidDTD               : 1; //!< EDID detailed timing from base block
    LwU32 edidSTD               : 1; //!< EDID standard timing from base block
    LwU32 edidEST               : 1; //!< EDID established timing from base block
    LwU32 edidCVT               : 1; //!< EDID defined CVT timing (EDID 1.4)
    LwU32 edid861ST             : 1; //!< EDID CEA861 extension block
    LwU32 edidExtDTD            : 1; //!< EDID detailed timing from extension block
    LwU32 edidExtVTB            : 1; //!< EDID defined VTB extension timing
    LwU32 edidHdmiExt           : 1; //!< EDID HDMI 4kx2k extended resolutions
    
    LwU32 reserved              : 5;

} LW_DISPLAY_TARGET_ORIGIN;



typedef struct
{
    LwU32                         version;        //!< Structure version
    LwU32                         visibleWidth;   //!< Number of visible horizontal pixels
    LwU32                         visibleHeight;  //!< Number of visible vertical pixels
    LwU32                         totalWidth;     //!< Number of total horizontal pixels including blanking
    LwU32                         totalHeight;    //!< Number of total vertical pixels including blanking
    LW_DISPLAY_REFRESH_RATE       refreshRate;    //!< Non-interlaced Refresh Rate of the mode
    LwU32                         pclk;           //!< Pixel clock in Hz    
    LwU32                         aspectRatio;    //!< Lwrrently not being used    
    LW_DISPLAY_TARGET_ORIGIN      origin;
    LwU32                         isInterlaced  : 1;   //!< True if and only if interlace scan mode
    LwU32                         reserved      : 31;
  
} LW_DISPLAY_TARGET_MODE_V1;

typedef struct
{
    LwU32                         version;        //!< Structure version
    LwU32                         visibleWidth;   //!< Number of visible horizontal pixels
    LwU32                         visibleHeight;  //!< Number of visible vertical pixels
    LwU32                         totalWidth;     //!< Number of total horizontal pixels including blanking
    LwU32                         totalHeight;    //!< Number of total vertical pixels including blanking
    LW_DISPLAY_REFRESH_RATE       refreshRate;    //!< Non-interlaced Refresh Rate of the mode
    LwU32                         pclk;           //!< Pixel clock in Hz    
    LwU32                         aspectRatio;    //!< Lwrrently not being used    
    LW_DISPLAY_TARGET_ORIGIN      origin;
    LwU32                         isInterlaced  : 1;   //!< True if and only if interlace scan mode
    LwU32                         isPreferred   : 1;   //!< True if the target mode is the preferred mode.
    LwU32                         reserved      : 30;
    LW_DISPLAY_TV_FORMAT          tvFormat;
  
} LW_DISPLAY_TARGET_MODE_V2;


typedef struct
{
    LwU32                         version;        //!< Structure version
    LwU32                         visibleWidth;   //!< Number of visible horizontal pixels
    LwU32                         visibleHeight;  //!< Number of visible vertical pixels
    LwU32                         totalWidth;     //!< Number of total horizontal pixels including blanking
    LwU32                         totalHeight;    //!< Number of total vertical pixels including blanking
    LW_DISPLAY_REFRESH_RATE       refreshRate;    //!< Non-interlaced Refresh Rate of the mode
    LwU32                         pclk;           //!< Pixel clock in Hz    
    LwU32                         aspectRatio;    //!< Lwrrently not being used    
    LW_DISPLAY_TARGET_ORIGIN      origin;
    LwU32                         isInterlaced  : 1;   //!< True if and only if interlace scan mode
    LwU32                         isPreferred   : 1;   //!< True if the target mode is the preferred mode.
    LwU32                         reserved      : 30;
    LW_DISPLAY_TV_FORMAT          tvFormat;
    LwU32                         hSyncNumerator;      //!< Horizontal sync numerator.
    LwU32                         hSyncDenominator;    //!< Horizontal sync denominator.
    LwU32                         videoStandard;       //!< Video signal standards(ex : D3DKMDT_VSS_VESA_GTF).
} LW_DISPLAY_TARGET_MODE_V3;


#define LW_DISPLAY_TARGET_MODE_VER1   MAKE_LWAPI_VERSION(LW_DISPLAY_TARGET_MODE_V1, 1)
#define LW_DISPLAY_TARGET_MODE_VER2   MAKE_LWAPI_VERSION(LW_DISPLAY_TARGET_MODE_V2, 2)
#define LW_DISPLAY_TARGET_MODE_VER3   MAKE_LWAPI_VERSION(LW_DISPLAY_TARGET_MODE_V3, 3)

#define LW_DISPLAY_TARGET_MODE_VER    LW_DISPLAY_TARGET_MODE_VER3
typedef LW_DISPLAY_TARGET_MODE_V3     LW_DISPLAY_TARGET_MODE; 

#define LW_MAX_TARGET_MODE_NUM              32

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_GetTargetModeSet
//
//!
//! DESCRIPTION:     This API lets caller retrieve the target mode set corresponding to a particular pinned source mode
//!                  given the VidPN topology.
//!
//!                  A pinned source mode MUST be present on the path in pTopology indicated by pathIndex.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      pTopolgy(IN)            - Representing the required VidPN topology
//!                  pathIndex(IN)           - Index to pTopology for the required VidPN path containing the target device mask
//!                  pTargetModeSet(OUT)     - The array of target mode that will be returned
//!                                            Set version to current LW_DISPLAY_TARGET_MODE struct for least the first element
//!                  pTargetModeCount(OUT)   - The number of target mode returned
//!
//! RETURN STATUS:
//!                  LWAPI_OK - completed request
//!                  LWAPI_NO_IMPLEMENTATION - This interface is only supported by Windows Vista and above
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetTargetModeSet(
    __in LW_DISPLAY_TOPOLOGY                                                            *pTopology,
    __in LwU32                                                                          pathIndex,
    __out_ecount_part(LW_MAX_TARGET_MODE_NUM, *pTargetModeCount) LW_DISPLAY_TARGET_MODE pTargetModeSet[LW_MAX_TARGET_MODE_NUM],
    __out LwU32                                                                         *pTargetModeCount);
//! @}





//! \ingroup dispcontrol
//! @{

typedef struct
{
    LwU32 version;
    LwU32 useGpuScalerOnly         : 1;
    LwU32 useGpuAndDisplayScaler   : 1;
    LwU32 reserved                 : 30;
} LW_DISPLAY_TARGET_MODE_SETTINGS_V1;

#define LW_DISPLAY_TARGET_MODE_SETTINGS_VER1 MAKE_LWAPI_VERSION(LW_DISPLAY_TARGET_MODE_SETTINGS_V1, 1)

#define LW_DISPLAY_TARGET_MODE_SETTINGS_VER  LW_DISPLAY_TARGET_MODE_SETTINGS_VER1
typedef LW_DISPLAY_TARGET_MODE_SETTINGS_V1   LW_DISPLAY_TARGET_MODE_SETTINGS;

//! @}



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_GetTargetModeSetEx()
//
//! DESCRIPTION:     This API lets caller retrieve target mode set for the provided VidPN topology.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      pTopolgy(IN)            - Representing the required VidPN topology.
//!                  pathIndex(IN)           - Index to pTopology for the required VidPN path containing the target device mask.
//!                  pTargetModeSet(IN/OUT)  - The array of target mode that will be returned.
//!                                            Set version to current LW_DISPLAY_TARGET_MODE struct for least the first element.
//!                  pTargetModeCount(OUT)   - The number of target mode returned.
//!                  targetModeSettings(IN)  - Specifies settings to be used to find the target mode set.
//!
//! RETURN STATUS:
//!                  LWAPI_OK                          - Completed Request.
//!                  LWAPI_ERROR                       - Miscellaneous error oclwrred.
//!                  LWAPI_ILWALID_POINTER             - Invalid pointer to LW_DISPLAY_TOPOLOGY or LwU32.
//!                  LWAPI_ILWALID_ARGUMENT            - Invalid input parameter.
//!                  LWAPI_NO_IMPLEMENTATION           - This interface is only supported by Windows Vista and above.
//!                  LWAPI_API_NOT_INTIALIZED          - LWAPI not initialized.
//!                  LWAPI_INCOMPATIBLE_STRUCT_VERSION - The structure version passed is invalid.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////                                             
LWAPI_INTERFACE LwAPI_DISP_GetTargetModeSetEx(
    __in LW_DISPLAY_TOPOLOGY                                                            *pTopology,
    __in LwU32                                                                          pathIndex,
    __inout_ecount_part(LW_MAX_TARGET_MODE_NUM, *pTargetModeCount) LW_DISPLAY_TARGET_MODE pTargetModeSet[LW_MAX_TARGET_MODE_NUM],
    __out LwU32                                                                         *pTargetModeCount,
    __in LW_DISPLAY_TARGET_MODE_SETTINGS                                                targetModeSettings);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_GetScanoutRasterDimension
//
//! DESCRIPTION:     This API lets caller query the dimensions of the scanout and raster for a particular VidPN topology and pinned target mode.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      pTopolgy(IN)           - Representing the required VidPN topology.
//!                  pathIndex(IN)          - Index to pTopology for the required VidPN path containing the target device mask.
//!                  pPinnedTargetMode(IN)  - The pinned target mode for which caller needs the scanout and raster dimensions.
//!                  scaling(IN)            - The scaling for which caller needs the scanout and raster dimensions.
//!                  pScanoutRectangle(OUT) - The rectangle where the active image will be displayed.
//!                  pRasterRectangle(OUT)  - The rectangle where the monitor will show image.
//!
//! RETURN STATUS:
//!                  LWAPI_OK                          - Completed Request.
//!                  LWAPI_ERROR                       - Miscellaneous error oclwrred.
//!                  LWAPI_ILWALID_POINTER             - Invalid pointer to LW_DISPLAY_TOPOLOGY or LW_DISPLAY_TARGET_MODE or RECT.
//!                  LWAPI_ILWALID_ARGUMENT            - Invalid input parameter.
//!                  LWAPI_NO_IMPLEMENTATION           - This interface is only supported by Windows Vista and above.
//!                  LWAPI_API_NOT_INTIALIZED          - LWAPI not initialized.
//!                  LWAPI_INCOMPATIBLE_STRUCT_VERSION - The structure version passed is invalid.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////                                             
LWAPI_INTERFACE LwAPI_DISP_GetScanoutRasterDimension(__in  LW_DISPLAY_TOPOLOGY     *pTopology,
                                                     __in  LwU32                    pathIndex,
                                                     __in  LW_DISPLAY_TARGET_MODE  *pPinnedTargetMode,
                                                     __in  LW_SCALING               scaling,
                                                     __out LW_RECT                 *pScanoutRectangle,
                                                     __out LW_RECT                 *pRasterRectangle);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:  LwAPI_DISP_GetTimingInfo
//
//! \fn LwAPI_DISP_GetTimingInfo(__in LwU32 displayID, __inout LwU32 *timingInfoCount, __out_ecount_part_opt(*timingInfoCount, *timingInfoCount) LW_BACKEND_TIMING_INFO *timingInfo)
//! 
//! DESCRIPTION:   This API lets caller retrieve backend timings supported by the display along with timing origin information.
//!                Lwrrently the API returns only the timings present in EDID.
//!
//! USAGE:         Sequence of calls which caller should make to get the timing information.
//!                1. First call LWAPI_DISP_GetTimingInfo() with timingInfo as NULL to get the count of timings.
//!                2. Allocate memory for timing info array.
//!                3. Call LWAPI_DISP_GetTimingInfo() again with the pointer to the memory allocated to get all the timing info.
//!                   
//!                Note : 
//!                1. timingInfoCount should never be NULL, else the API will fail with LWAPI_ILWALID_ARGUMENT.
//!                2. *timingInfoCount returned from the API will always be the actual count in any/every call.
//!                3. Memory size to be allocated should be (*timingInfoCount * sizeof(LW_BACKEND_TIMING_INFO)).
//!                4. If the memory allocated is less than what is required to return all the timings, this API will return the
//!                   amount of timing information which can fit in user provided buffer and API will return LWAPI_INSUFFICIENT_BUFFER.
//!                5. If the caller specifies a greater value for *timingInfoCount in second call to LWAPI_DISP_GetTimingInfo() than
//!                   what was returned from first call, the API will return only the actual number of elements in the timingInfo array 
//!                   and the extra buffer will remain unused.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out] timingInfoCount - Always returns the actual number of timings.
//! \param [in,out]    timingInfo   - Array of LW_BACKEND_TIMING_INFO structure which holds the timing info.
//!
//! \return         This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                 specific meaning for this API, they are listed below.
//! 
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dispcontrol
//! Target timing related information.
typedef struct
{
        LwU32                    version;

    LW_DISPLAY_TARGET_ORIGIN targetOrigin;
        LW_TIMING                timingInfo;
} LW_BACKEND_TIMING_INFO_V1;

typedef LW_BACKEND_TIMING_INFO_V1     LW_BACKEND_TIMING_INFO;

#define LW_BACKEND_TIMING_INFO_VER1   MAKE_LWAPI_VERSION(LW_BACKEND_TIMING_INFO_V1, 1) 
#define LW_BACKEND_TIMING_INFO_VER    LW_BACKEND_TIMING_INFO_VER1 

//! \ingroup dispcontrol
LWAPI_INTERFACE LwAPI_DISP_GetTimingInfo(__in LwU32 displayID, __inout LwU32 *timingInfoCount, __inout_ecount_part_opt(*timingInfoCount, *timingInfoCount) LW_BACKEND_TIMING_INFO *timingInfo);
                                            



//! \ingroup dispcontrol
//! @{

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LWAPI_DISP_GetScalingSupport
//
//! \fn LwAPI_DISP_GetScalingSupport(LW_DISPLAY_TOPOLOGY        *pTopology, 
//!                                             LwU32                       pathIndex,
//!                                             LW_DISPLAY_TARGET_MODE     *pPinnedTargetMode,
//!                                             LW_DISPLAY_SCALING_SUPPORT *pScalingSupport)
//!
//! DESCRIPTION:     This API lets caller retrieve scaling support information given a VidPn topology, a pinned source mode
//!                  and optionally a pinned target mode
//!
//!                  A pinned source mode MUST be present(not NULL) on the path in pTopology indicated by pathIndex.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      pTopolgy(IN)            - Representing the required VidPN topology
//!                  pathIndex(IN)           - Index to pTopology for the required VidPN path containing the target device mask
//!                  pPinnedTargetMode(IN)   - Optionally a target mode can be pinned for getting scaling support on full source/target mode combination
//!                  pScalingSupport(OUT)    - Scaling support information
//!
//! RETURN STATUS:
//!                  LWAPI_OK - completed request
//!                  LWAPI_NO_IMPLEMENTATION - This interface is only supported by Windows Vista and above
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////

typedef struct
{
    LwU32   identity                : 1; //!< Capability for displaying content with no transformation.
    LwU32   centered                : 1; //!< Capability for displaying centered content.
    LwU32   stretched               : 1; //!< Capability for displaying scaled content.
    LwU32   aspectRatioCenteredMax  : 1; //!< (Windows 7) Capability for scaling source content to fit the target while preserving the aspect ratio of the source.
    LwU32   custom                  : 1; //!< (Windows 7) Capability for displaying one or more scaling modes that are not described by other members of this structure.
    LwU32   reserved                : 27;

} LW_DISPLAY_SCALING_SUPPORT;

LWAPI_INTERFACE LwAPI_DISP_GetScalingSupport(LW_DISPLAY_TOPOLOGY        *pTopology, 
                                             LwU32                       pathIndex,
                                             LW_DISPLAY_TARGET_MODE     *pPinnedTargetMode,
                                             LW_DISPLAY_SCALING_SUPPORT *pScalingSupport);
                                            
//! @}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_GetScalingCapsOverride
//
//! DESCRIPTION:     This API lets caller retrieve scaling override information for a particular display.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      displayId(IN)     - Display ID of display to override the scaling caps. 
//!                                      Retrieved from LwAPI_SYS_GetDisplayIdFromGpuAndOutputId().
//!                  pScalingCaps(OUT) - Scaling settings information which caller has overridden.
//!
//! RETURN STATUS:
//!                  LWAPI_OK                          - Completed request.
//!                  LWAPI_ERROR                       - Miscellaneous error oclwrred.
//!                  LWAPI_ILWALID_POINTER             - Invalid pointer to LW_GET_SCALING_CAPS.
//!                  LWAPI_ID_OUT_OF_RANGE             - Incorrect display ID.
//!                  LWAPI_NO_IMPLEMENTATION           - Only supported on Windows Vista and above.
//!                  LWAPI_API_NOT_INTIALIZED          - LWAPI not initialized.
//!                  LWAPI_INCOMPATIBLE_STRUCT_VERSION - The structure version passed is invalid.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////                                             
LWAPI_INTERFACE LwAPI_DISP_GetScalingCapsOverride(LwU32 displayId, LW_GET_SCALING_CAPS * pScalingCaps);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_SetScalingCapsOverride
//
//! DESCRIPTION:     This API lets caller set scaling override for a particular display.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      displayId(IN)            - Display ID corresponding to the connected display for which the caller wants to override scaling.
//!                  pScalingCaps(IN)         - The requested scaling capabilities the caller wishes to use instead of the true scaling capabilities.
//!                                             Due to a driver limitation, there can be only one bit set in the scaling cap override structure.  
//!                                             To disable the scaling cap override feature, set pScalingCaps to the true scaling capabilities
//!                                             (from LwAPI_DISP_GetScalingCaps).
//!                  preferredScaling(IN)     - Changes the current display scaling to preferredScaling settings. This parameter is ignored if the display is inactive.
//!
//! RETURN STATUS:
//!                  LWAPI_OK                          - Completed request.
//!                  LWAPI_ERROR                       - Miscellaneous error oclwrred.
//!                  LWAPI_ILWALID_POINTER             - Invalid pointer to LW_GET_SCALING_CAPS.
//!                  LWAPI_ID_OUT_OF_RANGE             - Incorrect display ID.
//!                  LWAPI_ILWALID_ARGUMENT            - Invalid value passed for preferredScaling.
//!                  LWAPI_NO_IMPLEMENTATION           - Only supported on Windows Vista and above.
//!                  LWAPI_API_NOT_INTIALIZED          - LWAPI not initialized.
//!                  LWAPI_ILWALID_COMBINATION         - Invalid combination of pScalingCaps and preferredScaling.
//!                  LWAPI_INCOMPATIBLE_STRUCT_VERSION - The structure version passed is invalid.
//!
//! \ingroup dispcontrol 
///////////////////////////////////////////////////////////////////////////////                                             
LWAPI_INTERFACE LwAPI_DISP_SetScalingCapsOverride(LwU32 displayId, LW_GET_SCALING_CAPS * pScalingCaps, LW_SCALING preferredScaling);



//! \ingroup dispcontrol
//! @{

typedef struct _LW_DISPLAY_BLANKING_INFO_V1 
{ 
   LwU32 version;
   LwU32 blankingState                      : 1;  //!< 1 - Set    , 0 - Unset.
   LwU32 persistBlankingAcrossHotPlugUnplug : 1;  //!< 1 - Persist, 0 - Do Not persist.
   LwU32 reserved                           : 30;
}LW_DISPLAY_BLANKING_INFO_V1; 

typedef LW_DISPLAY_BLANKING_INFO_V1   LW_DISPLAY_BLANKING_INFO;

#define LW_DISPLAY_BLANKING_INFO_VER1 MAKE_LWAPI_VERSION(LW_DISPLAY_BLANKING_INFO_V1, 1) 
#define LW_DISPLAY_BLANKING_INFO_VER  LW_DISPLAY_BLANKING_INFO_VER1 

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_DISP_GetDisplayBlankingState 
//
//! DESCRIPTION:    This API returns the information about the display's blanking state. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     displayId              - LWPU Display selection.
//! \param [out]    pDisplayBlankingState  - Pointer to the structure containing the flags about the display's current blanking state.
//!
//! \retval ::LWAPI_OK                           - Completed request.
//! \retval ::LWAPI_ERROR                        - Miscellaneous error oclwrred.
//! \retval ::LWAPI_NOT_SUPPORTED                - Feature not supported on GPU. Will work on Lwdqro's only.
//! \retval ::LWAPI_ID_OUT_OF_RANGE              - Incorrect display ID.
//! \retval ::LWAPI_ILWALID_POINTER              - Invalid pointer to LW_DISPLAY_BLANKING_INFO structure.
//! \retval ::LWAPI_NO_IMPLEMENTATION            - API not implemented. Will return this error in case of WinXP.    
//! \retval ::LWAPI_API_NOT_INTIALIZED           - LwAPI_Initialize() has not been called or was not successfull.
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  - The structure version passed is invalid.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetDisplayBlankingState(LwU32 displayId, LW_DISPLAY_BLANKING_INFO *pDisplayBlankingState); 



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_DISP_SetDisplayBlankingState 
//
//! DESCRIPTION:    This API sets the display's blanking state information provided by the user. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     displayId               - LWPU Display selection.
//! \param [in]     pDisplayBlankingState   - Pointer to the structure containing the blanking flags which the user 
//!                                              wants to set on the display.
//!
//! \retval ::LWAPI_OK                           - Completed request.
//! \retval ::LWAPI_ERROR                        - Miscellaneous error oclwrred.
//! \retval ::LWAPI_ACCESS_DENIED                - Access denied to the current caller process of this API. 
//!                                                Until the process which has blanked the display doesn't unblank the display
//!                                                or exits, no other process can set the blanking state.
//! \retval ::LWAPI_NOT_SUPPORTED                - Feature not supported on GPU. Will work on Lwdqro's only.
//! \retval ::LWAPI_ID_OUT_OF_RANGE              - Incorrect display ID.
//! \retval ::LWAPI_ILWALID_POINTER              - Invalid pointer to LW_DISPLAY_BLANKING_INFO structure.
//! \retval ::LWAPI_NO_IMPLEMENTATION            - API not implemented. Will return this error in case of WinXP.    
//! \retval ::LWAPI_API_NOT_INTIALIZED           - LwAPI_Initialize() has not been called or was not successfull.
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  - The structure version passed is invalid.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_SetDisplayBlankingState(LwU32 displayId, LW_DISPLAY_BLANKING_INFO * pDisplayBlankingState); 



//! \ingroup dispcontrol
//! @{
typedef struct _LW_DISPLAY_EDID_MONITOR_RANGE
{
    LwU16    minRefreshRateHz;               // Minimum frame rate in Hz
    LwU16    maxRefreshRateHz;               // Maximum frame rate in Hz
    LwU16    minLineRateKHz;                 // Minimum line rate in kHz
    LwU16    maxLineRateKHz;                 // Maximum line rate in kHz 
    LwU16    maxPclkMHz;                     // Maximum pixel rate in MHz
} LW_DISPLAY_EDID_TIMING_RANGE;

typedef struct _LW_DISPLAY_EDID_DATA_V1 
{ 
   LwU32 version;
   LwAPI_ShortString displayName;             // Display name string.
   LwAPI_ShortString manufacturerName;        // Manufacturer name string.
   LwU32 specificID;                          // 32 bit CRC32, will be the same for all displays with identical EDID data.
   LwU32 commonID;                            // 32 bit CRC callwlated after purging 'Week of Manufacture', 'Year of Manufacture', 'Product ID String' & 'Serial Number' from EDID.
   LwU32 isValid                      : 1;    // EDID validity
   LwU32 reserved                     : 31;
}LW_DISPLAY_EDID_DATA_V1; 

typedef struct _LW_DISPLAY_EDID_DATA_V2 
{ 
   LwU32 version;
   LwAPI_ShortString displayName;             // Display name string.
   LwAPI_ShortString manufacturerName;        // Manufacturer name string.
   LwU32 specificID;                          // 32 bit CRC32, will be the same for all displays with identical EDID data.
   LwU32 commonID;                            // 32 bit CRC callwlated after purging 'Week of Manufacture', 'Year of Manufacture', 'Product ID String' & 'Serial Number' from EDID.
   LwU32 isValid                      : 1;    // EDID validity
   LwU32 reserved                     : 31;
   LW_DISPLAY_EDID_TIMING_RANGE timingRangeLimit;  // EDID timing range limit    
}LW_DISPLAY_EDID_DATA_V2; 


typedef LW_DISPLAY_EDID_DATA_V2   LW_DISPLAY_EDID_DATA;

#define LW_DISPLAY_EDID_DATA_VER1 MAKE_LWAPI_VERSION(LW_DISPLAY_EDID_DATA_V1, 1) 
#define LW_DISPLAY_EDID_DATA_VER2 MAKE_LWAPI_VERSION(LW_DISPLAY_EDID_DATA_V2, 2) 
#define LW_DISPLAY_EDID_DATA_VER  LW_DISPLAY_EDID_DATA_VER2 

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_DISP_GetEdidParsed 
//
//! DESCRIPTION:    This API returns the parsed edid data from Driver. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:     displayId(IN)  - LWPU Display selection.
//!                 pEdidData(OUT) - Pointer to the structure to get the parsed edid data.
//!
//! RETURN STATUS: 
//!    LWAPI_OK                           - Completed request.
//!    LWAPI_ERROR                        - Miscellaneous error oclwrred.
//!    LWAPI_ID_OUT_OF_RANGE              - Incorrect display ID.
//!    LWAPI_ILWALID_POINTER              - Invalid pointer to LW_DISPLAY_EDID_DATA structure.
//!    LWAPI_NO_IMPLEMENTATION            - API not implemented. Will return this error in case of WinXP.    
//!    LWAPI_API_NOT_INTIALIZED           - LwAPI_Initialize() has not been called or was not successfull.
//!    LWAPI_INCOMPATIBLE_STRUCT_VERSION  - The structure version passed is invalid.
//!
//! \ingroup dispcontrol 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetEdidParsed(LwU32 displayId, LW_DISPLAY_EDID_DATA *pEdidData); 







///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Coproc_QueryHDAudioState  
//
//! PARAMETERS:      pHDAState (OUT)               Pointer to a LwU32 which receives the status 
//!                                                of HDAudio from driver. 
//!                                                1 : HDAudio is enabled.
//!                                                0 : HDAudio is disabled.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! DESCRIPTION:     This API call is used to query the status of HDAudio from the driver.
//!
//! RETURN STATUS:
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_NOT_SUPPORTED - call is not supported
//!    LWAPI_API_NOT_INTIALIZED - LwAPI not initialized
//!    LWAPI_ILWALID_ARGUMENT - Invalid Argument passed.
//!
//! \ingroup coprocapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Coproc_QueryHDAudioState(LwU32 *pHDAState);



///////////////////////////////////////////////////////////////////////////////
// Heterogeneous Clone related APIs.
///////////////////////////////////////////////////////////////////////////////



//! \ingroup hcloneapi
typedef struct
{
    LwU32   width;
    LwU32   height;
    LW_FORMAT colorFormat;
    LW_DISPLAY_REFRESH_RATE   refreshRate;
    LwU32   reserved; //!< Must be initialized to zero.
} LW_DISPLAY_SETTING;

//! \ingroup hcloneapi
typedef struct
{
    LwU32       version;
    LwU32       isNonLWIDIA :1; //!< True for non-LWPU GPU and False for LWPU GPU. We assume there is only one non-LWPU iGPU in the system.
    LwU32       isAttachedToDesktop :1;//!< True for path attached to desktop (lwrrently path index 0 and until primary path is different from attached one).
    LwU32       reserved :30;
    LwU32       sourceId;  //!< For SET call: 
                          //!< IN: For the main adapter which is the primary of this HClone node that is attached and visible to the desktop,
                          //!< pass in the sourceId as seen by the OS.
                          //!< N/A: For the paths not visible to the OS, Driver will internally pick the sourceId. Note that this sourceId can
                          //!< dynamically be changed by Driver at runtime such as when MSPanel extends a monitor on the main adapter.
                          //!< For the GET call:
                          //!< OUT: Driver will return the sourceId for all the paths ilwolved in this Hclone Node. The main adapter's 
                          //!< sourceId, is guaranteed to remain the same as passed in at the SET time but the value might have changed for
                          //!< the other paths
    union {
        LwU32       targetId; //!< same as in SDC() and QDC() for non LWPU display. This will be used when isNonLWIDIA is 1.
        LwU32       displayId; //!, LWPU display ID only for LWPU displays. This will be used when isNonLWIDIA is 0.
    };
    LW_DISPLAY_SETTING   dispSetting;
    LwU32      reserved1; //!< Must be initialized to zero.
} LW_HCLONE_PATH_V1;


//! \ingroup hcloneapi
typedef LW_HCLONE_PATH_V1    LW_HCLONE_PATH;

//! \ingroup hcloneapi
#define LW_HCLONE_PATH_VER1  MAKE_LWAPI_VERSION(LW_HCLONE_PATH_V1,1)

//! \ingroup hcloneapi
#define LW_HCLONE_PATH_VER   LW_HCLONE_PATH_VER1

//! \ingroup hcloneapi
typedef struct 
{
    LwU32 version;
    LwU32 numPaths; //!< Number of paths in this node.
    LW_HCLONE_PATH *pHClonePathArray;//!< index 0 is primary (of highest priority)
    LwU32  reserved1; //!< Must be initialized to zero.
} LW_HCLONE_NODE_V1;

//! \ingroup hcloneapi
typedef LW_HCLONE_NODE_V1    LW_HCLONE_NODE;

//! \ingroup hcloneapi
#define LW_HCLONE_NODE_VER1  MAKE_LWAPI_VERSION(LW_HCLONE_NODE_V1,1)

//! \ingroup hcloneapi
#define LW_HCLONE_NODE_VER   LW_HCLONE_NODE_VER1

//! \ingroup hcloneapi
typedef enum LW_HCLONE_HOTPLUG_BEHAVIOR
{
    LW_HCLONE_HOTPLUG_BEHAVIOR_CCD=0,   //!< Default behavior, using CCD rules for hotplug behavior
    LW_HCLONE_HOTPLUG_BEHAVIOR_EXTENDED,//!< Override Hotplug for the 1st display - will ignore persistence and go to extended mode
    LW_HCLONE_HOTPLUG_BEHAVIOR_UI,      //!< Override Hotplug for the 1st display - will ilwoke the Hotplug Dialog interraction
                                        //!< (note, also depends on 
                                        //!< the additional setting persisted within the dialog)
} LW_HCLONE_HOTPLUG_BEHAVIOR;

//! \ingroup hcloneapi
typedef struct 
{
    LwU32 version;
    LwU32 numHCloneNodes;
    LW_HCLONE_NODE *pHCloneNodeArray;
    LwU32 isMultiHClonePairsEnabled:1; //!< True: allow more than 1 hclone pairs simultaneously. 
                                       //!< False: Only a single pair is allowed with integrated adapter as primary display.
    LwU32 isNWayHCloneNodesEnabled:1;  //!< True: 3-way and 4-way nodes are enabled. False: Only 2-way hclone nodes are enabled.
    LwU32 reserved1:30;                //!< Must be initialized to zero.
    LW_HCLONE_HOTPLUG_BEHAVIOR HCloneHotPlugBehavior;      //!< Different flavors of behaviors on hotplug.
} LW_HCLONE_TOPOLOGY_V1;



//! \ingroup hcloneapi
typedef LW_HCLONE_TOPOLOGY_V1    LW_HCLONE_TOPOLOGY;

//! \ingroup hcloneapi
#define LW_HCLONE_TOPOLOGY_VER1  MAKE_LWAPI_VERSION(LW_HCLONE_TOPOLOGY_V1,1)

//! \ingroup hcloneapi
#define LW_HCLONE_TOPOLOGY_VER   LW_HCLONE_TOPOLOGY_VER1


/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_DISP_SetHCloneTopology   
//!   DESCRIPTION: This API applies the Heterogeneous clone over displays given in pHCloneTopology.  
//!                Caller should first set the topology over all primary display using OS-API and then call this LWAPI.
//!  
//! SUPPORTED OS:  Windows 7
//!
//! \param [in] pHCloneTopology    Heterogeneous clone topology information              
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT: invalid arguments.
//! \retval ::LWAPI_OK: Display topology successfully applied.
//! \retval ::LWAPI_NOT_SUPPORTED: This software feature is not supported on the system.
//! \retval ::LWAPI_OUT_OF_MEMORY: Could not allocate sufficient memory to complete the call
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION: LW_HCLONE_TOPOLOGY/LW_HCLONE_NODE structure version mismatch. see pDispTopology->version.
//!
//! \ingroup hcloneapi
//////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_SetHCloneTopology(__in LW_HCLONE_TOPOLOGY *pHCloneTopology);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:  LwAPI_DISP_GetHCloneTopology
//
//! DESCRIPTION:   This API retrieves the current HClone topology information.
//!                Use the following steps to retrieve pHCloneTopology completely:
//!                -# Call this function with pHCloneTopology->pHCloneNodeArray set to NULL, to get the total number nodes in the HClone.
//!                -# Allocate memory to pHCloneTopology->pHCloneNodeArray of size sizeof(LW_HCLONE_NODE)*pHCloneTopology->numHCloneNodes.
//!                -# Assign NULL to all pHCloneTopology->pHCloneNodeArray[count].pHClonePathArray in a loop and call this function
//!                   to get all the pHCloneTopology->pHCloneNodeArray[count].numPaths.
//!                -# In loop allocate memory to pHCloneTopology->pHCloneNodeArray[code].pHClonePathArray
//!                   of size sizeof(LW_HCLONE_PATH)*pHCloneTopology->pHCloneNodeArray[count].numPaths.
//!                -# Call this function to get entire topology.
//!
//!                In step 5, if HClone is not completed, return value will be LWAPI_DEVICE_BUSY. \p
//!                In step 1 and step 3, even if HClone is not completed you will get return value as ::LWAPI_OK.
//!                
//! SUPPORTED OS:  Windows 7
//!
//! 
//! \param [out]    pHCloneTopology(gives current Heterogeneous clone topology information.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT invalid arguments.
//! \retval ::LWAPI_OK  successfully returned.
//! \retval ::LWAPI_DEVICE_BUSY It means HClone is not completed yet and pHCloneTopology will contain topology that is being set.
//! \retval ::LWAPI_NOT_SUPPORTED This software feature is not supported on the system.
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION LW_HCLONE_TOPOLOGY/LW_HCLONE_NODE structure version mismatch. See pHCloneTopology->version.
//!
//! \ingroup hcloneapi
//////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetHCloneTopology(__inout LW_HCLONE_TOPOLOGY *pHCloneTopology);


typedef struct {
    LwU32 version;                  //!< [IN] Must be set to LW_HCLONE_DISPLAY_CAPS_VER.
    union {
        LwU32 displayID;            //!< [IN] Display ID for LWPU monitor. Must be set if isNonLWIDIADisplay is false.
        LwU32 targetID;             //!< [IN] CCD's target ID for non LWPU monitor. Must be set if isNonLWIDIADisplay is true.
    };

    LwU32 isNonLWIDIA:1;            //!< [IN] States if monitor is attached to LWPU or non-LWPU display.
    LwU32 isPrimaryCapable:1;       //!< [OUT] This monitor is capable of being a primary monitor in Heterogeneous clone.
    LwU32 isSecondaryCapable:1;     //!< [OUT] This monitor is capable of being a secondary monitor in Heterogeneous clone.
    LwU32 reserved:29;              //!< [OUT] This will be undefined.
} LW_HCLONE_DISPLAY_CAPS_V1;

//! \ingroup hcloneapi
typedef LW_HCLONE_DISPLAY_CAPS_V1   LW_HCLONE_DISPLAY_CAPS;

//! \ingroup hcloneapi
#define LW_HCLONE_DISPLAY_CAPS_VER1 MAKE_LWAPI_VERSION(LW_HCLONE_DISPLAY_CAPS_V1,1)

//! \ingroup hcloneapi
#define LW_HCLONE_DISPLAY_CAPS_VER  LW_HCLONE_DISPLAY_CAPS_VER1

///////////////////////////////////////////////////////////////////////////////
//
//! DESCRIPTION:    This function gets capabilities of monitors related to HClone.
//!                 The capability includes:
//!                     1. Can a monitor becomes primary monitor in HClone (isPrimaryCapable).
//!                     2. Can a monitor becomes secondary monitor in HClone (isSecondaryCapable).
//!
//! SUPPORTED OS:  Windows 7
//!
//! \param [in,out]     pDisplayCaps    Array of display capabilities. See LW_HCLONE_DISPLAY_CAPS for more details.
//! \param [in]         countDisplay    Number of displays in array pDisplayCaps.
//! 
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status.
//!              If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_NOT_SUPPORTED Heterogeneous clone is not supported on your system.
//!
//! \ingroup hcloneapi
//////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetHCloneDisplayCaps(__inout_ecount_full(countDisplay) LW_HCLONE_DISPLAY_CAPS *pDisplayCaps, __in LwU32 countDisplay);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:  LwAPI_DISP_ValidateHCloneTopology
//
//! DESCRIPTION:   This API validates the HClone topology if that is supported/valid.It will validate only topology (Not the display setting)
//!                any LW_DISPLAY_SETTING in pHCloneTopology would be ignored
//!
//! SUPPORTED OS:  Windows 7
//!
//!
//! \param [in]   pHCloneTopology    Heterogenous clone topology information.
//! \param [out]  pValid             TRUE if valid/supported otherwise FALSE
//! 
//! \retval ::LWAPI_ILWALID_ARGUMENT invalid arguments.
//! \retval ::LWAPI_OK  succesfully returned.
//! \retval ::LWAPI_NOT_SUPPORTED This software feature is not supported on the system.
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION LW_HCLONE_TOPOLOGY/LW_HCLONE_NODE structure version mismatch. see pHCloneTopology->version.
//! \ingroup hcloneapi
//////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_ValidateHCloneTopology(__in LW_HCLONE_TOPOLOGY *pHCloneTopology, __out LwU32 *pValid);



//! SUPPORTED OS:  Windows 7 and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DISP_GetHCloneIGPUDisplayEdid
//
//!   DESCRIPTION: Returns the EDID data for the specified Target Id. Supported on IGPU display only.
//!                User must call this function with pEDID NULL and pSizeofEDID set, to get the size of
//!                buffer for pEDID. Once user get the size, allocate pEDID with buffer of size returned
//!                by pSizeofEDID and call this function again with all parameters.
//!
//! \param [in]     targetId     The same TargetId that is retrieved from CCD-API QueryDisaplyConfig.
//! \param [out]    pEdid        The pointer to the buffer that will have EDID data returned from
//!                              the driver. To get just the size of EDID data, call this function
//!                              with pEdid NULL and pSizeofEDID set.
//! \param [in,out] pSizeofEDID  Pointer to size of buffer pointed by pEDID as input.
//                               Size of actual EDID data as output. When pEDID is
//                               NULL this is output only parameter.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT  This can be returned in any of the following scenarios:
//!                    - targetId is invalid.
//!                    - pSizeofEDID is NULL.
//!                    - pEdid is present and *pSizeofEDID is 0.
//! \retval ::LWAPI_OK              *pEDID contains valid data.
//! \retval ::LWAPI_DATA_NOT_FOUND  requested display does not contain an EDID
//!
//! \ingroup hcloneapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetHCloneIGPUDisplayEdid(__in LwU32 targetId, __out_bcount_part_opt(*pSizeofEDID, *pSizeofEDID) LwU8 *pEdid, __inout LwU32 *pSizeofEDID);




//! \ingroup dispcontrol
typedef enum _LW_WIDE_COLOR_RANGE
{
    LW_COLOR_UNKNOWN = 0,
    LW_COLOR_xvYCC, 
    
}LW_WIDE_COLOR_RANGE; 

//! \ingroup dispcontrol
typedef struct _LW_WIDE_COLOR_RANGE_SETTING
{
    LwU32 version;                   //!< structure version
    LW_WIDE_COLOR_RANGE colorRange;  //!< (IN)Color range (LW_WIDE_COLOR_RANGE)
    LwU32 enable    :1;              //!< (IN for LwAPI_DISP_SetWideColorRange, OUT for LwAPI_DISP_GetWideColorRange ) 
                                     //! 1: enable ,0: disable
    LwU32 reserved  :31;             //!< reserved 
}LW_WIDE_COLOR_RANGE_SETTING_V1;

//! \ingroup dispcontrol
typedef LW_WIDE_COLOR_RANGE_SETTING_V1    LW_WIDE_COLOR_RANGE_SETTING;

//! \ingroup dispcontrol
#define LW_WIDE_COLOR_RANGE_SETTING_VER1  MAKE_LWAPI_VERSION(LW_WIDE_COLOR_RANGE_SETTING_V1,1)

//! \ingroup dispcontrol
#define LW_WIDE_COLOR_RANGE_SETTING_VER   LW_WIDE_COLOR_RANGE_SETTING_VER1

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_SetWideColorRange
//
//! DESCRIPTION:     This API is used to enable/disable different color modes.
//!                  Lwrrently only LW_COLOR_xvYCC_Range is supported.
//!
//! \param [in]      displayId          Monitor Identifier.
//! \param [in]      colorRangeSetting  Color range settings.
//!
//! \retval ::LWAPI_OK - completed request
//! \retval ::LWAPI_ERROR - miscellaneous error oclwrred
//! \retval ::LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//! \retval ::LWAPI_NO_IMPLEMENTATION - API is not supported on the system
//! \retval ::LWAPI_API_NOT_INTIALIZED - LWAPI not initialized
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION - Structure version mismatch
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_SetWideColorRange(LwU32 displayId, LW_WIDE_COLOR_RANGE_SETTING *colorRangeSetting);



//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_GetWideColorRange
//
//! DESCRIPTION:     This API is used to query the status of different color modes.
//!                  Lwrrently LW_COLOR_xvYCC_Range is supported only.
//!
//! \param [in]      displayId           Monitor Identifier.
//! \param [in,out]  colorRangeSetting   Color range settings.
//!
//! \retval ::LWAPI_OK - completed request
//! \retval ::LWAPI_ERROR - miscellaneous error oclwrred
//! \retval ::LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//! \retval ::LWAPI_NO_IMPLEMENTATION - API is not supported on the system
//! \retval ::LWAPI_API_NOT_INTIALIZED - LWAPI not initialized
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION - Structure version mismatch
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetWideColorRange(LwU32 displayId, LW_WIDE_COLOR_RANGE_SETTING *colorRangeSetting);



//! \ingroup vidcontrol
//! @{

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GetVideoLinkParams
//
//! \fn LwAPI_GetVideoLinkParams(__in_opt LwDisplayHandle hLwDisplay, __in LwU32 outputId, __ inout LW_VIDEO_LINK_INFO* pVideoLinkInfo)
//!
//! DESCRIPTION:     This API receives content protection information
//!                  during video playback.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      hLwDisplay(IN)      - LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//!                                        This parameter is ignored when the outputId is a LwAPI displayId.
//!                  outputId(IN)        - This can either be the connection bit mask or the LwAPI displayId. When the legacy connection bit mask is passed, 
//!                                        it should have exactly 1 bit set to indicate a single display. If it's "0" then the default outputId from 
//!                                        LwAPI_GetAssociatedDisplayOutputId() will be used.
//!                  pVideoLinkInfo(OUT) - The supplied LW_VIDEO_LINK_INFO packet. 
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

typedef enum _LW_HDCP_STATUS_INFO 
{
    LW_HDCP_STATUS_INFO_AVAILABLE                               = 0x00000000, //!< Link (GPU + display) is HDCP-capable
    LW_HDCP_STATUS_INFO_UNAVAILABLE                             = 0x00000001, //!< Link not HDCP-capable
    LW_HDCP_STATUS_INFO_UNAVAILABLE_ILWALID_DISPLAY_ID          = 0x00000002, //!< DisplayId does not match a digital (DVI/HDMI) connector
    LW_HDCP_STATUS_INFO_UNAVAILABLE_ILWALID_DISPLAY             = 0x00000004, //!< Display is not HDCP-capable as reported by RM (may be independent of _ILWALID_DISPLAY_ID)
    LW_HDCP_STATUS_INFO_UNAVAILABLE_ILWALID_DISPLAY_MODE        = 0x00000008, //!< In clone/span mode
    LW_HDCP_STATUS_INFO_UNAVAILABLE_ILWALID_GPU                 = 0x00000010, //!< GPU is not HDCP-capable as reported by RM
    LW_HDCP_STATUS_INFO_UNAVAILABLE_ILWALID_GPU_MODE            = 0x00000020, //!< *NOT SUPPORTED, please remove option from CPL* 
    LW_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_UNTRUST               = 0x00000040, //!< Status signature did not match
    LW_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_LINK_FAILURES         = 0x00000080, //!< Abort due to repeated link failures
    LW_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_KSV_LENGTH            = 0x00000100, //!< Invalid key parameter passed by app
    LW_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_KSV_SIGNATURE         = 0x00000200, //!< Invalid key signature passed by app
    LW_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_SRM_SIGNATURE         = 0x00000400, //!< The player app looks suspicious
    LW_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_SRM_REVOKED           = 0x00000800, //!< Bad display due to revocation to carry HDCP content
    LW_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_REPEATER_NO_READY     = 0x00001000, //!< Repeater not ready
    LW_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_TOPOLOGY_ERROR        = 0x00002000, //!< Invalid topology for display devices' configuration
    LW_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_BAD_DISPLAY           = 0x00004000, //!< Invalid BKSV from display device
    LW_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_DEVICE_REVOKED        = 0x00008000, //!< Revoked device in multi stream topology
    LW_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_DEVICE_ILWALID        = 0x00010000, //!< Invalid device in multi stream topology
    LW_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_HOP_LIMIT_EXCEEDED    = 0x00020000, //!< Number of device hops in multi stream topology exceeds supported limit    
    // additional HDCP-related codes
} LW_HDCP_STATUS_INFO;

typedef struct _LW_HDCP_LINK_STATUS
{
    LW_HDCP_STATUS_INFO     lwHdcpStatusInfo;           //!< One or more HDCP-related status codes         
    LwU64                   bRepeaterPresent    : 1;    //!< Has a repeater
    LwU64                   bDebuggerDetected   : 1;    //!< Debugger is present
    LwU64                   bHDCPOn             : 1;    //!< HDCP encryption is ON
    LwU64                   bReserved1          : 61;
    LwU64                   qwReserved2;
} LW_HDCP_LINK_STATUS;

typedef struct _LW_MACROVISION_STATUS
{
    LwU64   bMacrovisionOn      : 1; //!< Macrovision protection is ON
    LwU64   bReserved1          : 63;
    LwU64   qwReserved2;
} LW_MACROVISION_STATUS;

typedef struct _LW_VIDEO_LINK_INFO
{
    LwU32                   version;
    LW_HDCP_LINK_STATUS     hdcpStatus;         //!< (OUT)
    LW_MACROVISION_STATUS   macrovisionStatus;  //!< (OUT)
} LW_VIDEO_LINK_INFO;

//! macro for constructing the version field of ::LW_VIDEO_LINK_INFO
#define LW_VIDEO_LINK_INFO_VER  MAKE_LWAPI_VERSION(LW_VIDEO_LINK_INFO,1)

LWAPI_INTERFACE LwAPI_GetVideoLinkParams(__in_opt LwDisplayHandle hLwDisplay, __in LwU32 outputId, __inout LW_VIDEO_LINK_INFO* pVideoLinkInfo);





#define LW_WFD_MAC_LEN 6
#define LW_WFD_SSID_LEN 32

///// BEGIN WFD Spec version 1.43 /////

typedef enum _LW_RESOLUTION_SPEC
{
    LW_RESOLUTION_SPEC_UNKNOWN         = 0,
    LW_RESOLUTION_SPEC_VESA            = 1,
    LW_RESOLUTION_SPEC_CEA             = 2,
    LW_RESOLUTION_SPEC_HANDHELD        = 3,
} LW_RESOLUTION_SPEC;

typedef struct _LW_RESOLUTION_EX_V1
{
    LwU32   version;
    LwU32   width;
    LwU32   height;
    LwU32   colorDepth;
    LwU32   refreshRate;
    LwU16   isInterlaced:1;
    LwU16   isNative    :1;
    LwU16   is3D        :1;
    LwU16   reserved    :13;
    LW_RESOLUTION_SPEC originSpec;
} LW_RESOLUTION_EX_V1;

typedef LW_RESOLUTION_EX_V1   LW_RESOLUTION_EX;
#define LW_RESOLUTION_EX_VER1 MAKE_LWAPI_VERSION(LW_RESOLUTION_EX_V1,1)
#define LW_RESOLUTION_EX_VER  LW_RESOLUTION_EX_VER1

// WFD spec, section 5.1.5.5, Table 5-14: Profiles Bitmap
typedef struct _LW_WFD_PROFILE_BITMAP
{
    LwU8    CBPbit          :  1;   //!< when 1, constrained baseline profile is supported
    LwU8    CHPbit          :  1;   //!< when 1, constrained high profile is supported
    LwU8    reserved        :  6;   //!< must be zero
} LW_WFD_PROFILE_BITMAP;


// WFD spec, section 5.1.5.6, Table 5-15: Levels bitmap
typedef struct _LW_WFD_LEVELS_BITMAP
{
    LwU16    supportH264Level3_1    :  1;   //!< when 1, H.264 Level 3.1 supported
    LwU16    supportH264Level3_2    :  1;   //!< when 1, H.264 Level 3.2 supported
    LwU16    supportH264Level4      :  1;   //!< when 1, H.264 Level 4 supported
    LwU16    supportH264Level4_1    :  1;   //!< when 1, H.264 Level 4.1 supported
    LwU16    supportH264Level4_2    :  1;   //!< when 1, H.264 Level 4.2 supported
    LwU16    reserved               :  11;  //!< must be zero
} LW_WFD_LEVELS_BITMAP;

// WFD spec, section 5.1.5.7, Table 5-16: Slice Encoding parameters bitmap
typedef struct _LW_WFD_SLICE_ENCODING_INFO
{
    LwU32   maxSliceNumBits     : 10;   
    LwU32   maxSliceSizeRatio   :  3;
    LwU32   reserved            : 19;   //!< must be zero
} LW_WFD_SLICE_ENCODING_INFO;


// WFD spec, section 5.1.5.8, Table 5-17: Video Frame Rate Control Support Bitmap
typedef struct _LW_WFD_FRAME_RATE_CONTROL_INFO
{
    LwU16    supportVideoFrameSkipping   :  1;   // lsb
    LwU16    maxSkipInterval             :  3;
    LwU16    supportVideoFrameRateChange :  1;
    LwU16    reserved                    :  11;   // msb, must be zero
} LW_WFD_FRAME_RATE_CONTROL_INFO;


typedef struct _LW_WFD_VIDEO_FORMATS
{  
    LW_WFD_PROFILE_BITMAP          profileBitmap;
    LW_WFD_LEVELS_BITMAP           levelsBitmap;
    LwU32                          resolutionCount;
    LW_RESOLUTION_EX*              resolutions;
    LwU8                           latencyField;                   //!< WFD spec 5.1.5, retrieve via WFD Video Format subelement
    LwU16                          minSliceSize;                   //!< WFD spec 5.1.5, retrieve via WFD Video Format subelement
    LW_WFD_SLICE_ENCODING_INFO     sliceEncoding;
    LW_WFD_FRAME_RATE_CONTROL_INFO frameRateControl;
    LwU8                           supportPreferredDisplayMode  :1; //!< WFD spec, wfd-preferred-display-mode (6.1.14) and Preferred Display Mode (Chapter 8)
    LwU8                           reserved                     :7; //!< Reserved. Should be ZERO.
    LwU16                          maxWidth;                        //!< WFD spec 6.1.3, supportedPreferredDisplayMode is true
    LwU16                          maxHeight;                       //!< WFD spec 6.1.3, supportedPreferredDisplayMode is true
} LW_WFD_VIDEO_FORMATS;


// Lwpu WFD definition based on WFD spec section 6.1.5
typedef struct _LW_WFD_CONTENT_PROTECTION
{
    LwU32   hdcp2_0     :  1;   //!< WFD transition period only
    LwU32   hdcp2_1     :  1; 
    LwU32   reserved    : 30;   //!< must be zero
    LwU16   tcpPort;
} LW_WFD_CONTENT_PROTECTION;


// Lwpu WFD definition
typedef struct _LW_WFD_PROTOCOL_PARAM_V1
{
    LwU32   version;   
    LwU32   isVideoFormatsValid       :  1;
    LwU32   iscontentProtectiolwalid  :  1;
    LwU32   reserved                  : 30;
    LW_WFD_VIDEO_FORMATS           videoFormats;
    LW_WFD_CONTENT_PROTECTION      contentProtection;
} LW_WFD_PROTOCOL_PARAM_V1;

typedef LW_WFD_PROTOCOL_PARAM_V1   LW_WFD_PROTOCOL_PARAM;
#define LW_WFD_PROTOCOL_PARAM_VER1 MAKE_LWAPI_VERSION(LW_WFD_PROTOCOL_PARAM_V1,1)
#define LW_WFD_PROTOCOL_PARAM_VER  LW_WFD_PROTOCOL_PARAM_VER1

typedef struct _LW_WFD_DISPLAY_V1
{
    LwU32 version;                     

    union
    {
        LwU32   displayId;                      //!< Display Identifier of display. Used for LwAPI_DISP_ReportDisplayEvent during LW_DISPLAY_REQUEST_UNPLUG
        LwPhysicalGpuHandle   hPhysicalGPU;     //!< GPU Identifier. Used for LwAPI_DISP_ReportDisplayEvent during LW_DISPLAY_REQUEST_HOTPLUG
    };
    LwU8    MAC[LW_WFD_MAC_LEN];                //!< Unique identity of the WFD sink 
    LwU8    SSID[LW_WFD_SSID_LEN];              //!< Current SSID associated to the WiFi Group
    LwU32   sizeOfEdid;                         //!< size of edid
    LwU8*   edid;                               //!< Edid of the monitor. Only used for LwAPI_DISP_ReportDisplayEvent during LW_DISPLAY_REQUEST_HOTPLUG
    LW_WFD_PROTOCOL_PARAM protocolParams;       //!< WFD protocol params. Only used for LwAPI_DISP_ReportDisplayEvent during LW_DISPLAY_REQUEST_HOTPLUG

    LwU32   wfdFormatsProvided          : 1;    //!< if formats provided via 6.1.3 wfd-video-formats, 6.1.4 wfd-3d-formats 
    LwU32   reconstructEdid             : 1;    //!< if edid is missing (6.1.6 wfd-display-edid not supported) reconstruct edid via wfd-video-formats 
    LwU32   blockSingleView             : 1;    //!< disallow topology in singleview for this monitor 
    LwU32   blockCloneView              : 1;    //!< disallow topology in clolwiew for this monitor  
    LwU32   blockMultiView              : 1;    //!< disallow topology in multiview for this monitor 
    LwU32   blockMixedView              : 1;    //!< disallow topology with combination of clone and extended for this monitor 
    LwU32   checkOwnerProcessId         : 1;    //!< disallow unplug operations on monitors not owned by the process 
    LwU32   unplugConnectionOnOwnerExit : 1;    //!< unplug monitor when owner process exits 
    LwU32   refreshConnectionOnBoot     : 1;    //!< if true, remember the last hotplug state prior to reboot
    LwU32   refreshConnectionOnResume   : 1;    //!< if true, remember the last hotplug state prior to hibernate
    LwU32   reserved                    : 22;   //!< must be zero
} LW_WFD_DISPLAY_V1;

typedef LW_WFD_DISPLAY_V1   LW_WFD_DISPLAY;
#define LW_WFD_DISPLAY_VER1 MAKE_LWAPI_VERSION(LW_WFD_DISPLAY_V1,1)
#define LW_WFD_DISPLAY_VER  LW_WFD_DISPLAY_VER1

typedef struct _LW_WFD_DISP_INFO_V1
{
    LwU32   version;                  
    LwU32   maxOsVisibleWFDDisplays;  //!< [out]max number of WFD sinks that are visible to the OS; not necessarily active
    LwU32   maxOsActiveWFDDisplays;   //!< [out]max number of WFD sink that can be simultaneously active
    LwU32   wfdDisplaysCount;         //!< [in]number of wireless displays for which information is being asked
    LW_WFD_DISPLAY* wfdDisplays;      //!< [in-out]displayIds as input
} LW_WFD_DISP_INFO_V1;


typedef LW_WFD_DISP_INFO_V1   LW_WFD_DISP_INFO;
#define LW_WFD_DISP_INFO_VER1 MAKE_LWAPI_VERSION(LW_WFD_DISP_INFO_V1,1)
#define LW_WFD_DISP_INFO_VER  LW_WFD_DISP_INFO_VER1

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_GetWFDDisplaysInfo
//
//! \fn LwAPI_DISP_GetWFDDisplaysInfo(__inout LW_WFD_DISP_INFO *wfdDisplaysInfo);
//! \code
//! DESCRIPTION:    This API gets information about wireless displays. To get display specific information, Caller is supposed to pass wfdDisplaysCount and 
//!                 displayIds of LW_WFD_DISPLAY. It will return information of all WFD displays whose displayId is passed.
//!                 DisplayId for WFD displays can be retrieved by LwAPI_GPU_GetConnectedDisplayIds.
//!                 
//!
//! SUPPORTED OS:  Windows 7
//!
//! \param [in,out]     wfdDisplaysInfo      pointer to LW_WFD_DISP_INFO
//! 
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status.
//!              If there are return error codes with specific meaning for this API, they are listed below.
//!
//!
//! \ingroup dispcontrol 
//////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetWFDDisplaysInfo(__inout LW_WFD_DISP_INFO *wfdDisplaysInfo);




typedef enum _LW_DISP_REQUEST_TYPE
{
    LW_DISPLAY_REQUEST_UNKNOWN = 0,
    LW_DISPLAY_REQUEST_HOTPLUG,           //!< Hot-Plug Request
    LW_DISPLAY_REQUEST_UNPLUG,            //!< Unplug Request
}LW_DISP_REQUEST_TYPE;

typedef struct _LW_DISP_REQ_INFO_V1
{
    LwU32 version;                  
    LW_DISP_REQUEST_TYPE reqType;
    LwU32 isWFD    : 1;                 //!< if WFD display
    LwU32 reserved : 31;
    LW_WFD_DISPLAY wfdDisplay;          //!< if request is related to WFD display, this must be filled. Otherwise ignored.
} LW_DISP_REQ_INFO_V1;

typedef LW_DISP_REQ_INFO_V1   LW_DISP_REQ_INFO;
#define LW_DISP_REQ_INFO_VER1 MAKE_LWAPI_VERSION(LW_DISP_REQ_INFO_V1,1)
#define LW_DISP_REQ_INFO_VER  LW_DISP_REQ_INFO_VER1

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_ReportDisplayEvent
//
//! \fn LwAPI_DISP_ReportDisplayEvent(__in LW_DISP_REQ_INFO *dispReqInfo);
//! \code
//! DESCRIPTION:    This API reports hot-plug, unplug event of display to driver with detailed info of display.To unplug, Caller needs to just
//!                 pass displayId of LW_WFD_DISPLAY. To hot-plug, caller needs to pass maciD, SSID, protocol etc except displayId.
//!
//! SUPPORTED OS:  Windows 7
//!
//! \param [in]  dispReqInfo      Properties of WFD displays with request type.
//! 
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status.
//!              If there are return error codes with specific meaning for this API, they are listed below.
//!
//!
//! \ingroup dispcontrol 
//////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_ReportDisplayEvent(__in LW_DISP_REQ_INFO *dispReqInfo);




//! @}


//! \ingroup dispcontrol
//! Used in _LW_BPC_CONFIG
typedef enum _LW_BPC_CONFIG_CMD
{
    LW_BPC_CONFIG_CMD_GET = 0,        //!< get the current BPC configuration
    LW_BPC_CONFIG_CMD_SET             //!< set the new BPC configuration

}LW_BPC_CONFIG_CMD;

//! \ingroup dispcontrol
//! Used in LwAPI_DISP_BpcConfiguration().
typedef struct _LW_BPC_CONFIG_V1
{
    LwU32                   version;                   //!< (IN)     structure version
    LwU32                   displayId;                 //!< (IN)     the displayId of the monitor whose BPC config is being get or set
    LW_BPC_CONFIG_CMD       cmd;                       //!< (IN)     see :: _LW_BPC_CONFIG_CMD
    LwU32                   bpc;                       //!< (IN/OUT) the new/current scan out bits per component
    LwU32                   ditherOff :            1;  //!< (IN)     Force to turn the dither off. Valid for _CMD_SET only.
    LwU32                   forceAtLwrLinkConfig : 1;  //!< (IN)     Force the depth change even if it is not supported at current link config - used for testing.
                                                       //!<          Valid for _CMD_SET only.
    LwU32                   forceRGDivMode :       1;  //!< (IN)     Force the hardware into RG Div mode - used for testing. Valid for _CMD_SET only.
}LW_BPC_CONFIG_V1;

#define LW_BPC_CONFIG_VER1  MAKE_LWAPI_VERSION(LW_BPC_CONFIG_V1,1)
#define LW_BPC_CONFIG_VER   LW_BPC_CONFIG_VER1

typedef LW_BPC_CONFIG_V1    LW_BPC_CONFIG;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DISP_BpcConfiguration
//
//!  DESCRIPTION: This API gets or set the BPC (Bits per Component) configuration
//!               for the display specified by the displayId input.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out] pLwBpcConfig  Pointer to the LW_BPC_CONFIG structure.
//!
//! \return     This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!             specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////

LWAPI_INTERFACE LwAPI_DISP_BpcConfiguration(__inout LW_BPC_CONFIG *pLwBpcConfig);



//! \ingroup disphandle

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_GetDisplayHandleFromDisplayId
//
//! DESCRIPTION:    This API maps a Display ID to the Display Handle of a display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:     displayId(IN)       - Display ID assigned to a display selection.
//!                 phLwDisplay(OUT)    - Pointer to display handle associated with the input displayId.
//!
//!                  
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//! \endcode
///////////////////////////////////////////////////////////////////////////////

LWAPI_INTERFACE LwAPI_DISP_GetDisplayHandleFromDisplayId(__in LwU32 displayId, __out LwDisplayHandle *phLwDisplay);


//! \ingroup disphandle

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DISP_GetDisplayIdFromDisplayHandle
//
//! DESCRIPTION:    This API maps a Display Handle to the Display ID of a display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:     hLwDisplay(IN)     - Display handle assigned to a display selection.
//!	                pdisplayId(OUT)    - Pointer to display ID associated with the input hLwDisplay.
//!
//!                  
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//! \endcode
///////////////////////////////////////////////////////////////////////////////

LWAPI_INTERFACE LwAPI_DISP_GetDisplayIdFromDisplayHandle(__in LwDisplayHandle hLwDisplay, __out LwU32 *pDisplayId);

//! SUPPORTED OS:  Windows Vista and higher
//!

//! This enum could be extended in the future to support more request type.
typedef enum _LW_DP_REQUEST
{
    LW_DP_REQUEST_QSES
} LW_DP_REQUEST;

typedef enum _LW_DP_REQUEST_STATUS
{
    LW_DP_REQUEST_STATUS_PENDING = 0,
    LW_DP_REQUEST_STATUS_DONE = 1,
    LW_DP_REQUEST_STATUS_ERROR = 2,
    LW_DP_REQUEST_STATUS_NEWREQUEST = 3,
} LW_DP_REQUEST_STATUS;

typedef enum _LW_DP_STREAM_STATE
{
    LW_DP_STREAM_STATE_NOT_EXIST = 0,
    LW_DP_STREAM_STATE_INACTICE = 1,
    LW_DP_STREAM_STATE_ACTIVE = 2,
} LW_DP_STREAM_STATE;

typedef enum _LW_OUTPUT_SINK_TYPE
{
    LW_OUTPUT_SINK_TYPE_UNCONNECTED = 0,
    LW_OUTPUT_SINK_TYPE_NONEAUTH_LEGACY_DEVICE = 1,    //!< TV or CRT
    LW_OUTPUT_SINK_TYPE_NONE12CP_OR_NONQSE = 2,        //!< DVI/HDMI or DP 1.1 sink/repeater
    LW_OUTPUT_SINK_TYPE_DP_MST = 4
} LW_OUTPUT_SINK_TYPE;

typedef enum _LW_OUTPUT_CPTYPE
{
    LW_OUTPUT_CPTYPE_HDCP1x = 1,
    LW_OUTPUT_CPTYPE_HDCP2x = 2
} LW_OUTPUT_CPTYPE;

//! more info for this struct, refer to VESA DisplayPort Standard
typedef struct _LW_DP_REPLY_QSES
{
    LW_DP_STREAM_STATE      streamState;            //!< active or inactive
    LwU8                    repeaterFuncPresent;    //!< true, if The stream is directed to one or more outputs of the Branch device
    LwU8                    encryption;             //!< true, if encryting on
    LwU8                    authentication;         //!< true if stream completed all parts of authentication
    LW_OUTPUT_SINK_TYPE     sinkType;               //!< receiver type
    LW_OUTPUT_CPTYPE        cpType;                 //!< output type
    LwU8                    signedLPrime;           //!< true if signature L' is provided
    LwU8                    streamId;               //!< stream ID
    LwU8                    LPrime[20];             //!< L' signature
} LW_DP_REPLY_QSES;

typedef struct _LW_DP_REQUEST_HEADER
{
    LwU32                   requestSize;            //!< size of real requeset structure pointed by pRequest
    void                    *pRequest;              //!< request pointer
} LW_DP_REQUEST_HEADER;

//! Macro for constructing the version field of LW_DP_REQUEST_HEADER.
#define LW_DP_REQUEST_HEADER_VER1  MAKE_LWAPI_VERSION(LW_DP_REQUEST_HEADER,1)

typedef struct _LW_DP_STATUS_REQUEST_QSES
{
    LW_DP_REQUEST                   requestType;    //!< indicated what status to get, for DP    
    LwU32                           streamID;
    LW_DP_REPLY_QSES                reply;
} LW_DP_STATUS_REQUEST_QSES;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DISP_DP_QueryStatus
//
//! DESCRIPTION: This API is used to get display device status. The type of status to get is based on the arguments.
//!
//!              pRequest in a LW_DP_REQUEST_HEADER pointed by pRequestHeader should point to a LW_DP_STATUS_REQUEST_xxx
//!              structure. The requestSize in the LW_DP_REQUEST_HEADER structure should be sizeof(LW_DP_STATUS_REQUEST_xxx)
//!              
//! \param [in]         displayId             Display ID
//! \param [in,out]     pRequestHeader        pointer to request header structure
//!
//! \return    This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!                              
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_DP_QueryStatus(__in LwU32 displayId, __inout LW_DP_REQUEST_HEADER *pRequestHeader);

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DISP_DP_GetStreamIDs
//
//! DESCRIPTION: This is API used to get DP device stream IDs. 
//!              
//!              The API should be called twice,
//!              first time with NULL for pStreamIds to get the total stream number pointed by pCount,
//!              and second time pass in the buffer pointer of minimum size sizeof(*pCount * sizeof(LwU32)).
//!
//!              For the second time call, the pCount should point to the number that indicates the maximum
//!              number of streams the buffer can hold. After API returns, the number pointed by pCount will
//!              indicated how many streamID has been put in the buffer, if the function succeeds. The return
//!              value should always be checked. If the function fails for LWAPI_INSUFFICIENT_BUFFER, the value
//!              pointed by pCount indicates the number of entry the buffer should hold.
//!
//! \param [in]             displayId           Display ID
//! \param [in,out,opt]     pStreamIds          pointer to streamID buffer
//! \param [in,out]         pCount              pointer to counter of entries
//!
//! \return    This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_DP_GetStreamIDs(__in LwU32 displayId, __inout_opt LwU32 *pStreamIds, __inout LwU32 *pCount);

//! SUPPORTED OS:  Windows 7 and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DISP_ApplyAndSaveLwstomResolution
//
//! DESCRIPTION: This API is used to apply the given resolution directly on the specified display.
//!              
//!                 Lwrrently this API is only supported on a virtualized platform.
//!                 The originSpec field in the LW_RESOLUTION_EX structure is ignored.
//!
//! \param [in]     displayId           Display ID
//! \param [in]     pResolution         pointer to LW_RESOLUTION_EX structure.
//!
//! \return    This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_ApplyAndSaveLwstomResolution(__in LwU32 displayId, __in LW_RESOLUTION_EX *pResolution);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_DISP_GetDisplayIdsInCluster
//
//! DESCRIPTION:    This API returns the set of Display Ids which comprise the cluster, whose representative display ID is passed as input.
//!
//! HOW TO USE: 1. The first call should be made to get the physical display ID count. To get the display ID count, send in 
//!                  a) clusterDisplayId     - a valid cluster representative's display Id as input.
//!                  b) clusterType          - a valid pointer to LW_CLUSTER_TYPE, whose value is set to ZERO.      
//!                  c) displayIdCount       - a valid pointer to LwU32, whose value is set to ZERO.                            
//!                  d) displayIds           - NULL, as we just want to get the display ID count.                 
//!                If all parameters are correct and this call is successful, this call will return the display ID's count and the cluster type. 
//!             2. To get the display ID array, make the second call to LwAPI_DISP_GetDisplayIdsInCluster() with   
//!                  a) clusterDisplayId     - a valid cluster representative's display Id as input.
//!                  b) clusterType          - a valid pointer to LW_CLUSTER_TYPE.                                  
//!                  c) displayIdCount       - a valid pointer to LwU32. This indicates for how many display IDs            
//!                                            the memory is allocated(displayIds) by the caller. 
//!                  d) displayIds           - pointer to the display ID array allocated by caller based on display ID count,   
//!                                            eg. malloc(sizeof(LwU32) * displayIdCount).                                             
//!                If all parameters are correct and this call is successful, this call will return the cluster type, display ID array 
//!                and actual display ID count (which was obtained in the first call to LwAPI_DISP_GetDisplayIdsInCluster).
//!                If the input display ID count is  less than the actual display ID count, it will overwrite the input and give the
//!                displayIdCount as actual count and the API will return LWAPI_INSUFFICIENT_BUFFER.
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     clusterDisplayId  The representative display ID for which the underlying display IDs are requested.
//! \paran [out]    clusterType       This parameter will return the type of cluster the displays form.
//! \param [in,out] displayIdCount    As input, this parameter indicates the number of display's id's for which caller has 
//!                                   allocated the memory. As output, it will return the actual number of display IDs.
//! \param [out]    displayIds        Pointer to an array of LwU32 structure, each entry represents one displayID.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval  LWAPI_INSUFFICIENT_BUFFER  When the input buffer(displayIds) is less than the actual number of display IDs, this API 
//!                                     will return LWAPI_INSUFFICIENT_BUFFER. 
//!
//! \ingroup dispcontrol
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetDisplayIdsInCluster(__in LwU32 clusterDisplayId, __out LW_CLUSTER_TYPE* clusterType, __inout LwU32* displayIdCount,  __out_ecount_part_opt(*displayIdCount, *displayIdCount) LwU32* displayIds);




typedef enum _LW_HYPER_SAMPLING_CMD
{
    LW_HYPER_SAMPLING_CREATE  = 1,
    LW_HYPER_SAMPLING_APPLY_SHARPNESS_ONLY  = 2, 
} LW_HYPER_SAMPLING_CMD;

typedef struct _LW_HYPER_SAMPLING_V1
{
    LwU32                           version;
    LwU32                           samplingFactorsCount;  //!< number of entries in samplingFactors
    LwU32                           *samplingFactors;     //!< Array of factor in multipleS of 10K to which native resolution of monitor is multiplied
    LwU32                           sharpness;           //!< sharpness in percentage. It will be same for all smooth sampling factors.
                                                     
} LW_HYPER_SAMPLING_V1;

#define LW_HYPER_SAMPLING_VER1  MAKE_LWAPI_VERSION(LW_HYPER_SAMPLING_V1,1)
#define LW_HYPER_SAMPLING_VER   LW_HYPER_SAMPLING_VER1

typedef LW_HYPER_SAMPLING_V1    LW_HYPER_SAMPLING;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DISP_SetHyperSamplingSettings
//
//! DESCRIPTION: This API is used to enable smooth sampling. After successful return of API, native resolution*sampling factor
//!              will be enabled on the display. Before calling LwAPI_DISP_SetHyperSamplingSettings, LwAPI_SYS_SetFeatureState must be called
//!              to enable LW_FEATURE_ID_HYPER_SAMPLING.
//!              In case of cmd LW_HYPER_SAMPLING_APPLY_SHARPNESS, sharpness would be applied on all smooth samplings.
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in]         displayId             display identifier. Ignored in case of cmd LW_HYPER_SAMPLING_APPLY_SHARPNESS.
//! \param [in]         cmd                   one of command of LW_HYPER_SAMPLING_CMD.
//! \param [in,out]     smoothSampling         pointer to LW_HYPER_SAMPLING
//! \param [in]         flag                  reserved for future use
//!
//! \return    This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!  \retval ::LWAPI_SET_NOT_ALLOWED        - Either custom resolution is active or active sampling factor is getting removed.
//!                              
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_SetHyperSamplingSettings(__in LwU32 displayId, __in LW_HYPER_SAMPLING_CMD cmd, __inout LW_HYPER_SAMPLING hyperSampling, __in LwU32 *flag);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DISP_GetHyperSamplingSettings
//
//! DESCRIPTION: This API is used to get all Hyper sampling setting applied on the display. 
//!              
//! HOW TO USE: 1.make a call to LwAPI_DISP_GetHyperSamplingSettings to get the hyperSampling->hyperSamplingcount by passing the hyperSampling->samplingFactors as NULL. 
//!              On call success:
//!             2.Allocate memory (samplingFactorsCount * sizeof(LwU32)) then make a call LwAPI_DISP_GetHyperSamplingSettings to get hyperSampling info.
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in]         displayId             display identifier. Ignored in case of cmd LW_HYPER_SAMPLING_APPLY_SHARPNESS_ONLY.
//! \param [in,out]     hyperSampling          pointer to LW_HYPER_SAMPLING
//! \param [out]        flag                  reserved for future use
//! \return    This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!                              
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DISP_GetHyperSamplingSettings(__in LwU32 displayId, __in_opt LW_HYPER_SAMPLING *hyperSampling, __out LwU32 *flag);


////////////////////////////////////////////////////////////////////////////////////////
//
// MOSAIC allows a multi display target output scanout on a single source. 
//
// SAMPLE of MOSAIC 1x4 topo with 8 pixel horizontal overlap
//
//+-------------------------++-------------------------++-------------------------++-------------------------+
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|        DVI1             ||           DVI2          ||         DVI3            ||          DVI4           |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//+-------------------------++-------------------------++-------------------------++-------------------------+


//! \addtogroup mosaicapi
//! @{

#define LWAPI_MAX_MOSAIC_DISPLAY_ROWS       8
#define LWAPI_MAX_MOSAIC_DISPLAY_COLUMNS    8
#define LW_MOSAIC_MAX_DISPLAYS      (64)
//
// These bits are used to describe the validity of a topo.
//
#define LW_MOSAIC_TOPO_VALIDITY_VALID               0x00000000  //!< The topology is valid
#define LW_MOSAIC_TOPO_VALIDITY_MISSING_GPU         0x00000001  //!< Not enough SLI GPUs were found to fill the entire
                                                                //! topology. hPhysicalGPU will be 0 for these.
#define LW_MOSAIC_TOPO_VALIDITY_MISSING_DISPLAY     0x00000002  //!< Not enough displays were found to fill the entire
                                                                //! topology. displayOutputId will be 0 for these.
#define LW_MOSAIC_TOPO_VALIDITY_MIXED_DISPLAY_TYPES 0x00000004  //!< The topoogy is only possible with displays of the same
                                                                //! LW_GPU_OUTPUT_TYPE. Check displayOutputIds to make
                                                                //! sure they are all CRTs, or all DFPs.


//
//! This structure defines the topology details.
typedef struct 
{
    LwU32                version;              //!< Version of this structure
    LwLogicalGpuHandle   hLogicalGPU;          //!< Logical GPU for this topology 
    LwU32                validityMask;         //!< 0 means topology is valid with the current hardware.
                                               //! If not 0, inspect bits against LW_MOSAIC_TOPO_VALIDITY_*.
    LwU32                rowCount;             //!< Number of displays in a row
    LwU32                colCount;             //!< Number of displays in a column

    struct 
    {
        LwPhysicalGpuHandle hPhysicalGPU;      //!< Physical GPU to be used in the topology (0 if GPU missing)
        LwU32               displayOutputId;   //!< Connected display target (0 if no display connected)
        LwS32               overlapX;          //!< Pixels of overlap on left of target: (+overlap, -gap)
        LwS32               overlapY;          //!< Pixels of overlap on top of target: (+overlap, -gap)

    } gpuLayout[LWAPI_MAX_MOSAIC_DISPLAY_ROWS][LWAPI_MAX_MOSAIC_DISPLAY_COLUMNS];

} LW_MOSAIC_TOPO_DETAILS;

//! Macro for constructing te vesion field of LW_MOSAIC_TOPO_DETAILS
#define LWAPI_MOSAIC_TOPO_DETAILS_VER         MAKE_LWAPI_VERSION(LW_MOSAIC_TOPO_DETAILS,1)


//
//! These values refer to the different types of Mosaic topologies that are possible.  When
//! getting the supported Mosaic topologies, you can specify one of these types to narrow down
//! the returned list to only those that match the given type.
typedef enum
{
    LW_MOSAIC_TOPO_TYPE_ALL,                          //!< All mosaic topologies
    LW_MOSAIC_TOPO_TYPE_BASIC,                        //!< Basic Mosaic topologies
    LW_MOSAIC_TOPO_TYPE_PASSIVE_STEREO,               //!< Passive Stereo topologies
    LW_MOSAIC_TOPO_TYPE_SCALED_CLONE,                 //!< Not supported at this time
    LW_MOSAIC_TOPO_TYPE_PASSIVE_STEREO_SCALED_CLONE,  //!< Not supported at this time
    LW_MOSAIC_TOPO_TYPE_MAX,                          //!< Always leave this at end of the enum
} LW_MOSAIC_TOPO_TYPE;


//
//! This is a complete list of supported Mosaic topologies.
//!
//! Using a "Basic" topology combines multiple monitors to create a single desktop.
//!
//! Using a "Passive" topology combines multiples monitors to create a passive stereo desktop.
//! In passive stereo, two identical topologies combine - one topology is used for the right eye and the other identical //! topology (targeting different displays) is used for the left eye.  \n  
//! NOTE: common\inc\lwEscDef.h shadows a couple PASSIVE_STEREO enums.  If this
//!       enum list changes and effects the value of LW_MOSAIC_TOPO_BEGIN_PASSIVE_STEREO
//!       please update the corresponding value in lwEscDef.h
typedef enum
{
    LW_MOSAIC_TOPO_NONE,

    // 'BASIC' topos start here
    //
    // The result of using one of these Mosaic topos is that multiple monitors
    // will combine to create a single desktop.
    //
    LW_MOSAIC_TOPO_BEGIN_BASIC,
    LW_MOSAIC_TOPO_1x2_BASIC = LW_MOSAIC_TOPO_BEGIN_BASIC,
    LW_MOSAIC_TOPO_2x1_BASIC,
    LW_MOSAIC_TOPO_1x3_BASIC,
    LW_MOSAIC_TOPO_3x1_BASIC,
    LW_MOSAIC_TOPO_1x4_BASIC,
    LW_MOSAIC_TOPO_4x1_BASIC,
    LW_MOSAIC_TOPO_2x2_BASIC,
    LW_MOSAIC_TOPO_2x3_BASIC,
    LW_MOSAIC_TOPO_2x4_BASIC,
    LW_MOSAIC_TOPO_3x2_BASIC,
    LW_MOSAIC_TOPO_4x2_BASIC,
    LW_MOSAIC_TOPO_1x5_BASIC,
    LW_MOSAIC_TOPO_1x6_BASIC,
    LW_MOSAIC_TOPO_7x1_BASIC,

    // Add padding for 10 more entries. 6 will be enough room to specify every
    // possible topology with 8 or fewer displays, so this gives us a little
    // extra should we need it.
    LW_MOSAIC_TOPO_END_BASIC = LW_MOSAIC_TOPO_7x1_BASIC + 9,

    // 'PASSIVE_STEREO' topos start here
    //
    // The result of using one of these Mosaic topos is that multiple monitors
    // will combine to create a single PASSIVE STEREO desktop.  What this means is
    // that there will be two topos that combine to create the overall desktop.
    // One topo will be used for the left eye, and the other topo (of the
    // same rows x cols), will be used for the right eye.  The difference between
    // the two topos is that different GPUs and displays will be used.
    //
    LW_MOSAIC_TOPO_BEGIN_PASSIVE_STEREO,    // value shadowed in lwEscDef.h
    LW_MOSAIC_TOPO_1x2_PASSIVE_STEREO = LW_MOSAIC_TOPO_BEGIN_PASSIVE_STEREO,
    LW_MOSAIC_TOPO_2x1_PASSIVE_STEREO,
    LW_MOSAIC_TOPO_1x3_PASSIVE_STEREO,
    LW_MOSAIC_TOPO_3x1_PASSIVE_STEREO,
    LW_MOSAIC_TOPO_1x4_PASSIVE_STEREO,
    LW_MOSAIC_TOPO_4x1_PASSIVE_STEREO,
    LW_MOSAIC_TOPO_2x2_PASSIVE_STEREO,
    LW_MOSAIC_TOPO_END_PASSIVE_STEREO = LW_MOSAIC_TOPO_2x2_PASSIVE_STEREO + 4,


    //
    // Total number of topos.  Always leave this at the end of the enumeration.
    //
    LW_MOSAIC_TOPO_MAX  //! Total number of topologies.

} LW_MOSAIC_TOPO;


//
//! This is a "topology brief" structure.  It tells you what you need to know about
//! a topology at a high level. A list of these is returned when you query for the
//! supported Mosaic information.
//!
//! If you need more detailed information about the topology, call
//! LwAPI_Mosaic_GetTopoGroup() with the topology value from this structure.
typedef struct 
{
    LwU32                        version;            //!< Version of this structure
    LW_MOSAIC_TOPO               topo;               //!< The topology
    LwU32                        enabled;            //!< 1 if topo is enabled, else 0
    LwU32                        isPossible;         //!< 1 if topo *can* be enabled, else 0

} LW_MOSAIC_TOPO_BRIEF;

//! Macro for constructing the version field of LW_MOSAIC_TOPO_BRIEF
#define LWAPI_MOSAIC_TOPO_BRIEF_VER         MAKE_LWAPI_VERSION(LW_MOSAIC_TOPO_BRIEF,1)


//
//! Basic per-display settings that are used in setting/getting the Mosaic mode
typedef struct 
{
    LwU32                        version;            //!< Version of this structure
    LwU32                        width;              //!< Per-display width
    LwU32                        height;             //!< Per-display height
    LwU32                        bpp;                //!< Bits per pixel
    LwU32                        freq;               //!< Display frequency
} LW_MOSAIC_DISPLAY_SETTING;

//! Macro for constructing the version field of LW_MOSAIC_DISPLAY_SETTING
#define LWAPI_MOSAIC_DISPLAY_SETTING_VER         MAKE_LWAPI_VERSION(LW_MOSAIC_DISPLAY_SETTING,1)


//
// Set a reasonable max number of display settings to support
// so arrays are bound.
//
#define LW_MOSAIC_DISPLAY_SETTINGS_MAX 40  //!< Set a reasonable maximum number of display settings to support
                                           //! so arrays are bound.


//
//! This structure is used to contain a list of supported Mosaic topologies
//! along with the display settings that can be used.
typedef struct 
{
    LwU32                       version;                                         //!< Version of this structure
    LwU32                       topoBriefsCount;                                 //!< Number of topologies in below array
    LW_MOSAIC_TOPO_BRIEF        topoBriefs[LW_MOSAIC_TOPO_MAX];                  //!< List of supported topologies with only brief details
    LwU32                       displaySettingsCount;                            //!< Number of display settings in below array
    LW_MOSAIC_DISPLAY_SETTING   displaySettings[LW_MOSAIC_DISPLAY_SETTINGS_MAX]; //!< List of per display settings possible

} LW_MOSAIC_SUPPORTED_TOPO_INFO;

//! Macro forconstructing  the version field of LW_MOSAIC_SUPPORTED_TOPO_INFO
#define LWAPI_MOSAIC_SUPPORTED_TOPO_INFO_VER         MAKE_LWAPI_VERSION(LW_MOSAIC_SUPPORTED_TOPO_INFO,1)


//
// Indices to use to access the topos array within the mosaic topology
#define LW_MOSAIC_TOPO_IDX_DEFAULT       0

#define LW_MOSAIC_TOPO_IDX_LEFT_EYE      0
#define LW_MOSAIC_TOPO_IDX_RIGHT_EYE     1
#define LW_MOSAIC_TOPO_NUM_EYES          2


//
//! This defines the maximum number of topos that can be in a topo group.
//! At this time, it is set to 2 because our largest topo group (passive
//! stereo) only needs 2 topos (left eye and right eye).
//!
//! If a new topo group with more than 2 topos is added above, then this
//! number will also have to be incremented.
#define LW_MOSAIC_MAX_TOPO_PER_TOPO_GROUP 2 


//
//! This structure defines a group of topologies that work together to create one
//! overall layout.  All of the supported topologies are represented with this
//! structure.
//!
//! For example, a 'Passive Stereo' topology would be represented with this
//! structure, and would have separate topology details for the left and right eyes.
//! The count would be 2.  A 'Basic' topology is also represented by this structure,
//! with a count of 1.
//!
//! The structure is primarily used internally, but is exposed to applications in a
//! read-only fashion because there are some details in it that might be useful
//! (like the number of rows/cols, or connected display information).  A user can
//! get the filled-in structure by calling LwAPI_Mosaic_GetTopoGroup().
//!
//! You can then look at the detailed values within the structure.  There are no
//! entrypoints which take this structure as input (effectively making it read-only).
typedef struct 
{
    LwU32                      version;              //!< Version of this structure
    LW_MOSAIC_TOPO_BRIEF       brief;                //!< The brief details of this topo
    LwU32                      count;                //!< Number of topos in array below
    LW_MOSAIC_TOPO_DETAILS     topos[LW_MOSAIC_MAX_TOPO_PER_TOPO_GROUP];

} LW_MOSAIC_TOPO_GROUP;

//! Macro for constructing the version field of LW_MOSAIC_TOPO_GROUP
#define LWAPI_MOSAIC_TOPO_GROUP_VER         MAKE_LWAPI_VERSION(LW_MOSAIC_TOPO_GROUP,1)

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_GetSupportedTopoInfo
//
//! DESCRIPTION:     This API returns information on the topologies and display resolutions
//!                  supported by Mosaic mode.
//!
//!                  NOTE: Not all topologies returned can be set immediately.
//!                        See 'OUT' Notes below.
//!
//!                  Once you get the list of supported topologies, you can call
//!                  LwAPI_Mosaic_GetTopoGroup() with one of the Mosaic topologies if you need
//!                  more information about it.
//!
//!     <b>'IN' Notes:</b>  pSupportedTopoInfo->version must be set before calling this function.
//!                  If the specified version is not supported by this implementation,
//!                  an error will be returned (LWAPI_INCOMPATIBLE_STRUCT_VERSION).
//!
//!     <b>'OUT' Notes:</b> Some of the topologies returned might not be valid for one reason or
//!                  another.  It could be due to mismatched or missing displays.  It
//!                  could also be because the required number of GPUs is not found.
//!                  At a high level, you can see if the topology is valid and can be enabled
//!                  by looking at the pSupportedTopoInfo->topoBriefs[xxx].isPossible flag.
//!                  If this is true, the topology can be enabled. If it
//!                  is false, you can find out why it cannot be enabled by getting the
//!                  details of the topology via LwAPI_Mosaic_GetTopoGroup().  From there,
//!                  look at the validityMask of the individual topologies.  The bits can
//!                  be tested against the LW_MOSAIC_TOPO_VALIDITY_* bits.
//!
//!                  It is possible for this function to return LWAPI_OK with no topologies
//!                  listed in the return structure.  If this is the case, it means that
//!                  the current hardware DOES support Mosaic, but with the given configuration
//!                  no valid topologies were found.  This most likely means that SLI was not
//!                  enabled for the hardware. Once enabled, you should see valid topologies
//!                  returned from this function.
//!    
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//!
//! \param [in,out]  pSupportedTopoInfo  Information about what topologies and display resolutions
//!                                      are supported for Mosaic.
//! \param [in]      type                The type of topologies the caller is interested in
//!                                      getting. See LW_MOSAIC_TOPO_TYPE for possible values.
//!
//! \retval ::LWAPI_OK                          No errors in returning supported topologies.
//! \retval ::LWAPI_NOT_SUPPORTED               Mosaic is not supported with the existing hardware.
//! \retval ::LWAPI_ILWALID_ARGUMENT            One or more arguments passed in are invalid.
//! \retval ::LWAPI_API_NOT_INTIALIZED          The LwAPI API needs to be initialized first.
//! \retval ::LWAPI_NO_IMPLEMENTATION           This entrypoint not available.
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION The version of the structure passed in is not
//                                              compatible with this entry point.
//! \retval ::LWAPI_ERROR:                      Miscellaneous error oclwrred.
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Mosaic_GetSupportedTopoInfo(LW_MOSAIC_SUPPORTED_TOPO_INFO *pSupportedTopoInfo, LW_MOSAIC_TOPO_TYPE type);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_GetSupportedTopoInfoEx
//
//! DESCRIPTION:     This API returns information on the topologies and display resolutions
//!                  supported by Mosaic.
//!
//!                  This function is equivalent to calling LwAPI_Mosaic_GetSupportedTopoInfo(), and
//!                  then calling LwAPI_Mosaic_GetTopoGroup() for each topology.
//!
//!                  If pTopoGroups and pDisplaySettngs are NULL, then pTopoGroupCount and
//!                  pDisplaySettingsCount will be set to the number of supported Mosaic topologies
//!                  and the number of supported display modes.
//!
//!                  If pTopoGroups and pDisplaySettings are not NULL, then pTopoGroupCount and
//!                  pDisplaySettingsCount contain the maximum number of topologies and display
//!                  modes to return. On return, pTopoGroupCount and pDisplaySettingsCount will
//!                  be set to the number of topologies and modes that were returned.
//!
//!                  NOTE: Not all topologies returned can be immediately set.
//!                        See 'OUT' Notes below.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     type                    The type of topology the caller is interested
//!                                         in getting. See ::LW_MOSAIC_TOPO_TYPE for possible
//!                                         values.
//! \param [out]    pTopoGroups             The details of each supported Mosaic topology.
//! \param [in,out] pTopoGroupCount         A pointer to the number of SLI topologies.
//! \param [out]    pDisplaySettings        The list of supported display modes.
//! \param [in,out] pDisplaySettingsCount   A pointer to the number of display modes.
//!
//!     'OUT' Notes: Some of the topologies returned might not be valid for one reason or
//!                  another. It could be due to mismatched or missing displays. It could
//!                  also be because the required number of GPUs is not found. At a high
//!                  level, you can see if the topology is valid and can be enabled by looking
//!                  at the pTopoGroups[xxx].brief.isPossible flag. If this is true, the
//!                  topology can be enabled. Otherwise, if it is false, you can find out why
//!                  it cannot be enabled by looking at the validityMask of the individual
//!                  topologies. The bits can be tested against the LW_MOSAIC_TOPO_VALIDITY_*
//!                  bits.
//!
//!                  It is possible for this function to return LWAPI_OK with no topologies
//!                  listed in the array. If this is the case, it means that the current
//!                  hardware DOES support Mosaic, but with the given configuration no
//!                  valid topologies were found. This most likely means that SLI was not
//!                  enabled for the hardware. Once enabled, you should see valid topologies
//!                  returned from this function.
//!
//! \retval ::LWAPI_OK                          No errors in returning supported topologies
//! \retval ::LWAPI_NOT_SUPPORTED               Mosaic is not supported with the existing hardware
//! \retval ::LWAPI_ILWALID_ARGUMENT            One or more args passed in are invalid
//! \retval ::LWAPI_API_NOT_INTIALIZED          The LwAPI API needs to be initialized first
//! \retval ::LWAPI_NO_IMPLEMENTATION           This entrypoint not available
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION The version of the structure passed in is not
//                                              compatible with this entrypoint
//! \retval ::LWAPI_ERROR                       Miscellaneous error oclwrred
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Mosaic_GetSupportedTopoInfoEx(LW_MOSAIC_TOPO_TYPE type,
                                                    LW_MOSAIC_TOPO_GROUP *pTopoGroups,
                                                    LwU32 *pTopoGroupCount,
                                                    LW_MOSAIC_DISPLAY_SETTING *pDisplaySettings,
                                                    LwU32 *pDisplaySettingsCount);






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_GetTopoGroup
//
//! DESCRIPTION:     This API returns a structure filled with the details
//!                  of the specified Mosaic topology.
//!
//!                  If the pTopoBrief passed in matches the current topology,
//!                  then information in the brief and group structures
//!                  will reflect what is current. Thus the brief would have
//!                  the current 'enable' status, and the group would have the
//!                  current overlap values. If there is no match, then the
//!                  returned brief has an 'enable' status of FALSE (since it
//!                  is obviously not enabled), and the overlap values will be 0.
//!
//!     <b>'IN' Notes:</b>  pTopoGroup->version must be set before calling this function.
//!                  If the specified version is not supported by this implementation,
//!                  an error will be returned (LWAPI_INCOMPATIBLE_STRUCT_VERSION).
//!
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]     pTopoBrief        The topology for getting the details
//!                                   This must be one of the topology briefs
//!                                   returned from LwAPI_Mosaic_GetSupportedTopoInfo().
//! \param [in,out] pTopoGroup        The topology details matching the brief
//!
//! \retval ::LWAPI_OK                          Details were retrieved successfully.
//! \retval ::LWAPI_NOT_SUPPORTED               Mosaic is not supported with the existing hardware.
//! \retval ::LWAPI_ILWALID_ARGUMENT            One or more argumentss passed in are invalid.
//! \retval ::LWAPI_API_NOT_INTIALIZED          The LwAPI API needs to be initialized first.
//! \retval ::LWAPI_NO_IMPLEMENTATION           This entrypoint not available.
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION The version of the structure passed in is not
//                                              compatible with this entry point.
//! \retval ::LWAPI_ERROR:                      Miscellaneous error oclwrred.
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Mosaic_GetTopoGroup(LW_MOSAIC_TOPO_BRIEF *pTopoBrief, LW_MOSAIC_TOPO_GROUP *pTopoGroup);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_GetOverlapLimits
//
//! DESCRIPTION:     This API returns the X and Y overlap limits required if
//!                  the given Mosaic topology and display settings are to be used.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]   pTopoBrief          The topology for getting limits
//!                                   This must be one of the topo briefs
//!                                   returned from LwAPI_Mosaic_GetSupportedTopoInfo().
//! \param [in]   pDisplaySetting     The display settings for getting the limits.
//!                                   This must be one of the settings
//!                                   returned from LwAPI_Mosaic_GetSupportedTopoInfo().
//! \param [out]  pMinOverlapX        X overlap minimum
//! \param [out]  pMaxOverlapX        X overlap maximum
//! \param [out]  pMinOverlapY        Y overlap minimum
//! \param [out]  pMaxOverlapY        Y overlap maximum
//!
//! \retval ::LWAPI_OK                          Details were retrieved successfully.
//! \retval ::LWAPI_NOT_SUPPORTED               Mosaic is not supported with the existing hardware.
//! \retval ::LWAPI_ILWALID_ARGUMENT            One or more argumentss passed in are invalid.
//! \retval ::LWAPI_API_NOT_INTIALIZED          The LwAPI API needs to be initialized first.
//! \retval ::LWAPI_NO_IMPLEMENTATION           This entrypoint not available.
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION The version of the structure passed in is not
//!                                             compatible with this entry point.
//! \retval ::LWAPI_ERROR                       Miscellaneous error oclwrred.
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Mosaic_GetOverlapLimits(LW_MOSAIC_TOPO_BRIEF *pTopoBrief, LW_MOSAIC_DISPLAY_SETTING *pDisplaySetting, LwS32 *pMinOverlapX, LwS32 *pMaxOverlapX, LwS32 *pMinOverlapY, LwS32 *pMaxOverlapY);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_SetLwrrentTopo
//
//! DESCRIPTION:     This API sets the Mosaic topology and performs a mode switch 
//!                  using the given display settings.
//!
//!                  If LWAPI_OK is returned, the current Mosaic topology was set
//!                  correctly.  Any other status returned means the
//!                  topology was not set, and remains what it was before this
//!                  function was called.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]     pTopoBrief        The topology to set. This must be one of the topologies returned from
//!                                   LwAPI_Mosaic_GetSupportedTopoInfo(), and it must have an isPossible value of 1.
//! \param [in]     pDisplaySetting   The per display settings to be used in the Mosaic mode. This must be one of the
//!                                   settings returned from LwAPI_Mosaic_GetSupportedTopoInfo().
//! \param [in]     overlapX          The pixel overlap to use between horizontal displays (use positive a number for
//!                                   overlap, or a negative number to create a gap.) If the overlap is out of bounds
//!                                   for what is possible given the topo and display setting, the overlap will be clamped.
//! \param [in]     overlapY          The pixel overlap to use between vertical displays (use positive a number for
//!                                   overlap, or a negative number to create a gap.) If the overlap is out of bounds for
//!                                   what is possible given the topo and display setting, the overlap will be clamped.
//! \param [in]     enable            If 1, the topology being set will also be enabled, meaning that the mode set will
//!                                   occur.  \n
//!                                   If 0, you don't want to be in Mosaic mode right now, but want to set the current
//!                                   Mosaic topology so you can enable it later with LwAPI_Mosaic_EnableLwrrentTopo().
//!
//! \retval  ::LWAPI_OK                          The Mosaic topology was set.
//! \retval  ::LWAPI_NOT_SUPPORTED               Mosaic is not supported with the existing hardware.
//! \retval  ::LWAPI_ILWALID_ARGUMENT            One or more argumentss passed in are invalid.
//! \retval  ::LWAPI_TOPO_NOT_POSSIBLE           The topology passed in is not lwrrently possible.
//! \retval  ::LWAPI_API_NOT_INTIALIZED          The LwAPI API needs to be initialized first.
//! \retval  ::LWAPI_NO_IMPLEMENTATION           This entrypoint not available.
//! \retval  ::LWAPI_INCOMPATIBLE_STRUCT_VERSION The version of the structure passed in is not
//!                                              compatible with this entrypoint.
//! \retval  ::LWAPI_MODE_CHANGE_FAILED          There was an error changing the display mode.
//! \retval  ::LWAPI_ERROR                       Miscellaneous error oclwrred.
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Mosaic_SetLwrrentTopo(LW_MOSAIC_TOPO_BRIEF *pTopoBrief, LW_MOSAIC_DISPLAY_SETTING *pDisplaySetting, LwS32 overlapX, LwS32 overlapY, LwU32 enable);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_GetLwrrentTopo
//
//! DESCRIPTION:     This API returns information for the current Mosaic topology.
//!                  This includes topology, display settings, and overlap values.
//!
//!                  You can call LwAPI_Mosaic_GetTopoGroup() with the topology
//!                  if you require more information.
//!
//!                  If there isn't a current topology, then pTopoBrief->topo will
//!                  be LW_MOSAIC_TOPO_NONE.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [out]     pTopoBrief       The current Mosaic topology
//! \param [out]     pDisplaySetting  The current per-display settings
//! \param [out]     pOverlapX        The pixel overlap between horizontal displays
//! \param [out]     pOverlapY        The pixel overlap between vertical displays
//!
//! \retval ::LWAPI_OK                          Success getting current info.
//! \retval ::LWAPI_NOT_SUPPORTED               Mosaic is not supported with the existing hardware.
//! \retval ::LWAPI_ILWALID_ARGUMENT            One or more argumentss passed in are invalid.
//! \retval ::LWAPI_API_NOT_INTIALIZED          The LwAPI API needs to be initialized first.
//! \retval ::LWAPI_NO_IMPLEMENTATION           This entry point not available.
//! \retval ::LWAPI_ERROR                       Miscellaneous error oclwrred.
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Mosaic_GetLwrrentTopo(LW_MOSAIC_TOPO_BRIEF *pTopoBrief, LW_MOSAIC_DISPLAY_SETTING *pDisplaySetting, LwS32 *pOverlapX, LwS32 *pOverlapY);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_EnableLwrrentTopo
//
//! DESCRIPTION:     This API enables or disables the current Mosaic topology
//!                  based on the setting of the incoming 'enable' parameter.
//!
//!                  An "enable" setting enables the current (previously set) Mosaic topology.
//!                  Note that when the current Mosaic topology is retrieved, it must have an isPossible value of 1 or
//!                  an error will occur.
//!
//!                  A "disable" setting disables the current Mosaic topology.
//!                  The topology information will persist, even across reboots.
//!                  To re-enable the Mosaic topology, call this function
//!                  again with the enable parameter set to 1.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]   enable               1 to enable the current Mosaic topo, 0 to disable it.
//!
//! \retval ::LWAPI_OK                 The Mosaic topo was enabled/disabled.
//! \retval ::LWAPI_NOT_SUPPORTED      Mosaic is not supported with the existing hardware.
//! \retval ::LWAPI_ILWALID_ARGUMENT   One or more arguments passed in are invalid.
//! \retval ::LWAPI_TOPO_NOT_POSSIBLE  The current topology is not lwrrently possible.
//! \retval ::LWAPI_MODE_CHANGE_FAILED There was an error changing the display mode.
//! \retval ::LWAPI_ERROR:             Miscellaneous error oclwrred.
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Mosaic_EnableLwrrentTopo(LwU32 enable);

//! \ingroup mosaicapi
//! @{
typedef struct
{
    LwU32                       displayId;              //!< DisplayID of the display
    LwS32                       overlapX;               //!< (+overlap, -gap)
    LwS32                       overlapY;               //!< (+overlap, -gap)
    LW_ROTATE                   rotation;               //!< Rotation of display
    LwU32                       cloneGroup;             //!< Reserved, must be 0
} LW_MOSAIC_GRID_TOPO_DISPLAY;

typedef struct
{
    LwU32                       version;                            //!< Version of this structure
    LwU32                       rows;                               //!< Number of rows
    LwU32                       columns;                            //!< Number of columns
    LwU32                       displayCount;                       //!< Number of display details
    LwU32                       applyWithBezelCorrect : 1;          //!< When enabling and doing the modeset, do we switch to the bezel-corrected resolution
    LwU32                       immersiveGaming : 1;                //!< Enable as immersive gaming instead of Mosaic SLI (for Lwdqro-boards only)
    LwU32                       baseMosaic : 1;                     //!< Enable as Base Mosaic (Panoramic) instead of Mosaic SLI (for LWS and Lwdqro-boards only)
    LwU32                       driverReloadAllowed : 1;            //!< If necessary, reloading the driver is permitted (for Vista and above only). Will not be persisted. Value undefined on get.
    LwU32                       acceleratePrimaryDisplay : 1;       //!< Enable SLI acceleration on the primary display while in single-wide mode (For Immersive Gaming only). Will not be persisted. Value undefined on get.
    LwU32                       reserved : 27;                      //!< Reserved, must be 0
    LW_MOSAIC_GRID_TOPO_DISPLAY displays[LW_MOSAIC_MAX_DISPLAYS];   //!< Displays are done as [(row * columns) + column]
    LW_MOSAIC_DISPLAY_SETTING   displaySettings;                    //!< Display settings
} LW_MOSAIC_GRID_TOPO_V1;

//! Macro for constructing the version field of ::LW_MOSAIC_GRID_TOPO_V1
#define LW_MOSAIC_GRID_TOPO_VER1         MAKE_LWAPI_VERSION(LW_MOSAIC_GRID_TOPO_V1,1)

typedef struct
{
    LwU32                       version;                            //!< Version of this structure
    LwU32                       rows;                               //!< Number of rows
    LwU32                       columns;                            //!< Number of columns
    LwU32                       displayCount;                       //!< Number of display details
    LwU32                       applyWithBezelCorrect : 1;          //!< When enabling and doing the modeset, do we switch to the bezel-corrected resolution
    LwU32                       immersiveGaming : 1;                //!< Enable as immersive gaming instead of Mosaic SLI (for Lwdqro-boards only)
    LwU32                       baseMosaic : 1;                     //!< Enable as Base Mosaic (Panoramic) instead of Mosaic SLI (for LWS and Lwdqro-boards only)
    LwU32                       driverReloadAllowed : 1;            //!< If necessary, reloading the driver is permitted (for Vista and above only). Will not be persisted. Value undefined on get.
    LwU32                       acceleratePrimaryDisplay : 1;       //!< Enable SLI acceleration on the primary display while in single-wide mode (For Immersive Gaming only). Will not be persisted. Value undefined on get.
    LwU32                       reserved : 27;                      //!< Reserved, must be 0
    LW_MOSAIC_GRID_TOPO_DISPLAY displays[LW_MOSAIC_MAX_DISPLAYS];   //!< Displays are done as [(row * columns) + column]
    LW_MOSAIC_DISPLAY_SETTING   displaySettings;                    //!< Display settings
    LwU32                       virtualDisplayId;                   //!< Reserved for future use
} LW_MOSAIC_GRID_TOPO_V2;

typedef LW_MOSAIC_GRID_TOPO_V2           LW_MOSAIC_GRID_TOPO;

//! Macro for constructing the version field of ::LW_MOSAIC_GRID_TOPO_V2
#define LW_MOSAIC_GRID_TOPO_VER2         MAKE_LWAPI_VERSION(LW_MOSAIC_GRID_TOPO_V2,2)

//! Macro for constructing the version field of ::LW_MOSAIC_GRID_TOPO
#define LW_MOSAIC_GRID_TOPO_VER          LW_MOSAIC_GRID_TOPO_VER2

#ifndef LW_MOSAIC_GRID_TOPO_VER

typedef LW_MOSAIC_GRID_TOPO_V1           LW_MOSAIC_GRID_TOPO;

//! Macro for constructing the version field of ::LW_MOSAIC_GRID_TOPO
#define LW_MOSAIC_GRID_TOPO_VER          LW_MOSAIC_GRID_TOPO_VER1

#endif

//! @}


//! \ingroup mosaicapi
//! @{
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_SetGridTopology
//
//! \fn LwAPI_Mosaic_SetGridTopology(LW_MOSAIC_GRID_TOPO *pGridTopology, LwU32 enable)
//! DESCRIPTION:     This API sets a grid-based Mosaic topology and does a 
//!                  mode change using the given display settings.
//!
//!                  If LWAPI_OK is returned, the requested Mosaic topo was set
//!                  correctly.  Any other status returned means the
//!                  topo was not set, and remains what it was before this
//!                  function was called. It is possible for this API to return
//!                  success, but the displays enabled have an issue, leading
//!                  to a black screen.
//!
//!                  Note: Not all exposed features are available on all 
//!                  platforms.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     pGridTopology     The topology details to set.
//! \param [in]     enable            If 1, the topo being set will also be enabled,
//!                                   meaning that the mode set will occur.  
//!                                   Passing a 0 means you don't want to be in
//!                                   Mosaic mode right now, but want to set the current
//!                                   Mosaic topo so you can enable it later with
//!                                   LwAPI_Mosaic_EnableLwrrentTopo().
//!
//! \return    This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//! \retval ::LWAPI_NO_ACTIVE_SLI_TOPOLOGY        GPUs are not lwrrently in SLI
//! \retval ::LWAPI_ILWALID_COMBINATION           The current SLI set does not support Mosaic SLI or Immersive Gaming
//! \retval ::LWAPI_SLI_RENDERING_MODE_NOTALLOWED The current display configuration cannot be used for the requested 
//!                                               mosaic topology (for instance, having the displays only in the center 
//!                                               of the SLI topology), or does not support center display
//!                                               acceleration
//
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Mosaic_SetGridTopology(LW_MOSAIC_GRID_TOPO *pGridTopology, LwU32 enable);

//! @}

//! \ingroup mosaicapi
//! @{
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_GetMosaicCapabilities
//
//! \fn LwAPI_Mosaic_GetMosaicCapabilities(LW_GPU_VALID_GPU_TOPOLOGIES *pSliTopology, LW_MOSAIC_CAPS *pCaps) 
//! DESCRIPTION:     This API returns a set of capabilities based on a provided
//!                  SLI topology. The pSliTopology is the same parameter as
//!                  used for LwAPI_SetGpuTopologies. If more than one SLI 
//!                  topology is marked to be active, only the first active 
//!                  topology will be validated.
//!                  At least one topology in pSliTopology must have the 
//!                  LW_GPU_TOPOLOGY_ACTIVE flag set. This does not require the
//!                  topology to be lwrrently active, but marks which topology
//!                  will have the capabilities retrieved for.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]       pSliTopology    SLI topology for capabilties query
//! \param [out]      pCaps           Capabilities for Mosaic SLI
//!
//! \retval ::LWAPI_OK                          Capabilities have been returned.
//! \retval ::LWAPI_ILWALID_ARGUMENT            One or more argumenets passed in are invalid.
//! \retval ::LWAPI_API_NOT_INTIALIZED          The LwAPI API needs to be initialized first.
//! \retval ::LWAPI_NO_ACTIVE_SLI_TOPOLOGY      No topology had the ::LW_GPU_TOPOLOGY_ACTIVE flag marked.
//! \retval ::LWAPI_NO_IMPLEMENTATION           This entrypoint is not available.
//! \retval ::LWAPI_ERROR                       Miscellaneous error oclwrred.
//
///////////////////////////////////////////////////////////////////////////////

//! See LwAPI_Mosaic_GetMosaicCapabilities{}.
typedef struct
{
    LwU32  version;                          //!< Must be set to ::LW_MOSAIC_CAPS_VER.
    LwU32  bSupportsImmersiveGaming : 1;     //!< These GPUs could enter immersive gaming if proper displays are attached.
    LwU32  bSupportsMosaicSli : 1;           //!< Supports QuadroPlex Mosaic SLI.
    LwU32  bSupportsGlobalRotation : 1;      //!< All displays must share rotation.
    LwU32  bSupportsPerDisplayRotation : 1;  //!< Each display may have a different rotation.
    LwU32  bSupportsPerDisplaySettings : 1;  //!< Each display may have a different resolution.
    LwU32  bSupportsOverlap : 1;             //!< Overlap is supported (+overlap).
    LwU32  bSupportsGaps : 1;                //!< Gap is supported (-overlap).
    LwU32  bSupportsUnevenGapping : 1;       //!< Allows for each display to have different overlap values.
    LwU32  bSupportsBaseMosaic : 1;          //!< These GPUs could enter base Mosaic if proper displays are attached
    LwU32  reserved : 23;                    //!< Reserved, must be 0
} LW_MOSAIC_CAPS_V1;

//! See LwAPI_Mosaic_GetMosaicCapabilities{}.
typedef struct
{
    LwU32  version;                          //!< Must be set to ::LW_MOSAIC_CAPS_VER.
    LwU32  bSupportsImmersiveGaming : 1;     //!< These GPUs could enter immersive gaming if proper displays are attached.
    LwU32  bSupportsMosaic : 1;              //!< Supports Mosaic.
    LwU32  bSupportsGlobalRotation : 1;      //!< All displays must share rotation.
    LwU32  bSupportsPerDisplayRotation : 1;  //!< Each display may have a different rotation.
    LwU32  bSupportsPerDisplaySettings : 1;  //!< Each display may have a different resolution.
    LwU32  bSupportsOverlap : 1;             //!< Overlap is supported (+overlap).
    LwU32  bSupportsGaps : 1;                //!< Gap is supported (-overlap).
    LwU32  bSupportsUnevenGapping : 1;       //!< Allows for each display to have different overlap values.
    LwU32  bSupportsPassiveStereo : 1;       //!< Allows passive stereo using clone groups.
    LwU32  reserved : 23;                    //!< Reserved, must be 0
} LW_MOSAIC_CAPS_V2;

typedef LW_MOSAIC_CAPS_V2 LW_MOSAIC_CAPS;

//! Macro for constructing the version field of LW_MOSAIC_CAPS
#define LW_MOSAIC_CAPS_VER1                 MAKE_LWAPI_VERSION(LW_MOSAIC_CAPS_V1,1)
#define LW_MOSAIC_CAPS_VER2                 MAKE_LWAPI_VERSION(LW_MOSAIC_CAPS_V2,2)
#define LW_MOSAIC_CAPS_VER                  LW_MOSAIC_CAPS_VER2

LWAPI_INTERFACE LwAPI_Mosaic_GetMosaicCapabilities(LW_GPU_VALID_GPU_TOPOLOGIES *pSliTopology, LW_MOSAIC_CAPS *pCaps);
//! @}

//! \ingroup mosaicapi
//! @{
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_GetMosaicCapabilitiesEx
//
//! \fn LwAPI_Mosaic_GetMosaicCapabilitiesEx(LW_GPU_TOPOLOGY *pTopology, LW_MOSAIC_CAPS *pCaps)
//! DESCRIPTION:     This API returns a set of capabilities based on a provided
//!                  SLI topology. If pTopology only contains a single GPU,
//!                  then the capabilities of that particular GPU are returned.
//!                  This does not require the topology to be lwrrently active.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! since Release R290
//!
//! \param [in]       pTopology       GPU Topology for querying capabilities
//! \param [out]      pCaps           Capabilities for Mosaic
//!
//! \return    This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with
//!            specific meaning for this API, they are listed below.
//
///////////////////////////////////////////////////////////////////////////////

LWAPI_INTERFACE LwAPI_Mosaic_GetMosaicCapabilitiesEx(LW_GPU_TOPOLOGY *pTopology, LW_MOSAIC_CAPS *pCaps);
//! @}

//! SUPPORTED OS:  Windows XP and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_GetSingleGpuMosaicCaps
//
//! DESCRIPTION:     This API returns the set of capabilities for a
//!                  physical GPU when used by itself (not as part of an SLI
//!                  topology).
//!
//!                  If hPysGpu is NULL, then pCaps will specify whether SLI
//!                  Mosaic, Surround Gaming, and Base Mosaic are supported on any GPU or SLI
//!                  topology.
//!
//! \param [in]      hPhysGpu         Physical GPU for capabilities query
//! \param [out]     pCaps            Capabilities for Mosaic SLI
//!
//! \retval ::LWAPI_OK:                          Capabilties have been returned.
//! \retval ::LWAPI_ILWALID_ARGUMENT:            One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INTIALIZED:          The LwAPI API needs to be initialized first
//! \retval ::LWAPI_NO_IMPLEMENTATION:           This entrypoint not available
//! \retval ::LWAPI_ERROR:                       Miscellaneous error oclwrred
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Mosaic_GetSingleGpuMosaicCaps(LwPhysicalGpuHandle hPhysGpu, LW_MOSAIC_CAPS *pCaps);







//! \ingroup mosaicapi
//! @{
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_GetDisplayCapabilities
//
//! \fn LwAPI_Mosaic_GetDisplayCapabilities(LW_MOSAIC_DISPLAY_CAPS *pDisplayCaps)
//! DESCRIPTION:     This API returns a set of capabilities based on a provided
//!                  displays. The caller uses this function to determine if a
//!                  given set of displays, regardless of SLI topology, would
//!                  support Mosaic SLI / Immersive Gaming. This API can also
//!                  assist in identifying if a display would be compatible, 
//!                  but is lwrrently plugged into the wrong connector of a GPU.
//! 
//!                  Problem flags are SLI-agnostic. This API will not verify
//!                  that all displays are on the same SLI topology.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in,out]      pDisplayCaps   List of display capabilities and 
//!                                     problem codes, as well as list of
//!                                     valid display settings shared by the
//!                                     selected monitors.
//!
//! \retval ::LWAPI_OK                          The display capabilities have been returned.
//! \retval ::LWAPI_ILWALID_ARGUMENT            One or more arguments passed in are invalid.
//! \retval ::LWAPI_API_NOT_INTIALIZED          The LwAPI API needs to be initialized first.
//! \retval ::LWAPI_NO_IMPLEMENTATION           This entrypoint is not available.
//! \retval ::LWAPI_ERROR                       Miscellaneous error oclwrred.
//
///////////////////////////////////////////////////////////////////////////////

#define LW_MOSAIC_DISPLAYCAPS_PROBLEM_DISPLAY_ON_ILWALID_GPU        LW_BIT(0)
#define LW_MOSAIC_DISPLAYCAPS_PROBLEM_DISPLAY_ON_WRONG_CONNECTOR    LW_BIT(1)
#define LW_MOSAIC_DISPLAYCAPS_PROBLEM_NO_COMMON_TIMINGS             LW_BIT(2)
#define LW_MOSAIC_DISPLAYCAPS_PROBLEM_NO_EDID_AVAILABLE             LW_BIT(3)
#define LW_MOSAIC_DISPLAYCAPS_PROBLEM_MISMATCHED_OUTPUT_TYPE        LW_BIT(4)
#define LW_MOSAIC_DISPLAYCAPS_PROBLEM_NO_DISPLAY_CONNECTED          LW_BIT(5)
#define LW_MOSAIC_DISPLAYCAPS_PROBLEM_NO_GPU_TOPOLOGY               LW_BIT(6)
#define LW_MOSAIC_DISPLAYCAPS_PROBLEM_NOT_SUPPORTED                 LW_BIT(7)
#define LW_MOSAIC_DISPLAYCAPS_PROBLEM_NO_SLI_BRIDGE                 LW_BIT(8)
#define LW_MOSAIC_DISPLAYCAPS_PROBLEM_ECC_ENABLED                   LW_BIT(9)
#define LW_MOSAIC_DISPLAYCAPS_PROBLEM_GPU_TOPOLOGY_NOT_SUPPORTED    LW_BIT(10)

//! See ::LW_MOSAIC_DISPLAY_CAPS.
typedef struct
{
    LwU32  displayId;                       //!< (IN) DisplayID of display
    LwU32  problemFlags;                    //!< (OUT) Any problem flags found (LW_MOSAIC_DISPLAYCAPS_PROBLEM_*)
    LwU32  supportsRotation : 1;            //!< (OUT) This display can be rotated
    LwU32  reserved : 31;                   //!< (OUT) reserved
} LW_MOSAIC_DISPLAY_DETAILS;

//! See LwAPI_Mosaic_GetDisplayCapabilities().
typedef struct
{
    LwU32  version;                         //!< (IN) Must be LW_MOSAIC_DISPLAY_CAPS_VER
    LwU32  displayCount;                    //!< (IN) Number of valid displays in displays array
    LW_MOSAIC_DISPLAY_DETAILS   displays[LWAPI_MAX_DISPLAYS];   //!< (IN/OUT) Array of individual displays, the first 
                                                                //!< display will be used to validate the remaining displays 
                                                                //!< for EDID matching. There is other order dependency.
    LwU32  displaySettingsCount;            //!< (OUT) Number of valid display settings found
    LW_MOSAIC_DISPLAY_SETTING   displaySettings[LW_MOSAIC_DISPLAY_SETTINGS_MAX];    //!< (OUT) List of common timings
    LwU32  problemFlags;                    //!< (OUT) Any problem flags found (LW_MOSAIC_DISPLAYCAPS_PROBLEM_*)
} LW_MOSAIC_DISPLAY_CAPS_V1;


#define LW_MOSAIC_DISPLAY_CAPS_MAX      1600

//! See LwAPI_Mosaic_GetDisplayCapabilities().
typedef struct
{
    LwU32  version;                         //!< (IN) Must be LW_MOSAIC_DISPLAY_CAPS_VER
    LwU32  displayCount;                    //!< (IN) Number of valid displays in displays array
    LW_MOSAIC_DISPLAY_DETAILS   displays[LWAPI_MAX_DISPLAYS];   //!< (IN/OUT) Array of individual displays, the first
                                                                //!< display will be used to validate the remaining displays
                                                                //!< for EDID matching. There is other order dependency.
    LwU32  displaySettingsCount;            //!< (OUT) Number of valid display settings found
    LW_MOSAIC_DISPLAY_SETTING   displaySettings[LW_MOSAIC_DISPLAY_CAPS_MAX];    // (OUT) List of common timings
    LwU32  problemFlags;                    //!< (OUT) Any problem flags found (LW_MOSAIC_DISPLAYCAPS_PROBLEM_*)
} LW_MOSAIC_DISPLAY_CAPS_V2;


typedef LW_MOSAIC_DISPLAY_CAPS_V2           LW_MOSAIC_DISPLAY_CAPS;

//! Macro for constructing the version field of ::LW_MOSAIC_DISPLAY_CAPS_V1
#define LW_MOSAIC_DISPLAY_CAPS_VER1         MAKE_LWAPI_VERSION(LW_MOSAIC_DISPLAY_CAPS_V1,1)

//! Macro for constructing the version field of ::LW_MOSAIC_DISPLAY_CAPS_V2
#define LW_MOSAIC_DISPLAY_CAPS_VER2         MAKE_LWAPI_VERSION(LW_MOSAIC_DISPLAY_CAPS_V2,2)

//! Macro for constructing the version field of ::LW_MOSAIC_DISPLAY_CAPS
#define LW_MOSAIC_DISPLAY_CAPS_VER          LW_MOSAIC_DISPLAY_CAPS_VER2


LWAPI_INTERFACE LwAPI_Mosaic_GetDisplayCapabilities(LW_MOSAIC_DISPLAY_CAPS *pDisplayCaps);

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_GetGridOverlapLimits
//
//! \fn LwAPI_Mosaic_GetGridOverlapLimits(LW_MOSAIC_GRID_TOPO *pGridTopology, LW_MOSAIC_OVERLAP_LIMITS *pOverlapLimits)
//! DESCRIPTION:     This API returns the X and Y overlap limits required if
//!                  the given Mosaic topology and display settings are to be used.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      pGridTopology       The topology to get limits for.
//! \param [out]     pOverlapLimits      The total and per-display overlap limits for the grid.
//!
//! \retval ::LWAPI_OK:                          Details were retrieved successfully
//! \retval ::LWAPI_NOT_SUPPORTED:               Mosaic is not supported with the existing hardware
//! \retval ::LWAPI_ILWALID_ARGUMENT:            One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INTIALIZED:          The LwAPI API needs to be initialized first
//! \retval ::LWAPI_NO_IMPLEMENTATION:           This entrypoint not available
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION: The version of the structure passed in is not
//!                                                     compatible with this entrypoint
//! \retval ::LWAPI_ERROR:                       Miscellaneous error oclwrred
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup mosaicapi
typedef struct
{
    LwU32 version;
    LwS32 minDispX;  //!< The minimum X overlap for each display.
    LwS32 maxDispX;  //!< The maximum X overlap for each display.
    LwS32 minDispY;  //!< The minimum Y overlap for each display.
    LwS32 maxDispY;  //!< The maximum Y overlap for each display.
    LwS32 minTotalX; //!< The minimum total X overlap for the entire grid.
    LwS32 maxTotalX; //!< The maximum total X overlap for the entire grid.
    LwS32 minTotalY; //!< The minimum total Y overlap for the entire grid.
    LwS32 maxTotalY; //!< The maximum total Y overlap for the entire grid.
} LW_MOSAIC_OVERLAP_LIMITS;

//! \ingroup mosaicapi
#define LW_MOSAIC_OVERLAP_LIMITS_VER         MAKE_LWAPI_VERSION(LW_MOSAIC_OVERLAP_LIMITS,1)

//! \ingroup mosaicapi
LWAPI_INTERFACE LwAPI_Mosaic_GetGridOverlapLimits(LW_MOSAIC_GRID_TOPO *pGridTopology, LW_MOSAIC_OVERLAP_LIMITS *pOverlapLimits);








//! \ingroup mosaicapi
//! @{
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_EnumGridTopologies
//
//! \fn LwAPI_Mosaic_EnumGridTopologies(LwU32 index, LwU32 flags, LW_MOSAIC_GRID_TOPO *pGridTopology, LwU8* bEnabled)
//! DESCRIPTION:     This API retrieves the current grid topology information
//!                  for Mosaic SLI.
//!
//!                  If there has been no existing call to set a topology
//!                  (either enabled or disable), this call will return 
//!                  ::LWAPI_DATA_NOT_FOUND. If the existing data is no longer
//!                  valid due to display connectors being moved, or GPUs
//!                  being moved, ::LWAPI_DATA_NOT_FOUND will also be returned.
//!                  This API does not validate whether SLI is lwrrently 
//!                  enabled.
//!
//!                  When enumerating all current grid topologies, ::LWAPI_DATA_NOT_FOUND will
//!                  be returned when there are no more topologies.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     index               A zero-based index to enumerate
//!                                     multiple applied grid topologies.
//! \param [in]     flags               This field controls which data is returned.
//!                                          By default, all known topologies are returned.
//!                                          A known topology is either an active topology
//!                                          or a topology which has been disabled and not
//!                                          included in another topology. Unless specified,
//!                                          topology validity will be applied during enum,
//!                                          and topologies which are no longer valid will
//!                                          not be returned (ex: a monitor was disconnected).
//!                                          Only topologies which have been enabled in the 
//!                                          past will be returned, this API will not 
//!                                          enumerate all possible topologies. To determine 
//!                                          all possible topologies, manually create each 
//!                                          possible topology and validate each using 
//!                                          LwAPI_Mosaic_GetDisplayCapabilities. 
//!
//! \param [in,out] pGridTopology       The topology details of the current
//!                                     topology. On input, version must be
//!                                     properly set, all other fields are ignored.
//! \param [out] bEnabled            (May pass in NULL to ignore)
//!                                     -1 if Mosaic is enabled, 
//!                                     -0 if Mosaic is lwrrently disabled.
//!
//! \retval ::LWAPI_OK                          Mosaic topology was set.
//! \retval ::LWAPI_NOT_SUPPORTED               Mosaic is not supported with the existing hardware.
//! \retval ::LWAPI_ILWALID_ARGUMENT            One or more arguments passed in are invalid.
//! \retval ::LWAPI_API_NOT_INTIALIZED          The LwAPI API needs to be initialized first.
//! \retval ::LWAPI_NO_IMPLEMENTATION           This entrypoint is not available.
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION The version of the structure passed in is not
//!                                             compatible with this entrypoint.
//! \retval ::LWAPI_DATA_NOT_FOUND              There was no existing valid topology information.
//! \retval ::LWAPI_ERROR                       Miscellaneous error oclwrred.
//
///////////////////////////////////////////////////////////////////////////////


#define LWAPI_MOSAIC_ENUMGRIDTOPOS_FLAG_ACTIVE_ONLY       LW_BIT(0)
#define LWAPI_MOSAIC_ENUMGRIDTOPOS_FLAG_NO_VALIDATION     LW_BIT(1)

LWAPI_INTERFACE LwAPI_Mosaic_EnumGridTopologies(LwU32 index, LwU32 flags, LW_MOSAIC_GRID_TOPO *pGridTopology, LwU8* bEnabled);

//! @}



//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_GetDisplayViewportsByResolution
//
//! DESCRIPTION:     This API returns the viewports that would be applied on
//!                  the requested display.
//!
//! \param [in]      displayId       Display ID of a single display in the active
//!                                  mosaic topology to query.
//! \param [in]      srcWidth        Width of full display topology. If both
//!                                  width and height are 0, the current
//!                                  resolution is used.
//! \param [in]      srcHeight       Height of full display topology. If both
//!                                  width and height are 0, the current
//!                                  resolution is used.
//! \param [out]     viewports       Array of LW_RECT viewports which represent
//!                                  the displays as identified in
//!                                  LwAPI_Mosaic_EnumGridTopologies. If the
//!                                  requested resolution is a single-wide
//!                                  resolution, only viewports[0] will
//!                                  contain the viewport details, regardless
//!                                  of which display is driving the display.
//! \param [out]     bezelCorrected  Returns 1 if the requested resolution is
//!                                  bezel corrected. May be NULL.
//!
//! \retval ::LWAPI_OK                          Capabilties have been returned.
//! \retval ::LWAPI_ILWALID_ARGUMENT            One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INTIALIZED          The LwAPI API needs to be initialized first
//! \retval ::LWAPI_MOSAIC_NOT_ACTIVE           The display does not belong to an active Mosaic Topology
//! \retval ::LWAPI_NO_IMPLEMENTATION           This entrypoint not available
//! \retval ::LWAPI_ERROR                       Miscellaneous error oclwrred
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Mosaic_GetDisplayViewportsByResolution(LwU32 displayId, LwU32 srcWidth, LwU32 srcHeight, LW_RECT viewports[LW_MOSAIC_MAX_DISPLAYS], LwU8* bezelCorrected);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_GetBezelPeeking
//
//! DESCRIPTION:     This API returns the current state of bezel peeking. Any
//!                  displayId of the current topology can be passed.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      displayId        Display ID of one of the displays in 
//!                                   the Mosaic topology.
//! \param [out]     pActive          Returns 1 if the bezel peeking is 
//!                                   active, otherwise, returns 0.
//!
//! \retval ::LWAPI_OK:                          Capabilities have been returned.
//! \retval ::LWAPI_ILWALID_ARGUMENT:            One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INTIALIZED:          The LwAPI API needs to be initialized first
//! \retval ::LWAPI_MOSAIC_NOT_ACTIVE:           The display does not belong to an active Mosaic Topology
//! \retval ::LWAPI_NO_IMPLEMENTATION:           This entrypoint not available
//! \retval ::LWAPI_ERROR:                       Miscellaneous error oclwrred
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Mosaic_GetBezelPeeking(LwU32 displayId, LwU8* pActive);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_SetBezelPeeking
//
//! DESCRIPTION:     This API sets the current state of bezel peeking. Any
//!                  displayId of the current topology can be passed.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      displayId      Display ID of one of the displays in 
//!                                 the Mosaic topology.
//! \param [in]      active         Set to 1 to enable bezel peeking.
//!                                 Set to 0 to disable bezel peeking.
//!
//! \retval ::LWAPI_OK:                          Capabilties have been returned.
//! \retval ::LWAPI_ILWALID_ARGUMENT:            One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INTIALIZED:          The LwAPI API needs to be initialized first
//! \retval ::LWAPI_MOSAIC_NOT_ACTIVE:           The display does not belong to an active Mosaic Topology
//! \retval ::LWAPI_NO_IMPLEMENTATION:           This entrypoint not available
//! \retval ::LWAPI_ERROR:                       Miscellaneous error oclwrred
//!
//! \ingroup mosaciapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Mosaic_SetBezelPeeking(LwU32 displayId, LwU8 active);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_GetResolutionPruning
//
//! \fn LwAPI_Mosaic_GetResolutionPruning(LwU32 displayId, LW_MOSAIC_RESOLUTION_PRUNING *resList)
//! DESCRIPTION:     This API returns the full list of mosaic base resolutions
//!                  and whether they are visible as mosaic with and without
//!                  bezel correction.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      displayId          DisplayID of a display in the mosaic
//!                                     topology to retrieve the pruning list
//!                                     from.
//! \param [in,out]  resList            On input, only version is valid. On
//!                                     success, this structure will be filled
//!                                     with the details of all the 
//!                                     single-wide resolutions and whether
//!                                     they expose a mosaic resolution or a
//!                                     bezel-corrected mosaic resolution. 
//! 
//! retval ::LWAPI_OK:                          Capabilties have been returned.
//! retval ::LWAPI_ILWALID_ARGUMENT:            One or more args passed in are invalid.
//! retval ::LWAPI_API_NOT_INTIALIZED:          The LwAPI API needs to be initialized first
//! retval ::LWAPI_NO_IMPLEMENTATION:           This entrypoint not available
//! retval ::LWAPI_ERROR:                       Miscellaneous error oclwrred
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup mosaicapi
#define LW_MOSAIC_RESOLUTION_PRUNING_MAX_RESOLUTIONS     100

//! \ingroup mosaicapi
typedef struct
{
    LwU32               version;                //!< Must be LW_MOSAIC_RESOLUTION_PRUNING_VER
    LwU32               count;                  //!< IN - count of calid allowedResolutions[] entries
    LwU32               skipModeEnumeration : 1; //!< IN - Skip re-enumeration of modelist. Only used during LwAPI_Mosaic_SetResolutionPruning.
    LwU32               reserved : 31;           //!< IN - Reserved, must be 0.
    struct
    {
        LwU16           width;
        LwU16           height;
        LwU32           allowMosaicResolution : 1;
        LwU32           allowBezelCorrectedMosaicResolution : 1;
        LwU32           isDefaultResolution : 1;
        LwU32           isLwrrentResolution : 1;        //!< Note, this will only be set if the current resolution is the active mosaic resolution, not a base resolution
        LwU32           reserved : 28;                  //!< Reserved, must be 0
    } resolutionList[LW_MOSAIC_RESOLUTION_PRUNING_MAX_RESOLUTIONS];
} LW_MOSAIC_RESOLUTION_PRUNING;

//! \ingroup mosaicapi
#define LW_MOSAIC_RESOLUTION_PRUNING_VER1       MAKE_LWAPI_VERSION(LW_MOSAIC_RESOLUTION_PRUNING,1)
//! \ingroup mosaicapi
#define LW_MOSAIC_RESOLUTION_PRUNING_VER        LW_MOSAIC_RESOLUTION_PRUNING_VER1

//! \ingroup mosaicapi
LWAPI_INTERFACE LwAPI_Mosaic_GetResolutionPruning(LwU32 displayId, LW_MOSAIC_RESOLUTION_PRUNING *resList);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_SetResolutionPruning
//
//! DESCRIPTION:     This API applies resolution pruning to the driver. This
//!                  list must be in the same order and size as the list 
//!                  returned by LwAPI_Mosaic_GetResolutionPruning(), or an error
//!                  will be returned. You cannot prune the current resolution
//!                  unless Mosaic is lwrrently in single-wide or disabled.
//!
//! NOTE:            If the current active resolution is not enabled, it will
//!                  be enabled automatically.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      displayId      DisplayID of a display in the mosaic
//!                                 topology to retrieve the pruning list
//!                                 from.
//! \param [in]      resList        Details which resolutions should have
//!                                 mosaic resolutions and bezel-corrected
//!                                 mosaic resolutions exported from the
//!                                 display driver. A forced mode 
//!                                 re-enumeration will occur after the 
//!                                 change is applied.
//! 
//! \retval ::LWAPI_OK:                          Capabilities have been returned.
//! \retval ::LWAPI_ILWALID_ARGUMENT:            One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INTIALIZED:          The LwAPI API needs to be initialized first
//! \retval ::LWAPI_NO_IMPLEMENTATION:           This entrypoint not available
//! \retval ::LWAPI_ERROR:                       Miscellaneous error oclwrred
//!
//! \ingroup mosaciapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Mosaic_SetResolutionPruning(LwU32 displayId, LW_MOSAIC_RESOLUTION_PRUNING *resList);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_GetMosaicViewports
//
//! DESCRIPTION:     This API returns the viewport information for a mosaic mode
//!                  passed in by the user.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pGridTopology        A grid topology to callwlate the
//!                                       viewport information. Does not need
//!                                       to be lwrrently active.
//! \param [in]      baseWidth            Width of a single display in the 
//!                                       topology.
//! \param [in]      baseHeight           Height of a single display in the 
//!                                       topology.
//! \param [in]      bezelCorrected       If set to 1, returns the details for
//!                                       bezel corrected. If set to 0, returns
//!                                       the details without bezel correction.
//! \param [out]     totalWidth           May be NULL. If passed, will return
//!                                       the total width of the mosaic.
//! \param [out]     totalHeight          May be NULL. If passed, will return
//!                                       the total height of the mosaic.
//! \param [out]     viewports            Array will be filled in with the
//!                                       individual viewport details for
//!                                       the topology.
//! 
//! \retval ::LWAPI_OK                          Capabilities have been returned.
//! \retval ::LWAPI_ILWALID_ARGUMENT            One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INITIALIZED         The LwAPI API needs to be initialized first
//! \retval ::LWAPI_NO_IMPLEMENTATION           This entrypoint not available
//! \retval ::LWAPI_ERROR                       Miscellaneous error oclwrred
//! \ingroup mosaciapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Mosaic_GetMosaicViewports(LW_MOSAIC_GRID_TOPO *pGridTopology, 
                                                LwU32 baseWidth, 
                                                LwU32 baseHeight, 
                                                LwU8 bezelCorrected, 
                                                LwU32* totalWidth, 
                                                LwU32* totalHeight, 
                                                LW_RECT viewports[LW_MOSAIC_MAX_DISPLAYS]);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_SetDisplayGrids
//
//! DESCRIPTION:     Sets a new display topology, replacing any existing topologies
//!                  that use the same displays.
//!
//!                  This function will look for an SLI configuration that will
//!                  allow the display topology to work.
//!
//!                  To revert to a single display, specify that display as a 1x1
//!                  grid.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]      pGridTopologies    The topology details to set.
//! \param [in]      gridCount          The number of elements in the pGridTopologies array.
//! \param [in]      setTopoFlags       Zero or more of the LWAPI_MOSAIC_SETDISPLAYTOPO_FLAG_*
//!                                     flags.
//!
//!
//! \retval ::LWAPI_OK                          Capabilities have been returned.
//! \retval ::LWAPI_ILWALID_ARGUMENT            One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INTIALIZED          The LwAPI API needs to be initialized first
//! \retval ::LWAPI_NO_IMPLEMENTATION           This entrypoint not available
//! \retval ::LWAPI_NO_ACTIVE_SLI_TOPOLOGY      No matching GPU topologies could be found.
//! \retval ::LWAPI_TOPO_NOT_POSSIBLE           One or more of the display grids are not valid.
//! \retval ::LWAPI_ERROR                       Miscellaneous error oclwrred
//! \ingroup mosaicapi 
///////////////////////////////////////////////////////////////////////////////


//! Do not change the current GPU topology. If the NO_DRIVER_RELOAD bit is not
//! specified, then it may still require a driver reload.
#define LW_MOSAIC_SETDISPLAYTOPO_FLAG_LWRRENT_GPU_TOPOLOGY LW_BIT(0)

//! Do not allow a driver reload. That is, stick with the same master GPU as well as the
//! same SLI configuration.
#define LW_MOSAIC_SETDISPLAYTOPO_FLAG_NO_DRIVER_RELOAD     LW_BIT(1)

//! When choosing a GPU topology, choose the topology with the best performance.
//! Without this flag, it will choose the topology that uses the smallest number
//! of GPU's.
#define LW_MOSAIC_SETDISPLAYTOPO_FLAG_MAXIMIZE_PERFORMANCE LW_BIT(2)

//! Do not return an error if no configuration will work with all of the grids.
#define LW_MOSAIC_SETDISPLAYTOPO_FLAG_ALLOW_ILWALID        LW_BIT(3)

LWAPI_INTERFACE LwAPI_Mosaic_SetDisplayGrids(__in_ecount(gridCount) LW_MOSAIC_GRID_TOPO *pGridTopologies, __in LwU32 gridCount, __in LwU32 setTopoFlags);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_SetDisplayGridsWithSLI
//
//! \fn LwAPI_Mosaic_SetDisplayGridsWithSLI
//! DESCRIPTION:     Sets a new display topology, replacing any existing topologies
//!                  that use the same displays.
//!
//!                  This function will enable the given SLI configuration before
//!                  applying the display topology.
//!
//!                  To revert to a single display, specify that display as a 1x1
//!                  grid.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]      pGpuTopologies     The GPU topologies to set.
//! \param [in]      pGridTopologies    The topology details to set.
//! \param [in]      gridCount          The number of elements in the pGridTopologies array.
//!
//! \return    This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//! \retval ::LWAPI_TOPO_NOT_POSSIBLE           One or more of the display grids are not valid.
//! \ingroup mosaicapi 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Mosaic_SetDisplayGridsWithSLI(__in LW_GPU_VALID_GPU_TOPOLOGIES *pGpuTopologies, __in_ecount(gridCount) LW_MOSAIC_GRID_TOPO *pGridTopologies, __in LwU32 gridCount);


//! \ingroup mosaicapi
typedef struct
{
    LwU32 version;
    LwU32 errorFlags;            //!< (OUT) Any of the LW_MOSAIC_DISPLAYTOPO_ERROR_* flags.
    LwU32 warningFlags;          //!< (OUT) Any of the LW_MOSAIC_DISPLAYTOPO_WARNING_* flags.

    LwU32 displayCount;          //!< (OUT) The number of valid entries in the displays array.
    struct
    {
        LwU32 displayId;             //!< (OUT) The DisplayID of this display.
        LwU32 errorFlags;            //!< (OUT) Any of the LW_MOSAIC_DISPLAYTOPO_ERROR_* flags.
        LwU32 warningFlags;          //!< (OUT) Any of the LW_MOSAIC_DISPLAYTOPO_WARNING_* flags.

        LwU32  supportsRotation : 1; //!< (OUT) This display can be rotated
        LwU32  reserved : 31;        //!< (OUT) reserved
    } displays[LWAPI_MAX_DISPLAYS];
} LW_MOSAIC_DISPLAY_TOPO_STATUS;

//! \ingroup mosaicapi
#define LW_MOSAIC_DISPLAY_TOPO_STATUS_VER         MAKE_LWAPI_VERSION(LW_MOSAIC_DISPLAY_TOPO_STATUS,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_ValidateDisplayGridsWithSLI
//
//! \fn LwAPI_Mosaic_ValidateDisplayGridsWithSLI
//! \code
//! DESCRIPTION:     Determines if a list of grid topologies is valid.
//!
//!                  This function works the same way as LwAPI_Mosaic_ValidateDisplayGrids90, except
//!                  that the caller specifies an SLI configuration, rather than having LwAPI choose
//!                  one.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! PARAMETERS:      pGpuTopologies(IN):  The GPU topologies to use.
//!                  pGridTopologies(IN): The array of grid topologies to verify.
//!                  pTopoStatus(IN/OUT): The array of problems and warnings with each topology.
//!                  gridCount(IN):       The number of elements in the pGridTopologies and
//!                                       pTopoStatus arrays.
//!
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status.
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup mosaicapi
//! Indicates that a display's position in the grid is sub-optimal.
#define LW_MOSAIC_DISPLAYTOPO_WARNING_DISPLAY_POSITION            LW_BIT(0)

//! \ingroup mosaicapi
//! Indicates that SetDisplaySettings would need to perform a driver reload.
#define LW_MOSAIC_DISPLAYTOPO_WARNING_DRIVER_RELOAD_REQUIRED      LW_BIT(1)

//! \ingroup mosaicapi
LWAPI_INTERFACE LwAPI_Mosaic_ValidateDisplayGridsWithSLI(__in LW_GPU_VALID_GPU_TOPOLOGIES *pGpuTopologies,
        __in_ecount(gridCount) LW_MOSAIC_GRID_TOPO *pGridTopologies,
        __inout_ecount_full(gridCount) LW_MOSAIC_DISPLAY_TOPO_STATUS *pTopoStatus,
        __in LwU32 gridCount);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_ValidateDisplayGrids
//
//! DESCRIPTION:     Determines if a list of grid topologies is valid. It will choose an SLI
//!                  configuration in the same way that LwAPI_Mosaic_SetDisplayGrids() does.
//!
//!                  On return, each element in the pTopoStatus array will contain any errors or
//!                  warnings about each grid topology. If any error flags are set, then the topology
//!                  is not valid. If any warning flags are set, then the topology is valid, but
//!                  sub-optimal.
//!
//!                  If the ALLOW_ILWALID flag is set, then it will continue to validate the grids
//!                  even if no SLI configuration will allow all of the grids. In this case, a grid
//!                  grid with no matching GPU topology will have the error
//!                  flags NO_GPU_TOPOLOGY or NOT_SUPPORTED set.
//!
//!                  If the ALLOW_ILWALID flag is not set and no matching SLI configuration is
//!                  found, then it will skip the rest of the validation and return
//!                  LWAPI_NO_ACTIVE_SLI_TOPOLOGY.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]      setTopoFlags       Zero or more of the LWAPI_MOSAIC_SETDISPLAYTOPO_FLAG_*
//!                                     flags.
//! \param [in]      pGridTopologies    The array of grid topologies to verify.
//! \param [in,out]  pTopoStatus        The array of problems and warnings with each grid topology.
//! \param [in]      gridCount          The number of elements in the pGridTopologies and
//!                                     pTopoStatus arrays.
//!
//!
//! \retval ::LWAPI_OK:                          Capabilities have been returned.
//! \retval ::LWAPI_ILWALID_ARGUMENT:            One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INTIALIZED:          The LwAPI API needs to be initialized first
//! \retval ::LWAPI_NO_IMPLEMENTATION:           This entrypoint not available
//! \retval ::LWAPI_NO_ACTIVE_SLI_TOPOLOGY:      No matching GPU topologies could be found.
//! \retval ::LWAPI_ERROR:                       Miscellaneous error oclwrred
//!
//! \ingroup mosaicapi 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Mosaic_ValidateDisplayGrids(__in LwU32 setTopoFlags,
        __in_ecount(gridCount) LW_MOSAIC_GRID_TOPO *pGridTopologies,
        __inout_ecount_full(gridCount) LW_MOSAIC_DISPLAY_TOPO_STATUS *pTopoStatus,
        __in LwU32 gridCount);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_EnumDisplayModes
//
//! DESCRIPTION:     Determines the set of available display modes for a given grid topology.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]      pGridTopology         The grid topology to use.
//! \param [in,out]  pDisplaySettings      A pointer to an array of display settings to populate,
//!                                        or NULL to find out the total number of available modes.
//! \param [in,out]  pDisplayCount         If pDisplaySettings is not NULL, then pDisplayCount
//!                                        should point to the number of elements in the
//!                                        pDisplaySettings array. On return, it will contain the
//!                                        number of modes that were actually returned. If
//!                                        pDisplaySettings is NULL, then pDisplayCount will receive
//!                                        the total number of modes that are available.
//!
//!
//! \retval ::LWAPI_OK                          Capabilities have been returned.
//! \retval ::LWAPI_ILWALID_ARGUMENT            One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INTIALIZED          The LwAPI API needs to be initialized first
//! \retval ::LWAPI_NO_IMPLEMENTATION           This entrypoint not available
//! \retval ::LWAPI_ERROR                       Miscellaneous error oclwrred
//!
//! \ingroup mosaciapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Mosaic_EnumDisplayModes(__in LW_MOSAIC_GRID_TOPO *pGridTopology,
        __inout_ecount_part_opt(*pDisplayCount, *pDisplayCount) LW_MOSAIC_DISPLAY_SETTING *pDisplaySettings,
        __inout LwU32 *pDisplayCount);


//! SUPPORTED OS:  Windows 7 and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_ChooseGpuTopologies
//
//! DESCRIPTION:     Chooses an SLI configuration for a list of grid topologies.
//!
//!                  This function will look for a valid SLI configuration that will allow
//!                  each of the grid topologies to work.
//!
//!                  On return, the displayGpuIndex field of each active GPU topology will specify
//!                  the master GPU for that topology.
//!
//!                  If the LWRRENT_GPU_TOPOLOGY flag is set, then it will keep the same physical
//!                  GPU's in each logical GPU, but it may change the master GPU. If the
//!                  NO_DRIVER_RELOAD flag is set, then it will not change the current GPU topology
//!                  at all, but will still verify that the GPU topology is valid.
//!
//! \param [in]      pGridTopologies   The grid topologies to use.
//! \param [in]      gridCount         The number of elements in the pGridTopologies array.
//! \param [in]      setTopoFlags      Zero or more of the LWAPI_MOSAIC_SETDISPLAYTOPO_FLAG_*
//!                                    flags.
//! \param [out]     pGpuTopologies    The chosen SLI configuration.
//!
//!
//! \retval ::LWAPI_OK                          Capabilties have been returned.
//! \retval ::LWAPI_ILWALID_ARGUMENT            One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INTIALIZED          The LwAPI API needs to be initialized first
//! \retval ::LWAPI_NO_IMPLEMENTATION           This entrypoint not available
//! \retval ::LWAPI_NO_ACTIVE_SLI_TOPOLOGY      No matching GPU topologies could be found.
//! \retval ::LWAPI_ERROR                       Miscellaneous error oclwrred
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Mosaic_ChooseGpuTopologies(__in_ecount(gridCount) LW_MOSAIC_GRID_TOPO *pGridTopologies,
        __in LwU32 gridCount,
        __in LwU32 setTopoFlags,
        __inout LW_GPU_VALID_GPU_TOPOLOGIES *pGpuTopologies);


//! SUPPORTED OS:  Windows 7 and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_EnumDisplayGrids
//
//! DESCRIPTION:     Enumerates the current active grid topologies. This includes Mosaic, IG, and
//!                  Panoramic topologies, as well as single displays.
//!
//!                  If pGridTopologies is NULL, then pGridCount will be set to the number of active
//!                  grid topologies.
//!
//!                  If pGridTopologies is not NULL, then pGridCount contains the maximum number of
//!                  grid topologies to return. On return, pGridCount will be set to the number of
//!                  grid topologies that were returned.
//!
//! \param [out]     pGridTopologies   The list of active grid topologies.
//! \param [in,out]  pGridCount        A pointer to the number of grid topologies returned.
//!
//! \retval ::LWAPI_OK                          Capabilties have been returned.
//! \retval ::LWAPI_END_ENUMERATION             There are no more topologies to return.
//! \retval ::LWAPI_ILWALID_ARGUMENT            One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INTIALIZED          The LwAPI API needs to be initialized first
//! \retval ::LWAPI_NO_IMPLEMENTATION           This entrypoint not available
//! \retval ::LWAPI_ERROR                       Miscellaneous error oclwrred
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Mosaic_EnumDisplayGrids(__inout_ecount_part_opt(*pGridCount, *pGridCount) LW_MOSAIC_GRID_TOPO *pGridTopologies,
        __inout LwU32 *pGridCount);

//! SUPPORTED OS:  Windows XP and higher
//!
 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_EnumPossibleConfigs
//
//! \fn LwAPI_Mosaic_EnumPossibleConfigs(LW_MOSAIC_CONFIG* configs, LwU32* configCount, LwU32* maxConfigCount, LW_MOSAIC_CONFIG_FILTER* filter, LwU32 flags)
//! DESCRIPTION:                     This API retrieves the list of possible configs for Mosaic.
//!
//! \param [in,out]  configs         Array of configurations, passed by the caller, to be filled in with the requested
//!                                  data. If the array is too small, the call will report *configCount smaller than 
//!                                  *maxConfigCount. On input, only version is required to be set. If using with 
//!                                  filters, then appropriate fields must be filled in, as defined by the valid filters.
//!                                  This API only reads input from the 0th element of the array. On return, these configs
//!                                  are sorted to return configurations from best configuration to worst configuration. 
//!                                  Newer board architectures take priority over older board architectures, then number
//!                                  of GPUs.
//!
//! \param [in,out]  configCount     On input, the length of the array of configs. On return, contains the number of
//!                                  valid entries in the configs array. If this field is zero, an error is returned
//!                                  and the required length is provided in maxConfigCount. If maxConfigCount is NULL and
//!                                  configCount is 0 (or configs == NULL), an invalid parameter error will be returned.
//!
//! \param [out]    maxConfigCount   On return, this field will contain the maximum number of configs which would be
//!                                  returned. If this number is greater than *configCount, the API has only returned
//!                                  a subset of the configurations. This field is optional, and may be NULL.
//!
//! \param [in]     filter           Either one of the predefined filters (LW_MOSAIC_FILTER_*) or a pointer to the filter
//!                                  structure which defines how to filter the results. If this is NULL, all possible
//!                                  results are returned.
//!
//! \param [in]     flags            A bitmask of LW_MOSAIC_FLAGS_* entries to control the behavior of this API
//!
//! Notes:
//!  The filters are used to control which entries are returned. If no GPU list is provided, the API will only return 
//! up to a single valid and a single invalid configuration per GPU topology. If the GPU topology is provided, the API 
//! will return one configuration 
//! per displayCount. The elements returned will always favor valid over rewire, and rewire over invalid. 
//!
//! \retval ::LWAPI_INSUFFICIENT_BUFFER     The configCount is less than the required size. configCount will be set to the required size.
//! \retval ::LWAPI_END_ENUMERATION         The requested configurations results in no results.
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
 
//! \ingroup mosaicapi
typedef struct {
    LwU32 version;                                          //!< Version of filter structure

    LwU32 isValid : 1;                                      //!< If true, only return configurations which require no hardware changes to apply. A driver reload may still be required
    LwU32 includesDisplays : 1;                             //!< If true, the displayIds array contains displays which must be part of the configuration to be returned
    LwU32 excludesDisplays : 1;                             //!< If true, the displayIds array contains displays which must not be part of the configuration to be returned
    LwU32 includesGpus     : 1;                             //!< If true, only return configurations which include GPUs specified in the gpus array
    LwU32 excludesGpus     : 1;                             //!< If true, only return configurations which do not include GPUs specified in the gpus array
    LwU32 supportsSurround : 1;                             //!< If true, only return configurations which support surround
    LwU32 supportsMosaic   : 1;                             //!< If true, only return configurations which support mosaic
    LwU32 noReloadRequired : 1;                             //!< If true, only return configurations which do not require a driver reload to apply. This implies isValid
    LwU32 noRewireRequired : 1;                             //!< If true, only return configurations which do not require displays to be moved to a different GPU. This implies isValid
    LwU32 noBridgeChangeRequired : 1;                       //!< If true, only return configurations which do not require an SLI bridge to be added or moved
 
    LwU32 reserved : 22;                                    //!< Reserved, must be 0
 
    // Displays
    LwS32 minDisplayCount;                                  //!< The minimum number of displays required. Ignored if 0. 
    LwS32 maxDisplayCount;                                  //!< The maximum number of displays required. Ignored if 0.
    LwU32 suppliedDisplays;                                 //!< The number of valid elements in the displayIds array. Ignored unless includesDisplays or excludesDisplays is true
    LwU32 displayIds[LW_MOSAIC_MAX_DISPLAYS];               //!< An array of displayIds, used by includesDisplays and excludesDisplays
 
    // GPUs
    LwS32 minGpuCount;                                      //!< The minimum number of GPUs required. Ignored if 0.
    LwS32 maxGpuCount;                                      //!< The maximum number of GPUs required. Ignored if 0.
    LwU32 suppliedGpus;                                     //!< The number of valid elements in the gpus array. Ignored unless includesGpus or excludesGpus is true
    LwPhysicalGpuHandle gpus[LWAPI_MAX_GPU_PER_TOPOLOGY];   //!< An array of gpu handles, used by includesGpus and excludesGpus
} LW_MOSAIC_CONFIG_FILTER;
 
//! \ingroup mosaicapi
//! @{
#define LW_MOSAIC_FILTER_NONE               ((LW_MOSAIC_CONFIG_FILTER*) 0)  //!< Same as NULL, request all configurations
#define LW_MOSAIC_FILTER_VALID              ((LW_MOSAIC_CONFIG_FILTER*) 1)  //!< Use in place of LW_MOSAIC_CONFIG_FILTER to simplify requesting all valid topologies
#define LW_MOSAIC_FILTER_SURROUND           ((LW_MOSAIC_CONFIG_FILTER*) 2)  //!< Use in place of LW_MOSIAC_CONFIG_FILTER to simplify requesting all surround topologies
#define LW_MOSAIC_FILTER_MOSAIC             ((LW_MOSAIC_CONFIG_FILTER*) 3)  //!< Use in place of LW_MOSAIC_CONFIG_FILTER to simplify requesting all mosaic topologies
 
#define LW_MOSAIC_CONFIG_FILTER_VER1        MAKE_LWAPI_VERSION(LW_MOSAIC_CONFIG_FILTER, 1)
#define LW_MOSAIC_CONFIG_FILTER_VER         LW_MOSAIC_CONFIG_FILTER_VER1
 
 
#define LW_MOSAIC_FLAGS_CACHED          LW_BIT(0)   //!< This causes the API to use cached information about the GPUs and displays. It is recommended that the first call in a series not use the cached flag, then subsequent calls in a series use this flag to reduce the number of queries done to the hardware. Cached mode is not thread safe against uncached mode, so it is up to the caller to ensure that while one thread is using cached mode, no other thread makes an uncached query.
//! @}
 
//! \ingroup mosaicapi
//! @{
typedef struct {
    LwU32 displayId;                    //!< (OUT) The displayId associated to the display details
    LwU32 problemFlags;                 //!< (OUT) A bitmask of different problems associated with use of this display in the detailed configuration (See LW_MOSAIC_DISPLAYCAPS_PROBLEM_* for list of problem flags)
    LwU32 requiredGpuId;                //!< (OUT) The GPU to have this display connected to for this display topology. This will be 0 if problemFlags does not contain LW_MOSAIC_DISPLAYCAPS_PROBLEM_DISPLAY_ON_ILWALID_GPU
    LwU32 requiredConnector;            //!< (OUT) The connector for which this display must be connected for this display topology. This will be 0 if problemFlags does not contain LW_MOSAIC_DISPLAYCAPS_PROBLEM_DISPLAY_ON_WRONG_CONNECTOR
 
    LwU32 supportsSingleRotation : 1;   //!< (OUT) This display can be rotated independently of the rest of the displays in the configuration
    LwU32 supportsUniqueSettings : 1;   //!< (OUT) This display can have display settings (resolution/timing) independently of the rest of the displays in the configuration
    LwU32 canBePrimary : 1;             //!< (OUT) This display can be the primary display of the Mosaic/Surround topology

    LwU32 reserved : 29;                //!< (OUT) Reserved
} LW_MOSAIC_CONFIG_DISPLAY;


typedef struct {
    LwU32 version;

    // Displays
    LwU32 displayCount;                 //!< (OUT) The number of displays in this configuration
    LW_MOSAIC_CONFIG_DISPLAY displays[LW_MOSAIC_MAX_DISPLAYS];  //!< (OUT) List of displays, in arbitrary order
 
    // GPU Topology
    LW_GPU_TOPOLOGY gpuTopology;        //!< (OUT) The GPU topology for this configuration. For a single-GPU topology, this will be filled with 0
    LwU32 problemFlags;                 //!< (OUT) A bitmask of different problems associated with use of this configuration (See LW_MOSAIC_DISPLAYCAPS_PROBLEM_* for list of problem flags)
 
    // Single bit settings
    LwU32 mosaic : 1;                   //!< (OUT) This configuration is a Mosaic configuration
    LwU32 surround : 1;                 //!< (OUT) This configuration is a Surround configuration
    LwU32 supportsRotation : 1;         //!< (OUT) This configuration supports all displays rotated the same way (Portrait or Landscape)
    LwU32 supportsPassiveStereo : 1;    //!< (OUT) This configuration supports passive stereo
 
    LwU32 reserved : 28;                //!< (OUT) Reserved
 
} LW_MOSAIC_CONFIG;
//! @}

#define LW_MOSAIC_CONFIG_VER1           MAKE_LWAPI_VERSION(LW_MOSAIC_CONFIG, 1)
#define LW_MOSAIC_CONFIG_VER            LW_MOSAIC_CONFIG_VER1

//! \ingroup mosaicapi
LWAPI_INTERFACE LwAPI_Mosaic_EnumPossibleConfigs(LW_MOSAIC_CONFIG* configs, LwU32* configCount, LwU32* maxConfigCount, LW_MOSAIC_CONFIG_FILTER* filter, LwU32 flags);


//! SUPPORTED OS:  Windows XP and higher
//!
 
//! \ingroup mosaicapi
//! @{
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_GetResolutions
//! \fn LwAPI_Mosaic_GetResolutions(__in LwU32 displayId, __inout_ecount(*resListCount) LW_MOSAIC_RESOLUTION* resList, __inout LwU32* resListCount, __in_opt LW_MOSAIC_GRID_TOPO* pGridTopo)
//! DESCRIPTION:    This API returns an array of resolutions for a grid topology.
//!
//!                 If no predictive grid topology is provided, the current grid
//!                 topology is returned.
//!
//!                 If a predictive grid topology is provided, that topology is
//!                 used to callwlate the answers. This list will not set the
//!                 defaultResolution or isVisible bits.
//!
//!                 To retrieve the number of resolutions, resList must be NULL and
//!                 resListCount must be set to 0.
//!
//! \param [in]     displayId        Any displayId of the mosaic topology in question
//!
//! \param [in,out] resList          The array of resolutions
//!
//! \param [in,out] resListCount     On input, the length of the array of resolutions. On return, contains the number of
//!                                  valid resolutions. If the array is too small, an error is returned
//!                                  and the required length is provided in resListCount.
//!
//! \param [in]     pGridTopo        May provide a grid topology to return the results against. displayId must be one of
//!                                  the displays provided in the grid topology. This argument may be NULL, in which case
//!                                  the lwrrently applied grid topology, active or not, will be used.
//!
//! \retval ::LWAPI_INSUFFICIENT_BUFFER     The configCount is less than the required size. configCount will be set to the required size.
//!
///////////////////////////////////////////////////////////////////////////////

typedef struct 
{
    LwU32                       version;                //!< Version of this structure
    LwU32                       width;                  //!< Per-display width
    LwU32                       height;                 //!< Per-display height
    LwU32                       freq;                   //!< Display frequency
    LwU32                       singleWide : 1;         //!< This resolution is a single-wide resolution
    LwU32                       mosaic : 1;             //!< This resolution is a mosaic or surround resolution
    LwU32                       bezelCorrected : 1;     //!< This resolution has bezel correction
    LwU32                       defaultResolution : 1;  //!< This resolution is a default resolution
    LwU32                       isVisible : 1;          //!< This resolution is visible
    LwU32                       reserved : 27;          //!< Reserved
} LW_MOSAIC_RESOLUTION;

#define LW_MOSAIC_RESOLUTION_VER1       MAKE_LWAPI_VERSION(LW_MOSAIC_RESOLUTION, 1)
#define LW_MOSAIC_RESOLUTION_VER        LW_MOSAIC_RESOLUTION_VER1

LWAPI_INTERFACE LwAPI_Mosaic_GetResolutions(__in LwU32 displayId, __inout_ecount(*resListCount) LW_MOSAIC_RESOLUTION* resList, __inout LwU32* resListCount, __in_opt LW_MOSAIC_GRID_TOPO* pGridTopo);
//! @}
 
//! SUPPORTED OS:  Windows XP and higher
//!
 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Mosaic_SetResolutions
//
//! DESCRIPTION:    This API allows setting the isVisible flags on a grid topology. All other
//!                 fields must be the same as the LwAPI_Mosaic_GetResolutions API call reports.
//!
//! \param [in]     displayId        Any displayId of the mosaic topology in question
//!
//! \param [in]     resList          The array of resolutions
//!
//! \param [inout]  resListCount     The length of the array of resolutions.
//!
//! \retval ::LWAPI_INSUFFICIENT_BUFFER     The configCount is less than the required size. configCount will be set to the required size.
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////

LWAPI_INTERFACE LwAPI_Mosaic_SetResolutions(__in LwU32 displayId, __in_ecount(resListCount) LW_MOSAIC_RESOLUTION* resList, __in LwU32 resListCount);



////////////////////////////////////////////////////////////////////////////////////////
//
// ###########################################################################
// DELME_RUSS - DELME_RUSS - DELME_RUSS - DELME_RUSS - DELME_RUSS - DELME_RUSS
//
//   Below is the Phase 1 Mosaic stuff, the Phase 2 stuff above is what will remain
//   once Phase 2 is complete.  For a small amount of time, the two will co-exist.  As
//   soon as apps (lwapichk, LwAPITestMosaic, and CPL) are updated to use the Phase 2
//   entrypoints, the code below will be deleted.
//
// DELME_RUSS - DELME_RUSS - DELME_RUSS - DELME_RUSS - DELME_RUSS - DELME_RUSS
// ###########################################################################
//
// Supported topos 1x4, 4x1 and 2x2 to start with.
// 
// Selected scan out targets can be one per GPU or more than one on the same GPU.
//
// SAMPLE of MOSAIC 1x4 SCAN OUT TOPO with 8 pixel horizontal overlap
//
//+-------------------------++-------------------------++-------------------------++-------------------------+
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|        DVI1             ||           DVI2          ||         DVI3            ||          DVI4           |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//+-------------------------++-------------------------++-------------------------++-------------------------+


//! \addtogroup mosaicapi
//! @{

//! Used in LW_MOSAIC_TOPOLOGY.
#define LWAPI_MAX_MOSAIC_DISPLAY_ROWS       8

//! Used in LW_MOSAIC_TOPOLOGY.
#define LWAPI_MAX_MOSAIC_DISPLAY_COLUMNS    8 

//! Used in LW_MOSAIC_TOPOLOGY.
#define LWAPI_MAX_MOSAIC_TOPOS              16

//! Used in LwAPI_GetLwrrentMosaicTopology() and LwAPI_SetLwrrentMosaicTopology().
typedef struct 
{
    LwU32 version;                             //!< Version number of the mosaic topology
    LwU32 rowCount;                            //!< Horizontal display count
    LwU32 colCount;                            //!< Vertical display count

    struct 
    {
        LwPhysicalGpuHandle hPhysicalGPU;      //!< Physical GPU to be used in the topology
        LwU32               displayOutputId;   //!< Connected display target
        LwS32               overlapX;          //!< Pixels of overlap on the left of target: (+overlap, -gap)
        LwS32               overlapY;          //!< Pixels of overlap on the top of target: (+overlap, -gap)

    } gpuLayout[LWAPI_MAX_MOSAIC_DISPLAY_ROWS][LWAPI_MAX_MOSAIC_DISPLAY_COLUMNS];

} LW_MOSAIC_TOPOLOGY;

//! Used in LW_MOSAIC_TOPOLOGY.
#define LWAPI_MOSAIC_TOPOLOGY_VER         MAKE_LWAPI_VERSION(LW_MOSAIC_TOPOLOGY,1)

//! Used in LwAPI_GetSupportedMosaicTopologies().
typedef struct 
{
    LwU32                   version;                                    
    LwU32                   totalCount;                     //!< Count of valid topologies
    LW_MOSAIC_TOPOLOGY      topos[LWAPI_MAX_MOSAIC_TOPOS];  //!< Maximum number of topologies

} LW_MOSAIC_SUPPORTED_TOPOLOGIES;

//! Used in LW_MOSAIC_SUPPORTED_TOPOLOGIES. 
#define LWAPI_MOSAIC_SUPPORTED_TOPOLOGIES_VER         MAKE_LWAPI_VERSION(LW_MOSAIC_SUPPORTED_TOPOLOGIES,1)

//!@}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GetSupportedMosaicTopologies
//
//! DESCRIPTION:     This API returns all valid Mosaic topologies.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 177
//!
//! \param [out] pMosaicTopos                   An array of valid Mosaic topologies.
//!
//! \retval      LWAPI_OK                       Call succeeded; 1 or more topologies were returned
//! \retval      LWAPI_ILWALID_ARGUMENT         One or more arguments are invalid
//! \retval      LWAPI_MIXED_TARGET_TYPES       Mosaic topology is only possible with all targets of the same LW_GPU_OUTPUT_TYPE.
//! \retval      LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found
//! \retval      LWAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.
//! \retval      LWAPI_NO_ACTIVE_SLI_TOPOLOGY   SLI is not enabled, yet needs to be, in order for this function to succeed.
//!
//! \ingroup     mosaicapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetSupportedMosaicTopologies(LW_MOSAIC_SUPPORTED_TOPOLOGIES *pMosaicTopos);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GetLwrrentMosaicTopology
//
//! DESCRIPTION:     This API gets the current Mosaic topology.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 177
//!
//! \param [out] pMosaicTopo                    The current Mosaic topology
//! \param [out] pEnabled                       TRUE if returned topology is lwrrently enabled, else FALSE
//!
//! \retval      LWAPI_OK                       Call succeeded
//! \retval      LWAPI_ILWALID_ARGUMENT         One or more arguments are invalid
//! \retval      LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found
//! \retval      LWAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.
//! \retval      LWAPI_NO_ACTIVE_SLI_TOPOLOGY   SLI is not enabled, yet needs to be, in order for this function to succeed.
//!
//! \ingroup     mosaicapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetLwrrentMosaicTopology(LW_MOSAIC_TOPOLOGY *pMosaicTopo, LwU32 *pEnabled);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_SetLwrrentMosaicTopology
//
//! DESCRIPTION:     This API sets the Mosaic topology, and enables it so that the
//!                  Mosaic display settings are enumerated upon request.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 177
//!
//! \param [in]  pMosaicTopo                    A valid Mosaic topology
//!
//! \retval      LWAPI_OK                       Call succeeded
//! \retval      LWAPI_ILWALID_ARGUMENT         One or more arguments are invalid
//! \retval      LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found
//! \retval      LWAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.
//! \retval      LWAPI_NO_ACTIVE_SLI_TOPOLOGY   SLI is not enabled, yet needs to be, in order for this function to succeed.
//!
//! \ingroup     mosaicapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetLwrrentMosaicTopology(LW_MOSAIC_TOPOLOGY *pMosaicTopo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_EnableLwrrentMosaicTopology
//
//! DESCRIPTION:    This API enables or disables the current Mosaic topology. 
//!                 When enabling, the last Mosaic topology will be set.
//!
//!                  - If enabled, enumeration of display settings will include valid Mosaic resolutions.  
//!                  - If disabled, enumeration of display settings will not include Mosaic resolutions.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 177
//!
//! \param [in]  enable                         TRUE to enable the Mosaic Topology, FALSE to disable it.
//!
//! \retval      LWAPI_OK                       Call succeeded
//! \retval      LWAPI_ILWALID_ARGUMENT         One or more arguments are invalid
//! \retval      LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found
//! \retval      LWAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.
//! \retval      LWAPI_NO_ACTIVE_SLI_TOPOLOGY   SLI is not enabled, yet needs to be, in order for this function to succeed.
//!
//! \ingroup     mosaicapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_EnableLwrrentMosaicTopology(LwU32 enable);


///////////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_Mosaic_GetSymmetricOrderedDisplayIds
//
//! DESCRIPTION: This API is independent of the topology or the grid. It returns symmetric ordered display IDs for all possible outputs on the GPU.
//!              Displays on the same index of the display ID array for two GPUs can be a part of the mosaic topology since they are symmetric.
//!              In case of DPMST, it will return entries for each unique auxiliary address present in the stream. Each connected display ID is
//!              identified with the isConnected flag.
//! HOW TO USE: 1. The first call should be made to get the all display ID count. To get the display ID count, send in 
//!                  a) hPhysicalGpu    - a valid GPU handle(enumerated using LwAPI_EnumPhysicalGPUs()) as input,      
//!                  b) pDisplayIds     - NULL, as we just want to get the display ID count.                            
//!                  c) pDisplayIdCount - a valid pointer to LwU32, whose value is set to ZERO.                        
//!                If all parameters are correct and this call is successful, this call will return the display ID's count. 
//!             2. To get the display ID array, make the second call to LwAPI_Mosaic_GetSymmetricOrderedDisplayIds() with   
//!                  a) hPhysicalGpu    - should be same value which was sent in first call,                           
//!                  b) pDisplayIds     - pointer to the display ID array allocated by caller based on display ID count,   
//!                                       eg. malloc(sizeof(LW_GPU_DISPLAYIDS) * pDisplayIdCount).                     
//!                  c) pDisplayIdCount - a valid pointer to LwU32. This indicates for how many display IDs            
//!                                       the memory is allocated(pDisplayIds) by the caller.                         
//!                If all parameters are correct and this call is successful, this call will return the display ID array and actual
//!                display ID count (which was obtained in the first call to LwAPI_Mosaic_GetSymmetricOrderedDisplayIds).
//!                If the input display ID count is  less than the actual display ID count, it will overwrite the input and give the
//!                pDisplayIdCount as actual count and the API will return LWAPI_INSUFFICIENT_BUFFER.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     hPhysicalGpu         GPU selection.
//! \param [in,out] DisplayIds           Pointer to an array of LW_GPU_DISPLAYIDS structures, each entry represents one displayID 
//!                                      and its attributes.
//! \param [in,out] pDisplayIdCount      As input, this parameter indicates the number of display's id's for which caller has 
//!                                      allocated the memory. As output, it will return the actual number of display IDs.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval  LWAPI_INSUFFICIENT_BUFFER  When the input buffer(pDisplayIds) is less than the actual number of display IDs, this API 
//!                                     will return LWAPI_INSUFFICIENT_BUFFER. 
//!
//! \ingroup mosaicapi
////////////////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Mosaic_GetSymmetricOrderedDisplayIds(__in LwPhysicalGpuHandle hPhysicalGpu, __inout_ecount_part_opt(*pDisplayIdCount, *pDisplayIdCount) LW_GPU_DISPLAYIDS* pDisplayIds, __inout LwU32* pDisplayIdCount);


//! \ingroup viscompapi
//! @{
#define LWAPI_MAX_GPUS_PER_VISUAL_COMPUTING_DEVICE    8
#define LWAPI_MAX_VISUAL_COMPUTING_DEVICES            8
#define LWAPI_MAX_HIC_DEVICES                         4
//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_EnumVisualComputingDevices
//
//!   DESCRIPTION: This API returns an array of Visual Computing Device handles. A Visual Computing Device handle
//!                represents one or more GPUs acting in concert as a single Visual Computing Device.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \param [out]  lwComputeHandles   The caller provides an array of handles, which must contain at least 
//!                                  LWAPI_MAX_VISUAL_COMPUTING_DEVICES elements. The API will zero out the entire array, 
//!                                  and then fill in one or more handles. If an error oclwrs, the array is invalid.
//! \param [out] *pSystemCount       The caller provides the storage space. LwAPI_EnumVisualComputingDevices sets *pSystemCount
//!                                  to indicate how many of the elements in the lwComputeHandles[] array are valid.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT           lwComputingHandle or pSystemCount is NULL.
//! \retval ::LWAPI_OK                         One or more handles were returned.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND    The queried Graphics system does not have any Visual Computing Device.
//! \retval ::LWAPI_ERROR 
//!
//! \ingroup viscompapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_EnumVisualComputingDevices(LwVisualComputingDeviceHandle lwComputeHandles[LWAPI_MAX_VISUAL_COMPUTING_DEVICES], LwU32 *pSystemCount);


//! \ingroup viscompapi
//! Used in _LW_VISUAL_COMPUTING_DEVICE_INFO.
typedef enum _LW_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE
{
    LW_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE_ON = 1,
    LW_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE_OFF = 2,
    LW_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE_NOT_SUPPORTED = -1,

} LW_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE;


//! \ingroup viscompapi
//! Used in LwAPI_VCD_GetDeviceInfo().
typedef struct _LW_VISUAL_COMPUTING_DEVICE_INFO
{
    LwU32                               version;
    LwAPI_LongString                    productName;
    LwAPI_LongString                    serialNumber;
    LwAPI_ShortString                   firmwareVersion;                    //!< major number.minor number
    LwU32                               buildDateYear;                      //!< Build date: year the system was built.
    LwU32                               buildDateWeek;                      //!< Build date: week the system was built.
    LwAPI_ShortString                   hardwareVersion;                    //!< Version of the hardware spin
    LW_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE  perfMode;                  //!< System performance mode

    LwPhysicalGpuHandle gpuHandle[LWAPI_MAX_GPUS_PER_VISUAL_COMPUTING_DEVICE];//!< Associated physical GPU handles.

} LW_VISUAL_COMPUTING_DEVICE_INFO;




//! \ingroup viscompapi
//! Macro for constructing the version field of  _LW_VISUAL_COMPUTING_DEVICE_INFO, 
#define LW_VISUAL_COMPUTING_DEVICE_INFO_VER  MAKE_LWAPI_VERSION(LW_VISUAL_COMPUTING_DEVICE_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_VCD_GetDeviceInfo
//
//!   DESCRIPTION: This API returns Visual Computing Device information.
//!
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \param [in]    lwComputingHandle  The enumerated Visual Computing Device handle retrieved from LwAPI_EnumVisualComputingDevices.
//! \param [out]   pVisInfo           Contains the retrieved Visual Computing Device information with the associated GPU handles.
//!                                   pVisInfo->version needs to be set to ::LW_VISUAL_COMPUTING_DEVICE_INFO_VER for the API to succeed.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT        lwComputingHandle or pVisInfo is NULL
//! \retval ::LWAPI_OK
//! \retval ::LWAPI_ERROR
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND The queried Graphics system does not have any Visual Computing Device.
//!
//! \ingroup viscompapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VCD_GetDeviceInfo(LwVisualComputingDeviceHandle lwComputingHandle, LW_VISUAL_COMPUTING_DEVICE_INFO *pVisInfo);







//! \addtogroup viscompapi
//! @{

typedef enum _LW_HIC_TYPE
{
    LW_HIC_TYPE_UNKNOWN = 0, //!< HIC type unknown.
    LW_HIC_TYPE_SHIC       , //!< Single HIC.
    LW_HIC_TYPE_DOHIC      , //!< Dual HIC.
    LW_HIC_TYPE_GHIC         //!< Graphics HIC.
} LW_HIC_TYPE;

typedef struct _LW_VCD_TOPOLOGY_TARGET
{
    LwU32                         version;
    LwVisualComputingDeviceHandle lwComputingHandle; //!<Visual Computing Device handle
    LwU32                         gpuCount;
    LwPhysicalGpuHandle           lwGpuHandles[LWAPI_MAX_GPUS_PER_VISUAL_COMPUTING_DEVICE]; //!< associated physical gpu handles.
} LW_VCD_TOPOLOGY_TARGET;

//! Macro for constructing the version field of ::LW_VCD_TOPOLOGY_TARGET
#define LW_VCD_TOPOLOGY_TARGET_VER  MAKE_LWAPI_VERSION(LW_VCD_TOPOLOGY_TARGET,1)

typedef struct _LW_HIC_TOPOLOGY
{
    LwU32                       version;
    LwHICHandle                 lwHICHandle;
    LwU32                       vcdCount; //VCD target count associated with this HIC
    LW_VCD_TOPOLOGY_TARGET      vcdTarget[LWAPI_MAX_VISUAL_COMPUTING_DEVICES]; //Array of VCD's associated with one HIC
    LW_HIC_TYPE                 lwHICType;
} LW_HIC_TOPOLOGY;

//! Macro for constructing the version field of ::LW_HIC_TOPOLOGY
#define LW_HIC_TOPOLOGY_VER  MAKE_LWAPI_VERSION(LW_HIC_TOPOLOGY,1)

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_HIC_QueryTopology
//
//! \code
//!   DESCRIPTION: Returns Topology of Host Interface Cards presented in a system, for each HIC returns associated Visual Computing Devices and corresponding GPU's.
//!
//!   PARAMETERS:  lwHICTopologies[OUT] - The caller provides an array of HICTopologies. Topology contains number of HIC's 
//!                                       presented in the system, for each HIC returns associated Visual Computing Devices and corresponding GPU handles.
//!                pTopoCount[OUT] - The caller provides the storage space. *pTopoCount indicates how many of the elements in the lwHICTopologies are valid.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: lwHICTopologies or pTopoCount is NULL
//!                LWAPI_OK: lwHICTopologies was populated.
//!                LWAPI_ERROR: the operation failed.
//!                LWAPI_LWIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any Host Interface Card.
//! \endcode
//! \ingroup viscompapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_HIC_QueryTopology(LW_HIC_TOPOLOGY lwHICTopologies[LWAPI_MAX_HIC_DEVICES], LwU32 *pTopoCount);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_VCD_UpdatePerformanceMode
//
//!   DESCRIPTION: This API enables or disables the Visual Computing Device high performance mode.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \param [in]   lwComputingHandle   The enumerated Visual Computing Device handle retrieved from LwAPI_EnumVisualComputingDevices().
//! \param [in]   systemPerfMode      The valid value to switch to the new performance mode.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT  Any values other than LW_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE_ON
//!                                   and LW_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE_OFF are invalid.
//! \retval ::LWAPI_OK               
//! \retval ::LWAPI_NOT_SUPPORTED     This controller does not support performance mode.
//! \retval ::LWAPI_ERROR
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any Visual Computing Device.
//!
//! \ingroup viscompapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VCD_UpdatePerformanceMode(LwVisualComputingDeviceHandle lwComputingHandle, LW_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE systemPerfMode);



//! \addtogroup viscompapi
//! @{
#define LW_POWER_SUPPLY_STATE_NORMAL                    0x00000001    //!< Normal operation
#define LW_POWER_SUPPLY_STATE_ABNORMAL                  0x00000002    //!< Power Shut down
//Additional Abnormal power states
#define LW_POWER_SUPPLY_STATE_ABNORMAL_HIGH_VOLTAGE     0x00000008    //!< Output shutdown due to high-voltage
#define LW_POWER_SUPPLY_STATE_ABNORMAL_FAN_FAILURE      0x00000010    //!< Fan failure
#define LW_POWER_SUPPLY_STATE_ABNORMAL_HEATSINK         0x00000040    //!< Alarm - "Heatsink over temperature"
#define LW_POWER_SUPPLY_STATE_ABNORMAL_LIMIT_REACHED    0x00000080    //!< Current limit reached
#define LW_POWER_SUPPLY_STATE_ABNORMAL_OUTPUT_THRESHOLD 0x00000100    //!< Output voltage below UV alarm threshold
#define LW_POWER_SUPPLY_STATE_ABNORMAL_LOW_VOLTAGE      0x00000200    //!< Output shut down due to low-voltage
#define LW_POWER_SUPPLY_STATE_ABNORMAL_I2C_REMOTE_OFF   0x00001000    //!< Shutdown due to I2C remote off command
#define LW_POWER_SUPPLY_STATE_ABNORMAL_DISABLE          0x00002000    //!< Shutdown due to MOD_DISABLE input
#define LW_POWER_SUPPLY_STATE_ABNORMAL_SHORT_PIN        0x00004000    //!< Shutdown due to short pin transition
//! @}

//! \ingroup viscompapi
//! Used in _LW_POWER_SUPPLY_INFO,
typedef enum _LW_POWER_SUPPLY_TYPE
{
    LW_POWER_SUPPLY_VALERE = 1,
    LW_POWER_SUPPLY_DELTA,

} LW_POWER_SUPPLY_TYPE;


//! \ingroup viscompapi
//! Used in LwAPI_VCD_GetPowerSupplyInfo().
typedef struct _LW_POWER_SUPPLY_INFO
{
    LwU32                   version;
    LW_POWER_SUPPLY_TYPE    psuType;    //!< Power supply make
    LwU32                   voltage;    //!< in volts
    LwU32                   current;    //!< in amps
    LwU32                   stateFlags; //!< One or more power state flags - normal or abnormal

} LW_POWER_SUPPLY_INFO;




//! \ingroup viscompapi
//! Macro for constructing the version field of _LW_POWER_SUPPLY_INFO 
#define LW_POWER_SUPPLY_INFO_VER  MAKE_LWAPI_VERSION(LW_POWER_SUPPLY_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_VCD_GetPowerSupplyInfo
//
//!   DESCRIPTION: This API returns power supply information on the Visual Computing Device.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \param [in]    lwComputingHandle            The enumerated Visual Computing Device handle retrieved from LwAPI_EnumVisualComputingDevices().
//! \param [out]   pPowerInfo                   Contains the retrieved Power Supply information for the selected Visual Computing Device.
//!                                             pPowerInfo->version must be set to LW_POWER_SUPPLY_INFO_VER for the API to succeed.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT         lwComputingHandle or pPowerInfo is NULL
//! \retval ::LWAPI_OK                       Information successfully in pPowerInfo.
//! \retval ::LWAPI_ERROR
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any Visual Computing Device.
//!
//! \ingroup viscompapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VCD_GetPowerSupplyInfo(LwVisualComputingDeviceHandle lwComputingHandle, LW_POWER_SUPPLY_INFO *pPowerInfo);

#define LWAPI_MAX_GSYNC_DEVICES                       4

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_VCD_GetAssociatedGSyncs
//
//! \code 
//!   DESCRIPTION: Returns all the GSync devices attached to a Visual Computing Device(VCD)
//!
//!   PARAMETERS:  lwComputingHandle[IN] - The enumerated Visual Computing Device handle retrieved from LwAPI_EnumVisualComputingDevices.
//!                lwGSyncHandles[OUT] - The caller provides an array of handles, which must contain at least 
//!                LWAPI_MAX_GSYNC_DEVICES elements. The API will fill in one or more handles. If an error oclwrs, the array is invalid.
//!
//!                *gsyncCount[OUT] - The caller provides the storage space. LwAPI_VCD_GetAssociatedGSyncs
//!                sets *gsyncCount to indicate how many of the elements in the lwGSyncHandles[] array are valid.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: One of the arguments is NULL.
//!                LWAPI_OK: Information retrieved successfully.
//!                LWAPI_ERROR: The operation failed.
//!                LWAPI_LWIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any Visual Computing Device.
//!                LWAPI_NOT_SUPPORTED: The queried Visual Computing Device does not support GSync Cards.
//! \endcode
//! \ingroup viscompapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VCD_GetAssociatedGSyncs(LwVisualComputingDeviceHandle lwComputingHandle, LwGSyncDeviceHandle lwGSyncHandles[LWAPI_MAX_GSYNC_DEVICES], LwU32 *gsyncCount);


//! \addtogroup gsyncapi
//! @{


// Sync Display APIs

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_EnumSyncDevices
//
//!   DESCRIPTION: This API returns an array of Sync device handles. A Sync device handle represents a
//!                single Sync device on the system.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \since Release: 313
//!
//! \param [out] lwGSyncHandles-  The caller provides an array of handles, which must contain at least
//!                               LWAPI_MAX_GSYNC_DEVICES elements. The API will zero out the entire array and then fill in one
//!                               or more handles. If an error oclwrs, the array is invalid.
//! \param [out] *gsyncCount-     The caller provides the storage space. LwAPI_GSync_EnumSyncDevices
//!                               sets *gsyncCount to indicate how many of the elements in the lwGSyncHandles[] array are valid.
//!                               If an error oclwrs, *gsyncCount will be set to zero.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//! \retval ::LWAPI_ILWALID_ARGUMENT         lwGSyncHandles or gsyncCount is NULL.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any Sync Device.
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GSync_EnumSyncDevices(__out LwGSyncDeviceHandle lwGSyncHandles[LWAPI_MAX_GSYNC_DEVICES], __out LwU32 *gsyncCount);



// GSync boardId values
#define LWAPI_GSYNC_BOARD_ID_P358 856       //!< GSync board ID 0x358, see LW_GSYNC_CAPABILITIES
#define LWAPI_GSYNC_BOARD_ID_P2060 8288     //!< GSync board ID 0x2060, see LW_GSYNC_CAPABILITIES 


//! Used in LwAPI_GSync_QueryCapabilities().
typedef struct _LW_GSYNC_CAPABILITIES
{
    LwU32   version;                        //!< Version of the structure
    LwU32   revId;                          //!< FPGA Revision (low 4 bits) and Board ID (high 4 bits)
    LwU32   boardId;                        //!< Board ID
    LwU32   revision;                       //!< FPGA Revision
    LwU32   capFlags;                       //!< Capabilities of the Sync board. Reserved for future use
    LwU32   maxSyncSkew;                    //!< Maximum units of sync skew the board supports
    LwU32   syncSkewResolution;             //!< Number of nanoseconds that one unit of sync skew corresponds to
    LwU32   maxStartDelay;                  //!< Maximum units of sync start delay the board supports
    LwU32   startDelayResolution;           //!< Number of nanoseconds that one unit of sync start delay corresponds to 
} LW_GSYNC_CAPABILITIES;



//! \ingroup gsyncapi
//! Macro for constructing the version field of LW_GSYNC_CAPABILITIES.
#define LW_GSYNC_CAPABILITIES_VER  MAKE_LWAPI_VERSION(LW_GSYNC_CAPABILITIES,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_QueryCapabilities
//
//!   DESCRIPTION: This API returns the capabilities of the Sync device.
//!
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \since Release: 313
//!
//! \param [in]    hLwGSyncDevice-        The handle for a Sync device for which the capabilities will be queried.
//! \param [inout] *pLwGSyncCapabilities- The caller provides the storage space. LwAPI_GSync_QueryCapabilities() sets
//!                                       *pLwGSyncCapabilities to the version and capabilities details of the Sync device
//!                                       If an error oclwrs, *pLwGSyncCapabilities will be set to NULL.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//! \retval ::LWAPI_ILWALID_ARGUMENT         hLwGSyncDevice is NULL.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any Sync Device.
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GSync_QueryCapabilities(__in LwGSyncDeviceHandle hLwGSyncDevice, __inout LW_GSYNC_CAPABILITIES *pLwGSyncCapabilities);



//! Connector values for a GPU. Used in LW_GSYNC_GPU.
typedef enum _LWAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR
{
    LWAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_NONE         = 0,
    LWAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_PRIMARY      = 1,
    LWAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_SECONDARY    = 2,
    LWAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_TERTIARY     = 3,
    LWAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_QUARTERNARY  = 4,
} LWAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR;

//! Display sync states. Used in LW_GSYNC_DISPLAY.
typedef enum _LWAPI_GSYNC_DISPLAY_SYNC_STATE
{
    LWAPI_GSYNC_DISPLAY_SYNC_STATE_UNSYNCED         = 0,
    LWAPI_GSYNC_DISPLAY_SYNC_STATE_SLAVE            = 1,
    LWAPI_GSYNC_DISPLAY_SYNC_STATE_MASTER           = 2,
} LWAPI_GSYNC_DISPLAY_SYNC_STATE;

typedef struct _LW_GSYNC_GPU
{
    LwU32                               version;            //!< Version of the structure
    LwPhysicalGpuHandle                 hPhysicalGpu;       //!< GPU handle
    LWAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR  connector;          //!< Indicates which connector on the device the GPU is connected to.
    LwPhysicalGpuHandle                 hProxyPhysicalGpu;  //!< GPU through which hPhysicalGpu is connected to the Sync device (if not directly connected)
                                                            //!<  - this is NULL otherwise
    LwU32                               isSynced : 1;       //!< Whether this GPU is sync'd or not.
    LwU32                               reserved : 31;      //!< Should be set to ZERO
} LW_GSYNC_GPU;

typedef struct _LW_GSYNC_DISPLAY
{
    LwU32                               version;            //!< Version of the structure
    LwU32                               displayId;          //!< display identifier for displays.The GPU to which it is connected, can be retireved from LwAPI_SYS_GetPhysicalGpuFromDisplayId
    LwU32                               isMasterable : 1;   //!< Can this display be the master? (Read only)
    LwU32                               reserved : 31;      //!< Should be set to ZERO
    LWAPI_GSYNC_DISPLAY_SYNC_STATE      syncState;          //!< Is this display slave/master
                                                            //!< (Retrieved with topology or set by caller for enable/disable sync)
} LW_GSYNC_DISPLAY;

#define LW_GSYNC_DISPLAY_VER  MAKE_LWAPI_VERSION(LW_GSYNC_DISPLAY,1)
#define LW_GSYNC_GPU_VER      MAKE_LWAPI_VERSION(LW_GSYNC_GPU,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_GetTopology
//
//!   DESCRIPTION: This API returns the topology for the specified Sync device.
//!
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \since Release: 313
//!
//! \param [in]       hLwGSyncDevice-     The caller provides the handle for a Sync device for which the topology will be queried.
//! \param [in, out]  gsyncGpuCount-      It returns number of GPUs connected to Sync device
//! \param [in, out]  gsyncGPUs-          It returns info about GPUs connected to Sync device
//! \param [in, out]  gsyncDisplayCount-  It returns number of active displays that belongs to Sync device
//! \param [in, out]  gsyncDisplays-      It returns info about all active displays that belongs to Sync device
//!
//! HOW TO USE: 1) make a call to get the number of GPUs connected OR displays synced through Sync device
//!                by passing the gsyncGPUs OR gsyncDisplays as NULL respectively. Both gsyncGpuCount and gsyncDisplayCount can be retrieved in same call by passing
//!                both gsyncGPUs and gsyncDisplays as NULL
//!                On call success:
//!             2) Allocate memory based on gsyncGpuCount(for gsyncGPUs) and/or gsyncDisplayCount(for gsyncDisplays) then make a call to populate gsyncGPUs and/or gsyncDisplays respectively.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//! \retval ::LWAPI_ILWALID_ARGUMENT               hLwGSyncDevice is NULL.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND        The queried Graphics system does not have any Sync Device.
//! \retval ::LWAPI_INSUFFICIENT_BUFFER            When the actual number of GPUs/displays in the topology exceed the number of elements allocated for SyncGPUs/SyncDisplays respectively.
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GSync_GetTopology(__in LwGSyncDeviceHandle hLwGSyncDevice, __inout_opt LwU32 *gsyncGpuCount,  __inout_ecount_part_opt(*gsyncGpuCount, *gsyncGpuCount) LW_GSYNC_GPU *gsyncGPUs,
                                        __inout_opt LwU32 *gsyncDisplayCount, __inout_ecount_part_opt(*gsyncDisplayCount, *gsyncDisplayCount) LW_GSYNC_DISPLAY *gsyncDisplays);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_SetSyncStateSettings
//
//!   DESCRIPTION: Sets a new sync state for the displays in system.
//!
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \since Release: 313
//!
//! \param [in]  gsyncDisplayCount-         The number of displays in gsyncDisplays.
//! \param [in]  pGsyncDisplays-            The caller provides the structure containing all displays that need to be synchronized in the system. 
//!                                         The displays that are not part of pGsyncDisplays, will be un-synchronized.
//! \param [in]  flags-                     Reserved for future use.
//!
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT            If the display topology or count not valid.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND     The queried Graphics system does not have any Sync Device.
//! \retval ::LWAPI_ILWALID_SYNC_TOPOLOGY       1.If any mosaic grid is partial.
//!                                             2.If timing(HVisible/VVisible/refreshRate) applied of any display is different. 
//!                                             3.If There is a across GPU mosaic grid in system and that is not a part of pGsyncDisplays.
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GSync_SetSyncStateSettings(__in LwU32 gsyncDisplayCount, __in_ecount(gsyncDisplayCount) LW_GSYNC_DISPLAY *pGsyncDisplays, __in LwU32 flags);


//! \ingroup gsyncapi

//! Source signal edge to be used for output pulse. See LW_GSYNC_CONTROL_PARAMS.
typedef enum _LWAPI_GSYNC_POLARITY
{
    LWAPI_GSYNC_POLARITY_RISING_EDGE     = 0,
    LWAPI_GSYNC_POLARITY_FALLING_EDGE    = 1,
    LWAPI_GSYNC_POLARITY_BOTH_EDGES      = 2,
} LWAPI_GSYNC_POLARITY;

//! Used in LW_GSYNC_CONTROL_PARAMS.
typedef enum _LWAPI_GSYNC_VIDEO_MODE
{
    LWAPI_GSYNC_VIDEO_MODE_NONE          = 0,
    LWAPI_GSYNC_VIDEO_MODE_TTL           = 1,
    LWAPI_GSYNC_VIDEO_MODE_NTSCPALSECAM  = 2,
    LWAPI_GSYNC_VIDEO_MODE_HDTV          = 3,
    LWAPI_GSYNC_VIDEO_MODE_COMPOSITE     = 4,
} LWAPI_GSYNC_VIDEO_MODE;

//! Used in LW_GSYNC_CONTROL_PARAMS.  
typedef enum _LWAPI_GSYNC_SYNC_SOURCE
{
    LWAPI_GSYNC_SYNC_SOURCE_VSYNC        = 0,
    LWAPI_GSYNC_SYNC_SOURCE_HOUSESYNC    = 1,
} LWAPI_GSYNC_SYNC_SOURCE;

//! Used in LW_GSYNC_CONTROL_PARAMS. 
typedef struct _LW_GSYNC_DELAY
{
    LwU32        version;          //!< Version of the structure
    LwU32        numLines;         //!< delay to be induced in number of horizontal lines.
    LwU32        numPixels;        //!< delay to be induced in number of pixels.
    LwU32        maxLines;         //!< maximum number of lines supported at current display mode to induce delay. Updated by LwAPI_GSync_GetControlParameters(). Read only.
    LwU32        minPixels;        //!< minimum number of pixels required at current display mode to induce delay. Updated by LwAPI_GSync_GetControlParameters(). Read only.
} LW_GSYNC_DELAY;

#define LW_GSYNC_DELAY_VER  MAKE_LWAPI_VERSION(LW_GSYNC_DELAY,1)

//! Used in LwAPI_GSync_GetControlParameters() and LwAPI_GSync_SetControlParameters().
typedef struct _LW_GSYNC_CONTROL_PARAMS
{
    LwU32                       version;            //!< Version of the structure
    LWAPI_GSYNC_POLARITY        polarity;           //!< Leading edge / Falling edge / both
    LWAPI_GSYNC_VIDEO_MODE      vmode;              //!< None, TTL, NTSCPALSECAM, HDTV
    LwU32                       interval;           //!< Number of pulses to wait between framelock signal generation
    LwS32                       skew;               //!< The time delay between the frame sync signal and the GPUs signal. This would be deprecated once CPL moves to new format.
    LwS32                       startDelay;         //!< Sync start delay for master. This would be deprecated once CPL moves to new format.
    LWAPI_GSYNC_SYNC_SOURCE     source;             //!< VSync/House sync
    LwU32                       interlaceMode:1;    //!< interlace mode for a Sync device
    LwU32                       reserved:31;        //!< should be set zero
    LW_GSYNC_DELAY              syncSkew;           //!< The time delay between the frame sync signal and the GPUs signal. 
    LW_GSYNC_DELAY              startupDelay;       //!< Sync start delay for master. 
} LW_GSYNC_CONTROL_PARAMS;

#define LW_GSYNC_CONTROL_PARAMS_VER  MAKE_LWAPI_VERSION(LW_GSYNC_CONTROL_PARAMS,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_GetControlParameters
//
//!   DESCRIPTION: This API queries for sync control parameters as defined in LW_GSYNC_CONTROL_PARAMS.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \since Release: 313
//!
//! \param [in]    hLwGSyncDevice-   The caller provides the handle of the Sync device for which to get parameters
//! \param [inout] *pGsyncControls-  The caller provides the storage space. LwAPI_GSync_GetControlParameters() populates *pGsyncControls with values.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//! \retval ::LWAPI_ILWALID_ARGUMENT          hLwGSyncDevice is NULL.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any Sync Device.
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GSync_GetControlParameters(__in LwGSyncDeviceHandle hLwGSyncDevice, __inout LW_GSYNC_CONTROL_PARAMS *pGsyncControls);



//////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_SetControlParameters
//
//!   DESCRIPTION: This API sets control parameters as defined in LW_SYNC_CONTROL_PARAMS.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \since Release: 313
//!
//! \param [in]  hLwGSyncDevice-   The caller provides the handle of the Sync device for which to get parameters
//! \param [inout]  *pGsyncControls-  The caller provides LW_GSYNC_CONTROL_PARAMS. skew and startDelay will be updated to the applied values.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//! \retval ::LWAPI_ILWALID_ARGUMENT          hLwGSyncDevice is NULL.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any Sync Device.
//! \retval ::LWAPI_SYNC_MASTER_NOT_FOUND     Control Parameters can only be set if there is a Sync Master enabled on the Gsync card.
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GSync_SetControlParameters(__in LwGSyncDeviceHandle hLwGSyncDevice, __inout LW_GSYNC_CONTROL_PARAMS *pGsyncControls);




//! Used in LwAPI_GSync_AdjustSyncDelay()
typedef enum _LWAPI_GSYNC_DELAY_TYPE
{
    LWAPI_GSYNC_DELAY_TYPE_UNKNOWN          = 0,
    LWAPI_GSYNC_DELAY_TYPE_SYNC_SKEW        = 1,
    LWAPI_GSYNC_DELAY_TYPE_STARTUP          = 2
} LWAPI_GSYNC_DELAY_TYPE;

//////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_AdjustSyncDelay
//
//!   DESCRIPTION: This API adjusts the skew and startDelay to the closest possible values. Use this API before calling LwAPI_GSync_SetControlParameters for skew or startDelay.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \since Release: 319
//!
//! \param [in]  hLwGSyncDevice-    The caller provides the handle of the Sync device for which to get parameters
//! \param [in]  delayType-         Specifies whether the delay is syncSkew or startupDelay. 
//! \param [inout]  *pGsyncDelay-   The caller provides LW_GSYNC_DELAY. skew and startDelay will be adjusted and updated to the closest values.
//! \param [out]  *syncSteps-       This parameter is optional. It returns the sync delay in unit steps. If 0, it means either the LW_GSYNC_DELAY::numPixels is less than LW_GSYNC_DELAY::minPixels or LW_GSYNC_DELAY::numOfLines exceeds the LW_GSYNC_DELAY::maxLines.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GSync_AdjustSyncDelay(__in LwGSyncDeviceHandle hLwGSyncDevice, __in LWAPI_GSYNC_DELAY_TYPE delayType, __inout LW_GSYNC_DELAY *pGsyncDelay, __out_opt LwU32* syncSteps);



//! Used in LwAPI_GSync_GetSyncStatus().
typedef struct _LW_GSYNC_STATUS
{
    LwU32 version;                          //!< Version of the structure
    LwU32 bIsSynced;                        //!< Is timing in sync?
    LwU32 bIsStereoSynced;                  //!< Does the phase of the timing signal from the GPU = the phase of the master sync signal?
    LwU32 bIsSyncSignalAvailable;           //!< Is the sync signal available?
} LW_GSYNC_STATUS;

//! Macro for constructing the version field for LW_GSYNC_STATUS.
#define LW_GSYNC_STATUS_VER  MAKE_LWAPI_VERSION(LW_GSYNC_STATUS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_GetSyncStatus
//
//!   DESCRIPTION: This API queries the sync status of a GPU - timing, stereosync and sync signal availability.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \since Release: 313
//!
//! \param [in]  hLwGSyncDevice-     Handle of the Sync device
//! \param [in]  hPhysicalGpu-       GPU to be queried for sync status.
//! \param [out] *status-            The caller provides the storage space. LwAPI_GSync_GetSyncStatus() populates *status with
//!                                  values - timing, stereosync and signal availability. On error, *status is set to NULL.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//! \retval ::LWAPI_ILWALID_ARGUMENT          hLwGSyncDevice is NULL / SyncTarget is NULL.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any G-Sync Device.
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GSync_GetSyncStatus(__in LwGSyncDeviceHandle hLwGSyncDevice, __in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_GSYNC_STATUS *status);


//! \ingroup gsyncapi

#define LWAPI_MAX_RJ45_PER_GSYNC    2

//! Used in LW_GSYNC_STATUS_PARAMS.
typedef enum _LWAPI_GSYNC_RJ45_IO
{
    LWAPI_GSYNC_RJ45_OUTPUT     = 0,
    LWAPI_GSYNC_RJ45_INPUT      = 1,
    LWAPI_GSYNC_RJ45_UNUSED     = 2 //!< This field is used to notify that the framelock is not actually present.

} LWAPI_GSYNC_RJ45_IO;

//! \ingroup gsyncapi
//! Used in LwAPI_GSync_GetStatusParameters().
typedef struct _LW_GSYNC_STATUS_PARAMS
{
    LwU32                       version;
    LwU32                       refreshRate;                                //!< The refresh rate
    LWAPI_GSYNC_RJ45_IO         RJ45_IO[LWAPI_MAX_RJ45_PER_GSYNC];          //!< Configured as input / output
    LwU32                       RJ45_Ethernet[LWAPI_MAX_RJ45_PER_GSYNC];    //!< Connected to ethernet hub? [ERRONEOUSLY CONNECTED!]
    LwU32                       houseSyncIncoming;                          //!< Incoming house sync frequency in Hz
    LwU32                       bHouseSync;                                 //!< Is house sync connected?
} LW_GSYNC_STATUS_PARAMS;


//! \ingroup gsyncapi
//! Macro for constructing the version field of LW_GSYNC_STATUS_PARAMS 
#define LW_GSYNC_STATUS_PARAMS_VER  MAKE_LWAPI_VERSION(LW_GSYNC_STATUS_PARAMS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_GetStatusParameters
//
//!   DESCRIPTION: This API queries for sync status parameters as defined in LW_GSYNC_STATUS_PARAMS.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 313
//!
//! \param [in]  hLwGSyncDevice   The caller provides the handle of the GSync device for which to get parameters
//! \param [out] *pStatusParams   The caller provides the storage space. LwAPI_GSync_GetStatusParameters populates *pStatusParams with
//!                               values.
//! 
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//! \retval ::LWAPI_ILWALID_ARGUMENT            hLwGSyncDevice is NULL / pStatusParams is NULL.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND     The queried Graphics system does not have any GSync Device.
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GSync_GetStatusParameters(LwGSyncDeviceHandle hLwGSyncDevice, LW_GSYNC_STATUS_PARAMS *pStatusParams);

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_EnumGSyncDevices
//
//!   DESCRIPTION: This API returns an array of GSync device handles. A GSync device handle represents a
//!                single GSync device on the system.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [out] lwGSyncHandles   The caller provides an array of handles, which must contain at least
//!                               LWAPI_MAX_GSYNC_DEVICES elements. The API will zero out the entire array and then fill in one
//!                               or more handles. If an error oclwrs, the array is invalid.
//! \param [out] *gsyncCount      The caller provides the storage space. LwAPI_EnumGSyncDevices
//!                               sets *gsyncCount to indicate how many of the elements in the lwGSyncHandles[] array are valid.
//!                               If an error oclwrs, *gsyncCount will be set to zero.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT         lwGSyncHandles or gsyncCount is NULL.
//! \retval ::LWAPI_OK                       One or more handles were returned.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any GSync Device.
//! \retval ::LWAPI_ERROR           
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_EnumGSyncDevices(LwGSyncDeviceHandle lwGSyncHandles[LWAPI_MAX_GSYNC_DEVICES], LwU32 *gsyncCount);


//! \addtogroup gsyncapi
//! @{

//Indicate the number of decimal places of accuracy that the G-Sync board supports when reporting/accepting refresh rates

//! Supported refresh rates reported to 2 decimal place accuracy.
#define LWAPI_GSYNC_CAPS_FLAG_FREQ_ACLWRACY_2DPS  (0x00000001)

//! Supported refresh rates reported to 3 decimal place accuracy.
#define LWAPI_GSYNC_CAPS_FLAG_FREQ_ACLWRACY_3DPS  (0x00000002)

//! Supported refresh rates reported to 4 decimal place accuracy.
#define LWAPI_GSYNC_CAPS_FLAG_FREQ_ACLWRACY_4DPS  (0x00000004)

//Indicate the types of events that the G-Sync board can report back to the client

//! G-Sync board can report sync-lock events to the client.
#define LWAPI_GSYNC_CAPS_FLAG_SYNC_LOCK_EVENT     (0x80000000)

//! G-Sync board can report house-sync events to the client.
#define LWAPI_GSYNC_CAPS_FLAG_HOUSE_SYNC_EVENT    (0x40000000)

//! G-Sync board can report frame-count events to the client.
#define LWAPI_GSYNC_CAPS_FLAG_FRAME_COUNT_EVENT   (0x20000000)


//gsync boardId values
#define LWAPI_GSYNC_BOARD_ID_P154 340 //!< GSync board ID 0x154, see LW_GSYNC_CAPABILITIES
#define LWAPI_GSYNC_BOARD_ID_P294 660 //!< GSync board ID 0x294, see LW_GSYNC_CAPABILITIES

//! @}

//! \addtogroup gsyncapi
//! @{

#define LWAPI_MAX_GPUS_PER_GSYNC                    4

//! Used in LW_GSYNC_TOPOLOGY.
typedef struct _LW_GSYNC_TOPOLOGY_TARGET
{
    LwU32                               version;
    LwPhysicalGpuHandle                 hPhysicalGpu;       //!< GPU handle
    LWAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR  connector;          //!< Indicates which connector on the device the GPU is connected to.
    LwPhysicalGpuHandle                 hProxyPhysicalGpu;  //!< GPU through which hPhysicalGpu is connected to the G-Sync device (if not directly connected)
                                                            //!<  - this is NULL otherwise
    LwU32                               bIsSynced;          //!< Whether this GPU is sync'd or not.
    LwU32                               displayCount;
    struct
    {
        LwDisplayHandle                 hLwDisplay;         //!< Handle for display (May be common for multiple displays if not in single view mode)
        LwU32                           displayMask;        //!< So the mask will distinguish among them
        LwU32                           bIsMasterable;      //!< Can this display be the master? (Read only)
        LWAPI_GSYNC_DISPLAY_SYNC_STATE  syncState;          //!< Is this display unsync'd/slave/master
                                                            //!< (Retrieved with topology or set by caller for enable/disable sync)
    } lwDisplays[LW_MAX_HEADS];     //!< May have 0 elements if no displays connected to GPU
                                    //!<  - And, this array needs to have at least one element when enabling / disabling sync.
} LW_GSYNC_TOPOLOGY_TARGET;

//! Macro for constructing the version field of LW_GSYNC_TOPOLOGY_TARGET. 
#define LW_GSYNC_TOPOLOGY_TARGET_VER  MAKE_LWAPI_VERSION(LW_GSYNC_TOPOLOGY_TARGET,1)


//! Used in LwAPI_GSync_QueryTopology().
typedef struct _LW_GSYNC_TOPOLOGY
{
    LwU32                       version;
    LwU32                       gsyncTargetCount;                       //!< The number of valid G-Sync targets
    LW_GSYNC_TOPOLOGY_TARGET    gsyncTarget[LWAPI_MAX_GPUS_PER_GSYNC];  //!< Array of G-Sync targets
} LW_GSYNC_TOPOLOGY;


//! @}



//! Macro for constructing the version field of LW_GSYNC_TOPOLOGY. 
#define LW_GSYNC_TOPOLOGY_VER  MAKE_LWAPI_VERSION(LW_GSYNC_TOPOLOGY,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_QueryTopology
//
//!   DESCRIPTION: This API returns the topology for the specified G-Sync device.
//!
//!                Note: Display handles can get ilwalidated on a modeset, so the calling applications need to
//!                requery the topology after every modeset.
//!   
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_GetTopology.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]   hLwGSyncDevice  The caller provides the handle for a GSync device for which the topology will
//!                               be queried.
//! \param [out] *pLwGPUTopology  The caller provides the storage space. LwAPI_GSync_QueryTopology sets *pLwGPUTopology
//!                to an object containing an array of all GPUs connected to the GSync device, their connectors, handles of their
//!                proxy GPUs(handle of GPU through which a GPU is connected to the GSync device) and displays on each GPU.
//!                LwDisplayHandle may be same for multiple displays in the structure if in clone or Mosaic modes. This API will
//!                return data on all active heads associated with a GPU, even ones on the slaves.
//!                If an error oclwrs, *pLwGPUTopology will be set to NULL.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT        hLwGSyncDevice is NULL.
//! \retval ::LWAPI_OK                      *pLwGPUTopology was populated.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND The queried Graphics system does not have any GSync Device.
//! \retval ::LWAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_GetTopology.")
LWAPI_INTERFACE LwAPI_GSync_QueryTopology(LwGSyncDeviceHandle hLwGSyncDevice, LW_GSYNC_TOPOLOGY *pLwGPUTopology);


//! \ingroup gsyncapi
//! Used in LwAPI_GSync_QueryStatusSignals().
typedef struct _LW_GSYNC_STATUS_SIGNALS
{
    LwU32   version;
    LwU32   RJ45[LWAPI_MAX_RJ45_PER_GSYNC];     //!< The RJ45 signals in Hz
    LwU32   house;                              //!< House sync signal in Hz
} LW_GSYNC_STATUS_SIGNALS;


//! \ingroup gsyncapi
//! Macro for constructing the version field of LW_GSYNC_STATUS_SIGNALS.
#define LW_GSYNC_STATUS_SIGNALS_VER  MAKE_LWAPI_VERSION(LW_GSYNC_STATUS_SIGNALS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_QueryStatusSignals
//
//!   DESCRIPTION: This API returns the status signals of the RJ45 and house sync for the specified G-Sync device.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]   hLwGSyncDevice         Handle of the G-Sync device for which the status signals will be queried.
//! \param [out] *pLwGSyncStatusSignals  The caller provides the storage space. LwAPI_GSync_QueryStatusSignals() sets 
//!                                      *pLwGSyncStatusSignals to the values of the RJ45 and house sync. 
//!                                      House = 0 => No signal and RJ45 = ~0 => Signal detected, but no rate info available.
//!                                      If an error oclwrs, *pLwGSyncStatusSignals will be set to NULL.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT         hLwGSyncDevice is NULL.
//! \retval ::LWAPI_OK                      *pLwGSyncStatusSignals was populated.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any GSync Device.
//! \retval ::LWAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GSync_QueryStatusSignals(LwGSyncDeviceHandle hLwGSyncDevice, LW_GSYNC_STATUS_SIGNALS *pLwGSyncStatusSignals);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_Signal_Event
//
//! \code
//!   DESCRIPTION: 1. Signal events coming from kmd/rm back to kmd to allow 
//!                further processing at kmd.
//!                2. Signal events for Sync state change.
//!
//!    PARAMETERS: hLwGSyncDevice[IN] - The caller provides the handle of the GSync device on 
//!                which the provided GPU is located. This can be NULL for systemwide events.
//!
//!                eventFlags[IN] - Notification flags. see LW_GSYNC_EVENT
//!
//!                
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: LWAPI_OK: completed request.
//!                LWAPI_ERROR: The operation failed.
//! \endcode
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GSync_Signal_Event(__in_opt LwGSyncDeviceHandle hLwGSyncDevice, __in LwU32 eventFlags);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_EnableSync
//
//!   DESCRIPTION: This API synchronizes the displays (as master or slaves) at the refresh rate provided.
//!
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_SetSyncStateSettings.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]       hLwGSyncDevice      Handle of the G-Sync device on which the provided GPU is located.
//! \param [out]      refreshRate         The desired refresh rate to be sync'd at. The value is in 0.0001 Hz.
//! \param [in,out]  *pLwGTopologyTarget  The caller provides the structure containing the GPU, and the displays
//!                                       on the GPU to be sync'd. Any display not sync'd will cause the corresponding
//!                                       handle in the structure to become NULL.
//!                                       If an error oclwrs, *pLwGTopologyTarget will be set to NULL.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT         hLwGSyncDevice is NULL; pLwGTopologyTarget is NULL.
//! \retval ::LWAPI_OK                       Master display and/or slave displays were sync'd.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any G-Sync Device; does not have a GPU 
//!                                          attached to the G-ync device; display handles are invalid.
//! \retval ::LWAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_SetSyncStateSettings.")
LWAPI_INTERFACE LwAPI_GSync_EnableSync(LwGSyncDeviceHandle hLwGSyncDevice, LW_GSYNC_TOPOLOGY_TARGET *pLwGTopologyTarget, LwU32 refreshRate);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_DisableSync
//
//!   DESCRIPTION: This API unsynchronizes the displays.
//!
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_SetSyncStateSettings.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]      hLwGSyncDevice     The handle of the G-Sync device on which the provided GPU is located.
//! \param [in]      retainMaster       The caller provides whether to keep a display as master even after unsync'ing.
//! \param [in,out] *pLwGTopologyTarget The caller provides the structure containing the GPU, and the displays on the GPU to be unsync'd.
//!                                     If an error oclwrs, *pLwGTopologyTarget will be set to NULL.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT         hLwGSyncDevice is NULL; pLwGTopologyTarget is NULL.
//! \retval ::LWAPI_OK                       Master and/or slave displays were unsync'd.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have a G-Sync Device, or does not have a GPU attached to
//!                                          the G-Sync device.
//! \retval ::LWAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_SetSyncStateSettings.")
LWAPI_INTERFACE LwAPI_GSync_DisableSync(LwGSyncDeviceHandle hLwGSyncDevice, LW_GSYNC_TOPOLOGY_TARGET *pLwGTopologyTarget, LwU32 retainMaster);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_SetSyncState
//
//! \code
//!   DESCRIPTION: Sets a new sync state for the displays contained in the given pLwGTopology.
//!                The refreshrate is taken into account in case at least a framelock master or slave is contained in the topology.
//!
//!    PARAMETERS: hLwGSyncDevice[IN] - The caller provides the handle of the GSync device on which the provided GPUs are located.
//!
//!                refreshRate[IN] - The caller provides the desired refresh rate to be synced at. The value is in 0.0001 Hertz
//!
//!                *pLwGTopology[IN|OUT] - The caller provides the structure containing all GPUs connected to a gsync device, and the
//!                displays on the GPUs to be synced. 
//!                Any display which should not be synced should get it's syncState set to LWAPI_GSYNC_DISPLAY_SYNC_STATE_UNSYNCED.
//!                The bIsSynced member of the LW_GSYNC_TOPOLOGY_TARGET is ignored in the call.
//!                This API ensures the atomicity. 
//!                This API takes care of all the Quadroplex models including D4 and non-Quadroplex.
//!
//!                If an error oclwrs, *pLwGTopology will be set to the current hw state.
//!                In case a gpu or displayhandle could not be found, the target is set the NULL.
//!
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_SetSyncStateSettings.
//! SUPPORTED OS:  Windows XP and higher
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: hLwGSyncDevice is NULL / pLwGTopology is NULL.
//!                LWAPI_OK: Master display and/or slave displays were synced.
//!                LWAPI_LWIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any GSync Device / does not have a GPU attached to
//!                the GSync device / display handles are invalid.
//!                LWAPI_ERROR: The operation failed.
//! \endcode
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_SetSyncStateSettings.")
LWAPI_INTERFACE LwAPI_GSync_SetSyncState(LwGSyncDeviceHandle hLwGSyncDevice, LW_GSYNC_TOPOLOGY *pLwGPUTopology, LwU32 refreshRate);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_UpdateSyncPolarity
//
//!   DESCRIPTION: This API sets which edge of the source signal to use to generate the output sync pulse - leading edge, falling edge, or both.
//!
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_SetControlParameters.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]  hLwGSyncDevice   Handle of the G-Sync device for which to set the sync polarity.
//! \param [in]  polarity         Rising / Falling / Both
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT         hLwGSyncDevice is NULL; polarity is invalid.
//! \retval ::LWAPI_OK                       Polarity set.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND  The queried graphics system does not have any G-Sync Device.
//! \retval ::LWAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_SetControlParameters.")
LWAPI_INTERFACE LwAPI_GSync_UpdateSyncPolarity(LwGSyncDeviceHandle hLwGSyncDevice, LWAPI_GSYNC_POLARITY polarity);


//! \ingroup gsyncapi

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_UpdateVideoMode
//
//!   DESCRIPTION: This API sets the video mode to either None, TTL, NTSCPALSECAM, or HDTV.
//!
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_SetControlParameters.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]    hLwGSyncDevice  Handle of the G-Sync device for which to set video mode.
//! \param [in]    vmode          The video mode - None, TTL, NTSCPALSECAM, or HDTV
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT        hLwGSyncDevice is NULL; vmode is invalid.
//! \retval ::LWAPI_OK                      Video mode set.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND The queried Graphics system does not have any GSync Device.
//! \retval ::LWAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_SetControlParameters.")
LWAPI_INTERFACE LwAPI_GSync_UpdateVideoMode(LwGSyncDeviceHandle hLwGSyncDevice, LWAPI_GSYNC_VIDEO_MODE vmode);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_UpdateSyncInterval
//
//!   DESCRIPTION: This API sets the sync interval, or the number of pulses to wait between sync signals.
//!
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_SetControlParameters.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]  hLwGSyncDevice  Handle of the G-Sync device for which to set the sync interval.
//! \param [in]  interval        The number of pulses to skip for signal generation. 0 uses source, 1 gives half the frequency, and so on.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT         hLwGSyncDevice is NULL / interval is invalid.
//! \retval ::LWAPI_OK                       Interval set.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any G-Sync Device.
//! \retval ::LWAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_SetControlParameters.")
LWAPI_INTERFACE LwAPI_GSync_UpdateSyncInterval(LwGSyncDeviceHandle hLwGSyncDevice, LwU32 interval);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_UpdateSyncSkew
//
//!   DESCRIPTION: This API sets the sync skew.
//!
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_SetControlParameters.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]   hLwGSyncDevice   Handle of the G-Sync device for which to set the skew.
//! \param [in]   skew             The time delay between the frame sync signal and the GPU's signal in units of 7.81 us; maximum 15.99 ms.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT         hLwGSyncDevice is NULL / skew is invalid.
//! \retval ::LWAPI_OK                       Skew is set.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any G-Sync Device.
//! \retval ::LWAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_SetControlParameters.")
LWAPI_INTERFACE LwAPI_GSync_UpdateSyncSkew(LwGSyncDeviceHandle hLwGSyncDevice, LwS32 skew);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_UpdateSyncStartDelay
//
//!   DESCRIPTION: This API sets the sync start delay for the master.
//!   
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_SetControlParameters.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]  hLwGSyncDevice     Handle of the GSync device for which to set start delay
//! \param [in]  startDelay         The amount of time to wait before generating the first sync pulse, in units of 7.81 us; maximum 64 ms
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT          hLwGSyncDevice is NULL / startDelay is invalid.
//! \retval ::LWAPI_OK                        Delay set.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any G-Sync Device.
//! \retval ::LWAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_SetControlParameters.")
LWAPI_INTERFACE LwAPI_GSync_UpdateSyncStartDelay(LwGSyncDeviceHandle hLwGSyncDevice, LwS32 startDelay);


//! \ingroup gsyncapi

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_UpdateSyncSource
//
//!   DESCRIPTION: This API sets the sync source for the G-Sync device provided.
//!   
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_SetControlParameters.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]  hLwGSyncDevice     Handle of the GSync device for which to set the sync source.
//! \param [in]  source             Either VSync or House sync to be set as the source.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT         hLwGSyncDevice is NULL; source is invalid.
//! \retval ::LWAPI_OK                       Source set.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any G-Sync Device.
//! \retval ::LWAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_SetControlParameters.")
LWAPI_INTERFACE LwAPI_GSync_UpdateSyncSource(LwGSyncDeviceHandle hLwGSyncDevice, LWAPI_GSYNC_SYNC_SOURCE source);



//! \ingroup gsyncapi
//! Used in LwAPI_GSync_QuerySyncParameters().
typedef struct _LW_GSYNC_PARAMS
{
    LwU32                       version;
    LWAPI_GSYNC_POLARITY        polarity;           //!< Leading edge / Falling edge / both
    LWAPI_GSYNC_VIDEO_MODE      vmode;              //!< None, TTL, NTSCPALSECAM, HDTV
    LwU32                       interval;           //!< Number of pulses to wait between framelock signal generation
    LwS32                       skew;               //!< The time delay between the frame sync signal and the GPUs signal
    LwS32                       startDelay;         //!< Sync start delay for master
    LWAPI_GSYNC_SYNC_SOURCE     source;             //!< VSync / House sync
    LwU32                       refreshRate;        //!< The refresh rate
    LWAPI_GSYNC_RJ45_IO         RJ45_IO[LWAPI_MAX_RJ45_PER_GSYNC];          //!< Configured as input / output
    LwU32                       RJ45_Ethernet[LWAPI_MAX_RJ45_PER_GSYNC];    //!< Connected to ethernet hub? [ERRONEOUSLY CONNECTED!]
} LW_GSYNC_PARAMS;


//! \ingroup gsyncapi
//! Macro for contructing the version field of LW_GSYNC_PARAMS.
#define LW_GSYNC_PARAMS_VER  MAKE_LWAPI_VERSION(LW_GSYNC_PARAMS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_QuerySyncParameters
//
//!   DESCRIPTION: Queries for all sync parameters as defined in LW_GSYNC_PARAMS
//!
//! \deprecated  Do not use this function - it is deprecated in release 313. Instead, use following functions: LwAPI_GSync_GetStatusParameters, and, LwAPI_GSync_GetControlParameters.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]   hLwGSyncDevice    Handle of the GSync device for which to set start delay
//! \param [out] *pVals             The caller provides the storage space. LwAPI_GSync_QuerySyncParameters() populates *pVals with
//!                                 values. On error, *pVals is set to NULL.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT          hLwGSyncDevice is NULL.
//! \retval ::LWAPI_OK                       *pVals populated with values.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any G-Sync Device.
//! \retval ::LWAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 313. Instead, use following functions: LwAPI_GSync_GetStatusParameters, and, LwAPI_GSync_GetControlParameters.")
LWAPI_INTERFACE LwAPI_GSync_QuerySyncParameters(LwGSyncDeviceHandle hLwGSyncDevice, LW_GSYNC_PARAMS *pVals);



//! \ingroup gsyncapi
//////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_QuerySyncStatus
//
//!   DESCRIPTION: This API queries the sync status of a GPU - timing, stereosync and sync signal availability.
//!   
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_GetSyncStatus.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]  hLwGSyncDevice     Handle of the GSync device for which to set start delay
//! \param [in]  gsyncTarget        GPU to be queried for sync status. The displays (if any are specified) are ignored.
//! \param [out] *pStatus           The caller provides the storage space. LwAPI_GSync_QuerySyncStatus() populates *pStatus with
//!                                 values - timing, stereosync and signal availability. On error, *pStatus is set to NULL.
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT          hLwGSyncDevice is NULL / gsyncTarget is NULL.
//! \retval ::LWAPI_OK                       *pStatus populated with values.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any G-Sync Device.
//! \retval ::LWAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_GetSyncStatus.")
LWAPI_INTERFACE LwAPI_GSync_QuerySyncStatus(LwGSyncDeviceHandle hLwGSyncDevice, LW_GSYNC_TOPOLOGY_TARGET gsyncTarget, LW_GSYNC_STATUS *pStatus);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_UpdateInterlaceMode
//
//!   DESCRIPTION: This API enables/disables interlace mode for a G-Sync device.
//!   
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_SetControlParameters.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]  hLwGSyncDevice     Handle of the GSync device for which to set start delay
//! \param [in]  state              Enable = 1, Disable = 0
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT          hLwGSyncDevice is NULL.
//! \retval ::LWAPI_OK                        Interlace mode enabled.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any G-Sync Device.
//! \retval ::LWAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_SetControlParameters.")
LWAPI_INTERFACE LwAPI_GSync_UpdateInterlaceMode(LwGSyncDeviceHandle hLwGSyncDevice, LwU32 state);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_QueryInterlaceMode
//
//!   DESCRIPTION: This API queries the state of the interlace mode (enabled/disabled) for a G-Sync device
//!  
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_GetControlParameters.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]   hLwGSyncDevice     Handle of the GSync device for which to set start delay
//! \param [out] *pState             Interlace mode enabled = 1, disabled = 0
//!
//! \retval ::LWAPI_ILWALID_ARGUMENT          hLwGSyncDevice is NULL.
//! \retval ::LWAPI_OK                        Interlace mode returned.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any G-Sync Device.
//! \retval ::LWAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use LwAPI_GSync_GetControlParameters.")
LWAPI_INTERFACE LwAPI_GSync_QueryInterlaceMode(LwGSyncDeviceHandle hLwGSyncDevice, LwU32 *pState);


//! \ingroup gsyncapi
//! @{

typedef enum _LWAPI_GSYNC_DIAGNOSTIC_LOCK_STATE
{
    LWAPI_GSYNC_DIAGNOSTIC_LOCK_NONE        = 0,
    LWAPI_GSYNC_DIAGNOSTIC_LOCK_FRAMELOCK   = 1,
    LWAPI_GSYNC_DIAGNOSTIC_LOCK_RASTERLOCK  = 3,
} LWAPI_GSYNC_DIAGNOSTIC_LOCK_STATE;

typedef enum _LWAPI_GSYNC_DIAGNOSTIC_RM_LOCK_STATE
{
    LWAPI_GSYNC_DIAGNOSTIC_RM_LOCK_NONE      = 0,
    LWAPI_GSYNC_DIAGNOSTIC_RM_LOCK_MASTER    = 1,
    LWAPI_GSYNC_DIAGNOSTIC_RM_LOCK_SLAVE     = 2,
} LWAPI_GSYNC_DIAGNOSTIC_RM_LOCK_STATE;

//! specify a signal path from or to the GPU
typedef enum _LWAPI_GSYNC_DIAGNOSTIC_PIN
{
    LWAPI_GSYNC_DIAGNOSTIC_PIN_INTERNAL  = 0,   //!< inside GPU between two heads
    LWAPI_GSYNC_DIAGNOSTIC_PIN_0         = 1,   //!< through different GPIO of GPU
    LWAPI_GSYNC_DIAGNOSTIC_PIN_1         = 2,
    LWAPI_GSYNC_DIAGNOSTIC_PIN_2         = 3,
    LWAPI_GSYNC_DIAGNOSTIC_PIN_3         = 4,
} LWAPI_GSYNC_DIAGNOSTIC_PIN;

typedef struct _LWAPI_GSYNC_DIAGNOSTIC_PARAMS
{
    LwU32                                version;
    LWAPI_GSYNC_DIAGNOSTIC_LOCK_STATE    masterLockState;       //!< master lock mode
    LWAPI_GSYNC_DIAGNOSTIC_PIN           masterLockPin;         //!< lock to which GPIO
    LWAPI_GSYNC_DIAGNOSTIC_LOCK_STATE    slaveLockState;
    LWAPI_GSYNC_DIAGNOSTIC_PIN           slaveLockPin;
    LWAPI_GSYNC_DIAGNOSTIC_PIN           stereoPin;
    LwU8                                 modeTweaking;          //!< whether display driver needs to be adjusted for better synchronization
    LWAPI_GSYNC_DIAGNOSTIC_RM_LOCK_STATE rmFramelockState;      //!< framelock state in RM
    LwU8                                 stereoLock;            //!< Is stereo locked?
    LwU8                                 syncLock;              //!< Is synced?
    LwU8                                 primary;               //!< Is primary or secondary?
    // Mode related information    
    LwU32                                refreshRateX10k;
    LwU32                                hBlankStart;
    LwU32                                hSyncEnd;
    LwU32                                hBlankEnd;
    LwU32                                hTotal;
    LwU32                                vBlankStart;
    LwU32                                vSyncEnd;
    LwU32                                vBlankEnd;
    LwU32                                vTotal;
    LwU32                                vInterlacedBlankEnd;
    LwU32                                vInterlacedBlankStart;
    LwU32                                pixelClockHz;
    LwU8                                 interlaced;
} LWAPI_GSYNC_DIAGNOSTIC_PARAMS;

//! Macro for constructing the version field of ::LWAPI_GSYNC_DIAGNOSTIC_PARAMS
#define LW_GSYNC_DIAGNOSTIC_PARAMS_VER  MAKE_LWAPI_VERSION(LWAPI_GSYNC_DIAGNOSTIC_PARAMS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_Get_DiagnosticSettings
//
//! \code
//!   DESCRIPTION: Queries for all sync parameters as defined in LWAPI_GSYNC_DIAGNOSTIC_PARAMS
//!
//!    PARAMETERS: hLwDisplay[IN]  - The caller provides the handle of the display for which to get parameters
//!                outputId[IN] - In lwiew mode a displaymask is alse needed to define the monitor for which to get parameters
//!
//!                *pDiagParams[OUT] - The caller provides the storage space. LwAPI_GSync_Diag populates *pDiagParams with
//!                                        values. On error, *pDiagParams is set to NULL.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: LWAPI_OK: *pDiagParams populated with values.
//!                LWAPI_ILWALID_ARGUMENT: outputId/pDiagParams is NULL.
//!                LWAPI_EXPECTED_DISPLAY_HANDLE: invalid diaplay handle.
//!                LWAPI_ERROR: The operation failed.
//!                LWAPI_API_NOT_INTIALIZED
//!                LWAPI_INCOMPATIBLE_STRUCT_VERSION
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GSync_Get_DiagnosticSettings(LwDisplayHandle hLwDisplay, LwU32 outputId, LWAPI_GSYNC_DIAGNOSTIC_PARAMS *pDiagParams);

//! \ingroup gsyncapi
//! @
typedef enum _LW_GSYNC_REG_OP_CMD
{
    LW_GSYNC_REG_OP_READ             = 0x00000001, //!< read operation
    LW_GSYNC_REG_OP_WRITE            = 0x00000002, //!< write operation
} LW_GSYNC_REG_OP_CMD;

typedef enum _LW_GSYNC_REG
{
    LW_GSYNC_REG_FLASH_BOOT_STATUS    = 0x00000001, //!<boot_status register
    LW_GSYNC_REG_FLASH_CMD            = 0x00000002, //!<flash command register
    LW_GSYNC_REG_FLASH_ADDRESS        = 0x00000003, //!<flash address register
    LW_GSYNC_REG_FLASH_DATA           = 0x00000004, //!<flash data register
    LW_GSYNC_REG_FLASH_CHECKSUM       = 0x00000005, //!<flash checksum register
    LW_GSYNC_REG_SOFT_RESET           = 0x00000006, //!<Soft Reset register
} LW_GSYNC_REG;

typedef struct _LW_GSYNC_REG_DATA
{
    LwU32              version;    //!< structure version 
    LW_GSYNC_REG_OP_CMD   cmd;
    LW_GSYNC_REG          reg;         //!< register
    LwU32                 value : 8;     //!< value in register. lwrrently 8 bits used only
    LwU32                 reserved : 24; //!< reserved
} LW_GSYNC_REG_DATA;

#define LW_GSYNC_REG_DATA_VER  MAKE_LWAPI_VERSION(LW_GSYNC_REG_DATA, 1)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_RegOp
//
//!  DESCRIPTION: This API reads/writes gsync register. It is used to flash firmware.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 304
//!
//! \param [in]   hLwGSyncDevice  The caller provides the handle for a GSync device on which register is being read/written
//! \param [out]  regData   pointer to LW_GSYNC_REG_DATA
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GSync_RegOp(__in LwGSyncDeviceHandle hLwGSyncDevice, __inout LW_GSYNC_REG_DATA *regData);

//! \ingroup gsyncapi

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GSync_FPGAFlashHelper
//
//!  DESCRIPTION: This API does pre-flash and post-flash operations on Gsync card.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 304
//!
//! \param [in]   hLwGSyncDevice  The caller provides the handle for a GSync device on which register is being read/written
//! \param [in]   isPreFlash      It specifies whether caller wants to do pre-flash(isPreFlash = 1) operation or post-flash(isPreFlash = 0) operation.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GSync_FPGAFlashHelper(__in LwGSyncDeviceHandle hLwGSyncDevice, __in LwU8 isPreFlash);

//! @}

//! Prototype structure version, check common/inc/FrameDebuggerStruct.h for versions
//! lwrrently supported by the driver!
//! \ingroup nsightapi
typedef struct _fdStatsReport
{
    LwU32 structVersion;
} fdStatsReport;

#define FD_STATS_REPORT_STRUCT_VERSION_V0 MAKE_LWAPI_VERSION(fdStatsReport, 0)

typedef void (__cdecl *fdStatsReportsCompletedCallback)(void *pCallbackData, fdStatsReport *pStartReport, LwU32 reportCount);

//-----------------------------------------------------------------------------
// DirectX APIs
//-----------------------------------------------------------------------------


//! \ingroup dx
//! Used in LwAPI_D3D10_GetLwrrentSLIState(), and LwAPI_D3D_GetLwrrentSLIState().
typedef struct
{
    LwU32 version;                    //!< Structure version
    LwU32 maxNumAFRGroups;            //!< [OUT] The maximum possible value of numAFRGroups
    LwU32 numAFRGroups;               //!< [OUT] The number of AFR groups enabled in the system
    LwU32 lwrrentAFRIndex;            //!< [OUT] The AFR group index for the frame lwrrently being rendered
    LwU32 nextFrameAFRIndex;          //!< [OUT] What the AFR group index will be for the next frame (i.e. after calling Present)
    LwU32 previousFrameAFRIndex;      //!< [OUT] The AFR group index that was used for the previous frame (~0 if more than one frame has not been rendered yet)
    LwU32 bIsLwrAFRGroupNew;          //!< [OUT] Boolean: Is this frame the first time running on the current AFR group

} LW_GET_LWRRENT_SLI_STATE;

//! \ingroup dx
#define LW_GET_LWRRENT_SLI_STATE_VER  MAKE_LWAPI_VERSION(LW_GET_LWRRENT_SLI_STATE,1)


#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
//! \ingroup dx
//! D3D_FEATURE_LEVEL supported - used in LwAPI_D3D11_CreateDevice() and LwAPI_D3D11_CreateDeviceAndSwapChain()
typedef enum
{
    LWAPI_DEVICE_FEATURE_LEVEL_NULL       = -1,
    LWAPI_DEVICE_FEATURE_LEVEL_10_0       = 0,
    LWAPI_DEVICE_FEATURE_LEVEL_10_0_PLUS  = 1,
    LWAPI_DEVICE_FEATURE_LEVEL_10_1       = 2,
    LWAPI_DEVICE_FEATURE_LEVEL_11_0       = 3,
} LWAPI_DEVICE_FEATURE_LEVEL;

#endif  //defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))

#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

LW_DECLARE_HANDLE(LWDX_ObjectHandle);  // DX Objects
static const LWDX_ObjectHandle LWDX_OBJECT_NONE = 0;

#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

//! \ingroup nsightapi
typedef enum
{
    PCD_NEXUS_FRAME_AND_DC_INDEX,  //!< [31:24] FrameID [23:0] DrawCallID
    PCD_NEXUS_DC_EXTRA_INFO,
    PCD_NEXUS_TRAP_HANDLER_DUMP_GPU_VIRTUAL_ADDRESS,
    
    // Compute specific slots
    PCD_NEXUS_COMPUTE_START,
    PCD_NEXUS_COMPUTE_FRAME_AND_DC_INDEX = PCD_NEXUS_COMPUTE_START,
    PCD_NEXUS_COMPUTE_DC_EXTRA_INFO,
    
    PCD_COUNT
} LwAPIPrivateConstDataSlot;

//! Prototype structure version, check common/inc/ShaderDebuggerStruct.h for versions
//! lwrrently supported by the driver!
//! \ingroup nsightapi
typedef struct _sdRmHandlesCollection
{
    LwU32 structVersion;
} sdRmHandlesCollection;

//! \ingroup nsightapi
#define SD_RM_HANDLES_COLLECTION_STRUCT_VERSION_V0 MAKE_LWAPI_VERSION(sdRmHandlesCollection, 0)

//! Prototype structure version, check common/inc/ShaderDebuggerStruct.h for versions
//! lwrrently supported by the driver!
//! \ingroup nsightapi
typedef struct _sdWarpSemaphoreReport
{
    LwU32 structVersion;
} sdWarpSemaphoreReport;

//! \ingroup nsightapi
#define SD_WARP_SEMAPHORE_REPORT_VERSION_V0 MAKE_LWAPI_VERSION(sdWarpSemaphoreReport, 0)

#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D_GetLwrrentSLIState
//
//! DESCRIPTION:     This function returns the current SLI state for the specified device.  The structure
//!                  contains the number of AFR groups, the current AFR group index,
//!                  and what the AFR group index will be for the next frame. \p
//!                  pDevice can be either a IDirect3DDevice9 or ID3D10Device pointer.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 173
//!
//! \retval         LWAPI_OK     Completed request
//! \retval         LWAPI_ERROR  Error oclwrred
//!
//! \ingroup  dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D_GetLwrrentSLIState(IUnknown *pDevice, LW_GET_LWRRENT_SLI_STATE *pSliState);
#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_RegisterResource
//
//! DESCRIPTION:    This API binds a resource (surface/texture) so that it can be retrieved
//!                 internally by LWAPI.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! \param [in]     pResource      surface/texture
//!
//! \return ::LWAPI_OK, ::LWAPI_ERROR 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_RegisterResource(IDirect3DResource9* pResource);
#endif //defined(_D3D9_H_)
#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_UnregisterResource
//
//! DESCRIPTION:     This API unbinds a resource (surface/texture) after use.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! 
//! \param [in]     pResource    surface/texture
//!
//! \return ::LWAPI_OK, ::LWAPI_ERROR 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_UnregisterResource(IDirect3DResource9* pResource);

#endif //defined(_D3D9_H_)



#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_AliasSurfaceAsTexture
//
//! \fn LwAPI_D3D9_AliasSurfaceAsTexture(IDirect3DDevice9* pDev,
//!                                              IDirect3DSurface9* pSurface,
//!                                              IDirect3DTexture9 **ppTexture,
//!                                              DWORD dwFlag);
//!   DESCRIPTION: Create a texture that is an alias of a surface registered with LwAPI.  The
//!                new texture can be bound with IDirect3DDevice9::SetTexture().  Note that the texture must
//!                be unbound before drawing to the surface again.
//!                Unless the USE_SUPER flag is passed, MSAA surfaces will be resolved before
//!                being used as a texture.  MSAA depth buffers are resolved with a point filter,
//!                and non-depth MSAA surfaces are resolved with a linear filter.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]    pDev         The D3D device that owns the objects
//! \param [in]    pSurface     Pointer to a surface that has been registered with LwAPI 
//!                             to which a texture alias is to be provided
//! \param [out]   ppTexture    Fill with the texture created
//! \param [in]    dwFlag       LWAPI_ALIAS_SURFACE_FLAG to describe how to handle the texture
//!
//! \retval ::LWAPI_OK                  completed request
//! \retval ::LWAPI_ILWALID_POINTER     A null pointer was passed as an argument
//! \retval ::LWAPI_ILWALID_ARGUMENT    One of the arguments was invalid, probably dwFlag.
//! \retval ::LWAPI_UNREGISTERED_RESOURCE pSurface has not been registered with LwAPI
//! \retval ::LWAPI_ERROR               error oclwrred
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup dx
//! See LwAPI_D3D9_AliasSurfaceAsTexture().
typedef enum {
    LWAPI_ALIAS_SURFACE_FLAG_NONE                     = 0x00000000,
    LWAPI_ALIAS_SURFACE_FLAG_USE_SUPER                = 0x00000001,  //!< Use the surface's msaa buffer directly as a texture, rather than resolving. (This is much slower, but potentially has higher quality.)
    LWAPI_ALIAS_SURFACE_FLAG_MASK                     = 0x00000001
} LWAPI_ALIAS_SURFACE_FLAG;


//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D9_AliasSurfaceAsTexture(IDirect3DDevice9* pDev,
                                                 IDirect3DSurface9* pSurface,
                                                 IDirect3DTexture9 **ppTexture,
                                                 DWORD dwFlag);
#endif //defined(_D3D9_H_)
#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_StretchRectEx
//
//! DESCRIPTION:     This API copies the contents of the source resource to the destination
//!                  resource.  This function can colwert
//!                  between a wider range of surfaces than
//!                  IDirect3DDevice9::StretchRect.  For example, it can copy
//!                  from a depth/stencil surface to a texture.
//!
//!                  The source and destination resources *must* be registered
//!                  with LwAPI before being used with LwAPI_D3D9_StretchRectEx().
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     pDevice             The D3D device that owns the objects.
//! \param [in]     pSourceResource     Pointer to the source resource.
//! \param [in]     pSrcRect            Defines the rectangle on the source to copy from.  If NULL, copy from the entire resource.
//! \param [in]     pDestResource       Pointer to the destination resource.
//! \param [in]     pDstRect            Defines the rectangle on the destination to copy to.  If NULL, copy to the entire resource.
//! \param [in]     Filter              Choose a filtering method: D3DTEXF_NONE, D3DTEXF_POINT, D3DTEXF_LINEAR.
//!
//! \retval ::LWAPI_OK                       completed request
//! \retval ::LWAPI_ILWALID_POINTER          An invalid pointer was passed as an argument (probably NULL)
//! \retval ::LWAPI_ILWALID_ARGUMENT         One of the arguments was invalid
//! \retval ::LWAPI_UNREGISTERED_RESOURCE    a resource was passed in without being registered
//! \retval ::LWAPI_ERROR                    error oclwrred
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_StretchRectEx(IDirect3DDevice9 * pDevice,
                                         IDirect3DResource9 * pSourceResource,
                                         CONST RECT * pSourceRect,
                                         IDirect3DResource9 * pDestResource,
                                         CONST RECT * pDestRect,
                                         D3DTEXTUREFILTERTYPE Filter);

#endif //defined(_D3D9_H_)
#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_ClearRT
//
//! DESCRIPTION:     This API Clears the lwrrently bound render target(s) with the 
//!                  given color
//!
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     pDevice             The D3D device that owns the objects.
//! \param [in]     dwNumRects          The no of rectangles to clear. If 0, clear the entire surface (clipped to viewport)
//! \param [in]     pRects              Defines the rectangles to clear.  Should be NULL if dwNumRects == 0
//! \param [in]     r                   red component of the clear color
//! \param [in]     g                   green component of the clear color
//! \param [in]     b                   blue component of the clear color
//! \param [in]     a                   alpha component of the clear color
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_ClearRT(IDirect3DDevice9 * pDevice,
                                   LwU32 dwNumRects,
                                   CONST RECT * pRects,
                                   float r, float g, float b, float a);
#endif //if defined(_D3D9_H_)



#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D_GetObjectHandleForResource
//
//!   DESCRIPTION: This API gets a handle to a resource.
//!
//! \param [in]  pDev       The ID3D11Device, ID3D10Device or IDirect3DDevice9 to use
//! \param [in]  pResource  The ID3D10Resource, ID3D10Resource or IDirect3DResource9 from which
//!                         we want the LwAPI handle
//! \param [out]  pHandle   A handle to the resource
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \return ::LWAPI_OK if the handle was populated.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D_GetObjectHandleForResource(
    IUnknown *pDevice,
    IUnknown *pResource,
    LWDX_ObjectHandle *pHandle);


#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)


#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D_SetDriverDebugState (for DX9/DX10)
//
//! DESCRIPTION:     This function sets the internal driver state that affects debugging code.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]        stateEnum    internal state to change (usually encoded as 'fourcc' name)
//! \param [in]        stateValue   new state value
//!
//! \retval ::LWAPI_OK     If the state changed was committed
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D_SetDriverDebugState(IUnknown *pDev,
                                              LwU32     stateEnum,
                                              LwU32     stateValue);
#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D_SetDriverDebugState (for DX11)
//
//! DESCRIPTION:     This function sets the internal driver state that affects debugging code.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in] stateEnum    internal state to change (usually encoded as 'fourcc' name)
//! \param [in] stateValue   new state value
//!
//! \retval ::LWAPI_OK     if the state changed was committed
//!
//! \ingroup dx 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_SetDriverDebugState(ID3D11DeviceContext *pDc,
                                                LwU32                stateEnum,
                                                LwU32                stateValue);
#endif  //defined(__d3d11_h__)
#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)


#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D_SetResourceHint
//
//! \fn LwAPI_D3D_SetResourceHint(IUnknown *pDev, LWDX_ObjectHandle obj,
//!                                          LWAPI_D3D_SETRESOURCEHINT_CATEGORY dwHintCategory, 
//!                                          LwU32 dwHintName, 
//!                                          LwU32 *pdwHintValue)
//!
//!   DESCRIPTION: This is a general purpose function for passing down various resource
//!                related hints to the driver. Hints are divided into categories
//!                and types within each category.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in] pDev            The ID3D10Device or IDirect3DDevice9 that is a using the resource
//! \param [in] obj             Previously obtained HV resource handle
//! \param [in] dwHintCategory  Category of the hints
//! \param [in] dwHintName      A hint within this category
//! \param [in] *pdwHintValue   Pointer to location containing hint value
//!
//! \return an int which could be an LwAPI status or DX HRESULT code
//!
//! \retval ::LWAPI_OK               
//! \retval ::LWAPI_ILWALID_ARGUMENT  
//! \retval ::LWAPI_ILWALID_CALL     It is illegal to change a hint dynamically when the resource is already bound.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//! \ingroup dx
//! Valid categories for LwAPI_D3D_SetResourceHint()
typedef enum _LWAPI_D3D_SETRESOURCEHINT_CATEGORY
{
    LWAPI_D3D_SRH_CATEGORY_SLI = 1
} LWAPI_D3D_SETRESOURCEHINT_CATEGORY;


//
//  LWAPI_D3D_SRH_SLI_APP_CONTROLLED_INTERFRAME_CONTENT_SYNC: 


//! \ingroup dx
//!  Types of SLI hints; \n
//!  LWAPI_D3D_SRH_SLI_APP_CONTROLLED_INTERFRAME_CONTENT_SYNC: Valid values : 0 or 1 \n
//!  Default value: 0 \n
//!  Explanation: If the value is 1, the driver will not track any rendering operations that would mark this resource as dirty, 
//!  avoiding any form of synchronization across frames rendered in parallel in multiple GPUs in AFR mode.
typedef enum _LWAPI_D3D_SETRESOURCEHINT_SLI
{
    LWAPI_D3D_SRH_SLI_APP_CONTROLLED_INTERFRAME_CONTENT_SYNC = 1
}  LWAPI_D3D_SETRESOURCEHINT_SLI;

//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D_SetResourceHint(IUnknown *pDev, LWDX_ObjectHandle obj,
                                          LWAPI_D3D_SETRESOURCEHINT_CATEGORY dwHintCategory, 
                                          LwU32 dwHintName, 
                                          LwU32 *pdwHintValue);
#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D_BeginResourceRendering
//
//! \fn LwAPI_D3D_BeginResourceRendering(IUnknown *pDev, LWDX_ObjectHandle obj, LwU32 Flags)
//!   DESCRIPTION: This function tells the driver that the resource will begin to receive updates. It must be used in combination with LwAPI_D3D_EndResourceRendering(). 
//!                The primary use of this function is allow the driver to initiate early inter-frame synchronization of resources while running in AFR SLI mode. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]  pDev         The ID3D10Device or IDirect3DDevice9 that is a using the resource
//! \param [in]  obj          Previously obtained HV resource handle
//! \param [in]  Flags        The flags for functionality applied to resource while being used.
//!
//! \retval ::LWAPI_OK                Function succeeded, if used properly and driver can initiate proper sync'ing of the resources.
//! \retval ::LWAPI_ILWALID_ARGUMENT  Bad argument(s) or invalid flag values
//! \retval ::LWAPI_ILWALID_CALL      Mismatched begin/end calls
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dx
//! Used in LwAPI_D3D_BeginResourceRendering().
typedef enum  _LWAPI_D3D_RESOURCERENDERING_FLAG
{
    LWAPI_D3D_RR_FLAG_DEFAULTS                 = 0x00000000,  //!< All bits set to 0 are defaults.
    LWAPI_D3D_RR_FLAG_FORCE_DISCARD_CONTENT    = 0x00000001,  //!< (bit 0) The flag forces to discard previous content of the resource regardless of the LwApiHints_Sli_Disable_InterframeSync hint
    LWAPI_D3D_RR_FLAG_FORCE_KEEP_CONTENT       = 0x00000002,   //!< (bit 1) The flag forces to respect previous content of the resource regardless of the LwApiHints_Sli_Disable_InterframeSync hint
    LWAPI_D3D_RR_FLAG_MULTI_FRAME              = 0x00000004   //!< (bit 2) The flag hints the driver that content will be used for many frames. If not specified then the driver assumes that content is used only on the next frame
} LWAPI_D3D_RESOURCERENDERING_FLAG;

//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D_BeginResourceRendering(IUnknown *pDev, LWDX_ObjectHandle obj, LwU32 Flags);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)


#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D_EndResourceRendering
//
//!   DESCRIPTION: This function tells the driver that the resource is done receiving updates. It must be used in combination with
//!                LwAPI_D3D_BeginResourceRendering(). 
//!                The primary use of this function is allow the driver to initiate early inter-frame syncs of resources while running in AFR SLI mode. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]  pDev         The ID3D10Device or IDirect3DDevice9 thatis a using the resource
//! \param [in]  obj          Previously obtained HV resource handle
//! \param [in]  Flags        Reserved, must be zero
//
//! \retval ::LWAPI_OK                Function succeeded, if used properly and driver can initiate proper sync'ing of the resources.
//! \retval ::LWAPI_ILWALID_ARGUMENT  Bad argument(s) or invalid flag values
//! \retval ::LWAPI_ILWALID_CALL      Mismatched begin/end calls
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D_EndResourceRendering(IUnknown *pDev, LWDX_ObjectHandle obj, LwU32 Flags);
#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)



#if defined(_D3D9_H_) || defined(__d3d10_h__)

///////////////////////////////////////////////////////////////////////////////
// LWAPI Query Types
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dx
//! Used in LwAPI_D3D_CreateQuery() and LwAPI_D3D_Query_GetType().
typedef enum _LWAPI_D3D_QUERY_TYPE
{
    LWAPI_D3D_QUERY_TYPE_RESERVED0       = 0,
    LWAPI_D3D_QUERY_TYPE_RESERVED1       = 1,
    LWAPI_D3D_QUERY_TYPE_RESERVED2       = 2,
    LWAPI_D3D_QUERY_TYPE_RESERVED3       = 3,
    LWAPI_D3D_QUERY_TYPE_PMTRIGGER       = 0,
    LWAPI_D3D_QUERY_TYPE_ZLWLL_STATS     = 1,
    LWAPI_D3D_QUERY_TYPE_FE_TIMESTAMP    = 2,
    LWAPI_D3D_QUERY_TYPE_DA_TIMESTAMP    = 3,
    LWAPI_D3D_QUERY_TYPE_ROP_TIMESTAMP   = 4,
}LWAPI_D3D_QUERY_TYPE;


//! \ingroup dx
//! See LwAPI_D3D_Query_GetData().
typedef enum _LWAPI_D3D_QUERY_GETDATA_FLAGS
{
    LWAPI_D3D_QUERY_GETDATA_FLUSH      = 0,
    LWAPI_D3D_QUERY_GETDATA_DONOTFLUSH = 1
}LWAPI_D3D_QUERY_GETDATA_FLAGS;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D_CreateQuery
//
//! DESCRIPTION:     This API creates LWPU-specific D3D Query Objects. For DirectX 11, if a device is supplied the query will
//!                  always execute on the immediate context.  This makes sense for almost all queries since GetData is
//!                  invalid on deferred contexts. If a DirectX 11 context is supplied, the query will always execute on that context.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]      pDeviceOrContext    The D3D9, D3D10, D3D11 device, or D3D11 device context to create this query object on
//! \param [in]      type                Type of the query to be created (see LWAPI_D3D_QUERY_TYPE)
//! \param [out]     pHandle             The handle to the Query object
//!
//!
//! \retval ::LWAPI_OK - completed request
//! \retval ::LWAPI_ILWALID_POINTER - pDevice was NULL
//! \retval ::LWAPI_ILWALID_ARGUMENT - one of the arguments was not valid
//! \retval ::LWAPI_OUT_OF_MEMORY - unable to allocate sufficient memory to complete the call
//! \retval ::LWAPI_ERROR - error oclwrred
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D_CreateQuery(IUnknown *pDeviceOrContext, LWAPI_D3D_QUERY_TYPE type, LWDX_ObjectHandle *pHandle);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D_DestroyQuery
//
//! DESCRIPTION:    This API destroys LWPU-specific Direct3D query objects.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]    queryHandle      The handle to the Query object
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ILWALID_HANDLE  The Query object handle is invalid.
//! \retval ::LWAPI_ILWALID_CALL    The call could not be completed.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D_DestroyQuery(LWDX_ObjectHandle queryHandle);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D_Query_Begin
//
//! DESCRIPTION:     This API mark the beginning of a series of commands.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]    queryHandle      The handle to the Query object
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ILWALID_HANDLE  The Query object handle is invalid.
//! \retval ::LWAPI_ILWALID_CALL    The call could not be completed.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D_Query_Begin(LWDX_ObjectHandle queryHandle);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D_Query_End
//
//! DESCRIPTION:    This API marks the end of a series of commands.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]    queryHandle      The handle to the Query object
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ILWALID_HANDLE  The Query object handle is invalid.
//! \retval ::LWAPI_ILWALID_CALL    The call could not be completed.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D_Query_End(LWDX_ObjectHandle queryHandle);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D_Query_GetData
//
//! DESCRIPTION:     This API polls a queried resource to get the query state or a query result.
//!                  This makes it possible to get data from the GPU or the driver asynchronously.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]     queryHandle         The handle to the Query object
//! \param [in]     dwSize              Size of the data to retrieve or 0;
//!                                     This value can be obtained with LwAPI_D3D_Query_GetDataSize().
//! \param [in]     dwGetDataFlags      Optional flags; can be 0 or any combination of LWAPI_D3D_QUERY_GETDATA_FLAGS
//! \param [out]    pData               Address of memory that will receive the data 
//!                                     If NULL, GetData will be used only to check status.
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ILWALID_HANDLE  The Query object handle is invalid
//! \retval ::LWAPI_ILWALID_CALL    The call could not be completed
//! \retval ::LWAPI_DATA_NOT_FOUND  The Queried data was not yet available
//! \retval ::LWAPI_ERROR 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D_Query_GetData(LWDX_ObjectHandle queryHandle, void* pData, UINT dwSize, UINT dwGetDataFlags);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D_Query_GetDataSize
//
//! DESCRIPTION:    This API gets the size of the data (in bytes) that is output when calling
//!                 LwAPI_D3D_Query_GetData().
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]     queryHandle         The handle to the Query object
//! \param [out]    pDwSize             The requested size
//! 
//! \retval ::LWAPI_OK             
//! \retval ::LWAPI_ILWALID_HANDLE   the Query object handle is invalid
//! \retval ::LWAPI_ILWALID_POINTER  pDwSize is NULL
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D_Query_GetDataSize(LWDX_ObjectHandle queryHandle, UINT *pDwSize);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D_Query_GetType
//
//! DESCRIPTION:    This API gets the LWAPI_D3D_QUERY_TYPE of the given query object.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]    queryHandle         The handle to the Query object
//! \param [out]   pType               The requested LWAPI_D3D_QUERY_TYPE value
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ILWALID_HANDLE   the Query object handle is invalid
//! \retval ::LWAPI_ILWALID_POINTER  pType is NULL
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D_Query_GetType(LWDX_ObjectHandle queryHandle, LWAPI_D3D_QUERY_TYPE *pType);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D_GetDeviceKmtHandle
//
//!   DESCRIPTION: This function retrieves the KMT handle for the specified device.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//! \param [in] pDev     The target device
//! \param [out]phDevice The device's KMT handle
//!
//! \return LWAPI_OK if and only if phDevice was populated with a valid KMT handle
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D_GetDeviceKmtHandle(IUnknown *pDev,
                                             LwU64* phDevice);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D_LwdaInteropFunction
//
//!   DESCRIPTION: This API is a container for a number of LWCA interop functions, including
//!                open/close interop, register/unregister resource, map/unmap
//!                resource, and sync.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//! \param [in]   pDev       The ID3D10Device or IDirect3DDevice9 to use
//! \param [in]   dwFunction Identifier for the interop function to call
//! \param [in]   pData      The data that will be used by the method
//!
//! \return LWAPI_OK if the call succeeded
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D_LwdaInteropFunction(IUnknown *pDev,
                                              UINT dwFunction,
                                              void *pData);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D_LwdaInteropGetObjectHandle
//
//!   DESCRIPTION: This API gets a handle to a resource for use by LWCA.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//! \param [in]  pDev       The ID3D10Device or IDirect3DDevice9 to use
//! \param [in]  pResource  The IDirect3DResource9 or ID3D10Resource to which
//!                         we want the LwAPI handle
//! \param [out] pHandle    A handle to the resource
//!
//! \return  LWAPI_OK if the handle was populated.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D_LwdaInteropGetObjectHandle(
    IUnknown *pDevice,
    IUnknown *pResource,
    LWDX_ObjectHandle *pHandle);

#endif  // #if defined(_D3D9_H_) || defined(__d3d10_h__)

#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D_RegisterApp
//
//! DESCRIPTION:    This API allows known DirectX 11, DirectX 10, or DirectX 9 applications to register themselves in order to enable specific driver modes.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in] userAppId  A predetermined LWPU-specified number that the driver uses to 
//!                        turn on application-specific features.
//!                        If the code is not recognized, it would return ::LWAPI_NOT_SUPPORTED.
//!                        Otherwise, it would return ::LWAPI_OK.
//!
//! \retval ::LWAPI_ERROR             Registration failed.
//! \retval ::LWAPI_OK                The application is supported.
//! \retval ::LWAPI_ILWALID_ARGUMENT  Bad parameters were given.
//!
//! \ingroup dx 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D_RegisterApp(IUnknown *pDev, LwU32 userAppId);
#endif // defined(_D3D9_H_) || defined(__d3d10_h__)





//-----------------------------------------------------------------------------
// Direct3D9 APIs
//-----------------------------------------------------------------------------

#if defined(_D3D9_H_) && defined(__cplusplus)

//! \ingroup dx
//! @{

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_CreatePathContextLW
//
//! \fn LwAPI_D3D9_CreatePathContextLW(IDirect3DDevice9* pDevice, LwU32* context)
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  LW Path Library.
//!                  Creates a new LWPL context.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   pDevice  Direct3D 9 device
//! \param [out]  context  LWPL context
//!
//!\return LwAPI status code or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
// LW Path Library data types
//--------------------------------------------------------------------------------------

typedef enum _LW_PATH_DATATYPE
{
    LW_BYTE                        = 0,
    LW_UNSIGNED_BYTE,
    LW_SHORT,
    LW_UNSIGNED_SHORT,
    LW_INT,
    LW_UNSIGNED_INT,
    LW_FLOAT,
    LW_FIXED
} LwPathDataType;

typedef enum _LW_PATH_PARAMTYPE
{
    PATH_QUALITY_LW             = 0x8ED8,
    FILL_RULE_LW                = 0x8ED9,
    STROKE_CAP0_STYLE_LW        = 0x8EE0,
    STROKE_CAP1_STYLE_LW        = 0x8EE1,
    STROKE_CAP2_STYLE_LW        = 0x8EE2,
    STROKE_CAP3_STYLE_LW        = 0x8EE3,
    STROKE_JOIN_STYLE_LW        = 0x8EE8,
    STROKE_MITER_LIMIT_LW       = 0x8EE9
} LWPathParamType;

typedef enum _LW_PATH_FILLRULE
{
    EVEN_ODD_LW                 = 0x8EF0,
    NON_ZERO_LW                 = 0x8EF1
} LWPathFillRule;

typedef enum _LW_PATH_CAPSTYLE
{
    CAP_BUTT_LW                 = 0x8EF4,
    CAP_ROUND_LW                = 0x8EF5,
    CAP_SQUARE_LW               = 0x8EF6,
    CAP_TRIANGLE_LW             = 0x8EF7
} LWPathCapStyle;

typedef enum _LW_PATH_JOINSTYLE
{
    JOIN_MITER_LW               = 0x8EFC,
    JOIN_ROUND_LW               = 0x8EFD,
    JOIN_BEVEL_LW               = 0x8EFE,
    JOIN_CLIPPED_MITER_LW       = 0x8EFF
} LWPathJoinStyle;

typedef enum _LW_PATH_TARGETTYPE
{
    MATRIX_PATH_TO_CLIP_LW      = 0x8F04,
    MATRIX_STROKE_TO_PATH_LW    = 0x8F05,
    MATRIX_PATH_COORD0_LW       = 0x8F08,
    MATRIX_PATH_COORD1_LW       = 0x8F09,
    MATRIX_PATH_COORD2_LW       = 0x8F0A,
    MATRIX_PATH_COORD3_LW       = 0x8F0B
} LWPathTargetType;

typedef enum _LW_PATH_MODE
{
    FILL_PATH_LW                = 0x8F18,
    STROKE_PATH_LW              = 0x8F19
} LWPathMode;

typedef enum _LW_PATH_CMD
{
    MOVE_TO_LW                  = 0x00,
    LINE_TO_LW                  = 0x01,
    QUADRATIC_BEZIER_TO_LW      = 0x02,
    LWBIC_BEZIER_TO_LW          = 0x03,
    START_MARKER_LW             = 0x20,
    CLOSE_LW                    = 0x21,
    STROKE_CAP0_LW              = 0x40,
    STROKE_CAP1_LW              = 0x41,
    STROKE_CAP2_LW              = 0x42,
    STROKE_CAP3_LW              = 0x43,
} LWPathCmd;


LWAPI_INTERFACE LwAPI_D3D9_CreatePathContextLW(IDirect3DDevice9* pDevice, LwU32* context);

//! @}

#endif //defined(_D3D9_H_) && defined(__cplusplus)




#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_DestroyPathContextLW
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  LW Path Library.
//!                  Destroys a LWPL context. This function *MUST* be called
//!                    on all created path contexts or else memory leaks will
//!                    occur.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      context  LWPL context
//!
//! \return ::LWAPI_OK or ::LWAPI_ILWALID_ARGUMENT
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_DestroyPathContextLW(LwU32 context);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_CreatePathLW
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  LW Path Library.
//!                  Creates a LWPL path. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]        context      LWPL context
//! \param [in]        datatype      Type of path vertex data
//! \param [in]        numCommands      Number of commands in path
//! \param [in]        commands      Path command buffer
//!
//! \param [out]    path          Path handle
//!
//! \return   LwAPI status code or DX HRESULT code
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_CreatePathLW(LwU32 context, LwPathDataType datatype, LwU32 numCommands, const LwU8* commands, LwU32* path);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_DeletePathLW
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  LW Path Library.
//!                  Destroys a LWPL path. This function *MUST* be called
//!                    on all created paths or else memory leaks will occur.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]    path  LWPL path handle
//!
//! \return ::LWAPI_OK or ::LWAPI_ILWALID_ARGUMENT
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_DeletePathLW(LwU32 path);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_PathVerticesLW
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  LW Path Library.
//!                  Sets vertex data for a path.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]          path  LWPL path handle
//! \param [in        vertices  vertex data
//!
//! \return  LwAPI status code or DX HRESULT code
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_PathVerticesLW(LwU32 path, const void* vertices);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_PathParameterfLW
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  LW Path Library.
//!                  Sets a path rendering parameter of type float
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!           INPUT:    path - LWPL path handle
//!           INPUT:    paramType - parameter name
//!           INPUT:    param - parameter value
//!
//! \return   LwAPI status code or DX HRESULT code
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_PathParameterfLW(LwU32 path, LWPathParamType paramType, float param);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_PathParameteriLW
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  LW Path Library.
//!                  Sets a path rendering parameter of type int
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]        path      LWPL path handle
//! \param [in]        paramType parameter name
//! \param [in]        param     parameter value
//!
//! \return   LwAPI status code or DX HRESULT code
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_PathParameteriLW(LwU32 path, LWPathParamType paramType, int param);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_PathMatrixLW
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  LW Path Library.
//!                  Sets a transformation matrix
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     context  LWPL context handle
//! \param [in]     target   type of transformation
//! \param [in]     value  matrix values
//!
//! \return  LwAPI status code or DX HRESULT code
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_PathMatrixLW(LwU32 context, LWPathTargetType paramType, const float* value);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_PathDepthLW
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  LW Path Library.
//!                  Sets the current path depth
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]    context   LWPL context handle
//! \param [in]       value     depth value
//!
//! \return  LwAPI status code or DX HRESULT code
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_PathDepthLW(LwU32 context, float value);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_PathClearDepthLW
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  LW Path Library.
//!                  Clears the depth buffer
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  context  LWPL context handle
//! \param [in]  value    depth value
//!
//! \return  LwAPI status code or DX HRESULT code
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_PathClearDepthLW(LwU32 context, float value);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_PathEnableDepthTestLW
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                 LW Path Library.
//!                  Enables / Disables depth testing
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!           INPUT:    context - LWPL context handle
//!           INPUT:    enable - enable depth test if true, else disable
//!
//! RETURN STATUS: a LwAPI status code or DX HRESULT code
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_PathEnableDepthTestLW(LwU32 context, bool enable);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_PathEnableColorWriteLW
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  LW Path Library.
//!                  Enables / Disables color write
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]    context  LWPL context handle
//! \param [in] enable   enable color write if true, else disable
//!
//! \return LwAPI status code or DX HRESULT code
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_PathEnableColorWriteLW(LwU32 context, bool enable);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_DrawPathLW
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  LW Path Library.
//!                  Draws the path.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]    path  LWPL path handle
//! \param [in] mode  path rendering mode
//!
//! \return LwAPI status code or DX HRESULT code
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_DrawPathLW(LwU32 path, LWPathMode mode);


#endif //defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
//! SUPPORTED OS:  Windows XP and higher
//!

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_GetSurfaceHandle
//
//!  This function gets the handle of a given surface. This handle uniquely 
//!  identifies the surface through all LwAPI entries.
//!
//!
//! \since Release: 313
//!
//! \param [in]     pSurface  Surface to be identified
//! \param [out]    pHandle    Will be filled by the return handle
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_GetSurfaceHandle(IDirect3DSurface9 *pSurface, 
                                        LWDX_ObjectHandle *pHandle);

#endif //defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_GetOverlaySurfaceHandle
//
//! \fn LwAPI_D3D9_GetOverlaySurfaceHandles(IDirect3DDevice9 *pDev, LW_OVLY_SURFS_INFO *pInfo)
//!   DESCRIPTION: This function gets the surface handles for the YUY2 overlay surfaces created.
//!
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 175
//!
//!   \param [in]  pDev  Device whose YUY2 surface handles need to be retrieved.
//!
//!   \param [out] pInfo Array (see LW_OVLY_SURFS_INFO) of surface handles (LWDX_ObjectHandle) that will be filled by
//!                the driver. The array has to initialized before it is passed on to 
//!                the function. The handles are populated in the order in which they 
//!                are created. For example, the handle of the first surface created will be
//!                stored in pHandle[0], second surface will be stored in pHandle[1], and so on.
//!
//! \return  An int which could be an LwAPI status or DX HRESULT code
//////////////////////////////////////////////////////////////////////////////


//! \ingroup dx
//! Used in LW_OVLY_SURFS_INFO.
#define MAX_OVLY_SURFS     6

//! \ingroup dx
//! Overlay surface handle and other information - used in LwAPI_D3D9_GetOverlaySurfaceHandles().
typedef struct _LW_OVLY_SURFS_INFO
{
    LWDX_ObjectHandle  handle[MAX_OVLY_SURFS];
    unsigned int       numSurfs;
}LW_OVLY_SURFS_INFO;


//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D9_GetOverlaySurfaceHandles(IDirect3DDevice9 *pDev, LW_OVLY_SURFS_INFO *pInfo);
#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_GetTextureHandle
//
//!  This function gets the handle of a given DirectX 9 texture.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \param [in]    pTexture   Surface to be identified
//! \param [out]   pHandle    Will be filled by the return handle
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_GetTextureHandle(IDirect3DTexture9 *pTexture, 
                                        LWDX_ObjectHandle *pHandle);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_GpuSyncGetHandleSize
//
//!  This function returns the size of the init and copy sync handles. These handles are
//!  then allocated and initialized to zero by the application.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 90
//!
//! \param [out]    pInitHandleSize   size of GpuSync init handle
//! \param [out]    pMapHandleSize    size of GpuSync copy handle
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_GpuSyncGetHandleSize(IDirect3DDevice9 *pDev, 
                                            unsigned int *pInitHandleSize,
                                            unsigned int *pMapHandleSize);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_GpuSyncInit
//
//! This function sets up sync functionality.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 90
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_GpuSyncInit(IDirect3DDevice9 *pDev, 
                                            void * syncInitData);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_GpuSyncEnd
//
//! This function tears down sync structures.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 90
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_GpuSyncEnd(IDirect3DDevice9 *pDev, 
                                            void * syncData);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_GpuSyncMapTexBuffer
//
//! This function maps a texture to receive OpenGL data.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 90
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_GpuSyncMapTexBuffer(IDirect3DDevice9 *pDev, 
                                            IDirect3DTexture9 *pTexture,
                                            void * syncData);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_GpuSyncMapSurfaceBuffer
//
//!  This function maps a texture to receive OpenGL data.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \return    An int which could be an LwAPI status or DX HRESULT code
//!  \ingroup   dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_GpuSyncMapSurfaceBuffer(IDirect3DDevice9 *pDev, 
                                                   IDirect3DSurface9 *pSurface,
                                                   void * syncData);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_GpuSyncMapVertexBuffer
//
//! This function maps a vertex buffer to receive OpenGL data.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 90
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_GpuSyncMapVertexBuffer(IDirect3DDevice9 *pDev, 
                                            IDirect3DVertexBuffer9 *pVertexBuffer,
                                            void * syncData);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_GpuSyncMapIndexBuffer
//
//!   This function maps an index buffer to receive OpenGL data.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 177
//!
//!  \return  An int which could be an LwAPI status or DX HRESULT code
//!  \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_GpuSyncMapIndexBuffer(IDirect3DDevice9 *pDev, 
                                            IDirect3DIndexBuffer9 *pIndexBuffer,
                                            void * syncData);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_SetPitchSurfaceCreation
//
//!   This function forces the next CreateTexture()/CreateRenderTarget() call to use pitch surfaces.
//!   The action is applied only once for the next surface. Set Signature==0 to make sure this is disabled.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 177
//!
//!  \return   An int which could be an LwAPI status or DX HRESULT code
//!  \ingroup  dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_SetPitchSurfaceCreation(IDirect3DDevice9 *pDev, 
                                                   LwU32 Signature);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_GpuSyncAcquire
//
//! This function acquires a semaphore for synchronization control of a mapped buffer.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 90
//!
//! \param [in] accessMode Acquire mapped buffer read/write access
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_GpuSyncAcquire(IDirect3DDevice9 *pDev, 
                                            void * syncData);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_GpuSyncRelease
//
//! This function releases a semaphore for synchronization control of a mapped buffer.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 90
//!
//! \param [in] accessMode  Release mapped buffer read/write access
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_GpuSyncRelease(IDirect3DDevice9 *pDev, 
                                            void * syncData);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_GetLwrrentRenderTargetHandle
//
//!  This function gets the handle of the current render target or z-buffer.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \param [in]  pDev     Device whose current render target is to be identified
//!
//! \param [out] pHandle  Will be filled by the return handle
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_GetLwrrentRenderTargetHandle(IDirect3DDevice9 *pDev,
                                            LWDX_ObjectHandle *pHandle);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_GetLwrrentZBufferHandle
//
//! 
//!  This function gets the handle of the current z-buffer.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \param [in]  pDev     Device whose current z-buffer is to be identified
//!
//! \param [out] pHandle  Will be filled by the return handle
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_GetLwrrentZBufferHandle(IDirect3DDevice9 *pDev,
                                               LWDX_ObjectHandle *pHandle);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_GetIndexBufferHandle
//
//!  This function gets the handle of a given DirectX 9 index buffer.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \param [in]   pIndexBuffer  Index Buffer to be identified
//! \param [out]  pHandle       Will be filled by the return handle
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_GetIndexBufferHandle(IDirect3DIndexBuffer9 *pIndexBuffer, 
                                        LWDX_ObjectHandle *pHandle);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_GetVertexBufferHandle
//
//!  This function gets the handle of a given DirectX 9 vertex buffer.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \param [in]    pVertexBuffer  Vertex Buffer to be identified
//! \param [out]   pHandle        Will be filled by the return handle
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_GetVertexBufferHandle(IDirect3DVertexBuffer9 *pVertexBuffer, 
                                        LWDX_ObjectHandle *pHandle);


#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_CreateTexture
//
//! \fn LwAPI_D3D9_CreateTexture(IDirect3DDevice9 *pDev,
//!   DESCRIPTION: This function creates a texture with special properties. \note The texture 
//!                is always created in "POOL_DEFAULT", not managed. \p
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 173
//!
//!   \param [in]  pDev         The device to get primary surface from Width,Height,Levels,Format 
//!   \param [in]  Width        Width of the top-level of the texture, in pixels. 
//!                             (See MS DirectX interface Direct3D9Device::CreateTexture.)
//!   \param [in]  Height       Height of the top-level of the texture, in pixels.
//!                             (See MS DirectX interface Direct3D9Device::CreateTexture.)
//!   \param [in]  Level        Number of levels in the texture. 
//!                             (See MS DirectX interface Direct3D9Device::CreateTexture.)
//!   \param [in]  Flags        The flags for special texture creation - \p
//!                - FORCEVIDMEM  This will force the texture into video memory, 
//!                               if that cannot be done, the texture creation will fail.
//!                - FORCELINEAR  Ensure the texture is stored in pitched-linear layout.
//!                - NOTMOVABLE   Indicates the texture should not be moved once allocated.
//!                               This is usually used to accommodate a 3rd party DMA engine.
//!                               \note This is only a hint, the OS may still move the texture
//!                                     under memory-constrained cirlwmstances.
//!   \param [in]  format       Describes the format of all levels in the texture. (See the MS DirectX SDK D3DFORMAT enumerated type) 
//!   \param [out] ppTexture    Fill with the texture created. (See MS DirectX SDK IDirect3DTexture9 interface) 
//!   \param [out] pHandle      If non-NULL, fill with the LWDX handle of the created texture.
//
//////////////////////////////////////////////////////////////////////////////


//!  \addtogroup dx
//! @{
#define LW_SURFACEFLAG_FORCEVIDMEM      0x00000001  //!< Flag for texture creation in LwAPI_D3D9_CreateTexture() 
#define LW_SURFACEFLAG_FORCELINEAR      0x00000010  //!< Flag for texture creation in LwAPI_D3D9_CreateTexture() 
#define LW_SURFACEFLAG_NOTMOVABLE       0x00000100  //!< Flag for texture creation in LwAPI_D3D9_CreateTexture() 
//! @}


//!   \ingroup  dx
LWAPI_INTERFACE LwAPI_D3D9_CreateTexture(IDirect3DDevice9 *pDev,
                                         LwU32 Width, LwU32 Height, LwU32 Level,
                                         LwU32 Flags, D3DFORMAT Format,
                                         IDirect3DTexture9 **ppTexture,
                                         LWDX_ObjectHandle *pHandle = 0);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_AliasPrimaryAsTexture
//
//!  This function creates a texture that is an alias of the current device's primary surface.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 80
//!
//! \param [in]     pDev       The device from which to get the primary surface
//! \param [in]     dwIndex    The index to the primary flipchain of device (usually 0)
//! \param [out]    ppTexture  Fill with the texture created
//! \param [out]    pHandle    If non-NULL, fill with the LWDX handle of the created texture
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_AliasPrimaryAsTexture(IDirect3DDevice9 *pDev, 
                                            LwU32 dwIndex,
                                            IDirect3DTexture9 **ppTexture,
                                            LWDX_ObjectHandle *pHandle = 0);
#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_PresentSurfaceToDesktop
//
//! \fn LwAPI_D3D9_PresentSurfaceToDesktop(IDirect3DDevice9 *pDev,
//!  This function presents a given surface to the desktop. This interface can be
//!  used to start a full-screen flipping mode even within windowed Direct 3D application.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 80
//!
//! \param [in]    pDev              The device (display) to present to 
//! \param [in]    surfaceHandle     The surface handle obtained from LWD3D9_GetSurfaceHandle().
//!                                  NOTE: LWDX_OBJECT_NONE means restore
//! \param [in]    dwFlipFlags       Flags to indicate SYNC mode (other bits reserved and must be 0)
//! \param [in]    dwExcludeDevices  This is a bitmask (usually 0) to indicate which device
//!                                  will be EXCLUDED from this present. This is only
//!                                  effective when used in a Clone mode configuration where
//!                                  the application wants one monitor to show the specially
//!                                  rendered screen and the other the normal desktop.
//!
//! \note It is application's responsibility to determine which devices are
//!       available on the current Clone mode configuration, through lwcpl interfaces.
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////


//! Parameters used for dwFlipFlags (All other bits reserved) - See LwAPI_D3D9_PresentSurfaceToDesktop()
//! \addtogroup dwFlipFlags
//! @{
#define LW_FLIPFLAG_VSYNC               0x00000001  //!< SYNCMODE         (bit 0:1) - 0:NOSYNC, 1:VSYNC, 2:HSYNC
#define LW_FLIPFLAG_HSYNC               0x00000002
#define LW_FLIPFLAG_TRIPLEBUFFERING     0x00000004  //!< TRIPLEBUFFERING  (bit 2)   - 0: DoubleBuffer, 1:TripleBuffer or more
//! @}


//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D9_PresentSurfaceToDesktop(IDirect3DDevice9 *pDev, 
                                               LWDX_ObjectHandle surfaceHandle, 
                                               LwU32 dwFlipFlags,
                                               LwU32 dwExcludeDevices = 0);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
// 
// FUNCTION_NAME: LwAPI_D3D9_CreateVideoBegin
//
//!  DESCRIPTION:  This function signals the driver that the application will next create a set of 
//!                D3DFMT_X8R8G8B8 render targets for overlay use. The call will fail 
//!                if the driver/hardware doesn't support this mode, in which case the 
//!                application should fall back to the traditional overlay (with driver 
//!                internal overlay buffers). If this call returns successfully, then 
//!                before the driver sees _CreateVideoEnd, all D3DFMT_A8R8G8B8 render 
//!                targets will be allocated as overlay surfaces. 
//!                See _CreateVideo, \ref LW_CVFLAG_EXTERNAL_OVERLAY flag for more details.
//!                This interface is only available on Windows Vista.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//!
//! \param [in]    pDev        The device (display) to present to
//!
//! \return        An int which could be an LwAPI status or DX HRESULT code
//! \ingroup       dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_CreateVideoBegin(IDirect3DDevice9 *pDev);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
// 
// FUNCTION_NAME: LwAPI_D3D9_CreateVideoEnd
//
//!  DESCRIPTION:  This function signals the driver that the application has finished creating 
//!                D3DFMT_X8R8G8B8 render targets for overlays.
//!                See _CreateVideo, \ref LW_CVFLAG_EXTERNAL_OVERLAY flag for more details.
//!                This interface is only available on Windows Vista.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//!
//!  \param [in]   pDev    The device (display) to present to
//!
//!  \return       An int which could be an LwAPI status or DX HRESULT code
//!  \ingroup      dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_CreateVideoEnd(IDirect3DDevice9 *pDev);

#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
// 
// FUNCTION_NAME: LwAPI_D3D9_CreateVideo
//
//! \fn LwAPI_D3D9_CreateVideo(IDirect3DDevice9 *pDev,
//!  This function allocates and initializes video resources for playback within a D3D9 context.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 90
//!
//! \param [in]  pDev              The device (display) to present to
//! \param [in]  pCVParams         Pointer to the create video paramater structures. See LW_DX_CREATE_VIDEO_PARAMS1.
//!
//! \return  An int which could be an LwAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////////////



//! \addtogroup cvflags
//! Create Video Flags - See LW_DX_CREATE_VIDEO_PARAMS1
//! @{

//! Overlay will be used
#define LW_CVFLAG_OVERLAY                   0x00000001 

//! Change source size or flip queue hint once overlay
//! resources have already been allocated.  Be wary
//! of upward allocating new resources, if there is
//! a failure, be prepared to deallocate everything
//! and start from scratch.     
#define LW_CVFLAG_OVERLAY_REINIT            0x00000002      

//! Use overlay surfaces allocated by the application. This flag
//! is supported only in LW_DX_CREATE_VIDEO_PARAMS_VER2 and above 
//! on Windows Vista. 
//!
//! The application sets this flag to indicate that the driver should
//! not allocate any internal overlay buffers, and the first
//! dwNumOvlSurfs surfaces in pCVParams->hOvlSurfs[] will be used for
//! overlay scan-out directly. The driver will validate these surfaces
//! against the following conditions, and fail the call otherwise: 
//!
//! -# No less than LW_CV_MIN_OVERLAY_SURFACE_NUMBER and no more than
//!    LW_CV_MAX_OVERLAY_SURFACE_NUMBER should be passed in.
//! -# Only surface handles of D3DFMT_A8R8G8B8 render targets created
//!    inside a pair of _CreateVideoBegin ()/_CreateVideoEnd() should be
//!    used.
//! -# The size of the surfaces must be identical to the target display.
//!
//! If all of the above condictions are met for each of the surfaces,
//! then the driver will not allocate any internal overlay buffers. Upon
//! _PresentVideo(), the source surface will be used for overlay scan-
//! out directly without the driver copying the content to an overlay
//! buffer first.
#define LW_CVFLAG_EXTERNAL_OVERLAY          0x00000004      

//! Forces full screen video on secondary device to be
//! disabled in multihead modes, regardless of user setting
#define LW_CVFLAG_2ND_FORCE_DISABLE         0x00010000

//! Forces full screen video on secondary device to be
//! enabled on the default device in multihead modes, 
//! regardless of user setting      
#define LW_CVFLAG_2ND_FORCE_ENABLE          0x00020000

//! Forces full screen video on secondary device to be
//! enabled on the primary device in clone mode, 
//! regardless of user setting      
#define LW_CVFLAG_2ND_FORCE_ENABLE1         0x00040000

//! If another application owns the secondary full-screen
//! device, forcibly take possession of it.      
#define LW_CVFLAG_2ND_COMMANDEER            0x00100000 

//! Is the target display secondary display when in Dualview mode     
#define LW_CVFLAG_SECONDARY_DISPLAY         0x01000000     
//! @}

//! \ingroup dx
//! Used in LwAPI_D3D9_CreateVideo()
typedef struct
{
    LwU32 version;       //!< Version of the CreateVideoParams structure
    LwU32 cvFlags;       //!< Initialization flags (See \ref cvflags for description)
    LwU32 flipQueueHint; //!< If an overlay is allocated, this indicates the desired number of flips
                         //!  to be queued (minimum of 1). A larger number is better for performance,
                         //!  but also consumes more frame buffer resources. This number should be
                         //!  set according to the number of fields/frames that can be decoded in
                         //!  advance of presentation. For example, if the decoder cannot decode in advance and
                         //!  must display immediately after decoding a frame, then set this to 1.
                         //!  If the decoder is decoding field content one frame at a time, then it
                         //!  is decoding one field ahead - set this to 2.  If the decoder
                         //!  can decode n flips ahead, then set this to n+1.  If the GPU has
                         //!  constrained frame buffer resources, then set this number lower, and also
                         //!  reduce the decode-ahead pipeline resources accordingly.
    LwU32 maxSrcWidth;   //!< Maximum video source width
    LwU32 maxSrcHeight;  //!< Maximum video source height
} LW_DX_CREATE_VIDEO_PARAMS1;

//! \ingroup dx
#define LW_CV_MIN_OVERLAY_SURFACE_NUMBER    2

//! \ingroup dx
#define LW_CV_MAX_OVERLAY_SURFACE_NUMBER    6

//! \ingroup dx
//! Used in LwAPI_D3D9_CreateVideo()
typedef struct
{
    LwU32 version;       //!< Version of the CreateVideoParams structure 
    LwU32 cvFlags;       //!< Initialization flags (See \ref cvflags for description)
    LwU32 flipQueueHint; //!< If an overlay is allocated, this indicates the desired number of flips
                         //!  to be queued (minimum of 1). A larger number is better for performance,
                         //!  but also consumes more frame buffer resources. This number should be
                         //!  set according to the number of fields/frames that can be decoded in
                         //!  advance of presentation. For example, if the decoder cannot decode in advance and
                         //!  must display immediately after decoding a frame, then set this to 1.
                         //!  If the decoder is decoding field content one frame at a time, then it
                         //!  is decoding one field ahead - set this to 2.  If the decoder
                         //!  can decode n flips ahead, then set this to n+1.  If the GPU has
                         //!  constrained frame buffer resources, then set this number lower, and also
                         //!  reduce the decode-ahead pipeline resources accordingly.
    LwU32 maxSrcWidth;   //!< Maximum video source width
    LwU32 maxSrcHeight;  //!< Maximum video source height
    LwU32 dwNumOvlSurfs; //!< Number of surfaces that the application intends to use for the   
                         //!  overlay (also refer to the LW_CVFLAG_EXTERNAL_OVERLAY flag)
    LWDX_ObjectHandle hOvlSurfs[LW_CV_MAX_OVERLAY_SURFACE_NUMBER];  //!< Handles to the surfaces that the application intends to use
                                                                    //!  for the overlay (also refer to the LW_CVFLAG_EXTERNAL_OVERLAY flag)
} LW_DX_CREATE_VIDEO_PARAMS2;

//! \ingroup dx
typedef LW_DX_CREATE_VIDEO_PARAMS2  LW_DX_CREATE_VIDEO_PARAMS;

//! \ingroup dx
#define LW_DX_CREATE_VIDEO_PARAMS_VER1  MAKE_LWAPI_VERSION(LW_DX_CREATE_VIDEO_PARAMS1,1)

//! \ingroup dx
#define LW_DX_CREATE_VIDEO_PARAMS_VER2  MAKE_LWAPI_VERSION(LW_DX_CREATE_VIDEO_PARAMS2,2)

//! \ingroup dx
#define LW_DX_CREATE_VIDEO_PARAMS_VER   LW_DX_CREATE_VIDEO_PARAMS_VER2



//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D9_CreateVideo(IDirect3DDevice9 *pDev, 
                                       LW_DX_CREATE_VIDEO_PARAMS *pCVParams);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
// 
// FUNCTION_NAME: LwAPI_D3D9_FreeVideo
//
//! This function releases all video resources.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!      
//! \param [in] pDev   The device (display) to present to
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_FreeVideo(IDirect3DDevice9 *pDev);

#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_PresentVideo
//
//! \fn LwAPI_D3D9_PresentVideo(IDirect3DDevice9 *pDev, 
//!   This function signals a final and complete frame ready for presentation.
//!   It can optionally render to the overlay, but should be called
//!   regardless of whether any actual rendering oclwrs.  If the
//!   user has enabled full screen video in a multi-head mode,
//!   this frame will also be rendered on the secondary device.
//!
//! \note Use LW_DX_PRESENT_VIDEO_PARAMS_VER in the "version" method for both 32 bit and 64 bit
//!       callers.  For older drivers that do not support 64 bit callers, 32 bit callers
//!       should use the evaluation of MAKE_LWAPI_VERSION(LW_DX_PRESENT_VIDEO_PARAMS1,1)
//!       in that field.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \param [in]   pDev             The device (display) to present to
//! \param [in]   pPVParams        The present video parameters structure. See LW_DX_PRESENT_VIDEO_PARAMS1. 
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//!
//!                LWAPI_DEVICE_BUSY - This return value indicates the flip request was dropped 
//!                because the hardware flip queue was too deep, thus no more present requests can be 
//!                accepted at the moment. \n
//!
//!                When an external overlay is used (for "external overlay" please refer to LwAPI_D3D9_CreateVideoBegin(),  
//!                LwAPI_D3D9_CreateVideoEnd(), and VER2-only descriptions of LwAPI_D3D9_CreateVideo()), 
//!                a failure in _PresentVideo means the current front (on-screen) buffer will remain  
//!                unchanged. In this case the application should be careful not to render to the current 
//!                front buffer, as it will cause video tearing. The application could retry presenting 
//!                the same frame during the next V-Sync, or continue with rendering the next frame to a 
//!                back buffer.
//
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup pvflags
//! PresentVideo flags - See LW_DX_PRESENT_VIDEO_PARAMS1
//! @{

//! Field is odd
#define LW_PVFLAG_ODD           0x00000001      

//! Field is even
#define LW_PVFLAG_EVEN          0x00000002 

//! Indicates that this frame is protected and guarantees full 
//! screen video will not display this frame on any secondary device.
//! Colwersely, not setting this indicates an unprotected frame.     
#define LW_PVFLAG_PROTECTED     0x00000004 
     
//! Indicates progressive frame. If the odd or even flags are set
//! in conjunction with this, it indicates the original field that
//! generated this deinterlaced frame, and attempts to synchronize
//! this presentation to the corresponding display field of an
//! interlaced display
#define LW_PVFLAG_PROGRESSIVE   0x00000008      

//! Show the overlay. \n
//! If the application is minimized or obslwred, continue to call LwAPI_D3D9_PresentVideo()
//! for every complete frame without this flag set. \n
//! If enabled, the unprotected video will continue to play in full-screen mode
//! on the secondary device, using the pixel aspect cached from
//! the last time a frame was shown. To change the pixel aspect while hidden,
//! the caller must "show" a frame at least once with a new clipped source and 
//! destination rectangle.  This shown frame can be rendered invisible with
//! appropriate color key selection.
#define LW_PVFLAG_SHOW          0x00000010      

//! Move overlay position without waiting for vblank.
//! The only parameters used are dwDstX, dwDstY, and LW_PVFLAG_SHOW.
#define LW_PVFLAG_FAST_MOVE     0x00000020     

//! If set, blocking flips, wait until the flip queue can accept another flip.
//! A non-blocking flip will return an error if the flip cannot be queued yet.
#define LW_PVFLAG_WAIT          0x00000040      

//! Video data is completely unchanged from the previous flip (used for telecine)
#define LW_PVFLAG_REPEAT        0x00000080

//! Use destination color key.
#define LW_PVFLAG_DST_KEY       0x00000100     

//! Indicates that the overlay is playing full-screen on the desktop.
//! This bit is used to automatically overscan the image on TVs.
#define LW_PVFLAG_FULLSCREEN    0x00000200      

//! Set the current time.
#define LW_PVFLAG_SET_STAMP     0x00001000 

//! If set, use timestamps. \n
//! If not set, flip on the next vblank.     
#define LW_PVFLAG_USE_STAMP     0x00002000     
//! @}

//! \ingroup dxvidcontrol
//! Used in LwAPI_D3D9_PresentVideo().
typedef struct 
{
    LwU32 version;                   //!< Structure version
    LWDX_ObjectHandle surfaceHandle; //!< The surface handle obtained from LwAPI_D3D9_GetSurfaceHandle
                                     //!  or LwAPI_D3D9_GetLwrrentRenderTargetHandle
    LwU32 pvFlags;                   //!< Presentation flags (See \ref pvflags for description)
    LwU32 colourKey;                 //!< Colour key to use if LW_PVFLAG_DST_KEY is set
    LwU32 timeStampLow;              //
                                     //
    LwU32 timeStampHigh;             //
    LwU32 flipRate;                  //!< Set to the current flip rate.
                                     //!  Set to zero if the frame to be presented is a still frame.
    LwSBox srlwnclipped;             //!< Unclipped source rectangle of the entire frame of data
    LwSBox srcClipped;               //!< Cropped source rectangle.  It is the caller's responsibility to crop
                                     //!  the source if the desktop crops the destination.
    LwSBox dst;                      // 
} LW_DX_PRESENT_VIDEO_PARAMS1;

//! \ingroup dxvidcontrol
typedef LW_DX_PRESENT_VIDEO_PARAMS1 LW_DX_PRESENT_VIDEO_PARAMS;

#ifdef _WIN32
//! \ingroup dxvidcontrol
#define LW_DX_PRESENT_VIDEO_PARAMS_VER1  MAKE_LWAPI_VERSION(LW_DX_PRESENT_VIDEO_PARAMS1,1)
#endif //_WIN32


//! \ingroup dxvidcontrol
#define LW_DX_PRESENT_VIDEO_PARAMS_VER  MAKE_LWAPI_VERSION(LW_DX_PRESENT_VIDEO_PARAMS1,2)



//! \ingroup dxvidcontrol
LWAPI_INTERFACE LwAPI_D3D9_PresentVideo(IDirect3DDevice9 *pDev, 
                                        LW_DX_PRESENT_VIDEO_PARAMS *pPVParams);

#endif //defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \addtogroup dxvidcontrol
//! @{

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION_NAME: LwAPI_D3D9_VideoSetStereoInfo
//
//! \fn LwAPI_D3D9_VideoSetStereoInfo(IDirect3DDevice9 *pDev,
//!                                            LW_DX_VIDEO_STEREO_INFO *pStereoInfo);
//! \code
//!   DESCRIPTION: This api specifies the stereo format of a surface, so that the
//!                surface could be used for stereo video processing or compositing. 
//!                In particular, this api could be used to link the left and right 
//!                views of a decoded picture.
//!
//! \since Release: 313
//!
//!         INPUT: pDev        - The device on which the stereo surface will be used
//!                pStereoInfo - The stereo format of the surface
//!
//! RETURN STATUS: an int which could be an LwAPI status or DX HRESULT code
//! \endcode
///////////////////////////////////////////////////////////////////////////////

#ifndef LW_STEREO_VIDEO_FORMAT_DEFINE
#define LW_STEREO_VIDEO_FORMAT_DEFINE


typedef enum _LW_STEREO_VIDEO_FORMAT
{
    LW_STEREO_VIDEO_FORMAT_NOT_STEREO         = 0,

    LW_STEREO_VIDEO_FORMAT_SIDE_BY_SIDE_LR    = 1,
    LW_STEREO_VIDEO_FORMAT_SIDE_BY_SIDE_RL    = 2,
    LW_STEREO_VIDEO_FORMAT_TOP_BOTTOM_LR      = 3,
    LW_STEREO_VIDEO_FORMAT_TOP_BOTTOM_RL      = 4,
    LW_STEREO_VIDEO_FORMAT_ROW_INTERLEAVE_LR  = 5,
    LW_STEREO_VIDEO_FORMAT_ROW_INTERLEAVE_RL  = 6,
    LW_STEREO_VIDEO_FORMAT_TWO_FRAMES_LR      = 7,
    LW_STEREO_VIDEO_FORMAT_MONO_PLUS_OFFSET   = 8,

    LW_STEREO_VIDEO_FORMAT_LAST               = 9,
} LW_STEREO_VIDEO_FORMAT;

#endif // LW_STEREO_VIDEO_FORMAT_DEFINE


typedef struct _LW_DX_VIDEO_STEREO_INFO {
    LwU32                     dwVersion;         //!< Must be LW_DX_VIDEO_STEREO_INFO_VER
    LWDX_ObjectHandle         hSurface;          //!< The surface whose stereo format is to be set
    LWDX_ObjectHandle         hLinkedSurface;    //!< The linked surface (must be valid when eFormat==LW_STEREO_VIDEO_FORMAT_TWO_FRAMES_LR)
    LW_STEREO_VIDEO_FORMAT    eFormat;           //!< Stereo format of the surface
    LwS32                     sViewOffset;       //!< Signed offset of each view (positive offset indicating left view is shifted left)
    BOOL                      bStereoEnable;     //!< Whether stereo rendering should be enabled (if FALSE, only left view will be used)
} LW_DX_VIDEO_STEREO_INFO;

//! Macro for constructing the version field of ::LW_DX_VIDEO_STEREO_INFO
#define LW_DX_VIDEO_STEREO_INFO_VER  MAKE_LWAPI_VERSION(LW_DX_VIDEO_STEREO_INFO,1)

LWAPI_INTERFACE LwAPI_D3D9_VideoSetStereoInfo(IDirect3DDevice9 *pDev,
                                              LW_DX_VIDEO_STEREO_INFO *pStereoInfo);

//! @}
#endif //defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_SetGamutData
//
//! \fn LwAPI_D3D9_SetGamutData(IDirect3DDevice9 *pDev, LwU32 outputId, LW_GAMUT_FORMAT format, LW_GAMUT_METADATA *pGamutData)
//! DESCRIPTION:     This API sets the Gamut Boundary Description (GBD) data.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 175
//!
//! \param [in]     pDev        The device (display) to present to.
//! \param [in]     outputId    The display output ID, which can be determined using LwAPI_GetAssociatedDisplayOutputId()
//!                             for an intended display. 
//! \param [in]     format      The format of GBD data structure.                    
//! \param [in]     pGamutData  The GBD data.
//!
//! \retval  ::LWAPI_OK 
//! \retval  ::LWAPI_ERROR 
//! \retval  ::LWAPI_ILWALID_ARGUMENT
//
/////////////////////////////////////////////////////////////////////////////////


//! \ingroup dx
//! Gamut format data - used in LwAPI_D3D9_SetGamutData().
typedef enum _LW_GAMUT_FORMAT
{
    LW_GAMUT_FORMAT_VERTICES   = 0,
    LW_GAMUT_FORMAT_RANGE,
} LW_GAMUT_FORMAT;


//! \ingroup dx
//! Gamut range metadata - used in LW_GAMUT_METADATA.
typedef struct _LW_GAMUT_METADATA_RANGE
{
    // Header
    LwU32    GBD_Color_Space:3;
    LwU32    GBD_Color_Precision:2;
    LwU32    Rsvd:2;                    //!< Must be set to 0
    LwU32    Format_Flag:1;             //!< Must be set to 1

    // Packaged data
    LwU32    Min_Red_Data:12;
    LwU32    Max_Red_Data:12;
    LwU32    Min_Green_Data:12;
    LwU32    Max_Green_Data:12;
    LwU32    Min_Blue_Data:12;
    LwU32    Max_Blue_Data:12;
} LW_GAMUT_METADATA_RANGE;


//! \ingroup dx
//! Gamut vertices metadata - used in LW_GAMUT_METADATA.
typedef struct _LW_GAMUT_METADATA_VERTICES
{
    // Header  
    LwU32    GBD_Color_Space:3;
    LwU32    GBD_Color_Precision:2;
    LwU32    Rsvd:1;
    LwU32    Facet_Mode:1;            //!< Must be set to 0
    LwU32    Format_Flag:1;                //!< Must be set to 0
    LwU32    Number_Vertices_H:8;        //!< Must be set to 0
    LwU32    Number_Vertices_L:8;        //!< Must be set to 4
   
    // Packaged data
    LwU32    Black_Y_R:12;
    LwU32    Black_Cb_G:12;
    LwU32    Black_Cr_B:12;
    LwU32    Red_Y_R:12;
    LwU32    Red_Cb_G:12;
    LwU32    Red_Cr_B:12;
    LwU32    Green_Y_R:12;
    LwU32    Green_Cb_G:12;
    LwU32    Green_Cr_B:12;
    LwU32    Blue_Y_R:12;
    LwU32    Blue_Cb_G:12;
    LwU32    Blue_Cr_B:12;
} LW_GAMUT_METADATA_VERTICES;


//! \ingroup dx
//! Gamut boundary description data - used in LwAPI_D3D9_SetGamutData().
typedef struct _LW_GAMUT_METADATA
{
   union
   {
        LW_GAMUT_METADATA_RANGE     rangeData;
        LW_GAMUT_METADATA_VERTICES  verticesData;        
   }data;
}LW_GAMUT_METADATA;


//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D9_SetGamutData(IDirect3DDevice9 *pDev, LwU32 outputId, LW_GAMUT_FORMAT format, LW_GAMUT_METADATA *pGamutData);


#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
//! \ingroup dx
//! @{
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_SetSurfaceCreationLayout
//
//! \fn LwAPI_D3D9_SetSurfaceCreationLayout(IDirect3DDevice9            *pDev,
//!                                                 LWAPI_SURFACE_LAYOUT_STRUCT *pSurfaceLayout);
//! \code
//!   DESCRIPTION: This call will be used primarily for testing VIC for MCP89.
//!                This will set up the layout of surfaces that are created through CreateSurface calls
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!         INPUT: pDev                          The device (display) to present to
//!                pSurfaceLayout                The pointer to the surface layout
//!                Surface layouts supported right now include Block-Linear (BL), 
//!                Pitch-Linear (PL) and Tiled (16x16)
//! 
//! RETURN STATUS: an int which could be an LwAPI status or DX HRESULT code
//! \endcode
///////////////////////////////////////////////////////////////////////////////
typedef enum _LWAPI_SURFACE_LAYOUT
{
    LWAPI_SURFACE_LAYOUT_BL    = 0,
    LWAPI_SURFACE_LAYOUT_PL    = 1,
    LWAPI_SURFACE_LAYOUT_TILED = 2,
} LWAPI_SURFACE_LAYOUT;

typedef struct _LWAPI_SURFACE_LAYOUT_STRUCT
{
    BOOL                 bEnableLayoutOverride;
    LWAPI_SURFACE_LAYOUT slLayout;
    DWORD                reserved[4];
    
} LWAPI_SURFACE_LAYOUT_STRUCT;


LWAPI_INTERFACE LwAPI_D3D9_SetSurfaceCreationLayout(IDirect3DDevice9            *pDev,
                                                    LWAPI_SURFACE_LAYOUT_STRUCT *pSurfaceLayout);

//! @}

#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_Video_GetVideoCapabilities
//
//! \fn LwAPI_D3D9_GetVideoCapabilities(IDirect3DDevice9 *pDev,
//!   DESCRIPTION: This function gets the GPU's video processing capabilities. The caller is responsible for furnishing
//!                the inputs within the LWAPI_VIDEO_CAPS_PACKET. This packet shall contain the output 
//!                consisting of the supported video features for the current configuration. The number of 
//!                LWAPI_VIDEO_CAPS will match the number of input video streams for which the capabilites
//!                have been requested. Multiple supported video profiles may be returned that would include
//!                a combination of various video features.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 158
//!                
//!   \param [in]  pDev             The device (display) to present to
//!   \param [in]  version          Version of the LW_DX_VIDEO_CAPS structure
//!   \param [in]  videoCaps        LWAPI_VIDEO_CAPS_PACKET containing both the 
//!                                 input Video Source information for which the capabilities
//!                                 are requested, as well as the output available 
//!                                 supported video features for the current configuration.
//!
//!  \return  An int which could be an LwAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////



//! \ingroup dxvidcontrol
//! Used in _LWAPI_VIDEO_SRC_INFO.
typedef enum _LW_CODEC
{
    LW_CODEC_TYPE_NONE,     
    LW_CODEC_TYPE_MPEG2, 
    LW_CODEC_TYPE_H264,
    LW_CODEC_TYPE_VC1,
    LW_CODEC_TYPE_MVC,
} LW_CODEC;




//! Current video surface to be played back. \n
//! Used in _LWAPI_VIDEO_CAPS_PACKET.
//! \ingroup dxvidcontrol
typedef struct _LWAPI_VIDEO_SRC_INFO
{
    LwU32       srcWidth;   //!< Input video width 
    LwU32       srcHeight;  //!< Input video height
    LW_CODEC    codecType;  //!< One of the available LW_CODEC's
    LwU32       avgBitrate; //!< Average bit rate for each stream in Kbps
    LwU64       reserved1;  //!< reserved for future expansion
    LwU64       reserved2;
} LWAPI_VIDEO_SRC_INFO;



//! Current desktop resolution. \n
//! Used in _LWAPI_VIDEO_CAPS_PACKET.
//! \ingroup dxvidcontrol
typedef struct _LWAPI_DESKTOP_RES
{
    LwU32 width;            //!< Current resolution width
    LwU32 height;           //!< Current resolution height
    LwU32 bitsPerPixel;     //!< Current resolution depth
    LwU32 refreshRate;      //!< Current display refresh rate
    LwU64 reserved1;        //!< Reserved for future expansion
    LwU64 reserved2;
} LWAPI_DESKTOP_RES;


//! \addtogroup dxvidcontrol
//! @{
#define LW_DEINTERLACE_PIXADAPTIVE_BIT      0   //!< Hardware pixel adaptive deinterlacing available
#define LW_VID_ENHANCE_EDGE_ENHANCE_BIT     0   //!< Edge enhancement present
#define LW_VID_ENHANCE_NOISE_REDUCTION_BIT  1   //!< Noise reduction present
 
#define LW_COLOR_CTRL_PROCAMP_BIT           0   //!< ProCamp is supported
#define LW_COLOR_CTRL_COLOR_TEMP_BIT        1   //!< Color temp control supported
#define LW_COLOR_CTRL_COLORSPACE_601_BIT    2   //!< Color space format ITU-R BT.601 supported
#define LW_COLOR_CTRL_COLORSPACE_709_BIT    3   //!< Color space format ITU-R BT.709 supported
#define LW_COLOR_CTRL_COLORSPACE_RGB_BIT    4   //!< Color space format RGB supported
 
#define LW_GAMMA_Y_BIT                      0   //!< Y-Gamma controls present
#define LW_GAMMA_RGB_BIT                    1   //!< RGB-Gamma controls present
#define LW_MISC_CAPS_ILW_TELECINE_BIT       0   //!< Ilwerse telecine is available
//! @}


//! Available video post-process features.\n
//! Used in _LWAPI_VIDEO_CAPS.
//! \ingroup dxvidcontrol
typedef struct _LWAPI_VIDEO_PROCESSING_CAPS 
{
    LwU64               deinterlaceMode;    //!< Possible deinterlace modes supported, "check LW_DEINTERLACE_xxx bits"
    LwU64               videoEnhance;       //!< Possible HW postproc enhancements e.g. NR, EE, "check LW_VID_ENHANCE_xxx bits"
    LwU64               colorControl;       //!< Color control is supported, "check LW_COLOR_xxx bits"
    LwU64               gamma;              //!< Available gamma colwersions, "check LW_GAMMA_xxx bits"
    LwU64               miscCaps;           //!< Miscellaneous post processing caps supported, "check LW_MISC_CAPS_xxx bits"
    LwU64               reserved1;          //!< Rserved for future use
    LwU64               reserved2;
    LwU64               reserved3;
} LWAPI_VIDEO_PROCESSING_CAPS;



//! \addtogroup vidFeature
//! Video feature cap bits. \n
//! Used in \ref _LWAPI_VIDEO_CAPS.
//! @{
#define LW_VID_FEATURE_NO_SYNC_FLIPS_BIT            0   //!< When this bit is set, the application needs to lock the RGB render target
                                                        //!< before calling RGB overlay to present video.
                                                        //!< In general this bit is set for G7x, and not set for G8x and later chips.
#define LW_VID_FEATURE_HALF_RES_ON_INTERLACED_BIT   1   //!< When this bit is set, it means that GPU can only show half resolution
                                                        //!< video on the interlaced display, which is true for G7x. The application
                                                        //!< needs a special workaround to show full-resolution video.
#define LW_VID_FEATURE_DX_PROTECTION_VERSION_2      2   //!< When this bit it set, the driver supports version 2 of
                                                        //!< DirectX video protection.
#define LW_VID_FEATURE_STEREO_VIDEO_BIT             3   //!< When this bit is set, the driver supports stereo
                                                        //!< VPBlit/VBBlitHD using LwAPI_D3D9_VideoSetStereoInfo().
//! @}

//! \ingroup vidFeature
#define LW_VID_FEATURE_STEREO_OVERLAY_VIDEO_BIT     4   //!< When this bit is set, it means the driver supports stereo overlay through                                                                    //!< VPBlit/VBBlitHD using LwAPI_D3D9_VideoSetStereoInfo.


//! \addtogroup perfLevel
//! Performance level bits. \n
//! Used in \ref _LWAPI_VIDEO_CAPS.
//! @{
#define LW_PERF_LEVEL_RED_BIT                       0   //!< When this bit is set, the GPU CANNOT support HD DVD/BluRay disc playback
#define LW_PERF_LEVEL_YELLOW_BIT                    1   //!< When this bit is set, the GPU meets the minimum requirement for
                                                        //!< HD DVD/BluRay disc playback
#define LW_PERF_LEVEL_GREEN_BIT                     2   //!< When this bit is set, the GPU can support HD DVD/BluRay disc playback.
#define LW_PERF_LEVEL_AERO_BIT                      3   //!< When this bit is set, it means the GPU can support HD/BD playback with Aero enabled.
#define LW_PERF_LEVEL_FRUC_BIT                      4   //!< When this bit is set, it means the GPU can support FRUC.
#define LW_PERF_LEVEL_3DBD_COMPOSITE_BIT            6   //!< When this bit is set, it means the GPU can support compositing for 3DBD
//! @}


//! Available video decode and post-process features \n
//! Used in _LWAPI_VIDEO_CAPS_PACKET.
//! \ingroup dxvidcontrol
typedef struct _LWAPI_VIDEO_CAPS
{
    LwU32                       maxFlipRate;    //!< Maximum flipping rate supported 
    LW_CODEC                    hwDecode;       //!< Supported codec for HW decoding
    LwU64                       vidFeature;     //!< Indicates presence of special video processing features
    LwU32                       perfLevel;      //!< GPU dependent level; can be red, yellow, or green
    LwU32                       numVidProfiles; //!< Number of returned video profiles              
    LwU32                       maxResPixels;   //!< Number of pixels in the max screen resolution supported at maxFlipRate for the input
                                                //!  codecType (refer to codecType field of the LWAPI_VIDEO_SRC_INFO structure).
    LwU32                       reserved1;
    LWAPI_VIDEO_PROCESSING_CAPS vidProcCaps[LW_MAX_VID_PROFILES];
} LWAPI_VIDEO_CAPS;

//! \addtogroup dxvidcontrol
//! @{
#define LWAPI_VIDEO_CAPS_PACKET_VER 2
#define RENDER_MODE_DWM_BIT         0
#define RENDER_MODE_OVERLAY_BIT     1
#define RENDER_MODE_STEREO_FULLSCREEN_BIT 2
//! @}



//! Used in _LW_DX_VIDEO_CAPS. 
//! \ingroup dxvidcontrol
typedef struct _LWAPI_VIDEO_CAPS_PACKET
{              
    LwU32                   packetVer;                      //!< (IN) Packet version that needs to match LWAPI_VIDEO_CAPS_PACKET_VER
    LwU32                   numVidStreams;                  //!< (IN) Number of streams for which the video caps are requested
    LWAPI_VIDEO_SRC_INFO    vidSrcInfo[LW_MAX_VID_STREAMS]; //!< (IN) Video source info
    LWAPI_DESKTOP_RES       res[LW_MAX_HEADS];              //!< (IN) Current desktop resolution(s)
    LwU64                   renderMode;                     //!< (IN) Requested rendering mode for the video source
    LwU64                   totalFB;                        //!< (OUT) Total framebuffer supported
    LwU16                   NumExtOvlBufNeeded;             //!< (OUT) Recommended number of external overlay buffers
    LwU16                   reserved1;                      //!< (IN/OUT) Reserved for future expansion
    LwU32                   reserved2;                      //!< (IN/OUT)
    LWAPI_VIDEO_CAPS        videoCaps[LW_MAX_VID_STREAMS];  //!< (OUT) Available video features for requested video streams
} LWAPI_VIDEO_CAPS_PACKET;



//! Used in LwAPI_D3D9_GetVideoCapabilities().
//! \ingroup dxvidcontrol
typedef struct _LW_DX_VIDEO_CAPS
{
    LwU32                   version;                        //!< (IN) LWAPI version that matched LW_DX_VIDEO_CAPS_VER
    LWAPI_VIDEO_CAPS_PACKET videoCapsPacket;                //!< (IN/OUT)
} LW_DX_VIDEO_CAPS;


//! \ingroup dxvidcontrol 
#define LW_DX_VIDEO_CAPS_VER  MAKE_LWAPI_VERSION(LW_DX_VIDEO_CAPS,1)


//! SUPPORTED OS:  Windows XP and higher
//!
//!  \ingroup dxvidcontrol
LWAPI_INTERFACE LwAPI_D3D9_GetVideoCapabilities(IDirect3DDevice9 *pDev, 
                                                LW_DX_VIDEO_CAPS *pVideoCaps);

#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)

//! \ingroup dx
//! @{
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_QueryVideoInfo
//
//! \fn LwAPI_D3D9_QueryVideoInfo(IDirect3DDevice9 *pDev,
//!                                       LWAPI_D3D9_QUERY_VIDEO_INFO *pQueryInfo)
//!   DESCRIPTION: Extensible LwAPI command for mechanism to retrieve various video related information
//!                The information may not be specific to the GPU, but will appear like it is from the 
//!                application's POV. The calling application can various query commands, and fill in the
//!                appropriate structure packet (if necessary), for the specified command. The list of 
//!                queries available to the application and exposed through this command is intended to be
//!                lwstomizable so we only need to expose as much as needed.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   pDev              The D3D9 device
//! \param [in]   pQueryInfo        LWAPI_D3D9_QUERY_VIDEO_INFO containing the type of query to 
//!                                 perform and returned information.
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//!
///////////////////////////////////////////////////////////////////////////////



//! Query video info commands
typedef enum _LWAPI_D3D9_QUERY_COMMAND
{
    LWAPI_D3D9_QUERY_NULL_CMD                       = 0,    //!< Null command
    LWAPI_D3D9_QUERY_STEREO_INFO_CMD                = 1,    //!< Stereo video information
    LWAPI_D3D9_QUERY_COLOR_INFO_CMD                 = 2,    //!< Color space and range information
} LWAPI_D3D9_QUERY_COMMAND;


//! Query stereo input formats
typedef enum _LW_QUERY_STEREO_INFO_FORMAT
{
    LWAPI_QUERY_STEREO_INFO_FORMAT_NOT_STEREO           = 0x00000000,
    LWAPI_QUERY_STEREO_INFO_FORMAT_SIDE_BY_SIDE_LR      = 0x00000001,
    LWAPI_QUERY_STEREO_INFO_FORMAT_SIDE_BY_SIDE_RL      = 0x00000002,
    LWAPI_QUERY_STEREO_INFO_FORMAT_TOP_BOTTOM_LR        = 0x00000004,
    LWAPI_QUERY_STEREO_INFO_FORMAT_TOP_BOTTOM_RL        = 0x00000008,
    LWAPI_QUERY_STEREO_INFO_FORMAT_ROW_INTERLEAVE_LR    = 0x00000010,
    LWAPI_QUERY_STEREO_INFO_FORMAT_ROW_INTERLEAVE_RL    = 0x00000020,
    LWAPI_QUERY_STEREO_INFO_FORMAT_TWO_FRAMES_LR        = 0x00000040,
    LWAPI_QUERY_STEREO_INFO_FORMAT_MONO_PLUS_OFFSET     = 0x00000080,
} LW_QUERY_STEREO_INFO_FORMAT;

#define LWAPI_QUERY_STEREO_INFO_FORMAT_ALL              LWAPI_QUERY_STEREO_INFO_FORMAT_SIDE_BY_SIDE_LR      | \
                                                        LWAPI_QUERY_STEREO_INFO_FORMAT_SIDE_BY_SIDE_RL      | \
                                                        LWAPI_QUERY_STEREO_INFO_FORMAT_TOP_BOTTOM_LR        | \
                                                        LWAPI_QUERY_STEREO_INFO_FORMAT_TOP_BOTTOM_RL        | \
                                                        LWAPI_QUERY_STEREO_INFO_FORMAT_ROW_INTERLEAVE_LR    | \
                                                        LWAPI_QUERY_STEREO_INFO_FORMAT_ROW_INTERLEAVE_RL    | \
                                                        LWAPI_QUERY_STEREO_INFO_FORMAT_TWO_FRAMES_LR        | \
                                                        LWAPI_QUERY_STEREO_INFO_FORMAT_MONO_PLUS_OFFSET

//! Query stereo info packet
typedef struct _LWAPI_QUERY_STEREO_INFO
{
    LwU32   dwFormats;                              //!< (OUT) Mask of supported stereo formats
    LwU32   bIsSupported        : 1;                //!< (OUT) Whether stereo is supported
    LwU32   bIsEnabled          : 1;                //!< (OUT) Whether stereo is current enabled
    LwU32   dwReserved1         :30;                //!< (IN/OUT) Future expansion
    LwU32   dwReserved2[4];                         //!< (IN/OUT) Future expansion
} LWAPI_QUERY_STEREO_INFO;

//! Query color colorspace formats
typedef enum _LWAPI_QUERY_COLOR_INFO_COLORSPACE
{
    LWAPI_QUERY_COLOR_INFO_COLORSPACE_NONE          = 0x00000000,
    LWAPI_QUERY_COLOR_INFO_COLORSPACE_601           = 0x00000001,
    LWAPI_QUERY_COLOR_INFO_COLORSPACE_709           = 0x00000002,
    LWAPI_QUERY_COLOR_INFO_COLORSPACE_RGB           = 0x00000004,

} LWAPI_QUERY_COLOR_INFO_COLORSPACE;

#define LWAPI_QUERY_COLOR_INFO_COLORSPACE_ALL       LWAPI_QUERY_COLOR_INFO_COLORSPACE_601   | \
                                                    LWAPI_QUERY_COLOR_INFO_COLORSPACE_709   | \
                                                    LWAPI_QUERY_COLOR_INFO_COLORSPACE_RGB

//! Query color info packet
typedef struct _LWAPI_QUERY_COLOR_INFO
{
    LwU32   dwColorSpaces;                          //!< (OUT) Mask of supported color spaces
    LwU32   dwReserved[4];                          //!< (IN/OUT) Future expansion
} LWAPI_QUERY_COLOR_INFO;

//! Query video info packet
typedef struct _LWAPI_DX_QUERY_VIDEO_INFO
{
    LwU32                               dwVersion;          //!< (IN) LWAPI version that matched LW_DX_QUERY_INFO_VER
    LWAPI_D3D9_QUERY_COMMAND            eQueryCommand;      //!< (IN) Type of query to perform or information requested
    union
    {
        LWAPI_QUERY_STEREO_INFO         stStereoInfo;       //!< (OUT)
        LWAPI_QUERY_COLOR_INFO          stColorInfo;        //!< (OUT)
    };
} LWAPI_D3D9_QUERY_VIDEO_INFO;

//! Macro for constructing the version field of ::LWAPI_D3D9_QUERY_VIDEO_INFO
#define LWAPI_D3D9_QUERY_VIDEO_INFO_VER  MAKE_LWAPI_VERSION(LWAPI_D3D9_QUERY_VIDEO_INFO,1)


LWAPI_INTERFACE LwAPI_D3D9_QueryVideoInfo(IDirect3DDevice9 *pDev,
                                          LWAPI_D3D9_QUERY_VIDEO_INFO *pQueryInfo);

//! @}


#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_EnableStereoOverlay
//
//!   DESCRIPTION: Turns on stereo overlay if supported. Should be done
//!                before app creates Overlay.
//!
//! \return ::LWAPI_ERROR or ::LWAPI_OK
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
//! SUPPORTED OS:  Windows Vista and higher
//!
LWAPI_INTERFACE LwAPI_D3D9_EnableStereoOverlay(IDirect3DDevice9 *pDev);


#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_RestoreDesktop
//
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \return  LWAPI_ERROR or LWAPI_OK
//!
//! \note This is not an interface, this is just a short-hand helper
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
inline int LwAPI_D3D9_RestoreDesktop(IDirect3DDevice9 *pDev)
{
    return LwAPI_D3D9_PresentSurfaceToDesktop(pDev,LWDX_OBJECT_NONE,0);
}

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_AliasPrimaryFromDevice
//
//! This function creates an alias surface from the given pDevFrom's primary swap chain.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 80
//!
//! \param [in]    pDevTo      Where new surfaces created in
//! \param [in]    pDevFrom    Where the surfaces aliased from
//! \param [in]    dwIndex     Index to the primary flipchain of pDevFrom
//!          
//! \param [out]   ppSurf      Filled with new surface pointer (to be released by the caller)
//! \param [out]   pHandle     (optional) If non-NULL, filled with SurfaceHandle of the surface
//!                            The same can be achieved by calling LWD3D9_GetSurfaceHandle afterwards.
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//! \ingroup dx
//////////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_AliasPrimaryFromDevice(IDirect3DDevice9 *pDevTo, 
                                              IDirect3DDevice9 *pDevFrom, 
                                              LwU32 dwIndex,
                                              IDirect3DSurface9 **ppSurf,
                                              LWDX_ObjectHandle *pHandle = 0);
#endif //defined(_D3D9_H_) && defined(__cplusplus)




#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_SetResourceHint
//
//! \fn LwAPI_D3D9_SetResourceHint(IDirect3DDevice9 *pDev, LWDX_ObjectHandle obj,
//!                This API has been deprecated.  
//!                This is a general purpose function for passing down various resource 
//!                related hints to the driver. Hints are divided into categories
//!                and types within each cateroy. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [in]   pDev           Valid device context
//! \param [in]   obj            Previously obtained HV resource handle 
//! \param [in]   dwHintCategory Category of the hints
//! \param [in]   dwHintType     A hint within this category
//! \param [in]  *pdwHintValue   Pointer to location containing hint value
//! \param [out] *dwHintValue    Receives previous value of this hint.
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//
////////////////////////////////////////////////////////////////////////////////

//! Available hint categories / hint names:
//! - SLI:
//! \ingroup dx
typedef enum _LWAPI_SETRESOURCEHINT_CATEGORY
{
    LwApiHints_Sli = 1,

}  LWAPI_SETRESOURCEHINT_CATEGORY;


  //! Types of SLI hints;
  //! LwApiHints_Sli_InterframeAwareForTexturing - deprecated
  //!
  //! Default value: zero
  //! \ingroup dx
typedef enum _LWAPI_SETRESOURCEHINT_SLI_HINTS
{
    LwApiHints_Sli_InterframeAwareForTexturing = 1,

}  LWAPI_SETRESOURCEHINT_SLI_HINTS;

//
// end of categories


//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D9_SetResourceHint(IDirect3DDevice9 *pDev, LWDX_ObjectHandle obj, 
                            LWAPI_SETRESOURCEHINT_CATEGORY dwHintCategory, LwU32 dwHintName, LwU32 *pdwHintValue);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_Lock
//
//! \fn LwAPI_D3D9_Lock(IDirect3DDevice9 *pDev, LWDX_ObjectHandle obj, LwU32 dwLockFlags,
//!  This function locks and unlocks a given surface identified by handle. This
//!  function can provide CPU access to all object including
//!  RTs, ZBs, textures, VBs and IBs.
//!
//! \note 
//! - (a) Do not use this if an object can be accessed using normal DX9 means.
//! - (b) Lock should be called right before CPU access, and Unlock called right after
//!     the access is completed. Any 3D rendering or state change may cause the locked
//!     surface to be lost. When that happens, trying to access the cached CPU 
//!     address may cause the application to crash.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------

//! \ingroup dx
#define LW_ACCESSFLAG_READONLY  0x00000001 // TBD: do these go with dwLockFlags?

//! \ingroup dx
#define LW_ACCESSFLAG_DISCARD   0x00000002


//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D9_Lock(IDirect3DDevice9 *pDev, LWDX_ObjectHandle obj, LwU32 dwLockFlags,
                            void **ppAddress, LwU32 *pPitch);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_Unlock
//
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_Unlock(IDirect3DDevice9 *pDev, LWDX_ObjectHandle obj);

#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
#ifndef LW_VIDEO_COMPONENTS_DEFINE
#define LW_VIDEO_COMPONENTS_DEFINE

///////////////////////////////////////////////////////////////////////////////
// Structs and enums related to Video state
///////////////////////////////////////////////////////////////////////////////


//! \ingroup dxvidstate
//! Used in LWAPI_GET_VIDEO_STATE_COMPONENT \n
//! Components related to the video state
typedef enum _LWAPI_VIDEO_STATE_COMPONENT_ID
{
    LWAPI_VIDEO_STATE_COMPONENT_ID_NONE     = -1,   //!< Placeholder for invalid component ID
    LWAPI_VIDEO_STATE_COMPONENT_BRIGHTNESS      ,   //!< Permits control of video's brightness value
    LWAPI_VIDEO_STATE_COMPONENT_CONTRAST        ,   //!< Allows control of video's contrast value
    LWAPI_VIDEO_STATE_COMPONENT_HUE             ,   //!< To control the hue value
    LWAPI_VIDEO_STATE_COMPONENT_SATURATION      ,   //!< Allows control of video's saturation value
    LWAPI_VIDEO_STATE_COMPONENT_COLORTEMP       ,   //!< Allows control of the color temperature value
    LWAPI_VIDEO_STATE_COMPONENT_Y_GAMMA         ,   //!< To set the Y-gamma values
    LWAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_R     ,   //!< To set the R value of RGB gamma
    LWAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_G     ,   //!< To set the G value of RGB gamma
    LWAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_B     ,   //!< To set the B value of RGB gamma
    LWAPI_VIDEO_STATE_COMPONENT_COLOR_SPACE     ,   //!< Permits choice of various color spaces using VIDEO_COMP_ALGO_COLOR_SPACE_xxx
    LWAPI_VIDEO_STATE_COMPONENT_COLOR_RANGE     ,   //!< Allows setting between a limited/full color range using VIDEO_COMP_ALGO_COLOR_RANGE_xxx
    LWAPI_VIDEO_STATE_COMPONENT_PLAYBACK_PROFILE,   //!< Permits using special postprocessing for Adobe Flash 9 Content
    LWAPI_VIDEO_STATE_COMPONENT_DEINTERLACE     ,   //!< To set various types of deinterlacing algorithms
    LWAPI_VIDEO_STATE_COMPONENT_SCALING         ,   //!< Allows setting video scaling algorithms
    LWAPI_VIDEO_STATE_COMPONENT_CADENCE         ,   //!< Allows control of the cadence algorithms
    LWAPI_VIDEO_STATE_COMPONENT_NOISE_REDUCE    ,   //!< Allows setting post-processing noise reduction values
    LWAPI_VIDEO_STATE_COMPONENT_EDGE_ENHANCE    ,   //!< Permits post-processing edge enhancement value adjustment
    LWAPI_VIDEO_STATE_COMPONENT_OVERDRIVE       ,   //!< To control the overdrive feature
    LWAPI_VIDEO_STATE_COMPONENT_SPLITSCREEN     ,   //!< To permit setting a splitscreen using one of VIDEO_COMP_ALGO_SPLITSCREEN_xxx
    LWAPI_VIDEO_STATE_COMPONENT_DEBLOCKING      ,   //!< Allows out-of-loop deblocking
    LWAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONTRAST,   //!< Permits control of video's dynamic contrast value
    LWAPI_VIDEO_STATE_COMPONENT_GREEN_STRETCH   ,   //!< Permits control of green stretch
    LWAPI_VIDEO_STATE_COMPONENT_BLUE_STRETCH    ,   //!< Allows control of blue enhancement
    LWAPI_VIDEO_STATE_COMPONENT_SKIN_TONE_CORRECTION, //!< Allows skin-tone correction for video
    LWAPI_VIDEO_STATE_COMPONENT_GAMUT_REMAPPING ,   //!< Applies gamut remapping on video
    LWAPI_VIDEO_STATE_COMPONENT_2DTO3D          ,   //!< Colwerts 2D video to 3D stereo video
    LWAPI_VIDEO_STATE_COMPONENT_3D_ANALYSIS     ,   //!< Analyzing 3D stereo video
    LWAPI_VIDEO_STATE_COMPONENT_FRC             ,   //!< Frame Rate Colwerter
    LWAPI_VIDEO_STATE_COMPONENT_BEN             ,   //!< Applies deblocking on video
    LWAPI_VIDEO_STATE_COMPONENT_ID_LAST         ,   //!< All valid components defined before this one
} LWAPI_VIDEO_STATE_COMPONENT_ID;


//! Dynamic contrast value - kept for backward compatibility.  
#define LWAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONSTRAST  LWAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONTRAST  


//! \ingroup dxvidstateypes
//! See \ref #LWAPI_VIDEO_COMPONENT_ALGORITHM.
#define VIDEO_COMP_ALGO_LWSTOM_BASE 64


//! \ingroup dxvidstate
//! Used in LWAPI_GET_VIDEO_STATE_COMPONENT. \n
//! Algorithms controlling various video components
typedef enum _LWAPI_VIDEO_COMPONENT_ALGORITHM
{
    VIDEO_COMP_ALGO_COLOR_SPACE_601                  = 0,  //!< Use the ITU-R BT.601 standard in color-space colwersion for xxx_COLOR_SPACE component
    VIDEO_COMP_ALGO_COLOR_SPACE_709                  = 1,  //!< Use the ITU-R BT.709 standard in color-space colwersion for xxx_COLOR_SPACE component
    VIDEO_COMP_ALGO_COLOR_SPACE_LWSTOM_04            = VIDEO_COMP_ALGO_LWSTOM_BASE+4, //!< Use custom color matrix
    VIDEO_COMP_ALGO_COLOR_RANGE_STD                  = 0,  //!< Full range of (0-255) for xxx_COLOR_RANGE component, equivalent to Microsoft's DXVADDI_NOMINALRANGE::DXVADDI_NominalRange_0_255
    VIDEO_COMP_ALGO_COLOR_RANGE_EXT                  = 1,  //!< Limited range of (16-235) for xxx_COLOR_RANGE component, equivalent to Microsoft's DXVADDI_NOMINALRANGE::DXVADDI_NominalRange_16_235
    VIDEO_COMP_ALGO_PLAYBACK_PROFILE_NONE            = 0,  //!< Use no playback profile
    VIDEO_COMP_ALGO_PLAYBACK_PROFILE_ADOBE_FLASH_9   = 1,  //!< Use the internet video enhancement postprocessing for Adobe Flash 9 
    VIDEO_COMP_ALGO_DEINTERLACE_NONE                 = 0,  //!< No deinterlacing is done
    VIDEO_COMP_ALGO_DEINTERLACE_BOB                  = 1,  //!< Perform Bob deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_WEAVE                = 2,  //!< Use weave deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_SIMPLE_ADAPTIVE      = 3,  //!< Perform a simple motion adaptive deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_GRADIENT_SIMPLE      = 4,  //!< Use a simple gradient deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_GRADIENT_FULL        = 5,  //!< Use advanced gradient deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_ADAPTIVE_FOUR_FIELD  = 6,  //!< Perform four field motion adaptive deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_DIR_SPATIAL          = 7,  //!< User directional spatial deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_ADVANCED             = 8,  //!< Perform proprietary advanced deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_GPU_CAPABLE          = 9,  //!< Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_DEINTERLACE_MEDIAN               = 10,  //!< Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_DEINTERLACE_DIR_SPATIAL_LIGHT    = 11,  //!< Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_DEINTERLACE_DIR_SPATIAL_SD       = 12,  //!< Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_DEINTERLACE_DIR_SPATIAL_HD       = 13,  //!< Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_DEINTERLACE_ONE_PASS             = 14,  //!< Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_DEINTERLACE_COMPUTE              = 15,  //!< Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_DEINTERLACE_LWSTOM_00            = VIDEO_COMP_ALGO_LWSTOM_BASE+0,    //!< Use custom Deinterlacing algorithm
    VIDEO_COMP_ALGO_DEINTERLACE_LWSTOM_01            = VIDEO_COMP_ALGO_LWSTOM_BASE+1,    //!< Use custom Deinterlacing algorithm
    VIDEO_COMP_ALGO_SCALING_ALG_SIMPLE               = 0,  //!< Do scaling using a simple algorithm       
    VIDEO_COMP_ALGO_SCALING_ALG_4x4FILTER            = 1,  //!< Perform scaling using a 4x4 filter
    VIDEO_COMP_ALGO_SCALING_ALG_8x8FILTER            = 2,  //!< Perform scaling using a 8x8 filter
    VIDEO_COMP_ALGO_SCALING_ALG_LWSTOM_00            = VIDEO_COMP_ALGO_LWSTOM_BASE+0,    //!< Use custom scaling component
    VIDEO_COMP_ALGO_SCALING_ALG_LWSTOM_01            = VIDEO_COMP_ALGO_LWSTOM_BASE+1,    //!< Use custom scaling component
    VIDEO_COMP_ALGO_CADENCE_NONE                     = 0,  //!< Turn cadence OFF
    VIDEO_COMP_ALGO_CADENCE_SIMPLE                   = 1,  //!< Use simple cadence detection
    VIDEO_COMP_ALGO_CADENCE_VOF                      = 2,  //!< Use video on film cadence detection
    VIDEO_COMP_ALGO_CADENCE_COMPUTE                  = 3,  //!< Use compute cadence detection
    VIDEO_COMP_ALGO_CADENCE_GPU_CAPABLE              = 4,  //!< Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_NOISE_REDUCE_PUREVIDEO           = 0,  //!< Use PureVideo noise reduction
    VIDEO_COMP_ALGO_NOISE_REDUCE_LWSTOM_00           = VIDEO_COMP_ALGO_LWSTOM_BASE+0,  //!< Use custom noise reduction
    VIDEO_COMP_ALGO_NOISE_REDUCE_LWSTOM_01           = VIDEO_COMP_ALGO_LWSTOM_BASE+1,  //!< Use custom noise reduction
    VIDEO_COMP_ALGO_EDGE_ENHANCE_PUREVIDEO           = 0,  //!< Use PureVideo Sharpening Filter
    VIDEO_COMP_ALGO_EDGE_ENHANCE_LWSTOM_00           = VIDEO_COMP_ALGO_LWSTOM_BASE+0,  //!< Use custom Sharpening Filter
    VIDEO_COMP_ALGO_EDGE_ENHANCE_LWSTOM_01           = VIDEO_COMP_ALGO_LWSTOM_BASE+1,  //!< Use custom Sharpening Filter
    VIDEO_COMP_ALGO_OVERDRIVE_SIMPLE                 = 0,  //!< Use simple overdrive algorithm
    VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_NORMAL          = 0,  //!< Set the splitscreen in normal mode
    VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_REPEATED        = 1,  //!< Set the splitscreen to be repeated
    VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_ON_MIRROR       = 2,  //!< Set the splitscreen as a mirror
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_NONE     = 0,  //!< Use the value setting for dynamic contrast instead of a preset
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_LOW      = 1,  //!< Turn the dynamic contrast to a low setting
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_MEDIUM   = 2,  //!< Turn the dynamic contrast to a medium setting
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_HIGH     = 3,  //!< Turn the dynamic contrast to a high setting
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_NONE        = 0,  //!< Use the value setting for green stretch instead of a preset
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_LOW         = 1,  //!< Set the green stretch to a low setting
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_MEDIUM      = 2,  //!< Set the green stretch to a medium setting
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_HIGH        = 3,  //!< Set the green stretch to a high setting
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_NONE         = 0,  //!< Use the value setting for blue stretch instead of a preset   
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_LOW          = 1,  //!< Set the blue stretch to a low setting
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_MEDIUM       = 2,  //!< Set the blue stretch to a medium setting
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_HIGH         = 3,  //!< Set the blue stretch to a high setting
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_NONE = 0,  //!< Use the value setting for skin tone correction instead of a preset  
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_SQUEEZE = 1,  //!< Turn the skin tone correction to a low setting
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_RED     = 2,  //!< Turn the skin tone correction to a medium setting
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_YELLOW  = 3,  //!< Turn the skin tone correction to a high setting
    VIDEO_COMP_ALGO_GAMUT_REMAPPING_LWSTOM_00        = VIDEO_COMP_ALGO_LWSTOM_BASE+0, //!< Use custom 3x3 gamut remapping matrix
    VIDEO_COMP_ALGO_GAMUT_REMAPPING_LWSTOM_01        = VIDEO_COMP_ALGO_LWSTOM_BASE+1, //!< Use custom 3x3 gamut remapping matrix
    VIDEO_COMP_ALGO_2DTO3D_LWSTOM_00                 = VIDEO_COMP_ALGO_LWSTOM_BASE+0, //!< Use custom 2Dto3D colwersion
    VIDEO_COMP_ALGO_2DTO3D_LWSTOM_01                 = VIDEO_COMP_ALGO_LWSTOM_BASE+1, //!< Use custom 2Dto3D colwersion
    VIDEO_COMP_ALGO_3D_ANALYSIS_LWSTOM_00            = VIDEO_COMP_ALGO_LWSTOM_BASE+0, //!< Use custom 3DAnalysis algorithm
    VIDEO_COMP_ALGO_3D_ANALYSIS_LWSTOM_01            = VIDEO_COMP_ALGO_LWSTOM_BASE+1, //!< Use custom 3DAnalysis algorithm
    VIDEO_COMP_ALGO_FRC_LWSTOM_00                    = VIDEO_COMP_ALGO_LWSTOM_BASE+0, //!< Use custom frame rate colwerter
    VIDEO_COMP_ALGO_FRC_LWSTOM_01                    = VIDEO_COMP_ALGO_LWSTOM_BASE+1, //!< Use custom frame rate colwerter
    VIDEO_COMP_ALGO_BEN_LWSTOM_00                    = VIDEO_COMP_ALGO_LWSTOM_BASE+0, //!< Use custom deblocking algorithm
    VIDEO_COMP_ALGO_BEN_LWSTOM_01                    = VIDEO_COMP_ALGO_LWSTOM_BASE+1, //!< Use custom deblocking algorithm

} LWAPI_VIDEO_COMPONENT_ALGORITHM;


//! \ingroup dxvidstate
//! Used in LWAPI_GET_VIDEO_STATE_COMPONENT. \n
//! Bit masks for enabling video components at various resolutions
typedef enum _LWAPI_VIDEO_COMPONENT_ENABLE
{
    VIDEO_COMP_ENA_480i     = 0x00000001, //!< component is enabled at 480i video resolution
    VIDEO_COMP_ENA_480p     = 0x00000002, //!< component is enabled at 480p video resolution
    VIDEO_COMP_ENA_576i     = 0x00000004, //!< component is enabled at 576i video resolution
    VIDEO_COMP_ENA_576p     = 0x00000008, //!< component is enabled at 576p video resolution
    VIDEO_COMP_ENA_720p     = 0x00000010, //!< component is enabled at 720p video resolution
    VIDEO_COMP_ENA_1080i    = 0x00000020, //!< component is enabled at 1080i video resolution
    VIDEO_COMP_ENA_1080p    = 0x00000040, //!< component is enabled at 1080p video resolution
} LWAPI_VIDEO_COMPONENT_ENABLE;


//! \ingroup dxvidstate
//! Used in LwAPI_D3D9_GetVideoState(). \n
//! Packet that facilitates retrieving information about a video component
typedef struct _LWAPI_GET_VIDEO_STATE_COMPONENT
{
    LwU32   version;                    //!< (IN)  LWAPI version that matches LWAPI_GET_VIDEO_STATE_COMPONENT_VER
    LwU32   componentID;                //!< (IN)  identify the individual component, one of LWAPI_VIDEO_STATE_COMPONENT_xxx enums
    LwU32   bIsSupported        : 1;    //!< (OUT) set if this component feature is supported
    LwU32   bIsOverridenByUser  : 1;    //!< (OUT) set if component is overriden by user's choice
    LwU32   reserved1           : 30;   //!< (OUT) reserved for future expansion
    LwU32   isEnabled;                  //!< (OUT) set if component is enabled, one or more of LWAPI_VIDEO_COMPONENT_ENABLE bitmasks
    LwU32   milwalue;                   //!< (OUT) minimum valid value
    LwU32   maxValue;                   //!< (OUT) maximum valid value
    LwU32   totalSteps;                 //!< (OUT) number of steps between min and max
    LwU32   defaultValue;               //!< (OUT) pre-defined LWPU default
    LwU32   unityValue;                 //!< (OUT) unity is the disable value for a component
    LwU32   lwrrentValueActive;         //!< (OUT) value in use
    LwU64   defaultAlgo;                //!< (OUT) default algorithm, one or more of LWAPI_VIDEO_COMPONENT_ALGORITHM enums
    LwU64   lwrrentAlgoActive;          //!< (OUT) algorithm in use, one or more of LWAPI_VIDEO_COMPONENT_ALGORITHM enums
    union
    {
        LwU64 qwReserved[9];
        struct
        {            
            LwU32   dwAppKey;           //!< (IN) Secret key to authenticate the caller, ONLY used in LwAPI_SetVideoState
            LwU32   bTopPriority   : 1; //!< (OUT)Indicates that these settings have precedence over D3D LwAPI settings, ONLY valid in LwAPI_GetVideoState
            LwU32   bHasLwstomAlgo : 1; //!< (OUT)Indicates whether an out-of-process application has custom algorithm data
            LwU32   bReserved      : 30;//!< (OUT)Reserved for expansion   
            struct
            {
                LwU64   pData;          //!< (IN) Buffer to hold the retrieved custom algo data
                LwU32   dwSize;         //!< (IN) Size in bytes of the above buffer, must be <= LWAPI_VIDEO_STATE_MAX_LWSTOM_ALGO_SIZE.
            } lwstomAlgo;

        } appInfo; 
    };         
} LWAPI_GET_VIDEO_STATE_COMPONENT;


//! \ingroup dxvidstate
//! Used in LWAPI_GET_VIDEO_STATE_COMPONENT.
#define LWAPI_GET_VIDEO_STATE_COMPONENT_VER  MAKE_LWAPI_VERSION(LWAPI_GET_VIDEO_STATE_COMPONENT,1)


//! \ingroup dxvidstate
//! Used in LWAPI_SET_VIDEO_STATE_COMPONENT. \n
//! Return status after attempting to set a video component 
typedef enum _LWAPI_VIDEO_COMP_RETURN_STATUS
{
    VIDEO_COMP_STATUS_SUCCESS                   = 0x00000000, //!< Video component is set successfully
    VIDEO_COMP_STATUS_UNSUCCESSFUL              = 0x00000001, //!< Failed to set video component
    VIDEO_COMP_STATUS_COMPONENT_NOT_SUPPORTED   = 0x00000002, //!< Video component is not supported
    VIDEO_COMP_STATUS_VALUE_OUT_OF_RANGE        = 0x00000004, //!< Video component's value is invalid and does not fall into range
    VIDEO_COMP_STATUS_ALGO_NOT_RECOGNIZED       = 0x00000008, //!< Video component's algorithm is invalid 
    VIDEO_COMP_STATUS_OVERRIDDEN_BY_USER        = 0x00000010, //!< Request not completed because of user-mandated override
    VIDEO_COMP_STATUS_Y_GAMMA_ENABLED           = 0x00000020, //!< Cannot set RGB-gamma because Y-Gamma is already enabled
    VIDEO_COMP_STATUS_RGB_GAMMA_ENABLED         = 0x00000040, //!< Cannot set Y-gamma because RGB-Gamma is already enabled
} LWAPI_VIDEO_COMP_RETURN_STATUS;


// Packet containing information to allow setting the video component

//! \ingroup dxvidstate 
#define LWAPI_VIDEO_STATE_MAX_LWSTOM_ALGO_SIZE 128


//! \ingroup dxvidstate
//! Packet containing information to allow setting the video component. \n
//! Used in LwAPI_D3D9_SetVideoState().
typedef struct _LWAPI_SET_VIDEO_STATE_COMPONENT
{
    LwU32   version;                        //!< (IN) LWAPI version that matches LWAPI_SET_VIDEO_STATE_COMPONENT_VER
    LwU32   componentID;                    //!< (IN) identify the individual component, one of LWAPI_VIDEO_STATE_COMPONENT_xxx enums
    LwU32   enable;                         //!< (IN) flag to enable setting of component, one or more of LWAPI_VIDEO_COMPONENT_ENABLE bitmasks
    LwU32   setToValue;                     //!< (IN) value to use
    LwU64   setToAlgo;                      //!< (IN) algorithm to use
    LwU32   retStatus;                      //!< (OUT) result of video-component-set operation; a combination of VIDEO_COMP_STATUS_xxx bitmasks 
    LwU32   reserved;
    union
    {
        LwU64 qwReserved[4];
        struct
        {
            LwU32   dwAppKey;               //!< (IN) Secret key to authenticate the caller, ONLY used in LwAPI_SetVideoState()
            LwU32   bTopPriority       : 1; //!< (IN) Force these settings to have priority over D3D LwAPI settings, ONLY valid in LwAPI_GetVideoState()
            LwU32   bHasLwstomAlgo     : 1; //!< (IN) Out-of-process application has custom algorithm data
            LwU32   bReserved          : 30;//!< (IN) reserved for expansion
            struct
            {
                LwU64   pData;              //!< (IN) (Used only when bHasLwstomAlgo == 1) Pointer to the custom algorithm data.
                LwU32   dwSize;             //!< (IN) (Used only when bHasLwstomAlgo == 1) Size in Bytes of the custom algorithm data, must be <= LWAPI_VIDEO_STATE_MAX_LWSTOM_ALGO_SIZE.
            } lwstomAlgo;
        } appInfo; 
    }; 
} LWAPI_SET_VIDEO_STATE_COMPONENT;


//! \ingroup dxvidstate
//! Used in LWAPI_SET_VIDEO_STATE_COMPONENT.
#define LWAPI_SET_VIDEO_STATE_COMPONENT_VER  MAKE_LWAPI_VERSION(LWAPI_SET_VIDEO_STATE_COMPONENT,1)

#endif // LW_VIDEO_COMPONENTS_DEFINE


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_GetVideoState
//
//!   DESCRIPTION: This function returns the video state component for the specified component ID.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 170
//!
//!   \param [in]     pDev              The Direct3D device for which the component is requested
//!   \param [in,out] pGetVidStateComp  LWAPI_GET_VIDEO_STATE_COMPONENT packet containing
//!                                     a valid component ID
//!
//!   \return  An int which could be an LwAPI status (LWAPI_OK, LWAPI_ILWALID_ARGUMENT,
//!            LWAPI_INCOMPATIBLE_STRUCT_VERSION, LWAPI_ERROR) or DX HRESULT code
//!
//!   \ingroup dxvidstate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_GetVideoState(IDirect3DDevice9 *pDev, 
                                         LWAPI_GET_VIDEO_STATE_COMPONENT *pGetVidStateComp);
#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
/////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_SetVideoState
//
//!   DESCRIPTION: This function sets a particular video state component for the specific component ID.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 170
//! 
//!   \param [in]       pDev              The Direct3D device for which the component-set is requested
//!   \param [in,out]   pSetVidStateComp  LWAPI_SET_VIDEO_STATE_COMPONENT packet containing
//!                                       the video component information to be applied 
//!
//!   \return  An int which could be an LwAPI status (LWAPI_OK, LWAPI_ILWALID_ARGUMENT,
//!            LWAPI_INCOMPATIBLE_STRUCT_VERSION, LWAPI_ERROR) or DX HRESULT code
//!
//!   \ingroup dxvidstate                
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_SetVideoState(IDirect3DDevice9 *pDev, 
                                         LWAPI_SET_VIDEO_STATE_COMPONENT *pSetVidStateComp);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_EnumVideoFeatures
//
//! \fn LwAPI_D3D9_EnumVideoFeatures(IDirect3DDevice9 *pDev, LWAPI_DX_VIDEO_FEATURE_DETAILS *pVideoFeatureDetails)
//!   DESCRIPTION:  This API enumerates all video features supported on the current configuration.
//! 
//!                 - First, the client should call the function with VF_GET_COUNT flag set. This will return the total 
//!                  feature count. 
//!                 - Then the client calls this function again iteratively, with the VF_GET_DETAILS flag until all of 
//!                  the features are enumerated.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \return An int which could be an LwAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
// enums and structs related to Video Features

//! \addtogroup dxvidfeatures
//! @{


#define LWAPI_MAX_FEATURES_PER_PACKET   3 //!< Maximum number of structs that can fit into dwArgs[20] of lwdxExtensionData struct

// Update the lwVidFeatureNames[] array in lwd3d.cpp when adding a new Feature ID.
//! Video feature IDs; used in _LWAPI_VIDEO_FEATURE_DETAILS
typedef enum _LWAPI_VIDEO_FEATURE
{
    LWAPI_VF_UNKNOWN = 0,
    LWAPI_VF_MPEG2SDDecodeAcceleration,
    LWAPI_VF_MPEG2HDDecodeAcceleration,
    LWAPI_VF_VC1SDDecodeAcceleration,
    LWAPI_VF_VC1HDDecodeAcceleration,
    LWAPI_VF_H264SDDecodeAcceleration,
    LWAPI_VF_H264HDDecodeAcceleration,
    LWAPI_VF_WMV9SDDecodeAcceleration,
    LWAPI_VF_WMV9HDDecodeAcceleration,
    LWAPI_VF_ProcAmp,
    LWAPI_VF_ColorTemperatureCorrection,
    LWAPI_VF_ColorSpaceColwersion,
    LWAPI_VF_GammaCorrection,
    LWAPI_VF_OverDrive,
    LWAPI_VF_DynamicContrastEnhancement,
    LWAPI_VF_StretchBlueGreenSkin,
    LWAPI_VF_AdaptiveDeInterlacing,
    LWAPI_VF_NoiseReduction,
    LWAPI_VF_EdgeEnhancement,
    LWAPI_VF_IlwerseTelecine,
    LWAPI_VF_Scaling,
    LWAPI_VF_VideoMirror,
    LWAPI_VF_Blend,
    LWAPI_VF_DxvaHDTest,
    LWAPI_VF_GamutRemap,
    LWAPI_VF_MftXcode,
    LWAPI_VF_SkinToneCorrection,
    LWAPI_VF_MftYUY2Xcode,
    LWAPI_VF_MftDivxXcode,
    LWAPI_VF_MftWmv9Encode,
    LWAPI_VF_DynamicPState,    
    LWAPI_VF_PostProcessVIC,
    LWAPI_VF_MVCHDDecodeAcceleration,
    LWAPI_VF_SVCHDDecodeAcceleration,
    LWAPI_VF_SimpleScaling,
    LWAPI_VF_VP8HDDecodeAcceleration,
    LWAPI_VF_VP9HDDecodeAcceleration,
    LWAPI_VF_ID_LAST,
} LWAPI_VIDEO_FEATURE;

// Update the lwVidEngineNames[] array in lwd3d.cpp when adding a new Engine name.
//! Video feature engine names; used in _LWAPI_VIDEO_FEATURE_DETAILS
typedef enum _LWAPI_VIDEO_ENGINES
{
    LWAPI_VE_UNKNOWN = 0,
    LWAPI_VE_PixelShader,
    LWAPI_VE_MPEG2Decoder,
    LWAPI_VE_VideoProcessor1,
    LWAPI_VE_VideoProcessor2,
    LWAPI_VE_MSDEC,
    LWAPI_VE_VIC,
} LWAPI_VIDEO_ENGINES;

// Update the lwVidEntryPointNames[] array in lwd3d.cpp when adding a new Entry point in this enum.
//! Video driver entry point; used in _LWAPI_VIDEO_FEATURE_DETAILS 
typedef enum _LWAPI_VIDEO_DRIVER_ENTRY_POINT
{
    LWAPI_EP_UNKNOWN = 0,
    LWAPI_EP_DecodeEndFrame,
    LWAPI_EP_OverlayTransfer,
    LWAPI_EP_DIBlitEx,
    LWAPI_EP_VideoProcessBlt,
    LWAPI_EP_D3DBlt,
    LWAPI_EP_Blit32,
    LWAPI_EP_VPBltHD,
} LWAPI_VIDEO_DRIVER_ENTRY_POINT;



//! Used in _LWAPI_VIDEO_FEATURE_DESCRIPTOR
typedef enum _LWAPI_VIDEO_FEATURE_GET_FLAG
{
    LWAPI_VF_GET_COUNT = 0,
    LWAPI_VF_GET_DETAILS,
} LWAPI_VIDEO_FEATURE_GET_FLAG;


//! Used in _LWAPI_VIDEO_FEATURE_DESCRIPTOR
typedef struct _LWAPI_VIDEO_FEATURE_DETAILS
{
    LWAPI_VIDEO_FEATURE            eFeature;
    LWAPI_VIDEO_ENGINES            eEngine;
    LWAPI_VIDEO_DRIVER_ENTRY_POINT eEntryPoint;
    LwU32                          dwReserved;
} LWAPI_VIDEO_FEATURE_DETAILS;

//! Returns the strings for each feature to the client. \n
//! Used in _LWAPI_DX_VIDEO_FEATURE_DETAILS
typedef struct _LWAPI_VID_FEATURE_STRINGS
{
    LWAPI_VIDEO_FEATURE eFeature;
    LwAPI_ShortString   szFeature; //!< Feature name
    LwAPI_ShortString   szEngine; //!< Video engine name
    LwAPI_ShortString   szDrvEntryPoint; //!< drv Entry Point name
    LwAPI_ShortString   szReserved1; //!< Reserved for future expansion
} LWAPI_VID_FEATURE_STRINGS;


//! Macro for constructing the version field of LWAPI_VIDEO_FEATURE_DESCRIPTOR
#define LWAPI_VIDEO_FEATURE_DESCRIPTOR_VER  1


//! Used in _LWAPI_DX_VIDEO_FEATURE_DETAILS
typedef struct _LWAPI_VIDEO_FEATURE_DESCRIPTOR
{
    LwU32                          version;                     //!< (IN) Version that matches LWAPI_VIDEO_FEATURE_DETAILS_PACKET_VER
    LWAPI_VIDEO_FEATURE_GET_FLAG   eVideoFeatureGetID;          //!< (IN) Get total feature count or feature details
    LwU32                          dwVFCount;                   //!< (OUT) Feature count returned
    LwU32                          dwStartVFCount;              //!< (IN) Starting surface count when reading the data
    LWAPI_VIDEO_FEATURE_DETAILS    astFeatureDetails[LWAPI_MAX_FEATURES_PER_PACKET]; //!< (OUT) Array of video feature details
    LwU32                          adwReserved[4];              //!< (IN/OUT) Reserved for future expansion
} LWAPI_VIDEO_FEATURE_DESCRIPTOR;


//! Used in LwAPI_D3D9_EnumVideoFeatures().
typedef struct _LWAPI_DX_VIDEO_FEATURE_DETAILS
{
    LwU32                           version;              //!< (IN) LWAPI version that matched LWAPI_DX_VIDEO_FEATURE_DETAILS_VER
    LWAPI_VIDEO_FEATURE_DESCRIPTOR  videoFeaturesPacket;  //!< (IN/OUT)
    LWAPI_VID_FEATURE_STRINGS       astFeatureDescNames[LWAPI_MAX_FEATURES_PER_PACKET]; //!< (OUT) Descriptor strings 
} LWAPI_DX_VIDEO_FEATURE_DETAILS;

//! Macro for constructing the version field of _LWAPI_DX_VIDEO_FEATURE_DETAILS
#define LWAPI_DX_VIDEO_FEATURE_DETAILS_VER MAKE_LWAPI_VERSION(LWAPI_DX_VIDEO_FEATURE_DETAILS,1)

//! @}

//! \ingroup dxvidfeatures
LWAPI_INTERFACE LwAPI_D3D9_EnumVideoFeatures(IDirect3DDevice9 *pDev, LWAPI_DX_VIDEO_FEATURE_DETAILS *pVideoFeatureDetails);




#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)

//////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_GetSLIInfo
//
//! \fn LwAPI_D3D9_GetSLIInfo(IDirect3DDevice9 *pDev, LW_SLI_INFO *pSliInfo)
//! This API is obsolete, please use LwAPI_D3D_GetLwrrentSLIState().
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 100
//!
//!
//! \retval   LWAPI_OK                      Completed request
//! \retval   LWAPI_NO_ACTIVE_SLI_TOPOLOGY  SLI is not active on this device
//! \retval   LWAPI_ERROR                   Error oclwrred
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dx
//! Used in LW_SLI_INFO
typedef enum _LW_SLI_MODE
{
    LW_SLI_RENDERING_MODE_AUTOSELECT  = 0,     //!< AutoSelect
    LW_SLI_RENDERING_MODE_AFR         = 1,     //!< Alternate Frames
    LW_SLI_RENDERING_MODE_SFR         = 2,     //!< Split Frame
    LW_SLI_RENDERING_MODE_SINGLE      = 3,      //!< Single GPU
    LW_SLI_RENDERING_MODE_AFR_OF_SFR  = 4      //!< AFR of SFR

} LW_SLI_MODE;

//! \ingroup dx
//! Used in LwAPI_D3D9_GetSLIInfo()
typedef struct
{
    LwU32 version;                       //!< Structure version

    LW_SLI_MODE         mode;            //!< [OUT] Current SLI mode
    LwU32               gpus;            //!< [OUT] Number of GPUs
} LW_SLI_INFO;


//! \ingroup dx
#define LW_SLI_INFO_VER  MAKE_LWAPI_VERSION(LW_SLI_INFO,1)



//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D9_GetSLIInfo(IDirect3DDevice9 *pDev, LW_SLI_INFO *pSliInfo);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_SetSLIMode
//
//! This function sets the SLI rendering mode for the Direct 3D device. The LWAPI_SLI_RENDERING_MODE_NOTALLOWED
//!                 return status oclwrs when SLI mode is enabled in the middle of a rendering. An application may try
//!                 to recreate/reset device and perform the call again. The normal way to set up SLI mode
//!                 is immediately after CreateDevice() or Reset(). The LWAPI_NO_ACTIVE_SLI_TOPOLOGY value is
//!                 returned when SLI is not active on this device.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 100
//!
//! \retval    LWAPI_OK                             Completed request
//! \retval    LWAPI_NO_ACTIVE_SLI_TOPOLOGY         SLI is not active on this device
//! \retval    LWAPI_SLI_RENDERING_MODE_NOTALLOWED  Setup of SLI mode is not possible right now
//! \retval    LWAPI_ILWALID_ARGUMENT               Invalid rendering mode
//! \retval    LWAPI_ERROR                          Error oclwrred
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_SetSLIMode(IDirect3DDevice9 *pDev, LW_SLI_MODE SliMode);



#endif //defined(_D3D9_H_) && defined(__cplusplus)




#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_QueryAAOverrideMode
//
//! \fn LwAPI_D3D9_QueryAAOverrideMode(IDirect3DDevice9 *pDev, LwU32* pRenderingSampleCount, LwU32* pBufferSampleCount, LwU32* pAAMode)
//! DESCRIPTION:    This function returns the antialiasing level selected through LWCPL, 
//!                 the corresponding buffer requirement, and the equivalent multisample quality.                  
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!                   
//! \param [in]     pDev                    The Direct3D device for which the component is requested
//! \param [out]    pRenderingSampleCount   The number of equivalent sample counts for this AA method, 0 indicates no AA set in the control panel
//! \param [out]    pBufferSampleCount      The number of buffer samples required for every pixel, 0 indicates no AA set in the control panel
//! \param [out]    pAAMode                 The AA mode that is lwrrently selected
//!                                             
//! \retval         LWAPI_OK                Completed request
//! \retval         LWAPI_ERROR             Error oclwrred
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dx
//! Used in LwAPI_D3D9_QueryAAOverrideMode().
enum
{
    LWAPI_AAMODE_VCAA             = 0x00000001,    //!< The current AA method is one of the VCAA methods
    LWAPI_AAMODE_SLIAA            = 0x00000002,    //!< The current AA method is one of the SLI-AA methods
    LWAPI_AAMODE_VCAA_HIGHQUALITY = 0x00000004     //!< The current AA method is a VCAA high-quality method
};



//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D9_QueryAAOverrideMode(IDirect3DDevice9 *pDev, LwU32* pRenderingSampleCount, LwU32* pBufferSampleCount, LwU32* pAAMode);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_D3D9_VideoSurfaceEncryptionControl
//
//! \fn LwAPI_D3D9_VideoSurfaceEncryptionControl(IDirect3DDevice9 *pDev, LWAPI_VIDSURF_ENCRYPT_CTRL_PARAMS *pVidSurfEncrCtrlParams)
//!  DESCRIPTION:   This API is deprecated. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//! 
//! \retval  LWAPI_NOT_SUPPORTED               Deprecated 
//
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup dxvidcontrol
//! @{

//! Video Surface Encryption Control Commands, 
//! used in \ref LWAPI_VIDSURF_ENCRYPT_CTRL_PARAMS.
typedef enum 
{
    LWAPI_VIDSURF_ENCRYPT_CMD_NULL              = 0x00, //!< Null command
    LWAPI_VIDSURF_ENCRYPT_CMD_GET_GUID_COUNT    = 0x01, //!< Get GUID count
    LWAPI_VIDSURF_ENCRYPT_CMD_GET_GUIDS         = 0x02, //!< Get GUIDs
    LWAPI_VIDSURF_ENCRYPT_CMD_SET_GUID          = 0x03, //!< Set GUID
    LWAPI_VIDSURF_ENCRYPT_CMD_ENABLE            = 0x04, //!< Enable encryption
    LWAPI_VIDSURF_ENCRYPT_CMD_SET_KEY           = 0x05, //!< Set key
    LWAPI_VIDSURF_ENCRYPT_CMD_SET_IV            = 0x06  //!< Set IV
} LWAPI_VIDSURF_ENCRYPT_COMMANDS;


//! Used in LWAPI_VIDSURF_ENCRYPT_CTRL_GET_GUIDS
#define LWAPI_VIDSURF_ENCRYPT_MAX_GUIDS        (4)


//! Used in LWAPI_VIDSURF_ENCRYPT_CTRL_PARAMS
typedef struct
{
    LwU32   dwGuidCount;                                // (OUT)
} LWAPI_VIDSURF_ENCRYPT_CTRL_GET_GUID_COUNT;


//! Used in LWAPI_VIDSURF_ENCRYPT_CTRL_PARAMS
typedef struct
{
    GUID    guids[LWAPI_VIDSURF_ENCRYPT_MAX_GUIDS];     // (OUT)
} LWAPI_VIDSURF_ENCRYPT_CTRL_GET_GUIDS;


//! Used in LWAPI_VIDSURF_ENCRYPT_CTRL_PARAMS
typedef struct
{
    GUID    guid;                                       // (IN)
} LWAPI_VIDSURF_ENCRYPT_CTRL_SET_GUID;


//! Used in LWAPI_VIDSURF_ENCRYPT_CTRL_PARAMS
typedef struct
{
    IDirect3DSurface9  *pSurface;                       // D3D9 surface ptr (IN)
    LwU32               bEnable;                        // (IN)
} LWAPI_VIDSURF_ENCRYPT_CTRL_ENABLE;


//! Used in LWAPI_VIDSURF_ENCRYPT_CTRL_PARAMS
typedef struct
{
    LwU32   dwEncryptKeyProtectionMode;
    LwU32   dwEncryptKeyProtectionIdentifier;
    LwU32   dwKey[4];                                   // (IN)
} LWAPI_VIDSURF_ENCRYPT_CTRL_SET_KEY;


//! Used in LWAPI_VIDSURF_ENCRYPT_CTRL_PARAMS
typedef struct
{
    LwU32   dwEncryptKeyProtectionMode;
    LwU32   dwEncryptKeyProtectionIdentifier;
    LwU32   dwIV[4];                                    // (IN)
} LWAPI_VIDSURF_ENCRYPT_CTRL_SET_IV;


//! Used in LwAPI_D3D9_VideoSurfaceEncryptionControl()
typedef struct
{
    LwU32               version;                        // structure version (IN)
    LwU32               dwCommand;                      // command (IN)
    union
    {
        LWAPI_VIDSURF_ENCRYPT_CTRL_GET_GUID_COUNT       GetGuidCount;
        LWAPI_VIDSURF_ENCRYPT_CTRL_GET_GUIDS            GetGuids;
        LWAPI_VIDSURF_ENCRYPT_CTRL_SET_GUID             SetGuid;
        LWAPI_VIDSURF_ENCRYPT_CTRL_ENABLE               Enable;
        LWAPI_VIDSURF_ENCRYPT_CTRL_SET_KEY              SetKey;
        LWAPI_VIDSURF_ENCRYPT_CTRL_SET_IV               SetIV;
    };
} LWAPI_VIDSURF_ENCRYPT_CTRL_PARAMS;


#define LWAPI_VIDSURF_ENCRYPT_CTRL_PARAMS_VER \
    MAKE_LWAPI_VERSION(LWAPI_VIDSURF_ENCRYPT_CTRL_PARAMS,1)

//! @}



//! \ingroup dxvidcontrol
LWAPI_INTERFACE LwAPI_D3D9_VideoSurfaceEncryptionControl(IDirect3DDevice9 *pDev, LWAPI_VIDSURF_ENCRYPT_CTRL_PARAMS *pVidSurfEncrCtrlParams);


#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_D3D9_DMA
//
//! \fn LwAPI_D3D9_DMA(IDirect3DDevice9 *pDev, LWAPI_D3D9_DMA_PARAMS *pVideoDMAParams)
//!
//! DESCRIPTION:     This API lets the caller perform a number of functions related to
//!                  the efficient DMA transfer of data between a Direct3D/DirectX 9 surface and
//!                  user-allocated system memory.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 190
//!
//! \retval ::LWAPI_OK                           Completed request
//! \retval ::LWAPI_ERROR                        Miscellaneous error oclwrred
//! \retval ::LWAPI_ILWALID_ARGUMENT             Invalid input parameter.
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  The version of struct LWAPI_D3D9_DMA_PARAMS
//!                                              is not supported.
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup dxdma
//! @{

//! Direct3D/DirectX 9 DMA commands used in _LWAPI_D3D9_DMA_PARAMS.
typedef enum _LWAPI_D3D9_DMA_COMMANDS
{
    LWAPI_D3D9_DMA_CMD_NULL         = 0x00,             //!< Null command
    LWAPI_D3D9_DMA_CMD_DESCRIBE     = 0x01,             //!< Describe allocation requirements - See _LWAPI_D3D9_DMA_DESCRIBE_PARAMS for parameters.
    LWAPI_D3D9_DMA_CMD_MAP          = 0x02,             //!< Map user-allocated system memory - See _LWAPI_D3D9_DMA_MAP_PARAMS for parameters.
    LWAPI_D3D9_DMA_CMD_UNMAP        = 0x03,             //!< Unmap user-allocated system memory - See _LWAPI_D3D9_DMA_UNMAP_PARAMS for parameters.
    LWAPI_D3D9_DMA_CMD_REG_EVENT    = 0x04,             //!< Register user-mode event handle - See _LWAPI_D3D9_DMA_EVENT_PARAMS for parameters.
    LWAPI_D3D9_DMA_CMD_UNREG_EVENT  = 0x05,             //!< Unregister user-mode event handle - See _LWAPI_D3D9_DMA_EVENT_PARAMS for parameters. 
    LWAPI_D3D9_DMA_CMD_TRANSFER     = 0x06,             //!< Transfer between user system memory and Direct3D/DirectX 9 surface
                                                        //!< See  _LWAPI_D3D9_DMA_TRANSFER_PARAMS for parameters.
    LWAPI_D3D9_DMA_CMD_COLOR_MATRIX = 0x07,             //!< Set up the color matrix for the transfer
} LWAPI_D3D9_DMA_COMMANDS;


//! Specifies the direction of the DMA transfer.
//! See LWAPI_D3D9_DMA_TRANSFER_PARAMS for more details.
typedef enum _LWAPI_D3D9_DMA_TRANSFER_DIR
{
    LWAPI_D3D9_DMA_TRANSFER_DIR_UPLOAD     = 0x00,      //!< Transfer from user system memory to Direct3D/DirectX 9 surface.
    LWAPI_D3D9_DMA_TRANSFER_DIR_DOWNLOAD   = 0x01,      //!< Transfer from Direct3D/DirectX 9 surface to user system memory.
} LWAPI_D3D9_DMA_TRANSFER_DIR;


//! Specifies the type of the DMA transfer.
//! See LWAPI_D3D9_DMA_TRANSFER_PARAMS for more details.
typedef enum _LWAPI_D3D9_DMA_TRANSFER_TYPE
{
    LWAPI_D3D9_DMA_TRANSFER_TYPE_PROGRESSIVE    = 0x00, //!< Transfer progressive frame.
    LWAPI_D3D9_DMA_TRANSFER_TYPE_INTERLACED     = 0x01, //!< Transfer both fields and keep the result interleaved.
    LWAPI_D3D9_DMA_TRANSFER_TYPE_BOB_TOP_FIELD  = 0x02, //!< Perform bob deinterlacing on the top field.
    LWAPI_D3D9_DMA_TRANSFER_TYPE_BOB_BTM_FIELD  = 0x03, //!< Perform bob deinterlacing on the bottom field.
} LWAPI_D3D9_DMA_TRANSFER_TYPE;


#define LWAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_MASK (LWAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_601|LWAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_709|LWAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_240|LWAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_LWSTOM)

#define LWAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_RANGE_MASK (LWAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_RANGE_FULL| LWAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_RANGE_LIM)

//! Specifies the type of the color space and range.
//! See ::LWAPI_D3D9_DMA_CMD_COLOR_MATRIX for more details
typedef enum _LWAPI_D3D9_DMA_COLOR_MATRIX_FLAGS
{
    LWAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_601         = 0x01, //!< Color Standard: 601
    LWAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_709         = 0x02, //!< Color Standard: 709
    LWAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_240         = 0x04, //!< Color Standard: 240
    LWAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_LWSTOM      = 0x08, //!< Color Standard: Custom
    LWAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_RANGE_FULL      = 0x10, //!< Color Range: Full [0 .. 255]
    LWAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_RANGE_LIM       = 0x20, //!< Color Range: Limited [16 .. 235]
} LWAPI_D3D9_DMA_COLOR_MATRIX_FLAGS;



//! Parameter data structure for the LWAPI_D3D9_DMA_CMD_DESCRIBE command (See ::_LWAPI_D3D9_DMA_COMMANDS.)
//! Given the surface dimension and format as input, the command
//! provides the driver requirements (such as alignment) for memory allocation.
typedef struct _LWAPI_D3D9_DMA_DESCRIBE_PARAMS
{
    LwU32                       dwWidth;                //!< width (IN)
    LwU32                       dwHeight;               //!< height (IN)
    LwU32                       dwFormat;               //!< FOURCC format (IN)
    LwU32                       dwPitch;                //!< pitch (OUT)
    LwU32                       dwSize;                 //!< size (OUT)
    LwU32                       dwAlignment;            //!< alignment (OUT)
} LWAPI_D3D9_DMA_DESCRIBE_PARAMS;


//! Parameter data structure for the LWAPI_D3D9_DMA_CMD_MAP command. (See ::_LWAPI_D3D9_DMA_COMMANDS.)
//! The command maps user-allocated system memory buffer to an LWPU DirectX object handle.
//! The pMemory buffer must satisfy the driver requirements.
//! Supported FOURCC formats are: LW12, YV12, YUY2
typedef struct _LWAPI_D3D9_DMA_MAP_PARAMS
{
    LwU32                       dwWidth;                //!< width (IN)
    LwU32                       dwHeight;               //!< height (IN)
    LwU32                       dwFormat;               //!< FOURCC format (IN)
    void                       *pMemory;                //!< memory pointer (IN)
    LWDX_ObjectHandle           hSysmemSurface;         //!< sysmem surface handle (OUT)
} LWAPI_D3D9_DMA_MAP_PARAMS;


//! Parameter data structure for the LWAPI_D3D9_DMA_CMD_UNMAP command. (See ::_LWAPI_D3D9_DMA_COMMANDS.)
//! The command unmaps the user-allocated system memory buffer.
typedef struct _LWAPI_D3D9_DMA_UNMAP_PARAMS
{
    LWDX_ObjectHandle           hSysmemSurface;         //<! sysmem surface handle (IN)
} LWAPI_D3D9_DMA_UNMAP_PARAMS;


//! Parameter data structure for the LWAPI_D3D9_DMA_CMD_REG_EVENT
//! command and the LWAPI_D3D9_DMA_CMD_UNREG_EVENT command. (See ::_LWAPI_D3D9_DMA_COMMANDS.)
//! The commands register or unregister a user-mode event handle with the Direct3D/DireectX 9 device.
typedef struct _LWAPI_D3D9_DMA_EVENT_PARAMS
{
    HANDLE                      hCompletionEvent;       //!< user-mode event handle (IN)
} LWAPI_D3D9_DMA_EVENT_PARAMS;



//! Parameter data structure for the LWAPI_D3D9_DMA_CMD_TRANSFER command. (See ::_LWAPI_D3D9_DMA_COMMANDS.)
//! The command performs DMA transfers between system memory buffer and the Direct3D/DirectX 9 surface.
//! It supports both upload and download directions, and supports scaling, color space and pixel format colwersion.
//! A NULL rectangle indicates that the entire surface is used. \n
//! The last reserved word is used to specify the scaling interpolation method
//! and whether the source transfer rect has floating point co-ordinates.
//! Floating point rects and smoothing levels are applied to LW12/IYUV/YV12->ARGB transfers only.
typedef struct _LWAPI_D3D9_DMA_TRANSFER_PARAMS
{
    LWAPI_D3D9_DMA_TRANSFER_DIR     direction;          //!< Direction of the transfer (IN)
    LWDX_ObjectHandle               hSysmemSurface;     //!< sysmem surface handle (IN)
    RECT*                           pSysmemSurfaceRect; //!< sysmem surface rectangle (IN)
    LWDX_ObjectHandle               hD3D9Surface;       //!< D3D9 surface handle (IN)
    RECT*                           pD3D9SurfaceRect;   //!< floatSrcRectFlag=0 => (RECT *) D3D9 Surface rectangle with integral co-ords (IN)
                                                        //!< floatSrcRectFlag=1 => (RECTF *)D3D9 Surface rectangle with float co-ords appended to integral co-ords (IN)

    HANDLE                          hCompletionEvent;   //!< Completion event handle (IN)
    LWAPI_D3D9_DMA_TRANSFER_TYPE    transferType;       //!< Type of the transfer (IN)
    LwU32                           floatSrcRectFlag:1; //!< 1=>pD3D9SurfaceRectF has float co-ords appended (IN)
    LwU32                           smoothingLevel:2;   //!< Type of interpolation for scaling. 
                                                        //!< 0=>Bilinear, 1=>Nearest Neighbor, 2,3=>Reserved for future.
    LwU32                           reserved:17;           //!< Reserved for future expansion (IN / OUT)
    LwU32                           reservedFlagValid:12;//!< Secret keyword that implies floatSrcRectFlag/smoothingLevel flags are valid (IN)
} LWAPI_D3D9_DMA_TRANSFER_PARAMS;



//! Used in _LWAPI_D3D9_DMA_COLOR_MATRIX_PARAMS.
#define LWAPI_D3D9_DMA_COLOR_MATRIX_SIZE            12

//! parameter data structure for the LWAPI_D3D9_DMA_CMD_COLOR_MATRIX command \n
//! Specifies the flags for the color spaces and color range.
//! Lwrrently color Spaces 601 and 709 are available inside the driver. For others, the input
//! color matrix [cm0-cm11] will be used. It has the following format for a YUV to RGB color colwersion
//! \code   
//!   | cm0  cm1  cm2 |    | y |   | cm9  |    | r |
//!   | cm3  cm4  cm5 | * (| u | + | cm10 |) = | g |
//!   | cm6  cm7  cm8 |    | v |   | cm11 |    | b |
//!  i.e.  MATRIX * (YUV + const) = RGB
//! \endcode
//!  The offsets cm9..cm11 are divided by 255.
typedef struct _LWAPI_D3D9_DMA_COLOR_MATRIX_PARAMS
{
   LwU32                             colorMatrixFlags;  //!< LWAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_XX flags to define the color space and range.
   float*                            colorMatrix;       //!< 4x3 float array containing the matrix (LWAPI_D3D9_DMA_COLOR_MATRIX_SIZE)
} LWAPI_D3D9_DMA_COLOR_MATRIX_PARAMS;



//! Used in LwAPI_D3D9_DMA(). 
typedef struct _LWAPI_D3D9_DMA_PARAMS
{
    LwU32               version;                        //!< Structure version (IN)
    LwU32               dwCommand;                      //!< Command (IN)
    union
    {
        LWAPI_D3D9_DMA_DESCRIBE_PARAMS     DescribeParams;
        LWAPI_D3D9_DMA_MAP_PARAMS          MapParams;
        LWAPI_D3D9_DMA_UNMAP_PARAMS        UnmapParams;
        LWAPI_D3D9_DMA_EVENT_PARAMS        EventParams;
        LWAPI_D3D9_DMA_TRANSFER_PARAMS     TransferParams;
        LWAPI_D3D9_DMA_COLOR_MATRIX_PARAMS ColorMatrixParams;
    };
} LWAPI_D3D9_DMA_PARAMS;


//! Macro for constructing the version field of _LWAPI_D3D9_DMA_PARAMS.
#define LWAPI_D3D9_DMA_PARAMS_VER \
    MAKE_LWAPI_VERSION(LWAPI_D3D9_DMA_PARAMS, 1)

//! @}


//! \ingroup dxdma
LWAPI_INTERFACE LwAPI_D3D9_DMA(IDirect3DDevice9 *pDev,
    LWAPI_D3D9_DMA_PARAMS *pVideoDMAParams);

#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
//! SUPPORTED OS:  Windows XP and higher
//!

//! \ingroup dx
//! @{

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION_NAME: LwAPI_D3D9_EnableStereo
//
//! \fn LwAPI_D3D9_EnableStereo(IDirect3DDevice9 *pDev,
//!     LWAPI_D3D9_ENABLE_STEREO_PARAMS *pEnableStereoParams)
//!   DESCRIPTION:   This API allows an approved application to enable stereo viewing
//!                  on an HDMI 1.4 TV.
//!
//! \retval ::LWAPI_OK                 completed request
//! \retval ::LWAPI_ILWALID_ARGUMENT   the vendor ID and/or response is invalid
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION   the version of LWAPI_D3D9_ENABLE_STEREO_PARAMS struct not supported.
//
///////////////////////////////////////////////////////////////////////////////

//! D3D9 Enable Stereo Commands
typedef enum _LWAPI_D3D9_ENABLE_STEREO_COMMANDS
{
    LWAPI_D3D9_ENABLE_STEREO_CMD_CHALLENGE = 0x01,
    LWAPI_D3D9_ENABLE_STEREO_CMD_RESPONSE  = 0x02,
} LWAPI_D3D9_ENABLE_STEREO_COMMANDS;

//! D3D9 Enable Stereo Constants
#define LWAPI_D3D9_ENABLE_STEREO_CHALLENGE_SIZE     16
//! D3D9 Enable Stereo Constants
#define LWAPI_D3D9_ENABLE_STEREO_RESPONSE_SIZE      20

//
//! Parameter data structure for the LWAPI_D3D9_ENABLE_STEREO_CMD_CHALLENGE command - 
//! This command requests a random challenge from driver.
//! It must be ilwoked before the LWAPI_D3D9_ENABLE_STEREO_CMD_RESPONSE command.
typedef struct _LWAPI_D3D9_ENABLE_STEREO_CHALLENGE_PARAMS
{
    LwU8 challenge[LWAPI_D3D9_ENABLE_STEREO_CHALLENGE_SIZE];    //!< random challenge from driver (OUT)
} LWAPI_D3D9_ENABLE_STEREO_CHALLENGE_PARAMS;

//
//! Parameter data structure for the LWAPI_D3D9_ENABLE_STEREO_CMD_RESPONSE command
//!
//! The application must possess the following information in order to callwlate a valid response:
//! - vendorGUID: a unique ID assigned to the application vendor by LWPU;
//! - vendorKEY:  a secret key issued to the application vendor by LWPU;
//!
//! The response is callwlated as HMAC(vendorKEY, (vendorGUID || challenge))
//! where HMAC is the Keyed-Hash Message Authentication Code using SHA-1 as the
//! underlying hash function. See FIPS Publication 198 for details of the algorithm.
typedef struct _LWAPI_D3D9_ENABLE_STEREO_RESPONSE_PARAMS
{
    LwGUID vendorGUID;                                          //!< vendor GUID from app (IN)
    LwU8   response[LWAPI_D3D9_ENABLE_STEREO_RESPONSE_SIZE];    //!< response from the app (IN)
} LWAPI_D3D9_ENABLE_STEREO_RESPONSE_PARAMS;

typedef struct _LWAPI_D3D9_ENABLE_STEREO_PARAMS
{
    LwU32 version;                      //!< structure version (IN)
    LwU32 dwCommand;                    //!< command (IN)
    union
    {
        LWAPI_D3D9_ENABLE_STEREO_CHALLENGE_PARAMS   ChallengeParams;
        LWAPI_D3D9_ENABLE_STEREO_RESPONSE_PARAMS    ResponseParams;
    };
} LWAPI_D3D9_ENABLE_STEREO_PARAMS_V1;

typedef LWAPI_D3D9_ENABLE_STEREO_PARAMS_V1      LWAPI_D3D9_ENABLE_STEREO_PARAMS;
#define LWAPI_D3D9_ENABLE_STEREO_PARAMS_VER1    MAKE_LWAPI_VERSION(LWAPI_D3D9_ENABLE_STEREO_PARAMS_V1, 1)
#define LWAPI_D3D9_ENABLE_STEREO_PARAMS_VER     LWAPI_D3D9_ENABLE_STEREO_PARAMS_VER1

LWAPI_INTERFACE LwAPI_D3D9_EnableStereo(IDirect3DDevice9 *pDev,
    LWAPI_D3D9_ENABLE_STEREO_PARAMS *pEnableStereoParams);

//! @}

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_StretchRect
//
//! DESCRIPTION:    This API copies the contents of the source rectangle to the
//!                  destination rectangle.  This function can colwert
//!                  between a wider range of surfaces than
//!                  IDirect3DDevice9::StretchRect. For example, it can copy
//!                  from a depth/stencil surface to a texture.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//! \param [in]      pDev       The D3D device that owns the objects.
//! \param [in]      hSrcObj    Handle to the source object.
//! \param [in]      pSrcRect   Defines the rectangle on the source to copy from.  If NULL, copy from the entire object.
//! \param [in]      hDstObj    Handle to the destination object.
//! \param [in]      pDstRect   Defines the rectangle on the destination to copy to.  If NULL, copy to the entire object.
//! \param [in]      Filter     Choose a filtering method: D3DTEXF_NONE, D3DTEXF_POINT, D3DTEXF_LINEAR.
//!
//! \return ::LWAPI_OK,    
//!         ::LWAPI_ILWALID_POINTER, 
//!         ::LWAPI_ILWALID_ARGUMENT, 
//!         ::LWAPI_ERROR 
//!
//! \ingroup dxvidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_StretchRect(IDirect3DDevice9 *pDev,
                                       LWDX_ObjectHandle hSrcObj,
                                       CONST RECT * pSourceRect,
                                       LWDX_ObjectHandle hDstObj,
                                       CONST RECT * pDestRect,
                                       D3DTEXTUREFILTERTYPE Filter);



#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_CreateRenderTarget
//
//! DESCRIPTION:     This API is deprecated.
//! 
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 190
//!
//! \retval ::LWAPI_NOT_SUPPORTED  deprecated
//
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_CreateRenderTarget(IDirect3DDevice9 *pDev,
                                              UINT Width,
                                              UINT Height,
                                              D3DFORMAT Format,
                                              D3DMULTISAMPLE_TYPE MultiSample,
                                              DWORD MultisampleQuality,
                                              BOOL Lockable,
                                              IDirect3DSurface9** ppSurface,
                                              LWDX_ObjectHandle *pHandle = NULL);

#endif //defined(_D3D9_H_) && defined(__cplusplus)



//-----------------------------------------------------------------------------
// DirectX + BDVMA private API
//-----------------------------------------------------------------------------



#if defined(_D3D9_H_) && defined(__cplusplus)

//////////////////////////////////////////////////////////////////////////////                      
//
// FUNCTION NAME: LwAPI_D3D9_BDVMA_Alloc
//
//! \fn LwAPI_D3D9_BDVMA(IDirect3DDevice9 *pDev, LW_BDVMA_INFO *pBDVMAInfo)
//! 
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \return LWAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dx
//! Used in LwAPI_D3D9_BDVMA().
typedef struct 
{
    LwU32               version;                //!< structure version (IN)

    LwU32               dwFunction;             //!< [OUT] 1 is Alloc, 2 is Free, 3 is Map, 4 is UnMap
    LwU32               dwSize;                 //!< [IN] Size of the allocation
    LwU32               hAllocHandle;           //!< [OUT/IN] RM handle of the alloc
    LwU64               qwPhysVidOffset;        //!< [OUT/IN] Physical offset of the memory allocated in the frame buffer
    void *              pCPUPtr;                //!< [OUT/IN] CPU mapping
    void *              pMemAllocPtr;           //!< [OUT/IN] pointer to MEMALLOCATION
} LW_BDVMA_INFO;


//! \ingroup dx 
LWAPI_INTERFACE LwAPI_D3D9_BDVMA(IDirect3DDevice9 *pDev, LW_BDVMA_INFO *pBDVMAInfo);


#endif // defined(_D3D9_H_) && defined(__cplusplus)

//-----------------------------------------------------------------------------
// DirectX + lwFBC private API
//-----------------------------------------------------------------------------


// this need to be kept in sync with the defines in lwUMFBC.cpp

//Removing if _D3D9_H_ condition because this structure is also used by D3D1x and above (see LwAPI_D3D1x_IFR_SetUpTargetBufferToSys)
#if defined(__cplusplus)


//! \ingroup dx
typedef enum 
{

    // include in NDA for IFR
    // This will be deprecated from NDA starting with GRID SDK 2.2
    LWFBC_FORMAT_ARGB               =      0,      //!< ARGB 
    LWFBC_FORMAT_RGB                =      1,      //!< RGB packed
    LWFBC_FORMAT_YUV_420            =      2,      //!< YYYYUV
    LWFBC_FORMAT_RGB_PLANAR         =      3,      //!< RGB planar, RRRRRRRR GGGGGGGG BBBBBBBB
    LWFBC_FORMAT_RGB_XOR            =      4,      //!< XOR RGB
    LWFBC_FORMAT_YUV_444            =      5,      //!< YUV444
    LWFBC_FORMAT_NOT_SUPPORTED      =      6       //
}LWFBC_BUFFER_FORMAT;

#endif //defined(__cplusplus)

#if defined(__cplusplus)

typedef enum
{
    LWFBC_API_CREATE_CAPTURE_BUFFER         = 0,
    LWFBC_API_DESTROY_CAPTURE_BUFFER        = 1,
    LWFBC_API_QUERY_CAPTURE_CTRL            = 2,
    LWFBC_API_XFER_RT_TO_LWDA               = 4,
    LWFBC_API_SETUP_TO_SYS_SURF             = 6,
    LWFBC_API_XFER_RT_TO_SYS                = 7,
    LWIFR_API_XFER_RT_TO_SYS                = 8,
    LWFBC_API_SETUP_LW12_TO_VID_SURF        = 9,
    LWFBC_API_XFER_RT_TO_LW12BL             = 10,
    LWIFR_API_XFER_RT_TO_LW12BL             = 11,
    LWIFR_API_DX9_CREATE_SHARED_SURFACE     = 20,
    LWIFR_API_DX9_DESTROY_SHARED_SURFACE    = 21,
    LWIFR_API_DX9_MAP_SHARED_SURFACE        = 22,
    LWIFR_API_DX9_UNMAP_SHARED_SURFACE      = 23,
    LWIFR_API_DX9_COPY_TO_SHARED_SURF       = 24,
    LWIFR_API_DX9_COPY_FROM_SHARED_SURF     = 25,
    LWFBC_API_CHECK_DEVICE_SUPPORT          = 26,
    LWFBC_API_SET_CAPTURE_HW_MOUSE_LWRSOR   = 27,
    LWFBC_API_XFER_RT_PREFILTER_TO_LW12BL   = 28,
    LWFBC_API_MOUSE_CAPTURE                 = 29,
    LWFBC_API_XFER_SYS_TO_LW12BL            = 30,
    LWFBC_API_GET_CAPS                      = 31,
    LWFBC_API_LAST
} LWFBC_API_ENUM;

//! \ingroup dx

#endif //defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_D3D9_LWFBC_CreateCaptureBuffer
//! \fn LwAPI_D3D9_LWFBC_CreateCaptureBuffer(IDirect3DDevice9 *pDev, LW_LWFBC_INFO *pLWFBCInfo)
//! 
//! \return LWAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dx
typedef struct 
{
    LwU32               version;                //!< structure version (IN)
    LwU32               dwSize;                 //!< [IN] Size of the allocation
} LW_LWFBC_INFO;

typedef struct : public LW_LWFBC_INFO
{
    LwU32               dwFlags;                 //!< [IN] allocation flags:
} LW_LWFBC_INFO4;

typedef struct : public LW_LWFBC_INFO4
{
    LwU32               dwAllocSize;             //!< [OUT] size of allocated capture buffer
} LW_LWFBC_INFO5;

typedef enum _LWAPI_LW_LWFBC_CREATEFLAGS
{
    LWAPI_LWFBC_FLAG_CREATESTEREO     = 0x00000001, //!< Tell KMD to bloat allocation to ~2x dwSize (2x + alignment) for stereo capture
    LWAPI_LWFBC_FLAG_ARGB_Z_HINTSDATA = 0x00000002, // 
} LWAPI_LW_LWFBC_CREATEFLAGS;

// each time the struct version needs to be updated
// sync the structure version to LWFBC_DLL_VERSION (defined in LwFBC.h) 
#define LWAPI_LW_LWFBC_INFO_VER5        MAKE_LWAPI_VERSION(LW_LWFBC_INFO,0x22)
#define LWAPI_LW_LWFBC_INFO_VER         LWAPI_LW_LWFBC_INFO_VER5

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D9_LWFBC_CreateCaptureBuffer(IDirect3DDevice9 *pDev, LW_LWFBC_INFO *pLWFBCInfo);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_D3D9_LWFBC_DestroyCaptureBuffer
//! \fn LwAPI_D3D9_LWFBC_DestroyCaptureBuffer(IDirect3DDevice9 *pDev)
//!
//! \return LWAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D9_LWFBC_DestroyCaptureBuffer(IDirect3DDevice9 *pDev);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_LWFBC_CopyCaptureBufferToLWDA
//! \fn LWAPI_INTERFACE LwAPI_D3D9_LWFBC_CaptureBufferToLWDA
//!
//! \return LWAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////


//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D9_LWFBC_CaptureBufferToLWDA(IDirect3DDevice9 *pDev, void * pLwFBCFrameGrabInfo, IDirect3DVertexBuffer9 *pVertexBuffer, DWORD dwFlags);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_LWFBC_CaptureBufferToDX9Tex
//! \fn LWAPI_INTERFACE LwAPI_D3D9_LWFBC_CaptureBufferToLWDAWithFormat
//!
//! \return LWAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D9_LWFBC_CaptureBufferToLWDAWithFormat(IDirect3DDevice9 *pDev, void * pLwFBCFrameGrabInfo, IDirect3DVertexBuffer9 *pVertexBuffer, DWORD dwFlags, LWFBC_BUFFER_FORMAT eFormat);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_LWFBC_CaptureBufferToLW12BLVideoSurface
//! \fn LwAPI_D3D9_LWFBC_CaptureBufferToLW12BLVideoSurface(IDirect3DDevice9 *pDev, void * pDataGrabInfo, DWORD dwBufferIndex, DWORD dwFlags, DWORD dwGrabMode, DWORD dwTargetWidth, DWORD dwTargetHeight, DWORD dwStartX, DWORD dwStartY)
//!
//! \return LWAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D9_LWFBC_CaptureBufferToLW12BLVideoSurface(IDirect3DDevice9 *pDev, void * pDataGrabInfo, DWORD dwBufferIndex, DWORD dwFlags=0, DWORD dwGrabMode=0, DWORD dwTargetWidth=0, DWORD dwTargetHeight=0, DWORD dwStartX=0, DWORD dwStartY=0);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_LWFBC_SetUpToLW12BLVideoSurface
//! \fn LwAPI_D3D9_LWFBC_SetUpToLW12BLVideoSurface(IDirect3DDevice9 *pDev, BOOL bWithHWLwrsor, DWORD dwNBuffers, HANDLE * ppBuffer, DWORD dwWidth, DWORD dwHeight, BOOL bUseYUV444 = 0)
//!
//! \return LWAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D9_LWFBC_SetUpToLW12BLVideoSurface(IDirect3DDevice9 *pDev, BOOL bWithHWLwrsor, DWORD dwNBuffers, HANDLE * ppBuffer, DWORD dwWidth, DWORD dwHeight, BOOL bUseYUV444 = 0);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_LWFBC_SetHWLwrsorCapture
//! \fn LwAPI_D3D9_LWFBC_SetHWLwrsorCapture(IDirect3DDevice9 *pDev, BOOL bWithHWLwrsor)
//!
//! \return LWAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D9_LWFBC_SetHWLwrsorCapture(IDirect3DDevice9 *pDev, BOOL bWithHWLwrsor);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_LWFBC_SetUpToSys
//! \fn LwAPI_D3D9_LWFBC_SetUpToSys(IDirect3DDevice9 *pDev, BOOL bWithHWLwrsor, LWFBC_BUFFER_FORMAT eFormat, DWORD dwNBuffers, unsigned char ** ppBuffer, unsigned char ** ppDiffMap)
//!
//! \return LWAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D9_LWFBC_SetUpToSys(IDirect3DDevice9 *pDev, BOOL bWithHWLwrsor, LWFBC_BUFFER_FORMAT eFormat, DWORD dwNBuffers, unsigned char ** ppBuffer, unsigned char ** ppDiffMap);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_LWFBC_CaptureBufferToSys
//! \fn LwAPI_D3D9_LWFBC_CaptureBufferToSys(IDirect3DDevice9 *pDev, void * pLwFBCFrameGrabInfo, DWORD dwFlags=0, DWORD dwGrabMode=0, DWORD dwTargetWidth=0, DWORD dwTargetHeight=0, DWORD dwStartX=0, DWORD dwStartY=0)
//!
//! \return LWAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D9_LWFBC_CaptureBufferToSys(IDirect3DDevice9 *pDev, void * pLwFBCFrameGrabInfo, DWORD dwFlags=0, DWORD dwGrabMode=0, DWORD dwTargetWidth=0, DWORD dwTargetHeight=0, DWORD dwStartX=0, DWORD dwStartY=0);

#endif // defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_LWFBC_GetStatus
//
//! \fn LwAPI_D3D9_LWFBC_GetStatus(void * pLwFBCStatus)
//!   DESCRIPTION: This API returns the current status with regard to the LWFBC subsystem.  
//!
//! \param [in] pLwFBCStatus Pointer to a structure for the status of the LWFBC subsystem.
//!
//! \retval ::LWAPI_OK if the call succeeded
//
/////////////////////////////////////////////////////////////////////////////


//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D9_LWFBC_GetStatus(void * pLwFBCStatus);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_IFR_SetUpTargetBufferToSys
//
//!   DESCRIPTION: This API requests the driver to allocate n buffers (up to a maximum of 3). 
//!                Additional calls to LwAPI_D3D9_IFR_SetUpTargetBufferToSys() will free the buffers that were allocated previously with the same call on the d3d device. 
//!
//!
//! \param [in]   pDev       The device to get primary surface on
//! \param [in]   eFormat    The format of the blit
//! \param [in]   dwNBuffers The number of buffers in ppBuffer (max 6).
//! \param [in]   ppBuffer   A pointer to an array of dwNBuffers (max 6) pointers. Virtual memory buffers will be allocated by the driver.
//!
//! \return ::LWAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
__lwapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")
LWAPI_INTERFACE LwAPI_D3D9_IFR_SetUpTargetBufferToSys(IDirect3DDevice9 *pDev, LWFBC_BUFFER_FORMAT eFormat, DWORD dwNBuffers, unsigned char ** ppBuffer);
 

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_GPUBasedCPUSleep
//
//! \fn LwAPI_D3D9_GPUBasedCPUSleep(IDirect3DDevice9 *pDev, LwU64 qwMicroSeconds)
//!   DESCRIPTION: This API provides sub-quantum (usually 16 ms) sleep that does not burn CPU cycles. 
//!
//! \param [in] pDev           The device for which to get the primary surface 
//! \param [in] qwMicroSeconds The number of micro-seconds to block the CPU thread
//!
//! \return ::LWAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D9_GPUBasedCPUSleep(IDirect3DDevice9 *pDev, LwU64 qwMicroSeconds);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_IFR_TransferRenderTarget
//
//!  DESCRIPTION: This API copies the current rendertarget into the provided system memory buffer.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device to get primary surface on
//! \param [in]      pEvent    When not NULL, will receive a handle to an event that the driver will signal 
//!                            upon completion of LwAPI_D3D9_IFR_TransferRenderTarget().
//! \param [in]      dwBufferIndex  The index of the buffer that will receive a copy of the rendertarget. 
//!                                 This ordinal is between 0 and the number of buffer created by LwAPI_D3D9_IFR_SetUpTargetBufferToSys().
//! \param [in]      dwTargetWidth  When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//! \param [in]      dwTargetHeight When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//!
//! \return ::LWAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")
LWAPI_INTERFACE LwAPI_D3D9_IFR_TransferRenderTarget(IDirect3DDevice9 *pDev, HANDLE * pEvent, DWORD dwBufferIndex, DWORD dwTargetWidth, DWORD dwTargetHeight);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_IFR_SetUpTargetBufferToLW12BLVideoSurface
//
//!   DESCRIPTION: This API requests the driver to allocate n buffers (up to a maximum of 3). 
//!                Additional calls to LwAPI_D3D9_IFR_SetUpTargetBufferToSys() will free the buffers that were allocated previously with the same call on the d3d device. 
//!
//!
//! \since Release: 295
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   pDev       The device to get primary surface on
//! \param [in]   dwNBuffers The number of buffers in ppBuffer (max 3).
//! \param [in]   aHandles   A pointer to an array of videolibrary surfaces.
//!
//! \return ::LWAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

__lwapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")
LWAPI_INTERFACE LwAPI_D3D9_IFR_SetUpTargetBufferToLW12BLVideoSurface(IDirect3DDevice9 *pDev, DWORD dwNBuffers, HANDLE * aHandles, DWORD dwTargetWidth, DWORD dwTargetHeight);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_IFR_TransferRenderTargetToLW12BLVideoSurface
//
//!  DESCRIPTION: This API copies the current rendertarget into the provided system memory buffer.
//!
//! \since Release: 295
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device to get primary surface on
//! \param [in]      dwBufferIndex  The index of the buffer that will receive a copy of the rendertarget. 
//!                                 This ordinal is between 0 and the number of buffer created by LwAPI_D3D9_IFR_SetUpTargetBufferToLW12BLVideoSurface().
//! \param [in]      dwTargetWidth  When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//! \param [in]      dwTargetHeight When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//!
//! \return ::LWAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")
LWAPI_INTERFACE LwAPI_D3D9_IFR_TransferRenderTargetToLW12BLVideoSurface(IDirect3DDevice9 *pDev, DWORD dwBufferIndex, DWORD dwTargetWidth, DWORD dwTargetHeight);

#endif // defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_IFR_CreateSharedSurface
//
//!
//! \since Release: 304
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device that creates/owns the shared surface
//! \param [in]      dwWidth  
//! \param [in]      dwHeight 
//!
//! \return ::LWAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

typedef void * IFRSharedSurfaceHandle;

__lwapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")
LWAPI_INTERFACE LwAPI_D3D9_IFR_CreateSharedSurface(IDirect3DDevice9 *pDev, DWORD dwWidth, DWORD dwHeight, IFRSharedSurfaceHandle * phLwIFRSharedSurface);

#endif // defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_IFR_DestroySharedSurface
//
//!
//! \since Release: 304
//! 
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device that created the shared surface
//!
//! \return ::LWAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

__lwapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")

LWAPI_INTERFACE LwAPI_D3D9_IFR_DestroySharedSurface(IDirect3DDevice9 *pDev, IFRSharedSurfaceHandle hLwIFRSharedSurface);

#endif // defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_IFR_CopyToSharedSurface
//
//!
//! \since Release: 304
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device that will do the blit
//!
//! \return ::LWAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

__lwapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")

LWAPI_INTERFACE LwAPI_D3D9_IFR_CopyToSharedSurface(IDirect3DDevice9 *pDev, IFRSharedSurfaceHandle hLwIFRSharedSurface, IDirect3DSurface9 * pSurface);

#endif // defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_IFR_CopyFromSharedSurface
//
//!
//! \since Release: 304
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device that will do the blit
//!
//! \return ::LWAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

__lwapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")

LWAPI_INTERFACE LwAPI_D3D9_IFR_CopyFromSharedSurface(IDirect3DDevice9 *pDev, IFRSharedSurfaceHandle hLwIFRSharedSurface, IDirect3DSurface9 * pSurface);

#endif // defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_IFR_CreateCrossProcessSharedSurface
//! \fn LwAPI_D3D9_IFR_CreateCrossProcessSharedSurface(__in IDirect3DDevice9 * pDev,
//!                                                    __inout LWIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS * pParams)
//!
//! \since Release: 340
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device that creates/owns the shared surface
//! \param [inout]   pParams   Shared surface creation parameters 
//!
//! \retval      LWAPI_OK                       Call succeeded
//! \retval      LWAPI_ILWALID_ARGUMENT         One or more arguments are invalid
//! \retval      LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found
//! \retval      LWAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.
//! \retval      LWAPI_ERROR                    An unidentified error oclwrred
//! \retval      LWAPI_ILWALID_POINTER          A NULL pointer was passed
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
typedef struct _LWIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_V1
{
    LwU32 version;                                                           //!< [in]  Struct version. Set to LWIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_VER.
    LwU32 width;                                                             //!< [in]  Width of shared surface
    LwU32 height;                                                            //!< [in]  Height of shared surface
    LwU32 pitch;                                                             //!< [out] Pitch of allocated shared surface
    LwU32 linearSize;                                                        //!< [out] Size of allocation in bytes
    LwU32 driverAllocationSize;                                           //!< [out] Size of driver data structure
    LwU64 framebufOffset;                                                          //!< [out] Frame Buffer offset of shared surface allocation
    LwU64 masterMemAllocPtr;                                                  //!< [out] Allocation info
} LWIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_V1;

typedef LWIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_V1 LWIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS;
#define LWIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_VER1  MAKE_LWAPI_VERSION(LWIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_V1,1)
#define LWIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_VER LWIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_VER1


LWAPI_INTERFACE LwAPI_D3D9_IFR_CreateCrossProcessSharedSurface(__in IDirect3DDevice9 * pDev, __inout LWIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS * pParams);

#endif // defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_IFR_CopyFromCrossProcessSharedSurface
//! \fn LwAPI_D3D9_IFR_CopyFromCrossProcessSharedSurface (__in IDirect3DDevice9 * pDevice, __in LWIFR_CROSSPROC_COPY_PARAMS * pParams)
//!
//! \since Release: 340
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDevice      The device that creates/owns the shared surface
//! \param [in]      pParams      Copy parameters
//!
//! \retval      LWAPI_OK                       Call succeeded
//! \retval      LWAPI_ILWALID_ARGUMENT         One or more arguments are invalid
//! \retval      LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found
//! \retval      LWAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.
//! \retval      LWAPI_ERROR                    An unidentified error oclwrred
//! \retval      LWAPI_ILWALID_POINTER          A NULL pointer was passed
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

typedef struct _LWIFR_CROSSPROC_COPY_PARAMS
{
    LwU32 version;                                                           //!< [in] Struct version. Set to LWIFR_CROSSPROC_COPY_PARAMS_VER.
    LwU32 width;                                                             //!< [in] Width of shared surface
    LwU32 height;                                                            //!< [in] Height of shared surface
    LwU32 pitch;                                                             //!< [in] Pitch of shraed surface
    LwU64 sharedAlloc;                                                        //!< [in] Shared memory allocation
    LwU64 surface;                                                            //!< [in] directx9 surface
} LWIFR_CROSSPROC_COPY_PARAMS_V1;
typedef LWIFR_CROSSPROC_COPY_PARAMS_V1 LWIFR_CROSSPROC_COPY_PARAMS;
#define LWIFR_CROSSPROC_COPY_PARAMS_VER1  MAKE_LWAPI_VERSION(LWIFR_CROSSPROC_COPY_PARAMS_V1,1)
#define LWIFR_CROSSPROC_COPY_PARAMS_VER LWIFR_CROSSPROC_COPY_PARAMS_VER1

LWAPI_INTERFACE LwAPI_D3D9_IFR_CopyFromCrossProcessSharedSurface(__in IDirect3DDevice9 * pDevice, __in LWIFR_CROSSPROC_COPY_PARAMS * pParams);

#endif // defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_IFR_ConnectToCrossProcessSharedSurface
//! \fn LwAPI_D3D9_IFR_ConnectToCrossProcessSharedSurface(__in IDirect3DDevice9 * pDevice,
//!                                                       __inout LWIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS * pParams)
//!
//! \since Release: 340
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDevice      The device that creates/owns the shared surface
//! \param [inout]   pParams      Shared surface client connection parameters
//!
//! \retval      LWAPI_OK                       Call succeeded
//! \retval      LWAPI_ILWALID_ARGUMENT         One or more arguments are invalid
//! \retval      LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found
//! \retval      LWAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.
//! \retval      LWAPI_ERROR                    An unidentified error oclwrred
//! \retval      LWAPI_ILWALID_POINTER          A NULL pointer was passed
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

typedef struct _LWIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_V1
{
    LwU32 version;                                                           //!< [in] Struct version. Set to LWIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_VER.
    LwU32 linearSize;                                                        //!< [in] Size of shared memory allocation in bytes
    LwU64 framebufOffset;                                                          //!< [in] Frame Buffer Offset of shared allocation
    LwU64 clientMasterMirrorMemAllocPtr;                                      //!< [in] Master handle for shared surface allocation
    LwU64 clientMemAllocPtr;                                                  //!< [out] Client handle for shared surface allocation
} LWIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_V1;
typedef LWIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_V1 LWIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS;
#define LWIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_VER1  MAKE_LWAPI_VERSION(LWIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_V1,1)
#define LWIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_VER LWIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_VER1

LWAPI_INTERFACE LwAPI_D3D9_IFR_ConnectToCrossProcessSharedSurface(__in IDirect3DDevice9 * pDevice, __inout LWIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS * pParams);

#endif // defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_IFR_CopyToCrossProcessSharedSurface
//
//!
//! \since Release: 340
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDevice      The device that creates/owns the shared surface
//! \param [in]      pParams      Shared surface copy parameters
//!
//! \retval      LWAPI_OK                       Call succeeded
//! \retval      LWAPI_ILWALID_ARGUMENT         One or more arguments are invalid
//! \retval      LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found
//! \retval      LWAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.
//! \retval      LWAPI_ERROR                    An unidentified error oclwrred
//! \retval      LWAPI_ILWALID_POINTER          A NULL pointer was passed
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

LWAPI_INTERFACE LwAPI_D3D9_IFR_CopyToCrossProcessSharedSurface(__in IDirect3DDevice9 * pDevice, __in LWIFR_CROSSPROC_COPY_PARAMS * pParams);

#endif // defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_IFR_DisconnectCrossProcessSharedSurface

//!
//! \since Release: 340
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDevice      The device that creates/owns the shared surface
//! \param [in]      pSharedAlloc Shared surface allocation handle
//!
//! \retval      LWAPI_OK                       Call succeeded
//! \retval      LWAPI_ILWALID_ARGUMENT         One or more arguments are invalid
//! \retval      LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found
//! \retval      LWAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.
//! \retval      LWAPI_ERROR                    An unidentified error oclwrred
//! \retval      LWAPI_ILWALID_POINTER          A NULL pointer was passed
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

LWAPI_INTERFACE LwAPI_D3D9_IFR_DisconnectCrossProcessSharedSurface(__in IDirect3DDevice9 * pDevice, __in void * pSharedAlloc);

#endif // defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_IFR_DestroyCrossProcessSharedSurface
//
//!
//! \since Release: 340
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDevice      The device that creates/owns the shared surface
//! \param [in]      pSharedAlloc Shared surface allocation handle
//!
//! \retval      LWAPI_OK                       Call succeeded
//! \retval      LWAPI_ILWALID_ARGUMENT         One or more arguments are invalid
//! \retval      LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU GPU driving a display was found
//! \retval      LWAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.
//! \retval      LWAPI_ERROR                    An unidentified error oclwrred
//! \retval      LWAPI_ILWALID_POINTER          A NULL pointer was passed
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

LWAPI_INTERFACE LwAPI_D3D9_IFR_DestroyCrossProcessSharedSurface(__in IDirect3DDevice9 * pDevice, __in void * pSharedAlloc);

#endif // defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_FBC_CheckSupport
//
//!
//! \since Release: 304
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device that will do the blit
//! \param [in]      pParam    The vesion check params
//!
//! \return ::LWAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

typedef struct 
{
    DWORD dwVersion;
    DWORD dwType;
    DWORD bSupported   : 1;
    DWORD bLwEncLogoNeeded : 1;
    DWORD bReservedBits : 30;
    DWORD dwPrivateDataSize;
    void* pPrivateData;
    DWORD dwReserved[60];
    void* pReserved[31];
} LwFBCCheckSupportParams;

LWAPI_INTERFACE LwAPI_D3D9_FBC_CheckSupport(IDirect3DDevice9 *pDev, void * pParam);

#endif // defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
//! \fn LwAPI_D3D9_LWFBC_FORCE_GRAB_FULL_FRAME(__inout LWFBC_FORCE_GRAB_FULL_FRAME * pParam);
//!
//!
//! DESCRIPTION: Forces LwFBC to grab full screen surface irrespective of subrect dimensions inside Present call
//!
//! \since Release: 319
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]            version
//! \param [in]            bForceGrabFullFrame             Bool variable forces KMD to grab full screen in win7-aero off if set to 1
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!          (None)
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

typedef struct 
{
    LwU32                   version;                             // in Struct version
    LwU64                   forceGrabFullFrame: 1;                     // in In case of LwFBC + win7 + aero off, for first screen capture whole desktop
    LwU64                   ReservedBits      : 63;                    // Reserved
    LwU64                   Reserved[5];                               // Reserved
} LWFBC_FORCE_GRAB_FULL_FRAME;

#define LWFBC_FORCE_GRAB_FULL_FRAME_VER    MAKE_LWAPI_VERSION(LWFBC_FORCE_GRAB_FULL_FRAME, 1)

LWAPI_INTERFACE LwAPI_D3D9_LWFBC_FORCE_GRAB_FULL_FRAME(__inout LWFBC_FORCE_GRAB_FULL_FRAME * pParam);

#endif // defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)
typedef enum
{
    LWFBC_CAPS_YUV444_NATIVE_SUPPORT =  0
} LWFBC_CAPS_TYPE;


///////////////////////////////////////////////////////////////////////////////
//
//! FUNCTION NAME: LwAPI_D3D9_LWFBC_GetCaps(__in IDirect3DDevice9 *pDev, __in DWORD dwCaptype , __out unsigned int * pResult);
//!
//!
//! DESCRIPTION: Get caps from LwFBC
//!
//! \since Release: 331
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]            LWFBC_CAPS_TYPE
//! \param [out]           pResult
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!          (None)
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////


LWAPI_INTERFACE LwAPI_D3D9_LWFBC_GetCaps(IDirect3DDevice9 *pDev, __in LWFBC_CAPS_TYPE dwCaptype , __out int * pResult);

#endif // defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)

typedef struct _LWFBC_MOUSE_CAPTURE_SETUP
{
    LwU32                           dwVersion;              // Struct Version
    HANDLE                          handle;                 // Event handle created by lwfbc, store it in KMD through escape call
    DWORD                           vidPnSourceId;          // vidPnSource associated with lwfbc
} LWFBC_MOUSE_CAPTURE_SETUP;

///////////////////////////////////////////////////////////////////////////////
//
//!FUNCTION NAME: LwAPI_D3D9_LWFBC_MOUSE_CAPTURE_SETUP
//!
//!  DESCRIPTION: This API is called one time to pass event handle in KMD through escape call
//!
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]            pParam        contains event handle
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

#define LWFBC_MOUSE_CAPTURE_SETUP_VER    MAKE_LWAPI_VERSION(LWFBC_MOUSE_CAPTURE_SETUP, 1)

LWAPI_INTERFACE LwAPI_D3D9_LWFBC_MOUSE_CAPTURE_SETUP(__in LWFBC_MOUSE_CAPTURE_SETUP * pParam);

#endif // defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)

typedef struct _LWFBC_MOUSE_CAPTURE_V1
{
    LwU32   dwVersion;           // [in] Struct version
    LwU32   bIsHwLwrsor;         // [out] Indicates if HW cursor is in use
    LwU32   width;               // [out] Cursor glyph width
    LwU32   height;              // [out] Cursor glyph height
    LwU32   pitch;               // [out] Cursor glyph stride
    BYTE*   pPixels;             // [inout] Cursor image
} LWFBC_MOUSE_CAPTURE_V1;
#define LWFBC_MOUSE_CAPTURE_VER_1    MAKE_LWAPI_VERSION(LWFBC_MOUSE_CAPTURE, 1)

typedef struct _LWFBC_MOUSE_CAPTURE_V2
{
    LwU32   version;             // [in] Struct version
    LwU32   isHwLwrsor;          // [out] Indicates if HW cursor is in use
    LwU32   width;               // [out] Cursor glyph width
    LwU32   height;              // [out] Cursor glyph height
    LwU32   pitch;               // [out] Cursor glyph stride
    LwU8*   pixels;             // [inout] Cursor image
    LwU32   hotSpotX;            // [out] Cursor hotspot x-coordinate
    LwU32   hotSpotY;            // [out] Cursor hotspot y-coordinate
    LwU32   flags;               // [out] Cursor Flags
} LWFBC_MOUSE_CAPTURE_V2;
#define LWFBC_MOUSE_CAPTURE_VER_2    MAKE_LWAPI_VERSION(LWFBC_MOUSE_CAPTURE, 2)
#define LWFBC_MOUSE_CAPTURE_VER LWFBC_MOUSE_CAPTURE_VER_2
typedef LWFBC_MOUSE_CAPTURE_V2  LWFBC_MOUSE_CAPTURE;

///////////////////////////////////////////////////////////////////////////////
//
//!FUNCTION NAME: LwAPI_D3D9_LWFBC_MOUSE_CAPTURE
//!
//!  DESCRIPTION: This API is called every time shape of mouse changes
//!
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \pDev  [in]               pDev
//! \param [inout]            pParam
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////


LWAPI_INTERFACE LwAPI_D3D9_LWFBC_MOUSE_CAPTURE(__in IDirect3DDevice9 *pDev, __inout LWFBC_MOUSE_CAPTURE * pParam);

#endif // defined(_D3D9_H_) && defined(__cplusplus)


//-----------------------------------------------------------------------------
// Direct3D9 Sharing surface API
//-----------------------------------------------------------------------------

#if defined(_D3D9_H_) && defined(__cplusplus)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_BeginShareResource
//! \fn API_D3D9_BeginShareResource(IDirect3DDevice9 *pDev,
//!                                              IDirect3DResource9 *pResource,
//!                                              UINT32 flags,
//!                                              HANDLE *pHandle)
//! \code
//!   DESCRIPTION:   Starts sharing the given resource, and increases the refcount of it.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! INPUT:           pDev          (IN)     The device which created the resource.
//!                  pResource     (IN)     The resource to be shared.
//!                  flags         (IN)     Flags
//!                  pHandle       (OUT)    The shared handle of the given resource 
//!                  pLocation     (OUT)    Return the location where the shared resource is allocated.
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ILWALID_ARGUMENT - invalid argument
//!                  LWAPI_NO_IMPLEMENTATION
//!                  LWAPI_ERROR - generic error
//!                  LWAPI_SHARE_RESOURCE_RELOCATED - the surface is relocated away from vidmem
//! \endcode
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dx
enum LWAPI_SHARE_RESOURCE_FLAGS
{
    LWAPI_SHARE_RESOURCE_FLAGS_NONE                = 0x0,
    LWAPI_SHARE_RESOURCE_FLAGS_DISCARD             = 0x1,   //!< Discard the current content
    LWAPI_SHARE_RESOURCE_FLAGS_FAIL_IF_RELOCATED   = 0x2,   //!< Fail if the surface is relocated away from vidmem.
    LWAPI_SHARE_RESOURCE_FLAGS_DISABLE_CPU_ACCESS  = 0x4,   //!< Disable CPU access to the resource
};

//! \ingroup dx
enum LWAPI_SHARE_RESOURCE_LOCATION
{
    LWAPI_SHARE_RESOURCE_LOCATION_UNKNOWN    = 0,
    LWAPI_SHARE_RESOURCE_LOCATION_VIDMEM     = 1,
    LWAPI_SHARE_RESOURCE_LOCATION_SYSMEM     = 2
};

//! \ingroup dx                                             
LWAPI_INTERFACE LwAPI_D3D9_BeginShareResource(IDirect3DDevice9 *pDev,
                                              IDirect3DResource9 *pResource,
                                              UINT32 flags,
                                              HANDLE *pHandle);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_EndShareResource
//
//! \code 
//!   DESCRIPTION:   Ends sharing the given resource.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! INPUT:           pDev          (IN)     The device which created the resource.
//!                  pResource     (IN)     The shared resource.
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ILWALID_ARGUMENT - invalid argument
//!                  LWAPI_ERROR - generic error
//! \endcode
//! \ingroup dx
/////////////////////////////////////////////////////////////////////////////////                       
LWAPI_INTERFACE LwAPI_D3D9_EndShareResource(IDirect3DDevice9 *pDev, IDirect3DResource9 *pResource);
  
#endif // defined(_D3D9_H_) && defined(__cplusplus)

//! \ingroup dx
//! Hash size.
#define LWAPI_GFE_ECID_HASH_SIZE_IN_BYTES                    (32)

//! \ingroup dx
//! Signed buffer size
#define LWAPI_GFE_SIGNED_ECID_RSA_1024_BUF_SIZE              (0x00000080)
#define LWAPI_GFE_SIGNED_ECID_RSA_2048_BUF_SIZE              (0x00000160)

//! \ingroup dx
//! Signing algorithms
#define LWAPI_GFE_SIGN_ECID_SIGNALGO_RSA_1024                (0x00000001)
#define LWAPI_GFE_SIGN_ECID_SIGNALGO_RSA_2048                (0x00000002)

//! \ingroup dx
//! GPU ECID data.
typedef struct _LWAPI_GPU_ECID
{
    LwU8                ecidSha2Hash[LWAPI_GFE_ECID_HASH_SIZE_IN_BYTES]; //! SHA hashed ECID value.
} LWAPI_GPU_ECID;

//! \ingroup dx
//! Input matrix to the RSA signing API.
typedef struct _LWAPI_SIGN_GPUID_INPUT
{
    LwU32                   version;            //! version info
    LwU8                    Nonce[16];          //! 16 Byte random number to be passed by the client.
    LwU8                    ProgramId[4];       //! 4 Byte Program Id to be passed by the client.
    LwU8                    SessionId[4];       //! 4 Byte Session Id to be passed by the client.
    LwU8                    SignAlgo[4];        //! The algo to be used for signing of payload.
}LWAPI_SIGN_GPUID_INPUT;

//! \ingroup dx
//! Macro for constructing version field of LWAPI_SIGN_GPUID_OUTPUT
#define LWAPI_SIGN_GPUID_INPUT_VERSION_1   MAKE_LWAPI_VERSION(LWAPI_SIGN_GPUID_INPUT, 1)

//! \ingroup dx
//! Encrypted public key info
typedef struct _LWAPI_ENCRYPTED_KEY_INFO
{
    LwU8                    *pEncryptedKey;         //! The encrypted public key to be send from the server.
    LwU32                   uEncryptedKeySize;      //! Size of the encrypted public key buffer.
} LWAPI_ENCRYPTED_KEY_INFO;

//! \ingroup dx
//! Output matrix for the RSA signing API. The signedValue buffer has be to allocated
//! by the caller and correct size of the buffer should be passed.
//! The return code (retCode) can have following values. Bits marked X are don't care.
//!     GFE_READ_ECID_ERROR_NONE                    (0x00000000)
//!     GFE_READ_ECID_ERROR_ILWALID_BUF_SIZE        (0x00000001)
//!     GFE_READ_ECID_ERROR_SIGN_MODE_UNSUPPORTED   (0x00000002)
//!     GFE_READ_ECID_ERROR_KEY_VERIF_FAILED        (0x00000003)
//!     GFE_READ_ECID_ERROR_UNKNOWN                 (0xXXXXFFFF)
typedef struct _LWAPI_SIGN_GPUID_OUTPUT
{
    LWAPI_SIGN_GPUID_INPUT  stInput;            //! Copy of the input data just for sanity.
    LWAPI_GPU_ECID          stEcid;             //! Actual ECID data.
    LwU32                   uCodeVersion;       //! Version of the uCode used.
    LwU32                   retCode;            //! Return code from driver.
}LWAPI_SIGN_GPUID_OUTPUT;

//! The output buffer returned by the function is in the below format
//! /////////////////////////////////////////////////////////////////
//! struct LWAPI_SIGN_GPUID_OUTPUT
//! /////////////////////////////////////////////////////////////////
//! Followed by actual signed buffer.
//! /////////////////////////////////////////////////////////////////

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D9_GetSignedGPUID
//
//!   DESCRIPTION:   This function call returns the signed ECID value.
//!                  The pOutputBuffer must be allocated by the caller 
//!                  and the correct size of the allocated buffer must
//!                  be specified in uOutputBufferSize
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev               The device which created the resource.
//! \param [in]      input              The input structure contained all values that is to be used for signing.
//! \param [out]     pOutputBuffer      The output buffer that contains the GPU ID and the signed buffer.
//! \param [in]      uOutBufferSize     The size of the output buffer.

//!
//! \return This API can return any of the error codes enumerated in
//! LwAPI_Status. If there are return error codes with specific
//! meaning for this API, they are listed below.
//! \ingroup dx
/////////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_GetSignedGPUID(__in IDirect3DDevice9 *pDev, 
                                          __in LWAPI_SIGN_GPUID_INPUT *pInput, 
                                          __in LWAPI_ENCRYPTED_KEY_INFO *pKeyInfo, 
                                          __out unsigned char* pOutputBuffer, 
                                          __in LwU32 uOutputBufferSize);
#endif // defined(_D3D9_H_) && defined(__cplusplus)

#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_D3D_GetSignedGPUID
//
//!   DESCRIPTION:   This function call returns the signed ECID value.
//!                  The pOutputBuffer must be allocated by the caller 
//!                  and the correct size of the allocated buffer must
//!                  be specified in uOutputBufferSize
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      hPhysicalGpu       The GPU handle for which the ECID is to be retrieved.
//! \param [in]      input              The input structure contained all values that is to be used for signing.
//! \param [out]     pOutputBuffer      The output buffer that contains the GPU ID and the signed buffer.
//! \param [in]      uOutBufferSize     The size of the output buffer.

//!
//! \return This API can return any of the error codes enumerated in
//! LwAPI_Status. If there are return error codes with specific
//! meaning for this API, they are listed below.
//! \ingroup dx
/////////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D_GetSignedGPUID(__in LwPhysicalGpuHandle hPhysicalGpu, 
                                          __in LWAPI_SIGN_GPUID_INPUT *pInput, 
                                          __in LWAPI_ENCRYPTED_KEY_INFO *pKeyInfo, 
                                          __out unsigned char* pOutputBuffer, 
                                          __in LwU32 uOutputBufferSize);
  
#endif // defined(__cplusplus) && defined(__d3d10_h__)


//-----------------------------------------------------------------------------
// Direct3D10 APIs
//-----------------------------------------------------------------------------

#if defined(__cplusplus) && defined(__d3d10_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_AliasPrimaryAsTexture
//
//!   DESCRIPTION: This function creates a texture that is an alias of the current device's
//!                primary surface
//!
//!  \note The texture returned is created without any CPU access flags. Locking
//!        to read from the texture should be done by creating a second
//!        application. Otherwise, this texture can be used as any normal
//!        Direct3D texture (it can be blitted from, used as a texture in a
//!        pixel shader, etc.)
//!
//!        This texture is not a render target and cannot be rendered to.
//!
//!        Before this texture is used, the application must call
//!        LwAPI_D3D10_ProcessFlipChainCallbacks() to properly update any internal
//!        driver state.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 173
//!
//!   \param [in]  pDev        The device to get the primary surface from
//!   \param [in]  dwHeadIndex The index to the head to alias
//!   \param [out] ppTexture   Filled with the texture created
//!
//!   \retval      LWAPI_OK    The texture was successfully created.
//!   \retval      LWAPI_ERROR The texture could not be created.
//!
//!   \ingroup dx
/////////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_AliasPrimaryAsTexture(ID3D10Device *pDev,
                                             LwU32 headIndex,
                                             ID3D10Texture2D **ppTexture);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
//! \ingroup dx
typedef void (*LWAPI_PRIMARY_FLIP_CHAIN_CALLBACK)(LwU32);

//! \ingroup dx
//! Used by LWAPI_PRIMARY_FLIP_CHAIN_CALLBACK.
typedef struct
{
    LwU32                     version;              //!< structure version (IN)

    LWAPI_PRIMARY_FLIP_CHAIN_CALLBACK pPrimaryFlipped; //!< A callback function to be notified
                                                       //!  when the primary flip oclwrred.

    LWAPI_PRIMARY_FLIP_CHAIN_CALLBACK pPrimaryFlipChainModified; //!< A callback function to be notified
                                                                 //!  when the primary flip chain has
                                                                 //!  been modified, either due to a new
                                                                 //!  surface being added, an existing
                                                                 //!  surface being removed, or the resolution
                                                                 //!  being changed. In response to this
                                                                 //!  an application MUST recreate any
                                                                 //!  aliased primary surfaces with
                                                                 //!  LwAPI_D3D10_AliasPrimaryAsTexture()
                                                                 //!  as the existing texture will be invalid.

    LWAPI_PRIMARY_FLIP_CHAIN_CALLBACK pPrimaryAliasIlwalid; //!< An error oclwred while using a texture
                                                            //!  created with LwAPI_D3D10_AliasPrimaryAsTexture().
                                                            //!  The texture needs to be re-created.

    LWAPI_PRIMARY_FLIP_CHAIN_CALLBACK pPrimaryAliasOperationDropped; //!< An operation using the primary alias
                                                                     //!  was not completed because a flip
                                                                     //!  happened while the operation
                                                                     //!  was in progress. The last operation
                                                                     //!  may have operated on an incomplete
                                                                     //!  primary, and should be retried.

    LWAPI_PRIMARY_FLIP_CHAIN_CALLBACK pLwrsorVisibleUpdated;  //!< A callback function to be notified
                                                              //!  when the cursor visibility has been toggled

    LWAPI_PRIMARY_FLIP_CHAIN_CALLBACK pLwrsorShapeUpdated; //!< A callback function to be notified
                                                           //!  when the cursor shape has been updated

} LWAPI_FLIP_CHAIN_CALLBACK_PARAMS;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_SetPrimaryFlipChainCallbacks
//
//!   DESCRIPTION: Defines callback functions to receive notification about
//!                certain events relating to the primary flip chain.
//!
//!   \note The events will only be registered at this time. To receive the events
//!         an application must call LwAPI_D3D10_ProcessFlipChainCallbacks().
//!
//!         An application may change it's callback functions at any time, and may
//!         unregister from any function by passing NULL in as a function pointer.
//! 
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 173
//!
//!   \param [in]  pDev             The device to receive events on
//!   \param [in]  pCallbackParams  A structure containing function
//!                                 pointers that will receive the events.
//!                                 A pointer may be set to NULL if
//!                                 an application does not wish to receive
//!                                 the notification.
//!
//!  \return LWAPI_OK if the events were registered successfully
//!
//!  \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_SetPrimaryFlipChainCallbacks(ID3D10Device *pDev,
                                             const LWAPI_FLIP_CHAIN_CALLBACK_PARAMS* pCallbackParams);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_ProcessCallbacks
//
//!   DESCRIPTION: This function processes pending events. 
//!
//! \note All callback functions are passed the head index for the event.
//!
//!       This will call the registered callbacks for any events pending. With
//!       the exeception of the primary flipped callback, an application cannot
//!       "miss" an event if the event were to be notified while the
//!       application was not calling ProcessCallbacks. The application
//!       will receive this event the first time it calls ProcessCallbacks
//!       after the event happened.
//!
//!       The flipped event is an exception to this rule. This callback will
//!       only be fired for flips that occur after the application calls
//!       ProcessCallbacks.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 173
//!
//!   \param [in]  pDev            The device to process events on
//!   \param [in]  dwMilliseconds  The number of milliseconds to sleep while
//!                                waiting for events before returning. This
//!                                can be zero to only process any outstanding
//!                                events, or INFINITE if the application
//!                                wishes to wait forever.
//!
//!   \return  LWAPI_OK if events were properly processed
//!
//!   \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_ProcessCallbacks(ID3D10Device *pDev,
                                             LwU32 dwMilliseconds);


 
#endif //defined(__cplusplus) && defined(__d3d10_h__)



#if defined(__cplusplus) && defined(__d3d10_h__)
//! \ingroup dx
//! Used in 
typedef enum
{
    LW_HW_LWRSOR_COLOR_FORMAT_MONOCHROME     = 0,
    LW_HW_LWRSOR_COLOR_FORMAT_COLOR          = 1,
    LW_HW_LWRSOR_COLOR_FORMAT_MASKED_COLOR   = 2
} LW_HW_LWRSOR_COLOR_FORMAT_FLAGS;

//! \ingroup dx
//! Used in LwAPI_D3D10_GetRenderedLwrsorAsBitmap().
typedef struct _LWAPI_RENDERED_LWRSOR_BITMAP_DATA
{
    LwU32 version;     //!< (in) version info
    LwU32 headIndex;   //!< (in) head index to get cursor on
    LwU32 bufferSize;  //!< (in) size of raw bitmap data buffer
    PBITMAP pBitmap;   //!< (in/out) bitmap data for rendered cursor
    LwU32 xHot;        //!< (out) x value for Hotspot
    LwU32 yHot;        //!< (out) y value for Hotspot
    LW_HW_LWRSOR_COLOR_FORMAT_FLAGS formatFlag; //!, (out) cursor color format
    LwU32 bVisible;    //!< (out) cursor visibility (0 = not visible, 1 = visible)
} LWAPI_RENDERED_LWRSOR_BITMAP_DATA;


//! \ingroup dx
//! Macro for constructing theversion field of _LWAPI_RENDERED_LWRSOR_BITMAP_DATA
#define LWAPI_RENDERED_LWRSOR_BITMAP_DATA_VER  MAKE_LWAPI_VERSION(LWAPI_RENDERED_LWRSOR_BITMAP_DATA,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_GetRenderedLwrsorAsBitmap
//
//!   DESCRIPTION:  This function provides a bitmap of the hardware cursor and the visible
//!                 state of the cursor at the time the bitmap is captured.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 173
//!
//!   \param [in]     pDev                       The device from which to get the rendered cursor
//!   \param [in,out] pRenderedLwrsorBitmapData  Structure for input/output with fields as follows:
//!                                              - headIndex:  [input] The display head from which to get the cursor  
//!                                              - bufferSize: [input] The size of the buffer for storing raw bitmap data
//!                                              - pBitmap:    [output] Bitmap data for the rendered cursor.  
//!                                                                     Note that this result data is undefined in the
//!                                                                     case where LWAPI_OK is not the return status
//!                                              - xHot: [output] Location of the X hot spot in the bitmap
//!                                              - yHot: [output] Location of the Y hot spot in the bitmap
//!                                              - formatFlag: [output] Cursor format (monochrome, color, or masked color)
//!                                                                     For monochrome or masked color formats, the corresponding bitmap
//!                                                                     format is ROP1R5G5B5.  For color format, the bitmap format is A8R8G8B8.   //!   
//!                                              - pVisible: [output]  Boolean:  zero=not visible, one=visible
//!
//!   \return LWAPI_OK if the cursor bitmap is successfully returned
//!
//!  \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_GetRenderedLwrsorAsBitmap(ID3D10Device *pDev,
                                                      LWAPI_RENDERED_LWRSOR_BITMAP_DATA *pRenderedLwrsorBitmapData);

#endif //defined(__cplusplus) && defined(__d3d10_h__)




#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_BeginShareResource
//
//!   DESCRIPTION:  This API recreates the resource as a shared resource.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   pResource   The resource to recreate as shared
//! \param [out]  pHandle     The shared resource handle
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                 If there are return error codes with specific meaning for this API, they are listed below.
//!                 (None)
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_BeginShareResource(ID3D10Resource *pResource,
                                               HANDLE         *pHandle);


#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_BeginShareResourceEx
//
//!   DESCRIPTION:  This API is similar to LwAPI_D3D10_BeginShareResource(), except it takes an additional flag parameter.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]  pResource   The resource to recreate as shared
//! \param [in]  flags       Should be one of LWAPI_SHARE_RESOURCE_FLAGS
//! \param [out] pHandle     The shared resource handle
//!
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                 If there are return error codes with specific meaning for this API, they are listed below.
//!                 (None)
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_BeginShareResourceEx(ID3D10Resource *pResource,
                                                 UINT32          flags,
                                                 HANDLE         *pHandle);



#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_EndShareResource
//
//!   DESCRIPTION:  This API restores the original resource.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] pResource    The resource that was shared using LwAPI_D3D10_BeginShareResource
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                 If there are return error codes with specific meaning for this API, they are listed below.
//!                 (None)
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_EndShareResource(ID3D10Resource *pResource);



#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_SetDepthBoundsTest
//
//!   DESCRIPTION: This function enables/disables the depth bounds test.
//!
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev         The device to set the depth bounds test
//!   \param [in]  bEnable      Enable(non-zero)/disable(zero) the depth bounds test
//!   \param [in]  fMinDepth    The minimum depth for the depth bounds test
//!   \param [in]  fMaxDepth    The maximum depth for the depth bounds test \n
//!                             The valid values for fMinDepth and fMaxDepth
//!                             are such that 0 <= fMinDepth <= fMaxDepth <= 1
//!
//!   \return LWAPI_OK if the depth bounds test was correctly enabled or disabled 
//!
//!   \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_SetDepthBoundsTest(ID3D10Device *pDev,
                                               LwU32 bEnable,
                                               float fMinDepth,
                                               float fMaxDepth);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_GetResourceHandle
//
//!   DESCRIPTION: This function retrieves a driver handle to a DirectX 10 resource.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//!  \param [in]   pDev         The device on which the resource was created.
//!  \param [in]   pResource    The resource for which we want to retrieve a
//!                             driver handle.
//!  \param [out]  phObject     Pointer to an LwAPI handle to be populated
//!                             on success
//!
//!  \return LWAPI_OK if and only if phObject was populated with a valid
//!            driver handle
//!  \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_GetResourceHandle(ID3D10Device *pDev,
                                              ID3D10Resource* pResource,
                                              LWDX_ObjectHandle* phObject);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_GetVertexShaderHandle
//! \code
//!   DESCRIPTION:  Note: call LwAPI_D3D10_RegisterDevice once before using with this function!!!
//!                This function returns a shader's handle as used inside of the UMD
//!
//!         INPUT:  pD3D10VertexShader  The runtime shader handle
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phShader     The UMD's shader handle
//!
//! RETURN STATUS: LWAPI_OK if pD3D10VertexShader is valid and the OUT pointers are non-null
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_GetVertexShaderHandle(ID3D10Device *pDev,
                                                  ID3D10VertexShader *pD3D10VertexShader,
                                                  LWDX_ObjectHandle* phShader);
#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_GetGeometryShaderHandle
//! \code
//!                 This function returns a shader's handle as used inside of the UMD
//!
//!         INPUT:  pD3D10GeometryShader  The runtime shader handle
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phShader     The UMD's shader handle
//!
//! RETURN STATUS: LWAPI_OK if pD3D10GeometryShader is valid and the OUT pointers are non-null
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_GetGeometryShaderHandle(ID3D10Device *pDev,
                                                    ID3D10GeometryShader *pD3D10GeometryShader,
                                                    LWDX_ObjectHandle* phShader);
#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_GetPixelShaderHandle
//! \code
//!                 This function returns a shader's handle as used inside of the UMD
//!
//!        INPUT:  pD3D10PixelShader  The runtime pixel shader handle
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phShader     The UMD's shader handle
//!
//! RETURN STATUS: LWAPI_OK if pD3D10PixelShader is valid and the OUT pointers are non-null
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_GetPixelShaderHandle(ID3D10Device *pDev,
                                                 ID3D10PixelShader *pD3D10PixelShader,
                                                 LWDX_ObjectHandle* phShader);
#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_GetShaderUCodeAllocationInfo
//! \code
//!                 This function returns a shader's address in video memory, and
//!                 its memory allocation handle.
//!
//!         INPUT:  pDev         The device on which the resource was created
//!                 hShader      Handle to the internal shader data struction of the UMD
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phAllocation   The shader's allocation handle
//!                 pBlockOffset   The shader's offset into its allocation
//!                 pProgramOffset The offset to shader's debug instance (w.r.t. pBlockOffset)
//!                 pLength        The shader block's length.
//!
//! RETURN STATUS: LWAPI_OK if the OUT pointers are non-null, and there exists
//!                at least (index+1) shaders of the given type in memory.
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_GetShaderUCodeAllocationInfo(ID3D10Device *pDev,
                                                         LWDX_ObjectHandle hShader,
                                                         LwU32* phAllocation,
                                                         LwU32* pBlockOffset,
                                                         LwU32* pProgramOffset,
                                                         LwU32* pLength);
#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_GetShaderLocalMemoryAllocationInfo
//
//!   This function returns the device's local memory allocation info.
//!   It does not take a shader handle because the local memory allocation
//!   is made per device and not per-shader.
//!
//!   \warning Note, this info represents the current state of the UMD and
//!   does not necessarily reflect the values used by the GPU. Enable warp
//!   semaphore reports (see LwAPI_D3D10_EnableWarpSemaphoreReports) if you
//!   need current data. 
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!    \param [in]   pDev                  The device on which the resource was created
//!    \param [out]  phAllocation          The D3DKMT local memory allocation handle
//!    \param [out]  pBlockOffset          The offset into the local memory allocation
//!    \param [out]  pLength               The length of the allocation
//!    \param [out]  pMaxWarpsPerSm;       Deprecated, returns zero
//!    \param [out]  pLmemBytesPerThread   Deprecated, returns zero
//!
//!    \return   LWAPI_OK if the OUT pointers are non-null.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_GetShaderLocalMemoryAllocationInfo(__in ID3D10Device *pDev,
                                                               __out LwU32* phAllocation,
                                                               __out LwU32* pBlockOffset,
                                                               __out LwU32* pLength,
                                                               __out LwU32* pMaxWarpsPerSm,
                                                               __out LwU32* pLmemBytesPerThread);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_GetResourceAllocationInfoSize
//
//!   This function should be called before GetResourceAllocationInfo, to get the size of pResourceAttributes.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev    The device on which the resource was created
//!   \param [out]  pSize   The size of the memory needed for pResourceAttributes in LwAPI_D3D10_GetResourceAllocationInfo.
//!
//!   \return   LWAPI_OK if pDev is valid and pSize not NULL.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_GetResourceAllocationInfoSize(__in ID3D10Device *pDev,
                                                          __out LwU32 *pSize);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)

//! \ingroup nsightapi
//! Prototype structure version, check common/inc/ShaderDebuggerStruct.h for versions
//! lwrrently supported by the driver!
typedef struct _sdResourceAttributes
{
    LwU32 structVersion;
} sdResourceAttributes;

//! \ingroup nsightapi
#define SD_RESOURCE_ATTRIBUTES_STRUCT_VERSION_V0 MAKE_LWAPI_VERSION(sdResourceAttributes, 0)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_GetResourceAllocationInfo
//
//!   This function returns the allocation info of a resource.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev                  The device on which the resource was created
//!   \param [in]   hResource             Handle to the internal resource data struction of the UMD
//!   \param [out]  phAllocation          The D3DKMT local memory allocation handle
//!   \param [out]  pBlockOffset          The offset into the local memory allocation
//!   \param [out]  pLength               The length of the allocation
//!   \param [out]  pResourceAttributes   The attributes of the resource- driver private.  Should be allocated by the caller using
//!                                       information from LwAPI_D3D10_GetResourceAllocationInfoSize.
//!                                       for the structure declaration.
//!
//!   \return   LWAPI_OK if the inputs are valid and the out pointers are non-null.
//!
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_GetResourceAllocationInfo(__in ID3D10Device *pDev,
                                                      __in LWDX_ObjectHandle hResource,
                                                      __out LwU32* phAllocation,
                                                      __out LwU32* pBlockOffset,
                                                      __out LwU32* pLength,
                                                      __inout sdResourceAttributes* pResourceAttributes);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_GetResourceAllocationInfo2
//
//!   This function returns the allocation info of a resource.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]      pDev                  The device on which the resource was created
//!   \param [in]      hResource             Handle to the internal resource data struction of the UMD
//!   \param [out]     phAllocation          The D3DKMT local memory allocation handle
//!   \param [out]     pBlockOffset          The 64-bit offset into the local memory allocation
//!   \param [out]     pLength               The 64-bit length of the allocation
//!   \param [in,out]  pResourceAttributes   The attributes of the resource- driver private.  Should be allocated by the caller using
//!                                          information from LwAPI_D3D10_GetResourceAllocationInfoSize.
//!
//! \return  LWAPI_OK if the OUT pointers are non-null.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_GetResourceAllocationInfo2(__in ID3D10Device *pDev,
                                                       __in LWDX_ObjectHandle hResource,
                                                       __out LwU32* phAllocation,
                                                       __out LwU64* pBlockOffset,
                                                       __out LwU64* pLength,
                                                       __inout sdResourceAttributes* pResourceAttributes);

#endif //defined(__cplusplus) && defined(__d3d10_h__)



#if defined(__cplusplus) && defined(__d3d10_h__)

//! Prototype structure version, check common/inc/ShaderDebuggerStruct.h for versions
//! lwrrently supported by the driver!
//! \ingroup nsightapi
typedef struct _sdBuildDebugShaderInstanceParamsIn
{
    LwU32 structVersion;
} sdBuildDebugShaderInstanceParamsIn;

//! \ingroup nsightapi
#define SD_BUILD_DEBUG_SHADER_INSTANCE_PARAMS_IN_VERSION_V0 MAKE_LWAPI_VERSION(sdBuildDebugShaderInstanceParamsIn, 0)

//! Prototype structure version, check common/inc/ShaderDebuggerStruct.h for versions
//! lwrrently supported by the driver!
//! \ingroup nsightapi
typedef struct _sdBuildDebugShaderInstanceParamsOut
{
    LwU32 structVersion;
} sdBuildDebugShaderInstanceParamsOut;

//! \ingroup nsightapi
#define SD_BUILD_DEBUG_SHADER_INSTANCE_PARAMS_OUT_VERSION_V0 MAKE_LWAPI_VERSION(sdBuildDebugShaderInstanceParamsOut, 0)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_BuildDebugShaderInstance2
//
//!   This function creates and builds a debug instance of a shader.
//!   If the shader already has a debug instance then it returns
//!   immediately with the instructions unless the rebuild param is true.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]      pDev         The device to which the shader belongs to.
//!   \param [in]      pParamsIn    Pointer to extendable input structure.
//!   \param [in,out]  pParamsOut   Pointer to extendable output structure.
//!
//!   \return LWAPI_OK if pDev is valid and pParamsIn and pParamsOut are non-null
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_BuildDebugShaderInstance2(__in ID3D10Device *pDev,
                                                      __in sdBuildDebugShaderInstanceParamsIn  *pParamsIn,
                                                      __inout sdBuildDebugShaderInstanceParamsOut *pParamsOut);

#endif //defined(__cplusplus) && defined(__d3d10_h__)



#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D1x_NsightEnableDebugMode
//
//!   Notify the D3D driver to use debug shader instances instead of
//!   release/optimized shaders from now until it gets this call with
//!   enable flag set to false. 
//!   EnableFlag is true, when a user sets his first BreakPoint
//!   EnableFlag is false, when the user removes his last BreakPoint
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev      The device pointer on which we want to set the flag. 
//!                           pDev can be either ID3D10Device or ID3D10Device1 or ID3D11Device ptr.
//!   \param [in]   bEnable   Boolean flag to denote either to enable/disable.
//!
//!   \return LWAPI_OK if the device was valid and we successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D1x_NsightEnableDebugMode(__in IUnknown *pDev,
                                                  __in bool bEnable);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D1x_NsightCommunication
//
//!   Uber call that handles all Nsight instrumentation in the DX driver
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!   \note <b> When pInternalDev is valid, pDev (device pointer) is just a mule device to carry our instructions.
//!              All the changes are really done on the pInternalDev (driver internal device pointer). </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]      pDev          The device pointer on which we want to instrument. 
//!                                  pDev can be either ID3D10Device or ID3D10Device1 or ID3D11Device ptr.
//!   \param [in]      pInternalDev  Driver internal device pointer on which we want to make changes. 
//!   \param [in, out] pPayload      All the data needed by the instrumentation.
//!                                  check common/inc/ShaderDebuggerStruct.h for PayLoad defines.
//!   \return LWAPI_OK if the device was valid and we successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D1x_NsightCommunication(__in IUnknown *pDev,
                                                __in void     *pInternalDev,
                                                __inout void  *pPayload);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)

//! Prototype structure version, check common/inc/ShaderDebuggerStruct.h for versions
//! lwrrently supported by the driver!
//! \ingroup nsightapi
typedef struct _sdPushMethodIntoPushBufferArguments
{
    LwU32 structVersion;
} sdPushMethodIntoPushBufferArguments;

//! \ingroup nsightapi
#define SD_PUSH_METHOD_INTO_PUSH_BUFFER_ARGUMENTS_VERSION_V0 MAKE_LWAPI_VERSION(sdPushMethodIntoPushBufferArguments, 0)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D1x_NsightPushMethodIntoPushBuffer
//
//!   Allows the tools to add a method into the PB.
//!   We will not allow any arbitrary PB methods to be inserted into the PB stream.
//!   The legal ones are defined in sdPushBufferMethod (see wgf2um\inc\ShaderDebuggerStruct.h).
//!   Right now we only have support for this in Kepler because the only supported PB method
//!   (SD_PUSHBUFFERMETHOD_TRAPHANDLERADDRESS) is a Kepler-only method.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev   The device pointer into which we want to push the PB method. 
//!                         pDev can be either ID3D10Device or ID3D10Device1 or ID3D11Device ptr
//!   \param [in]  pArgs   Identifies the method to push and its parameters.
//!
//!   \return LWAPI_OK if the device is valid and the operation completed successfully.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D1x_NsightPushMethodIntoPushBuffer(__in IUnknown *pDev,
                                                           __in sdPushMethodIntoPushBufferArguments* pArgs);
#endif //defined(__cplusplus) && defined(__d3d10_h__)



#if defined(__cplusplus) && defined(__d3d10_h__)

//! Prototype for callback functions used by the Nsight debugger
//! \ingroup nsightapi
typedef HRESULT (__cdecl *SHADERDEBUGGER_CALLBACK) (__in void* pCallbackData, __in_opt void* pParam);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_SetShaderDebuggerCallback
//
//!   This function is used to register callbacks for various debug events.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev               The device on which the callback is valid.
//!   \param [in]  cbType             The type of the callback to be set, see common/inc/ShaderDebuggerCallbacks.h
//!   \param [in]  pCallbackFunction  Pointer to the callback function. Pass NULL to disable the callback.
//!   \param [in]  pParam             Application data that will be passed back to this callback.
//!
//!   \return  LWAPI_OK if the callback was successfully set.
//!
//!   \note  An application may change its callback functions at any time, and may
//!          unregister from any function by passing NULL in as a function pointer.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_SetShaderDebuggerCallback(__in ID3D10Device *pDev,
                                                      __in LwU32 cbType,
                                                      __in_opt SHADERDEBUGGER_CALLBACK pCallbackFunction,
                                                      __in_opt void* pParam);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D1x_MoveShaderCacheBetweelwidAndSys
//
//!   This function will be used mainly by ShaderDebugger and will move shader cache and shader lmem
//!   from Video memory to System memory or the other way round. When the app starts up,
//!   we usually store shader cache and lmem in Video memory. To facilitate shader debugging (to
//!   set breakpoints, replace shaders at a breakpoint, and read/write lmem), we need these in system memory.
//!   Usual way of running things: When the user sets his first breakpoint in the shader, we
//!   get this call to move shader cache and lmem from VID to SYS. From then on, the driver maintains
//!   the cache and lmem in SYS memory. Once the user removes his last breakpoint, we will get this call
//!   to move cache and lmem from SYS to VID memory & continue normal operations after that.
//!   The shaderTypeFlags parameter allows us to move a single shaderType cache or multiple caches, as well as the 
//!   lmem at the same time.
//!
//!   \note Only moves the lmem to sys on Fermi architectures, Tesla lmem remains in vid.  Needs to be updated for Kepler.
//! 
//!   \note Compute Shader Manager is created, only when we have a compute channel. Hence this call would
//!         return LWAPI_ILWALID_ARGUMENT, If you use this call to move compute shader cache, without
//!         a compute channel.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev            The device for which we need to move shader cache and lmem. pDev can be either
//!                                ID3D10Device or ID3D10Device1 or ID3D11Device ptr
//!   \param [in]  cacheLocation   Specifies location to move the shadercache and lmem (SD_STORAGE_VID/SD_STORAGE_SYS).
//!                                Check the sdShaderHeapStorage enums in common/inc/ShaderDebuggerStruct.h for valid
//!                                values. Don't use SD_STORAGE_COUNT.
//!   \param [out] shaderTypeFlags Specifies what all shader caches need to be moved.
//!                                Check the sdShaderType enums in common/inc/ShaderDebuggerStruct.h for valid values.
//!                                You can use multiple of these, depending on the types of ShaderCaches you want to move.
//!                                NOTE: Trying to use SD_SHADER_TYPE_HULL & SD_SHADER_TYPE_DOMAIN flags on D3D10 devices
//!                                will return an LWAPI_ILWALID_ARGUMENT error.
//!
//!
//!   \return  This will be a synchronous call i.e. would be exelwted immediately. Hence will return LWAPI_OK if the call was successfull.
//!            This call will return LWAPI_OK, without doing anything, if shaderCache already exists in the requested location
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D1x_MoveShaderCacheBetweelwidAndSys(__in IUnknown *pDev,
                                                            __in LwU32 cacheLocation,
                                                            __in LwU32 shaderTypeFlags);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)

//! \ingroup nsightapi
typedef enum
{
    D3D_SHADER_TYPE_VERTEX   = 0,
    D3D_SHADER_TYPE_GEOMETRY = 1,
    D3D_SHADER_TYPE_PIXEL    = 2,
    D3D_SHADER_TYPE_COMPUTE  = 3,
    D3D_SHADER_TYPE_HULL     = 4,
    D3D_SHADER_TYPE_DOMAIN   = 5,
} D3D_SHADER_TYPE;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_SetShaderDebuggerHeapSize
//
//!   Sets the private heap available for use by the shader debugger.
//!   By default this heap has a size of zero.  The debugger should
//!   set this to zero if it wants to the destroy an existing heap.
//!   After the heap is resized, any previous contents of the heap
//!   are invalid and should be reinitialized by the debugger.
//!   However, the contents of this heap will be preserved between
//!   migrations between sysmem and vidmem for the applicable shader
//!   cache (see LwAPI_D3D1x_MoveShaderCacheBetweelwidAndSys)
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev         The device on which the callback is valid.
//!   \param [in]  newSize      The new requested size for the heap, in bytes
//!   \param [in]  shaderType   The shader type (using enum)
//!   \param [out] pNewOffset   The offset in bytes from the start of the shader heap. Can be NULL if newSize == 0.
//!
//!   \return LWAPI_OK if the heap was successfully resized.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_SetShaderDebuggerHeapSize(__in ID3D10Device *pDev,
                                                      __in LwU32 newSize,
                                                      __in D3D_SHADER_TYPE shaderType,
                                                      __out_opt LwU32 *pNewOffset);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_SetDeviceStateSaveBuffer
//
//!   Creates a region in Vidmem where the trap handler will dump
//!   the SM states. This will be used in Fermi and Kepler by the debugger.
//!   Set the size to zero to destroy the existing allocation.
//!   Resize operation is not supported -- destroy the allocation and recreate
//!   a new one.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev         The device on which the callback is valid.
//!   \param [in]   newSize      The new requested size for the heap, in bytes
//!   \param [in]   shaderType   The shader type (using enum)
//!   \param [out]  pNewOffset   The offset in bytes from the start of the shader heap. Can be NULL if newSize == 0.
//!
//!   \return LWAPI_OK if the heap was successfully resized.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_SetDeviceStateSaveBuffer(__in ID3D10Device *pDev,
                                                     __in LwU32 newSize,
                                                     __in D3D_SHADER_TYPE shaderType,
                                                     __out_opt LwU64 *phAllocation);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_LockCb
//! \code
//!   DESCRIPTION: This function is an accessor for the UMD's surface locking function.
//!
//!         INPUT:  pDev         The device on which the resource was created
//!                 hMemory      The memory handle to use.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  ppBuffer     The mapped buffer.
//!
//! RETURN STATUS: LWAPI_OK if the buffer is non_null, and the lock succeeds.
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_LockCb(ID3D10Device *pDev,
                                   LwU32 hMemory,
                                   LwU32** ppBuffer);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_UnlockCb
//! \code
//!   DESCRIPTION: This function is an accessor for the UMD's surface unlocking function.
//!
//!         INPUT:  pDev         The device on which the resource was created
//!                 hMemory      The memory handle to use.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: LWAPI_OK if the buffer is non_null, and the lock succeeds.
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_UnlockCb(ID3D10Device *pDev,
                                     LwU32 hMemory);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_GetAllContextRmHandles
//
//!   This function retrieves the RM handles for the device
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]      pDev                  The device whose handle we want
//!   \param [in,out]  pRmHandlesCollection  The device's RM handles of every channel/GPU combination that is active.
//!
//!   \return LWAPI_OK if and only if pDev was populated with valid RM handles
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_GetAllContextRmHandles(__in ID3D10Device *pDev,
                                                   __inout sdRmHandlesCollection* pRmHandlesCollection);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_GetAllocDebugInfo
//
//!   Internal function used by shader debugger, used for getting
//!   addressing info about resident shaders
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev                    D3D handle of client
//!   \param [in]   hKmtAlloc               KMT allocation object handle
//!   \param [in]   hAllocType              1 for resource, 2 for primary surface
//!   \param [in]   hAllocIsDeviceSpecific  Flag for allocation
//!   \param [out]  phClient                Matching RM client
//!   \param [out]  phDevice                Matching RM device
//!   \param [out]  pAllocPAddr             Allocation offset from FB
//!   \param [out]  pAllocSize              Size of allocation
//!
//!   \return LWAPI_OK if and only if the hKmtAlloc was known by the KMD
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_GetAllocDebugInfo(__in ID3D10Device *pDev,
                                              __in LwU32 hKmtAlloc,
                                              __in LwU32 hAllocType,
                                              __in LwU32 hAllocIsDeviceSpecific,
                                              __out LwU32* phClient,
                                              __out LwU32* phDevice,
                                              __out LwU64* pAllocPAddr,
                                              __out LwU32* pAllocSize);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_GetPixelShaderInstructions
//
//!   This function retrieves the SASS instructions of a DX10 pixel shader
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev           The device on which the resource was created.
//!   \param [in]   pShader        The pixel shader for which we want to retrieve the instructions.
//!   \param [out]  ppInstructions  Pointer to the SASS instructions of the shader.
//!   \param [out]  pBufferSize     The byte size of the instruction buffer.
//!
//!   \return LWAPI_OK if and only if pInstructions was populated with a valid
//!           set of instruction
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_GetPixelShaderInstructions(__in ID3D10Device *pDev,
                                                       __in ID3D10PixelShader* pShader,
                                                       __out_bcount(*pBufferSize) LwU32** ppInstructions,
                                                       __out LwU32* pBufferSize);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_SetPixelShaderInstructions
//
//!   This function sets the SASS instructions of a DX10 pixel shader
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev           The device on which the resource was created.
//!   \param [in]  pShader        The pixel shader for which we want to set the instructions.
//!   \param [in]  pInstructions  Pointer to the SASS instructions of the shader.
//!   \param [in]  bufferSize     The byte size of the instruction buffer.
//!
//!   \return LWAPI_OK if device and shader handle are valid and the instructions could be successfully set.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_SetPixelShaderInstructions(__in ID3D10Device *pDev,
                                                       __in ID3D10PixelShader* pShader,
                                                       __in_bcount(bufferSize) LwU32* pInstructions,
                                                       __in LwU32 bufferSize);
#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_NsightEnableReporting
//
//!   Notify the D3D driver that Nsight is attaching to the process,
//!   enable reporting, register a callback with the driver. This
//!   callback function is called when a report data is available.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev                       The device pointer on which we will tag on.
//!   \param [in]  bEnable                    boolean flag to denote either to enable/disable.
//!   \param [in]  completedReportsCallback   Callback function.
//!   \param [in]  pCallbackData              Data associated with the callback function 
//!                                           that is passed back through the callback.
//!
//!   \return  LWAPI_OK if we have successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_NsightEnableReporting(__in ID3D10Device *pDev,
                                                  __in bool bEnable,
                                                  __in fdStatsReportsCompletedCallback completedReportsCallback, 
                                                  __in_opt void *pCallbackData);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_NsightFlushReporting
//
//!   Flushes reporting output for nsight.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//
//!   \param [in]  pDev    The device pointer on which we will flush on.
//!
//!   \return  LWAPI_OK if we have successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_NsightFlushReporting(__in ID3D10Device *pDev);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_NsightSetLwstomReportData
//
//!   Specifies the current custom report data for Nsight reports
//!   in the driver.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev    The device pointer on which we will tag on.
//!                        lwstomData Custom report data.
//!
//!   \return  LWAPI_OK if we have successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_NsightSetLwstomReportData(__in ID3D10Device *pDev,
                                                      __in LwU32 lwstomData);





//! \ingroup nsightapi
// Increment version when call are added
typedef enum
{
    LWAPI_D3D_DRAW     = 0,
    LWAPI_D3D_DISPATCH = 1,
    LWAPI_D3D_PRESENT  = 2,
    LWAPI_D3D_COPY     = 3,
} LWAPI_NSIGHT_D3DCALLTYPE;

#define LWAPI_NSIGHT_CALLTYPE_VERSION 1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_NsightSetLwrrentContextAndD3DCallCount
//
//!   Sets context handle for the device & sets counter for the specified
//!   NsightD3DCallType. 
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev          The device pointer on which we need to set the above.
//!   \param [in]   contextHandle API handle
//!   \param [in]   d3dCallType   Type of d3d call
//!   \param [in]   count         count-value to be set for corresponding d3d call.
//!
//!   \return  LWAPI_OK if we have successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_NsightSetLwrrentContextAndD3DCallCount(__in ID3D10Device *pDev, 
                                                                   __in LwU64 contextHandle, 
                                                                   __in LWAPI_NSIGHT_D3DCALLTYPE d3dCallIdType,
                                                                   __in LwU64 count);

#endif //defined(__cplusplus) && defined(__d3d10_h__)

#if defined(__d3d10_h__)

//////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D_GetIDXGIAdapter
//
//!   DESCRIPTION: This function returns the IDXGIAdapter* of the input GPU handle.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 340
//!
//!   \param [in]     hPhysicalGpu
//!   \param [out]    ppAdapter
//!
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status.
//!              If there are return error codes with specific meaning for this API, they are listed below.
//!
//!   \ingroup dx
//////////////////////////////////////////////////////////////////////////

//!   \ingroup dx
LWAPI_INTERFACE LwAPI_D3D_GetIDXGIAdapter(__in LwPhysicalGpuHandle hPhysicalGpu, __out IDXGIAdapter** ppAdapter);
#endif // defined(__d3d10_h__)


#if defined(__cplusplus) && defined(__d3d10_h__)

#ifdef __d3d10_1_h__


//////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_CreateDevice
//
//!   DESCRIPTION: This function creates a d3d10 device. The function call is the 
//!                same as D3D10CreateDevice1(), but with an extra argument 
//!                (#D3D10_FEATURE_LEVEL supported by the device) that the function fills in.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!   \param [in]     pAdapter
//!   \param [in]     DriverType
//!   \param [in]     Software
//!   \param [in]     Flags
//!   \param [in]     HardwareLevel
//!   \param [in]     SDKVersion
//!   \param [in]     ppDevice
//!   \param [in]     *pLevel  D3D10_FEATURE_LEVEL supported - see #LWAPI_DEVICE_FEATURE_LEVEL
//!
//!   \return  LWAPI_OK if the createDevice call succeeded.
//
//////////////////////////////////////////////////////////////////////////

//!   \ingroup dx
LWAPI_INTERFACE LwAPI_D3D10_CreateDevice(IDXGIAdapter* pAdapter,
                                         D3D10_DRIVER_TYPE DriverType,
                                         HMODULE Software,
                                         UINT32 Flags,
                                         D3D10_FEATURE_LEVEL1 HardwareLevel,
                                         UINT SDKVersion,
                                         ID3D10Device1** ppDevice,
                                         LWAPI_DEVICE_FEATURE_LEVEL *pLevel);
#endif //defined(__d3d10_1_h__)
#endif //defined(__cplusplus) && defined(__d3d10_h__)



#if defined(__cplusplus) && defined(__d3d10_h__)
#ifdef __d3d10_1_h__
////////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_CreateDeviceAndSwapChain
//
//!   DESCRIPTION: This function creates a d3d10 device and swap chain. The function call is the 
//!                same as D3D10CreateDeviceAndSwapChain1(), but with an extra argument 
//!                (D3D10_FEATURE_LEVEL supported by the device) that the function fills in .
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!   \param [in]   pAdapter
//!   \param [in]   DriverType
//!   \param [in]   Software
//!   \param [in]   Flags
//!   \param [in]   HardwareLevel
//!   \param [in]   SDKVersion
//!   \param [in]   pSwapChainDesc
//!   \param [in]   ppSwapChain
//!   \param [in]   ppDevice
//!   \param [in]   pLevel       D3D10_FEATURE_LEVEL supported - see see #LWAPI_DEVICE_FEATURE_LEVEL
//!
//!   \return  LWAPI_OK if the createDevice with swap chain call succeeded.
//!
//!   \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_CreateDeviceAndSwapChain(IDXGIAdapter* pAdapter,
                                                     D3D10_DRIVER_TYPE DriverType,
                                                     HMODULE Software,
                                                     UINT32 Flags,
                                                     D3D10_FEATURE_LEVEL1 HardwareLevel,
                                                     UINT SDKVersion,
                                                     DXGI_SWAP_CHAIN_DESC* pSwapChainDesc,
                                                     IDXGISwapChain** ppSwapChain,
                                                     ID3D10Device1** ppDevice,
                                                     LWAPI_DEVICE_FEATURE_LEVEL *pLevel);


#endif //defined(__d3d10_1_h__)
#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)



//-----------------------------------------------------------------------------
// Private Direct3D10 APIs
//-----------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_GetBufferStreamOutBytesWritten
//
//!   DESCRIPTION: This API gets the number of bytes written during stream out for the
//!                specified buffer.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!  
//!  \param [in]  pDev
//!  \param [in]  Buffer
//!  \param [out] pCount
//!
//!  \return LWAPI_OK if the operation succeeded
//!
//!  \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_GetBufferStreamOutBytesWritten(ID3D10Device* pDev, ID3D10Buffer* pBuffer, LwU32* pCount);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_SetBufferStreamOutBytesWritten
//
//!   DESCRIPTION: This API sets the number of bytes written during stream out for the
//!                specified buffer.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!  
//!  \param [in]  pDev
//!  \param [in]  Buffer
//!  \param [in] pCount
//!
//!  \return LWAPI_OK if the operation succeeded
//!
//!  \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_SetBufferStreamOutBytesWritten(ID3D10Device* pDev, ID3D10Buffer* pBuffer, LwU32 Count);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_1_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_CreateDevice_McCompat
//! \code
//!   DESCRIPTION: This function creates a d3d10 device. The function call is the
//!                same as D3D10CreateDevice1, but 3 extra arguments:
//!                (D3D10_FEATURE_LEVEL supported by the device), mccompat bits to
//!                control SLI optimizations and mccompatHybrid bits to control
//!                Hybrid SLI.  The bits are the same ones exported by d3dreg.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!         INPUT:  IDXGIAdapter* pAdapter,
//!                 D3D10_DRIVER_TYPE DriverType,
//!                 HMODULE Software,
//!                 UINT32 Flags,
//!                 D3D10_FEATURE_LEVEL1 HardwareLevel,
//!                 UINT SDKVersion,
//!                 ID3D10Device1** ppDevice,
//!                 LWAPI_DEVICE_FEATURE_LEVEL *pLevel,  // D3D10_FEATURE_LEVEL supported
//!                 UINT32 mccompat,                     // SLI mccompat bits, default to 0
//!                 UINT32 mccompatHybrid,               // Hybrid SLI mccompat bits, default to 0
//!
//! RETURN STATUS: LWAPI_OK if the createDevice call succeeded.
//! \endcode
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_CreateDevice_McCompat(  IDXGIAdapter* pAdapter,
                                                    D3D10_DRIVER_TYPE DriverType,
                                                    HMODULE Software,
                                                    UINT32 Flags,
                                                    D3D10_FEATURE_LEVEL1 HardwareLevel,
                                                    UINT SDKVersion,
                                                    ID3D10Device1** ppDevice,
                                                    LWAPI_DEVICE_FEATURE_LEVEL *pLevel,
                                                    UINT32 mccompat,
                                                    UINT32 mccompatHybrid);




#endif //defined(__cplusplus) && defined(__d3d10_1_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_RegisterDevice
//
//!   DESCRIPTION: DEPRECATED- all functions should now auto-register the device. 
//!
//!                Register device with LwAPI before using it in specified funtions  This allows for
//!                more efficient high-frequency lwapi calls, as setting up the device for LwAPI use
//!                is an expensive operation.  When finished with the handle, clients should call 
//!                LwAPI_D3D10_ReleaseDeviceHandle.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] ID3D10Device* pDev
//!
//! \return  LWAPI_OK if the call succeeded.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_RegisterDevice(ID3D10Device *pDev);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_UnregisterDevice
//
//!   DESCRIPTION: Unregister a device after LwAPI_D3D10_RegisterDevice
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] ID3D10Device* pDev
//!
//! \return  LWAPI_OK if the call succeeded.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_UnregisterDevice(ID3D10Device* pDev);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_SetPrivateConstData
//
//!   Sets data in the private UMD constant buffer.
//!   Slots are defined by the LwAPIPrivateConstDataSlot enumeration.
//!   Consumers of this constant buffer data must take care to call
//!   LwAPI_D3D10_GetPrivateConstDataSlotAndOffset for the same instance
//!   of the shader which will consume the data.  Producers of this data
//!   should call LwAPI_D3D10_SetPrivateConstData any time before drawing.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//
//!   \param [in]  pDev       The device pointer
//!   \param [in]  dataslot   The data slot to update
//!   \param [in]  data       The data value
//!
//!   \return  LWAPI_OK if the call succeeded.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_SetPrivateConstData(__in ID3D10Device* pDev,
                                                __in LwAPIPrivateConstDataSlot dataslot,
                                                __in LwU32 data);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_GetPrivateConstDataSlotAndOffset
//
//!   This function retrieves the constant slot and offset corresponding
//!   to the private UMD constant buffer for the specified shader.  See
//!   comments for LwAPI_D3D10_SetPrivateConstData.  hShader should be
//!   acquired using one of the LwAPI_D3D10_GetXXXShaderHandle functions.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev               The device pointer
//!   \param [in]  hShader            The shader for which to query the data
//!   \param [in]  dataslot           The data slot to query
//!
//!   \param [out] pOutConstSlot      The buffer id (bank#)
//!   \param [out] pOutScalarOffset   The offset within the buffer
//!
//!   \return  LWAPI_OK if the call succeeded.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_GetPrivateConstDataSlotAndOffset(__in ID3D10Device* pDev,
                                                             __in LWDX_ObjectHandle* phShader,
                                                             __in LwAPIPrivateConstDataSlot dataslot,
                                                             __out LwU32 *pOutConstSlot,
                                                             __out LwU32 *pOutScalarOffset);

#endif //defined(__cplusplus) && defined(__d3d10_h__)



#if defined(__cplusplus) && defined(__d3d10_h__)

//! \ingroup nsightapi
typedef struct _LwAPI_D3DResourceSubresourceInfo
{
    LwU32 ArraySlice;
    LwU32 MipLevel;
    LwU32 OffsetInBytes;
} LwAPI_D3DResourceSubresourceInfo;

//! \ingroup nsightapi
#define LWAPI_GET_RESOURCE_SUBRESOURCE_INFO_VERSION 1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_GetResourceSubresourceInfo
//
//!   Returns information about the internal layout of subresources in a driver resource.
//!   To obtain the subresource count, callers should call this with ppInfoBuffer=NULL.
//!   Then, the caller should allocate an array of LwAPI_D3DResourceSubresourceInfo* and
//!   initialize each member of the array with a valid pointer.
//!   When ppInfoBuffer is non-null, the caller must provide its array length in pSubresourceCount.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//!   \deprecated Use LwAPI_D3D10_GetResourceSubresourceInfo2 instead.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev               The device pointer.
//!   \param [in]   hResource          The resource handle.
//!   \param [in]   Version            The version of the output structure used to allocate the buffer.
//!   \param [out]  pSubresourceCount  Available subresource count or size of ppInfoBuffer. See comments above.
//!   \param [out]  ppInfoBuffer       Result buffer allocated by caller. See comments above.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_GetResourceSubresourceInfo(__in ID3D10Device* pDev,
                                                       __in LWDX_ObjectHandle hResource,
                                                       __in LwU32 Version,
                                                       __inout LwU32* pSubresourceCount,
                                                       __out_ecount_part_opt(*pSubresourceCount, *pSubresourceCount) LwAPI_D3DResourceSubresourceInfo** ppInfoBuffer);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)

//! Prototype structure version, check common/inc/ShaderDebuggerStruct.h for versions
//! lwrrently supported by the driver!
//! \ingroup nsightapi
typedef struct _sdD3DResourceSubresourceInfo
{
    LwU32 structVersion;
} sdD3DResourceSubresourceInfo;

//! \ingroup nsightapi
#define SD_D3D_RESOURCE_SUBRESOURCE_INFO_STRUCT_VERSION_V0 MAKE_LWAPI_VERSION(sdD3DResourceSubresourceInfo, 0)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_GetResourceSubresourceInfo2
//
//!   Returns information about the internal layout of subresources in a driver resource.
//!   To obtain the subresource count, callers should call this with ppInfoBuffer=NULL.
//!   Then, the caller should allocate an array of sdD3DResourceSubresourceInfo_vX* (see
//!   common/inc/ShaderDebuggerStruct.h) and initialize each member of the array with a valid pointer.
//!   When ppInfoBuffer is non-null, the caller must provide its array length in pSubresourceCount.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//
//!   \param [in]   pDev               The device pointer.
//!   \param [in]   hResource          The resource handle.
//!   \param [in]   Version            The version of the output structure used to allocate the buffer.
//!   \param [out]  pSubresourceCount  Available subresource count or size of ppInfoBuffer. See comments above.
//!   \param [out]  ppInfoBuffer       Result buffer allocated by caller. See comments above.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_GetResourceSubresourceInfo2(__in ID3D10Device* pDev,
                                                       __in LWDX_ObjectHandle hResource,
                                                       __in LwU32 Version,
                                                       __inout LwU32* pSubresourceCount,
                                                       __out_ecount_part_opt(*pSubresourceCount, *pSubresourceCount) sdD3DResourceSubresourceInfo** ppInfoBuffer);

#endif //defined(__cplusplus) && defined(__d3d10_h__)


#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D10_EnableWarpSemaphoreReports
//
//!   Returns a pointer to a volatile block of memory, which contains lmem, crs,
//!   and warp parameters, circa when the debugger is servicing a breakpoint.
//!   In SLI mode, these pertain to GPU 0 only.
//!   The mapped memory is a an array of structures, which should be indexed
//!   with the correct sdWarpSemaphoreReportType enum as defined in common/inc/ShaderDebuggerStruct.h
//!   When this feature is enabled, extra WFIs can occur when driver state changes,
//!   and semaphores will be issued to the HW.  Thus this feature should be disabled
//!   when not in use.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//
//!   \param [in]   pDev                The device pointer
//!   \param [in]   enable              Enable or disable reporting
//!   \param [in]   requestedVersion    Since the driver allocates the memory, the user needs to
//!                                     let the driver know which version of the structure to create.
//!   \param [out]  ppOutMappedMemory   Pointer to the semaphore data block.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D10_EnableWarpSemaphoreReports(__in ID3D10Device* pDev,
                                                       __in bool enable,
                                                       __in LwU32 requestedVersion,
                                                       __out volatile sdWarpSemaphoreReport** ppOutMappedMemory);


#endif // defined(__cplusplus) && defined(__d3d10_h__)



//-----------------------------------------------------------------------------
// Direct3D11 APIs
//-----------------------------------------------------------------------------

#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_CreateDevice
//
//!   DESCRIPTION: This function tries to create a DirectX 11 device. If the call fails (if we are running
//!                on pre-DirectX 11 hardware), depending on the type of hardware it will try to create a DirectX 10.1 OR DirectX 10.0+
//!                OR DirectX 10.0 device. The function call is the same as D3D11CreateDevice(), but with an extra 
//!                argument (D3D_FEATURE_LEVEL supported by the device) that the function fills in. This argument
//!                can contain -1 (LWAPI_DEVICE_FEATURE_LEVEL_NULL), if the requested featureLevel is less than DirecX 10.0.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]   pAdapter
//! \param [in]   DriverType
//! \param [in]   Software
//! \param [in]   Flags
//! \param [in]   *pFeatureLevels
//! \param [in]   FeatureLevels
//! \param [in]   SDKVersion
//! \param [in]   **ppDevice
//! \param [in]   *pFeatureLevel
//! \param [in]   **ppImmediateContext
//! \param [in]   *pSupportedLevel  D3D_FEATURE_LEVEL supported
//!
//! \return LWAPI_OK if the createDevice call succeeded.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_CreateDevice(IDXGIAdapter* pAdapter,
                                         D3D_DRIVER_TYPE DriverType,
                                         HMODULE Software,
                                         UINT Flags,
                                         CONST D3D_FEATURE_LEVEL *pFeatureLevels,
                                         UINT FeatureLevels,
                                         UINT SDKVersion,
                                         ID3D11Device **ppDevice,
                                         D3D_FEATURE_LEVEL *pFeatureLevel,
                                         ID3D11DeviceContext **ppImmediateContext,
                                         LWAPI_DEVICE_FEATURE_LEVEL *pSupportedLevel);


#endif //defined(__cplusplus) && defined(__d3d11_h__)

#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_CreateDeviceAndSwapChain
//
//!   DESCRIPTION: This function tries to create a DirectX 11 device and swap chain. If the call fails (if we are 
//!                running on pre=DirectX 11 hardware), depending on the type of hardware it will try to create a DirectX 10.1 OR 
//!                DirectX 10.0+ OR DirectX 10.0 device. The function call is the same as D3D11CreateDeviceAndSwapChain,  
//!                but with an extra argument (D3D_FEATURE_LEVEL supported by the device) that the function fills
//!                in. This argument can contain -1 (LWAPI_DEVICE_FEATURE_LEVEL_NULL), if the requested featureLevel
//!                is less than DirectX 10.0.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]     pAdapter
//! \param [in]     DriverType
//! \param [in]     Software
//! \param [in]     Flags
//! \param [in]     *pFeatureLevels
//! \param [in]     FeatureLevels
//! \param [in]     SDKVersion
//! \param [in]     *pSwapChainDesc
//! \param [in]     **ppSwapChain
//! \param [in]     **ppDevice
//! \param [in]     *pFeatureLevel
//! \param [in]     **ppImmediateContext
//! \param [in]     *pSupportedLevel  D3D_FEATURE_LEVEL supported
//!
//!return  LWAPI_OK if the createDevice with swap chain call succeeded.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_CreateDeviceAndSwapChain(IDXGIAdapter* pAdapter,
                                         D3D_DRIVER_TYPE DriverType,
                                         HMODULE Software,
                                         UINT Flags,
                                         CONST D3D_FEATURE_LEVEL *pFeatureLevels,
                                         UINT FeatureLevels,
                                         UINT SDKVersion,
                                         CONST DXGI_SWAP_CHAIN_DESC *pSwapChainDesc,
                                         IDXGISwapChain **ppSwapChain,
                                         ID3D11Device **ppDevice,
                                         D3D_FEATURE_LEVEL *pFeatureLevel,
                                         ID3D11DeviceContext **ppImmediateContext,
                                         LWAPI_DEVICE_FEATURE_LEVEL *pSupportedLevel);



#endif //defined(__cplusplus) && defined(__d3d11_h__)


// under development. API will be nda or public after implementation is completed
//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_CreateComputeOnlyDevice
//
//!   DESCRIPTION: This function creates a restricted type of a D3D11 device for compute-only work.
//!                It is a companion device for the main fully-capable 3D device. It has its own 
//!                pipe-line state and can run asynchronously w.r.t. the main device.
//!                Therefore compute work, submitted  to the compute-only device, can run in parallel 
//!                with graphics/compute work of the main device. The compute-only device is fully
//!                free-threaded w.r.t the main device.
//!                
//!                Restrictions:
//!                1. The compute-only device holds a reference to the main device, so the two share lifetime.
//!                In case of device lost of either device, the recovery sequence is to release the compute-only
//!                device first, then recover the main device, and then use this call to create a new
//!                compute-only device.
//!                2. All graphics related "set" functions are silently ignored on this device. All draw calls
//!                cause device lost.
//!                3. Only non-stretching, non-format colwerting blits are supported on this device. More copy restrictions
//!                may apply.
//!                4. No DXGI services (like present calls) are supported on this device.
//!                5. Predicated rendering is not supported on this device.
//!                6. While calling this create function, no other calls can be made on the main device on any other thread.
//!
//!                Creation call takes a pointer to the main device and few of the parameters of the standard device creation call.
//!                The remaining parameters have to match those of the main device and are derived from the main device pointer.
//!
//!
//! \param [in]     *pBase3DDevice        - a pointer the main device
//! \param [in]     Flags                 - creation flags (see dolwmentaion for the D3D11CreateDevice() call) 
//! \param [in]     SDKVersion            - SDK version used by the caller  (see dolwmentaion for the D3D11CreateDevice() call) 
//! \param [out]    **ppDevice            - a pointer to return created device
//! \param [out]    *pFeatureLevel        - a pointer to return the feature level of the device
//! \param [out]    **ppImmediateContext  - a pointer to return an immediate context of this device
//!
//! \return  LWAPI_OK if the create compute-only device call succeeded.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_CreateComputeOnlyDevice(__in ID3D11Device *pBase3DDevice,
    __in  UINT Flags,
    __in  UINT SDKVersion,
    __out ID3D11Device **ppDevice,
    __out D3D_FEATURE_LEVEL *pFeatureLevel,
    __out ID3D11DeviceContext **ppImmediateContext);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_BeginShareResource
//
//!   DESCRIPTION:  This API recreates the resource as a shared resource.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!  \param [in]  pResource   The resource to recreate as shared
//!  \param [in]  flags       Should be one of LWAPI_SHARE_RESOURCE_FLAGS
//!  \param [out] pHandle     The shared resource handle
//!
//!
//!  \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                 If there are return error codes with specific meaning for this API, they are listed below.
//!                 (None)
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_BeginShareResource(ID3D11Resource *pResource,
                                               UINT32          flags,
                                               HANDLE         *pHandle);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_EndShareResource
//
//!   DESCRIPTION:  This API restores the original resource.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] pResource    The resource that was shared using LwAPI_D3D11_BeginShareResource
//!
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                 If there are return error codes with specific meaning for this API, they are listed below.
//!                 (None)
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_EndShareResource(ID3D11Resource *pResource);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_SetDepthBoundsTest
//
//!   DESCRIPTION: This function enables/disables the depth bounds test
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]        pDeviceOrContext   The device or device context to set depth bounds test
//! \param [in]        bEnable            Enable(non-zero)/disable(zero) the depth bounds test
//! \param [in]        fMinDepth          The minimum depth for depth bounds test
//! \param [in]        fMaxDepth          The maximum depth for depth bounds test
//!                                       The valid values for fMinDepth and fMaxDepth
//!                                       are such that 0 <= fMinDepth <= fMaxDepth <= 1
//!
//! \return  ::LWAPI_OK if the depth bounds test was correcly enabled or disabled
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_SetDepthBoundsTest(IUnknown* pDeviceOrContext,
                                               LwU32 bEnable,
                                               float fMinDepth,
                                               float fMaxDepth);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

#if defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_IsLwShaderExtnOpCodeSupported
//
//!   DESCRIPTION: This function checks if a lw HLSL shader extension opcode is 
//!                supported on current hardware. List of opcodes is in lwShaderExtnEnums.h
//!                To use Lwpu HLSL extensions the application must include lwHLSLExtns.h 
//!                in the hlsl shader code. See lwHLSLExtns.h for more details on supported opcodes.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]        pDev         The device on which to query for support,
//!                                 should be a ID3D11Device+ device
//! \param [in]        opCode       the opcode to check
//! \param [out]       pSupported   true if supported, false otherwise
//!
//! RETURN STATUS:     This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                    If there are return error codes with specific meaning for this API, they are listed below.
//! \retval ::         LWAPI_OK if the call succeeded
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_IsLwShaderExtnOpCodeSupported(__in  IUnknown *pDev,
                                                          __in  LwU32 opCode,
                                                          __out bool *pSupported);

#endif //defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))

#if defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_SetLwShaderExtnSlot
//
//!   DESCRIPTION: This function sets the fake UAV slot that is used by Lwpu HLSL
//!                shader extensions. All createShader calls made to the driver after
//!                setting this slot would treat writes/reads to this UAV in a 
//!                different way. Applications are expected to bind null UAV to this slot.
//!                The same slot is used for all shader stages.
//!                To disable shader extensions the app may set this uav slot
//!                to some value that is bigger than the max allowed slot index
//!                e.g, 128 or 0xFFFFFFFF.
//!                To use Lwpu HLSL extensions the application must include lwHLSLExtns.h 
//!                in the hlsl shader code. See lwHLSLExtns.h for more details.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]        pDev         The device for which to set the extension slot
//!                                 should be a ID3D11Device+ device
//! \param [in]        uavSlot      the uav slot to use
//!
//! RETURN STATUS:     This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                    If there are return error codes with specific meaning for this API, they are listed below.
//! \retval ::         LWAPI_OK    : success, the uavSlot was set sucessfully
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_SetLwShaderExtnSlot(__in IUnknown *pDev,
                                                __in LwU32 uavSlot);

#endif //defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))


#if defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D_ForcePerSampleInterlock
//
//!   DESCRIPTION: Pixel shader interlock happens at shader frequency by default. This 
//!                function forces the interlock to happen at sample frequency (even if the shader
//!                is running at per-pixel frequency). Note that this function has no effect
//!                if the shader is already running at per-sample frequency (supersampling).
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]        *pDeviceOrContext     pointer to D3D11 device, or D3D11 device context
//! \param [in]        bForcePerSample       set this to true to force per sample interlock
//!
//! RETURN STATUS:     This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                    If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D_ForcePerSampleInterlock(__in  IUnknown *pDeviceOrContext,
                                                  __in  bool bForcePerSample);

#endif //defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))


#if defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_BeginUAVOverlap
//
//!   DESCRIPTION: Causes the driver to skip synchronization that is normally needed when accessing UAVs.
//!                Applications must use this with caution otherwise this might cause data hazards when
//!                multiple draw calls/compute shader launches are accessing same memory locations
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]        *pDeviceOrContext     pointer to D3D11 device, or D3D11 device context
//!
//! RETURN STATUS:     This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                    If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_BeginUAVOverlap(__in  IUnknown *pDeviceOrContext);

#endif //defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))

#if defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_EndUAVOverlap
//
//!   DESCRIPTION: Re-enables driver synchronization between calls that access same UAVs
//!                See LwAPI_D3D_BeginUAVOverlap for more details.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]        *pDeviceOrContext     pointer to D3D11 device, or D3D11 device context
//!
//! RETURN STATUS:     This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                    If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_EndUAVOverlap(__in  IUnknown *pDeviceOrContext);

#endif //defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))

//-----------------------------------------------------------------------------
// Private Direct3D11 APIs
//-----------------------------------------------------------------------------
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_GetBufferStreamOutBytesWritten
//! \code
//!   DESCRIPTION: Gets the number of bytes written during stream out for the
//!                specified buffer.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!         INPUT:  ID3D11Device*
//!                 ID3D11Buffer*
//!                 LwU32*
//!
//! RETURN STATUS: LWAPI_OK if the operation succeeded
//! \endcode
//! \ingroup nsightapi
/////////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_GetBufferStreamOutBytesWritten(ID3D11Device* pDev, ID3D11Buffer* pBuffer, LwU32* pCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_SetBufferStreamOutBytesWritten
//! \code
//!   DESCRIPTION: Sets the number of bytes written during stream out for the
//!                specified buffer.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!         INPUT:  ID3D11Device*
//!                 ID3D11Buffer*
//!                 LwU32
//!
//! RETURN STATUS: LWAPI_OK if the operation succeeded
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_SetBufferStreamOutBytesWritten(ID3D11Device* pDev, ID3D11Buffer* pBuffer, LwU32 Count);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_GetResourceHandle
//
//! \code
//!   DESCRIPTION: This function retrieves a driver handle to a DX10 resource
//!
//!         INPUT:  pDev         The device on which the resource was created
//!                 pResource    The resource for which we want to retrieve a
//!                              driver handle.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phObject     Pointer to an LwAPI handle to be populated
//!                              on success
//!
//! RETURN STATUS: LWAPI_OK if and only if phObject was populated with a valid
//!                driver handle
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_GetResourceHandle(ID3D11Device *pDev,
                                              ID3D11Resource* pResource,
                                              LWDX_ObjectHandle* phObject);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_SetPrivateConstData
//
//!   Sets data in the private UMD constant buffer.
//!   Slots are defined by the LwAPIPrivateConstDataSlot enumeration.
//!   Consumers of this constant buffer data must take care to call
//!   LwAPI_D3D11_GetPrivateConstDataSlotAndOffset for the same instance
//!   of the shader which will consume the data.  Producers of this data
//!   should call LwAPI_D3D11_SetPrivateConstData any time before drawing.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//
//!   \param [in]  pDev       The device pointer
//!   \param [in]  dataslot   The data slot to update
//!   \param [in]  data       The data value
//!
//!   \return  LWAPI_OK if the call succeeded.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_SetPrivateConstData(__in ID3D11DeviceContext* pContext,
                                                __in LwAPIPrivateConstDataSlot dataslot,
                                                __in LwU32 data);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_GetPrivateConstDataSlotAndOffset
//
//!   This function retrieves the constant slot and offset corresponding
//!   to the private UMD constant buffer for the specified shader.  See
//!   comments for LwAPI_D3D11_SetPrivateConstData.  hShader should be
//!   acquired using one of the LwAPI_D3D11_GetXXXShaderHandle functions.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev               The device pointer
//!   \param [in]  hShader            The shader for which to query the data
//!   \param [in]  dataslot           The data slot to query
//!
//!   \param [out] pOutConstSlot      The buffer id (bank#)
//!   \param [out] pOutScalarOffset   The offset within the buffer
//!
//!   \return  LWAPI_OK if the call succeeded.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_GetPrivateConstDataSlotAndOffset(__in ID3D11DeviceContext* pContext,
                                                             __in LWDX_ObjectHandle* phShader,
                                                             __in LwAPIPrivateConstDataSlot dataslot,
                                                             __out LwU32 *pOutConstSlot,
                                                             __out LwU32 *pOutScalarOffset);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_GetResourceAllocationInfoSize
//
//!   This function should be called before GetResourceAllocationInfo, to get the size of pResourceAttributes.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev    The device on which the resource was created
//!   \param [out]  pSize   The size of the memory needed for pResourceAttributes in LwAPI_D3D11_GetResourceAllocationInfo.
//!
//!   \return   LWAPI_OK if pDev is valid and pSize not NULL.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_GetResourceAllocationInfoSize(__in ID3D11DeviceContext *pContext,
                                                          __out LwU32 *pSize);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_GetResourceAllocationInfo
//
//!   This function returns the allocation info of a resource.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev                  The device on which the resource was created
//!   \param [in]i  hResource             Handle to the internal resource data struction of the UMD
//!   \param [out]  phAllocation          The D3DKMT local memory allocation handle
//!   \param [out]  pBlockOffset          The offset into the local memory allocation
//!   \param [out]  pLength               The length of the allocation
//!   \param [out]  pResourceAttributes   The attributes of the resource- driver private.  Should be allocated by the caller using
//!                                       information from LwAPI_D3D11_GetResourceAllocationInfoSize.
//!                                       for the structure declaration.
//!
//!   \return   LWAPI_OK if the inputs are valid and the out pointers are non-null.
//!
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_GetResourceAllocationInfo(__in ID3D11DeviceContext *pContext,
                                                      __in LWDX_ObjectHandle hResource,
                                                      __out LwU32* phAllocation,
                                                      __out LwU32* pBlockOffset,
                                                      __out LwU32* pLength,
                                                      __inout sdResourceAttributes* pResourceAttributes);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_GetResourceAllocationInfo2
//
//!   This function returns the allocation info of a resource.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]      pDev                  The device on which the resource was created
//!   \param [in]      hResource             Handle to the internal resource data struction of the UMD
//!   \param [out]     phAllocation          The D3DKMT local memory allocation handle
//!   \param [out]     pBlockOffset          The 64-bit offset into the local memory allocation
//!   \param [out]     pLength               The 64-bit length of the allocation
//!   \param [in,out]  pResourceAttributes   The attributes of the resource- driver private.  Should be allocated by the caller using
//!                                          information from LwAPI_D3D11_GetResourceAllocationInfoSize.
//!
//! RETURN STATUS: LWAPI_OK if the OUT pointers are non-null.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_GetResourceAllocationInfo2(__in ID3D11Device *pDev,
                                                       __in LWDX_ObjectHandle hResource,
                                                       __out LwU32* phAllocation,
                                                       __out LwU64* pBlockOffset,
                                                       __out LwU64* pLength,
                                                       __inout sdResourceAttributes* pResourceAttributes);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_GetAllContextRmHandles
//
//!   This function retrieves the RM handles for the device
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]      pDev                  The device whose handle we want
//!   \param [in,out]  pRmHandlesCollection  The device's RM handles of every channel/GPU combination that is active.
//!
//!   \return LWAPI_OK if and only if pDev was populated with valid RM handles
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_GetAllContextRmHandles(__in ID3D11DeviceContext *pContext,
                                                   __inout sdRmHandlesCollection* pRmHandlesCollection);
 
#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_GetAllocDebugInfo
//
//!   Internal function used by shader debugger, used for getting
//!   addressing info about resident shaders
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev                    D3D handle of client
//!   \param [in]   hKmtAlloc               KMT allocation object handle
//!   \param [in]   hAllocType              1 for resource, 2 for primary surface
//!   \param [in]   hAllocIsDeviceSpecific  Flag for allocation
//!   \param [out]  phClient                Matching RM client
//!   \param [out]  phDevice                Matching RM device
//!   \param [out]  pAllocPAddr             Allocation offset from FB
//!   \param [out]  pAllocSize              Size of allocation
//!
//!   \return LWAPI_OK if and only if the hKmtAlloc was known by the KMD
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_GetAllocDebugInfo(__in ID3D11DeviceContext *pContext,
                                              __in LwU32 hKmtAlloc,
                                              __in LwU32 hAllocType,
                                              __in LwU32 hAllocIsDeviceSpecific,
                                              __out LwU32* phClient,
                                              __out LwU32* phDevice,
                                              __out LwU64* pAllocPAddr,
                                              __out LwU32* pAllocSize);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_GetVertexShaderHandle
//
//! \code
//!   DESCRIPTION:  This function returns a shader's handle as used inside of the UMD
//!
//!         INPUT:  pD3D11VertexShader   The runtime vertex shader handle
//!                 ppD3D11ClassInstance Pointer to an array of class-instance interfaces
//!                 NumClassInstances    Number of class-instance interfaces in the array
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phShader     The UMD's shader handle
//!
//! RETURN STATUS: LWAPI_OK if pD3D11VertexShader is valid and the OUT pointers are non-null
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_GetVertexShaderHandle(ID3D11DeviceContext *pContext,
                                                  ID3D11VertexShader  *pD3D11VertexShader,
                                                  ID3D11ClassInstance *const *ppD3D11ClassInstance,
                                                  UINT NumClassInstances,
                                                  LWDX_ObjectHandle* phShader);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_GetGeometryShaderHandle
//
//! \code
//!   DESCRIPTION:  This function returns a shader's handle as used inside of the UMD
//!
//!         INPUT:  pD3D11GeometryShader  The runtime geometry shader handle
//!                 ppD3D11ClassInstance Pointer to an array of class-instance interfaces
//!                 NumClassInstances    Number of class-instance interfaces in the array
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phShader     The UMD's shader handle
//!
//! RETURN STATUS: LWAPI_OK if pD3D11GeometryShader is valid and the OUT pointers are non-null
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_GetGeometryShaderHandle(ID3D11DeviceContext *pContext,
                                                    ID3D11GeometryShader *pD3D11GeometryShader,
                                                    ID3D11ClassInstance *const *ppD3D11ClassInstance,
                                                    UINT NumClassInstances,
                                                    LWDX_ObjectHandle* phShader);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_GetPixelShaderHandle
//
//! \code
//!   DESCRIPTION:  This function returns a shader's handle as used inside of the UMD
//!
//!         INPUT:  pD3D11PixelShader  The runtime pixel shader handle
//!                 ppD3D11ClassInstance Pointer to an array of class-instance interfaces
//!                 NumClassInstances    Number of class-instance interfaces in the array
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phShader     The UMD's shader handle
//!
//! RETURN STATUS: LWAPI_OK if pD3D11PixelShader is valid and the OUT pointers are non-null
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_GetPixelShaderHandle(ID3D11DeviceContext *pContext,
                                                 ID3D11PixelShader *pD3D11PixelShader,
                                                 ID3D11ClassInstance *const *ppD3D11ClassInstance,
                                                 UINT NumClassInstances,
                                                 LWDX_ObjectHandle* phShader);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_GetComputeShaderHandle
//
//! \code
//!   DESCRIPTION:  This function returns a shader's handle as used inside of the UMD
//!
//!         INPUT:  pD3D11ComputeShader  The runtime shader handle
//!                 ppD3D11ClassInstance Pointer to an array of class-instance interfaces
//!                 NumClassInstances    Number of class-instance interfaces in the array
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phShader     The UMD's shader handle
//!
//! RETURN STATUS: LWAPI_OK if pD3D11ComputeShader is valid and the OUT pointers are non-null
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_GetComputeShaderHandle(ID3D11DeviceContext *pContext,
                                                   ID3D11ComputeShader *pD3D11ComputeShader,
                                                   ID3D11ClassInstance *const *ppD3D11ClassInstance,
                                                   UINT NumClassInstances,
                                                   LWDX_ObjectHandle* phShader);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_GetHullShaderHandle
//
//! \code
//!   DESCRIPTION:  This function returns a shader's handle as used inside of the UMD
//!
//!         INPUT:  pD3D11HullShader  The runtime shader handle
//!                 ppD3D11ClassInstance Pointer to an array of class-instance interfaces
//!                 NumClassInstances    Number of class-instance interfaces in the array
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phShader     The UMD's shader handle
//!
//! RETURN STATUS: LWAPI_OK if pD3D11HullShader is valid and the OUT pointers are non-null
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_GetHullShaderHandle(ID3D11DeviceContext *pContext,
                                                ID3D11HullShader *pD3D11HullShader,
                                                ID3D11ClassInstance *const *ppD3D11ClassInstance,
                                                UINT NumClassInstances,
                                                LWDX_ObjectHandle* phShader);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_GetDomainShaderHandle
//
//! \code
//!   DESCRIPTION:  This function returns a shader's handle as used inside of the UMD
//!
//!         INPUT:  pD3D11DomainShader  The runtime shader handle
//!                 ppD3D11ClassInstance Pointer to an array of class-instance interfaces
//!                 NumClassInstances    Number of class-instance interfaces in the array
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phShader     The UMD's shader handle
//!
//! RETURN STATUS: LWAPI_OK if pD3D11DomainShader is valid and the OUT pointers are non-null
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_GetDomainShaderHandle(ID3D11DeviceContext *pContext,
                                                  ID3D11DomainShader *pD3D11DomainShader,
                                                  ID3D11ClassInstance *const *ppD3D11ClassInstance,
                                                  UINT NumClassInstances,
                                                  LWDX_ObjectHandle* phShader);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_SetShaderDebuggerHeapSize
//
//!   Sets the private heap available for use by the shader debugger.
//!   By default this heap has a size of zero.  The debugger should
//!   set this to zero if it wants to the destroy an existing heap.
//!   After the heap is resized, any previous contents of the heap
//!   are invalid and should be reinitialized by the debugger.
//!   However, the contents of this heap will be preserved between
//!   migrations between sysmem and vidmem for the applicable shader
//!   cache (see LwAPI_D3D1x_MoveShaderCacheBetweelwidAndSys)
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev         The device on which the callback is valid.
//!   \param [in]  newSize      The new requested size for the heap, in bytes
//!   \param [in]  shaderType   The shader type (using enum)
//!   \param [out] pNewOffset   The offset in bytes from the start of the shader heap. Can be NULL if newSize == 0.
//!
//!   \return LWAPI_OK if the heap was successfully resized.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_SetShaderDebuggerHeapSize(__in ID3D11Device *pDev,
                                                      __in LwU32 newSize,
                                                      __in D3D_SHADER_TYPE shaderType,
                                                      __out_opt LwU32 *pNewOffset);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_SetDeviceStateSaveBuffer
//
//!   Creates a region in Vidmem where the trap handler will dump
//!   the SM states. This will be used in Fermi and Kepler by the debugger.
//!   Set the size to zero to destroy the existing allocation.
//!   Resize operation is not supported -- destroy the allocation and recreate
//!   a new one.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!    \param [in]   pDev         The device on which the callback is valid.
//!    \param [in]   newSize      The new requested size for the heap, in bytes
//!    \param [in]   shaderType   The shader type (using enum)
//!    \param [out]  pNewOffset   The offset in bytes from the start of the shader heap. Can be NULL if newSize == 0.
//!
//!    \return LWAPI_OK if the heap was successfully resized.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_SetDeviceStateSaveBuffer(__in ID3D11Device *pDev,
                                                     __in LwU32 newSize,
                                                     __in D3D_SHADER_TYPE shaderType,
                                                     __out_opt LwU64 *phAllocation);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_GetShaderUCodeAllocationInfo
//
//! \code
//!   DESCRIPTION:  This function returns a shader's address in video memory, and
//!                 its memory allocation handle.
//!
//!         INPUT:  pContext     The Context on which the resource was created
//!                 hShader      Handle to the internal shader data struction of the UMD
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phAllocation   The shader's allocation handle
//!                 pBlockOffset   The shader's offset into its allocation
//!                 pProgramOffset The offset to shader's debug instance (w.r.t. pBlockOffset)
//!                 pLength        The shader block's length.
//!
//! RETURN STATUS: LWAPI_OK if the OUT pointers are non-null
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_GetShaderUCodeAllocationInfo(ID3D11DeviceContext *pContext,
                                                         LWDX_ObjectHandle hShader,
                                                         LwU32* phAllocation,
                                                         LwU32* pBlockOffset,
                                                         LwU32* pProgramOffset,
                                                         LwU32* pLength);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__d3d11_h__)

//! Versioned parameter structure for LwAPI_D3D11_GetComputeShaderInfo.  Please add new
//! parameters to the _end_ of the struct and increment the version info in LW_COMPUTE_SHADER_INFO_VER.
//! \ingroup nsightapi
typedef struct 
{
    LwU32 version;                    //!< [IN]  The struct version used by the client.  Set this to LW_COMPUTE_SHADER_INFO_VER
    LwU32 smemSize;                   //!< [OUT] Size of shared memory in bytes
    LwU32 tmpRegCount;                //!< [OUT] The number of temporary registers used
} LW_COMPUTE_SHADER_INFO;

//! \ingroup nsightapi
#define LW_COMPUTE_SHADER_INFO_VER MAKE_LWAPI_VERSION(LW_COMPUTE_SHADER_INFO, 1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_GetComputeShaderInfo
//
//!   This function returns various info about a compute shader 
//!   including smem size, register usage, etc.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//
//!   \param [in]      pContext            The Context on which the resource was created
//!   \param [in]      hShader             Handle to the internal shader data struction of the UMD
//!   \param [in,out]  pComputeShaderInfo  Results of the query
//!
//!   \return LWAPI_OK if the OUT pointers are non-null
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_GetComputeShaderInfo(__in ID3D11DeviceContext *pContext,
                                                 __in LWDX_ObjectHandle hShader,
                                                 __inout LW_COMPUTE_SHADER_INFO* pComputeShaderInfo);

#endif //if defined(__d3d11_h__)
#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_GetShaderLocalMemoryAllocationInfo
//
//!    This function returns the device's local memory allocation info.
//!    It does not take a shader handle because the local memory allocation
//!    is made per device and not per-shader.
//!  
//!    \warning Note, this info represents the current state of the UMD and
//!    does not necessarily reflect the values used by the GPU. Enable warp
//!    semaphore reports (see LwAPI_D3D11_EnableWarpSemaphoreReports) if you
//!    need current data. 
//!  
//!    \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!    \param [in]   pDev                  The device on which the resource was created
//!    \param [out]  phAllocation          The D3DKMT local memory allocation handle
//!    \param [out]  pBlockOffset          The offset into the local memory allocation
//!    \param [out]  pLength               The length of the allocation
//!    \param [out]  pMaxWarpsPerSm;       Deprecated, returns zero
//!    \param [out]  pLmemBytesPerThread   Deprecated, returns zero
//!
//!    \return   LWAPI_OK if the OUT pointers are non-null.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_GetShaderLocalMemoryAllocationInfo(__in ID3D11DeviceContext *pContext,
                                                               __out LwU32* phAllocation,
                                                               __out LwU32* pBlockOffset,
                                                               __out LwU32* pLength,
                                                               __out LwU32* pMaxWarpsPerSm,
                                                               __out LwU32* pLmemBytesPerThread);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_BuildDebugShaderInstance2
//
//!   This function creates and builds a debug instance of a shader.
//!   If the shader already has a debug instance then it returns
//!   immediately with the instructions unless the rebuild param is true.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]      pDev         The device to which the shader belongs to.
//!   \param [in]      pParamsIn    Pointer to extendable input structure.
//!   \param [in,out]  pParamsOut   Pointer to extendable output structure.
//!
//!   \return LWAPI_OK if pDev is valid and pParamsIn and pParamsOut are non-null
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_BuildDebugShaderInstance2(__in ID3D11Device *pDev,
                                                      __in sdBuildDebugShaderInstanceParamsIn  *pParamsIn,
                                                      __inout sdBuildDebugShaderInstanceParamsOut *pParamsOut);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_SetShaderDebuggerCallback
//
//!   This function is used to register callbacks for various debug events.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev               The device on which the callback is valid.
//!   \param [in]  cbType             The type of the callback to be set, see common/inc/ShaderDebuggerCallbacks.h
//!   \param [in]  pCallbackFunction  Pointer to the callback function. Pass NULL to disable the callback.
//!   \param [in]  pParam             Application data that will be passed back to this callback.
//!
//!   \return  LWAPI_OK if the callback was successfully set.
//!
//!   \note  An application may change it's callback functions at any time, and may
//!          unregister from any function by passing NULL in as a function pointer.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_SetShaderDebuggerCallback(__in ID3D11DeviceContext *pContext,
                                                      __in LwU32 cbType,
                                                      __in_opt SHADERDEBUGGER_CALLBACK pCallbackFunction,
                                                      __in_opt void* pParam);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_GetResourceSubresourceInfo
//
//!   Returns information about the internal layout of subresources in a driver resource.
//!   To obtain the subresource count, callers should call this with ppInfoBuffer=NULL.
//!   Then, the caller should allocate an array of LwAPI_D3DResourceSubresourceInfo* and
//!   initialize each member of the array with a valid pointer.
//!   When ppInfoBuffer is non-null, the caller must provide its array length in pSubresourceCount.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//!   \deprecated Use LwAPI_D3D11_GetResourceSubresourceInfo2 instead.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev               The device pointer.
//!   \param [in]   hResource          The resource handle.
//!   \param [in]   Version            The version of the output structure used to allocate the buffer.
//!   \param [out]  pSubresourceCount  Available subresource count or size of ppInfoBuffer. See comments above.
//!   \param [out]  ppInfoBuffer       Result buffer allocated by caller. See comments above.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_GetResourceSubresourceInfo(__in ID3D11Device* pDev,
                                                       __in LWDX_ObjectHandle hResource,
                                                       __in LwU32 Version,
                                                       __inout LwU32* pSubresourceCount,
                                                       __out_ecount_part_opt(*pSubresourceCount, *pSubresourceCount) LwAPI_D3DResourceSubresourceInfo** ppInfoBuffer);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_GetResourceSubresourceInfo2
//
//!   Returns information about the internal layout of subresources in a driver resource.
//!   To obtain the subresource count, callers should call this with ppInfoBuffer=NULL.
//!   Then, the caller should allocate an array of sdD3DResourceSubresourceInfo_vX* (see
//!   common/inc/ShaderDebuggerStruct.h) and initialize each member of the array with a valid pointer.
//!   When ppInfoBuffer is non-null, the caller must provide its array length in pSubresourceCount.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//
//!   \param [in]   pDev               The device pointer.
//!   \param [in]   hResource          The resource handle.
//!   \param [in]   Version            The version of the output structure used to allocate the buffer.
//!   \param [out]  pSubresourceCount  Available subresource count or size of ppInfoBuffer. See comments above.
//!   \param [out]  ppInfoBuffer       Result buffer allocated by caller. See comments above.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_GetResourceSubresourceInfo2(__in ID3D11Device* pDev,
                                                       __in LWDX_ObjectHandle hResource,
                                                       __in LwU32 Version,
                                                       __inout LwU32* pSubresourceCount,
                                                       __out_ecount_part_opt(*pSubresourceCount, *pSubresourceCount) sdD3DResourceSubresourceInfo** ppInfoBuffer);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_EnableWarpSemaphoreReports
//
//!   Returns a pointer to a volatile block of memory, which contains lmem, crs,
//!   and warp parameters, circa when the debugger is servicing a breakpoint.
//!   In SLI mode, these pertain to GPU 0 only.
//!   The mapped memory is a an array of structures, which should be indexed
//!   with the correct sdWarpSemaphoreReportType enum as defined in common/inc/ShaderDebuggerStruct.h
//!   When this feature is enabled, extra WFIs can occur when driver state changes,
//!   and semaphores will be issued to the HW.  Thus this feature should be disabled
//!   when not in use.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//
//!   \param [in]   pDev                The device pointer
//!   \param [in]   enable              Enable or disable reporting
//!   \param [in]   requestedVersion    Since the driver allocates the memory, the user needs to
//!                                     let the driver know which version of the structure to create.
//!   \param [out]  ppOutMappedMemory   Pointer to the semaphore data block.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_EnableWarpSemaphoreReports(__in ID3D11Device* pDev,
                                                       __in bool enable,
                                                       __in LwU32 requestedVersion,
                                                       __out volatile sdWarpSemaphoreReport** ppOutMappedMemory);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_NsightEnableReporting
//
//!   Notify the D3D driver that Nsight is attaching to the process,
//!   enable reporting, register a callback with the driver. This
//!   callback function is called when a report data is available.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev                       The device pointer on which we will tag on.
//!   \param [in]  bEnable                    boolean flag to denote either to enable/disable.
//!   \param [in]  completedReportsCallback   Callback function.
//!   \param [in]  pCallbackData              Data associated with the callback function 
//!                                           that is passed back through the callback.
//!
//!   \return  LWAPI_OK if we have successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_NsightEnableReporting(__in ID3D11Device *pDev,
                                                  __in bool bEnable,
                                                  __in fdStatsReportsCompletedCallback completedReportsCallback, 
                                                  __in_opt void *pCallbackData);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_NsightCommunication
//
//!   Uber call that handles all Nsight instrumentation in the DX driver
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!   \note <b> When pInternalDev is valid, pContext (device context pointer) is just a mule device to carry our instructions.
//!              All the changes are really done on the pInternalDev (driver/deviceContext internal device pointer). </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]      pContext      The device context on which we want to instrument. 
//!   \param [in]      pInternalDev  Driver internal device pointer on which we want to make changes. 
//!   \param [in, out] pPayload      All the data needed by the instrumentation.
//!                                  check common/inc/ShaderDebuggerStruct.h for PayLoad defines.
//!   \return LWAPI_OK if the device was valid and we successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_NsightCommunication(__in ID3D11DeviceContext *pContext,
                                                __in void     *pInternalDev,
                                                __inout void  *pPayload);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_NsightFlushReporting
//
//!   Flushes reporting output for nsight.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//
//!   \param [in]  pDev    The device pointer on which we will flush on.
//!
//!   \return  LWAPI_OK if we have successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_NsightFlushReporting(__in ID3D11Device *pDev);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_NsightSetLwstomReportData
//
//!   Specifies the current custom report data for Nsight reports
//!   in the driver.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev    The device pointer on which we will tag on.
//!                        lwstomData Custom report data.
//!
//!   \return  LWAPI_OK if we have successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_NsightSetLwstomReportData(__in ID3D11DeviceContext *pContext,
                                                      __in LwU32 lwstomData);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_NsightSetLwrrentContextAndD3DCallCount
//
//!   Sets context handle for the device & sets counter for the specified
//!   NsightD3DCallType. 
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev          The device pointer on which we need to set the above.
//!   \param [in]   contextHandle API handle
//!   \param [in]   d3dCallType   Type of d3d call
//!   \param [in]   count         count-value to be set for corresponding d3d call.
//!
//!   \return  LWAPI_OK if we have successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_NsightSetLwrrentContextAndD3DCallCount(__in ID3D11DeviceContext *pContext, 
                                                                   __in LwU64 contextHandle, 
                                                                   __in LWAPI_NSIGHT_D3DCALLTYPE d3dCallIdType,
                                                                   __in LwU64 count);

#endif // defined(__cplusplus) && defined(__d3d11_h__)





#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D_SetFPSIndicatorState
//
//!   DESCRIPTION: Display an overlay that tracks the number of times the app presents per second, or,   
//!      the number of frames-per-second (FPS)
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in] bool    Whether or not to enable the fps indicator.
//!                
//! \return ::LWAPI_OK, 
//!         ::LWAPI_ERROR
//!
//! \ingroup dx 
/////////////////////////////////////////////////////////////////////////////// 
LWAPI_INTERFACE LwAPI_D3D_SetFPSIndicatorState(IUnknown *pDev, LwU8 doEnable);

#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)


#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_Present
//
//! DESCRIPTION: This API presents the contents of the next buffer in the sequence of back buffers 
//!              owned by a IDirect3DDevice9 device.
//!              This Present operation supports using a SwapGroup and SwapBarrier on the SwapChain
//!              that owns the back buffer to be presented.
//!
//!          NOTE: LwAPI_D3D9_Present is a wrapper of the method IDirect3DDevice9::Present which
//!                additionally notifies the D3D driver of the SwapChain used by the runtime for
//!                presentation, thus allowing the D3D driver to apply SwapGroup and SwapBarrier
//!                functionality to that SwapChain.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]    pDevice     The IDirect3DDevice9 interface that is used to issue the Present, 
//!                using the following IDirect3DDevice9::Present input parameters
//! \param [in]    pSwapChain   Optional pointer to a IDirect3DSwapChain9 interface. If provided, the presentation is exelwted
//!                             using this interface (i.e. pSwapChain->Present()) for the given swapchain only.
//!                             If NULL, the presentation is exelwted on the device for all swapchains as in pDevice->Present()
//! \param [in]    pSourceRect  A pointer to a RECT structure containing the source rectangle. 
//!                             If NULL, the entire source surface is presented.
//! \param [in]    pDestRect      A pointer to a RECT structure containing the destination rectangle, in window client coordinates. 
//!                   If NULL, the entire client area is filled. 
//! \param [in]    hDestWindowOverride  A pointer to a destination window whose client area is taken as the target for this presentation. 
//!                                     If this value is NULL, then the hWndDeviceWindow member of D3DPRESENT_PARAMTERS is taken. 
//! \param [in]    pDirtyRegion (IN)   A pointer to a region to be presented. It must be NULL unless the swap chain was reated with 
//!                                    D3DSWAPEFFECT_COPY. If this value is non-NULL, the contained region is expressed in back buffer coordinates.
//!
//! \retval ::LWAPI_OK                 the Present operation was successfully exelwted
//! \retval ::LWAPI_D3D_DEVICE_LOST    D3D device status is D3DERR_DEVICELOST or D3DERR_DEVICENOTRESET, the caller has to reset device   
//! \retval ::LWAPI_DEVICE_BUSY        the Present operation failed with an error other than D3DERR_DEVICELOST or D3DERR_DEVICENOTRESET
//! \retval ::LWAPI_ERROR              the communication with the D3D driver failed, SwapGroup/SwapBarrier may not be possible.
//! \retval ::LWAPI_API_NOT_INITIALIZED LwAPI was not yet initialized.
//!
//!\ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_Present(IDirect3DDevice9 *pDevice,
                                   IDirect3DSwapChain9 *pSwapChain,
                                   const RECT *pSourceRect,
                                   const RECT *pDestRect,
                                   HWND hDestWindowOverride,
                                   const RGNDATA *pDirtyRegion);
#endif //if defined(_D3D9_H_)

#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_QueryFrameCount
//
//!   DESCRIPTION: This API queries the universal framecounter of the G-Sync master device.
//!
//! \param [in]   pDevice            The caller provides the DX9 device that has access to the GSync device
//! \param [out]  pFrameCount        The caller provides the storage space where the framecount is stored.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::LWAPI_OK                  *pFrameCount populated with framecount value.
//! \retval ::LWAPI_ERROR               The operation failed.
//! \retval ::LWAPI_ILWALID_ARGUMENT    One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INITIALIZED LwAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_QueryFrameCount(IDirect3DDevice9 *pDevice,
                                           LwU32 *pFrameCount);
#endif //if defined(_D3D9_H_)

#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_ResetFrameCount
//
//!   DESCRIPTION: This API resets the universal framecounter on the G-Sync master device.
//!
//! \param [in]   pDevice            The caller provides the DX9 device that has access to the GSync device
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::LWAPI_OK                   framecounter has been reset
//! \retval ::LWAPI_ERROR                The operation failed.
//! \retval ::LWAPI_ILWALID_ARGUMENT     One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INITIALIZED  LwAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_ResetFrameCount(IDirect3DDevice9 *pDevice);
#endif //if defined(_D3D9_H_)

#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_QueryMaxSwapGroup
//
//!   DESCRIPTION: This API queries the number of supported SwapGroups and SwapBarriers in the graphics system.
//!
//! \param [in]   pDevice              The caller provides the DirectX 9 device that is used as a swapgroup client
//! \param [out]  pMaxGroups           The caller provides the storage space where the number of available SwapGroups is stored.
//! \param [out]  pMaxBarriers         The caller provides the storage space where the number of available SwapBarriers is stored.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::LWAPI_OK                   the number of SwapGroups and SwapBarriers has been stored
//! \retval ::LWAPI_ERROR                The operation failed.
//! \retval ::LWAPI_ILWALID_ARGUMENT     One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INITIALIZED  LwAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_QueryMaxSwapGroup(IDirect3DDevice9 *pDevice, 
                                             LwU32 *pMaxGroups, 
                                             LwU32 *pMaxBarriers); 
#endif //if defined(_D3D9_H_)

#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_QuerySwapGroup
//
//!   DESCRIPTION: This API queries the current SwapGroup and SwapBarrier that a SwapChain of a specific client device is bound to.
//!
//! \param [in]   pDevice            The caller provides the DirectX 9 device that is used as a swapgroup client
//! \param [in]   pSwapChain         The caller provides the IDirect3DSwapChain9 interface as a handle to the SwapChain  
//!                                  that belongs to the swapgroup client device
//! \param [out]  pSwapGroup         The caller provides the storage space where the current SwapGroup is stored.
//! \param [out]  pSwapBarrier       The caller provides the storage space where the current SwapBarrier is stored.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::LWAPI_OK                   the current SwapGroup and SwapBarrier has been stored
//! \retval ::LWAPI_ERROR                The operation failed.
//! \retval ::LWAPI_ILWALID_ARGUMENT     One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INITIALIZED  LwAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_QuerySwapGroup(IDirect3DDevice9 *pDevice, 
                                          IDirect3DSwapChain9 *pSwapChain, 
                                          LwU32 *pSwapGroup, 
                                          LwU32 *pSwapBarrier); 
#endif //if defined(_D3D9_H_)

#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_JoinSwapGroup
//
//!   DESCRIPTION: This API causes the SwapChain of a SwapGroup client to join or leave the specified SwapGroup.
//!
//! \param [in]    pDevice               The caller provides the DirectX 9 device that is used as a swapgroup client
//! \param [in]    pSwapChain            The caller provides the IDirect3DSwapChain9 interface as a handle to the SwapChain  
//!                                      that belongs to the swapgroup client device
//! \param [in]    group                 The caller specifies the SwapGroup which the SwapChain should join.
//!                                      - If the value of group is zero, the SwapChain leaves the SwapGroup.
//!                                      - The SwapChain joins a SwapGroup if the SwapGroup number is a positive integer less than or
//!                                        equal to the maximum number of SwapGroups queried by LwAPI_SwapGroup_QueryMaxSwapGroup.
//! \param [in]    blocking              The caller specifies that a presentation of this SwapChain should return immediately or block
//!                                      until all members of the SwapGroup are ready and the presentation was actually exelwted.
//!                                      A boolean value of false means the Present operation returns immediately and a value of true
//!                                      means the Present operation is blocking.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::LWAPI_OK                   the SwapChain joined/left the SwapGroup accordingly
//! \retval ::LWAPI_ERROR                The operation failed.
//! \retval ::LWAPI_ILWALID_ARGUMENT     One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INITIALIZED  LwAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_JoinSwapGroup(IDirect3DDevice9 *pDevice, 
                                         IDirect3DSwapChain9 *pSwapChain, 
                                         LwU32 group,
                                         BOOL blocking); 
#endif //if defined(_D3D9_H_)

#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_BindSwapBarrier
//
//!   DESCRIPTION: This API causes a SwapGroup to be bound to or released from the specified SwapBarrier.
//!
//! \param [in]    pDevice    The caller provides the DirectX 9 device that is used as a swapgroup client
//! \param [in]    group      The caller specifies the SwapGroup to be bound to the SwapBarrier.
//! \param [in]    barrier    The caller specifies the SwapBarrier that the SwapGroup should be bound to.
//!                              - If the value of barrier is zero, the SwapGroup will be released from the SwapBarrier.
//!                              - The SwapGroup will be bound to the SwapBarrier if the value of barrier is a positive 
//!                                integer less than or equal to the maximum number of SwapBarriers queried by LwAPI_SwapGroup_QueryMaxSwapGroup.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::LWAPI_OK                  the SwapGroup is bound to or released from the specified SwapBarrier
//! \retval ::LWAPI_ERROR               The operation failed.
//! \retval ::LWAPI_ILWALID_ARGUMENT    One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INITIALIZED LwAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_BindSwapBarrier(IDirect3DDevice9 *pDevice, 
                                           LwU32 group, 
                                           LwU32 barrier); 
#endif //if defined(_D3D9_H_)


//! \ingroup dx
typedef enum
{
    LWAPI_VSYNC_DEFAULT,                    //!< Fall back to the default settings
    LWAPI_VSYNC_OFF,                        //!< Force vertical sync off when performance is more important than image quality and for benchmarking" 
    LWAPI_VSYNC_ON,                         //!< Force vertical sync on when image quality is more important than performance
    LWAPI_VSYNC_ADAPTIVE,                   //!< Select adaptive to turn vertical sync on or off based on the frame rate. 
                                            //!  Vertical sync will only be on for frame rates above the monitor refresh rate.
    LWAPI_VSYNC_ADAPTIVE_HALF_REFRESH_RATE  //!<

} LWAPI_VSYNC_MODE;

#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D_SetVerticalSyncMode
//
//!   DESCRIPTION: This API set the vertical sync mode for the given device context.
//!
//! \param [in]    pDevice    The caller provides the device and can be either IDirect3DDevice9 or ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [in]    vsyncMode  The caller specifies the LWAPI_VSYNC_MODE to be set.
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D_SetVerticalSyncMode(__in IUnknown *pDevice, __in LWAPI_VSYNC_MODE vsyncMode); 

#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)

#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D1x_Present
//
//! DESCRIPTION: Presents the contents of the next buffer in the sequence of back buffers 
//!              owned by a D3D device.
//!              This Present operation supports using a SwapGroup and SwapBarrier on the SwapChain
//!              that owns the back buffer to be presented.
//!
//!          NOTE: LwAPI_D3D1x_Present is a wrapper of the method IDXGISwapChain::Present which
//!                additionally notifies the D3D driver of the SwapChain used by the runtime for
//!                presentation, thus allowing the D3D driver to apply SwapGroup and SwapBarrier
//!                functionality to that SwapChain.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     pDevice          The D3D device interface that is used to issue the Present operation, 
//!                                 using the following IDirect3DDevice9::Present input parameters.
//!                                  pDevice can be either ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [in]     pSwapChain       The IDXGISwapChain interface that is intended to present
//! \param [in]     SyncInterval     An integer that specifies the how to synchronize presentation of a frame with the vertical blank.
//!                                          Values are: 
//!                                          - 0:  The presentation oclwrs immediately, there is no synchronization.
//!                                          - 1,2,3,4 : Synchronize presentation after the n'th vertical blank.
//! \param [in]     Flags            An integer value that contains swap-chain presentation options as defined in DXGI_PRESENT.
//!
//! \retval ::LWAPI_OK                 the Present operation was successfully exelwted
//! \retval ::LWAPI_DEVICE_BUSY        the Present operation failed with an error DXGI_ERROR_DEVICE_RESET or DXGI_ERROR_DEVICE_REMOVED, 
//                                     DXGI_STATUS_OCCLUDED, or D3DDDIERR_DEVICEREMOVED. 
//! \retval ::LWAPI_ERROR              the communication with the D3D driver failed, SwapGroup/SwapBarrier may not be possible.
//! \retval ::LWAPI_API_NOT_INITIALIZED LwAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D1x_Present(IUnknown *pDevice,
                                    IDXGISwapChain *pSwapChain,
                                    UINT SyncInterval,
                                    UINT Flags);

#endif //if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)

#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D1x_QueryFrameCount
//
//!   DESCRIPTION: This API queries the universal framecounter of the G-Sync master device.
//!
//! \param [in]    pDevice           The caller provides the D3D device that has access to the G-Sync device,
//!                                  pDevice can be either ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [out]   pFrameCount       The caller provides the storage space where the framecount is stored.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::LWAPI_OK                   *pFrameCount populated with framecount value.
//! \retval ::LWAPI_ERROR                The operation failed.
//! \retval ::LWAPI_ILWALID_ARGUMENT     One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INITIALIZED  LwAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D1x_QueryFrameCount(IUnknown *pDevice,
                                            LwU32 *pFrameCount);
#endif //if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)

#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D1x_ResetFrameCount
//
//!   DESCRIPTION: This API resets the universal framecounter on the G-Sync master device.
//!
//! \param [in]    pDevice         The caller provides the D3D device that has access to the GSync device,
//!                                pDevice can be either ID3D10Device or ID3D10Device1 or ID3D11Device.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::LWAPI_OK                   framecounter has been reset
//! \retval ::LWAPI_ERROR                The operation failed.
//! \retval ::LWAPI_ILWALID_ARGUMENT     pDevice arg passed in is invalid.
//! \retval ::LWAPI_API_NOT_INITIALIZED  LwAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D1x_ResetFrameCount(IUnknown *pDevice);
#endif //if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)

#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D1x_QueryMaxSwapGroup
//
//!   DESCRIPTION: This API queries the number of supported SwapGroups and SwapBarriers in the graphics system.
//!
//! \param [in]    pDevice        The caller provides the D3D device that is intended to use SwapGroup functionality.
//!                               pDevice can be either ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [out]   pMaxGroups     The caller provides the storage space where the number of available SwapGroups is stored.
//! \param [out]   pMaxBarriers   The caller provides the storage space where the number of available SwapBarriers is stored.
//! 
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::LWAPI_OK                  the number of SwapGroups and SwapBarriers has been stored
//! \retval ::LWAPI_ERROR               The operation failed.
//! \retval ::LWAPI_ILWALID_ARGUMENT    One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INITIALIZED LwAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D1x_QueryMaxSwapGroup(IUnknown *pDevice, 
                                              LwU32 *pMaxGroups, 
                                              LwU32 *pMaxBarriers); 
#endif //if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)

#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D1x_QuerySwapGroup
//
//!   DESCRIPTION: This API queries the current SwapGroup and SwapBarrier that a SwapChain of a specific client device is bound to.
//!
//! \param [in]    pDevice            The caller provides the D3D device that owns the SwapChain used as a SwapGroup client.
//!                                   pDevice can be either ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [in]    pSwapChain         The IDXGISwapChain interface that is used as the SwapGroup client.
//!
//! \param [out]   pSwapGroup         The caller provides the storage space where the current SwapGroup is stored.
//! \param [out]   pSwapBarrier       The caller provides the storage space where the current SwapBarrier is stored.
//! 
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::LWAPI_OK                   the current SwapGroup and SwapBarrier has been stored
//! \retval ::LWAPI_ERROR                The operation failed.
//! \retval ::LWAPI_ILWALID_ARGUMENT     One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INITIALIZED  LwAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D1x_QuerySwapGroup(IUnknown *pDevice, 
                                           IDXGISwapChain  *pSwapChain, 
                                           LwU32 *pSwapGroup, 
                                           LwU32 *pSwapBarrier); 
#endif //if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)

#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D1x_JoinSwapGroup
//
//!   DESCRIPTION: This API causes the SwapChain of a SwapGroup client to join or leave the specified SwapGroup.
//!
//! \param [in]   pDevice            The caller provides the D3D device that owns the SwapChain used as a SwapGroup client.
//!                                  pDevice can be either ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [in]   pSwapChain         The IDXGISwapChain interface that is used as the SwapGroup client.
//! \param [in]   group              The caller specifies the SwapGroup which the SwapChain should join.
//!                                      - If the value of group is zero, the SwapChain leaves the SwapGroup.
//!                                      - The SwapChain joins a SwapGroup if the SwapGroup number is a positive integer less than or
//!                                        equal to the maximum number of SwapGroups queried by LwAPI_SwapGroup_QueryMaxSwapGroup.
//! \param [in]   blocking           The caller specifies that a presentation of this SwapChain should return immediately or block
//!                                  until all members of the SwapGroup are ready and the presentation was actually exelwted.
//!                                  A boolean value of false means the Present operation returns immediately and a value of true
//!                                  means the Present operation is blocking.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::LWAPI_OK                   the SwapChain joined/left the SwapGroup accordingly
//! \retval ::LWAPI_ERROR                The operation failed.
//! \retval ::LWAPI_ILWALID_ARGUMENT     One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INITIALIZED  LwAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D1x_JoinSwapGroup(IUnknown *pDevice, 
                                          IDXGISwapChain  *pSwapChain, 
                                          LwU32 group,
                                          BOOL blocking);
#endif //if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)

#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D1x_BindSwapBarrier
//
//!   DESCRIPTION: This API causes a SwapGroup to be bound to or released from the specified SwapBarrier.
//!
//! \param [in]   pDevice            The caller provides the D3D device that owns the SwapChain used as a SwapGroup client.
//!                                  pDevice can be either ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [in]   group              The caller specifies the SwapGroup to be bound to the SwapBarrier.
//! \param [in]   barrier            The caller specifies the SwapBarrier that the SwapGroup should be bound to.
//!                                      - If the value of barrier is zero, the SwapGroup releases the SwapBarrier.
//!                                      - The SwapGroup will be bound to the SwapBarrier if the value of barrier is a positive 
//!                                        integer less than or equal to the maximum number of SwapBarriers queried by LwAPI_D3D1x_QueryMaxSwapGroup.
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::LWAPI_OK                  the SwapGroup is bound to the specified SwapBarrier
//! \retval ::LWAPI_ERROR                The operation failed.
//! \retval ::LWAPI_ILWALID_ARGUMENT     One or more args passed in are invalid.
//! \retval ::LWAPI_API_NOT_INITIALIZED  LwAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D1x_BindSwapBarrier(IUnknown *pDevice, 
                                            LwU32 group, 
                                            LwU32 barrier); 
#endif //if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)

#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D_SetLwrrentSwapChain
//
//!   DESCRIPTION:  This function notifies the D3D driver of the DX runtime swapchain used for presentation.
//!
//! \param [in]  pDev                  The device on which the current DX SwapChain was created.
//!                                    We track resources being created by this SwapChain in the D3D driver as a SwapChain object.
//!                                    pDev can be either IDirect3DDevice9 or ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [in]  hSwapChain            A handle that specifies the current SwapChain and which is used in the interface between
//!                                    LwAPI and the D3D driver to identify a SwapChain object.
//!                                          
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \return   This call will return LWAPI_OK if the SwapChain handle could be successfully identify an object in the D3D driver, 
//!           otherwise it returns LWAPI_ERROR.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D_SetLwrrentSwapChain(IUnknown *pDevice,
                                              void     *params);

#endif // defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)





//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightAttach
//
//!   DESCRIPTION: This API notifies the OpenGL driver that Nsight is attaching to the process.
//!
//!    PARAMETERS: None.
//!
//! \retval ::LWAPI_API_NOT_INTIALIZED         : LWAPI not initialized
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND    : no LWPU GPU found
//! \retval ::LWAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::LWAPI_OK    : success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightAttach(void);

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightAttachEx
//
//!   DESCRIPTION: This API notifies the OpenGL driver that Nsight is attaching to the process.
//!                componentMask will mention with specific components of Nsight are being enabled.
//!
//!    PARAMETERS: None.
//!
//! \param [in]  componentMask  mask of nsight components to be enabled.
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_API_NOT_INTIALIZED         : LWAPI not initialized
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND    : no LWPU GPU found
//! \retval ::LWAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::LWAPI_OK    : success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightAttachEx(__in LwU32 componentMask);

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightDetach
//
//!   DESCRIPTION: This API notifies the OpenGL driver that Nsight is detaching from the process.
//!
//!    PARAMETERS: None.
//!
//! \retval ::LWAPI_API_NOT_INTIALIZED         : LWAPI not initialized
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND    : no LWPU GPU found
//! \retval ::LWAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::LWAPI_OK    : success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightDetach(void);

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightEnableReporting
//
//!   DESCRIPTION: This API enables reporting of Nsight statistics in the OpenGL driver.
//!
//!    PARAMETERS: None.
//!
//! \retval ::LWAPI_API_NOT_INTIALIZED         : LWAPI not initialized
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND    : no LWPU GPU found
//! \retval ::LWAPI_OPENGL_CONTEXT_NOT_LWRRENT : no current LWPU OpenGL 
//!                                                  context
//! \retval ::LWAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::LWAPI_OK    : success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightEnableReporting(__in fdStatsReportsCompletedCallback completedReportsCallback, 
                                                __in_opt void *pCallbackData);

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightDisableReporting
//
//!   DESCRIPTION: This API disables reporting of Nsight statistics in the OpenGL driver.
//!
//!    PARAMETERS: None.
//!
//! \retval ::LWAPI_API_NOT_INTIALIZED         : LWAPI not initialized
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND    : no LWPU GPU found
//! \retval ::LWAPI_OPENGL_CONTEXT_NOT_LWRRENT : no current LWPU OpenGL 
//!                                                  context
//! \retval ::LWAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::LWAPI_OK    : success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightDisableReporting(void);

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightFlushReporting
//
//!   DESCRIPTION: This API enables flush reporting of Nsight statistics in the OpenGL driver.
//!
//!    PARAMETERS: None.
//!
//! \retval ::LWAPI_API_NOT_INTIALIZED         : LWAPI not initialized
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND    : no LWPU GPU found
//! \retval ::LWAPI_OPENGL_CONTEXT_NOT_LWRRENT : no current LWPU OpenGL 
//!                                                  context
//! \retval ::LWAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::LWAPI_OK    : success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightFlushReporting(void);

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightSetGlobalLwstomReportData
//
//!   DESCRIPTION: This API specifies the current global custom report data for Nsight 
//!                reports in the OpenGL driver. The global custom report data
//!                is process global data.
//!
//! \param [in]  lwstomData  Custom report data.
//!
//! \retval ::LWAPI_API_NOT_INTIALIZED         : LWAPI not initialized
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND    : no LWPU GPU found
//! \retval ::LWAPI_OPENGL_CONTEXT_NOT_LWRRENT : no current LWPU OpenGL 
//!                                                  context
//! \retval ::LWAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::LWAPI_OK    : success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightSetGlobalLwstomReportData(__in LwU32 lwstomData);

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightSetLwstomReportData
//
//!   DESCRIPTION: This API specifies the current custom report data for Nsight reports
//!                in the OpenGL driver. The custom report data is associated
//!                with the current context.
//!
//! \param [in]  lwstomData  Custom report data.
//!
//! \retval ::LWAPI_API_NOT_INTIALIZED         : LWAPI not initialized
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND    : no LWPU GPU found
//! \retval ::LWAPI_OPENGL_CONTEXT_NOT_LWRRENT : no current LWPU OpenGL 
//!                                                  context
//! \retval ::LWAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::LWAPI_OK    : success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightSetLwstomReportData(__in LwU32 lwstomData);

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightSetDrawCallId
//
//!   DESCRIPTION: This API specifies the ID of the current (next) draw call. This ID is
//!                used in LwapiNsightStatsReport() (stored in the count field)
//!                for draw calls, and it is also used by the OpenGL shader 
//!                debugger. The ID is associated with the current context.
//!
//! \param [in] id   ID of the current (next) draw call.
//!
//! \retval ::LWAPI_API_NOT_INTIALIZED         : LWAPI not initialized
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND    : no LWPU GPU found
//! \retval ::LWAPI_OPENGL_CONTEXT_NOT_LWRRENT : no current LWPU OpenGL 
//!                                                  context
//! \retval ::LWAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::LWAPI_OK    : success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightSetDrawCallId(__in LwU64 id);

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightPushTag
//
//!   DESCRIPTION: This API inserts the specified tag into the push buffer associated with
//!                the current context.
//!
//! \param [in]   tag   Tag to insert into the push buffer
//! \param [in]   id    An Nsight supplied ID to associate with the event
//
//! \retval ::LWAPI_API_NOT_INTIALIZED         : LWAPI not initialized
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND    : no LWPU GPU found
//! \retval ::LWAPI_OPENGL_CONTEXT_NOT_LWRRENT : no current LWPU OpenGL 
//!                                                  context
//! \retval ::LWAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::LWAPI_OK    : success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightPushTag(__in LwU32 tag, 
                                        __in LwU64 id);

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightPop
//
//!   DESCRIPTION: This API pops the tag most recently pushed with LwAPI_OGL_NsightPopTag().
//!
//!    PARAMETERS: None.
//!
//! \retval ::LWAPI_API_NOT_INTIALIZED         : LWAPI not initialized
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND    : no LWPU GPU found
//! \retval ::LWAPI_OPENGL_CONTEXT_NOT_LWRRENT : no current LWPU OpenGL 
//!                                                  context
//! \retval ::LWAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::LWAPI_OK    : success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightPop();

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightGetDeviceHandles
//
//!   This API gets the device handles associated with the current context / thread.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [out]  adapterHandle   Populated with the adapter handle
//!   \param [out]  deviceHandle    Populated with the device handle
//!   \param [out]  contextHandle   Populated with the context handle
//!
//!   \retval  LWAPI_API_NOT_INTIALIZED if LWAPI not initialized
//!   \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND if no LWPU GPU found
//!   \retval  LWAPI_OPENGL_CONTEXT_NOT_LWRRENT if no current LWPU OpenGL context
//!   \retval  LWAPI_ERROR if OpenGL driver failed to load properly
//!   \retval  LWAPI_OK if success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightGetDeviceHandles(__out LwU32 *adapterHandle,
                                                 __out LwU32 *deviceHandle,
                                                 __out LwU32 *contextHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightGetPrivateHandle
//
//!   This API gets the os-private handle associated with the current context.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [out]  handle   Populated with the driver's os-private handle for the current context
//!
//!   \retval  LWAPI_API_NOT_INTIALIZED if LWAPI not initialized
//!   \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND if no LWPU GPU found
//!   \retval  LWAPI_OPENGL_CONTEXT_NOT_LWRRENT if no current LWPU OpenGL context
//!   \retval  LWAPI_ERROR if OpenGL driver failed to load properly
//!   \retval  LWAPI_OK if success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightGetPrivateHandle(__out LwU64 *handle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightGetContextRmHandles
//
//!   This function retrieves the RM handles for the current context
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in,out]  pRmHandlesCollection  The device's RM handles of every channel/GPU combination that is active
//!
//!   \retval LWAPI_OK if and only if phClient and phDevice were populated with valid RM handles
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightGetContextRmHandles(__inout sdRmHandlesCollection* pRmHandlesCollection);


#ifndef _HRESULT_DEFINED
#define HRESULT long
#endif

typedef HRESULT (__cdecl *SHADERDEBUGGER_CALLBACK) (__in void* pCallbackData,
                                                    __in_opt void* pParam);

#ifndef _HRESULT_DEFINED
#undef HRESULT
#endif

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightSetShaderDebuggerCallback
//
//!   This function is used to register callbacks for various debug events.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]   cbType             The SHADERDEBUGGER_CALLBACK_TYPE.
//!   \param [in]   pCallbackFunction  Pointer to the callback function.
//!   \param [in]   pParam             Application data that will be passed back to this callback.
//!
//!
//!   \retval LWAPI_OK if the callback was successfully set.
//!
//!   \note An application may change it's callback functions at any time, and may
//!         unregister from any function by passing NULL in as a function pointer.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightSetShaderDebuggerCallback(__in LwU32 callbackType,
                                                          __in SHADERDEBUGGER_CALLBACK pCallbackFunction,
                                                          __in_opt void* pParam);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightGetPrivateConstDataSlotAndOffset
//
//!   Sets data in the private UMD constant buffer.
//!   Slots are defined by the LwAPIPrivateConstDataSlot enumeration.
//!   Consumers of this constant buffer data must take care to call
//!   LwAPI_OGL_NsightGetPrivateConstDataSlotAndOffset for the same instance
//!   of the shader which will consume the data.  Producers of this data
//!   should call LwAPI_OGL_NsightSetPrivateConstDataSlotAndOffset any time
//!   before drawing.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]   dataslot
//!
//!   \param [out]  pOutConstSlot
//!   \param [out]  pOutScalarOffset
//!
//!   \retval LWAPI_OK if the call succeeded.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightGetPrivateConstDataSlotAndOffset(__in LwAPIPrivateConstDataSlot dataslot,
                                                                 __out LwU32 *pOutConstSlot,
                                                                 __out LwU32 *pOutScalarOffset);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightSetPrivateConstData
//
//!   Sets data in the private UMD constant buffer.
//!   Slots are defined by the LwAPIPrivateConstDataSlot enumeration.
//!   Consumers of this constant buffer data must take care to call
//!   LwAPI_OGL_NsightGetPrivateConstDataSlotAndOffset for the same instance
//!   of the shader which will consume the data.  Producers of this data
//!   should call LwAPI_OGL_NsightSetPrivateConstData any time before drawing.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]  dataslot
//!   \param [in]  data
//!
//!   \retval LWAPI_OK if the call succeeded.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightSetPrivateConstData(__in LwAPIPrivateConstDataSlot dataslot,
                                                    __in LwU32 data);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightEnableWarpSemaphoreReports
//
//!    Returns a pointer to a volatile block of memory, which contains lmem, crs,
//!    and warp parameters, circa when the debugger is servicing a breakpoint.
//!    In SLI mode, these pertain to GPU 0 only.
//!    The mapped memory is a an array of structures, which should be indexed
//!    with the correct WarpSemaphoreReportType enum.
//!    When this feature is enabled, extra WFIs can occur when driver state changes,
//!    and semaphores will be issued to the HW.  Thus this feature should be disabled
//!    when not in use.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]   bEnable             boolean 0/1 flag to denote enable or disable reporting
//!   \param [in]   requestedVersion    Since the driver allocates the memory, the user needs to
//!                                     let the driver know which version of the structure to create.
//!   \param [out]  ppOutMappedMemory   Pointer to the semaphore data block.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightEnableWarpSemaphoreReports(__in LwU32 bEnable,
                                                           __in LwU32 requestedVersion,
                                                           __out volatile sdWarpSemaphoreReport** ppOutMappedMemory);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightSetShaderDebuggerHeapSize
//
//!   Sets the private heap available for use by the shader debugger.
//!   By default this heap has a size of zero.  The debugger should
//!   set this to zero if it wants to the destroy an existing heap.
//!   After the heap is resized, any previous contents of the heap
//!   are invalid and should be reinitialized by the debugger.
//!   However, the contents of this heap will be preserved between
//!   migrations between sysmem and vidmem for the applicable shader
//!   cache (see LwAPI_OGL_NsightMoveShaderCacheBetweelwidAndSys)
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]   newSize      The new requested size for the heap, in bytes
//!   \param [in]   shaderType   The shader type (using enum)
//!   \param [out]  pNewOffset   The offset in bytes from the start of the shader heap. Can be NULL if newSize == 0.
//!
//!   \retval LWAPI_OK if the heap was successfully resized.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightSetShaderDebuggerHeapSize(__in LwU32 newSize,
                                                          __in LwU32 shaderType,
                                                          __out LwU32 *pNewOffset);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightSetDeviceStateSaveBuffer
//
//!   Creates a region in Vidmem where the trap handler will dump
//!   the SM states. This will be used in Fermi and Kepler by the debugger.
//!   Set the size to zero to destroy the existing allocation.
//!   Resize operation is not supported -- destroy the allocation and recreate
//!   a new one.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]   newSize      The new requested size for the heap, in bytes
//!   \param [in]   shaderType   The shader type (using enum)
//!
//!   \param [out]  pNewOffset   The offset in bytes from the start of the shader heap. Can be NULL if newSize == 0.
//!
//!
//! RETURN STATUS: LWAPI_OK if the heap was successfully resized.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightSetDeviceStateSaveBuffer(__in LwU32 newSize,
                                                         __in LwU32 shaderType,
                                                         __out LwU64 *phAllocation);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightMoveShaderCacheBetweelwidAndSys
//
//!   This function will be used by the ShaderDebugger and will move shader cache and shader lmem
//!   from Video memory to System memory or the other way round. When the app starts up,
//!   we usually store shader cache and lmem in Video memory. To facilitate shader debugging (to
//!   set breakpoints, replace shaders at a breakpoint, and read/write lmem), we need these in system memory.
//!   Usual way of running things: When the user sets his first breakpoint in the shader, we
//!   get this call to move shader cache and lmem from VID to SYS. From then on, the driver maintains
//!   the cache and lmem in SYS memory. Once the user removes his last breakpoint, we will get this call
//!   to move cache and lmem from SYS to VID memory & continue normal operations after that.
//!   The shaderTypeFlags parameter allows us to move a single shaderType cache or multiple caches, as well as the 
//!   lmem at the same time.
//!
//!   \note Only moves the lmem to sys on Fermi and Kepler architectures, Tesla lmem remains in vid.
//! 
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]  cacheLocation   Specifies location to move the shadercache and lmem (SD_STORAGE_VID/SD_STORAGE_SYS).
//!                                Check the sdShaderHeapStorage enums in common/inc/ShaderDebuggerStruct.h for valid
//!                                values. Don't use SD_STORAGE_COUNT.
//!   \param [in]  shaderTypeFlags Specifies what all shader caches need to be moved.
//!                                Check the sdShaderType enums in common/inc/ShaderDebuggerStruct.h for valid values.
//!                                You can use multiple of these, depending on the types of ShaderCaches you want to move.
//!                                NOTE: Trying to use SD_SHADER_TYPE_HULL & SD_SHADER_TYPE_DOMAIN flags on D3D10 devices
//!                                will return an LWAPI_ILWALID_ARGUMENT error.
//!
//!
//!   \retval  This will be a synchronous call i.e. would be exelwted immediately. Hence will return LWAPI_OK if the call was successfull.
//!            This call will return LWAPI_OK, without doing anything, if shaderCache already exists in the requested location
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////

LWAPI_INTERFACE LwAPI_OGL_NsightMoveShaderCacheBetweelwidAndSys(__in LwU32 cacheLocation,
                                                                __in LwU32 shaderTypeFlags);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightGetDeviceKmtHandle
//
//!   This function retrieves the KMT handle for the current context
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [out]  phDevice  The current context's KMT handle
//!
//!   \retval LWAPI_OK if and only if phDevice was populated with a valid KMT handle.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightGetDeviceKmtHandle(__out LwU64* phDevice);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION TYPE: LwAPI_OGL_NsightEnableDebugMode
//
//!   Notify the OGL driver to use debug shader instances instead of
//!   release/optimized shaders from now until it gets this call with
//!   enable flag set to false. 
//!   EnableFlag is true, when a user sets his first BreakPoint
//!   EnableFlag is false, when the user removes his last BreakPoint
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]  bEnable  boolean 0/1 flag to denote either to enable/disable.
//!
//!   \retval LWAPI_OK if we have successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightEnableDebugMode(__in LwU32 bEnable);


//! Prototype structure version, check common/inc/ShaderDebuggerStruct.h for versions
//! lwrrently supported by the driver!
//! \ingroup nsightapi
typedef struct _sdGlBuildDebugShaderInstanceParamsIn
{
    LwU32 structVersion;
} sdGlBuildDebugShaderInstanceParamsIn;

//! \ingroup nsightapi
#define SD_GL_BUILD_DEBUG_SHADER_INSTANCE_PARAMS_IN_VERSION_V0 MAKE_SD_VERSION(sdGlBuildDebugShaderInstanceParamsIn, 0)

//! Prototype structure version, check common/inc/ShaderDebuggerStruct.h for versions
//! lwrrently supported by the driver!
//! \ingroup nsightapi
typedef struct _sdGlBuildDebugShaderInstanceParamsOut
{
    LwU32 structVersion;
} sdGlBuildDebugShaderInstanceParamsOut;

//! \ingroup nsightapi
#define SD_GL_BUILD_DEBUG_SHADER_INSTANCE_PARAMS_OUT_VERSION_V0 MAKE_SD_VERSION(sdGlBuildDebugShaderInstanceParamsOut_v0, 0)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION TYPE: LwAPI_OGL_NsightBuildDebugShaderInstance
//
//!   This function creates and builds a debug instance of a shader.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]      pParamsIn   Pointer to extendable input structure.
//!   \param [in,out]  pParamsOut  Pointer to extendable output structure.
//!
//!   \retval LWAPI_OK if we have successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightBuildDebugShaderInstance(__in sdGlBuildDebugShaderInstanceParamsIn  *pParamsIn,
                                                         __inout sdGlBuildDebugShaderInstanceParamsOut *pParamsOut);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightGetProgramiv
//
//!   This API notifies acts like glGetProgramiv, but accesses Nsight specific data.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]   id      Name of the program to query.
//!   \param [in]   pname   Name of the parameter to query.
//!   \param [out]  params  Pointer to memory where the query result will be stored
//!
//! /return   LWAPI_API_NOT_INTIALIZED if LWAPI not initialized
//! /return   LWAPI_LWIDIA_DEVICE_NOT_FOUND if no LWPU GPU found
//! /return   LWAPI_ERROR if OpenGL driver failed to load properly
//! /return   LWAPI_OK if success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightGetProgramiv(__in LwU32 id,
                                             __in LwU32 pname,
                                             __out LwU32 *params);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightGetDriverResourceInfoSize
//
//!   This API allows the caller to query the size required to 
//!   store all of the driver resource info.  The caller is
//!   responsible for allocating and freeing the memory necessary
//!   to query the resource info.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]   version   Version of the data structures to use.
//!   \param [out]  size      Pointer to an integer where the required size for the resource info
//!                           will be stored.
//!
//!   \retval  LWAPI_API_NOT_INTIALIZED if LWAPI not initialized
//!   \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND if no LWPU GPU found
//!   \retval  LWAPI_ERROR if OpenGL driver failed to load properly
//!   \retval  LWAPI_OK if success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightGetDriverResourceInfoSize(__in LwU32 version,
                                                          __out LwU32 *size);


//! Prototype structure version, check common/inc/ShaderDebuggerStruct.h for versions
//! lwrrently supported by the driver!
//! \ingroup nsightapi
typedef struct _sdOpenGLDriverResourceInfo
{
    LwU32 structVersion;
} sdOpenGLDriverResourceInfo;

//! \ingroup nsightapi
#define SD_OPENGL_DRIVER_RESOURCE_INFO_VERSION_V0 MAKE_SD_VERSION(sdOpenGLDriverResourceInfo_v0, 0)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightGetDriverResourceInfo
//
//!   This API allows the caller to query the driver resources
//!   that are in use on the GPU.  The resourceInfo parameter needs
//!   to be allocated/freed by the caller using the size obtained by calling
//!   LwAPI_OGL_NsightGetDriverResourceInfoSize() with the same struct version
//!   that will be passed as parameter to this call.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]  version       Version of the data structures to use.
//!   \param [out] resourceInfo  Pointer a memory allocation where the resource
//!                              info will be stored.
//!
//!   \retval  LWAPI_API_NOT_INTIALIZED if LWAPI not initialized
//!   \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND if no LWPU GPU found
//!   \retval  LWAPI_ERROR if OpenGL driver failed to load properly
//!   \retval  LWAPI_OK if success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightGetDriverResourceInfo(__in LwU32 version,
                                                      __out sdOpenGLDriverResourceInfo *resourceInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_OGL_NsightCommunication
//
//!   Uber call that handles all Nsight instrumentation in the GL driver
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in, out] pPayload      All the data needed by the instrumentation.
//!                                  check common/inc/LwDevToolsLwApiThunk.h for PayLoad defines.
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::LWAPI_API_NOT_INTIALIZED         : LWAPI not initialized
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND    : no LWPU GPU found
//! \retval ::LWAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::LWAPI_OK    : success, if the device was valid and we successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_OGL_NsightCommunication(__inout void  *pPayload);




//! SUPPORTED OS:  Windows Vista and higher
//!
//-----------------------------------------------------------------------------
// DirectX1x IFR API
//-----------------------------------------------------------------------------

#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) ) 

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D1x_IFR_SetUpTargetBufferToSys
//
//!   DESCRIPTION: This API allocates n buffers (up to a maximum of 6). 
//!                Additional calls to LwAPI_D3D10_IFR_SetUpTargetBufferToSys() will free the buffers that were allocated previously with the same call on the d3d device. 
//!
//! \param [in]    pDev       The device to get primary surface on. pDevice can be either ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [in]    eFormat    The format of the blit
//! \param [in]    dwNBuffers The number of buffers in ppBuffer (max 6).
//! \param [in]    ppBuffer   A pointer to an array of dwNBuffers (max 6) pointers. Virtual memory buffers will be allocated by the driver.
//!
//! \return ::LWAPI_OK if the call succeeded
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")
LWAPI_INTERFACE LwAPI_D3D1x_IFR_SetUpTargetBufferToSys(IUnknown *pDevice, LWFBC_BUFFER_FORMAT eFormat, DWORD dwNBuffers, void** ppBuffers);

#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) ) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D1x_IFR_TransferRenderTarget
//
//!   DESCRIPTION: This API copies the current rendertarget into the provided system memory buffer.
//!
//! \param [in]   pDev                      The device to get primary surface on. pDevice can be either ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [in]   pEvent                    When not NULL, will receive a handle to an event that the driver will signal upon completion of LwAPI_D3D10_IFR_TransferRenderTarget
//! \param [in]   dwBufferIndex             The index of the buffer that will receive a copy of the rendertarget. 
//!!                                        This ordinal is between 0 and the number of buffer created by LwAPI_D3D10_IFR_SetUpTargetBufferToSys.
//! \param [in]   dwTargetWidth             When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling will be done before the blit to system memory.
//! \param [in]   dwTargetHeight            When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling will be done before the blit to system memory.
//! \param [in]   dwRenderTargetIndex       The index of the rendertarget that will be copied.
//! \param [in]   dwRenderTargetArraySlice  The array slice we want copied
//!
//! \return ::LWAPI_OK if the call succeeded
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")
LWAPI_INTERFACE LwAPI_D3D1x_IFR_TransferRenderTarget(IUnknown *pDevice, HANDLE * pEvent, DWORD dwBufferIndex, 
                                                        DWORD dwTargetWidth, DWORD dwTargetHeight,
                                                        DWORD dwRenderTargetIndex, DWORD dwRenderTargetArraySlice);

#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) ) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D1x_IFR_CheckDeviceSupport
//
//!   DESCRIPTION: This API requests the driver to check if LwIFR context can be created. 
//!
//!
//! \since Release: 304
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   pDevice      The device to get primary surface on
//! \param [out]  pdwSupported The LwIFR support status on this device
//!
//! \return ::LWAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

typedef struct
{
    DWORD bSupported :1;
    DWORD bLwEncLogoNeeded : 1;
    DWORD bReservedBits : 30;
    DWORD dwPrivateDataSize;
    void* pPrivateData;
    IUnknown* pDevice;
    DWORD dwVersion;
    DWORD dwReserved[29];
    void* pReserved[30];
} LwIFRCheckDeviceSupportParams;

LWAPI_INTERFACE LwAPI_D3D1x_IFR_CheckDeviceSupport(LwIFRCheckDeviceSupportParams *pParams);

#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) ) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D1x_IFR_SetUpTargetBufferToLW12BLVideoSurface
//
//!   DESCRIPTION: This API requests the driver to allocate n buffers (up to a maximum of 3). 
//!                Additional calls to LwAPI_DxD1x_IFR_SetUpTargetBufferToLW12BLVideoSurface() will free the buffers that were allocated previously with the same call on the d3d device. 
//!
//!
//! \since Release: 304
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   pDevice    The device to get primary surface on
//! \param [in]   dwNBuffers The number of buffers in ppBuffer (max 3).
//! \param [in]   aHandles   A pointer to an array of videolibrary surfaces.
//!
//! \return ::LWAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")

LWAPI_INTERFACE LwAPI_D3D1x_IFR_SetUpTargetBufferToLW12BLVideoSurface(IUnknown *pDevice, DWORD dwNBuffers, HANDLE * aHandles, DWORD dwTargetWidth, DWORD dwTargetHeight);

#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) ) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D1x_IFR_TransferRenderTargetToLW12BLVideoSurface
//
//!  DESCRIPTION: This API copies the current rendertarget into the provided system memory buffer.
//!
//! \since Release: 304
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDevice      The device to get primary surface on
//! \param [in]      dwBufferIndex  The index of the buffer that will receive a copy of the rendertarget. 
//!                                 This ordinal is between 0 and the number of buffer created by LwAPI_D3D1x_IFR_SetUpTargetBufferToLW12BLVideoSurface().
//! \param [in]      dwTargetWidth  When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//! \param [in]      dwTargetHeight When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//! \param [in]   dwRenderTargetIndex       The index of the rendertarget that will be copied.
//! \param [in]   dwRenderTargetArraySlice  The array slice we want copied
//!
//! \return ::LWAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")
LWAPI_INTERFACE LwAPI_D3D1x_IFR_TransferRenderTargetToLW12BLVideoSurface(IUnknown *pDevice, DWORD dwBufferIndex, DWORD dwTargetWidth, DWORD dwTargetHeight, DWORD dwRenderTargetIndex, DWORD dwRenderTargetArraySlice);

#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )

//! SUPPORTED OS:  Windows Vista and higher
//!

#if defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))

enum LWAPI_QUAD_FILLMODE
{
    LWAPI_QUAD_FILLMODE_DISABLED = 0,
    LWAPI_QUAD_FILLMODE_BBOX = 1,
    LWAPI_QUAD_FILLMODE_FULL_VIEWPORT = 2,
};

typedef struct LwAPI_D3D11_RASTERIZER_DESC_EX : public D3D11_RASTERIZER_DESC
{
    LwU32 ForcedSampleCount;                 //<! Added DX 11.1, part of _DESC1 version of this struct.
    bool ProgrammableSamplePositionsEnable;  //<! enable Programmable Samples feature
    bool InterleavedSamplingEnable;          //<! when jitter is enabled, an app need to fill the whole arrays below, otherwise only as much entries as samples
    LwU8 SampleCount;                        //<! number of samples. In TIR N->1 it needs to match N, in non-TIR it needs to match RT sample count. Ignored if ForcePerSampleInterlock is set
    LwU8 SamplePositionsX[16];               //<! x positions in API sample order
    LwU8 SamplePositionsY[16];               //<! y positions in API sample order
    bool ConservativeRasterEnable;           //<! rasterize all pixels a primitive touches in any way instead of just those with the centroid covered. 
    LWAPI_QUAD_FILLMODE QuadFillMode;        //<! Fill a triangle outside its bounds as a screen-aligned quad, matching the tri's bounding-box or filling the full viewport.
    bool PostZCoverageEnable;                //<! Enable pixel-shader input SV_COVERAGE to account for z-test in early-z mode.
    bool CoverageToColorEnable;              //<! Enable output of coverage to a color render-target.
    LwU8 CoverageToColorRTIndex;             //<! Index of RT for coverage-to-color.
    LwU32 reserved[16];                      //<! reserved for expansion, set to zero.
} LwAPI_D3D11_RASTERIZER_DESC_EX;
 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_CreateRasterizerState
//
//! \code
//!   DESCRIPTION: This function is an extension of ID3D11Device::CreateRasterizerState with additional raster states
//!
//!         \param [in]        pDevice             current d3d device
//!         \param [in]        pRasterizerDesc     Rasterizer state description of type LWAPI_D3D11_RASTERIZER_DESC_EX
//!         \param [out]       ppRasterizerState   ID3D11RasterizerState 
//!
//!
//! \return ::LWAPI_OK     if the call succeeds.
//! \endcode
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_CreateRasterizerState(__in ID3D11Device *pDevice,
                                                  __in const LwAPI_D3D11_RASTERIZER_DESC_EX *pRasterizerDesc,
                                                  __out ID3D11RasterizerState **ppRasterizerState);

#endif //defined(__cplusplus) && defined(__d3d11_h__)


//! SUPPORTED OS:  Windows Vista and higher
//!

#if defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_CreateMultiSampledUAV
//
//! \code
//!   DESCRIPTION: This function is an extension of ID3D11Device::CreateUnorderedAccessView that allows creating UAV of multisampled Texture2D resources
//!                The Texture2D resource doesn't need to have D3D11_BIND_UNORDERED_ACCESS bind flag as d3d11 runtime won't allow creating multisampled
//!                Texture2D resource with D3D11_BIND_UNORDERED_ACCESS bind flag. Use LwLoadFromMultiSampledUav() and LwStoreToMultiSampledUav() Lwpu 
//!                HLSL extension functions in HLSL shader code to access UAVs created using this call.
//!
//!         \param [in]        pDevice             current d3d device
//!         \param [in]        pTex                The MultiSampled Texture2D resource for which the UAV is to be created
//!         \param [in]        pDesc               The UAV descriptor. pDesc->ViewDimension must be D3D11_UAV_DIMENSION_TEXTURE2D

//!
//!
//! \return ::LWAPI_OK     if the call succeeds.
//! \endcode
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_CreateMultiSampledUAV(__in ID3D11Device *pDevice,
                                                  __in ID3D11Texture2D *pTex,
                                                  __in const D3D11_UNORDERED_ACCESS_VIEW_DESC *pDesc,
                                                  __out ID3D11UnorderedAccessView **ppUAV);

#endif //defined(__cplusplus) && defined(__d3d11_h__)



//! SUPPORTED OS:  Windows Vista and higher
//!

#if defined (__cplusplus) && defined(__d3d11_h__) && (!defined(CINTERFACE) ) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_CreateGeometryShaderEx
//
//! \fn LwAPI_D3D11_CreateGeometryShaderEx
//!                                                
//!   DESCRIPTION: This function allows us to extend the creation of geometry shaders with extra bits
//!                of functionality.
//!                
//!                The first parameters are identical to ID3D11Device::CreateGeometryShader() 
//!                so please refer to its documentation for their usage.
//!                
//!                The new parameter is UseViewportMask which is to tell the driver to create a shader
//!                that outputs a viewport mask instead when a viewport index is indicated.
//!                Outputting a viewport mask allows a single primitive to land on many different viewports
//!                as specified by the bits set in the mask, rather than to rely on a single number that tells it
//!                which unique viewport it would be drawn on.
//!                This can be used for example in conjunction with the setting of coordinates swizzling (see XXX_LWAPI function)
//!                to generates multiple adjacent views of the same primitive in a more efficient fashion 
//!                (outputting the primitive only once).
//!                ! Warning these functions are NOT free-threaded create compatible. 
//!                So Don't call them from a different thread than the one calling immediate device setstate functions
//!                And make sure no other thread is calling into another (even unrelated) free threaded function !
//!                
//! \since Release: 
//!                
//!   \param [in]  pDevice               The device pointer
//!   \param [in]  pShaderBytecode       A pointer to the compiled shader.
//!   \param [in]  BytecodeLength        Size of the compiled geometry shader.
//!   \param [in]  pClassLinkage         A pointer to a class linkage interface. Can be NULL.
//!   \param [in]  UseViewportMask       Tell the driver to create a shader that outputs the viewport mask in lieu of the viewport index. See above description.
//!   \param [in]  OffsetRtIndexByVpIndex       The Rendertarget index is offset by the viewport index
//!   \param [in]  ForceFastGS           DEBUG/Internal testing only.
//!   \param [in]  UseViewportOrder      DEBUG/Internal testing only.
//!   \param [in]  UseAttributeSkipMask  DEBUG/Internal testing only.
//!   \param [out] ppGeometryShader      Address of a pointer to a ID3D11GeometryShader interface. 
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//
///////////////////////////////////////////////////////////////////////////////

LWAPI_INTERFACE LwAPI_D3D11_CreateGeometryShaderEx(__in ID3D11Device *pDevice, __in const void *pShaderBytecode, 
                                                   __in SIZE_T BytecodeLength, __in_opt ID3D11ClassLinkage *pClassLinkage, 
                                                   __in BOOL UseViewportMask, __in BOOL OffsetRtIndexByVpIndex, 
                                                   __in BOOL ForceFastGS, __in BOOL UseViewportOrder, 
                                                   __in BOOL UseAttributeSkipMask,
                                                   __out ID3D11GeometryShader **ppGeometryShader);

#endif //defined(__cplusplus) && defined(__d3d11_h__) && (!defined(CINTERFACE))

//! SUPPORTED OS:  Windows Vista and higher
//!

#if defined (__cplusplus) && defined(__d3d11_h__)

 typedef UINT LwAPI_D3D11_SWIZZLE_MODE;
 
typedef struct LwAPI_D3D11_VIEWPORT_EX : public D3D11_VIEWPORT
{
    bool bUseSubpixelBits;  // Define the number of bits used for sub-pixel snap. 8 is standard. 
                            // The rest is integer pixel coordinate. Leaving fewer bits than necessary to represent 
                            // entire range of int(width) or int(height) produces in undefined results.
    UINT NumSubpixelBits;   
    bool bUseCoordinateSwizzle;
    LwAPI_D3D11_SWIZZLE_MODE CoordinateSwizzle;       // Defines how clip-space (x,y,z,w) is swizzled and negated to produce output (x,y,z,w)
}LwAPI_D3D11_VIEWPORT_EX;
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_RSSetViewports
//
//! \code
//!   DESCRIPTION: This function is an extension of ID3D11DeviceContext::RSSetViewports with additional per viewport properties
//!
//!         \param [in]        pDevice             current d3d device
//!         \param [in]        NumViewports        Number of viewports to bind
//!         \param [in]        pViewports          Viewport declaration of type LWAPI_D3D11_VIEWPORT_EX 
//!
//!
//! \return ::LWAPI_OK     if the call succeeds.
//! \endcode
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_RSSetViewports(__in ID3D11Device *pDevice,
                                           __in UINT NumViewports,
                                           __in const LwAPI_D3D11_VIEWPORT_EX *pViewports);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

//! SUPPORTED OS:  Windows Vista and higher
//!

#if defined (__cplusplus) && defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D11_DecompressView
//
//! \code
//!   DESCRIPTION: This function is used to decompress a surface using the lwrrently bound programmable sample positions.
//!
//!                This is needed:
//!                  - When writing to a surface in a region previously rendered by different sample positions and no clear was done.
//!                  - When reading a surface in a shader that was rendered using non-standard sample positions.
//!                  - When copying from a surface that was rendered using non-standard sample positions.
//!
//!         \param [in]        pDevice             Current d3d11 device
//!         \param [in]        pDeviceContext      Current d3d11 device context
//!         \param [in]        pView               Current view to decompress
//!
//!
//! \return ::LWAPI_OK     if the call succeeds.
//! \endcode
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D11_DecompressView(__in ID3D11Device* pDevice, __in ID3D11DeviceContext *pDeviceContext, __in ID3D11View* pView);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined(_D3D9_H_) && defined(__cplusplus)

typedef struct _LW_FBC_CAPTURE_PARAMS_V1
{
    LwU32                     version;          //!<Version of structure. Must always be first member
    LwU32                     dwBufferIndex;    //!<Index of the target.
    LwU32                     dwFlags;          //!<Capture flags.
    LwU32                     dwGrabMode;       //!<GrabMode for colwerting current res to supplied resolution.
    LwU32                     dwTargetWidth;    //!<Supplied resolution Width.
    LwU32                     dwTargetHeight;   //!<Supplied resolution Height.
    LwU32                     dwBlend;          //!<Prefilter Blend Ratio.
    LwU32                     dwStartX;         //!<Supplied scaled resolution Widht.
    LwU32                     dwStartY;         //!<Supplied scaled resolution Height.
} LW_FBC_CAPTURE_PARAMS_V1;

#define LW_FBC_CAPTURE_PARAMS_VER_1 MAKE_LWAPI_VERSION(LW_FBC_CAPTURE_PARAMS_V1, 1)

typedef struct _LW_FBC_CAPTURE_PARAMS_V2
{
    LwU32                     version;          //!<Version of structure. Must always be first member
    LwU32                     dwBufferIndex;    //!<Index of the target.
    LwU32                     dwFlags;          //!<Capture flags.
    LwU32                     dwGrabMode;       //!<GrabMode for colwerting current res to supplied resolution.
    LwU32                     dwTargetWidth;    //!<Supplied resolution Width.
    LwU32                     dwTargetHeight;   //!<Supplied resolution Height.
    LwU32                     dwBlend;          //!<Prefilter Blend Ratio.
    LwU32                     dwStartX;         //!<Supplied scaled resolution Widht.
    LwU32                     dwStartY;         //!<Supplied scaled resolution Height.
    LwU32                     isSrcFromSysMem;  //!<Whether the client supplies the source surface from system memory
    LwU64                     qwSysMemPointer;  //!<Pointer to the client supplied source surface in system memory
    LwU32                     dwSourceWidth;    //!<Supplied source surface width
    LwU32                     dwSourceHeight;   //!<Supplied source surface height
} LW_FBC_CAPTURE_PARAMS_V2;

#define LW_FBC_CAPTURE_PARAMS_VER_2 MAKE_LWAPI_VERSION(LW_FBC_CAPTURE_PARAMS_V2, 2)

typedef struct _LW_FBC_CAPTURE_PARAMS_V3
{
    LwU32                     version;          //!<Version of structure. Must always be first member
    LwU32                     dwBufferIndex;    //!<Index of the target.
    LwU32                     dwFlags;          //!<Capture flags.
    LwU32                     dwGrabMode;       //!<GrabMode for colwerting current res to supplied resolution.
    LwU32                     dwTargetWidth;    //!<Supplied resolution Width.
    LwU32                     dwTargetHeight;   //!<Supplied resolution Height.
    LwU32                     dwBlend;          //!<Prefilter Blend Ratio.
    LwU32                     dwStartX;         //!<Supplied scaled resolution Widht.
    LwU32                     dwStartY;         //!<Supplied scaled resolution Height.
    LwU32                     isSrcFromSysMem;  //!<Whether the client supplies the source surface from system memory
    LwU64                     qwSysMemPointer;  //!<Pointer to the client supplied source surface in system memory
    LwU32                     dwSourceWidth;    //!<Supplied source surface width
    LwU32                     dwSourceHeight;   //!<Supplied source surface height
    LwU32                     bIsYUV444;        //!<Captured image should be colwerted YUV444 for encode
} LW_FBC_CAPTURE_PARAMS_V3;

#define LW_FBC_CAPTURE_PARAMS_VER_3 MAKE_LWAPI_VERSION(LW_FBC_CAPTURE_PARAMS_V3, 3)

#define LW_FBC_CAPTURE_PARAMS_VER   LW_FBC_CAPTURE_PARAMS_VER_3
typedef LW_FBC_CAPTURE_PARAMS_V3    LW_FBC_CAPTURE_PARAMS;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_LWFBC_Prefilter_CaptureBufferToLW12BLVideoSurface
//!
//!  DESCRIPTION: This API applies prefilter on captured backBuffer and blits into LW12 Surface
//!
//! \param [in]      pDev                     The device to get primary surface on
//! \param [out]     pDataGrabInfo            The Grabbed Frame information structure
//! \param [in]      pLwfbcCaptureParams      The Parameters of Capturing Frame 
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_LWFBC_Prefilter_CaptureBufferToLW12BLVideoSurface(__in IDirect3DDevice9 *pDev, __in LW_FBC_CAPTURE_PARAMS *pLwfbcCaptureParams, __out void * pDataGrabInfo);

#endif //defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_LWFBC_SysmemToLW12BLVideoSurface
//!
//!  DESCRIPTION: This API takes a frame buffer in system memory and blits it into LW12 Surface
//!
//! \param [in]      pDev                     The device to get frame surface on
//! \param [out]     pDataGrabInfo            The Grabbed Frame information structure
//! \param [in]      pLwfbcCaptureParams      The Parameters of Capturing Frame 
//!
//! \return  This API can return any of the error codes enumerated in
//!          #LwAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D9_LWFBC_SysmemToLW12BLVideoSurface(__in IDirect3DDevice9 *pDev, __in LW_FBC_CAPTURE_PARAMS *pLwfbcCaptureParams, __out void * pDataGrabInfo);

#endif //defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//!
//! FUNCTION NAME: LwAPI_D3D_GetVRRState
//!   DESCRIPTION: This API get the VRR state for the given device context.
//!
//! \param [in]    pDeviceOrContext    The D3D9, D3D10, D3D11 device, or D3D11 device context
//! \param [in]    LWDX_ObjectHandle   The handle of primary surface
//! \param [out]   pisVrrEnabled       true if VRR is enabled
//! \param [out]   pisVrrRequested     true if VRR is requested
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D_GetVRRState(__in IUnknown *pDeviceOrContext, __in LWDX_ObjectHandle primarySurface, __out_opt BOOL *pisVrrEnabled, __out_opt BOOL *pisVrrRequested);
#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)


#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//!
//! FUNCTION NAME: LwAPI_D3D_SetVRRState
//!   DESCRIPTION: This API enable/disable VRR state for the given device context.
//!
//! \param [in]    pDeviceOrContext    The D3D9, D3D10, D3D11 device, or D3D11 device context
//! \param [in]    LWDX_ObjectHandle   The handle of primary surface
//! \param [in]    enable              true to enable VRR and false to disable VRR
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D_SetVRRState(__in IUnknown *pDeviceOrContext, __in LWDX_ObjectHandle primarySurface, __in BOOL enable);
#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

//! \ingroup dx

#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#define LW_FLIP_PATTERNS_BUFFER_SIZE 7
typedef struct _LW_FLIP_PATTERN_DATA_V1
{
    LwU32   version;                    //!< Structure version
    LwU8    isLastCall;                 //!< [IN] set to stop data collection for this device
    LwU32   lastQueriedFlip;            //!< [IN/OUT] [IN]: a counter of last previously queried flip, [OUT]: a counter of last returned flip.
    LwU64   lwrrentTimestamp;           //!< [OUT]timestamp of the call
    LwU64   timestampFrequency;         //!< [OUT]frequency factor
    LwU64   flipTimestamps[LW_FLIP_PATTERNS_BUFFER_SIZE]; //!<  timestamps of flips
    LwU32   numFlipsReturned;              //!< [OUT]how many flip entries were filled
    LwU8    hasMoreData;                   //!< [OUT]are there more data pending
} LW_FLIP_PATTERN_DATA_V1;

typedef LW_FLIP_PATTERN_DATA_V1      LW_FLIP_PATTERN_DATA;
#define LW_FLIP_PATTERN_DATA_VER1    MAKE_LWAPI_VERSION(LW_FLIP_PATTERN_DATA_V1, 1)
#define LW_FLIP_PATTERN_DATA_VER     LW_FLIP_PATTERN_DATA_VER1

///////////////////////////////////////////////////////////////////////////////
//!
//! FUNCTION NAME: LwAPI_D3D_GetFlipPattern
//!   DESCRIPTION: This API returns flip pattern with timestamp.
//!
//! \param [in]    pDeviceOrContext    The D3D9, D3D10, D3D11 device, or D3D11 device context
//! \param [in]    LWDX_ObjectHandle   The handle of primary surface
//! \param [out]   pFlipData           pointer to struct LW_FLIP_PATTERN_DATA.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D_GetFlipPattern(__in IUnknown *pDeviceOrContext, __in LWDX_ObjectHandle primarySurface, __inout LW_FLIP_PATTERN_DATA *pFlipData);
#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_IFR_SetUpTargetBufferToSys_Pvt
//
//!   DESCRIPTION: This API requests the driver to allocate n buffers (up to a maximum of 3). 
//!                Additional calls to LwAPI_D3D9_IFR_SetUpTargetBufferToSys() will free the buffers that were allocated previously with the same call on the d3d device. 
//!
//! \since Release: 331
//!
//! \param [in]   pDev       The device to get primary surface on
//! \param [in]   eFormat    The format of the blit
//! \param [in]   dwNBuffers The number of buffers in ppBuffer (max 6).
//! \param [in]   ppBuffer   A pointer to an array of dwNBuffers (max 6) pointers. Virtual memory buffers will be allocated by the driver.
//!
//! \return ::LWAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
LWAPI_INTERFACE LwAPI_D3D9_IFR_SetUpTargetBufferToSys_Pvt(IDirect3DDevice9 *pDev, LWFBC_BUFFER_FORMAT eFormat, DWORD dwNBuffers, unsigned char ** ppBuffer);
#endif //#if defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_IFR_TransferRenderTarget_Pvt
//
//!  DESCRIPTION: This API copies the current rendertarget into the provided system memory buffer.
//!
//! \since Release: 331
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device to get primary surface on
//! \param [in]      pEvent    When not NULL, will receive a handle to an event that the driver will signal 
//!                            upon completion of LwAPI_D3D9_IFR_TransferRenderTarget().
//! \param [in]      dwBufferIndex  The index of the buffer that will receive a copy of the rendertarget. 
//!                                 This ordinal is between 0 and the number of buffer created by LwAPI_D3D9_IFR_SetUpTargetBufferToSys().
//! \param [in]      dwTargetWidth  When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//! \param [in]      dwTargetHeight When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//!
//! \return ::LWAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_IFR_TransferRenderTarget_Pvt(IDirect3DDevice9 *pDev, HANDLE * pEvent, DWORD dwBufferIndex, DWORD dwTargetWidth, DWORD dwTargetHeight);

#endif //defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_IFR_SetUpTargetBufferToLW12BLVideoSurface_Pvt
//
//!   DESCRIPTION: This API requests the driver to allocate n buffers (up to a maximum of 3). 
//!                Additional calls to LwAPI_D3D9_IFR_SetUpTargetBufferToSys() will free the buffers that were allocated previously with the same call on the d3d device. 
//!
//!
//! \since Release: 331
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   pDev       The device to get primary surface on
//! \param [in]   dwNBuffers The number of buffers in ppBuffer (max 3).
//! \param [in]   aHandles   A pointer to an array of videolibrary surfaces.
//!
//! \return ::LWAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

LWAPI_INTERFACE LwAPI_D3D9_IFR_SetUpTargetBufferToLW12BLVideoSurface_Pvt(IDirect3DDevice9 *pDev, DWORD dwNBuffers, HANDLE * aHandles, DWORD dwTargetWidth, DWORD dwTargetHeight, BOOL bUseYUV444  = 0);

#endif //defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_IFR_TransferRenderTargetToLW12BLVideoSurface_Pvt
//
//!  DESCRIPTION: This API copies the current rendertarget into the provided system memory buffer.
//!
//! \since Release: 331
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device to get primary surface on
//! \param [in]      dwBufferIndex  The index of the buffer that will receive a copy of the rendertarget. 
//!                                 This ordinal is between 0 and the number of buffer created by LwAPI_D3D9_IFR_SetUpTargetBufferToLW12BLVideoSurface().
//! \param [in]      dwTargetWidth  When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//! \param [in]      dwTargetHeight When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//!
//! \return ::LWAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_IFR_TransferRenderTargetToLW12BLVideoSurface_Pvt(IDirect3DDevice9 *pDev, DWORD dwBufferIndex, DWORD dwTargetWidth, DWORD dwTargetHeight, BOOL bUseYUV444 = 0);

#endif // defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_IFR_CreateSharedSurface_Pvt
//
//!
//! \since Release: 331
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device that creates/owns the shared surface
//! \param [in]      dwWidth  
//! \param [in]      dwHeight 
//!
//! \return ::LWAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

typedef void * IFRSharedSurfaceHandle;

LWAPI_INTERFACE LwAPI_D3D9_IFR_CreateSharedSurface_Pvt(IDirect3DDevice9 *pDev, DWORD dwWidth, DWORD dwHeight, IFRSharedSurfaceHandle * phLwIFRSharedSurface);

#endif // defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_IFR_DestroySharedSurface_Pvt
//
//!
//! \since Release: 331
//! 
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device that created the shared surface
//!
//! \return ::LWAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////


LWAPI_INTERFACE LwAPI_D3D9_IFR_DestroySharedSurface_Pvt(IDirect3DDevice9 *pDev, IFRSharedSurfaceHandle hLwIFRSharedSurface);

#endif // defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_IFR_CopyToSharedSurface_Pvt
//
//!
//! \since Release: 331
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device that will do the blit
//!
//! \return ::LWAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////


LWAPI_INTERFACE LwAPI_D3D9_IFR_CopyToSharedSurface_Pvt(IDirect3DDevice9 *pDev, IFRSharedSurfaceHandle hLwIFRSharedSurface, IDirect3DSurface9 * pSurface);

#endif // defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_IFR_CopyFromSharedSurface_Pvt
//
//!
//! \since Release: 331
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device that will do the blit
//!
//! \return ::LWAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////


LWAPI_INTERFACE LwAPI_D3D9_IFR_CopyFromSharedSurface_Pvt(IDirect3DDevice9 *pDev, IFRSharedSurfaceHandle hLwIFRSharedSurface, IDirect3DSurface9 * pSurface);

#endif // defined(_D3D9_H_) && defined(__cplusplus)


//! SUPPORTED OS:  Windows Vista and higher
//!
//-----------------------------------------------------------------------------
// DirectX1x IFR API
//-----------------------------------------------------------------------------

#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) ) 

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D1x_IFR_SetUpTargetBufferToSys_Pvt
//
//!   DESCRIPTION: This API allocates n buffers (up to a maximum of 6). 
//!                Additional calls to LwAPI_D3D10_IFR_SetUpTargetBufferToSys() will free the buffers that were allocated previously with the same call on the d3d device. 
//!
//! \since Release: 331
//!
//! \param [in]    pDev       The device to get primary surface on. pDevice can be either ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [in]    eFormat    The format of the blit
//! \param [in]    dwNBuffers The number of buffers in ppBuffer (max 6).
//! \param [in]    ppBuffer   A pointer to an array of dwNBuffers (max 6) pointers. Virtual memory buffers will be allocated by the driver.
//!
//! \return ::LWAPI_OK if the call succeeded
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D1x_IFR_SetUpTargetBufferToSys_Pvt(IUnknown *pDevice, LWFBC_BUFFER_FORMAT eFormat, DWORD dwNBuffers, void** ppBuffers);

#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) ) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D1x_IFR_TransferRenderTarget_Pvt
//
//!   DESCRIPTION: This API copies the current rendertarget into the provided system memory buffer.
//! \since Release: 331
//!
//! \param [in]   pDev                      The device to get primary surface on. pDevice can be either ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [in]   pEvent                    When not NULL, will receive a handle to an event that the driver will signal upon completion of LwAPI_D3D10_IFR_TransferRenderTarget
//! \param [in]   dwBufferIndex             The index of the buffer that will receive a copy of the rendertarget. 
//!!                                        This ordinal is between 0 and the number of buffer created by LwAPI_D3D10_IFR_SetUpTargetBufferToSys.
//! \param [in]   dwTargetWidth             When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling will be done before the blit to system memory.
//! \param [in]   dwTargetHeight            When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling will be done before the blit to system memory.
//! \param [in]   dwRenderTargetIndex       The index of the rendertarget that will be copied.
//! \param [in]   dwRenderTargetArraySlice  The array slice we want copied
//!
//! \return ::LWAPI_OK if the call succeeded
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D1x_IFR_TransferRenderTarget_Pvt(IUnknown *pDevice, HANDLE * pEvent, DWORD dwBufferIndex, 
                                                        DWORD dwTargetWidth, DWORD dwTargetHeight,
                                                        DWORD dwRenderTargetIndex, DWORD dwRenderTargetArraySlice);

#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )


//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) ) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D1x_IFR_SetUpTargetBufferToLW12BLVideoSurface_Pvt
//
//!   DESCRIPTION: This API requests the driver to allocate n buffers (up to a maximum of 3). 
//!                Additional calls to LwAPI_DxD1x_IFR_SetUpTargetBufferToLW12BLVideoSurface() will free the buffers that were allocated previously with the same call on the d3d device. 
//!
//!
//! \since Release: 331
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   pDevice    The device to get primary surface on
//! \param [in]   dwNBuffers The number of buffers in ppBuffer (max 3).
//! \param [in]   aHandles   A pointer to an array of videolibrary surfaces.
//!
//! \return ::LWAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

LWAPI_INTERFACE LwAPI_D3D1x_IFR_SetUpTargetBufferToLW12BLVideoSurface_Pvt(IUnknown *pDevice, DWORD dwNBuffers, HANDLE * aHandles, DWORD dwTargetWidth, DWORD dwTargetHeight);

#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) ) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D1x_IFR_TransferRenderTargetToLW12BLVideoSurface_Pvt
//
//!  DESCRIPTION: This API copies the current rendertarget into the provided system memory buffer.
//!
//! \since Release: 331
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDevice      The device to get primary surface on
//! \param [in]      dwBufferIndex  The index of the buffer that will receive a copy of the rendertarget. 
//!                                 This ordinal is between 0 and the number of buffer created by LwAPI_D3D1x_IFR_SetUpTargetBufferToLW12BLVideoSurface().
//! \param [in]      dwTargetWidth  When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//! \param [in]      dwTargetHeight When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//! \param [in]   dwRenderTargetIndex       The index of the rendertarget that will be copied.
//! \param [in]   dwRenderTargetArraySlice  The array slice we want copied
//!
//! \return ::LWAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D1x_IFR_TransferRenderTargetToLW12BLVideoSurface_Pvt(IUnknown *pDevice, DWORD dwBufferIndex, DWORD dwTargetWidth, DWORD dwTargetHeight, DWORD dwRenderTargetIndex, DWORD dwRenderTargetArraySlice);

#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) ) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D1x_DisableShaderDiskCache
//
//! DESCRIPTION: Disables driver managed caching of shader compilations to disk
//!
//! \param [in]    pDevice               Device to disabled the shader disk cache on
//!
//!
//! \retval ::LWAPI_OK                   Shader disk cache was disabled
//! \retval ::LWAPI_ERROR                The operation failed.
//! \retval ::LWAPI_ILWALID_ARGUMENT     Argument passed in is invalid.
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D1x_DisableShaderDiskCache(IUnknown *pDevice);

#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )

/////////////////////////////////////////////////////////////////////////
// Video Input Output (VIO) API
/////////////////////////////////////////////////////////////////////////



//! \ingroup vidio
//! Unique identifier for VIO owner (process identifier or LWVIOOWNERID_NONE)
typedef LwU32   LWVIOOWNERID;                               


//! \addtogroup vidio
//! @{


#define LWVIOOWNERID_NONE                   0      //!< Unregistered ownerId        


//! Owner type for device
typedef enum _LWVIOOWNERTYPE                               
{
    LWVIOOWNERTYPE_NONE                             ,       //!<  No owner for the device
    LWVIOOWNERTYPE_APPLICATION                      ,       //!<  Application owns the device
    LWVIOOWNERTYPE_DESKTOP                          ,       //!<  Desktop transparent mode owns the device (not applicable for video input)
}LWVIOOWNERTYPE;

// Access rights for LwAPI_VIO_Open()

//! Read access             (not applicable for video output)
#define LWVIO_O_READ                        0x00000000      

//! Write exclusive access  (not applicable for video input)
#define LWVIO_O_WRITE_EXCLUSIVE             0x00010001      

//! 
#define LWVIO_VALID_ACCESSRIGHTS            (LWVIO_O_READ              | \
                                             LWVIO_O_WRITE_EXCLUSIVE   )

              
//! VIO_DATA.ulOwnerID high-bit is set only if device has been initialized by VIOAPI
//! examined at LwAPI_GetCapabilities|LwAPI_VIO_Open to determine if settings need to be applied from registry or POR state read
#define LWVIO_OWNERID_INITIALIZED  0x80000000

//! VIO_DATA.ulOwnerID next-bit is set only if device is lwrrently in exclusive write access mode from LwAPI_VIO_Open()
#define LWVIO_OWNERID_EXCLUSIVE    0x40000000
                                              
//! VIO_DATA.ulOwnerID lower bits are:
//!  LWGVOOWNERTYPE_xxx enumerations indicating use context
#define LWVIO_OWNERID_TYPEMASK     0x0FFFFFFF //!< mask for LWVIOOWNERTYPE_xxx


//! @}
              
//---------------------------------------------------------------------
// Enumerations
//---------------------------------------------------------------------


//! \addtogroup vidio
//! @{

//! Video signal format and resolution
typedef enum _LWVIOSIGNALFORMAT
{
    LWVIOSIGNALFORMAT_NONE,                //!< Invalid signal format 
    LWVIOSIGNALFORMAT_487I_59_94_SMPTE259_NTSC,     //!< 01  487i    59.94Hz  (SMPTE259) NTSC
    LWVIOSIGNALFORMAT_576I_50_00_SMPTE259_PAL,      //!< 02  576i    50.00Hz  (SMPTE259) PAL
    LWVIOSIGNALFORMAT_1035I_60_00_SMPTE260,         //!< 03  1035i   60.00Hz  (SMPTE260)
    LWVIOSIGNALFORMAT_1035I_59_94_SMPTE260,         //!< 04  1035i   59.94Hz  (SMPTE260)
    LWVIOSIGNALFORMAT_1080I_50_00_SMPTE295,         //!< 05  1080i   50.00Hz  (SMPTE295)
    LWVIOSIGNALFORMAT_1080I_60_00_SMPTE274,         //!< 06  1080i   60.00Hz  (SMPTE274)
    LWVIOSIGNALFORMAT_1080I_59_94_SMPTE274,         //!< 07  1080i   59.94Hz  (SMPTE274)
    LWVIOSIGNALFORMAT_1080I_50_00_SMPTE274,         //!< 08  1080i   50.00Hz  (SMPTE274)
    LWVIOSIGNALFORMAT_1080P_30_00_SMPTE274,         //!< 09  1080p   30.00Hz  (SMPTE274)
    LWVIOSIGNALFORMAT_1080P_29_97_SMPTE274,         //!< 10  1080p   29.97Hz  (SMPTE274)
    LWVIOSIGNALFORMAT_1080P_25_00_SMPTE274,         //!< 11  1080p   25.00Hz  (SMPTE274)
    LWVIOSIGNALFORMAT_1080P_24_00_SMPTE274,         //!< 12  1080p   24.00Hz  (SMPTE274)
    LWVIOSIGNALFORMAT_1080P_23_976_SMPTE274,        //!< 13  1080p   23.976Hz (SMPTE274)
    LWVIOSIGNALFORMAT_720P_60_00_SMPTE296,          //!< 14  720p    60.00Hz  (SMPTE296)
    LWVIOSIGNALFORMAT_720P_59_94_SMPTE296,          //!< 15  720p    59.94Hz  (SMPTE296)
    LWVIOSIGNALFORMAT_720P_50_00_SMPTE296,          //!< 16  720p    50.00Hz  (SMPTE296)
    LWVIOSIGNALFORMAT_1080I_48_00_SMPTE274,         //!< 17  1080I   48.00Hz  (SMPTE274)
    LWVIOSIGNALFORMAT_1080I_47_96_SMPTE274,         //!< 18  1080I   47.96Hz  (SMPTE274)
    LWVIOSIGNALFORMAT_720P_30_00_SMPTE296,          //!< 19  720p    30.00Hz  (SMPTE296)
    LWVIOSIGNALFORMAT_720P_29_97_SMPTE296,          //!< 20  720p    29.97Hz  (SMPTE296)
    LWVIOSIGNALFORMAT_720P_25_00_SMPTE296,          //!< 21  720p    25.00Hz  (SMPTE296)
    LWVIOSIGNALFORMAT_720P_24_00_SMPTE296,          //!< 22  720p    24.00Hz  (SMPTE296)
    LWVIOSIGNALFORMAT_720P_23_98_SMPTE296,          //!< 23  720p    23.98Hz  (SMPTE296)
    LWVIOSIGNALFORMAT_2048P_30_00_SMPTE372,         //!< 24  2048p   30.00Hz  (SMPTE372)
    LWVIOSIGNALFORMAT_2048P_29_97_SMPTE372,         //!< 25  2048p   29.97Hz  (SMPTE372)
    LWVIOSIGNALFORMAT_2048I_60_00_SMPTE372,         //!< 26  2048i   60.00Hz  (SMPTE372)
    LWVIOSIGNALFORMAT_2048I_59_94_SMPTE372,         //!< 27  2048i   59.94Hz  (SMPTE372)
    LWVIOSIGNALFORMAT_2048P_25_00_SMPTE372,         //!< 28  2048p   25.00Hz  (SMPTE372)
    LWVIOSIGNALFORMAT_2048I_50_00_SMPTE372,         //!< 29  2048i   50.00Hz  (SMPTE372)
    LWVIOSIGNALFORMAT_2048P_24_00_SMPTE372,         //!< 30  2048p   24.00Hz  (SMPTE372)
    LWVIOSIGNALFORMAT_2048P_23_98_SMPTE372,         //!< 31  2048p   23.98Hz  (SMPTE372)
    LWVIOSIGNALFORMAT_2048I_48_00_SMPTE372,         //!< 32  2048i   48.00Hz  (SMPTE372)
    LWVIOSIGNALFORMAT_2048I_47_96_SMPTE372,         //!< 33  2048i   47.96Hz  (SMPTE372)
    
    LWVIOSIGNALFORMAT_1080PSF_25_00_SMPTE274,       //!< 34  1080PsF 25.00Hz  (SMPTE274)
    LWVIOSIGNALFORMAT_1080PSF_29_97_SMPTE274,       //!< 35  1080PsF 29.97Hz  (SMPTE274)
    LWVIOSIGNALFORMAT_1080PSF_30_00_SMPTE274,       //!< 36  1080PsF 30.00Hz  (SMPTE274)
    LWVIOSIGNALFORMAT_1080PSF_24_00_SMPTE274,       //!< 37  1080PsF 24.00Hz  (SMPTE274)
    LWVIOSIGNALFORMAT_1080PSF_23_98_SMPTE274,       //!< 38  1080PsF 23.98Hz  (SMPTE274)

    LWVIOSIGNALFORMAT_1080P_50_00_SMPTE274_3G_LEVEL_A, //!< 39  1080P   50.00Hz  (SMPTE274) 3G Level A
    LWVIOSIGNALFORMAT_1080P_59_94_SMPTE274_3G_LEVEL_A, //!< 40  1080P   59.94Hz  (SMPTE274) 3G Level A
    LWVIOSIGNALFORMAT_1080P_60_00_SMPTE274_3G_LEVEL_A, //!< 41  1080P   60.00Hz  (SMPTE274) 3G Level A
    
    LWVIOSIGNALFORMAT_1080P_60_00_SMPTE274_3G_LEVEL_B, //!< 42  1080p   60.00Hz  (SMPTE274) 3G Level B
    LWVIOSIGNALFORMAT_1080I_60_00_SMPTE274_3G_LEVEL_B, //!< 43  1080i   60.00Hz  (SMPTE274) 3G Level B
    LWVIOSIGNALFORMAT_2048I_60_00_SMPTE372_3G_LEVEL_B, //!< 44  2048i   60.00Hz  (SMPTE372) 3G Level B
    LWVIOSIGNALFORMAT_1080P_50_00_SMPTE274_3G_LEVEL_B, //!< 45  1080p   50.00Hz  (SMPTE274) 3G Level B
    LWVIOSIGNALFORMAT_1080I_50_00_SMPTE274_3G_LEVEL_B, //!< 46  1080i   50.00Hz  (SMPTE274) 3G Level B
    LWVIOSIGNALFORMAT_2048I_50_00_SMPTE372_3G_LEVEL_B, //!< 47  2048i   50.00Hz  (SMPTE372) 3G Level B
    LWVIOSIGNALFORMAT_1080P_30_00_SMPTE274_3G_LEVEL_B, //!< 48  1080p   30.00Hz  (SMPTE274) 3G Level B
    LWVIOSIGNALFORMAT_2048P_30_00_SMPTE372_3G_LEVEL_B, //!< 49  2048p   30.00Hz  (SMPTE372) 3G Level B
    LWVIOSIGNALFORMAT_1080P_25_00_SMPTE274_3G_LEVEL_B, //!< 50  1080p   25.00Hz  (SMPTE274) 3G Level B
    LWVIOSIGNALFORMAT_2048P_25_00_SMPTE372_3G_LEVEL_B, //!< 51  2048p   25.00Hz  (SMPTE372) 3G Level B
    LWVIOSIGNALFORMAT_1080P_24_00_SMPTE274_3G_LEVEL_B, //!< 52  1080p   24.00Hz  (SMPTE274) 3G Level B
    LWVIOSIGNALFORMAT_2048P_24_00_SMPTE372_3G_LEVEL_B, //!< 53  2048p   24.00Hz  (SMPTE372) 3G Level B
    LWVIOSIGNALFORMAT_1080I_48_00_SMPTE274_3G_LEVEL_B, //!< 54  1080i   48.00Hz  (SMPTE274) 3G Level B
    LWVIOSIGNALFORMAT_2048I_48_00_SMPTE372_3G_LEVEL_B, //!< 55  2048i   48.00Hz  (SMPTE372) 3G Level B
    LWVIOSIGNALFORMAT_1080P_59_94_SMPTE274_3G_LEVEL_B, //!< 56  1080p   59.94Hz  (SMPTE274) 3G Level B
    LWVIOSIGNALFORMAT_1080I_59_94_SMPTE274_3G_LEVEL_B, //!< 57  1080i   59.94Hz  (SMPTE274) 3G Level B
    LWVIOSIGNALFORMAT_2048I_59_94_SMPTE372_3G_LEVEL_B, //!< 58  2048i   59.94Hz  (SMPTE372) 3G Level B
    LWVIOSIGNALFORMAT_1080P_29_97_SMPTE274_3G_LEVEL_B, //!< 59  1080p   29.97Hz  (SMPTE274) 3G Level B
    LWVIOSIGNALFORMAT_2048P_29_97_SMPTE372_3G_LEVEL_B, //!< 60  2048p   29.97Hz  (SMPTE372) 3G Level B
    LWVIOSIGNALFORMAT_1080P_23_98_SMPTE274_3G_LEVEL_B, //!< 61  1080p   29.98Hz  (SMPTE274) 3G Level B
    LWVIOSIGNALFORMAT_2048P_23_98_SMPTE372_3G_LEVEL_B, //!< 62  2048p   29.98Hz  (SMPTE372) 3G Level B
    LWVIOSIGNALFORMAT_1080I_47_96_SMPTE274_3G_LEVEL_B, //!< 63  1080i   47.96Hz  (SMPTE274) 3G Level B
    LWVIOSIGNALFORMAT_2048I_47_96_SMPTE372_3G_LEVEL_B, //!< 64  2048i   47.96Hz  (SMPTE372) 3G Level B
    
    LWVIOSIGNALFORMAT_END                              //!< 65  To indicate end of signal format list

}LWVIOSIGNALFORMAT;

//! SMPTE standards format
typedef enum _LWVIOVIDEOSTANDARD
{
    LWVIOVIDEOSTANDARD_SMPTE259                        ,       //!< SMPTE259
    LWVIOVIDEOSTANDARD_SMPTE260                        ,       //!< SMPTE260
    LWVIOVIDEOSTANDARD_SMPTE274                        ,       //!< SMPTE274
    LWVIOVIDEOSTANDARD_SMPTE295                        ,       //!< SMPTE295
    LWVIOVIDEOSTANDARD_SMPTE296                        ,       //!< SMPTE296
    LWVIOVIDEOSTANDARD_SMPTE372                        ,       //!< SMPTE372
}LWVIOVIDEOSTANDARD;

//! HD or SD video type
typedef enum _LWVIOVIDEOTYPE
{
    LWVIOVIDEOTYPE_SD                                  ,       //!< Standard-definition (SD)
    LWVIOVIDEOTYPE_HD                                  ,       //!< High-definition     (HD)
}LWVIOVIDEOTYPE;

//! Interlace mode
typedef enum _LWVIOINTERLACEMODE 
{
    LWVIOINTERLACEMODE_PROGRESSIVE                     ,       //!< Progressive               (p)
    LWVIOINTERLACEMODE_INTERLACE                       ,       //!< Interlace                 (i)
    LWVIOINTERLACEMODE_PSF                             ,       //!< Progressive Segment Frame (psf)
}LWVIOINTERLACEMODE;

//! Video data format
typedef enum _LWVIODATAFORMAT
{
    LWVIODATAFORMAT_UNKNOWN   = -1                     ,       //!< Invalid DataFormat
    LWVIODATAFORMAT_R8G8B8_TO_YCRCB444                 ,       //!< R8:G8:B8                => YCrCb  (4:4:4)
    LWVIODATAFORMAT_R8G8B8A8_TO_YCRCBA4444             ,       //!< R8:G8:B8:A8             => YCrCbA (4:4:4:4)
    LWVIODATAFORMAT_R8G8B8Z10_TO_YCRCBZ4444            ,       //!< R8:G8:B8:Z10            => YCrCbZ (4:4:4:4)
    LWVIODATAFORMAT_R8G8B8_TO_YCRCB422                 ,       //!< R8:G8:B8                => YCrCb  (4:2:2)
    LWVIODATAFORMAT_R8G8B8A8_TO_YCRCBA4224             ,       //!< R8:G8:B8:A8             => YCrCbA (4:2:2:4)
    LWVIODATAFORMAT_R8G8B8Z10_TO_YCRCBZ4224            ,       //!< R8:G8:B8:Z10            => YCrCbZ (4:2:2:4)
    LWVIODATAFORMAT_X8X8X8_444_PASSTHRU                ,       //!< R8:G8:B8                => RGB    (4:4:4)
    LWVIODATAFORMAT_X8X8X8A8_4444_PASSTHRU             ,       //!< R8:G8:B8:A8             => RGBA   (4:4:4:4)
    LWVIODATAFORMAT_X8X8X8Z10_4444_PASSTHRU            ,       //!< R8:G8:B8:Z10            => RGBZ   (4:4:4:4)
    LWVIODATAFORMAT_X10X10X10_444_PASSTHRU             ,       //!< Y10:CR10:CB10           => YCrCb  (4:4:4)
    LWVIODATAFORMAT_X10X8X8_444_PASSTHRU               ,       //!< Y10:CR8:CB8             => YCrCb  (4:4:4)
    LWVIODATAFORMAT_X10X8X8A10_4444_PASSTHRU           ,       //!< Y10:CR8:CB8:A10         => YCrCbA (4:4:4:4)
    LWVIODATAFORMAT_X10X8X8Z10_4444_PASSTHRU           ,       //!< Y10:CR8:CB8:Z10         => YCrCbZ (4:4:4:4)
    LWVIODATAFORMAT_DUAL_R8G8B8_TO_DUAL_YCRCB422       ,       //!< R8:G8:B8 + R8:G8:B8     => YCrCb  (4:2:2 + 4:2:2)
    LWVIODATAFORMAT_DUAL_X8X8X8_TO_DUAL_422_PASSTHRU   ,       //!< Y8:CR8:CB8 + Y8:CR8:CB8 => YCrCb  (4:2:2 + 4:2:2)
    LWVIODATAFORMAT_R10G10B10_TO_YCRCB422              ,       //!< R10:G10:B10             => YCrCb  (4:2:2)
    LWVIODATAFORMAT_R10G10B10_TO_YCRCB444              ,       //!< R10:G10:B10             => YCrCb  (4:4:4)
    LWVIODATAFORMAT_X12X12X12_444_PASSTHRU             ,       //!< X12:X12:X12             => XXX    (4:4:4)
    LWVIODATAFORMAT_X12X12X12_422_PASSTHRU             ,       //!< X12:X12:X12             => XXX    (4:2:2)
    LWVIODATAFORMAT_Y10CR10CB10_TO_YCRCB422            ,       //!< Y10:CR10:CB10           => YCrCb  (4:2:2)
    LWVIODATAFORMAT_Y8CR8CB8_TO_YCRCB422               ,       //!< Y8:CR8:CB8              => YCrCb  (4:2:2)
    LWVIODATAFORMAT_Y10CR8CB8A10_TO_YCRCBA4224         ,       //!< Y10:CR8:CB8:A10         => YCrCbA (4:2:2:4)
    LWVIODATAFORMAT_R10G10B10_TO_RGB444                ,       //!< R10:G10:B10             => RGB    (4:4:4)
    LWVIODATAFORMAT_R12G12B12_TO_YCRCB444              ,       //!< R12:G12:B12             => YCrCb  (4:4:4)
    LWVIODATAFORMAT_R12G12B12_TO_YCRCB422              ,       //!< R12:G12:B12             => YCrCb  (4:2:2)
}LWVIODATAFORMAT;

//! Video output area
typedef enum _LWVIOOUTPUTAREA
{
    LWVIOOUTPUTAREA_FULLSIZE                           ,       //!< Output to entire video resolution (full size)
    LWVIOOUTPUTAREA_SAFEACTION                         ,       //!< Output to centered 90% of video resolution (safe action)
    LWVIOOUTPUTAREA_SAFETITLE                          ,       //!< Output to centered 80% of video resolution (safe title)
}LWVIOOUTPUTAREA;

//! Synchronization source
typedef enum _LWVIOSYNCSOURCE
{
    LWVIOSYNCSOURCE_SDISYNC                            ,       //!< SDI Sync  (Digital input)
    LWVIOSYNCSOURCE_COMPSYNC                           ,       //!< COMP Sync (Composite input)
}LWVIOSYNCSOURCE;

//! Composite synchronization type
typedef enum _LWVIOCOMPSYNCTYPE
{
    LWVIOCOMPSYNCTYPE_AUTO                             ,       //!< Auto-detect
    LWVIOCOMPSYNCTYPE_BILEVEL                          ,       //!< Bi-level signal
    LWVIOCOMPSYNCTYPE_TRILEVEL                         ,       //!< Tri-level signal
}LWVIOCOMPSYNCTYPE;

//! Video input output status
typedef enum _LWVIOINPUTOUTPUTSTATUS
{
    LWINPUTOUTPUTSTATUS_OFF                            ,       //!< Not in use
    LWINPUTOUTPUTSTATUS_ERROR                          ,       //!< Error detected
    LWINPUTOUTPUTSTATUS_SDI_SD                         ,       //!< SDI (standard-definition)
    LWINPUTOUTPUTSTATUS_SDI_HD                         ,       //!< SDI (high-definition)
}LWVIOINPUTOUTPUTSTATUS;

//! Synchronization input status
typedef enum _LWVIOSYNCSTATUS
{
    LWVIOSYNCSTATUS_OFF                                ,       //!< Sync not detected
    LWVIOSYNCSTATUS_ERROR                              ,       //!< Error detected
    LWVIOSYNCSTATUS_SYNCLOSS                           ,       //!< Genlock in use, format mismatch with output
    LWVIOSYNCSTATUS_COMPOSITE                          ,       //!< Composite sync
    LWVIOSYNCSTATUS_SDI_SD                             ,       //!< SDI sync (standard-definition)
    LWVIOSYNCSTATUS_SDI_HD                             ,       //!< SDI sync (high-definition)
}LWVIOSYNCSTATUS;

//! Video Capture Status
typedef enum _LWVIOCAPTURESTATUS
{
    LWVIOSTATUS_STOPPED                                ,       //!< Sync not detected
    LWVIOSTATUS_RUNNING                                ,       //!< Error detected
    LWVIOSTATUS_ERROR                                  ,       //!< Genlock in use, format mismatch with output
}LWVIOCAPTURESTATUS;

//! Video Capture Status
typedef enum _LWVIOSTATUSTYPE
{
    LWVIOSTATUSTYPE_IN                                 ,       //!< Input Status
    LWVIOSTATUSTYPE_OUT                                ,       //!< Output Status
}LWVIOSTATUSTYPE;


//! Assumption, maximum 4 SDI input and 4 SDI output cards supported on a system
#define LWAPI_MAX_VIO_DEVICES                 8   

//! 4 physical jacks supported on each SDI input card.
#define LWAPI_MAX_VIO_JACKS                   4   


//! Each physical jack an on SDI input card can have
//! two "channels" in the case of "3G" VideoFormats, as specified
//! by SMPTE 425; for non-3G VideoFormats, only the first channel within
//! a physical jack is valid.
#define LWAPI_MAX_VIO_CHANNELS_PER_JACK       2   

//! 4 Streams, 1 per physical jack
#define LWAPI_MAX_VIO_STREAMS                 4   

#define LWAPI_MIN_VIO_STREAMS                 1   

//! SDI input supports a max of 2 links per stream
#define LWAPI_MAX_VIO_LINKS_PER_STREAM        2   


#define LWAPI_MAX_FRAMELOCK_MAPPING_MODES     20

//! Min number of capture images 
#define LWAPI_GVI_MIN_RAW_CAPTURE_IMAGES      1   

//! Max number of capture images        
#define LWAPI_GVI_MAX_RAW_CAPTURE_IMAGES      32  

//! Default number of capture images
#define LWAPI_GVI_DEFAULT_RAW_CAPTURE_IMAGES  5   



// Data Signal notification events. These need a event handler in RM.
// Register/Unregister and PopEvent LWAPI's are already available.

//! Device configuration
typedef enum _LWVIOCONFIGTYPE
{
    LWVIOCONFIGTYPE_IN                                 ,       //!< Input Status
    LWVIOCONFIGTYPE_OUT                                ,       //!< Output Status
}LWVIOCONFIGTYPE;

typedef enum _LWVIOCOLORSPACE
{
    LWVIOCOLORSPACE_UNKNOWN,
    LWVIOCOLORSPACE_YCBCR,
    LWVIOCOLORSPACE_YCBCRA,
    LWVIOCOLORSPACE_YCBCRD,
    LWVIOCOLORSPACE_GBR,
    LWVIOCOLORSPACE_GBRA,
    LWVIOCOLORSPACE_GBRD,
} LWVIOCOLORSPACE;

//! Component sampling
typedef enum _LWVIOCOMPONENTSAMPLING
{
    LWVIOCOMPONENTSAMPLING_UNKNOWN,
    LWVIOCOMPONENTSAMPLING_4444,
    LWVIOCOMPONENTSAMPLING_4224,
    LWVIOCOMPONENTSAMPLING_444,
    LWVIOCOMPONENTSAMPLING_422
} LWVIOCOMPONENTSAMPLING;

typedef enum _LWVIOBITSPERCOMPONENT
{
    LWVIOBITSPERCOMPONENT_UNKNOWN,
    LWVIOBITSPERCOMPONENT_8,
    LWVIOBITSPERCOMPONENT_10,
    LWVIOBITSPERCOMPONENT_12,
} LWVIOBITSPERCOMPONENT;

typedef enum _LWVIOLINKID 
{
    LWVIOLINKID_UNKNOWN,
    LWVIOLINKID_A,
    LWVIOLINKID_B,
    LWVIOLINKID_C,
    LWVIOLINKID_D
} LWVIOLINKID;


typedef enum _LWVIOANCPARITYCOMPUTATION
{
    LWVIOANCPARITYCOMPUTATION_AUTO,
    LWVIOANCPARITYCOMPUTATION_ON,
    LWVIOANCPARITYCOMPUTATION_OFF
} LWVIOANCPARITYCOMPUTATION;



//! @}


//---------------------------------------------------------------------
// Structures
//---------------------------------------------------------------------

//! \addtogroup vidio
//! @{


//! Supports Serial Digital Interface (SDI) output
#define LWVIOCAPS_VIDOUT_SDI                0x00000001      

//! Supports Internal timing source
#define LWVIOCAPS_SYNC_INTERNAL             0x00000100      

//! Supports Genlock timing source
#define LWVIOCAPS_SYNC_GENLOCK              0x00000200      

//! Supports Serial Digital Interface (SDI) synchronization input
#define LWVIOCAPS_SYNCSRC_SDI               0x00001000      

//! Supports Composite synchronization input
#define LWVIOCAPS_SYNCSRC_COMP              0x00002000      

//! Supports Desktop transparent mode
#define LWVIOCAPS_OUTPUTMODE_DESKTOP        0x00010000      

//! Supports OpenGL application mode
#define LWVIOCAPS_OUTPUTMODE_OPENGL         0x00020000      

//! Supports Serial Digital Interface (SDI) input
#define LWVIOCAPS_VIDIN_SDI                 0x00100000  

//! Supports Packed ANC
#define LWVIOCAPS_PACKED_ANC_SUPPORTED      0x00200000     

//! Supports ANC audio blanking
#define LWVIOCAPS_AUDIO_BLANKING_SUPPORTED  0x00400000  

//! SDI-class interface: SDI output with two genlock inputs
#define LWVIOCLASS_SDI                      0x00000001      

//! Device capabilities
typedef struct _LWVIOCAPS
{
    LwU32             version;                              //!< Structure version
    LwAPI_String      adapterName;                          //!< Graphics adapter name
    LwU32             adapterClass;                         //!< Graphics adapter classes (LWVIOCLASS_SDI mask)
    LwU32             adapterCaps;                          //!< Graphics adapter capabilities (LWVIOCAPS_* mask)
    LwU32             dipSwitch;                            //!< On-board DIP switch settings bits
    LwU32             dipSwitchReserved;                    //!< On-board DIP switch settings reserved bits
    LwU32             boardID;                              //!< Board ID
    //! Driver version
    struct                                                  //
    {                                                      
        LwU32          majorVersion;                        //!< Major version. For GVI, majorVersion contains MajorVersion(HIWORD) And MinorVersion(LOWORD)
        LwU32          minorVersion;                        //!< Minor version. For GVI, minorVersion contains Revison(HIWORD) And Build(LOWORD)
    } driver;                                               //
    //! Firmware version 
    struct                                                  
    {                                                       
        LwU32          majorVersion;                        //!< Major version. In version 2, for both GVI and GVO, majorVersion contains MajorVersion(HIWORD) And MinorVersion(LOWORD)
        LwU32          minorVersion;                        //!< Minor version. In version 2, for both GVI and GVO, minorVersion contains Revison(HIWORD) And Build(LOWORD)
    } firmWare;                                             //
    LWVIOOWNERID      ownerId;                              //!< Unique identifier for owner of video output (LWVIOOWNERID_ILWALID if free running)
    LWVIOOWNERTYPE    ownerType;                            //!< Owner type (OpenGL application or Desktop mode)
} LWVIOCAPS;

//! Macro for constructing the version field of LWVIOCAPS
#define LWVIOCAPS_VER1  MAKE_LWAPI_VERSION(LWVIOCAPS,1)
#define LWVIOCAPS_VER2  MAKE_LWAPI_VERSION(LWVIOCAPS,2)
#define LWVIOCAPS_VER   LWVIOCAPS_VER2

//! Input channel status
typedef struct _LWVIOCHANNELSTATUS
{
    LwU32                  smpte352;                         //!< 4-byte SMPTE 352 video payload identifier
    LWVIOSIGNALFORMAT      signalFormat;                     //!< Signal format
    LWVIOBITSPERCOMPONENT  bitsPerComponent;                 //!< Bits per component
    LWVIOCOMPONENTSAMPLING samplingFormat;                   //!< Sampling format
    LWVIOCOLORSPACE        colorSpace;                       //!< Color space
    LWVIOLINKID            linkID;                           //!< Link ID
} LWVIOCHANNELSTATUS;

//! Input device status
typedef struct _LWVIOINPUTSTATUS
{
    LWVIOCHANNELSTATUS     vidIn[LWAPI_MAX_VIO_JACKS][LWAPI_MAX_VIO_CHANNELS_PER_JACK];     //!< Video input status per channel within a jack
    LWVIOCAPTURESTATUS     captureStatus;                  //!< status of video capture
} LWVIOINPUTSTATUS;

//! Output device status
typedef struct _LWVIOOUTPUTSTATUS
{
    LWVIOINPUTOUTPUTSTATUS    vid1Out;                        //!< Video 1 output status
    LWVIOINPUTOUTPUTSTATUS    vid2Out;                        //!< Video 2 output status
    LWVIOSYNCSTATUS        sdiSyncIn;                      //!< SDI sync input status
    LWVIOSYNCSTATUS        compSyncIn;                     //!< Composite sync input status
    LwU32            syncEnable;                     //!< Sync enable (TRUE if using syncSource)
    LWVIOSYNCSOURCE        syncSource;                     //!< Sync source
    LWVIOSIGNALFORMAT        syncFormat;                     //!< Sync format
    LwU32            frameLockEnable;                //!< Framelock enable flag
    LwU32            outputVideoLocked;              //!< Output locked status
    LwU32            dataIntegrityCheckErrorCount;   //!< Data integrity check error count
    LwU32            dataIntegrityCheckEnabled;      //!< Data integrity check status enabled 
    LwU32            dataIntegrityCheckFailed;       //!< Data integrity check status failed 
    LwU32                       uSyncSourceLocked;              //!< genlocked to framelocked to ref signal
    LwU32                       uPowerOn;                       //!< TRUE: indicates there is sufficient power
} LWVIOOUTPUTSTATUS;

//! Video device status.
typedef struct _LWVIOSTATUS
{
    LwU32                 version;                        //!< Structure version
    LWVIOSTATUSTYPE       lwvioStatusType;                //!< Input or Output status
    union                                                   
    {
        LWVIOINPUTSTATUS  inStatus;                       //!<  Input device status
        LWVIOOUTPUTSTATUS outStatus;                      //!<  Output device status
    }vioStatus;      
} LWVIOSTATUS;

//! Macro for constructingthe version field of LWVIOSTATUS
#define LWVIOSTATUS_VER   MAKE_LWAPI_VERSION(LWVIOSTATUS,1)

//! Output region
typedef struct _LWVIOOUTPUTREGION
{
    LwU32              x;                                    //!< Horizontal origin in pixels
    LwU32              y;                                    //!< Vertical origin in pixels
    LwU32              width;                                //!< Width of region in pixels
    LwU32              height;                               //!< Height of region in pixels
} LWVIOOUTPUTREGION;

//! Gamma ramp (8-bit index)
typedef struct _LWVIOGAMMARAMP8
{
    LwU16              uRed[256];                            //!< Red channel gamma ramp (8-bit index, 16-bit values)
    LwU16              uGreen[256];                          //!< Green channel gamma ramp (8-bit index, 16-bit values)
    LwU16              uBlue[256];                           //!< Blue channel gamma ramp (8-bit index, 16-bit values)
} LWVIOGAMMARAMP8;

//! Gamma ramp (10-bit index)
typedef struct _LWVIOGAMMARAMP10
{
    LwU16              uRed[1024];                           //!< Red channel gamma ramp (10-bit index, 16-bit values)
    LwU16              uGreen[1024];                         //!< Green channel gamma ramp (10-bit index, 16-bit values)
    LwU16              uBlue[1024];                          //!< Blue channel gamma ramp (10-bit index, 16-bit values)
} LWVIOGAMMARAMP10;


//! Sync delay
typedef struct _LWVIOSYNCDELAY
{
    LwU32              version;                              //!< Structure version
    LwU32              horizontalDelay;                      //!< Horizontal delay in pixels
    LwU32              verticalDelay;                        //!< Vertical delay in lines
} LWVIOSYNCDELAY;

//! Macro for constructing the version field of LWVIOSYNCDELAY
#define LWVIOSYNCDELAY_VER   MAKE_LWAPI_VERSION(LWVIOSYNCDELAY,1)


//! Video mode information
typedef struct _LWVIOVIDEOMODE
{
    LwU32                horizontalPixels;                   //!< Horizontal resolution (in pixels)
    LwU32                verticalLines;                      //!< Vertical resolution for frame (in lines)
    float                fFrameRate;                         //!< Frame rate
    LWVIOINTERLACEMODE   interlaceMode;                      //!< Interlace mode 
    LWVIOVIDEOSTANDARD   videoStandard;                      //!< SMPTE standards format
    LWVIOVIDEOTYPE       videoType;                          //!< HD or SD signal classification
} LWVIOVIDEOMODE;

//! Signal format details
typedef struct _LWVIOSIGNALFORMATDETAIL
{   
    LWVIOSIGNALFORMAT    signalFormat;                       //!< Signal format enumerated value
    LWVIOVIDEOMODE       videoMode;                          //!< Video mode for signal format
}LWVIOSIGNALFORMATDETAIL;


//! R8:G8:B8
#define LWVIOBUFFERFORMAT_R8G8B8                  0x00000001
 
//! R8:G8:B8:Z24  
#define LWVIOBUFFERFORMAT_R8G8B8Z24               0x00000002
   
//! R8:G8:B8:A8
#define LWVIOBUFFERFORMAT_R8G8B8A8                0x00000004   

//! R8:G8:B8:A8:Z24       
#define LWVIOBUFFERFORMAT_R8G8B8A8Z24             0x00000008   

//! R16FP:G16FP:B16FP
#define LWVIOBUFFERFORMAT_R16FPG16FPB16FP         0x00000010   

//! R16FP:G16FP:B16FP:Z24
#define LWVIOBUFFERFORMAT_R16FPG16FPB16FPZ24      0x00000020   

//! R16FP:G16FP:B16FP:A16FP
#define LWVIOBUFFERFORMAT_R16FPG16FPB16FPA16FP    0x00000040   

//! R16FP:G16FP:B16FP:A16FP:Z24
#define LWVIOBUFFERFORMAT_R16FPG16FPB16FPA16FPZ24 0x00000080   



//! Data format details
typedef struct _LWVIODATAFORMATDETAIL
{
    LWVIODATAFORMAT   dataFormat;                              //!< Data format enumerated value
    LwU32             vioCaps;                                 //!< Data format capabilities (LWVIOCAPS_* mask)
}LWVIODATAFORMATDETAIL;

//! Colorspace colwersion
typedef struct _LWVIOCOLORCOLWERSION
{
    LwU32       version;                                    //!<  Structure version
    float       colorMatrix[3][3];                          //!<  Output[n] =
    float       colorOffset[3];                             //!<  Input[0] * colorMatrix[n][0] +
    float       colorScale[3];                              //!<  Input[1] * colorMatrix[n][1] +
                                                            //!<  Input[2] * colorMatrix[n][2] +
                                                            //!<  OutputRange * colorOffset[n]
                                                            //!<  where OutputRange is the standard magnitude of
                                                            //!<  Output[n][n] and colorMatrix and colorOffset 
                                                            //!<  values are within the range -1.0 to +1.0
    LwU32      compositeSafe;                               //!<  compositeSafe constrains luminance range when using composite output
} LWVIOCOLORCOLWERSION;

//! macro for constructing the version field of _LWVIOCOLORCOLWERSION.
#define LWVIOCOLORCOLWERSION_VER   MAKE_LWAPI_VERSION(LWVIOCOLORCOLWERSION,1)

//! Gamma correction
typedef struct _LWVIOGAMMACORRECTION
{
    LwU32            version;                               //!< Structure version
    LwU32            vioGammaCorrectionType;                //!< Gamma correction type (8-bit or 10-bit)
    //! Gamma correction:
    union                                                   
    {                                                       
        LWVIOGAMMARAMP8  gammaRamp8;                        //!< Gamma ramp (8-bit index, 16-bit values)
        LWVIOGAMMARAMP10 gammaRamp10;                       //!< Gamma ramp (10-bit index, 16-bit values)
    }gammaRamp;                                      
    float            fGammaValueR;            //!< Red Gamma value within gamma ranges. 0.5 - 6.0
    float            fGammaValueG;            //!< Green Gamma value within gamma ranges. 0.5 - 6.0
    float            fGammaValueB;            //!< Blue Gamma value within gamma ranges. 0.5 - 6.0
} LWVIOGAMMACORRECTION;

//! Macro for constructing thevesion field of _LWVIOGAMMACORRECTION
#define LWVIOGAMMACORRECTION_VER   MAKE_LWAPI_VERSION(LWVIOGAMMACORRECTION,1)

//! Maximum number of ranges per channel
#define MAX_NUM_COMPOSITE_RANGE      2                      


typedef struct _LWVIOCOMPOSITERANGE
{
    LwU32   uRange;
    LwU32   uEnabled;
    LwU32   uMin;
    LwU32   uMax;
} LWVIOCOMPOSITERANGE;



// Device configuration (fields masks indicating LWVIOCONFIG fields to use for LwAPI_VIO_GetConfig/LwAPI_VIO_SetConfig() )
//
#define LWVIOCONFIG_SIGNALFORMAT            0x00000001      //!< fields: signalFormat
#define LWVIOCONFIG_DATAFORMAT              0x00000002      //!< fields: dataFormat
#define LWVIOCONFIG_OUTPUTREGION            0x00000004      //!< fields: outputRegion
#define LWVIOCONFIG_OUTPUTAREA              0x00000008      //!< fields: outputArea
#define LWVIOCONFIG_COLORCOLWERSION         0x00000010      //!< fields: colorColwersion
#define LWVIOCONFIG_GAMMACORRECTION         0x00000020      //!< fields: gammaCorrection
#define LWVIOCONFIG_SYNCSOURCEENABLE        0x00000040      //!< fields: syncSource and syncEnable
#define LWVIOCONFIG_SYNCDELAY               0x00000080      //!< fields: syncDelay
#define LWVIOCONFIG_COMPOSITESYNCTYPE       0x00000100      //!< fields: compositeSyncType
#define LWVIOCONFIG_FRAMELOCKENABLE         0x00000200      //!< fields: EnableFramelock
#define LWVIOCONFIG_422FILTER               0x00000400      //!< fields: bEnable422Filter
#define LWVIOCONFIG_COMPOSITETERMINATE      0x00000800      //!< fields: bCompositeTerminate (Not supported on Lwdqro FX 4000 SDI)         
#define LWVIOCONFIG_DATAINTEGRITYCHECK      0x00001000      //!< fields: bEnableDataIntegrityCheck (Not supported on Lwdqro FX 4000 SDI)
#define LWVIOCONFIG_CSCOVERRIDE             0x00002000      //!< fields: colorColwersion override
#define LWVIOCONFIG_FLIPQUEUELENGTH         0x00004000      //!< fields: flipqueuelength control
#define LWVIOCONFIG_ANCTIMECODEGENERATION   0x00008000      //!< fields: bEnableANCTimeCodeGeneration
#define LWVIOCONFIG_COMPOSITE               0x00010000      //!< fields: bEnableComposite
#define LWVIOCONFIG_ALPHAKEYCOMPOSITE       0x00020000      //!< fields: bEnableAlphaKeyComposite
#define LWVIOCONFIG_COMPOSITE_Y             0x00040000      //!< fields: compRange
#define LWVIOCONFIG_COMPOSITE_CR            0x00080000      //!< fields: compRange
#define LWVIOCONFIG_COMPOSITE_CB            0x00100000      //!< fields: compRange
#define LWVIOCONFIG_FULL_COLOR_RANGE        0x00200000      //!< fields: bEnableFullColorRange
#define LWVIOCONFIG_RGB_DATA                0x00400000      //!< fields: bEnableRGBData
#define LWVIOCONFIG_RESERVED_SDIOUTPUTENABLE         0x00800000      //!< fields: bEnableSDIOutput
#define LWVIOCONFIG_STREAMS                 0x01000000      //!< fields: streams
#define LWVIOCONFIG_ANC_PARITY_COMPUTATION  0x02000000      //!< fields: ancParityComputation
#define LWVIOCONFIG_ANC_AUDIO_REPEAT        0x04000000      //!< fields: enableAudioBlanking
 

// Don't forget to update LWVIOCONFIG_VALIDFIELDS in lwapi.spec when LWVIOCONFIG_ALLFIELDS changes.
#define LWVIOCONFIG_ALLFIELDS   ( LWVIOCONFIG_SIGNALFORMAT          | \
                                  LWVIOCONFIG_DATAFORMAT            | \
                                  LWVIOCONFIG_OUTPUTREGION          | \
                                  LWVIOCONFIG_OUTPUTAREA            | \
                                  LWVIOCONFIG_COLORCOLWERSION       | \
                                  LWVIOCONFIG_GAMMACORRECTION       | \
                                  LWVIOCONFIG_SYNCSOURCEENABLE      | \
                                  LWVIOCONFIG_SYNCDELAY             | \
                                  LWVIOCONFIG_COMPOSITESYNCTYPE     | \
                                  LWVIOCONFIG_FRAMELOCKENABLE       | \
                                  LWVIOCONFIG_422FILTER             | \
                                  LWVIOCONFIG_COMPOSITETERMINATE    | \
                                  LWVIOCONFIG_DATAINTEGRITYCHECK    | \
                                  LWVIOCONFIG_CSCOVERRIDE           | \
                                  LWVIOCONFIG_FLIPQUEUELENGTH       | \
                                  LWVIOCONFIG_ANCTIMECODEGENERATION | \
                                  LWVIOCONFIG_COMPOSITE             | \
                                  LWVIOCONFIG_ALPHAKEYCOMPOSITE     | \
                                  LWVIOCONFIG_COMPOSITE_Y           | \
                                  LWVIOCONFIG_COMPOSITE_CR          | \
                                  LWVIOCONFIG_COMPOSITE_CB          | \
                                  LWVIOCONFIG_FULL_COLOR_RANGE      | \
                                  LWVIOCONFIG_RGB_DATA              | \
                                  LWVIOCONFIG_RESERVED_SDIOUTPUTENABLE | \
                                  LWVIOCONFIG_STREAMS               | \
                                  LWVIOCONFIG_ANC_PARITY_COMPUTATION | \
                                  LWVIOCONFIG_ANC_AUDIO_REPEAT )

#define LWVIOCONFIG_VALIDFIELDS  ( LWVIOCONFIG_SIGNALFORMAT          | \
                                   LWVIOCONFIG_DATAFORMAT            | \
                                   LWVIOCONFIG_OUTPUTREGION          | \
                                   LWVIOCONFIG_OUTPUTAREA            | \
                                   LWVIOCONFIG_COLORCOLWERSION       | \
                                   LWVIOCONFIG_GAMMACORRECTION       | \
                                   LWVIOCONFIG_SYNCSOURCEENABLE      | \
                                   LWVIOCONFIG_SYNCDELAY             | \
                                   LWVIOCONFIG_COMPOSITESYNCTYPE     | \
                                   LWVIOCONFIG_FRAMELOCKENABLE       | \
                                   LWVIOCONFIG_RESERVED_SDIOUTPUTENABLE | \
                                   LWVIOCONFIG_422FILTER             | \
                                   LWVIOCONFIG_COMPOSITETERMINATE    | \
                                   LWVIOCONFIG_DATAINTEGRITYCHECK    | \
                                   LWVIOCONFIG_CSCOVERRIDE           | \
                                   LWVIOCONFIG_FLIPQUEUELENGTH       | \
                                   LWVIOCONFIG_ANCTIMECODEGENERATION | \
                                   LWVIOCONFIG_COMPOSITE             | \
                                   LWVIOCONFIG_ALPHAKEYCOMPOSITE     | \
                                   LWVIOCONFIG_COMPOSITE_Y           | \
                                   LWVIOCONFIG_COMPOSITE_CR          | \
                                   LWVIOCONFIG_COMPOSITE_CB          | \
                                   LWVIOCONFIG_FULL_COLOR_RANGE      | \
                                   LWVIOCONFIG_RGB_DATA              | \
                                   LWVIOCONFIG_RESERVED_SDIOUTPUTENABLE | \
                                   LWVIOCONFIG_STREAMS               | \
                                   LWVIOCONFIG_ANC_PARITY_COMPUTATION | \
                                   LWVIOCONFIG_ANC_AUDIO_REPEAT)

#define LWVIOCONFIG_DRIVERFIELDS ( LWVIOCONFIG_OUTPUTREGION          | \
                                   LWVIOCONFIG_OUTPUTAREA            | \
                                   LWVIOCONFIG_COLORCOLWERSION       | \
                                   LWVIOCONFIG_FLIPQUEUELENGTH)

#define LWVIOCONFIG_GAMMAFIELDS  ( LWVIOCONFIG_GAMMACORRECTION       )

#define LWVIOCONFIG_RMCTRLFIELDS ( LWVIOCONFIG_SIGNALFORMAT          | \
                                   LWVIOCONFIG_DATAFORMAT            | \
                                   LWVIOCONFIG_SYNCSOURCEENABLE      | \
                                   LWVIOCONFIG_COMPOSITESYNCTYPE     | \
                                   LWVIOCONFIG_FRAMELOCKENABLE       | \
                                   LWVIOCONFIG_422FILTER             | \
                                   LWVIOCONFIG_COMPOSITETERMINATE    | \
                                   LWVIOCONFIG_DATAINTEGRITYCHECK    | \
                                   LWVIOCONFIG_COMPOSITE             | \
                                   LWVIOCONFIG_ALPHAKEYCOMPOSITE     | \
                                   LWVIOCONFIG_COMPOSITE_Y           | \
                                   LWVIOCONFIG_COMPOSITE_CR          | \
                                   LWVIOCONFIG_COMPOSITE_CB)

#define LWVIOCONFIG_RMSKEWFIELDS ( LWVIOCONFIG_SYNCDELAY             )

#define LWVIOCONFIG_ALLOWSDIRUNNING_FIELDS ( LWVIOCONFIG_DATAINTEGRITYCHECK     | \
                                             LWVIOCONFIG_SYNCDELAY              | \
                                             LWVIOCONFIG_CSCOVERRIDE            | \
                                             LWVIOCONFIG_ANCTIMECODEGENERATION  | \
                                             LWVIOCONFIG_COMPOSITE              | \
                                             LWVIOCONFIG_ALPHAKEYCOMPOSITE      | \
                                             LWVIOCONFIG_COMPOSITE_Y            | \
                                             LWVIOCONFIG_COMPOSITE_CR           | \
                                             LWVIOCONFIG_COMPOSITE_CB           | \
                                             LWVIOCONFIG_ANC_PARITY_COMPUTATION)

                                             
 #define LWVIOCONFIG_RMMODESET_FIELDS ( LWVIOCONFIG_SIGNALFORMAT         | \
                                        LWVIOCONFIG_DATAFORMAT           | \
                                        LWVIOCONFIG_SYNCSOURCEENABLE     | \
                                        LWVIOCONFIG_FRAMELOCKENABLE      | \
                                        LWVIOCONFIG_COMPOSITESYNCTYPE    | \
                                        LWVIOCONFIG_ANC_AUDIO_REPEAT)                                            
                                             

//! Output device configuration 
// No members can be deleted from below structure. Only add new members at the 
// end of the structure.
typedef struct _LWVIOOUTPUTCONFIG_V1
{
    LWVIOSIGNALFORMAT    signalFormat;                         //!< Signal format for video output
    LWVIODATAFORMAT      dataFormat;                           //!< Data format for video output
    LWVIOOUTPUTREGION    outputRegion;                         //!< Region for video output (Desktop mode)
    LWVIOOUTPUTAREA      outputArea;                           //!< Usable resolution for video output (safe area)
    LWVIOCOLORCOLWERSION colorColwersion;                      //!< Color colwersion.
    LWVIOGAMMACORRECTION gammaCorrection;
    LwU32                syncEnable;                           //!< Sync enable (TRUE to use syncSource)
    LWVIOSYNCSOURCE      syncSource;                           //!< Sync source
    LWVIOSYNCDELAY       syncDelay;                            //!< Sync delay
    LWVIOCOMPSYNCTYPE    compositeSyncType;                    //!< Composite sync type
    LwU32                frameLockEnable;                      //!< Flag indicating whether framelock was on/off
    LwU32                psfSignalFormat;                      //!< Indicates whether contained format is PSF Signal format
    LwU32                enable422Filter;                      //!< Enables/Disables 4:2:2 filter
    LwU32                compositeTerminate;                   //!< Composite termination
    LwU32                enableDataIntegrityCheck;             //!< Enable data integrity check: true - enable, false - disable
    LwU32                cscOverride;                          //!< Use provided CSC color matrix to overwrite 
    LwU32                flipQueueLength;                      //!< Number of buffers used for the internal flipqueue
    LwU32                enableANCTimeCodeGeneration;          //!< Enable SDI ANC time code generation
    LwU32                enableComposite;                      //!< Enable composite
    LwU32                enableAlphaKeyComposite;              //!< Enable Alpha key composite
    LWVIOCOMPOSITERANGE  compRange;                            //!< Composite ranges
    LwU8                 reservedData[256];                    //!< Inicates last stored SDI output state TRUE-ON / FALSE-OFF
    LwU32                enableFullColorRange;                 //!< Flag indicating Full Color Range
    LwU32                enableRGBData;                        //!< Indicates data is in RGB format
} LWVIOOUTPUTCONFIG_V1;

typedef struct _LWVIOOUTPUTCONFIG_V2
{
    LWVIOSIGNALFORMAT    signalFormat;                         //!< Signal format for video output
    LWVIODATAFORMAT      dataFormat;                           //!< Data format for video output
    LWVIOOUTPUTREGION    outputRegion;                         //!< Region for video output (Desktop mode)
    LWVIOOUTPUTAREA      outputArea;                           //!< Usable resolution for video output (safe area)
    LWVIOCOLORCOLWERSION colorColwersion;                      //!< Color colwersion.
    LWVIOGAMMACORRECTION gammaCorrection;
    LwU32                syncEnable;                           //!< Sync enable (TRUE to use syncSource)
    LWVIOSYNCSOURCE      syncSource;                           //!< Sync source
    LWVIOSYNCDELAY       syncDelay;                            //!< Sync delay
    LWVIOCOMPSYNCTYPE    compositeSyncType;                    //!< Composite sync type
    LwU32                frameLockEnable;                      //!< Flag indicating whether framelock was on/off
    LwU32                psfSignalFormat;                      //!< Indicates whether contained format is PSF Signal format
    LwU32                enable422Filter;                      //!< Enables/Disables 4:2:2 filter
    LwU32                compositeTerminate;                   //!< Composite termination
    LwU32                enableDataIntegrityCheck;             //!< Enable data integrity check: true - enable, false - disable
    LwU32                cscOverride;                          //!< Use provided CSC color matrix to overwrite
    LwU32                flipQueueLength;                      //!< Number of buffers used for the internal flip queue
    LwU32                enableANCTimeCodeGeneration;          //!< Enable SDI ANC time code generation
    LwU32                enableComposite;                      //!< Enable composite
    LwU32                enableAlphaKeyComposite;              //!< Enable Alpha key composite
    LWVIOCOMPOSITERANGE  compRange;                            //!< Composite ranges
    LwU8                 reservedData[256];                    //!< Indicates last stored SDI output state TRUE-ON / FALSE-OFF
    LwU32                enableFullColorRange;                 //!< Flag indicating Full Color Range
    LwU32                enableRGBData;                        //!< Indicates data is in RGB format
    LWVIOANCPARITYCOMPUTATION ancParityComputation;            //!< Enable HW ANC parity bit computation (auto/on/off)
} LWVIOOUTPUTCONFIG_V2;

typedef struct _LWVIOOUTPUTCONFIG_V3
{
    LWVIOSIGNALFORMAT    signalFormat;                         //!< Signal format for video output
    LWVIODATAFORMAT      dataFormat;                           //!< Data format for video output
    LWVIOOUTPUTREGION    outputRegion;                         //!< Region for video output (Desktop mode)
    LWVIOOUTPUTAREA      outputArea;                           //!< Usable resolution for video output (safe area)
    LWVIOCOLORCOLWERSION colorColwersion;                      //!< Color colwersion.
    LWVIOGAMMACORRECTION gammaCorrection;
    LwU32                syncEnable;                           //!< Sync enable (TRUE to use syncSource)
    LWVIOSYNCSOURCE      syncSource;                           //!< Sync source
    LWVIOSYNCDELAY       syncDelay;                            //!< Sync delay
    LWVIOCOMPSYNCTYPE    compositeSyncType;                    //!< Composite sync type
    LwU32                frameLockEnable;                      //!< Flag indicating whether framelock was on/off
    LwU32                psfSignalFormat;                      //!< Indicates whether contained format is PSF Signal format
    LwU32                enable422Filter;                      //!< Enables/Disables 4:2:2 filter
    LwU32                compositeTerminate;                   //!< Composite termination
    LwU32                enableDataIntegrityCheck;             //!< Enable data integrity check: true - enable, false - disable
    LwU32                cscOverride;                          //!< Use provided CSC color matrix to overwrite
    LwU32                flipQueueLength;                      //!< Number of buffers used for the internal flip queue
    LwU32                enableANCTimeCodeGeneration;          //!< Enable SDI ANC time code generation
    LwU32                enableComposite;                      //!< Enable composite
    LwU32                enableAlphaKeyComposite;              //!< Enable Alpha key composite
    LWVIOCOMPOSITERANGE  compRange;                            //!< Composite ranges
    LwU8                 reservedData[256];                    //!< Indicates last stored SDI output state TRUE-ON / FALSE-OFF
    LwU32                enableFullColorRange;                 //!< Flag indicating Full Color Range
    LwU32                enableRGBData;                        //!< Indicates data is in RGB format
    LWVIOANCPARITYCOMPUTATION ancParityComputation;            //!< Enable HW ANC parity bit computation (auto/on/off)
    LwU32                enableAudioBlanking;                  //!< Enable HANC audio blanking on repeat frames
} LWVIOOUTPUTCONFIG_V3;

//! Stream configuration
typedef struct _LWVIOSTREAM
{
    LwU32                   bitsPerComponent;                     //!< Bits per component
    LWVIOCOMPONENTSAMPLING  sampling;                             //!< Sampling   
    LwU32                   expansionEnable;                      //!< Enable/disable 4:2:2->4:4:4 expansion
    LwU32                   numLinks;                             //!< Number of active links
    struct
    {
        LwU32               jack;                                 //!< This stream's link[i] will use the specified (0-based) channel within the
        LwU32               channel;                              //!< specified (0-based) jack
    } links[LWAPI_MAX_VIO_LINKS_PER_STREAM];
} LWVIOSTREAM;

//! Input device configuration
typedef struct _LWVIOINPUTCONFIG
{
    LwU32                numRawCaptureImages;                  //!< numRawCaptureImages is the number of frames to keep in the capture queue. 
                                                               //!< must be between LWAPI_GVI_MIN_RAW_CAPTURE_IMAGES and LWAPI_GVI_MAX_RAW_CAPTURE_IMAGES, 
    LWVIOSIGNALFORMAT    signalFormat;                         //!< Signal format.
                                                               //!< Please note that both numRawCaptureImages and signalFormat should be set together.
    LwU32                numStreams;                           //!< Number of active streams.
    LWVIOSTREAM          streams[LWAPI_MAX_VIO_STREAMS];       //!< Stream configurations
    LwU32                bTestMode;                            //!< This attribute controls the GVI test mode.
                                                               //!< Possible values 0/1. When testmode enabled, the
                                                               //!< GVI device will generate fake data as quickly as possible.
} LWVIOINPUTCONFIG;

typedef struct _LWVIOCONFIG_V1
{
    LwU32                version;                              //!< Structure version
    LwU32                fields;                               //!< Caller sets to LWVIOCONFIG_* mask for fields to use
    LWVIOCONFIGTYPE      lwvioConfigType;                      //!< Input or Output configuration
    union                                                   
    {
        LWVIOINPUTCONFIG  inConfig;                            //!<  Input device configuration
        LWVIOOUTPUTCONFIG_V1 outConfig;                           //!<  Output device configuration
    }vioConfig; 
} LWVIOCONFIG_V1;


typedef struct _LWVIOCONFIG_V2
{
    LwU32                version;                              //!< Structure version
    LwU32                fields;                               //!< Caller sets to LWVIOCONFIG_* mask for fields to use
    LWVIOCONFIGTYPE      lwvioConfigType;                      //!< Input or Output configuration
    union
    {
        LWVIOINPUTCONFIG     inConfig;                         //!< Input device configuration
        LWVIOOUTPUTCONFIG_V2 outConfig;                        //!< Output device configuration
    }vioConfig;
} LWVIOCONFIG_V2;

typedef struct _LWVIOCONFIG_V3
{
    LwU32                version;                              //!< Structure version
    LwU32                fields;                               //!< Caller sets to LWVIOCONFIG_* mask for fields to use
    LWVIOCONFIGTYPE      lwvioConfigType;                      //!< Input or Output configuration
    union
    {
        LWVIOINPUTCONFIG     inConfig;                         //!< Input device configuration
        LWVIOOUTPUTCONFIG_V3 outConfig;                        //!< Output device configuration
    }vioConfig;
} LWVIOCONFIG_V3;
typedef LWVIOOUTPUTCONFIG_V3 LWVIOOUTPUTCONFIG;
typedef LWVIOCONFIG_V3 LWVIOCONFIG;

#define LWVIOCONFIG_VER1  MAKE_LWAPI_VERSION(LWVIOCONFIG_V1,1)
#define LWVIOCONFIG_VER2  MAKE_LWAPI_VERSION(LWVIOCONFIG_V2,2)
#define LWVIOCONFIG_VER3  MAKE_LWAPI_VERSION(LWVIOCONFIG_V3,3)
#define LWVIOCONFIG_VER   LWVIOCONFIG_VER3


typedef struct
{
    LwPhysicalGpuHandle                    hPhysicalGpu;                    //!< Handle to Physical GPU (This could be NULL for GVI device if its not binded)
    LwVioHandle                         hVioHandle;                     //!<handle to SDI Input/Output device
    LwU32                               vioId;                          //!<device Id of SDI Input/Output device
    LwU32                               outputId;            //!<deviceMask of the SDI display connected to GVO device. 
                                                                        //!<outputId will be 0 for GVI device.
} LWVIOTOPOLOGYTARGET;                                                    

typedef struct _LW_VIO_TOPOLOGY
{
    LwU32                       version;
    LwU32                       vioTotalDeviceCount;                    //!<How many video I/O targets are valid
    LWVIOTOPOLOGYTARGET         vioTarget[LWAPI_MAX_VIO_DEVICES];       //!<Array of video I/O targets
}LW_VIO_TOPOLOGY, LWVIOTOPOLOGY;


//! Macro for constructing the version field of LW_VIO_TOPOLOGY
#define LW_VIO_TOPOLOGY_VER  MAKE_LWAPI_VERSION(LW_VIO_TOPOLOGY,1)

//! Macro for constructing the version field of LWVIOTOPOLOGY
#define LWVIOTOPOLOGY_VER    MAKE_LWAPI_VERSION(LWVIOTOPOLOGY,1)



//! @} 



//! \addtogroup vidio
//! @{
///////////////////////////////////////////////////////////////////////////////
//!   
//!   Function:    LwAPI_VIO_GetCapabilities
//!  
//!   Description: This API determine the graphics adapter video I/O capabilities.
//!  
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!  
//! \param [in]  LwVioHandle   The caller provides the SDI device handle as input.
//! \param [out] pAdapterCaps  Pointer to receive capabilities
//!  
//! \retval ::LWAPI_OK                           Success
//! \retval ::LWAPI_API_NOT_INTIALIZED           LWAPI Not Initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  LWVIOCAPS struct version used by the app is not compatible
//! \retval ::LWAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::LWAPI_ERROR                        LWAPI Random errors
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VIO_GetCapabilities(LwVioHandle     hVioHandle,
                                          LWVIOCAPS       *pAdapterCaps);


////////////////////////////////////////////////////////////////////////////////
//!   Function:    LwAPI_VIO_Open
//!  
//!   Description: This API opens the graphics adapter for video I/O operations
//!                using the OpenGL application interface.  Read operations
//!                are permitted in this mode by multiple clients, but Write 
//!                operations are application exclusive.
//!  
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!  
//! \param [in]  LwVioHandle      The caller provides the SDI output device handle as input.
//! \param [in]  vioClass         Class interface (LWVIOCLASS_* value)
//! \param [in]  ownerType        Specify LWVIOOWNERTYPE_APPLICATION or LWVIOOWNERTYPE_DESKTOP.
//!  
//! \retval ::LWAPI_OK                           Success
//! \retval ::LWAPI_API_NOT_INTIALIZED           LWAPI Not Initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::LWAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::LWAPI_ERROR                        LWAPI Random errors
//! \retval ::LWAPI_DEVICE_BUSY                  Access denied for requested access
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VIO_Open(LwVioHandle       hVioHandle,
                               LwU32             vioClass,
                               LWVIOOWNERTYPE    ownerType);

///////////////////////////////////////////////////////////////////////////////
//!   Function:    LwAPI_VIO_Close
//!  
//!   Description: This API closes the graphics adapter for graphics-to-video operations
//!                using the OpenGL application interface.  Closing an 
//!                OpenGL handle releases the device.
//!  
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!  
//! \param [in]  LwVioHandle   The caller provides the SDI output device handle as input.
//! \param [in]  bRelease      boolean value to either keep or release ownership
//!  
//! \retval ::LWAPI_OK                           Success
//! \retval ::LWAPI_API_NOT_INTIALIZED           LWAPI Not Initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::LWAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::LWAPI_ERROR                        LWAPI Random errors
//! \retval ::LWAPI_DEVICE_BUSY                  Access denied for requested access
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VIO_Close(LwVioHandle       hVioHandle,
                                LwU32             bRelease);
///////////////////////////////////////////////////////////////////////////////
//!   Function:    LwAPI_VIO_Status
//!  
//!   Description: This API gets the Video I/O LED status.
//!  
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!  
//! \param [in]  LwVioHandle   The caller provides the SDI device handle as input.
//! \param [out] pStatus       Return pointer to LWVIOSTATUS
//!  
//! \retval ::LWAPI_OK                           Success
//! \retval ::LWAPI_API_NOT_INTIALIZED           LWAPI Not Initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  Invalid structure version
//! \retval ::LWAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::LWAPI_ERROR                        LWAPI Random errors
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VIO_Status(LwVioHandle     hVioHandle, 
                                 LWVIOSTATUS     *pStatus);

////////////////////////////////////////////////////////////////////////////////
//!   Function:    LwAPI_VIO_SyncFormatDetect
//!  
//!   Description: This API detects the Video I/O incoming sync video format.
//!  
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!  
//! \param [in]  LwVioHandle  The caller provides the SDI device handle as input.
//! \param [out] pWait        Pointer to receive how many milliseconds will lapse 
//!                           before VIOStatus returns the detected syncFormat.
//!  
//! \retval ::LWAPI_OK                          Success
//! \retval ::LWAPI_API_NOT_INTIALIZED          LWAPI Not Initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT            Arguments passed to API are not valid
//! \retval ::LWAPI_NOT_SUPPORTED               Video I/O not supported
//! \retval ::LWAPI_ERROR                       LWAPI Random errors
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VIO_SyncFormatDetect(LwVioHandle hVioHandle,
                                           LwU32       *pWait);
///////////////////////////////////////////////////////////////////////////////
//!   Function:    LwAPI_VIO_GetConfig
//!  
//!   Description: This API gets the graphics-to-video configuration.
//!  
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!  
//! \param [in]  LwVioHandle   The caller provides the SDI device handle as input.
//! \param [out] pConfig       Pointer to the graphics-to-video configuration
//!  
//! \retval ::LWAPI_OK                           Success
//! \retval ::LWAPI_API_NOT_INTIALIZED           LWAPI Not Initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  Invalid structure version
//! \retval ::LWAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::LWAPI_ERROR                        LWAPI Random errors
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VIO_GetConfig(LwVioHandle        hVioHandle,
                                    LWVIOCONFIG        *pConfig); 

///////////////////////////////////////////////////////////////////////////////
//!   Function:    LwAPI_VIO_SetConfig
//!  
//!   Description: This API sets the graphics-to-video configuration.
//!  
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!  
//! \param [in]  LwVioHandle      The caller provides the SDI device handle as input.
//! \param [in]  pConfig          Pointer to Graphics-to-Video configuration
//!  
//! \retval ::LWAPI_OK                           Success
//! \retval ::LWAPI_API_NOT_INTIALIZED           LWAPI Not Initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  Stucture version invalid
//! \retval ::LWAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::LWAPI_ERROR                        LWAPI Random errors
//! \retval ::LWAPI_DEVICE_BUSY                  Access denied for requested access
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VIO_SetConfig(LwVioHandle            hVioHandle,
                                    const LWVIOCONFIG      *pConfig);

///////////////////////////////////////////////////////////////////////////////
//!   Function:    LwAPI_VIO_SetCSC
//!  
//!   Description: This API sets the colorspace colwersion parameters.
//!  
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use LwAPI_VIO_SetConfig.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!
//! \param [in]  LwVioHandle      The caller provides the SDI device handle as input.
//! \param [in]  pCSC             Pointer to CSC parameters
//!  
//! \retval ::LWAPI_OK                           Success
//! \retval ::LWAPI_API_NOT_INTIALIZED           LWAPI Not Initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  Stucture version invalid
//! \retval ::LWAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::LWAPI_ERROR                        LWAPI Random errors
//! \retval ::LWAPI_DEVICE_BUSY                  Access denied for requested access
////////////////////////////////////////////////////////////////////////////////----
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use LwAPI_VIO_SetConfig.")
LWAPI_INTERFACE LwAPI_VIO_SetCSC(LwVioHandle           hVioHandle,
                                 LWVIOCOLORCOLWERSION  *pCSC);
////////////////////////////////////////////////////////////////////////////////
//!   Function:    LwAPI_VIO_GetCSC
//! 
//!   Description: This API gets the colorspace colwersion parameters.
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use LwAPI_VIO_GetConfig.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!
//! \param [in]  LwVioHandle      The caller provides the SDI device handle as input.
//! \param [out] pCSC             Pointer to CSC parameters
//! 
//! \retval ::LWAPI_OK                           Success
//! \retval ::LWAPI_API_NOT_INTIALIZED           LWAPI Not Initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  Stucture version invalid
//! \retval ::LWAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::LWAPI_ERROR                        LWAPI Random errors
////////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use LwAPI_VIO_GetConfig.")
LWAPI_INTERFACE LwAPI_VIO_GetCSC(LwVioHandle           hVioHandle,
                                 LWVIOCOLORCOLWERSION  *pCSC);
///////////////////////////////////////////////////////////////////////////////
//!   Function:    LwAPI_VIO_SetGamma
//! 
//!   Description: This API sets the gamma colwersion parameters.
//! 
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use LwAPI_VIO_SetConfig.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!
//! \param [in]  LwVioHandle       The caller provides the SDI device handle as input.
//! \param [in]  pGamma            Pointer to gamma parameters
//! 
//! \retval ::LWAPI_OK                           Success
//! \retval ::LWAPI_API_NOT_INTIALIZED           LWAPI Not Initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  Stucture version invalid
//! \retval ::LWAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::LWAPI_ERROR                        LWAPI Random errors
//! \retval ::LWAPI_DEVICE_BUSY                  Access denied for requested access
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use LwAPI_VIO_SetConfig.")
LWAPI_INTERFACE LwAPI_VIO_SetGamma(LwVioHandle           hVioHandle,
                                   LWVIOGAMMACORRECTION  *pGamma);

///////////////////////////////////////////////////////////////////////////////
//!   Function:    LwAPI_VIO_GetGamma
//! 
//!   Description: This API gets the gamma colwersion parameters.
//! 
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use LwAPI_VIO_GetConfig.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!
//! \param [in]  LwVioHandle      The caller provides the SDI device handle as input.
//! \param [out] pGamma           Pointer to gamma parameters
//! 
//! \retval ::LWAPI_OK                           Success
//! \retval ::LWAPI_API_NOT_INTIALIZED           LWAPI Not Initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  Stucture version invalid
//! \retval ::LWAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::LWAPI_ERROR                        LWAPI Random errors
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use LwAPI_VIO_GetConfig.")
LWAPI_INTERFACE LwAPI_VIO_GetGamma(LwVioHandle           hVioHandle,
                                   LWVIOGAMMACORRECTION* pGamma);
////////////////////////////////////////////////////////////////////////////////
//!   Function:    LwAPI_VIO_SetSyncDelay
//! 
//!   Description: This API sets the sync delay parameters.
//! 
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use LwAPI_VIO_SetConfig.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//! 
//! \param [in]  LwVioHandle   The caller provides the SDI device handle as input.
//! \param [in]  pSyncDelay    Pointer to sync delay parameters
//!  
//! \retval ::LWAPI_OK                           Success
//! \retval ::LWAPI_API_NOT_INTIALIZED           LWAPI Not Initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  Stucture version invalid
//! \retval ::LWAPI_ERROR                        LWAPI Random errors
//! \retval ::LWAPI_DEVICE_BUSY                  Access denied for requested access
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use LwAPI_VIO_SetConfig.")
LWAPI_INTERFACE LwAPI_VIO_SetSyncDelay(LwVioHandle            hVioHandle,
                                       const LWVIOSYNCDELAY   *pSyncDelay);

////////////////////////////////////////////////////////////////////////////////
//!   Function:    LwAPI_VIO_GetSyncDelay
//! 
//!   Description: This API gets the sync delay parameters.
//! 
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use LwAPI_VIO_GetConfig.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//! 
//! \param [in]  LwVioHandle      The caller provides the SDI device handle as input.
//! \param [out] pSyncDelay       Pointer to sync delay parameters
//! 
//! \retval ::LWAPI_OK                           Success
//! \retval ::LWAPI_API_NOT_INTIALIZED           LWAPI Not Initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  Stucture version invalid
//! \retval ::LWAPI_ERROR                        LWAPI Random errors
///////////////////////////////////////////////////////////////////////////////
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use LwAPI_VIO_GetConfig.")
LWAPI_INTERFACE LwAPI_VIO_GetSyncDelay(LwVioHandle      hVioHandle,
                                       LWVIOSYNCDELAY   *pSyncDelay);

typedef enum _LWVIOPCILINKRATE
{
    LWVIOPCILINKRATE_UNKNOWN          = 0,
    LWVIOPCILINKRATE_GEN1             = 1,                    //<! 2.5 Gbps.
    LWVIOPCILINKRATE_GEN2             = 2,                    //<! 5 Gbps.
    LWVIOPCILINKRATE_GEN3             = 3,                    //<! 8 Gbps.
}LWVIOPCILINKRATE;

typedef enum _LWVIOPCILINKWIDTH
{
    LWVIOPCILINKWIDTH_UNKNOWN         = 0,
    LWVIOPCILINKWIDTH_x1              = 1,
    LWVIOPCILINKWIDTH_x2              = 2,
    LWVIOPCILINKWIDTH_x4              = 4,
    LWVIOPCILINKWIDTH_x8              = 8,
    LWVIOPCILINKWIDTH_x16            = 16,
}LWVIOPCILINKWIDTH;

typedef struct _LWVIOPCIINFO
{
    LwU32                     version;                            //!< Structure version
    
    LwU32                   pciDeviceId;                        //!< specifies the internal PCI device identifier for the GVI.
    LwU32                   pciSubSystemId;                        //!< specifies the internal PCI subsystem identifier for the GVI.
    LwU32                   pciRevisionId;                        //!< specifies the internal PCI device-specific revision identifier for the GVI.
    LwU32                   pciDomain;                            //!< specifies the PCI domain of the GVI device.
    LwU32                   pciBus;                                //!< specifies the PCI bus number of the GVI device.
    LwU32                   pciSlot;                            //!< specifies the PCI slot number of the GVI device.
    LWVIOPCILINKWIDTH       pciLinkWidth;                        //!< specifies the the negotiated PCIE link width.
    LWVIOPCILINKRATE           pciLinkRate;                        //!< specifies the the negotiated PCIE link rate.
} LWVIOPCIINFO_V1;

typedef LWVIOPCIINFO_V1                                         LWVIOPCIINFO;
#define LWVIOPCIINFO_VER1                                          MAKE_LWAPI_VERSION(LWVIOPCIINFO_V1,1)
#define LWVIOPCIINFO_VER                                        LWVIOPCIINFO_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_VIO_GetPCIInfo()
//
// DESCRIPTION:   This API gets PCI information of the attached SDI(input) capture card.
//
// PARAMETERS:      hVioHandle    (IN)    - Handle to SDI capture card.
//                  pVioPCIInfo    (OUT)    - PCI information of the attached SDI capture card.
//
//! SUPPORTED OS:  Windows XP and higher
//!
//
// RETURN STATUS: This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//                specific meaning for this API, they are listed below.
//
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VIO_GetPCIInfo(__in LwVioHandle hVioHandle, 
                                            __inout LWVIOPCIINFO* pVioPCIInfo);

////////////////////////////////////////////////////////////////////////////////
//!   Function:    LwAPI_VIO_IsRunning
//! 
//!   Description: This API determines if Video I/O is running.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//! 
//! \param [in]  LwVioHandle[IN]          The caller provides the SDI device handle as input.
//! 
//! \retval ::LWAPI_DRIVER_RUNNING        Video I/O running
//! \retval ::LWAPI_DRIVER_NOTRUNNING     Video I/O not running
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VIO_IsRunning(LwVioHandle   hVioHandle);

///////////////////////////////////////////////////////////////////////////////
//!   Function:    LwAPI_VIO_Start
//! 
//!   Description: This API starts Video I/O.
//!              This API should be called for LWVIOOWNERTYPE_DESKTOP only and will not work for OGL applications.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!
//! \param [in]  LwVioHandle[IN]     The caller provides the SDI device handle as input.
//! 
//! \retval ::LWAPI_OK                           Success
//! \retval ::LWAPI_API_NOT_INTIALIZED           LWAPI Not Initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::LWAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::LWAPI_ERROR                        LWAPI Random errors
//! \retval ::LWAPI_DEVICE_BUSY                  Access denied for requested access
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VIO_Start(LwVioHandle     hVioHandle);

///////////////////////////////////////////////////////////////////////////////
//!   Function:    LwAPI_VIO_Stop
//! 
//!   Description: This API stops Video I/O.
//!              This API should be called for LWVIOOWNERTYPE_DESKTOP only and will not work for OGL applications.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//! 
//! \param [in]  LwVioHandle[IN]     The caller provides the SDI device handle as input.
//! 
//! \retval ::LWAPI_OK                           Success
//! \retval ::LWAPI_API_NOT_INTIALIZED           LWAPI Not Initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::LWAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::LWAPI_ERROR                        LWAPI Random errors
//! \retval ::LWAPI_DEVICE_BUSY                  Access denied for requested access
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VIO_Stop(LwVioHandle     hVioHandle);


///////////////////////////////////////////////////////////////////////////////
//!   Function:    LwAPI_VIO_IsFrameLockModeCompatible
//! 
//!   Description: This API checks whether modes are compatible in frame lock mode.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//! 
//! \param [in]   LwVioHandle          The caller provides the SDI device handle as input.
//! \param [in]   srcEnumIndex         Source Enumeration index
//! \param [in]   destEnumIndex        Destination Enumeration index
//! \param [out]  pbCompatible         Pointer to receive compatibility
//! 
//! \retval ::LWAPI_OK                           Success
//! \retval ::LWAPI_API_NOT_INTIALIZED           LWAPI Not Initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::LWAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::LWAPI_ERROR                        LWAPI Random errors
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VIO_IsFrameLockModeCompatible(LwVioHandle              hVioHandle,
                                                    LwU32                    srcEnumIndex,
                                                    LwU32                    destEnumIndex,
                                                    LwU32*                   pbCompatible);


///////////////////////////////////////////////////////////////////////////////
//!   Function:    LwAPI_VIO_EnumDevices
//! 
//!   Description: This API enumerate all VIO devices connected to the system.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!
//! \param [out]  LwVioHandle                  User passes the pointer of LwVioHandle[] array to get handles to
//!                                            all the connected video I/O devices.
//! \param [out]  vioDeviceCount               User gets total number of VIO devices connected to the system.
//! 
//! \retval ::LWAPI_OK                         Success
//! \retval ::LWAPI_API_NOT_INTIALIZED         LWAPI Not Initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT           Arguments passed to API are not valid
//! \retval ::LWAPI_ERROR                      LWAPI Random errors
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND    No SDI Device found
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VIO_EnumDevices(LwVioHandle       hVioHandle[LWAPI_MAX_VIO_DEVICES],
                                      LwU32             *vioDeviceCount);
                                                                                          

///////////////////////////////////////////////////////////////////////////////
//!   Function:    LwAPI_VIO_QueryTopology
//! 
//!   Description: This API queries the valid SDI topologies.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!
//! \param [out] pLwVIOTopology     User passes the pointer to LWVIOTOPOLOGY to fetch all valid SDI topologies.
//! 
//! \retval ::LWAPI_OK                           Success
//! \retval ::LWAPI_API_NOT_INTIALIZED           LWAPI Not Initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  Invalid structure version
//! \retval ::LWAPI_ERROR                        LWAPI Random errors
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VIO_QueryTopology(LW_VIO_TOPOLOGY   *pLwVIOTopology);


///////////////////////////////////////////////////////////////////////////////
//!   Function:    LwAPI_VIO_EnumSignalFormats
//! 
//!   Description: This API enumerates signal formats supported by Video I/O.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!
//! \param [in]   LwVioHandle          The caller provides the SDI device handle as input.
//! \param [in]   enumIndex            Enumeration index
//! \param [out]  pSignalFormatDetail  Pointer to receive detail or NULL
//! 
//! \retval ::LWAPI_OK                  Success
//! \retval ::LWAPI_API_NOT_INTIALIZED  LWAPI not initialized
//! \retval ::LWAPI_ILWALID_ARGUMENT    Invalid argument passed
//! \retval ::LWAPI_END_ENUMERATION     No more signal formats to enumerate
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VIO_EnumSignalFormats(LwVioHandle              hVioHandle,
                                            LwU32                    enumIndex,
                                            LWVIOSIGNALFORMATDETAIL  *pSignalFormatDetail);

///////////////////////////////////////////////////////////////////////////////
//!   Function:    LwAPI_VIO_EnumDataFormats
//! 
//!   Description: This API enumerates data formats supported by Video I/O.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//! 
//! \param [in]  LwVioHandle         The caller provides the SDI device handle as input.
//! \param [in]  enumIndex           Enumeration index
//! \param [out] pDataFormatDetail   Pointer to receive detail or NULL
//! 
//! \retval ::LWAPI_OK                Success
//! \retval ::LWAPI_END_ENUMERATION   No more data formats to enumerate
//! \retval ::LWAPI_NOT_SUPPORTED     Unsupported LWVIODATAFORMAT_ enumeration
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VIO_EnumDataFormats(LwVioHandle            hVioHandle,
                                          LwU32                  enumIndex,
                                          LWVIODATAFORMATDETAIL  *pDataFormatDetail);
                                                                                      

//! @}




///////////////////////////////////////////////////////////////////////////////////
//  CAMERA TEST API
//  These APIs allows test apps to perform low level camera tests

//! \addtogroup vidio
//! @{
//! SUPPORTED OS:  Windows 8
//!

typedef enum _LWAPI_VIDEO_CAMERA_TEST_RETURN_STATUS
{
    LWAPI_VIDEO_CAMERA_TEST_RETURN_STATUS_SUCCESS,
    LWAPI_VIDEO_CAMERA_TEST_RETURN_STATUS_NA,
    LWAPI_VIDEO_CAMERA_TEST_RETURN_STATUS_ILWALID_ARG,
    LWAPI_VIDEO_CAMERA_TEST_RETURN_STATUS_ERROR,
    LWAPI_VIDEO_CAMERA_TEST_RETURN_STATUS_POWER_OFF,
    
} LWAPI_VIDEO_CAMERA_TEST_RETURN_STATUS;
typedef enum _LWAPI_CAMERA_TEST_DEVICE_ID
{
    LWAPI_CAMERA_TEST_DEVICE_CAMERA1_ID,
    LWAPI_CAMERA_TEST_DEVICE_SENSOR1_ID,
    LWAPI_CAMERA_TEST_DEVICE_FOLWSSER1_ID,
    LWAPI_CAMERA_TEST_DEVICE_FLASH1_ID,
    
    LWAPI_CAMERA_TEST_DEVICE_CAMERA2_ID,
    LWAPI_CAMERA_TEST_DEVICE_SENSOR2_ID,
    LWAPI_CAMERA_TEST_DEVICE_FOLWSSER2_ID,
    LWAPI_CAMERA_TEST_DEVICE_FLASH2_ID,
    
    
    LWAPI_CAMERA_TEST_DEVICE_CAMERA3_ID,
    LWAPI_CAMERA_TEST_DEVICE_SENSOR3_ID,
    LWAPI_CAMERA_TEST_DEVICE_FOLWSSER3_ID,
    LWAPI_CAMERA_TEST_DEVICE_FLASH3_ID,
    
}LWAPI_CAMERA_TEST_DEVICE_ID;

typedef enum _LWAPI_CAMERA_TEST_FUNCTION_ID
{
    LWAPI_CAMERA_TEST_FUNCTION_ID_POWERON,
    LWAPI_CAMERA_TEST_FUNCTION_ID_POWEROFF,
    LWAPI_CAMERA_TEST_FUNCTION_ID_GET_TOPOLOGY,
    LWAPI_CAMERA_TEST_FUNCTION_ID_SYSTEMTEST,
    LWAPI_CAMERA_TEST_FUNCTION_ID_REGWRITE,
    LWAPI_CAMERA_TEST_FUNCTION_ID_CAPTURE
}LWAPI_CAMERA_TEST_FUNCTION_ID;

typedef enum _LWAPI_CAMERA_TEST_FUNCTION_ID_POWER_PARAM
{
    LWAPI_CAMERA_TEST_FUNCTION_ID_POWER_PARAM_CAM1,
    LWAPI_CAMERA_TEST_FUNCTION_ID_POWER_PARAM_CAM2,
    LWAPI_CAMERA_TEST_FUNCTION_ID_POWER_PARAM_CAM3,
}LWAPI_CAMERA_TEST_FUNCTION_ID_POWER_PARAM;

typedef enum _LWAPI_CAMERA_TEST_FUNCTION_ID_SYSTEMTEST_PARAM
{
    LWAPI_CAMERA_TEST_FUNCTION_ID_SYSTEMTEST_PARAM_SENSOR,
    LWAPI_CAMERA_TEST_FUNCTION_ID_SYSTEMTEST_PARAM_FOLWSSER,
    LWAPI_CAMERA_TEST_FUNCTION_ID_SYSTEMTEST_PARAM_FLASH,
}LWAPI_CAMERA_TEST_FUNCTION_ID_SYSTEMTEST_PARAM;

typedef struct _LWAPI_CAMERA_TEST_PARAMS_V1
{
    LwU32                                   version; //!< (IN) version that matches LWAPI_CAMERA_TEST_PARAMS_VER
    LWAPI_VIDEO_CAMERA_TEST_RETURN_STATUS   dwStatus; //!< (OUT) one of the LWAPI_VIDEO_CAMERA_TEST_RETURN_STATUS 
    LWAPI_CAMERA_TEST_FUNCTION_ID           functionId; //!< (IN) one of the LW_CAMERA_TEST_FUNCTION_ID
    LwU32                                   dwParam; //!< (IN) device ID of the target device
    LwAPI_String                            szParam; //!< (IN/OUT) additional params for the test
    LwU32                                   adwReserved[5]; //!< (IN/OUT) reserved for future expansion
} LWAPI_CAMERA_TEST_PARAMS_V1;

#define LWAPI_CAMERA_TEST_PARAMS_VER_V1 MAKE_LWAPI_VERSION(LWAPI_CAMERA_TEST_PARAMS_V1,1)

typedef LWAPI_CAMERA_TEST_PARAMS_V1 LWAPI_CAMERA_TEST_PARAMS;
#define LWAPI_CAMERA_TEST_PARAMS_VER LWAPI_CAMERA_TEST_PARAMS_VER_V1
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Camera_Test
//
//!   DESCRIPTION: This API exelwtes camera tests in the KMD via escape calls. This is an internal API for usage only by our tools.
//! \param [in]     hLwDisplay(in)    - LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in,out] pCameraTestParams - LWAPI_CAMERA_TEST_PARAMS containing a FunctionId.
//!                                          
//! \return ::LWAPI_OK if the call succeeded. 
//!
//! \ingroup vidio

///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_CameraTest( __in LwDisplayHandle hLwDisplay, __inout LWAPI_CAMERA_TEST_PARAMS* pCameraTestParams );

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Stereo_GetInfo
//
//! \fn LwAPI_Stereo_GetInfo(__in LwDisplayHandle hLwDisplay, __inout LW_STEREO_DIAG_INFO *pStereoInfo)
//! DESCRIPTION:     This API returns requested stereo diagnostic information 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]          hLwDisplay      Display Handle
//! \param [in,out]      pStereoInfo     stereo information
//!
//! \return    This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \retval    LWAPI_ILWALID_POINTER                -   Invalid input parameter. Following can be the reason for this return value:
//!                                                 -# pStereoInfo is NULL.
//! \retval    LWAPI_INCOMPATIBLE_STRUCT_VERSION    -   LW_STEREO_DIAG_INFO Struct not compatible with this LWAPI driver
//! \retval    LWAPI_ILWALID_HANDLE                 -   Invalid Adapter handle
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereoapi
//! @{

//! See LwAPI_Stereo_GetInfo().
//! Macro for constructing the version field of LW_STEREO_DIAG_INFO
#define LW_STEREO_DIAG_INFO_VER MAKE_LWAPI_VERSION(LW_STEREO_DIAG_INFO, 2)

//! See LwAPI_Stereo_GetInfo().
#define LW_STEREO_MAX_HEADS           4

//! @}

//! \ingroup stereoapi
//! @{

//! See LwAPI_Stereo_GetInfo().
//! Stereo info query IDs.
typedef enum _LW_STEREO_DIAG_INFO_QUERY_ID
{
    LW_STEREO_DIAG_INFO_QUERY_ID_COMMON,

    // << Append here >> 
    LW_STEREO_DIAG_INFO_QUERY_ID_LAST,
}LW_STEREO_DIAG_INFO_QUERY_ID;

//! See LwAPI_Stereo_GetInfo().
//! Stereo High VBI override status.
typedef enum _LW_STEREO_HIGH_VBI_OVERRIDE
{
    LW_STEREO_HIGH_VBI_OVERRIDE_DONE              = 0x10000,
    LW_STEREO_HIGH_VBI_OVERRIDE_NOT_DONE          = 0x20000,
    LW_STEREO_HIGH_VBI_OVERRIDE_NO_MONITOR        = 0x40000,
    LW_STEREO_HIGH_VBI_OVERRIDE_PENDING_ON_RESUME = 0x80000
}LW_STEREO_HIGH_VBI_OVERRIDE;
//! @}

//! \ingroup stereoapi
//! @{

//! See LwAPI_Stereo_GetInfo().
//! Stereo global(kmd) status info: Used in LW_STEREO_DIAG_COMMON_INFO
typedef struct _LW_STEREO_STATUS_INFO
{
    LwU8         isStereoEnabled;       //!< TRUE if stereo enabled 
    LwU8         isStereoActive;        //!< TRUE if stereo active 
    LwU32        numStereoClients;      //!< Number of clients that have relwrsively enabled stereo (by calling setStereoConfig)
    LwS32        stereoDeviceCount;     //!< Number of devices which have allocated a stereo renderable 
                                        //!< primary (excluding the shared scanout primary).
    LwU32        pendingStereoConfig[LW_STEREO_MAX_HEADS];           //!< flags reflecting requested stereo configuration
    LwU32        persistentStereoConfig[LW_STEREO_MAX_HEADS];        //!< flags reflecting persistent stereo configuration
    LwU32        stereoConfig[LW_STEREO_MAX_HEADS];                  //!< flags reflecting adapter's stereo configuration
    LwU32        stereoVBIOverride[LW_STEREO_MAX_HEADS];             //!< indicates need to override high VBI on mode set if stereo is enabled.
    LwU32        stereoLastModeSetVBIOverride[LW_STEREO_MAX_HEADS];  //!< Last mode set VBI override status.
    LwU32        stereoDesktopCount[LW_STEREO_MAX_HEADS];            //!< Count of active devices running in windowed stereo.
    LwU32        monitor3DEnableStatus[LW_STEREO_MAX_HEADS];         //!< holds the last status of monitor 3D mode authentication.
    LwU32        stereoVBIOverrideTargetId[LW_STEREO_MAX_HEADS];     //!< target id of overridden monitor controlling the dongle

    LwU32        reserved[5];
}LW_STEREO_STATUS_INFO;

//! See LwAPI_Stereo_GetInfo().
//! Stereo emitter info: Used in LW_STEREO_DIAG_COMMON_INFO
typedef struct _LW_STEREO_EMITTER_INFO
{
    LwU8         isInit;                //!< Emitter initialized
    LwU8         isConnected;           //!< TRUE if stereo enabled 
    LwU8         isActivated;           //!< TRUE if stereo active 
    LwU32        activatedHead;         //!< Stereo activated head
    LwU32        activeHeadRR;          //!< Refresh Rate on active head
    LwU32        activeCount;           //!< Number of apps that have sent activate calls
    LwU8         isActiveStatusUSBDrv;  //!< Activation status in USB Driver
    LwU32        reserved[5];
}LW_STEREO_EMITTER_INFO;

//! See LwAPI_Stereo_GetInfo().
//! Stereo windowed app aero info: Used in LW_STEREO_DIAG_COMMON_INFO
typedef struct _LW_STEREO_AERO_INFO
{
    LwU32       appCount;               //!< Number of windowed mode active apps
    LwU32       appPid;                 //!< Process ID of app that initiated DWM restart
    LwU32       orgRR;                  //!< Original Refresh Rate
    LwU32       reserved[5];
}LW_STEREO_AERO_INFO;

//! See LwAPI_Stereo_GetInfo().
//! Stereo global(kmd) common info
typedef struct  _LW_STEREO_DIAG_COMMON_INFO
{
    LwU32                      reserved1;
    LW_STEREO_STATUS_INFO      status;          //!< (OUT) Stereo global status info
    LW_STEREO_EMITTER_INFO     emitter;         //!< (OUT) Emitter Status info
    LW_STEREO_AERO_INFO        aero;            //!< (OUT) Windowed mode app(AERO ON) info
    LwU32                      reserved2[20];
} LW_STEREO_DIAG_COMMON_INFO;


//! See LwAPI_Stereo_GetInfo().
//! Stereo info
typedef struct  _LW_STEREO_DIAG_INFO
{
    LwU32                      version;         //!< (IN) Stereo get  info version
    LwU32                      queryId;         //!< (IN)     Stereo info query ID
    LwU32                      result;          //!< (OUT)    info retrived successfully?
    LwU32                      reserved1;
    union
    {
        LW_STEREO_DIAG_COMMON_INFO commonInfo;        //!< (IN,OUT) Stereo common info 
        // To retrieve other types of info, please append structs here.
    };
} LW_STEREO_DIAG_INFO;


//! @}

//! \ingroup stereoapi
LWAPI_INTERFACE LwAPI_Stereo_GetInfo(__in LwDisplayHandle hLwDisplay, __inout LW_STEREO_DIAG_INFO *pStereoInfo);






///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_Stereo_GetAppInfo
//
//! \fn LwAPI_Stereo_GetAppInfo(__in LwDisplayHandle hLwDisplay, __inout LW_STEREO_DIAG_APP_INFO *pStereoInfo)
//! DESCRIPTION:     This API returns the application's stereo driver information 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]          hLwDisplay      Display Handle
//! \param [in,out]      pStereoInfo     application's stereo driver diagnostic information
//!
//! \return    This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \retval    LWAPI_ILWALID_POINTER                -   Invalid input parameter. Following can be the reason for this return value:
//!                                                 -# pStereoInfo is NULL.
//! \retval    LWAPI_INCOMPATIBLE_STRUCT_VERSION    -   LW_STEREO_DIAG_INFO Struct not compatible with this LWAPI driver
//! \retval    LWAPI_ILWALID_HANDLE                 -   Invalid Adapter handle
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereoapi
//! @{

//! See LwAPI_Stereo_GetAppInfo().
//! Macro for constructing the version field of LW_STEREO_DIAG_APP_INFO
#define LW_STEREO_DIAG_APP_INFO_VER MAKE_LWAPI_VERSION(LW_STEREO_DIAG_APP_INFO, 2)

//! See LwAPI_Stereo_GetAppInfo().
#define LW_STEREO_INFO_MAX_APPS       32
#define LW_STEREO_INFO_DX9_APP        1
#define LW_STEREO_INFO_DX10_APP       2
#define LW_STEREO_APP_INFO_SIZE       1024

//! @}

//! \ingroup stereoapi
//! @{

//! See LwAPI_Stereo_GetAppInfo().
//! Stereo Mode
typedef enum _LW_STEREO_MODE
{
    LW_STEREO_MODE_DEFAULT = 0,
    LW_STEREO_MODE_EXPLICIT = 1,
    LW_STEREO_MODE_QUADBUFFER = 2,
    LW_STEREO_MODE_LAST,
}LW_STEREO_MODE;

//! See LwAPI_Stereo_GetAppInfo().
//! Browser type
typedef enum _LW_STEREO_BROWSER_TYPE
{
    LW_STEREO_BROWSER_NONE              = 0x000,
    LW_STEREO_BROWSER_IE_BASE           = 0x100,
    LW_STEREO_BROWSER_IE9_PLUS          = 0x101,
    LW_STEREO_BROWSER_FF_BASE           = 0x200,
    LW_STEREO_BROWSER_FF_3_6_4_PLUS     = 0x201,
    LW_STEREO_BROWSER_FF_4_PLUS         = 0x202,
    LW_STEREO_BROWSER_CHROME_BASE       = 0x300,
    LW_STEREO_BROWSER_LAST
} LW_STEREO_BROWSER_TYPE;

//! See LwAPI_Stereo_GetAppInfo().
//! Stereo Source video layout
typedef enum _LW_STEREO_SOURCE_LAYOUT
{
    LW_STEREO_SOURCE_LAYOUT_LEFT_RIGHT = 0,
    LW_STEREO_SOURCE_LAYOUT_RIGHT_LEFT = 1,
    LW_STEREO_SOURCE_LAYOUT_TOP_BOTTOM = 2,
    LW_STEREO_SOURCE_LAYOUT_BOTTOM_TOP = 3,
    LW_STEREO_SOURCE_LAYOUT_MONO_MODE  = 4,
    LW_STEREO_SOURCE_LAYOUT_LAST 
}LW_STEREO_SOURCE_LAYOUT;

//! See LwAPI_Stereo_GetAppInfo().
//! Stereo State
typedef enum _LW_STEREO_STATE
{
    LW_STEREO_STATE_NOT_READY       =-1,
    LW_STEREO_STATE_OFF             = 0,
    LW_STEREO_STATE_ON              = 1,
    LW_STEREO_STATE_FORCED_OFF      = 2,
    LW_STEREO_STATE_OFF_IN_REGISTRY = 3,
}LW_STEREO_STATE;

//! See LwAPI_Stereo_GetAppInfo().
//! DX version
typedef enum _LW_STEREO_DX_VERSION
{
    LW_STEREO_DX_VERSION_DX10_0 = 2,
    LW_STEREO_DX_VERSION_DX10_1 = 3,
    LW_STEREO_DX_VERSION_DX11_0 = 4,
    LW_STEREO_DX_VERSION_DX11_1 = 5,
}LW_STEREO_DX_VERSION;

//! See LwAPI_Stereo_GetAppInfo().
//! Stereo Viewer types
typedef enum _LW_STEREO_CFG
{
    LW_STEREO_CFG_STEREOACTIVATED            = 0x80000000,
    LW_STEREO_CFG_CONNECTIONTYPE             = 0x000007FF,
    LW_STEREO_CFG_DEFAULT_VIEWER             = 0x00000001,//!< supersedes old ELSADDC. Also includes lw30+ native stereo.
    LW_STEREO_CFG_ELSADDC                    = 0x00000001,
    LW_STEREO_CFG_INTERLACED                 = 0x00000002,
    LW_STEREO_CFG_COLORINTERLEAVED           = 0x00000003,
    LW_STEREO_CFG_MULTIHEAD                  = 0x00000004,//!< show eyes rather on different heads.
    LW_STEREO_CFG_INTERLEAVED                = 0x00000008,//!< mixes tiles from left & right eyes together in one view.
    LW_STEREO_CFG_LINECODE                   = 0x00000010,
    LW_STEREO_CFG_ANAGLYPH                   = 0x00000020,
    LW_STEREO_CFG_LWIDIA_ONBOARD_GPIO5_DAC0  = 0x00000040,//!< GPIO programming for DAC0 (maybe different form head)
    LW_STEREO_CFG_LWIDIA_ONBOARD_GPIO5_DAC1  = 0x00000080,//!< GPIO programming for DAC1 (maybe different form head) 
    LW_STEREO_CFG_PRAMDAC_STEREO             = 0x00000100,//!< stereo glasses control is done via pramdac (no dac selection necessary, but head)
    LW_STEREO_CFG_SHARP_GPIO4                = 0x00000200,
}LW_STEREO_CFG;

//! @}

//! \ingroup stereoapi
//! @{

//! See LwAPI_Stereo_GetAppInfo().
//! DX9 app info
typedef struct _LW_STEREO_APP_INFO_DX9
{
    LwU8            exeName[128];
    LwU32           stereoMode;
    LwU32           reserved1;
    
    //Stereo Status
    LwU32           stereoHWType;           //!< Stereo Viewer HW type.
    // LwU32   bit-field byte1
    LwU32            reservedbits7:8;
    
    // LwU32   bit-field byte2
    LwU32            isStereoActivated:1;    //!< Stereo is lwrrently activated.
    LwU32            isStereoBlocked:1;      //!< Out of memory condition
    LwU32            isAnaglyphOnly:1;       //!< Protection defined
    LwU32            isHDMIStereo:1;
    LwU32            isHDMIAllowed:1;
    LwU32            isHDMISupported:1;
    LwU32            isHDMIProtected:1;
    LwU32            isHDMIWindowed:1;
    // LwU32   bit-field byte3
    LwU32            isSLIBroadcast:1;
    LwU32            isClonedMode:1;
    LwU32            isGameProfiled:1;
    LwU32            reservedbits1:5;
    // LwU32   bit-field byte4
    LwU32            reservedbits2:8;
    
    LwU32           reserved2;

    // Authentication
    // LwU32   bit-field byte1
    LwU32            isFullLicense:1;
    LwU32            isTestLicense:1;
    LwU32            isPanelReleased:1;
    LwU32            isDisplayIdentified:1;
    LwU32            isDisplayReleased:1;
    LwU32            isNB:1;
    LwU32            isQuadro:1;
    LwU32            isSandBox:1;
    // LwU32   bit-field byte2
    LwU32            reservedbits6:8;
    
    // LwU32   bit-field byte3
    LwU32            isDisableHighVBIOverride:1;
    LwU32            isDisableAuthentication:1;
    LwU32            isNBInternalPanel:1;
    LwU32            isBrowserStereoApp:1;
    LwU32            isBrowserPhotoApp:1;
    LwU32            isInDWM:1;                //!< current process is DWM
    LwU32            isBulkLicense:1;
    LwU32            isUserLicense:1;
    // LwU32   bit-field byte4
    LwU32            reservedbits4:8;
    
    LwU32           reserved3;
    
    // FS/Windowed, Aero ON/OFF
    // LwU32   bit-field byte1
    LwU32            isFullscreen:1;          
    LwU32            isAeroWindowModeEnabled:1;
    LwU32            isGDIWindowModeEnabled:1;
    LwU32            isAeroWindowModeActivated:1;
    LwU32            isGDIWindowModeActivated:1;
    LwU32            reservedBits4:3;
    
    // LwU32   bit-field byte2,3,4
    LwU32            reservedbits5:24;

    LwU32           reserved4;

    LwU32           browserType;
    
    // Swapchain parameters
    LwU32           primaryWidth;
    LwU32           primaryHeight;
    LwU32           primaryRR;
    LwU32           primaryFormat;
    LwU32           numStereoSwapChain;
    
    // used for silverlight streaming
    LwU32           lwrrentVideoWidth;
    LwU32           lwrrentVideoHeight;
    LwU32           reserved5;
    
   // Misc params
    LwU32           uFPS;
    LwU32           refreshRateOverride;
    LwU32           monitorHead;
    LwU32           originalRefreshRate;
    LwU32           stereoDesktopCount;
    LwU32           persistentStereoDesktop;
    LwU32           delayedStereoDesktop;
    LwU32           reserved6;
   // Display parameters
    LwU32           displayWidth;
    LwU32           displayHeight;
    LwU32           targetDisplayCount;

    LwU32           reserved7[20];
}LW_STEREO_APP_INFO_DX9;

//! See LwAPI_Stereo_GetAppInfo().
//! DX10+ app information
typedef struct _LW_STEREO_APP_INFO_DX10
{
    // LwU32   bit-field byte1
    LwU32                        reservedbits9:8;
    // LwU32   bit-field byte2
    LwU32                        isLwStereoEnabled:1;
    LwU32                        isDxStereoEnabled:1;
    LwU32                        isAnaglyphOnly:1;
    LwU32                        isStereoActivated:1;     //!< Stereo is lwrrently activated.
    LwU32                        isSLIDisabled:1;
    LwU32                        isStereoEnabledInRegistry:1;    
    LwU32                        isAeroWindowedModeEnabled:1;
    LwU32                        isAeroWindowedModeActive:1;
    // LwU32   bit-field byte3
    LwU32                        isStereoDesktopCreationDelayed:1;
    LwU32                        isAeroEnabled:1;      
    LwU32                        isBrowserStereoApp:1; 
    LwU32                        isFirefoxHTML5:1;
    LwU32                        isIE9HTML5:1;
    LwU32                        isGameProfiled:1;
    LwU32                        reservedBits1:2; 
    // LwU32   bit-field byte4
    LwU32                        reservedbits2:8;
 
    LwU32                       reserved1;

    LwU32                       html5FFWidth ;     
    LwU32                       html5FFHeight ;  
    LwU32                       browserType ;      
    LwU32                       fireFoxLayout;   
    LwU32                       reserved2;
    // Application resources info
    LwU32                       primaryFormat;
    LwU32                       primaryWidth;
    LwU32                       primaryHeight;

    LwU32                       primaryRR;
    LwU32                       origAeroRefreshRate;

    LwU32                       numStereoSwapChain;
    LwU32                       reserved3;

    LwU32                       stereoHWType;       //!< Stereo Viewer HW type.
    // LwU32   bit-field byte1
    LwU32                        reservedbits10:8;
    
    // LwU32   bit-field byte2
    LwU32                        isDLPStereo:1;
    LwU32                        isAnaglypthStereo:1;
    LwU32                        isAutoStereo:1;
    LwU32                        isHDMIStereo:1;
    LwU32                        isHDMIAllowed:1;
    LwU32                        isHDMISupported:1;
    LwU32                        isHDMIProtected:1;
    LwU32                        isHDMIWindowed:1;
    // LwU32   bit-field byte3
    LwU32                        isHDMINotificationDone:1;
    LwU32                        isHDMIWARsApplied:1;
    LwU32                        isHDMI3DEnabled:1;
    LwU32                        isFullLicense:1;
    LwU32                        isTestLicense:1;
    LwU32                        isNB:1;
    LwU32                        isQuadro:1;
    LwU32                        isPanelReleased:1;
    // LwU32   bit-field byte4
    LwU32                        isBulkLicense:1;
    LwU32                        isUserLicense:1;
    LwU32                        reservedbits3:6;
    
    LwU32                       reserved4;

    LwU32                       state;                //!< stereo state flags, used by on() and off()

    LwU32                        appRealName[128];     //!< Same asszAppName (if not a symbolic link).
    LwU32                       stereoMode;

    LwU32                       stereoVSConst;
    LwU32                       numStereoVS;          //!< number of stereo Stereo VS has been created
    LwU32                       reserved5;
    
    // LwU32   bit-field byte1
    LwU32                        reservedbits4:8;
    // LwU32   bit-field byte2
    LwU32                        isClonedMode:1;
    LwU32                        isStereoBroadcastSLI:1;
    LwU32                        doNotStartInStereoOnInit:1; //!< trackStartInStereo state derived from settings for first activate
    LwU32                        isStereoTextureEnabled:1;
    LwU32                        isStereoSmallTexturesEnabled:1;
    LwU32                        isStereoSmallTexturesEnabledOnlyForRGB10A2:1;
    LwU32                        isEnableVerticalOrientedTextures:1;
    LwU32                        isStereoSquareTexturesEnabled:1;
    // LwU32   bit-field byte3
    LwU32                        isDisableSmallSquareStereoTextures:1;
    LwU32                        isDisableBBSeparationIfStereoTexureInUse:1;
    LwU32                        isDisableBBSeparationCompletely:1;
    LwU32                        isStereoPlaneRTEnabled:1;
    LwU32                        isDisableStereoGSShader:1;  //!< deleteme: temporary dirty hack for CoJ_DX10
    LwU32                        isDisableSeparationWithoutZB:1;
    LwU32                        isDisableTexSeparationIfStereoTexureInUse:1;
    LwU32                        isStereoSmallTexturesDisabledForRGBA8:1;
    // LwU32   bit-field byte4
    LwU32                        isEnableVSStereoShadersWithoutConst:1;
    LwU32                        isEnableDSStereoShadersWithoutConst:1;
    LwU32                        isEnableGSStereoShadersWithoutConst:1;
    LwU32                        isWasLastDrawCallStereoized:1;//!< Intended only for debug use [Bug 755091]

    LwU32                        isDisplayIdentified:1;
    LwU32                        isDisplayReleased:1;

    LwU32                        isSandBox:1;
    LwU32                        reservedbits6:1;
    // LwU32   bit-field byte1
    LwU32                        reservedbits7:8;
    // LwU32   bit-field byte2
    LwU32                        reservedbits11:8;

    // LwU32   bit-field byte3
    LwU32                        isDisableHighVBIOverride:1;
    LwU32                        isDisableAuthentication:1;
    LwU32                        isNotInFullScreen:1;
    LwU32                        isNBInternalPanel:1;
    LwU32                        allowWindowedOnGDIStereo:1;
    LwU32                        activeWindowedOnGDIStereo:1;
    LwU32                        isPersistentMode:1;//!< Are we lwrrently in persistent mode. Lwrrently, means persistent regkey is set.
    LwU32                        isForcedPersistence:1;//!< Represents forced persistency even if regkey is not set. Used in HDMI1.4 case.
    // LwU32   bit-field byte4
    LwU32                        reservedbits8:8;
    
    // LwU32   bit-field byte1,2,3,4
    LwU32                        reservedbits12:32;
    
    LwU32                       reserved6[3];

    LwU32                       stereoConfig;       //!< reflects the last config sucessfully sent to KMD 

    LwU32                       refreshRateOverride;
    LwU32                       defaultRefreshRate;

    LwU32                       surfaceCreateMode;//!< Mode in which surfaces will be created [Bug 718493]
    LwU32                       failToSetHighVBIDueToLackOfMonitor;
    LwU32                       totalDisplaysInSys;

    LwU32                       origRefreshRate;       //!< The primary display's refresh rate upon DX device creation.
    LwU32                       reserved7[20];
}LW_STEREO_APP_INFO_DX10;

//! See LwAPI_Stereo_GetAppInfo().
typedef struct _LW_STEREO_APP_INFO
{
    LwU32 dxVersion; //!< DX Version
    LwU32 processId; //!< PRocess ID
    LwU32 reserved[2];
    union
    {
        LwU8 appData[LW_STEREO_APP_INFO_SIZE];
        LW_STEREO_APP_INFO_DX9  dx9;
        LW_STEREO_APP_INFO_DX10 dx10;
    };
}LW_STEREO_APP_INFO;

//! See LwAPI_Stereo_GetAppInfo().
//! Stereo app info.
typedef struct  _LW_STEREO_DIAG_APP_INFO
{
    LwU32                           version;        //!< (IN) Stereo get app info version
    LwU32                           reserved1;
    LwU32                           appCount;       //!< (IN,OUT) App count(No of apps/device 
                                                    //!< that have diagnostic info updated
    LwU32                           appDataSize;    //!< (IN) App diag info size
    LW_STEREO_APP_INFO              info[LW_STEREO_INFO_MAX_APPS]; //!< (OUT) App diag info of all apps
    LwU32                           reserved2[10];
} LW_STEREO_DIAG_APP_INFO;

//! @}

//! \ingroup stereoapi
LWAPI_INTERFACE LwAPI_Stereo_GetAppInfo(__in LwDisplayHandle hLwDisplay, __inout LW_STEREO_DIAG_APP_INFO *pStereoInfo);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_CreateConfigurationProfileRegistryKey
//
//! \fn LwAPI_Stereo_CreateConfigurationProfileRegistryKey(LW_STEREO_REGISTRY_PROFILE_TYPE registryProfileType)
//!
//! DESCRIPTION:   Creates new configuration registry key for current application.
//!
//!                If there is no configuration profile prior to the function call,
//!                this API tries to create a new configuration profile registry key
//!                for a given application and fill it with the default values.
//!                If an application already has a configuration profile registry key, the API does nothing.
//!                The name of the key is automatically set to the name of the exelwtable that calls this function.
//!                Because of this, the exelwtable should have a distinct and unique name.
//!                If the application is using only one version of DirectX, then the default profile type will be appropriate.
//!                If the application is using more than one version of DirectX from the same exelwtable,
//!                it should use the appropriate profile type for each configuration profile.
//!
//! HOW TO USE:    When there is a need for an application to have default stereo parameter values,
//!                use this function to create a key to store the values.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]    registryProfileType  Type of profile the application wants to create. It should be one of the symbolic constants defined in
//!                                     ::LW_STEREO_REGISTRY_PROFILE_TYPE. Any other value will cause function to do nothing and return
//!                                     ::LW_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED.
//!
//! \retval ::LWAPI_OK                                           Key exists in the registry.
//! \retval ::LWAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED   This profile type is not supported.
//! \retval ::LWAPI_STEREO_REGISTRY_ACCESS_FAILED                Access to registry failed.
//! \retval ::LWAPI_API_NOT_INTIALIZED           
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED                       Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR 
//!
///////////////////////////////////////////////////////////////////////////////


//! \ingroup stereoapi
//! Used in LwAPI_Stereo_CreateConfigurationProfileRegistryKey() 
typedef enum _LW_StereoRegistryProfileType
{
    LWAPI_STEREO_DEFAULT_REGISTRY_PROFILE, //!< Default registry configuration profile.
    LWAPI_STEREO_DX9_REGISTRY_PROFILE,     //!< Separate registry configuration profile for a DirectX 9 exelwtable.
    LWAPI_STEREO_DX10_REGISTRY_PROFILE     //!< Separate registry configuration profile for a DirectX 10 exelwtable.
} LW_STEREO_REGISTRY_PROFILE_TYPE;


//! \ingroup stereoapi
LWAPI_INTERFACE LwAPI_Stereo_CreateConfigurationProfileRegistryKey(LW_STEREO_REGISTRY_PROFILE_TYPE registryProfileType);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_DeleteConfigurationProfileRegistryKey
//
//! DESCRIPTION:   Removes configuration registry key for current application.
//!
//!                If an application already has a configuration profile prior to this function call,
//!                the function attempts to remove the application's configuration profile registry key from the registry.
//!                If there is no configuration profile registry key prior to the function call,
//!                the function does nothing and does not report an error.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]   registryProfileType   Type of profile that the application wants to delete. This should be one of the symbolic 
//!                                     constants defined in ::LW_STEREO_REGISTRY_PROFILE_TYPE. Any other value will cause the function 
//!                                     to do nothing and return ::LW_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED.
//!
//! \retval ::LWAPI_OK                                           Key does not exist in the registry any more.
//! \retval ::LWAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED   This profile type is not supported.
//! \retval ::LWAPI_STEREO_REGISTRY_ACCESS_FAILED                Access to registry failed.
//! \retval ::LWAPI_API_NOT_INTIALIZED                           LWAPI is not initialized.
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED                       Stereo part of LWAPI is not initialized.
//! \retval ::LWAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_DeleteConfigurationProfileRegistryKey(LW_STEREO_REGISTRY_PROFILE_TYPE registryProfileType);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_SetConfigurationProfileValue
//
//! \fn LwAPI_Stereo_SetConfigurationProfileValue(LW_STEREO_REGISTRY_PROFILE_TYPE registryProfileType, LW_STEREO_REGISTRY_ID valueRegistryID, void *pValue)
//!
//! DESCRIPTION:   This API sets the given parameter value under the application's registry key.
//!
//!                If the value does not exist under the application's registry key,
//!                the value will be created under the key.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     registryProfileType  The type of profile the application wants to access. It should be one of the 
//!                                      symbolic constants defined in ::LW_STEREO_REGISTRY_PROFILE_TYPE. Any other value 
//!                                      will cause function to do nothing and return ::LW_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED.
//! \param [in]     valueRegistryID      ID of the value that is being set. It should be one of the symbolic constants defined in
//!                                      ::LW_STEREO_REGISTRY_PROFILE_TYPE. Any other value will cause function to do nothing
//!                                      and return ::LWAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED.
//! \param [in]     pValue               Address of the value that is being set. It should be either address of a DWORD or of a float,
//!                                      dependent on the type of the stereo parameter whose value is being set. The API will then cast that
//!                                      address to DWORD* and write whatever is in those 4 bytes as a DWORD to the registry.
//!
//! \retval ::LWAPI_OK                                           Value is written to registry.
//! \retval ::LWAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED   This profile type is not supported.
//! \retval ::LWAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED          This value is not supported.
//! \retval ::LWAPI_STEREO_REGISTRY_ACCESS_FAILED                Access to registry failed.
//! \retval ::LWAPI_API_NOT_INTIALIZED                           LWAPI is not initialized.
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED                       Stereo part of LWAPI is not initialized.
//! \retval ::LWAPI_ERROR                                        Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup stereoapi
//! Used in LwAPI_Stereo_SetConfigurationProfileValue()
typedef enum _LW_StereoRegistryID
{
    LWAPI_COLWERGENCE_ID,         //!< Symbolic constant for colwergence registry ID.
    LWAPI_FRUSTUM_ADJUST_MODE_ID, //!< Symbolic constant for frustum adjust mode registry ID.
} LW_STEREO_REGISTRY_ID;


//! \ingroup stereoapi
LWAPI_INTERFACE LwAPI_Stereo_SetConfigurationProfileValue(LW_STEREO_REGISTRY_PROFILE_TYPE registryProfileType, LW_STEREO_REGISTRY_ID valueRegistryID, void *pValue);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_DeleteConfigurationProfileValue
//
//! DESCRIPTION:   This API removes the given value from the application's configuration profile registry key.
//!                If there is no such value, the function does nothing and does not report an error.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     registryProfileType   The type of profile the application wants to access. It should be one of the 
//!                                       symbolic constants defined in ::LW_STEREO_REGISTRY_PROFILE_TYPE. Any other value will 
//!                                       cause function to do nothing and return ::LW_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED.
//! \param [in]     valueRegistryID       ID of the value that is being deleted. It should be one of the symbolic constants defined in
//!                                       ::LW_STEREO_REGISTRY_PROFILE_TYPE. Any other value will cause function to do nothing and return
//!                                       ::LWAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED.
//!
//! \retval ::LWAPI_OK                                           Value does not exist in registry any more.
//! \retval ::LWAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED   This profile type is not supported.
//! \retval ::LWAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED          This value is not supported.
//! \retval ::LWAPI_STEREO_REGISTRY_ACCESS_FAILED                Access to registry failed.
//! \retval ::LWAPI_API_NOT_INTIALIZED 
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED                       Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_DeleteConfigurationProfileValue(LW_STEREO_REGISTRY_PROFILE_TYPE registryProfileType, LW_STEREO_REGISTRY_ID valueRegistryID);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_Enable
//
//! DESCRIPTION:   This APU enables stereo mode in the registry.
//!                Calls to this function affect the entire system.
//!                If stereo is not enabled, then calls to functions that require that stereo is enabled have no effect,
//!                and will return the appropriate error code.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \retval ::LWAPI_OK                      Stereo is now enabled.
//! \retval ::LWAPI_API_NOT_INTIALIZED 
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED  Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_Enable(void);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_Disable
//
//! DESCRIPTION:   This API disables stereo mode in the registry.
//!                Calls to this function affect the entire system.
//!                If stereo is not enabled, then calls to functions that require that stereo is enabled have no effect,
//!                and will return the appropriate error code.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \retval ::LWAPI_OK                     Stereo is now disabled.
//! \retval ::LWAPI_API_NOT_INTIALIZED  
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR 
//!
//! \ingroup stereoapi 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_Disable(void);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_IsEnabled
//
//! DESCRIPTION:   This API checks if stereo mode is enabled in the registry.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [out]     pIsStereoEnabled   Address where the result of the inquiry will be placed.
//!
//! \retval ::LWAPI_OK                       Check was sucessfully completed and result reflects current state of stereo availability.
//! \retval ::LWAPI_API_NOT_INTIALIZED 
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED   Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_IsEnabled(LwU8 *pIsStereoEnabled);


//! \ingroup stereoapi
//! windowed-mode stereo modes
typedef enum _LWAPI_STEREO_WINDOWED_MODE
{
    WINDOWED_MODE_STEREO_OFF            = 0,  //!< Windowed mode stereo is off.
    WINDOWED_MODE_STEREO_AUTOMATIC      = 1,  //!< Desktop is in mono mode by default, but will automatically switch to a stereo mode when a stereo application launches.
    WINDOWED_MODE_STEREO_PERSISTENT     = 2,  //!< Desktop stays in stereo mode by default, so appications will run in stereo mode without a mode switch.
} LWAPI_STEREO_WINDOWED_MODE;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_SetWindowedMode
//
//! DESCRIPTION:   This API enables/disables windowed stereo mode in the registry.
//!                It enters 120Hz High VBI mode and disables Aero by default.
//!                Calls to this function affect the entire system.
//!                It requires stereo to be enabled for any effect.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    modes    mode to set
//! \param [in]    flags    reserved for future use, must be 0 
//!
//! \retval ::LWAPI_OK
//! \retval ::LWAPI_API_NOT_INTIALIZED
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED
//! \retval ::LWAPI_ERROR
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_SetWindowedMode(LWAPI_STEREO_WINDOWED_MODE mode, LwU32 flags);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_GetWindowedMode
//
//! DESCRIPTION:   Ths API checks if windowed stereo is enabled in the registry.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [out]    pMode    Address where result of the inquiry will be placed.
//!
//! \retval ::LWAPI_OK
//! \retval ::LWAPI_API_NOT_INTIALIZED
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED
//! \retval ::LWAPI_ERROR
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_GetWindowedMode(LWAPI_STEREO_WINDOWED_MODE *pMode);



//! \addtogroup stereoapi
//! @{

typedef struct _LWAPI_STEREO_CAPS
{
    LwU32 version;
    LwU32 supportsWindowedModeOff        : 1;
    LwU32 supportsWindowedModeAutomatic  : 1;
    LwU32 supportsWindowedModePersistent : 1;
    LwU32 reserved                       : 29;  // must be 0
    LwU32 reserved2[3];                         // must be 0
} LWAPI_STEREO_CAPS_V1;

#define LWAPI_STEREO_CAPS_VER1  MAKE_LWAPI_VERSION(LWAPI_STEREO_CAPS,1)
#define LWAPI_STEREO_CAPS_VER   LWAPI_STEREO_CAPS_VER1

typedef LWAPI_STEREO_CAPS_V1    LWAPI_STEREO_CAPS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_GetStereoSupport
//
//! DESCRIPTION:  This API checks what kind of stereo support is lwrrently supported on a particular display.
//!               If the the display is prohibited from showing stereo (e.g. secondary in a multi-mon setup), we will 
//!               return 0 for all stereo modes (full screen exclusive, automatic windowed, persistent windowed).
//!               Otherwise, we will check which stereo mode is supported. On 120Hz display, this will be what
//!               the user chooses in control panel. On HDMI 1.4 display, persistent windowed mode is always assumed to be
//!               supported. Note that this function does not check if the CURRENT RESOLUTION/REFRESH RATE can support
//!               stereo. For HDMI 1.4, it is the app's responsibility to change the resolution/refresh rate to one that is
//!               3D compatible. For 120Hz, the driver will ALWAYS force 120Hz anyway.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 304
//!
//! \param [in]     hMonitor handle to monitor that app is going to run on
//! \param [out]    pCaps    Address where the result of the inquiry will be placed.
//!                          *pCaps is defined in LWAPI_STEREO_CAPS.
//! \return       This API can return any of the following error codes enumerated in #LwAPI_Status
//! \retval ::LWAPI_OK
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_GetStereoSupport(__in LwMonitorHandle hMonitor, __out LWAPI_STEREO_CAPS *pCaps);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_GetStereoCaps
//
//! DESCRIPTION:   This API checks if the system is capable of stereo features, e.g., windowed mode stereo.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [out]    pCaps    Address where the result of the inquiry will be placed.
//!                           *pCaps is defined in LWAPI_STEREO_CAPS.
//!
//! \retval ::LWAPI_OK
//! \retval ::LWAPI_API_NOT_INTIALIZED
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED
//! \retval ::LWAPI_ERROR
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_GetStereoCaps(LWAPI_STEREO_CAPS *pCaps);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_GetStereoCapsInternal
//
//! DESCRIPTION:   This API checks if the system is capable of stereo features, e.g., windowed mode stereo.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [out]     pCaps   Address where the result of the inquiry will be placed.
//!                          *pCaps is defined in LWAPI_STEREO_CAPS.
//!
//! \retval ::LWAPI_OK
//! \retval ::LWAPI_API_NOT_INTIALIZED
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED
//! \retval ::LWAPI_ERROR
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_GetStereoCapsInternal(LWAPI_STEREO_CAPS *pCaps);



#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_CreateHandleFromIUnknown
//
//! DESCRIPTION:   This API creates a stereo handle that is used in subsequent calls related to a given device interface.
//!                This must be called before any other LwAPI_Stereo_ function for that handle.
//!                Multiple devices can be used at one time using multiple calls to this function (one per each device). 
//!
//! HOW TO USE:    After the Direct3D device is created, create the stereo handle.
//!                On call success:
//!                -# Use all other LwAPI_Stereo_ functions that have stereo handle as first parameter.
//!                -# After the device interface that corresponds to the the stereo handle is destroyed,
//!                the application should call LwAPI_DestroyStereoHandle() for that stereo handle. 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate LwAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     pDevice        Pointer to IUnknown interface that is IDirect3DDevice9* in DX9, ID3D10Device*.
//! \param [out]    pStereoHandle  Pointer to the newly created stereo handle.
//!
//! \retval ::LWAPI_OK                       Stereo handle is created for given device interface.
//! \retval ::LWAPI_ILWALID_ARGUMENT         Provided device interface is invalid.
//! \retval ::LWAPI_API_NOT_INTIALIZED  
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED   Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_CreateHandleFromIUnknown(IUnknown *pDevice, StereoHandle *pStereoHandle);

#endif // defined(_D3D9_H_) || defined(__d3d10_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_DestroyHandle
//
//! DESCRIPTION:   This API destroys the stereo handle created with one of the LwAPI_Stereo_CreateHandleFrom() functions.
//!                This should be called after the device corresponding to the handle has been destroyed.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     stereoHandle  Stereo handle that is to be destroyed.
//!
//! \retval ::LWAPI_OK                      Stereo handle is destroyed.
//! \retval ::LWAPI_API_NOT_INTIALIZED      
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED  Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR                   
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_DestroyHandle(StereoHandle stereoHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_Activate
//
//! DESCRIPTION:   This API activates stereo for the device interface corresponding to the given stereo handle.
//!                Activating stereo is possible only if stereo was enabled previously in the registry.
//!                If stereo is not activated, then calls to functions that require that stereo is activated have no effect,
//!                and will return the appropriate error code. 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate LwAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]    stereoHandle  Stereo handle corresponding to the device interface.
//!
//! \retval ::LWAPI_OK                                Stereo is turned on.
//! \retval ::LWAPI_STEREO_ILWALID_DEVICE_INTERFACE   Device interface is not valid. Create again, then attach again.
//! \retval ::LWAPI_API_NOT_INTIALIZED 
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED            Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_Activate(StereoHandle stereoHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_Deactivate
//
//! DESCRIPTION:   This API deactivates stereo for the given device interface.
//!                If stereo is not activated, then calls to functions that require that stereo is activated have no effect,
//!                and will return the appropriate error code. 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate LwAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     stereoHandle  Stereo handle that corresponds to the device interface.
//!
//! \retval ::LWAPI_OK                               Stereo is turned off.
//! \retval ::LWAPI_STEREO_ILWALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.
//! \retval ::LWAPI_API_NOT_INTIALIZED 
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED           Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_Deactivate(StereoHandle stereoHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_IsActivated
//
//! DESCRIPTION:   This API checks if stereo is activated for the given device interface. 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate LwAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]    stereoHandle  Stereo handle that corresponds to the device interface.
//! \param [in]    pIsStereoOn   Address where result of the inquiry will be placed.
//! 
//! \retval ::LWAPI_OK - Check was sucessfully completed and result reflects current state of stereo (on/off).
//! \retval ::LWAPI_STEREO_ILWALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//! \retval ::LWAPI_API_NOT_INTIALIZED - LWAPI not initialized.
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED - Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR - Something is wrong (generic error).
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_IsActivated(StereoHandle stereoHandle, LwU8 *pIsStereoOn);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_GetSeparation
//
//! DESCRIPTION:   This API gets current separation value (in percents). 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate LwAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     stereoHandle           Stereo handle that corresponds to the device interface.
//! \param [out]    pSeparationPercentage  Address of @c float type variable to store current separation percentage in.
//!
//! \retval ::LWAPI_OK                                Retrieval of separation percentage was successfull.
//! \retval ::LWAPI_STEREO_ILWALID_DEVICE_INTERFACE   Device interface is not valid. Create again, then attach again.
//! \retval ::LWAPI_API_NOT_INTIALIZED  
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED            Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR  
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_GetSeparation(StereoHandle stereoHandle, float *pSeparationPercentage);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_SetSeparation
//
//! DESCRIPTION:   This API sets separation to given percentage. 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to appropriate LwAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     stereoHandle             Stereo handle that corresponds to the device interface.
//! \param [in]     newSeparationPercentage  New value for separation percentage.
//!
//! \retval ::LWAPI_OK                               Setting of separation percentage was successfull.
//! \retval ::LWAPI_STEREO_ILWALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.
//! \retval ::LWAPI_API_NOT_INTIALIZED               LWAPI not initialized.
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED           Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_STEREO_PARAMETER_OUT_OF_RANGE    Given separation percentage is out of [0..100] range.
//! \retval ::LWAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_SetSeparation(StereoHandle stereoHandle, float newSeparationPercentage);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_DecreaseSeparation
//
//! DESCRIPTION:   This API decreases separation for the given device interface (just like the Ctrl+F3 hotkey). 
//!
//! WHEN TO USE:   After the stereo handle for device interface is created via successfull call to the appropriate LwAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]   stereoHandle  Stereo handle that corresponds to the device interface.
//!
//! \retval ::LWAPI_OK - Decrease of separation percentage was successfull.
//! \retval ::LWAPI_STEREO_ILWALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//! \retval ::LWAPI_API_NOT_INTIALIZED - LWAPI not initialized.
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED - Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR - Something is wrong (generic error).
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_DecreaseSeparation(StereoHandle stereoHandle);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_IncreaseSeparation
//
//! DESCRIPTION:   This API increases separation for the given device interface (just like the Ctrl+F4 hotkey).
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate LwAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]    stereoHandle  Stereo handle that corresponds to the device interface.
//!
//! \retval ::LWAPI_OK                               Increase of separation percentage was successfull.
//! \retval ::LWAPI_STEREO_ILWALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.
//! \retval ::LWAPI_API_NOT_INTIALIZED               LWAPI not initialized.
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED           Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR                            Something is wrong (generic error).
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_IncreaseSeparation(StereoHandle stereoHandle);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_GetColwergence
//
//! DESCRIPTION:   This API gets the current colwergence value.
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate LwAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     stereoHandle   Stereo handle that corresponds to the device interface.
//! \param [out]    pColwergence   Address of @c float type variable to store current colwergence value in.
//!
//! \retval ::LWAPI_OK                               Retrieval of colwergence value was successfull.
//! \retval ::LWAPI_STEREO_ILWALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.
//! \retval ::LWAPI_API_NOT_INTIALIZED  
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED           Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_GetColwergence(StereoHandle stereoHandle, float *pColwergence);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_SetColwergence
//
//! DESCRIPTION:   This API sets colwergence to the given value.
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate LwAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     stereoHandle              Stereo handle that corresponds to the device interface.
//! \param [in]     newColwergence            New value for colwergence.
//! 
//! \retval ::LWAPI_OK                                Setting of colwergence value was successfull.
//! \retval ::LWAPI_STEREO_ILWALID_DEVICE_INTERFACE   Device interface is not valid. Create again, then attach again.
//! \retval ::LWAPI_API_NOT_INTIALIZED  
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED            Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_SetColwergence(StereoHandle stereoHandle, float newColwergence);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_DecreaseColwergence
//
//! DESCRIPTION:   This API decreases colwergence for the given device interface (just like the Ctrl+F5 hotkey). 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate LwAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     stereoHandle  Stereo handle that corresponds to the device interface.
//!
//! \retval ::LWAPI_OK - Decrease of colwergence was successfull.
//! \retval ::LWAPI_STEREO_ILWALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//! \retval ::LWAPI_API_NOT_INTIALIZED - LWAPI not initialized.
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED - Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR - Something is wrong (generic error).
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_DecreaseColwergence(StereoHandle stereoHandle);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_IncreaseColwergence
//
//! DESCRIPTION:   This API increases colwergence for given the device interface (just like the Ctrl+F5 hotkey). 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate LwAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]    stereoHandle  Stereo handle that corresponds to the device interface.
//!
//! \retval ::LWAPI_OK                               Increase of colwergence was successfull.
//! \retval ::LWAPI_STEREO_ILWALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.
//! \retval ::LWAPI_API_NOT_INTIALIZED 
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED           Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_IncreaseColwergence(StereoHandle stereoHandle);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_GetFrustumAdjustMode
//
//! \fn LwAPI_Stereo_GetFrustumAdjustMode(StereoHandle stereoHandle, LW_FRUSTUM_ADJUST_MODE *pFrustumAdjustMode)
//! DESCRIPTION:   This API gets the current frustum adjust mode value. 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate LwAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     stereoHandle         Stereo handle that corresponds to the device interface.
//! \param [out]    pFrustumAdjustMode   Address of the LW_FRUSTUM_ADJUST_MODE type variable to store current frustum value in.
//!
//! \retval ::LWAPI_OK - Retrieval of frustum adjust mode was successfull.
//! \retval ::LWAPI_STEREO_ILWALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//! \retval ::LWAPI_API_NOT_INTIALIZED - LWAPI not initialized.
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED - Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR - Something is wrong (generic error).
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereoapi
//! Used in LwAPI_Stereo_GetFrustumAdjustMode().
typedef enum _LW_FrustumAdjustMode
{
    LWAPI_NO_FRUSTUM_ADJUST,    //!< Do not adjust frustum.
    LWAPI_FRUSTUM_STRETCH,      //!< Stretch images in X.
    LWAPI_FRUSTUM_CLEAR_EDGES   //!< Clear corresponding edges for each eye.
} LW_FRUSTUM_ADJUST_MODE;

//! \ingroup stereoapi
LWAPI_INTERFACE LwAPI_Stereo_GetFrustumAdjustMode(StereoHandle stereoHandle, LW_FRUSTUM_ADJUST_MODE *pFrustumAdjustMode);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_SetFrustumAdjustMode
//
//! DESCRIPTION:   This API sets the current frustum adjust mode value. 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate LwAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     stereoHandle                Stereo handle that corresponds to the device interface.
//! \param [in]     newFrustumAdjustModeValue   New value for frustum adjust mode. It should be one of the symbolic constants defined in
//!                                             ::LW_FRUSTUM_ADJUST_MODE. Any other value will cause function to do nothing and return
//!                                             ::LWAPI_STEREO_FRUSTUM_ADJUST_MODE_NOT_SUPPORTED.
//!
//! \retval ::LWAPI_OK                                         Retrieval of frustum adjust mode was successfull.
//! \retval ::LWAPI_STEREO_ILWALID_DEVICE_INTERFACE            Device interface is not valid. Create again, then attach again.
//! \retval ::LWAPI_API_NOT_INTIALIZED 
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED                     Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_STEREO_FRUSTUM_ADJUST_MODE_NOT_SUPPORTED   Given frustum adjust mode is not supported.
//! \retval ::LWAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_SetFrustumAdjustMode(StereoHandle stereoHandle, LW_FRUSTUM_ADJUST_MODE newFrustumAdjustModeValue);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_CaptureJpegImage
//
//! DESCRIPTION:   This API captures the current stereo image in JPEG stereo format with the given quality.
//!                Only the last capture call per flip will be effective. 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate LwAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     stereoHandle  Stereo handle that corresponds to the device interface.
//! \param [in]     quality        Quality of the JPEG image to be captured. Integer value betweeen 0 and 100.
//! 
//! \retval ::LWAPI_OK                              Image captured.
//! \retval ::LWAPI_STEREO_ILWALID_DEVICE_INTERFACE Device interface is not valid. Create again, then attach again.
//! \retval ::LWAPI_API_NOT_INTIALIZED 
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED 
//! \retval ::LWAPI_STEREO_PARAMETER_OUT_OF_RANGE   Given quality is out of [0..100] range.
//! \retval ::LWAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_CaptureJpegImage(StereoHandle stereoHandle, LwU32 quality);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_InitActivation
//
//! DESCRIPTION:   This API allows an application to enable stereo viewing, without the need of a GUID/Key pair
//!                This API cannot be used to enable stereo viewing on 3DTV.
//!
//! HOW TO USE:    Call this function immediately after device creation, then follow with a reset. \n 
//!                Very generically:
//!                Create Device->Create Stereo Handle->InitActivation->Reset Device
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \since Release: 302
//!
//! \param [in]   stereoHandle            Stereo handle corresponding to the device interface.
//! \param [in]   bDelayed                Use delayed activation
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, 
//!         they are listed below.
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED - Stereo part of LWAPI not initialized.
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup stereoapi
//! @{

//! InitActivation Flags
typedef enum _LWAPI_STEREO_INIT_ACTIVATION_FLAGS
{
    LWAPI_STEREO_INIT_ACTIVATION_IMMEDIATE = 0X00,
    LWAPI_STEREO_INIT_ACTIVATION_DELAYED = 0x01,
} LWAPI_STEREO_INIT_ACTIVATION_FLAGS;

LWAPI_INTERFACE LwAPI_Stereo_InitActivation(__in StereoHandle hStereoHandle, __in LWAPI_STEREO_INIT_ACTIVATION_FLAGS flags);

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_Trigger_Activation
//
//! DESCRIPTION:   This API allows an application to trigger creation of a stereo desktop, 
//!                in case the creation was stopped on application launch. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \since Release: 302
//!
//! \param [in]   stereoHandle   Stereo handle that corresponds to the device interface.
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, 
//!         they are listed below.
//! \retval ::LWAPI_STEREO_INIT_ACTIVATION_NOT_DONE - Stereo InitActivation not called.
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED - Stereo part of LWAPI not initialized.
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_Trigger_Activation(__in StereoHandle hStereoHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_CapturePngImage
//
//! DESCRIPTION:   This API captures the current stereo image in PNG stereo format.
//!                Only the last capture call per flip will be effective. 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate LwAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     stereoHandle  Stereo handle corresponding to the device interface.
//!
//! \retval ::LWAPI_OK                               Image captured.
//! \retval ::LWAPI_STEREO_ILWALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.
//! \retval ::LWAPI_API_NOT_INTIALIZED 
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED           Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_CapturePngImage(StereoHandle stereoHandle);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_ReverseStereoBlitControl
//
//! DESCRIPTION:   This API turns on/off reverse stereo blit.
//!
//! HOW TO USE:    Use after the stereo handle for the device interface is created via successfull call to the appropriate 
//!                LwAPI_Stereo_CreateHandleFrom() function.
//!                After reversed stereo blit control is turned on, blits from the stereo surface will
//!                produce the right-eye image in the left side of the destination surface and the left-eye
//!                image in the right side of the destination surface.
//!
//!                In DirectX 9, the destination surface must be created as the render target, and StretchRect must be used.
//!                Conditions:
//!                - DstWidth == 2*SrcWidth
//!                - DstHeight == SrcHeight
//!                - Src surface is the stereo surface.
//!                - SrcRect must be {0,0,SrcWidth,SrcHeight}
//!                - DstRect must be {0,0,DstWidth,DstHeight}
//!
//!                In DirectX 10, ResourceCopyRegion must be used. 
//!                Conditions:
//!                - DstWidth == 2*SrcWidth
//!                - DstHeight == SrcHeight
//!                - dstX == 0,
//!                - dstY == 0,
//!                - dstZ == 0,
//!                - SrcBox: left=top=front==0; right==SrcWidth; bottom==SrcHeight; back==1;
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]    stereoHandle  Stereo handle corresponding to the device interface.
//! \param [in]    TurnOn         != 0 : Turns on \n 
//!                               == 0 : Turns off 
//!
//!
//! \retval ::LWAPI_OK                                Retrieval of frustum adjust mode was successfull.
//! \retval ::LWAPI_STEREO_ILWALID_DEVICE_INTERFACE   Device interface is not valid. Create again, then attach again.
//! \retval ::LWAPI_API_NOT_INTIALIZED 
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED            Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_ReverseStereoBlitControl(StereoHandle hStereoHandle, LwU8 TurnOn);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_SetNotificationMessage
//
//! DESCRIPTION:   This API is a Setup notification message that the stereo driver uses to notify the application
//!                when the user changes the stereo driver state. 
//!
//!                When the user changes the stereo state (Activated or Deactivated, separation or colwersion)
//!                the stereo driver posts a defined message with the following parameters:
//!
//!                lParam  is the current colwersion. (Actual colwersion is *(float*)&lParam )
//!          
//!                wParam == MAKEWPARAM(l, h) where
//!                - l == 0 if stereo is deactivated
//!                - l == 1 if stereo is deactivated
//!                - h is the current separation. (Actual separation is float(h*100.f/0xFFFF)  
//!                
//!                Call this API with NULL hWnd to prohibit notification.
//!
//! WHEN TO USE:   Use after the stereo handle for device interface is created via successful call to appropriate
//!                LwAPI_Stereo_CreateHandleFrom() function.
//!                
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//!
//! \param [in]     stereoHandle  Stereo handle corresponding to the device interface.
//! \param [in]     hWnd          Window HWND that will be notified when the user changes the stereo driver state.
//!                               Actual HWND must be cast to an LwU64.
//! \param [in]     messageID     MessageID of the message that will be posted to hWnd
//!
//! \retval ::LWAPI_OK                                Notification set.
//! \retval ::LWAPI_STEREO_ILWALID_DEVICE_INTERFACE   Device interface is not valid. Create again, then attach again.
//! \retval ::LWAPI_API_NOT_INTIALIZED 
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED            Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_SetNotificationMessage(StereoHandle hStereoHandle, LwU64 hWnd,LwU64 messageID);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_SetActiveEye
//
//! \fn LwAPI_Stereo_SetActiveEye(StereoHandle hStereoHandle, LW_STEREO_ACTIVE_EYE StereoEye);
//! DESCRIPTION:   This API sets the back buffer to left or right in Direct stereo mode.
//!                  
//! HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate 
//!                LwAPI_Stereo_CreateHandleFrom function.
//!
//! \since Release: 285
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   stereoHandle  Stereo handle that corresponds to the device interface.
//! \param [in]   StereoEye     Defines active eye in Direct stereo mode
//!
//! \retval ::LWAPI_OK - Active eye is set.
//! \retval ::LWAPI_STEREO_ILWALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//! \retval ::LWAPI_API_NOT_INTIALIZED - LWAPI not initialized.
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED - Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ILWALID_ARGUMENT - StereoEye parameter has not allowed value.
//! \retval ::LWAPI_SET_NOT_ALLOWED  - Current stereo mode is not Direct
//! \retval ::LWAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereoapi
typedef enum _LW_StereoActiveEye
{
    LWAPI_STEREO_EYE_RIGHT = 1,
    LWAPI_STEREO_EYE_LEFT = 2,
    LWAPI_STEREO_EYE_MONO = 3,
} LW_STEREO_ACTIVE_EYE;

//! \ingroup stereoapi
LWAPI_INTERFACE LwAPI_Stereo_SetActiveEye(StereoHandle hStereoHandle, LW_STEREO_ACTIVE_EYE StereoEye);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_SetDriverMode
//
//! \fn LwAPI_Stereo_SetDriverMode( LW_STEREO_DRIVER_MODE mode );
//! DESCRIPTION:   This API sets the 3D stereo driver mode: Direct or Automatic
//!                  
//! HOW TO USE:    This API must be called before the device is created.
//!                Applies to DirectX 9 and higher.
//!
//! \since Release: 285
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!      
//! \param [in]    mode       Defines the 3D stereo driver mode: Direct or Automatic
//!
//! \retval ::LWAPI_OK                      Active eye is set.
//! \retval ::LWAPI_API_NOT_INTIALIZED      LWAPI not initialized.
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED  Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ILWALID_ARGUMENT        mode parameter has not allowed value.
//! \retval ::LWAPI_ERROR                   Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereoapi
typedef enum _LW_StereoDriverMode
{
    LWAPI_STEREO_DRIVER_MODE_AUTOMATIC = 0,
    LWAPI_STEREO_DRIVER_MODE_DIRECT    = 2,
} LW_STEREO_DRIVER_MODE;

//! \ingroup stereoapi
LWAPI_INTERFACE LwAPI_Stereo_SetDriverMode( LW_STEREO_DRIVER_MODE mode );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_GetEyeSeparation
//
//! DESCRIPTION:   This API returns eye separation as a ratio of <between eye distance>/<physical screen width>.
//! 
//! HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate API. Applies only to DirectX 9 and up.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   stereoHandle  Stereo handle that corresponds to the device interface.
//! \param [out]  pSeparation   Eye separation.
//!
//! \retval ::LWAPI_OK                               Active eye is set.
//! \retval ::LWAPI_STEREO_ILWALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.
//! \retval ::LWAPI_API_NOT_INTIALIZED               LWAPI not initialized.
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED           Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR  (generic error).
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_GetEyeSeparation(StereoHandle hStereoHandle,  float *pSeparation );

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_IsWindowedModeSupported
//
//! DESCRIPTION:   This API returns availability of windowed mode stereo
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [out] bSupported(OUT)    != 0  - supported,  \n
//!                                 == 0  - is not supported 
//!
//!
//! \retval ::LWAPI_OK                      Retrieval of frustum adjust mode was successfull.
//! \retval ::LWAPI_API_NOT_INTIALIZED      LWAPI not initialized.
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED  Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR                   Something is wrong (generic error).
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_IsWindowedModeSupported(LwU8* bSupported);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_SetVideoControl
//
//! \fn LwAPI_Stereo_SetVideoControl(StereoHandle hStereoHandle, LWAPI_STEREO_VIDEO_CONTROL* pStereoVideoControl)
//! \code
//! PARAMETERS:    stereoHandle(IN) - Stereo handle that corresponds to the device interface.
//!                pStereoVideoControl (IN) - pointer to struct LWAPI_STEREO_VIDEO_CONTROL
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION:   Sets the control parameters for stereo video
//!
//! HOW TO USE:
//!
//! RETURN STATUS:
//!                LWAPI_OK - Video control was successful
//!                LWAPI_API_NOT_INTIALIZED - LWAPI not initialized.
//!                LWAPI_STEREO_NOT_INITIALIZED - Stereo part of LWAPI not initialized.
//!                LWAPI_ERROR - Something is wrong (generic error).
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereoapi
typedef enum _STEREO_SRC_LAYOUT
{
    STEREO_SRC_LAYOUT_LEFT_RIGHT = 0,
    STEREO_SRC_LAYOUT_RIGHT_LEFT = 1,
    STEREO_SRC_LAYOUT_TOP_BOTTOM = 2,
    STEREO_SRC_LAYOUT_BOTTOM_TOP = 3,
    STEREO_SRC_LAYOUT_MONO_MODE  = 4,
    STEREO_SRC_LAYOUT_LAST       = 5 
} STEREO_SRC_LAYOUT;

//! \ingroup stereoapi
typedef struct _LWAPI_STEREO_VIDEO_CONTROL
{
    LwU32               dwVersion;             // struct version
    STEREO_SRC_LAYOUT   eStereoSrcLayout;
    LwU32               dwClientIdentifier;
    LwU32               dwStereoEnable;
} LWAPI_STEREO_VIDEO_CONTROL_V1;

//! \ingroup stereoapi
typedef LWAPI_STEREO_VIDEO_CONTROL_V1      LWAPI_STEREO_VIDEO_CONTROL;
//! \ingroup stereoapi
#define LWAPI_STEREO_VIDEO_CONTROL_VER1    MAKE_LWAPI_VERSION(LWAPI_STEREO_VIDEO_CONTROL_V1, 1)
//! \ingroup stereoapi
#define LWAPI_STEREO_VIDEO_CONTROL_VER     LWAPI_STEREO_VIDEO_CONTROL_VER1
//! \ingroup stereoapi
LWAPI_INTERFACE LwAPI_Stereo_SetVideoControl(StereoHandle hStereoHandle, LWAPI_STEREO_VIDEO_CONTROL* pStereoVideoControl);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_SetVideoMetadata
//
//! \fn LwAPI_Stereo_SetVideoMetadata(StereoHandle hStereoHandle, LWAPI_STEREO_VIDEO_METADATA* pStereoVideoMetadata)
//! \code
//! PARAMETERS:    stereoHandle(IN) - Stereo handle that corresponds to the device interface.
//!                pStereoVideoMetadata (IN) - pointer to struct LWAPI_STEREO_VIDEO_METADATA
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION:   Sets the available stereo video metadata
//!
//! HOW TO USE:
//!
//! RETURN STATUS:
//!                LWAPI_OK - Setting of video metadata was successful
//!                LWAPI_API_NOT_INTIALIZED - LWAPI not initialized.
//!                LWAPI_STEREO_NOT_INITIALIZED - Stereo part of LWAPI not initialized.
//!                LWAPI_ERROR - Something is wrong (generic error).
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereoapi
typedef struct _LWAPI_STEREO_VIDEO_METADATA
{
    LwU32               dwVersion;        // struct version
    LwU32               dwVideoWidth;
    LwU32               dwVideoHeight;
    LwU64               hSrcLuma;
    LwU64               hDst;
} LWAPI_STEREO_VIDEO_METADATA_V1;

//! \ingroup stereoapi
typedef LWAPI_STEREO_VIDEO_METADATA_V1      LWAPI_STEREO_VIDEO_METADATA;
//! \ingroup stereoapi
#define LWAPI_STEREO_VIDEO_METADATA_VER1    MAKE_LWAPI_VERSION(LWAPI_STEREO_VIDEO_METADATA_V1, 1)
//! \ingroup stereoapi
#define LWAPI_STEREO_VIDEO_METADATA_VER     LWAPI_STEREO_VIDEO_METADATA_VER1
//! \ingroup stereoapi
LWAPI_INTERFACE LwAPI_Stereo_SetVideoMetadata(StereoHandle hStereoHandle, LWAPI_STEREO_VIDEO_METADATA* pStereoVideoMetadata);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_AppHandShake
//
//! \fn LwAPI_Stereo_AppHandShake(StereoHandle hStereoHandle, LWAPI_STEREO_HANDSHAKE_PARAMS* pStereoHandshakeParams)
//! DESCRIPTION:   This API allows an approved application to enable stereo viewing through
//!                a handshake with the driver instead of via a hardcoded application exe name.
//!
//! HOW TO USE:    Call this function immediately after device creation, then follow with a reset. \n 
//!                Very generically:
//!                Create Device->Create Stereo Handle->Do Handshake->Reset Device
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   stereoHandle            Stereo handle corresponding to the device interface.
//! \param [in]   pStereoHandshakeParams  pointer to struct LWAPI_STEREO_HANDSHAKE_PARAMS
//!
//! \retval ::LWAPI_OK - completed request
//! \retval ::LWAPI_API_NOT_INTIALIZED - LWAPI not initialized.
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED - Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ILWALID_ARGUMENT - the vendor ID and/or response is invalid
//! \retval ::LWAPI_STEREO_HANDSHAKE_NOT_DONE - Stereo handshake failed
//! \retval ::LWAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup stereoapi
//! @{

//! Stereo Handshake Commands
typedef enum _LWAPI_STEREO_HANDSHAKE_COMMANDS
{
    LWAPI_STEREO_HANDSHAKE_CMD_CHALLENGE = 0x01,
    LWAPI_STEREO_HANDSHAKE_CMD_RESPONSE  = 0x02,
} LWAPI_STEREO_HANDSHAKE_COMMANDS;

//! Stereo Handshake Constants
#define LWAPI_STEREO_HANDSHAKE_CHALLENGE_SIZE     16
#define LWAPI_STEREO_HANDSHAKE_RESPONSE_SIZE      20

//
//! Parameter data structure for the LWAPI_STEREO_HANDSHAKE_CMD_CHALLENGE command:
//! This command requests a random challenge from driver.
//! It must be ilwoked before the LWAPI_STEREO_HANDSHAKE_CMD_RESPONSE command.
typedef struct _LWAPI_STEREO_HANDSHAKE_CHALLENGE_PARAMS
{
    LwU8 challenge[LWAPI_STEREO_HANDSHAKE_CHALLENGE_SIZE];    //!< random challenge from driver (OUT)
} LWAPI_STEREO_HANDSHAKE_CHALLENGE_PARAMS;

//
//! Parameter data structure for the LWAPI_STEREO_HANDSHAKE_CMD_RESPONSE command
//!
//! The application must possess the following information in order to callwlate a valid response:
//! - vendorGUID: a unique ID assigned to the application vendor by LWPU;
//! - vendorKEY:  a secret key issued to the application vendor by LWPU;
//!
//! The response is callwlated as HMAC(vendorKEY, (vendorGUID || challenge))
//! where HMAC is the Keyed-Hash Message Authentication Code using SHA-1 as the
//! underlying hash function. See FIPS Publication 198 for details of the algorithm.
typedef struct _LWAPI_STEREO_HANDSHAKE_RESPONSE_PARAMS
{
    LwGUID vendorGUID;                                          //!< vendor GUID from app (IN)
    LwU8   response[LWAPI_STEREO_HANDSHAKE_RESPONSE_SIZE];    //!< response from app (IN)
    LwU32  flags;                                               //!< Flags set by application (IN/OPTIONAL)
} LWAPI_STEREO_HANDSHAKE_RESPONSE_PARAMS;

typedef struct _LWAPI_STEREO_HANDSHAKE_PARAMS
{
    LwU32 version;                      //!< structure version (IN)
    LwU32 dwCommand;                    //!< command (IN)
    union
    {
        LWAPI_STEREO_HANDSHAKE_CHALLENGE_PARAMS   ChallengeParams;
        LWAPI_STEREO_HANDSHAKE_RESPONSE_PARAMS    ResponseParams;
    };
} LWAPI_STEREO_HANDSHAKE_PARAMS_V1;

typedef LWAPI_STEREO_HANDSHAKE_PARAMS_V1      LWAPI_STEREO_HANDSHAKE_PARAMS;
#define LWAPI_STEREO_HANDSHAKE_PARAMS_VER1    MAKE_LWAPI_VERSION(LWAPI_STEREO_HANDSHAKE_PARAMS_V1, 1)
#define LWAPI_STEREO_HANDSHAKE_PARAMS_VER     LWAPI_STEREO_HANDSHAKE_PARAMS_VER1

LWAPI_INTERFACE LwAPI_Stereo_AppHandShake(StereoHandle hStereoHandle, LWAPI_STEREO_HANDSHAKE_PARAMS* pStereoHandshakeParams);

//! @}




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_HandShake_Trigger_Activation
//
//! DESCRIPTION:   This API allows an approved application (approved through handshake) to 
//!                trigger creation of a stereo desktop, in case the creation was stopped on application
//!                launch. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   stereoHandle   Stereo handle that corresponds to the device interface.
//!
//! \retval ::LWAPI_OK - completed request
//! \retval ::LWAPI_STEREO_HANDSHAKE_NOT_DONE - Stereo handshake not done prior to call
//! \retval ::LWAPI_API_NOT_INTIALIZED - LWAPI not initialized.
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED - Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR - Something is wrong (generic error).
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_HandShake_Trigger_Activation(StereoHandle hStereoHandle);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_HandShake_Message_Control
//
//! DESCRIPTION:   This API allows an approved application (approved through handshake) to 
//!                turn on/off the stereo message displayed onscreen.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   stereoHandle  Stereo handle that corresponds to the device interface.
//! \param [in]   TurnOn       != 0  - turns on,
//!                              == 0  - turns off
//!
//! \retval ::LWAPI_OK - completed request
//! \retval ::LWAPI_STEREO_HANDSHAKE_NOT_DONE - Stereo handshake not done prior to call
//! \retval ::LWAPI_API_NOT_INTIALIZED - LWAPI not initialized.
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED - Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR - Something is wrong (generic error).
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_HandShake_Message_Control(StereoHandle hStereoHandle, LwU8 TurnOn);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_SetSurfaceCreationMode
//
//! \function LwAPI_Stereo_SetSurfaceCreationMode(StereoHandle hStereoHandle, LWAPI_STEREO_SURFACECREATEMODE creationMode)
//! \param [in]   hStereoHandle   Stereo handle that corresponds to the device interface.
//! \param [in]   creationMode    New surface creation mode for this device interface.
//!
//! \since Release: 285
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API sets surface creation mode for this device interface.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successful call to appropriate LwAPI_Stereo_CreateHandleFrom function.
//!
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//!              There are no return error codes with specific meaning for this API.
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereoapi
typedef enum _LWAPI_STEREO_SURFACECREATEMODE 
{
    LWAPI_STEREO_SURFACECREATEMODE_AUTO,        //!< Use driver registry profile settings for surface creation mode. 
    LWAPI_STEREO_SURFACECREATEMODE_FORCESTEREO, //!< Always create stereo surfaces. 
    LWAPI_STEREO_SURFACECREATEMODE_FORCEMONO    //!< Always create mono surfaces. 
} LWAPI_STEREO_SURFACECREATEMODE; 

//! \ingroup stereoapi
LWAPI_INTERFACE LwAPI_Stereo_SetSurfaceCreationMode(__in StereoHandle hStereoHandle, __in LWAPI_STEREO_SURFACECREATEMODE creationMode);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_GetSurfaceCreationMode
//
//! \function LwAPI_Stereo_GetSurfaceCreationMode(StereoHandle hStereoHandle, LWAPI_STEREO_SURFACECREATEMODE* pCreationMode)
//! \param [in]   hStereoHandle   Stereo handle that corresponds to the device interface.
//! \param [out]   pCreationMode   The current creation mode for this device interface.
//!
//! \since Release: 295
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API gets surface creation mode for this device interface.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successful call to appropriate LwAPI_Stereo_CreateHandleFrom function.
//!
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//!              There are no return error codes with specific meaning for this API.
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereoapi
LWAPI_INTERFACE LwAPI_Stereo_GetSurfaceCreationMode(__in StereoHandle hStereoHandle, __in LWAPI_STEREO_SURFACECREATEMODE* pCreationMode);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_Debug_WasLastDrawStereoized
//
//! \param [in]  hStereoHandle    Stereo handle that corresponds to the device interface.
//! \param [out] pWasStereoized   Address where result of the inquiry will be placed.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API checks if the last draw call was stereoized. It is a very expensive to call and should be used for debugging purpose *only*.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successful call to appropriate LwAPI_Stereo_CreateHandleFrom function.
//!
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//!              There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_Debug_WasLastDrawStereoized(__in StereoHandle hStereoHandle, __out LwU8 *pWasStereoized);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_ForceToScreenDepth
//
//! \param [in]  hStereoHandle         Stereo handle that corresponds to the device interface.
//! \param [in]  bForceToScreenDepth   New mode for rendering depth of objects 
//!                   #true all objects after this call will be rendered at screen depth; 
//!                   #false all objects after this call will be rendered at their intended depth; 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API forces objects to be rendered at screen depth (or at their intended depth).
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate LwAPI_Stereo_CreateHandleFrom function.
//!
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//!              There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_ForceToScreenDepth(__in StereoHandle hStereoHandle, __in LwU8 bForceToScreenDepth);



#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_SetVertexShaderConstantF
//
//! \param [in]  hStereoHandle         Stereo handle that corresponds to the device interface.
//! \param [in]  StartRegister         Register number that will contain the first constant value.
//! \param [in]  pConstantDataMono     Pointer to an array of constants for mono view.
//! \param [in]  pConstantDataLeft     Pointer to an array of constants for left eye view.
//! \param [in]  pConstantDataRight    Pointer to an array of constants for right eye view.
//! \param [in]  Vector4fCount         Number of four float vectors in the array of constants.
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//!              There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API specifies 3 sets of floating constants to be used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate LwAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_SetVertexShaderConstantF(__in StereoHandle hStereoHandle, __in UINT StartRegister, __in float *pConstantDataMono, __in float *pConstantDataLeft, __in float *pConstantDataRight, __in UINT Vector4fCount);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_SetVertexShaderConstantB
//
//! \param [in]  hStereoHandle         Stereo handle that corresponds to the device interface.
//! \param [in]  StartRegister         Register number that will contain the first constant value.
//! \param [in]  pConstantDataMono     Pointer to an array of constants for mono view.
//! \param [in]  pConstantDataLeft     Pointer to an array of constants for left eye view.
//! \param [in]  pConstantDataRight    Pointer to an array of constants for right eye view.
//! \param [in]  BoolCount             Number of boolean values in the array of constants.
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//!              There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API specifies 3 sets of boolean constants to be used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate LwAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_SetVertexShaderConstantB(__in StereoHandle hStereoHandle, __in UINT StartRegister, __in BOOL *pConstantDataMono, __in BOOL *pConstantDataLeft, __in BOOL *pConstantDataRight, __in UINT BoolCount);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_SetVertexShaderConstantI
//
//! \param [in]  hStereoHandle         Stereo handle that corresponds to the device interface.
//! \param [in]  StartRegister         Register number that will contain the first constant value.
//! \param [in]  pConstantDataMono     Pointer to an array of constants for mono view.
//! \param [in]  pConstantDataLeft     Pointer to an array of constants for left eye view.
//! \param [in]  pConstantDataRight    Pointer to an array of constants for right eye view.
//! \param [in]  Vector4iCount         Number of four integer vectors in the array of constants.
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//!              There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API specifies 3 sets of integer constants to be used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate LwAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_SetVertexShaderConstantI(__in StereoHandle hStereoHandle, __in UINT StartRegister, __in int *pConstantDataMono, __in int *pConstantDataLeft, __in int *pConstantDataRight, __in UINT Vector4iCount);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_GetVertexShaderConstantF
//
//! \param [in]      hStereoHandle      Stereo handle that corresponds to the device interface.
//! \param [in]      StartRegister      Register number that will contain the first constant value.
//! \param [in,out]  pConstantDataMono  Pointer to an array of constants for mono view.
//! \param [in,out]  pConstantDataLeft  Pointer to an array of constants for left eye view.
//! \param [in,out]  pConstantDataRight Pointer to an array of constants for right eye view.
//! \param [in]      Vector4fCount      Number of four float vectors in the array of constants.
//! \return          This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                  There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API returns 3 sets of floating constants that are used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate LwAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_GetVertexShaderConstantF(__in StereoHandle hStereoHandle, __in UINT StartRegister, __inout float *pConstantDataMono, __inout float *pConstantDataLeft, __inout float *pConstantDataRight, __in UINT Vector4fCount);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_GetVertexShaderConstantB
//
//! \param [in]      hStereoHandle      Stereo handle that corresponds to the device interface.
//! \param [in]      StartRegister      Register number that will contain the first constant value.
//! \param [in,out]  pConstantDataMono  Pointer to an array of constants for mono view.
//! \param [in,out]  pConstantDataLeft  Pointer to an array of constants for left eye view.
//! \param [in,out]  pConstantDataRight Pointer to an array of constants for right eye view.
//! \param [in]      BoolCount          Number of boolean values in the array of constants.
//! \return          This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                  There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API returns 3 sets of boolean constants that are used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate LwAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_GetVertexShaderConstantB(__in StereoHandle hStereoHandle, __in UINT StartRegister, __inout BOOL *pConstantDataMono, __inout BOOL *pConstantDataLeft, __inout BOOL *pConstantDataRight, __in UINT BoolCount);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_GetVertexShaderConstantI
//
//! \param [in]      hStereoHandle      Stereo handle that corresponds to the device interface.
//! \param [in]      StartRegister      Register number that will contain the first constant value.
//! \param [in,out]  pConstantDataMono  Pointer to an array of constants for mono view.
//! \param [in,out]  pConstantDataLeft  Pointer to an array of constants for left eye view.
//! \param [in,out]  pConstantDataRight Pointer to an array of constants for right eye view.
//! \param [in]      Vector4iCount      Number of four integer vectors in the array of constants.
//! \return          This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                  There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API returns 3 sets of integer constants that are used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate LwAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_GetVertexShaderConstantI(__in StereoHandle hStereoHandle, __in UINT StartRegister, __inout int *pConstantDataMono, __inout int *pConstantDataLeft, __inout int *pConstantDataRight, __in UINT Vector4iCount);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_SetPixelShaderConstantF
//
//! \param [in]  hStereoHandle         Stereo handle that corresponds to the device interface.
//! \param [in]  StartRegister         Register number that will contain the first constant value.
//! \param [in]  pConstantDataMono     Pointer to an array of constants for mono view.
//! \param [in]  pConstantDataLeft     Pointer to an array of constants for left eye view.
//! \param [in]  pConstantDataRight    Pointer to an array of constants for right eye view.
//! \param [in]  Vector4fCount         Number of four float vectors in the array of constants.
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//!              There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API specifies 3 sets of floating constants to be used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate LwAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_SetPixelShaderConstantF(__in StereoHandle hStereoHandle, __in UINT StartRegister, __in float *pConstantDataMono, __in float *pConstantDataLeft, __in float *pConstantDataRight, __in UINT Vector4fCount);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_SetPixelShaderConstantB
//
//! \param [in]  hStereoHandle         Stereo handle that corresponds to the device interface.
//! \param [in]  StartRegister         Register number that will contain the first constant value.
//! \param [in]  pConstantDataMono     Pointer to an array of constants for mono view.
//! \param [in]  pConstantDataLeft     Pointer to an array of constants for left eye view.
//! \param [in]  pConstantDataRight    Pointer to an array of constants for right eye view.
//! \param [in]  BoolCount             Number of boolean values in the array of constants.
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//!              There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API specifies 3 sets of boolean constants to be used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate LwAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_SetPixelShaderConstantB(__in StereoHandle hStereoHandle, __in UINT StartRegister, __in BOOL *pConstantDataMono, __in BOOL *pConstantDataLeft, __in BOOL *pConstantDataRight, __in UINT BoolCount);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_SetPixelShaderConstantI
//
//! \param [in]  hStereoHandle         Stereo handle that corresponds to the device interface.
//! \param [in]  StartRegister         Register number that will contain the first constant value.
//! \param [in]  pConstantDataMono     Pointer to an array of constants for mono view.
//! \param [in]  pConstantDataLeft     Pointer to an array of constants for left eye view.
//! \param [in]  pConstantDataRight    Pointer to an array of constants for right eye view.
//! \param [in]  Vector4iCount         Number of four integer vectors in the array of constants.
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//!              There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API specifies 3 sets of integer constants to be used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate LwAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_SetPixelShaderConstantI(__in StereoHandle hStereoHandle, __in UINT StartRegister, __in int *pConstantDataMono, __in int *pConstantDataLeft, __in int *pConstantDataRight, __in UINT Vector4iCount);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_GetPixelShaderConstantF
//
//! \param [in]      hStereoHandle      Stereo handle that corresponds to the device interface.
//! \param [in]      StartRegister      Register number that will contain the first constant value.
//! \param [in,out]  pConstantDataMono  Pointer to an array of constants for mono view.
//! \param [in,out]  pConstantDataLeft  Pointer to an array of constants for left eye view.
//! \param [in,out]  pConstantDataRight Pointer to an array of constants for right eye view.
//! \param [in]      Vector4fCount      Number of four float vectors in the array of constants.
//! \return          This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                  There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API returns 3 sets of floating constants that are used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate LwAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_GetPixelShaderConstantF(__in StereoHandle hStereoHandle, __in UINT StartRegister, __inout float *pConstantDataMono, __inout float *pConstantDataLeft, __inout float *pConstantDataRight, __in UINT Vector4fCount);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_GetPixelShaderConstantB
//
//! \param [in]      hStereoHandle      Stereo handle that corresponds to the device interface.
//! \param [in]      StartRegister      Register number that will contain the first constant value.
//! \param [in,out]  pConstantDataMono  Pointer to an array of constants for mono view.
//! \param [in,out]  pConstantDataLeft  Pointer to an array of constants for left eye view.
//! \param [in,out]  pConstantDataRight Pointer to an array of constants for right eye view.
//! \param [in]      BoolCount          Number of boolean values in the array of constants.
//! \return          This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                  There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API returns 3 sets of boolean constants that are used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate LwAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_GetPixelShaderConstantB(__in StereoHandle hStereoHandle, __in UINT StartRegister, __inout BOOL *pConstantDataMono, __inout BOOL *pConstantDataLeft, __inout BOOL *pConstantDataRight, __in UINT BoolCount);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_GetPixelShaderConstantI
//
//! \param [in]      hStereoHandle      Stereo handle that corresponds to the device interface.
//! \param [in]      StartRegister      Register number that will contain the first constant value.
//! \param [in,out]  pConstantDataMono  Pointer to an array of constants for mono view.
//! \param [in,out]  pConstantDataLeft  Pointer to an array of constants for left eye view.
//! \param [in,out]  pConstantDataRight Pointer to an array of constants for right eye view.
//! \param [in]      Vector4iCount      Number of four integer vectors in the array of constants.
//! \return          This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                  There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API returns 3 sets of integer constants that are used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate LwAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_GetPixelShaderConstantI(__in StereoHandle hStereoHandle, __in UINT StartRegister, __inout int *pConstantDataMono, __inout int *pConstantDataLeft, __inout int *pConstantDataRight, __in UINT Vector4iCount);

#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_SetDefaultProfile
//
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API defines the stereo profile used by the driver in case the application has no associated profile.
//!
//! WHEN TO USE: To take effect, this API must be called before D3D device is created. Calling once a device has been created will not affect the current device.
//!
//! \param [in]  szProfileName        Default profile name. 
//!                                 
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//!              Error codes specific to this API are described below.
//!              
//! \retval      LWAPI_SUCCESS                               - Default stereo profile name has been copied into szProfileName.
//! \retval      LWAPI_ILWALID_ARGUMENT                      - szProfileName == NULL.
//! \retval      LWAPI_DEFAULT_STEREO_PROFILE_DOES_NOT_EXIST - Default stereo profile does not exist
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_SetDefaultProfile(__in const char* szProfileName);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_GetDefaultProfile
//
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API retrieves the current default stereo profile.
//!              
//!              After call cbSizeOut contain 0 if default profile is not set required buffer size cbSizeOut.
//!              To get needed buffer size this function can be called with szProfileName==0 and cbSizeIn == 0. 
//!
//! WHEN TO USE: This API can be called at any time.
//!              
//!
//! \param [in]   cbSizeIn             Size of buffer allocated for default stereo profile name.                  
//! \param [out]  szProfileName        Default stereo profile name. 
//! \param [out]  pcbSizeOut           Required buffer size.
//!                     # ==0 - there is no default stereo profile name lwrrently set
//!                     # !=0 - size of buffer required for lwrrently set default stereo profile name including trailing '0'.
//!
//!
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//!              Error codes specific to this API are described below.
//! 
//! \retval      LWAPI_SUCCESS                                - Default stereo profile name has been copied into szProfileName.
//! \retval      LWAPI_DEFAULT_STEREO_PROFILE_IS_NOT_DEFINED  - There is no default stereo profile set at this time.
//! \retval      LWAPI_ILWALID_ARGUMENT                       - pcbSizeOut == 0 or cbSizeIn >= *pcbSizeOut && szProfileName == 0
//! \retval      LWAPI_INSUFFICIENT_BUFFER                    - cbSizeIn < *pcbSizeOut
//!  
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_GetDefaultProfile( __in LwU32 cbSizeIn, __out_bcount_part_opt(cbSizeIn, *pcbSizeOut) char* szProfileName,  __out LwU32 *pcbSizeOut);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_ModeEnumControl
//! \fn LwAPI_Stereo_ModeEnumControl(__inout LWAPI_STEREO_DONGLE_CONTROL* pStereoDongleControl)
//!
//! DESCRIPTION: This API exelwtes stereo mode enumeration control interface commands
//!
//! WHEN TO USE: This API can be called at any time.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [inout]  pStereoModeEnumControl    Pointer to a LWAPI_STEREO_MODE_ENUM_CONTROL structure containing input and output params
//!
//! \return    This API can return any of the error codes enumerated in #LwAPI_Status. 
//!
///////////////////////////////////////////////////////////////////////////////
//! \addtogroup stereoapi
//! @{

//! \ingroup stereoapi
typedef enum _STEREO_MODE_ENUM_CONTROL
{
    STEREO_MODE_ENUM_DISABLE    = 0,
    STEREO_MODE_ENUM_ENBALE     = 1,
    STEREO_MODE_ENUM_STATUS     = 2,

} STEREO_MODE_ENUM_CONTROL;

//! \ingroup stereoapi
typedef struct _LWAPI_STEREO_MODE_ENUM_CONTROL
{
    LwU32                           version;        //!< IN:  struct version
    STEREO_MODE_ENUM_CONTROL        command;        //!< IN:  Interface command for stereo mode enumeration control
    LwU32                           data;           //!< IN:  Data required for interface comamnd
} LWAPI_STEREO_MODE_ENUM_CONTROL;

//! \ingroup stereoapi
#define LWAPI_STEREO_MODE_ENUM_CONTROL_VER    MAKE_LWAPI_VERSION(LWAPI_STEREO_MODE_ENUM_CONTROL, 1)

//! \ingroup stereoapi
LWAPI_INTERFACE LwAPI_Stereo_ModeEnumControl(__inout LWAPI_STEREO_MODE_ENUM_CONTROL* pStereoModeEnumControl);

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_IsAccessoryDisplayEnabled
//
//! DESCRIPTION: This API determines if an Accessory Display is enabled or not.
//!
//! WHEN TO USE: This API can be called at any time.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [out]    IsAccessoryDisplayEnabled    == 1  - Accessory Display is enabled.
//!                                              == 0  - Accessory Display not detected in the current config.
//!
//! \return         This API can return any of the error codes enumerated in #LwAPI_Status.
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_IsAccessoryDisplayEnabled(__out LwU32* IsAccessoryDisplayEnabled);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_DongleControl
//! \fn LwAPI_Stereo_DongleControl(__in LwDisplayHandle hLwDisplay, __inout LWAPI_STEREO_DONGLE_CONTROL* pStereoDongleControl)
//!
//! DESCRIPTION: This API exelwtes dongle control interface commands
//!
//! WHEN TO USE: This API can be called at any time.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     hLwDisplay              LWPU Display handle enumerated with LwAPI_EnumLWidiaDisplayHandle()
//! \param [inout]  pStereoDongleControl    Pointer to a LWAPI_STEREO_DONGLE_CONTROL structure containing input and output params
//!
//! \return    This API can return any of the error codes enumerated in #LwAPI_Status. 
//!
///////////////////////////////////////////////////////////////////////////////
//! \addtogroup stereoapi
//! @{

//! \ingroup stereoapi
typedef enum _STEREO_DONGLE_CONTROL_COMMAND
{
    STEREO_DONGLE_COMMAND_POLL                      = 1,
    STEREO_DONGLE_COMMAND_SUPPORTED                 = 2,
    STEREO_DONGLE_COMMAND_SET_TIMING                = 3,
    STEREO_DONGLE_COMMAND_ACTIVATE                  = 4,
    STEREO_DONGLE_COMMAND_DEACTIVATE                = 5,
    STEREO_DONGLE_COMMAND_AEGIS_SURROUND            = 6,
    STEREO_DONGLE_COMMAND_GET_ACTIVE_COUNT          = 7,
    STEREO_DONGLE_COMMAND_SUPPORTED_DEVINDEPENDENT  = 8,
}STEREO_DONGLE_CONTROL_COMMAND;

//! \ingroup stereoapi
typedef struct _LWAPI_STEREO_DONGLE_CONTROL
{
    LwU32                           version;        //!< IN:  struct version
    STEREO_DONGLE_CONTROL_COMMAND   command;        //!< IN:  Interface command for stereo dongle
    LwU32                           data;           //!< IN:  Data required for interface comamnd
    LwU32                           result;         //!< OUT: Provides the command exelwtion result
} LWAPI_STEREO_DONGLE_CONTROL_V1;

//! \ingroup stereoapi
typedef LWAPI_STEREO_DONGLE_CONTROL_V1      LWAPI_STEREO_DONGLE_CONTROL;
//! \ingroup stereoapi
#define LWAPI_STEREO_DONGLE_CONTROL_VER1    MAKE_LWAPI_VERSION(LWAPI_STEREO_DONGLE_CONTROL_V1, 1)
//! \ingroup stereoapi
#define LWAPI_STEREO_DONGLE_CONTROL_VER     LWAPI_STEREO_DONGLE_CONTROL_VER1

//! \ingroup stereoapi
LWAPI_INTERFACE LwAPI_Stereo_DongleControl(__in LwDisplayHandle hLwDisplay, __inout LWAPI_STEREO_DONGLE_CONTROL* pStereoDongleControl);

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_GetStereoDiag
//! \fn LwAPI_Stereo_GetStereoDiag(StereoHandle hStereoHandle, LWAPI_STEREO_DIAG *pDiag)
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API queries diagnostic data from the current stereo device.
//!              It is a wrapper which uses interfaces to the D3D UMD and LDDM KMD drivers to query the current 
//!              stereo state from these driver instances.
//!
//! WHEN TO USE: Typically after a Present() operation of a D3D device.
//!
//! \param [in]  hStereoHandle        LWAPI stereo handle for the device requested
//! \param [in]  pDiag                Pointer to a LWAPI_STEREO_DIAG data structure containing pointers to the diagnostic data 
//!                                 
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//!              Error codes specific to this API are described below.
//!              
//! \retval      LWAPI_SUCCESS                               - Diag data has been queried and stored in provided pointers.
//! \retval      LWAPI_ILWALID_POINTER                       - pDiag == NULL, or neither UMD or KMD data pointers are provided.
//! \retval      LWAPI_INCOMPATIBLE_STRUCT_VERSION           - version mismatch of datatype passed in with pDiag or UMD or KMD data pointers.
//!
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup stereoapi
//! @{

typedef struct _LWAPI_STEREO_DIAG_KMD
{
    LwU32 version;
    
    LwU32                   ulDongleActiveCount;          //!< OUT: current stereo dongle active count    
    LwU32                   ulStereoConfig[LW_MAX_HEADS]; //!< OUT: current stereo configuration per head
} LWAPI_STEREO_DIAG_KMD;

#define LWAPI_STEREO_DIAG_KMD_VER MAKE_LWAPI_VERSION(LWAPI_STEREO_DIAG_KMD, 1)

typedef struct _LWAPI_STEREO_DIAG
{
    LwU32 version;
    union                                //!< Anonymous union   
    {                              
    struct _LW_STEREO_API_DIAG_UMD *pUMDData;    
    LwU64 pad0;                       //!< Pad up to 64 bits on 32-bit systems
    };
    union                                //!< Anonymous union   
    {                              
    LWAPI_STEREO_DIAG_KMD* pKMDData;
    LwU64 pad1;                       //!< Pad up to 64 bits on 32-bit systems
    };
} LWAPI_STEREO_DIAG;

#define LWAPI_STEREO_DIAG_VER MAKE_LWAPI_VERSION(LWAPI_STEREO_DIAG, 1)

LWAPI_INTERFACE LwAPI_Stereo_GetStereoDiag(__in StereoHandle hStereoHandle, __in LWAPI_STEREO_DIAG *pDiag);

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_Is3DLwrsorSupported
//
//! DESCRIPTION:   This API checks if stereo cursor is supported on a given stereo device
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate LwAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 302
//!
//! \param [in]    stereoHandle  Stereo handle that corresponds to the device interface.
//! \param [out]   bSupported(OUT)    != 0  - supported,  \n
//!                                   == 0  - is not supported 
//! 
//! \retval ::LWAPI_OK - Check was sucessfully completed and result reflects current state of stereo (on/off).
//! \retval ::LWAPI_STEREO_ILWALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//! \retval ::LWAPI_API_NOT_INTIALIZED - LWAPI not initialized.
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED - Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR - Something is wrong (generic error).
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_Is3DLwrsorSupported(__in StereoHandle stereoHandle, __out LwU8* bSupported);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_GetLwrsorSeparation
//
//! DESCRIPTION:   This API gets current cursor separation value (in percents). 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate LwAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 302
//!
//! \param [in]     stereoHandle           Stereo handle that corresponds to the device interface.
//! \param [out]    pSeparationPercentage  Address of @c float type variable to store current separation percentage in.
//!
//! \retval ::LWAPI_OK                                Retrieval of separation percentage was successfull.
//! \retval ::LWAPI_STEREO_ILWALID_DEVICE_INTERFACE   Device interface is not valid. Create again, then attach again.
//! \retval ::LWAPI_API_NOT_INTIALIZED  
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED            Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_ERROR  
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_GetLwrsorSeparation(__in StereoHandle stereoHandle, __out float *pSeparationPercentage);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_SetLwrsorSeparation
//
//! DESCRIPTION:   This API sets cursor separation to given percentage. 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to appropriate LwAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 302
//!
//! \param [in]     stereoHandle             Stereo handle that corresponds to the device interface.
//! \param [in]     newSeparationPercentage  New value for separation percentage.
//!
//! \retval ::LWAPI_OK                               Setting of separation percentage was successfull.
//! \retval ::LWAPI_STEREO_ILWALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.
//! \retval ::LWAPI_API_NOT_INTIALIZED               LWAPI not initialized.
//! \retval ::LWAPI_STEREO_NOT_INITIALIZED           Stereo part of LWAPI not initialized.
//! \retval ::LWAPI_STEREO_PARAMETER_OUT_OF_RANGE    Given separation percentage is out of [0..100] range.
//! \retval ::LWAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_SetLwrsorSeparation(__in StereoHandle stereoHandle, __in float newSeparationPercentage);




//! \ingroup stereoapi
#define LWAPI_STEREO_QUADBUFFERED_API_VERSION   0x2

//! \ingroup stereoapi
 typedef enum _LW_StereoSwapChainMode
 {
   LWAPI_STEREO_SWAPCHAIN_DEFAULT = 0,
   LWAPI_STEREO_SWAPCHAIN_STEREO = 1,
   LWAPI_STEREO_SWAPCHAIN_MONO = 2,
 } LW_STEREO_SWAPCHAIN_MODE;

#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D1x_CreateSwapChain
//
//! DESCRIPTION: This API allows the user to create a mono or a stereo swap chain.
//!
//!          NOTE: LwAPI_D3D1x_CreateSwapChain is a wrapper of the method IDXGIFactory::CreateSwapChain which
//!                additionally notifies the D3D driver of the mode in which stereo mode the swap chain is to be
//!                created.
//!
//! \since Release: 285
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     hStereoHandle      Stereo handle that corresponds to the device interface.
//!                                   A pointer to the device that will write 2D images to the swap chain.
//! \param [in]     pDesc             A pointer to the swap-chain description (DXGI_SWAP_CHAIN_DESC). This parameter cannot be NULL.
//! \param [out]    ppSwapChain       A pointer to the swap chain created.
//! \param [in]     mode              The stereo mode fot the swap chain.
//!                                   LWAPI_STEREO_SWAPCHAIN_DEFAULT 
//!                                   LWAPI_STEREO_SWAPCHAIN_STEREO 
//!                                   LWAPI_STEREO_SWAPCHAIN_MONO 
//!
//! \retval ::LWAPI_OK                 The swap chain was created successfully.
//! \retval ::LWAPI_ERROR              The operation failed.
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D1x_CreateSwapChain(StereoHandle hStereoHandle,
                                            DXGI_SWAP_CHAIN_DESC* pDesc,
                                            IDXGISwapChain** ppSwapChain,
                                            LW_STEREO_SWAPCHAIN_MODE mode);

#endif //if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)


#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_D3D9_CreateSwapChain
//
//! DESCRIPTION: This API allows the user to create a mono or a stereo swap chain.
//!
//!          NOTE: LwAPI_D3D9_CreateSwapChain is a wrapper of the method IDirect3DDevice9::CreateAdditionalSwapChain which
//!                additionally notifies the D3D driver if the swap chain creation mode must be stereo or mono.
//!
//!
//! \since Release: 285
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]      hStereoHandle            Stereo handle that corresponds to the device interface.
//! \param [in, out] pPresentationParameters  A pointer to the swap-chain description (DXGI). This parameter cannot be NULL.
//! \param [out]     ppSwapChain              A pointer to the swap chain created.
//! \param [in]      mode                     The stereo mode for the swap chain.
//!                                           LWAPI_STEREO_SWAPCHAIN_DEFAULT 
//!                                           LWAPI_STEREO_SWAPCHAIN_STEREO 
//!                                           LWAPI_STEREO_SWAPCHAIN_MONO 
//!
//! \retval ::LWAPI_OK                        The swap chain creation was successful 
//! \retval ::LWAPI_ERROR                     The operation failed.
//!
//!\ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_D3D9_CreateSwapChain(StereoHandle hStereoHandle,
                                           D3DPRESENT_PARAMETERS *pPresentationParameters,
                                           IDirect3DSwapChain9 **ppSwapChain,
                                           LW_STEREO_SWAPCHAIN_MODE mode);
#endif //if defined(_D3D9_H_)




#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_SetProfileName
//
//! DESCRIPTION:   This API sets profile name on the device created.
//!                This profile will not get applied to the Direct3D calls coming to the driver before this call.
//!
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    stereoHandle  Stereo handle corresponding to the device interface
//! \param [in]    ProfileName   Profile Name
//! \param [in]    Pointer to IUnknown interface that is IDirect3DDevice9* in DX9
//! \param [in]    flags
//!
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status.
//!              If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_SetProfileName(__in StereoHandle hStereoHandle, __in LwAPI_String szProfileName, __in IUnknown *pDevice, __in unsigned int uiFlags);

#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_IsDisplayAegisDTType
//
//! DESCRIPTION:  This API checks whether a monitor specified by the the 'panel id', is AegisDT capable or not.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    ulPanelId                Bytes 4-7 of the EDID, considered as a single DWORD
//! \param [out]   bAegisDTDetected         Address of variable that will return whether a AegisDT was detected or not.
//!                                         1   -  AegisDT detected.
//!                                         0   -  AegisDT not present.
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status.
//!                If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_IsDisplayAegisDTType(__in LwU32 ulPanelId, __out LwU8 * bAegisDTDetected);

//! 'LwAPI_Stereo_Dongle_Status' related.
//! Following define - STEREO_DONGLE_DEVICE_STATUS corresponds to a 'new' case that has been added in the KM code
//! in escape and stereo_dongle to request 'dongle status' information.

#define STEREO_DONGLE_DEVICE_STATUS                 0x00000009

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Stereo_Dongle_Status
//
//! DESCRIPTION:  This API returns status information at the lower most levels in the KM driver related to
//!               stereo dongle. Specifically, from stereo_dongle code(RM-stereo) corresponding to the USB
//!               and AegisDT emitters.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     displayId               Display ID of the display to retrieve stereo dongle information for.
//! \param [in]     statusParam             Specifies the sub command for the specific dongle status required.
//! \param [out]    pResult                 Will contain the requested status. Following are possible values -
//!                                         '0x00000000' - Parameter corresponding to the command is disabled or in-active.
//!                                         '0x00000001' - Parameter corresponding to the command is enabled or active.
//!                                         '0xC0000000' - Command not supported.
//! \return         This API can return any of the error codes enumerated in #LwAPI_Status.
//!                 If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Stereo_Dongle_Status(__in LwU32 displayId, __in LwU8 statusParam, __out LwU32 *pResult);

#ifndef LW_VIDEO_POSTPROCESSING_DEFINE
#define LW_VIDEO_POSTPROCESSING_DEFINE

//! \addtogroup vidcontrol
//! @{


//! Used in LW_VIDEO_COLORCONTROL_INFO
typedef struct
{
    LwU32 value;        
    LwU32 min;        
    LwU32 max;        
} LW_VIDEO_POSTPROCESSING_RANGE_VALUE;


//! Used in LW_VIDEO_COLORCONTROL_INFO
typedef enum
{
    LW_VIDEO_POSTPROCESSING_CAPS_FEATURE_SUPPORTED          = 0x00,  
    LW_VIDEO_POSTPROCESSING_CAPS_FEATURE_NOT_SUPPORTED      = 0x01,  
} LW_VIDEO_POSTPROCESSING_CAPS;


// Deinterlace
 
//! Used in LW_VIDEO_POSTPROCESSING_DEINTERLACE_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_DEINTERLACE_FEATURE
{
    LW_VIDEO_POSTPROCESSING_DEINTERLACE_FEATURE_DISABLE           = 0x00,       
    LW_VIDEO_POSTPROCESSING_DEINTERLACE_FEATURE_ENABLE            = 0x01,       
} LW_VIDEO_POSTPROCESSING_DEINTERLACE_FEATURE;


//! Used in LW_VIDEO_POSTPROCESSING_DEINTERLACE_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_DEINTERLACE_ALG
{
    LW_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_BOB              = 0x01,
    LW_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_WEAVE            = 0x02,
    LW_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_SIMPLE_ADAPTIVE  = 0x03,
    LW_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_GRADIENT_SIMPLE  = 0x04,      
    LW_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_GRADIENT_FULL    = 0x05,
    LW_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_ADVANCED         = 0x06,
} LW_VIDEO_POSTPROCESSING_DEINTERLACE_ALG;


//! Used in LW_VIDEO_POSTPROCESSING_DEINTERLACE_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE
{
    LW_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE_DIR_SPATIAL_DEFAULT  = 0x01,
    LW_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE_DIR_SPATIAL_SIMPLE   = 0x02,
    LW_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE_DIR_SPATIAL_ADVANCED = 0x03,
} LW_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE;


//! Used in LW_VIDEO_POSTPROCESSING_DEINTERLACE_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_DEINTERLACE_MISC
{
    LW_VIDEO_POSTPROCESSING_DEINTERLACE_MISC_NONE = 0x00,  // none so far

} LW_VIDEO_POSTPROCESSING_DEINTERLACE_MISC;


//! Used in LW_VIDEO_POSTPROCESSING_CTRL_INFO
typedef struct
{
    LW_VIDEO_POSTPROCESSING_CAPS caps;
    LW_VIDEO_POSTPROCESSING_DEINTERLACE_FEATURE feature;
    LW_VIDEO_POSTPROCESSING_DEINTERLACE_ALG     alg;
    LW_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE enhance;
    LW_VIDEO_POSTPROCESSING_DEINTERLACE_MISC    misc;
} LW_VIDEO_POSTPROCESSING_DEINTERLACE_INFO;


//Scaling


//! Used in LW_VIDEO_POSTPROCESSING_SCALING_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_SCALING_FEATURE
{
    LW_VIDEO_POSTPROCESSING_SCALING_FEATURE_DISABLE            = 0x00,       
    LW_VIDEO_POSTPROCESSING_SCALING_FEATURE_ENABLE             = 0x01,       
} LW_VIDEO_POSTPROCESSING_SCALING_FEATURE;


//! Used in LW_VIDEO_POSTPROCESSING_SCALING_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_SCALING_ALG
{
    LW_VIDEO_POSTPROCESSING_SCALING_ALG_DEFAULT                = 0x01,
    LW_VIDEO_POSTPROCESSING_SCALING_ALG_4x4FILTER              = 0x02,
} LW_VIDEO_POSTPROCESSING_SCALING_ALG;


//! Used in LW_VIDEO_POSTPROCESSING_SCALING_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_SCALING_ENHANCE
{
    LW_VIDEO_POSTPROCESSING_SCALING_ENHANCE_NONE               = 0x00,   // None so far 
} LW_VIDEO_POSTPROCESSING_SCALING_ENHANCE;


//! Used in LW_VIDEO_POSTPROCESSING_SCALING_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_SCALING_MISC
{
    LW_VIDEO_POSTPROCESSING_SCALING_MISC_NONE                  = 0x00,  // none so far
} LW_VIDEO_POSTPROCESSING_SCALING_MISC;


//! Used in LW_VIDEO_POSTPROCESSING_CTRL_INFO
typedef struct
{
    LW_VIDEO_POSTPROCESSING_CAPS caps;
    LW_VIDEO_POSTPROCESSING_SCALING_FEATURE feature;
    LW_VIDEO_POSTPROCESSING_SCALING_ALG     alg;
    LW_VIDEO_POSTPROCESSING_SCALING_ENHANCE enhance;
    LW_VIDEO_POSTPROCESSING_SCALING_MISC    misc;
} LW_VIDEO_POSTPROCESSING_SCALING_INFO;


//Cadence


//! Used in LW_VIDEO_POSTPROCESSING_CADENCE_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_CADENCE_FEATURE
{
    LW_VIDEO_POSTPROCESSING_CADENCE_FEATURE_DISABLE            = 0x00,       
    LW_VIDEO_POSTPROCESSING_CADENCE_FEATURE_ENABLE             = 0x01,       
} LW_VIDEO_POSTPROCESSING_CADENCE_FEATURE;


//! Used in LW_VIDEO_POSTPROCESSING_CADENCE_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_CADENCE_ALG
{
    LW_VIDEO_POSTPROCESSING_CADENCE_ALG_NONE                   = 0x00, //None so far
} LW_VIDEO_POSTPROCESSING_CADENCE_ALG;


//! Used in LW_VIDEO_POSTPROCESSING_CADENCE_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_CADENCE_ENHANCE
{
    LW_VIDEO_POSTPROCESSING_CADENCE_ENHANCE_NONE               = 0x00,   
    LW_VIDEO_POSTPROCESSING_CADENCE_ENHANCE_VOF                = 0x01,   
} LW_VIDEO_POSTPROCESSING_CADENCE_ENHANCE;


//! Used in LW_VIDEO_POSTPROCESSING_CADENCE_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_CADENCE_MISC
{
    LW_VIDEO_POSTPROCESSING_CADENCE_MISC_NONE                  = 0x00,  // none so far
} LW_VIDEO_POSTPROCESSING_CADENCE_MISC;


//! Used in LW_VIDEO_POSTPROCESSING_CTRL_INFO
typedef struct
{
    LW_VIDEO_POSTPROCESSING_CAPS caps;
    LW_VIDEO_POSTPROCESSING_CADENCE_FEATURE feature;
    LW_VIDEO_POSTPROCESSING_CADENCE_ALG     alg;
    LW_VIDEO_POSTPROCESSING_CADENCE_ENHANCE enhance;
    LW_VIDEO_POSTPROCESSING_CADENCE_MISC    misc;
} LW_VIDEO_POSTPROCESSING_CADENCE_INFO;



// Edge Enhance

//! Used in LW_VIDEO_POSTPROCESSING_EE_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_EE_FEATURE
{
    LW_VIDEO_POSTPROCESSING_EE_FEATURE_DISABLE            = 0x00,       
    LW_VIDEO_POSTPROCESSING_EE_FEATURE_ENABLE             = 0x01,       
} LW_VIDEO_POSTPROCESSING_EE_FEATURE;


//! Used in LW_VIDEO_POSTPROCESSING_EE_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_EE_ALG
{
    LW_VIDEO_POSTPROCESSING_EE_ALG_NONE                   = 0x00, //None so far
} LW_VIDEO_POSTPROCESSING_EE_ALG;


//! Used in LW_VIDEO_POSTPROCESSING_EE_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_EE_ENHANCE
{
    LW_VIDEO_POSTPROCESSING_EE_ENHANCE_NONE                = 0x00,   
} LW_VIDEO_POSTPROCESSING_EE_ENHANCE;


//! Used in LW_VIDEO_POSTPROCESSING_EE_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_EE_MISC
{
    LW_VIDEO_POSTPROCESSING_EE_MISC_NONE                  = 0x00,  // none so far
} LW_VIDEO_POSTPROCESSING_EE_MISC;


//! Used in LW_VIDEO_POSTPROCESSING_CTRL_INFO
typedef struct
{
    LW_VIDEO_POSTPROCESSING_CAPS caps;
    LW_VIDEO_POSTPROCESSING_EE_FEATURE     feature;
    LW_VIDEO_POSTPROCESSING_EE_ALG         alg ;
    LW_VIDEO_POSTPROCESSING_EE_ENHANCE     enhance;
    LW_VIDEO_POSTPROCESSING_EE_MISC        misc;
    LW_VIDEO_POSTPROCESSING_RANGE_VALUE    rangeValue;
} LW_VIDEO_POSTPROCESSING_EE_INFO;


//Noise Reduction


//! Used in LW_VIDEO_POSTPROCESSING_NR_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_NR_FEATURE
{
    LW_VIDEO_POSTPROCESSING_NR_FEATURE_DISABLE            = 0x00,       
    LW_VIDEO_POSTPROCESSING_NR_FEATURE_ENABLE             = 0x01,       
} LW_VIDEO_POSTPROCESSING_NR_FEATURE;


//! Used in LW_VIDEO_POSTPROCESSING_NR_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_NR_ALG
{
    LW_VIDEO_POSTPROCESSING_NR_ALG_NONE                   = 0x00, //None so far
} LW_VIDEO_POSTPROCESSING_NR_ALG;


//! Used in LW_VIDEO_POSTPROCESSING_NR_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_NR_ENHANCE
{
    LW_VIDEO_POSTPROCESSING_NR_ENHANCE_NONE                = 0x00,   
} LW_VIDEO_POSTPROCESSING_NR_ENHANCE;


//! Used in LW_VIDEO_POSTPROCESSING_NR_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_NR_MISC
{
    LW_VIDEO_POSTPROCESSING_NR_MISC_NONE                  = 0x00,  // none so far
} LW_VIDEO_POSTPROCESSING_NR_MISC;


//! Used in LW_VIDEO_POSTPROCESSING_CTRL_INFO
typedef struct
{
    LW_VIDEO_POSTPROCESSING_CAPS caps;
    LW_VIDEO_POSTPROCESSING_NR_FEATURE     feature;
    LW_VIDEO_POSTPROCESSING_NR_ALG         alg;
    LW_VIDEO_POSTPROCESSING_NR_ENHANCE     enhance;
    LW_VIDEO_POSTPROCESSING_NR_MISC        misc;
    LW_VIDEO_POSTPROCESSING_RANGE_VALUE    rangeValue;
} LW_VIDEO_POSTPROCESSING_NR_INFO;


//Over Drive

//! Used in LW_VIDEO_POSTPROCESSING_OVERDRIVE_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_OVERDRIVE_FEATURE
{
    LW_VIDEO_POSTPROCESSING_OVERDRIVE_FEATURE_DISABLE            = 0x00,       
    LW_VIDEO_POSTPROCESSING_OVERDRIVE_FEATURE_ENABLE             = 0x01,       
} LW_VIDEO_POSTPROCESSING_OVERDRIVE_FEATURE;


//! Used in LW_VIDEO_POSTPROCESSING_OVERDRIVE_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_OVERDRIVE_ALG
{
    LW_VIDEO_POSTPROCESSING_OVERDRIVE_ALG_NONE                   = 0x00, //None so far
} LW_VIDEO_POSTPROCESSING_OVERDRIVE_ALG;


//! Used in LW_VIDEO_POSTPROCESSING_OVERDRIVE_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_OVERDRIVE_ENHANCE
{
    LW_VIDEO_POSTPROCESSING_OVERDRIVE_ENHANCE_NONE                = 0x00,   
} LW_VIDEO_POSTPROCESSING_OVERDRIVE_ENHANCE;


//! Used in LW_VIDEO_POSTPROCESSING_OVERDRIVE_INFO
typedef enum _LW_VIDEO_POSTPROCESSING_OVERDRIVE_MISC
{
    LW_VIDEO_POSTPROCESSING_OVERDRIVE_MISC_NONE                  = 0x00,  // none so far
} LW_VIDEO_POSTPROCESSING_OVERDRIVE_MISC;


//! Used in LW_VIDEO_POSTPROCESSING_CTRL_INFO
typedef struct
{
    LW_VIDEO_POSTPROCESSING_CAPS caps;
    LW_VIDEO_POSTPROCESSING_OVERDRIVE_FEATURE feature;
    LW_VIDEO_POSTPROCESSING_OVERDRIVE_ALG     alg;
    LW_VIDEO_POSTPROCESSING_OVERDRIVE_ENHANCE enhance;
    LW_VIDEO_POSTPROCESSING_OVERDRIVE_MISC    misc;
} LW_VIDEO_POSTPROCESSING_OVERDRIVE_INFO;


//! Postprocessing info struct 
//! Used in LwAPI_Video_PostProcessing_Get() and LwAPI_Video_PostProcessing_Set()
typedef struct 
{
    LwU32 version;                                              //!< Structure version
    LW_VIDEO_POSTPROCESSING_DEINTERLACE_INFO  deinterlaceInfo;  //!< Deinterlace info struct
    LW_VIDEO_POSTPROCESSING_SCALING_INFO      scalingInfo;      //!< Scaling info struct
    LW_VIDEO_POSTPROCESSING_CADENCE_INFO      cadenceInfo;      //!< Cadence info struct
    LW_VIDEO_POSTPROCESSING_NR_INFO           nrInfo;           //!< Noise reduction info struct
    LW_VIDEO_POSTPROCESSING_EE_INFO           eeInfo;           //!< Edge enhance info struct
    LW_VIDEO_POSTPROCESSING_OVERDRIVE_INFO    overDriveInfo;    //!< Overdrive info struct
} LW_VIDEO_POSTPROCESSING_CTRL_INFO;

#define LW_VIDEO_POSTPROCESSING_CTRL_LWAPI_VER MAKE_LWAPI_VERSION(LW_VIDEO_POSTPROCESSING_CTRL_INFO,1)

//Video Color control

//! This range value is exclusive for color controls, special fields may be added in the future \n
//! Used in LW_VIDEO_COLORCONTROL_INFO
typedef struct
{
    LwU32 value;        
    LwU32 min;        
    LwU32 max;        
} LW_VIDEO_COLORCONTROL_RANGE_VALUE;

//Color control caps are different from post processing caps

//! Used in LW_VIDEO_COLORCONTROL_INFO
typedef enum
{
    LW_VIDEO_COLORCONTROL_CAPS_FEATURE_SUPPORTED          = 0x00,  
    LW_VIDEO_COLORCONTROL_CAPS_FEATURE_NOT_SUPPORTED      = 0x01,  
} LW_VIDEO_COLORCONTROL_CAPS;

//! Used in LW_VIDEO_COLORCONTROL_INFO
typedef enum _LW_VIDEO_COLORCONTROL_FEATURE
{
    LW_VIDEO_COLORCONTROL_FEATURE_DISABLE            = 0x00,       
    LW_VIDEO_COLORCONTROL_FEATURE_ENABLE             = 0x01,       
} LW_VIDEO_COLORCONTROL_FEATURE;

//! Used in LW_VIDEO_COLORCONTROL_INFO
typedef enum _LW_VIDEO_COLORTEMP_FEATURE
{
    LW_VIDEO_COLORTEMP_FEATURE_DISABLE            = 0x00,       
    LW_VIDEO_COLORTEMP_FEATURE_ENABLE             = 0x01,       
} LW_VIDEO_COLORTEMP_FEATURE;

//! Used in LW_VIDEO_COLORCONTROL_INFO
typedef enum _LW_VIDEO_GAMMA_FEATURE
{
    LW_VIDEO_GAMMA_FEATURE_DISABLE            = 0x00,       
    LW_VIDEO_GAMMA_FEATURE_ENABLE_Y           = 0x01,       
    LW_VIDEO_GAMMA_FEATURE_ENABLE_RGB         = 0x02,       
} LW_VIDEO_GAMMA_FEATURE;


//! Used in LW_VIDEO_COLORCONTROL_INFO
typedef enum _LW_VIDEO_COLOR_CONTROL_SETTING
{
    LW_VIDEO_COLORCONTROL_SETTING_OVERRIDE_APP_CTRLS  = 0x00,  //!< Overrides application controls with lwapi settings        
    LW_VIDEO_COLORCONTROL_SETTING_USE_APP_CTRLS       = 0x01,  //!< Use application controls        
                                                               //!< In the future we may add app profile setting here     

} LW_VIDEO_COLORCONTROL_SETTING;

//! Used in LwAPI_Video_ColorControl_GetDefault(), LwAPI_Video_ColorControl_Get(), and LwAPI_Video_ColorControl_Set()
typedef struct 
{
    LwU32 version;          // structure version

    LW_VIDEO_COLORCONTROL_SETTING colorControlSettings; 

    //Set #1  brightness contrast hue and saturation
    LW_VIDEO_COLORCONTROL_CAPS            colorCaps;
    LW_VIDEO_COLORCONTROL_FEATURE         colorFeature;
    LW_VIDEO_COLORCONTROL_RANGE_VALUE     brightnessRangeValue;
    LW_VIDEO_COLORCONTROL_RANGE_VALUE     contrastRangeValue;
    LW_VIDEO_COLORCONTROL_RANGE_VALUE     hueRangeValue;
    LW_VIDEO_COLORCONTROL_RANGE_VALUE     saturationRangeValue;
    
    //Set #2  colorTemp
    LW_VIDEO_COLORCONTROL_CAPS            colorTempCaps;
    LW_VIDEO_COLORTEMP_FEATURE            colorTempFeature;
    LW_VIDEO_COLORCONTROL_RANGE_VALUE     colorTempRangeValue;
    
    //Set #3  Gamma
    LW_VIDEO_COLORCONTROL_CAPS            gammaCaps;
    LW_VIDEO_GAMMA_FEATURE                gammaFeature;
    
    LW_VIDEO_COLORCONTROL_RANGE_VALUE     yGammaRangeValue;
    LW_VIDEO_COLORCONTROL_RANGE_VALUE     rgbGammaRRangeValue;
    LW_VIDEO_COLORCONTROL_RANGE_VALUE     rgbGammaGRangeValue;
    LW_VIDEO_COLORCONTROL_RANGE_VALUE     rgbGammaBRangeValue;
} LW_VIDEO_COLORCONTROL_INFO;

#define LW_VIDEO_COLORCONTROL_LWAPI_VER MAKE_LWAPI_VERSION(LW_VIDEO_COLORCONTROL_INFO,1)

//! @}

#endif // ifndef LW_VIDEO_POSTPROCESSING_DEFINE



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Video_PostProcessing_GetDefault
//
//! This function queries the video postprocessing default control information.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \return LWAPI_ERROR or LWAPI_OK
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Video_PostProcessing_GetDefault(LwDisplayHandle hLwDisplay, LW_VIDEO_POSTPROCESSING_CTRL_INFO* pVideoPPCtrlInfo);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Video_PostProcessing_Get
//
//! This function queries the video postprocessing current control information.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \return LWAPI_ERROR or LWAPI_OK
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Video_PostProcessing_Get(LwDisplayHandle hLwDisplay, LW_VIDEO_POSTPROCESSING_CTRL_INFO* pVideoPPCtrlInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Video_PostProcessing_Set
//
//! This function sets the video postprocessing current control information.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \return LWAPI_ERROR or LWAPI_OK
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Video_PostProcessing_Set(LwDisplayHandle hLwDisplay, LW_VIDEO_POSTPROCESSING_CTRL_INFO* pVideoPPCtrlInfo);


//color control apis
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Video_ColorControl_GetDefault
//
//! This function queries the video default color control information.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \return LWAPI_ERROR or LWAPI_OK
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////

LWAPI_INTERFACE LwAPI_Video_ColorControl_GetDefault(LwDisplayHandle hLwDisplay, LW_VIDEO_COLORCONTROL_INFO* pVideoColorCtrlInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Video_ColorControl_Get
//
//! This function queries the video current color control information.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \return LWAPI_ERROR or LWAPI_OK
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////

LWAPI_INTERFACE LwAPI_Video_ColorControl_Get(LwDisplayHandle hLwDisplay, LW_VIDEO_COLORCONTROL_INFO* pVideoColorCtrlInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Video_ColorControl_Set
//
//! This function sets the video current color control information.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 100
//!
//! \return LWAPI_ERROR or LWAPI_OK
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////

LWAPI_INTERFACE LwAPI_Video_ColorControl_Set(LwDisplayHandle hLwDisplay, LW_VIDEO_COLORCONTROL_INFO* pVideoColorCtrlInfo);


//EVO Overlay LUT API

//! \ingroup vidcontrol
#define LW_EVO_VIDEO_LUT_VER  MAKE_LWAPI_VERSION(LW_EVO_VIDEO_LUT,1)

//! Used in LW_EVO_VIDEO_LUT.
//! \ingroup vidcontrol
typedef struct {
    LwU16 Red;
    LwU16 Green;
    LwU16 Blue;
    LwU16 Unused;
} LWAPI_EVO_VIDEO_CLUTDATA;

//! \ingroup videocontroltypes 
#define EVO_LUT_ENTRIES 257

//! See LW_EVO_VIDEO_LUT
//! \ingroup vidcontrol
typedef LWAPI_EVO_VIDEO_CLUTDATA LWAPI_EVO_VIDEO_LUT[EVO_LUT_ENTRIES];

//! Used in LwAPI_Video_EvoOverlayLUT_Get() and LwAPI_Video_EvoOverlayLUT_Set().
//! \ingroup vidcontrol
typedef struct
{
    LwU32 version;
    LWAPI_EVO_VIDEO_LUT lut;  
} LW_EVO_VIDEO_LUT;

 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Video_EvoOverlayLUT_Get
//
//!   DESCRIPTION: This function gets the EVO Overlay LUT.  For verification use only.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 105
//!
//! \return LWAPI_ERROR or LWAPI_OK
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////

LWAPI_INTERFACE LwAPI_Video_EvoOverlayLUT_Get(LwDisplayHandle hLwDisplay, LW_EVO_VIDEO_LUT* pLut);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Video_EvoOverlayLUT_Set
//
//!   DESCRIPTION: This function sets the EVO Overlay LUT.  For verification use only.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 105
//!
//! \return LWAPI_ERROR or LWAPI_OK
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////

LWAPI_INTERFACE LwAPI_Video_EvoOverlayLUT_Set(LwDisplayHandle hLwDisplay, LW_EVO_VIDEO_LUT* pLut);




#if defined(_D3D9_H_) && defined(__cplusplus)

//! \addtogroup videoapi
//! @{

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Video_Bringup
//
//! \fn LwAPI_Video_Bringup(IDirect3DDevice9 *pDev,
//!    LWAPI_VIDEO_BRINGUP_PARAMS *pVideoBringupParams)
//! \code
//!   DESCRIPTION: Run video engine bringup test
//!                Replaces the LWDIAG_CMD_ENGINE_BRINGUP
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: LWAPI_ERROR or LWAPI_OK
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! Video engine bringup action type
typedef enum _LWAPI_VIDEO_BRINGUP_ACTION
{
    LWAPI_VIDEO_BRINGUP_ACTION_RUN_TEST     = 0x01,     //!< Run test
    LWAPI_VIDEO_BRINGUP_ACTION_CHECK_RESULT = 0x02,     //!< Check test result
    LWAPI_VIDEO_BRINGUP_ACTION_INIT_TRACE_PLAYER= 0x03, //!< Initialise trace player
    LWAPI_VIDEO_BRINGUP_ACTION_SETUP_BUFFERS    = 0x04, //!< Setup ctx dmas
    LWAPI_VIDEO_BRINGUP_ACTION_SETUP_EXELWTE    = 0x05, //!< PB execute
    LWAPI_VIDEO_BRINGUP_ACTION_DESTROY_TRACE    = 0x06, //!< Cleanup
} LWAPI_VIDEO_BRINGUP_ACTION;

//! Video engine bringup test type
typedef enum _LWAPI_VIDEO_BRINGUP_TEST
{
    LWAPI_VIDEO_BRINGUP_TEST_TCIPHER_BASIC  = 0x01,     //!< Turbo cipher basic test
    LWAPI_VIDEO_BRINGUP_TEST_COMPUTE_MULTI  = 0x02,     //!< Compute multi test
    LWAPI_VIDEO_BRINGUP_TEST_SEC_BASIC      = 0x03,     //!< SEC basic test
    LWAPI_VIDEO_BRINGUP_TEST_SEC_EXELWTE    = 0x04,     //!< SEC execute test
    LWAPI_VIDEO_BRINGUP_TEST_CE_EXELWTE     = 0x05,     //!< CE execute test
} LWAPI_VIDEO_BRINGUP_TEST;

typedef struct _LWAPI_VIDEO_BRINGUP_PARAMS
{
    LwU32                       version;                //!< structure version (IN)
    LWAPI_VIDEO_BRINGUP_ACTION  action;                 //!< action type (IN)
    LWAPI_VIDEO_BRINGUP_TEST    test;                   //!< test type (IN)
    LwU32                       params[4];              //!< input parameters (IN)
    void                       *pOutput;                //!< output (OUT)
    LwU32                       dwOutputSize;           //!< output size (IN)
} LWAPI_VIDEO_BRINGUP_PARAMS;

//! Macro for constrlwting the version field of ::LWAPI_VIDEO_BRINGUP_PARAMS
#define LWAPI_VIDEO_BRINGUP_PARAMS_VER \
    MAKE_LWAPI_VERSION(LWAPI_VIDEO_BRINGUP_PARAMS, 1)

LWAPI_INTERFACE LwAPI_Video_Bringup(IDirect3DDevice9 *pDev,
    LWAPI_VIDEO_BRINGUP_PARAMS *pVideoBringupParams);
//! @}

#endif // defined(_D3D9_H_) && defined(__cplusplus)









//-----------------------------------------------------------------------------
// Video Microcode Loading routines and data structures
//-----------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_LoadMicrocode
//
//! \fn LwAPI_LoadMicrocode(LwDisplayHandle hLwDisplay, LW_MICROCODE_INFO* pMicrocodeInfo)
//!  This function loads the microcode provided in the pMicrocodeInfo.
//!
//! SUPPORTED OS:  Windows XP
//!
//!  
//!
//! \since Release: 85
//!
//! \return  LWAPI_ERROR or LWAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup viducode
//! Used in LwAPI_LoadMicrocode().
typedef struct 
{
    LwU32 version;          //!<  Structure version
    LwU32 ucID;             //!<  Microcode ID for VP2 its the subclass this microcode belongs to
    LwU32 ucVersion;        //!<  Version of the microcode -- depends upon the author
    char szMicrocodeDescription[40]; //!<  Short description of the microcode -- depends upon the author
    LwU32 ucCRC;            //!<  CRC value for the uncompressed microcode data
    LwU32 unCompressedSize; //!<  Uncompressed size of the microcode
    LwU32 flags;            //!<  0x00000001 means compressesd
    LwU32 microcodeFormat;  //!<  Type of compression/layout for microcode
    LwU32 compSize;         //!<  Size of the compressed microcode
    union {                 //!<  Anonymous union 
    LwU8 *pImg;             //!<  Pointer to the microcode - Use only in the API call
    LwU64 pImgpad;          //!<  Pad up to 64 bits on 32-bit systems
    };
} LW_MICROCODE_INFO;

//! \ingroup viducode
#define LW_MICROCODE_INFO_VER MAKE_LWAPI_VERSION(LW_MICROCODE_INFO,1)


//! \ingroup viducode
//! Used in LwAPI_GetLoadedMicrocodePrograms()
typedef struct _LW_MICROCODE_REPOS_INDEX
{
    LwU32                version;        //!< Structure version
    LW_MICROCODE_INFO    info;           //!< Note that the image data here is not valid
    LwU32                offset;         //!< This is not used by the API.
    LwU32                loadedDataSize;
    LwS32                indexStatus;
    union                                //!< Anonymous union   
    {                              
    struct _LW_MICROCODE_REPOS_INDEX* pNext;
    LwU64 pImgpad;                       //!< Pad up to 64 bits on 32-bit systems
    };
} LW_MICROCODE_REPOS_INDEX;

//! \ingroup viducode
#define LW_MICROCODE_REPOS_INDEX_VER MAKE_LWAPI_VERSION(LW_MICROCODE_REPOS_INDEX,1)


//! \ingroup viducode
LWAPI_INTERFACE LwAPI_LoadMicrocode(LwDisplayHandle hLwDisplay, LW_MICROCODE_INFO* pMicrocodeInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetLoadedMicrocodePrograms
//
//!   This function queries the lwrrently loaded microcode programs. 
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 85
//!
//! \return  LWAPI_ERROR or LWAPI_OK
//!
//! NOTE: It is very important that the caller of the function carefully 
//!       clears/frees up the memory of the linkedlist pMicrocodeReposIndex
//!
//! Sample code for freeing linked list
//! \code
//!   while (pMicrocodeReposIndex!= NULL) 
//!     {
//!        current = pMicrocodeReposIndex->pNext;
//!        delete pMicrocodeReposIndex;
//!        pMicrocodeReposIndex = current;
//!     }
//! \endcode
//!
//! \ingroup viducode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetLoadedMicrocodePrograms(LwDisplayHandle hLwDisplay, LW_MICROCODE_REPOS_INDEX** pMicrocodeReposIndex);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetVideoPerformanceData
//
//!  This function returns video-related performance data (frame drops, enabled video 
//!  processing features flags, etc) for the most recently played video stream. \n
//!
//!              The data is returned in a string with following format: \n
//!              TokenName1=Value1;TokenName2=Value2;TokenName3=Value3;  
//!
//!              Token names and values consist of only non-whitespace characters excluding the
//!              '=' and ';' delimiter characters. There is no whitespace between
//!              TokenNames, Values, '=', and ';' characters
//!
//! SUPPORTED OS:  Windows XP
//!
//!  
//!
//! \since Release: 95
//!
//! \retval  LWAPI_ILWALID_ARGUMENT pData is NULL 
//! \retval  LWAPI_OK               Data has been written to pData.
//! \retval  LWAPI_ERROR            Failed to retrieve performance data.
//! \ingroup vidperf
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetVideoPerformanceData(char *pData, LwU32 dataSize);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SetVideoPerformanceDataCollectionEnabled
//
//!  This function enables or disables logging of video performance data by the driver. 
//!  This data can be then collected using LwAPI_GetVideoPerformanceData call.
//!
//! SUPPORTED OS:  Windows XP
//!
//!  
//!
//! \since Release: 95
//!
//! \retval  LWAPI_OK     Logging was successfully enabled or disabled.
//! \retval  LWAPI_ERROR  Failed to set the registry flag enabling logging.
//! \ingroup vidperf
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetVideoPerformanceDataCollectionEnabled(LwU32 bEnabled);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetVideoPerformanceDataCollectionEnabled
//
//!  This function indicates whether video performance data collection is enabled.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \retval  LWAPI_ILWALID_ARGUMENT  pbEnabled is NULL 
//! \retval  LWAPI_OK                Logging status was successfully written to pbEnabled.
//! \retval  LWAPI_ERROR             Failed to get the registry flag to determine if logging is enabled.
//! \ingroup vidperf
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetVideoPerformanceDataCollectionEnabled(LwU32* pbEnabled);



//! Used in LwAPI_Video_PmmC_SetMode()
//! \ingroup vidperf 
typedef enum _LW_VIDEO_PMMC_ACTION
{
    LW_VIDEO_PMMC_DELETE       = 0,        //!< Finished. Delete report and resources
    LW_VIDEO_PMMC_START,                   //!< Enable. Allocate resources and start logging
    LW_VIDEO_PMMC_STOP,                    //!< Stop logging. Free resources (except for the report)
} LW_VIDEO_PMMC_ACTION;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Video_PmmC_SetMode
//
//!  DESCRIPTION: This function sets the video engines use of Perfmon Mode C based on the VideoPmmCSetModeAction enum. \n
//!               For information on PmmC, see lwPerfmonModeC.cpp - comments in the header.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 105
//!
//! \return  LWAPI_ERROR or LWAPI_OK
//! \ingroup vidperf
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Video_PmmC_SetMode(LW_VIDEO_PMMC_ACTION modeAction);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Video_PmmC_GetReport
//
//!  DESCRIPTION: This function gets the data from Video Perfmon Mode C. \n
//!               If pReport == NULL, then pbytesNeeded is filled so the caller 
//!               can allocate the memory.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 105
//!
//! \return LWAPI_ERROR or LWAPI_OK
//! \ingroup vidperf
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Video_PmmC_GetReport(LwU32 bytesAllocd, LwU32 *pBytesNeeded, char *pReport);



//! Used in LW_VIDEO_PMMC_DOMAIN_CONTROL_SETUP.
//! \ingroup vidperfunctions
typedef struct
{
    LwU32       version;            // structure version
    LwU32       dwControl;
    LwU32       dwTrig0Sel;
    LwU32       dwTrig1Sel;
    LwU32       dwEventSel;
    LwU32       dwSampleSel;
    LwU32       dwSampleOp;
    LwU32       engine[12];
    LwU32       sigtype[12];
} LW_VIDEO_PMMC_DOMAIN_CONTROL;

//! \ingroup vidperfunctions
#define LW_VIDEO_PMMC_DOMAIN_CONTROL_VER  MAKE_LWAPI_VERSION(LW_VIDEO_PMMC_DOMAIN_CONTROL,1)


//! Used in LwAPI_Video_Pmmc_SetDomainConfig()
//! \ingroup vidperfunctions
typedef struct
{
    LwU32                           version;            //!< structure version
    LwU32                           bEnable;
    LwU32                           dwMaxCaptureRecords;
    LwU32                           dwMaxReportRecords;
    LW_VIDEO_PMMC_DOMAIN_CONTROL    controlSetup;
} LW_VIDEO_PMMC_DOMAIN_CONTROL_SETUP;

//! \ingroup vidperfunctions
#define LW_VIDEO_PMMC_DOMAIN_CONTROL_SETUP_VER  MAKE_LWAPI_VERSION(LW_VIDEO_PMMC_DOMAIN_CONTROL_SETUP,1)


 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Video_Pmmc_SetDomainConfig
//
//!  DESCRIPTION: This function sets up the domain capture HW control for Video Perfmon Mode C
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 105
//!
//! \return LWAPI_ERROR or LWAPI_OK
//! \ingroup vidperf
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Video_Pmmc_SetDomainConfig(LwU32 domain, LW_VIDEO_PMMC_DOMAIN_CONTROL_SETUP *setupData);






// Video post-processing and color control APIs for private clients
// These add more information and include device choices


//! \ingroup vidcontrol
//! Used in LWAPI_VIDEO_GET_DEVICE_INFO.
typedef enum _LWAPI_VIDEO_STATE_DEVICE_KIND
{
    LWAPI_VIDEO_DEVICE_KIND_NONE      = -1,
    LWAPI_VIDEO_DEVICE_GLOBAL_DEFAULT     ,        //!< Default 
    LWAPI_VIDEO_DEVICE_MASK               ,        //!< By displayId
    LWAPI_VIDEO_DEVICE_EDID               ,        //!< EDID specified - there can be multiple EDIDs
    LWAPI_VIDEO_DEVICE_CONNECTOR_TYPE     ,        //!< GPU connector type
    LWAPI_VIDEO_DEVICE_KIND_LAST
} LWAPI_VIDEO_STATE_DEVICE_KIND;


//! \addtogroup vidcontrol
//! Used in LWAPI_VIDEO_GET_DEVICE_INFO.
//! @{
#define VIDEO_DEVICE_DESCRIPTION_LENGTH     40
#define VIDEO_DEVICE_REG_PREFIX_LENGTH      32
//! @}


//! \ingroup vidcontrol
//! Used in LwAPI_GetVideoDeviceInfo().
typedef struct _LWAPI_VIDEO_GET_DEVICE_INFO
{
    LwU32   version;                //!< (IN)  structure version
    LwU32   deviceIndex;            //!< (IN)  select device
    LwU32   deviceType;             //!< (OUT) specify what kind of device, one of LWAPI_VIDEO_STATE_DEVICE_KIND
    LwU32   deviceID;               //!< (OUT) device id (deviceMask, connector type, etc)
    LwU8    deviceDescription[VIDEO_DEVICE_DESCRIPTION_LENGTH];     //!< (OUT) what is the device
    LwU8    deviceRegistryPrefix[VIDEO_DEVICE_REG_PREFIX_LENGTH];   //!< (OUT) what is the device
    LwU32   bDefaultGammaCompIdx;   //!< (OUT) specifies the default gamma (Y/RGB) being used by this video device
    LwU8    reserved[4];            //!< (OUT) reserved for expansion
} LWAPI_VIDEO_GET_DEVICE_INFO;


//! \ingroup vidcontrol
//! Used in LWAPI_VIDEO_GET_DEVICE_INFO.
#define LWAPI_VIDEO_GET_DEVICE_INFO_VER  MAKE_LWAPI_VERSION(LWAPI_VIDEO_GET_DEVICE_INFO,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetVideoDeviceCount
//
//!   DESCRIPTION: This function returns the number of devices available.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \retval    LWAPI_OK
//! \retval    LWAPI_ERROR
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetVideoDeviceCount(LwDisplayHandle hLwDisplay, LwU32 *pParms);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetVideoDeviceInfo
//
//!   DESCRIPTION: This function returns information on the device selected by the index.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \retval  LWAPI_OK
//! \retval  LWAPI_NOT_SUPPORTED
//! \retval  LWAPI_ILWALID_ARGUMENT
//! \reatval LWAPI_ERROR
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetVideoDeviceInfo(LwDisplayHandle hLwDisplay, LWAPI_VIDEO_GET_DEVICE_INFO *pParms);


//! \ingroup vidcontrol
//! Active video device(s)-related enum \n
//! Used in #LWAPI_ACTIVE_VIDEO_DEVICE_INFO.
typedef enum _LWAPI_ACTIVE_VIDEO_DEVICE
{
    LWAPI_ACTIVE_VIDEO_DEVICE_USER_CHOICE =0, //!< The accompanying deviceIndex field determines the active device
    LWAPI_ACTIVE_VIDEO_DEVICE_PER_DISPLAY   , //!< Per-display settings are lwrrently active, deviceIndex is irrelevant  
    LWAPI_ACTIVE_VIDEO_DEVICE_LAST
} LWAPI_ACTIVE_VIDEO_DEVICE;


//! \ingroup vidcontrol
//! Active video device(s)-related struct /n
//! Used in LwAPI_GetActiveVideoDevice().
typedef struct _LWAPI_ACTIVE_VIDEO_DEVICE_INFO
{
    LwU32   version;        //!< (IN)     Structure version
    LwU32   activeDevice;   //!< (IN/OUT) One of LWAPI_ACTIVE_VIDEO_DEVICE, denotes setting choice
    LwU32   deviceIndex;    //!< (IN/OUT) Select device to be set active
    LwU32   reserved[5];    //!< (IN/OUT) reserved for expansion
} LWAPI_ACTIVE_VIDEO_DEVICE_INFO;


//! \ingroup vidcontrol
//! Used in LWAPI_ACTIVE_VIDEO_DEVICE_INFO.
#define LWAPI_ACTIVE_VIDEO_DEVICE_INFO_VER  MAKE_LWAPI_VERSION(LWAPI_ACTIVE_VIDEO_DEVICE_INFO,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetActiveVideoDevice
//
//!   DESCRIPTION: This function gets the active video device information that is lwrrently being
//!                used. The active device being used could correspond to a single 
//!                video device if the _USER_CHOICE enum is returned. It could also
//!                correspond to multiple video devices if the _PER_DISPLAY enum
//!                is returned.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \retval  LWAPI_OK
//! \retval  LWAPI_NOT_SUPPORTED
//! \retval  LWAPI_ILWALID_ARGUMENT
//! \retval  LWAPI_ERROR
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetActiveVideoDevice(LwDisplayHandle hLwDisplay, LWAPI_ACTIVE_VIDEO_DEVICE_INFO *pActiveVideoDevice);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SetActiveVideoDevice
//
//!   DESCRIPTION: This function sets the active video device to be used. The active device selected
//!                could either be specified as a single video device (only _GLOBAL_DEFAULT 
//!                or _DEVICE_MASK video devices can be set active); or could be 
//!                dynamically handled by the driver if per-display settings are
//!                requested by the client.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//! 
//! \retval  LWAPI_OK
//! \retval  LWAPI_NOT_SUPPORTED
//! \retval  LWAPI_ILWALID_ARGUMENT
//! \retval  LWAPI_ERROR
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetActiveVideoDevice(LwDisplayHandle hLwDisplay, LWAPI_ACTIVE_VIDEO_DEVICE_INFO *pActiveVideoDevice);





//! \ingroup vidcontrol
//! Used in LwAPI_GetVideoStateEx().
typedef struct _LWAPI_GET_VIDEO_STATE_COMPONENT_EX
{
    LwU32   version;                            //!< (IN)  Structure version
    LwU32   componentID;                        //!< (IN)  Identify the individual component
    LwU32   deviceIndex;                        //!< (IN)  Select device
    LwU32   bIsSupported                : 1;    //!< (OUT) Set if component is supported by driver
    LwU32   bIsHigherPriorityThanApp    : 1;    //!< (OUT) Flag to indicate priority of the LW Control Panel setting vs app-lwapi setting
    LwU32   bOverrideAppDefault         : 1;    //!< (OUT) Flag to indicate default priority of the LW Control Panel setting vs app-lwapi setting
    LwU32   reserved1                   : 29;   //!< (OUT) Reserved for future usage
    LwU32   isEnabled;                          //!< (OUT) Set if component is enabled by the LW Control Panel, one or more of LWAPI_VIDEO_COMPONENT_ENABLE bitmasks
    LwU32   defaultEnabledState;                //!< (OUT) Indicates the default enabled state for the LW Control Panel setting of this component
    LwU32   milwalue;                           //!< (OUT) Minimum valid value
    LwU32   maxValue;                           //!< (OUT) Maximum valid value
    LwU32   totalSteps;                         //!< (OUT) number of steps between min and max
    LwU32   defaultValue;                       //!< (OUT) defaultLW value
    LwU32   unityValue;                         //!< (OUT) Value prescribed for unity (disabled state)
    LwU32   lwrrentValueActive;                 //!< (OUT) Value in use, if it equals unity, operation can be skipped
    LwU64   defaultAlgo;                        //!< (OUT) Default algorithm
    LwU64   lwrrentAlgoActive;                  //!< (OUT) Algorithm in use
    LwU32   appValueInUse  : 1;                 //!< (OUT) Let the LW Control Panel know if the application value is set
    LwU32   appAlgoInUse   : 1;                 //!< (OUT) Let the LW Control Panel know if the application algorithm is set
    LwU32   reserved2      : 30;                //!< (OUT) Reserved for future usage
    LwU32   appValue;                           //!< (OUT) Application value
    LwU64   appAlgo;                            //!< (OUT) Application algorithm
    LwU64   lastAlgoSet;                        //!< (OUT) Last control panel algorithm set - may be different than lwrrentAlgoActive
    LwU32   lastValueSet;                       //!< (OUT) Last control panel value set - may be different than lwrrentActiveValue
    LwU32   reserved3;                          //!< (OUT) Reserved for expansion
    LwU64   reserved4[4];                       //!< (OUT) Reserved for later use

} LWAPI_GET_VIDEO_STATE_COMPONENT_EX;


//! ingroup vidcontrol
//! Used in LWAPI_GET_VIDEO_STATE_COMPONENT_EX.
#define LWAPI_GET_VIDEO_STATE_COMPONENT_EX_VER  MAKE_LWAPI_VERSION(LWAPI_GET_VIDEO_STATE_COMPONENT_EX,1)


//! \ingroup vidcontrol
//! Used in LwAPI_SetVideoStateEx().
typedef struct _LWAPI_SET_VIDEO_STATE_COMPONENT_EX
{
    LwU32   version;                            //!< (IN)  Structure version
    LwU32   componentID;                        //!< (IN)  Identify the individual state
    LwU32   deviceIndex;                        //!< (IN)  Selects the device
    LwU32   bIsTopPriority  :1;                 //!< (IN)  Flag to indicate priority of control panel setting vs app-lwapi setting
    LwU32   reserved1       :31;                //!< (IN)  Reserved for expansion
    LwU32   enable;                             //!< (IN)  Flag to enable control panel setting of component, one or more of LWAPI_VIDEO_COMPONENT_ENABLE bitmasks
    LwU32   setToValue;                         //!< (IN)  Value to use
    LwU64   setToAlgo;                          //!< (IN)  Algorithm to use
    LwU32   retStatus;                          //!< (OUT) Result of video-component-set operation; a combination of VIDEO_COMP_STATUS_xxx bitmasks 
    LwU32   reserved2;                          //!< (IN)  Reserved for later use
    LwU64   reserved3[3];                       //!< (IN)  Reserved for later use

} LWAPI_SET_VIDEO_STATE_COMPONENT_EX;


//! \ingroup vidcontrol
//! Used in LWAPI_SET_VIDEO_STATE_COMPONENT_EX. 
#define LWAPI_SET_VIDEO_STATE_COMPONENT_EX_VER  MAKE_LWAPI_VERSION(LWAPI_SET_VIDEO_STATE_COMPONENT_EX,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetVideoStateEx
//
//!   DESCRIPTION: This function returns the video state component for the control panel 
//!                for the componentID passed in. Clients may use this call to 
//!                retrieve the component state for any video device (for example global,
//!                displayId-specific, etc.) by specifying the appropriate device 
//!                index that has been enumerated using LwAPI_GetVideoDeviceInfo().
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \retval  LWAPI_OK
//! \retval  LWAPI_ILWALID_ARGUMENT
//! \retval  LWAPI_ERROR
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetVideoStateEx(LwDisplayHandle hLwDisplay, LWAPI_GET_VIDEO_STATE_COMPONENT_EX *pParms);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SetVideoStateEx
//
//!   DESCRIPTION: This function sets the video state component using the control panel. Clients
//!                may use this call to set the value/algorithm of a video component
//!                for any video device by supplying the device index. Please note
//!                that simply setting a value/algorithm for a particular video 
//!                component on a specific video device does not necessarily mean
//!                that this setting will be immediately applied to the video. 
//!                The setting will be immediately applied only if the current active
//!                device corresponds to the requested video device using this API.
//!                Clients may inquire about the current active video devices using
//!                the LwAPI_GetActiveVideoDevice() call. \n
//!                 
//!                The video component setting is determined using the following flags: 
//!
//!    <table>
//!    <tr> <td>bIsTopPriority</td>  <td>bEnableXXX</td>   <td>Value Source</td> </tr>
//!    <tr> <td>0</td>               <td>0</td>            <td>If present, Application LWAPI value; else defaultLW value</td> </tr>
//!    <tr> <td>0</td>               <td>1</td>            <td>If present, Application LWAPI value; else LW Control Panel value</td> </tr>
//!    <tr> <td>1</td>               <td>0</td>            <td>If present, Application LWAPI value; else defaultLW value</td> </tr>
//!    <tr> <td>1</td>               <td>1</td>            <td>The LW Control Panel value</td> </tr>
//!    </table>
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170  
//!
//! \retval  ::LWAPI_OK
//! \retval  ::LWAPI_ILWALID_ARGUMENT
//! \retval  ::LWAPI_ERROR
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetVideoStateEx(LwDisplayHandle hLwDisplay, LWAPI_SET_VIDEO_STATE_COMPONENT_EX *pParms);






// Let the control panel retrieve info on the various streams
    

//! \ingroup vidcontrol
//! Used in #LWAPI_VIDEO_GET_STREAM_INFO.
typedef enum _LWAPI_VIDEO_FORMAT_LAYOUT
{
    LWAPI_VIDEO_FMT_NONE          = 0,
    LWAPI_VIDEO_FMT_INTERLACED       ,
    LWAPI_VIDEO_FMT_PROGRESSIVE      ,
    LWAPI_VIDEO_FMT_FIELD            ,
    LWAPI_VIDEO_FMT_LAST
} LWAPI_VIDEO_FORMAT_LAYOUT;


//! \ingroup vidcontrol
//! Used in #LWAPI_VIDEO_GET_STREAM_INFO.
#define APP_NAME_LENGTH 64


//! \ingroup vidcontrol
//! Used in LwAPI_GetVideoStreamInfo().
typedef struct _LWAPI_VIDEO_GET_STREAM_INFO
{
    LwU32   version;                        //!< (IN)  Structure version, constructed from the macro #LWAPI_VIDEO_GET_STREAM_INFO_VER 
    LwU32   streamIndex;                    //!< (IN)  Selected stream
    LwU32   deviceIndex;                    //!< (OUT) Specifies which device is being applied to the stream
    LwU32   processID;                      //!< (OUT) Application process ID
    LwU8    processName[APP_NAME_LENGTH];   //!< (OUT) Application name
    LwU32   streamSrcWidth;                 //!< (OUT) Source width
    LwU32   streamSrcHeight;                //!< (OUT) Source height
    LwU32   streamSrcFormat;                //!< (OUT) Source fourCC format
    LwU32   streamFormatLayout;             //!< (OUT) Interlaced or progressive, one of #LWAPI_VIDEO_FORMAT_LAYOUT
    LwU32   streamSrcColorSpace;            //!< (OUT) colorspace of source, one of VIDEO_COMP_ALGO_COLOR_SPACE_xxx bitmask
    LwU32   streamDstWidth;                 //!< (OUT) Destination width
    LwU32   streamDstHeight;                //!< (OUT) Destination height
    LwU32   streamDstFormat;                //!< (OUT) Desination fourCC format
    LwU32   streamDstColorSpace;            //!< (OUT) Destination colorspace - one of VIDEO_COMP_ALGO_COLOR_SPACE_xxx bitmask
    LwU32   streamDstColorRange;            //!< (OUT) Destination color range - one of VIDEO_COMP_ALGO_COLOR_RANGE_xxx bitmask
    double  streamFreq;                     //!< (OUT) Video stream frequency reported by the application, not usable right now = 0
    double  streamFreqDetected;             //!< (OUT) Video stream frequency detected from the driver
    double  streamFreqPlayback;             //!< (OUT) Actual playback frequency
    LwU32   lwrPState;                      //!< (OUT) The current P-state
    LwU32   lwrPstateTuningAction;          //!< (OUT) The status of P-state tuning
    LwU64   lastUpdateTime;                 //!< (OUT) The last time that the stream is updated, use performance count/frequency
    LwU64   reserved;                       //!< (OUT) Reserved for future use
} LWAPI_VIDEO_GET_STREAM_INFO;


//! \ingroup vidcontrol
//! Used in #LWAPI_VIDEO_GET_STREAM_INFO.
#define LWAPI_VIDEO_GET_STREAM_INFO_VER  MAKE_LWAPI_VERSION(LWAPI_VIDEO_GET_STREAM_INFO,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetVideoStreamCount
//
//!   DESCRIPTION: This function returns the number of streams that are active.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \retval  LWAPI_OK
//! \reatval LWAPI_ERROR
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetVideoStreamCount(LwDisplayHandle hLwDisplay, LwU32 *pParms);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetVideoStreamInfo
//
//!   DESCRIPTION: This function gets the stream information by video context using the control panel.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \retval LWAPI_OK
//! \retval LWAPI_ILWALID_ARGUMENT
//! \retval LWAPI_ERROR
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetVideoStreamInfo(LwDisplayHandle hLwDisplay, LWAPI_VIDEO_GET_STREAM_INFO *pParms);





///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GetAdaptiveContrastInfo()
//
//! \fn LwAPI_GetAdaptiveContrastInfo(LwDisplayHandle hLwDisplay, LW_ADAPTIVE_CONTRAST_INFO *pCfg)
//! DESCRIPTION:    This API gets the parameters for adaptive contrast enchancement and color shift/squeeze.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]     hLwDisplay  LWPU Display selection \n
//!                 It can be #LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//!
//! \retval ::LWAPI_OK  
//! \retval ::LWAPI_ERROR
//! \retval ::LWAPI_API_NOT_INTIALIZED
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup vidcontrol
//! Used in LW_ADAPTIVE_CONTRAST_INFO.
#define LW_ADAPTIVE_CONTRAST_INFO_NUM_CONSTS 128

//! \ingroup vidcontrol
//! Used in LwAPI_GetAdaptiveContrastInfo() and LwAPI_SetAdaptiveContrastInfo().
typedef struct
{
    LwU32   version;                //!< Structure version
    LwU32   consts[LW_ADAPTIVE_CONTRAST_INFO_NUM_CONSTS];
     //!< -0-16 YUV2RGB coefs
     //! -16-24 maxdistance
     //! -24-32 squeeze constants
     //! -32-64 sliders
     //! -64-128 YUV regions for green,red, skin                                    
}LW_ADAPTIVE_CONTRAST_INFO;

//! \ingroup vidcontrol
//! Used in LW_ADAPTIVE_CONTRAST_INFO.
#define LW_ADAPTIVE_CONTRAST_INFO_VER  MAKE_LWAPI_VERSION(LW_ADAPTIVE_CONTRAST_INFO,1)


//! \ingroup vidcontrol
LWAPI_INTERFACE LwAPI_GetAdaptiveContrastInfo(LwDisplayHandle hLwDisplay, LW_ADAPTIVE_CONTRAST_INFO *pCfg);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SetAdaptiveContrastInfo()
//
//! DESCRIPTION:     This API sets the parameters for adaptive contrast enchancement and color shift/squeeze.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]     hLwDisplay  LWPU Display selection \n
//!                 It can be #LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//!
//! \retval ::LWAPI_OK  
//! \retval ::LWAPI_ERROR
//! \retval ::LWAPI_API_NOT_INTIALIZED
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetAdaptiveContrastInfo(LwDisplayHandle hLwDisplay, LW_ADAPTIVE_CONTRAST_INFO *pCfg);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GPU_SetVidPnInfo
//
//! DESCRIPTION:    This API allows the caller to inform the driver of any display
//!                 change events so that the VidPnSrcId's may be updated.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 173
//!
//! \param [in]     hPhysicalGpu            GPU selection
//!
//! \retval ::LWAPI_OK  
//! \retval ::LWAPI_ERROR
//! \retval ::LWAPI_ILWALID_ARGUMENT
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////    
LWAPI_INTERFACE LwAPI_GPU_SetVidPnInfo(LwPhysicalGpuHandle hPhysicalGpu);





///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GetVideoState
//
//! \fn LwAPI_GetVideoState(LwDisplayHandle hLwDisplay, LWAPI_GET_VIDEO_STATE_COMPONENT *pGetVidStateComp)
//! DESCRIPTION:     This function return the video state component for the component ID passed in. It is the responsibility
//!                  of the caller to fill secret application key that enables authentication of the caller.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]      hLwDisplay        LWPU Display selection \n
//!                                    It can be #LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [out]     pGetVidStateComp  LWAPI_GET_VIDEO_STATE_COMPONENT packet containing
//!                                    a valid component ID and a valid application secret key.
//!
//! \retval ::LWAPI_OK  
//! \retval ::LWAPI_ERROR
//! \retval ::LWAPI_ILWALID_ARGUMENT
//
///////////////////////////////////////////////////////////////////////////////

#ifndef LW_VIDEO_COMPONENTS_DEFINE
#define LW_VIDEO_COMPONENTS_DEFINE

///////////////////////////////////////////////////////////////////////////////
// Structs and enums related to Video state
///////////////////////////////////////////////////////////////////////////////


//! \ingroup vidcontrol
//! Components related to video state \n
//! Used in LWAPI_GET_VIDEO_STATE_COMPONENT and LWAPI_SET_VIDEO_STATE_COMPONENT.
typedef enum _LWAPI_VIDEO_STATE_COMPONENT_ID
{
    LWAPI_VIDEO_STATE_COMPONENT_ID_NONE     = -1,   //!< Placeholder for invalid component ID
    LWAPI_VIDEO_STATE_COMPONENT_BRIGHTNESS      ,   //!<  Permits control of video's brightness value
    LWAPI_VIDEO_STATE_COMPONENT_CONTRAST        ,   //!<  Allows control of video's contrast value
    LWAPI_VIDEO_STATE_COMPONENT_HUE             ,   //!<  To control the hue value
    LWAPI_VIDEO_STATE_COMPONENT_SATURATION      ,   //!<  Allows control of video's saturation value
    LWAPI_VIDEO_STATE_COMPONENT_COLORTEMP       ,   //!<  Allows control of the color temperature value
    LWAPI_VIDEO_STATE_COMPONENT_Y_GAMMA         ,   //!<  To set the Y-gamma values
    LWAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_R     ,   //!<  To set the R value of RGB gamma
    LWAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_G     ,   //!<  To set the G value of RGB gamma
    LWAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_B     ,   //!<  To set the B value of RGB gamma
    LWAPI_VIDEO_STATE_COMPONENT_COLOR_SPACE     ,   //!<  Permits choice of various color spaces using VIDEO_COMP_ALGO_COLOR_SPACE_xxx
    LWAPI_VIDEO_STATE_COMPONENT_COLOR_RANGE     ,   //!<  Allows setting between a limited/full color range using VIDEO_COMP_ALGO_COLOR_RANGE_xxx
    LWAPI_VIDEO_STATE_COMPONENT_PLAYBACK_PROFILE,   //!<  Permits using special postprocessing for Adobe Flash 9 Content
    LWAPI_VIDEO_STATE_COMPONENT_DEINTERLACE     ,   //!<  To set various types of deinterlacing algorithms
    LWAPI_VIDEO_STATE_COMPONENT_SCALING         ,   //!<  Allows setting video scaling algorithms
    LWAPI_VIDEO_STATE_COMPONENT_CADENCE         ,   //!<  Allows control of the cadence algorithms
    LWAPI_VIDEO_STATE_COMPONENT_NOISE_REDUCE    ,   //!<  Allows setting post-processing noise reduction values
    LWAPI_VIDEO_STATE_COMPONENT_EDGE_ENHANCE    ,   //!<  Permits post-processing edge enhancement value adjustment
    LWAPI_VIDEO_STATE_COMPONENT_OVERDRIVE       ,   //!<  To control the overdrive feature
    LWAPI_VIDEO_STATE_COMPONENT_SPLITSCREEN     ,   //!<  To permit setting a splitscreen using one of VIDEO_COMP_ALGO_SPLITSCREEN_xxx
    LWAPI_VIDEO_STATE_COMPONENT_DEBLOCKING      ,   //!<  Allows out-of-loop deblocking
    LWAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONTRAST,   //!<  Permits control of video's dynamic contrast value
    LWAPI_VIDEO_STATE_COMPONENT_GREEN_STRETCH   ,   //!<  Permits control of green stretch
    LWAPI_VIDEO_STATE_COMPONENT_BLUE_STRETCH    ,   //!<  Allows control of blue enhancement
    LWAPI_VIDEO_STATE_COMPONENT_SKIN_TONE_CORRECTION, //!<  Allows skin-tone correction for video 
    LWAPI_VIDEO_STATE_COMPONENT_GAMUT_REMAPPING ,   //!<  Applies gamut remapping on video
    LWAPI_VIDEO_STATE_COMPONENT_2DTO3D          ,   //!< Colwerts 2D video to 3D stereo video
    LWAPI_VIDEO_STATE_COMPONENT_3D_ANALYSIS     ,   //!< Analyzing 3D stereo video
    LWAPI_VIDEO_STATE_COMPONENT_FRC             ,   //!< Frame Rate Colwerter
    LWAPI_VIDEO_STATE_COMPONENT_BEN             ,   //!< Applies deblocking on video
    LWAPI_VIDEO_STATE_COMPONENT_ID_LAST         ,   //!< All valid components defined before this one
} LWAPI_VIDEO_STATE_COMPONENT_ID;

//! \ingroup vidcontrol 
//! Dynamic contrast value. Kept this for backward compatibility.
#define LWAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONSTRAST  LWAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONTRAST  


//! \ingroup vidcontrol
//! Used in #_LWAPI_VIDEO_COMPONENT_ALGORITHM.
#define VIDEO_COMP_ALGO_LWSTOM_BASE 64

//! \ingroup vidcontrol
//! Algorithms controlling various video components
//! Used in LWAPI_GET_VIDEO_STATE_COMPONENT and LWAPI_SET_VIDEO_STATE_COMPONENT.
typedef enum _LWAPI_VIDEO_COMPONENT_ALGORITHM
{
    VIDEO_COMP_ALGO_COLOR_SPACE_601                  = 0,  //!<  Use the ITU-R BT.601 standard in color-space colwersion for xxx_COLOR_SPACE component
    VIDEO_COMP_ALGO_COLOR_SPACE_709                  = 1,  //!<  Use the ITU-R BT.709 standard in color-space colwersion for xxx_COLOR_SPACE component
    VIDEO_COMP_ALGO_COLOR_SPACE_LWSTOM_04            = VIDEO_COMP_ALGO_LWSTOM_BASE+4,   //!< Use custom color matrix.
    VIDEO_COMP_ALGO_COLOR_RANGE_STD                  = 0,  //!<  Full range of (0-255) for xxx_COLOR_RANGE component, equivalent to Microsoft's DXVADDI_NOMINALRANGE::DXVADDI_NominalRange_0_255
    VIDEO_COMP_ALGO_COLOR_RANGE_EXT                  = 1,  //!<  Limited range of (16-235) for xxx_COLOR_RANGE component, equivalent to Microsoft's DXVADDI_NOMINALRANGE::DXVADDI_NominalRange_16_235
    VIDEO_COMP_ALGO_PLAYBACK_PROFILE_NONE            = 0,  //!<  Use no playback profile
    VIDEO_COMP_ALGO_PLAYBACK_PROFILE_ADOBE_FLASH_9   = 1,  //!<  Use the internet video enhancement postprocessing for Adobe Flash 9 
    VIDEO_COMP_ALGO_DEINTERLACE_BOB                  = 0,  //!<  Perform Bob deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_WEAVE                = 1,  //!<  Use weave deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_SIMPLE_ADAPTIVE      = 2,  //!<  Perform a simple motion adaptive deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_GRADIENT_SIMPLE      = 3,  //!<  Use a simple gradient deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_GRADIENT_FULL        = 4,  //!<  Use advanced gradient deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_ADAPTIVE_FOUR_FIELD  = 5,  //!<  Perform four field motion adaptive deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_DIR_SPATIAL          = 6,  //!<  User directional spatial deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_ADVANCED             = 7,  //!<  Perform proprietary advanced deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_GPU_CAPABLE          = 8,  //!<  Best available but GPU dependent. (video driver decides dynamically) 
    VIDEO_COMP_ALGO_DEINTERLACE_LWSTOM_00            = VIDEO_COMP_ALGO_LWSTOM_BASE+0,    //!< Use custom Deinterlacing algorithm
    VIDEO_COMP_ALGO_DEINTERLACE_LWSTOM_01            = VIDEO_COMP_ALGO_LWSTOM_BASE+1,    //!< Use custom Deinterlacing algorithm
    VIDEO_COMP_ALGO_SCALING_ALG_SIMPLE               = 0,  //!<  Do scaling using a simple algorithm       
    VIDEO_COMP_ALGO_SCALING_ALG_4x4FILTER            = 1,  //!<  Perform scaling using a 4x4 filter
    VIDEO_COMP_ALGO_SCALING_ALG_8x8FILTER            = 2,  //!< Perform scaling using a 8x8 filter
    VIDEO_COMP_ALGO_SCALING_ALG_LWSTOM_00            = VIDEO_COMP_ALGO_LWSTOM_BASE+0,    //!< Use custom scaling component
    VIDEO_COMP_ALGO_SCALING_ALG_LWSTOM_01            = VIDEO_COMP_ALGO_LWSTOM_BASE+1,    //!< Use custom scaling component
    VIDEO_COMP_ALGO_CADENCE_NONE                     = 0,  //!<  Turn cadence OFF
    VIDEO_COMP_ALGO_CADENCE_SIMPLE                   = 1,  //!<  Use simple cadence detection
    VIDEO_COMP_ALGO_CADENCE_VOF                      = 2,  //!<  Use video on film cadence detection
    VIDEO_COMP_ALGO_CADENCE_COMPUTE                  = 3,  //!<  Use compute cadence detection
    VIDEO_COMP_ALGO_CADENCE_GPU_CAPABLE              = 4,  //!<  Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_NOISE_REDUCE_PUREVIDEO           = 0,  //!<  Use PureVideo noise reduction
    VIDEO_COMP_ALGO_NOISE_REDUCE_LWSTOM_00           = VIDEO_COMP_ALGO_LWSTOM_BASE+0,  //!< Use custom noise reduction
    VIDEO_COMP_ALGO_NOISE_REDUCE_LWSTOM_01           = VIDEO_COMP_ALGO_LWSTOM_BASE+1,  //!< Use custom noise reduction
    VIDEO_COMP_ALGO_EDGE_ENHANCE_PUREVIDEO           = 0,  //!<  Use PureVideo Sharpening Filter
    VIDEO_COMP_ALGO_EDGE_ENHANCE_LWSTOM_00           = VIDEO_COMP_ALGO_LWSTOM_BASE+0,  //!< Use custom Sharpening Filter
    VIDEO_COMP_ALGO_EDGE_ENHANCE_LWSTOM_01           = VIDEO_COMP_ALGO_LWSTOM_BASE+1,  //!< Use custom Sharpening Filter
    VIDEO_COMP_ALGO_OVERDRIVE_SIMPLE                 = 0,  //!<  Use simple overdrive algorithm
    VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_NORMAL          = 0,  //!<  Set the splitscreen in normal mode
    VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_REPEATED        = 1,  //!<  Set the splitscreen to be repeated
    VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_ON_MIRROR       = 2,  //!<  Set the splitscreen as a mirror
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_NONE     = 0,  //!<  Use the value setting for dynamic contrast instead of a preset
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_LOW      = 1,  //!<  Turn the dynamic contrast to a low setting
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_MEDIUM   = 2,  //!<  Turn the dynamic contrast to a medium setting
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_HIGH     = 3,  //!<  Turn the dynamic contrast to a high setting
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_NONE        = 0,  //!<  Use the value setting for green stretch instead of a preset
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_LOW         = 1,  //!<  Set the green strech to a low setting
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_MEDIUM      = 2,  //!<  Set the green strech to a medium setting
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_HIGH        = 3,  //!<  Set the green strech to a high setting
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_NONE         = 0,  //!<  Use the value setting for blue stretch instead of a preset   
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_LOW          = 1,  //!<  Set the blue strech to a low setting
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_MEDIUM       = 2,  //!<  Set the blue strech to a medium setting
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_HIGH         = 3,  //!<  Set the blue strech to a high setting
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_NONE = 0,  //!<  Use the value setting for skin tone correction instead of a preset  
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_SQUEEZE = 1,  //!<  Turn the skin tone correction to a low setting
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_RED     = 2,  //!<  Turn the skin tone correction to a medium setting
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_YELLOW  = 3,  //!<  Turn the skin tone correction to a high setting
    VIDEO_COMP_ALGO_GAMUT_REMAPPING_LWSTOM_00        = VIDEO_COMP_ALGO_LWSTOM_BASE+0, //!< Use custom 3x3 gamut remapping matrix
    VIDEO_COMP_ALGO_GAMUT_REMAPPING_LWSTOM_01        = VIDEO_COMP_ALGO_LWSTOM_BASE+1, //!< Use custom 3x3 gamut remapping matrix
    VIDEO_COMP_ALGO_2DTO3D_LWSTOM_00                 = VIDEO_COMP_ALGO_LWSTOM_BASE+0, //!< Use custom 2Dto3D colwersion
    VIDEO_COMP_ALGO_2DTO3D_LWSTOM_01                 = VIDEO_COMP_ALGO_LWSTOM_BASE+1, //!< Use custom 2Dto3D colwersion
    VIDEO_COMP_ALGO_3D_ANALYSIS_LWSTOM_00            = VIDEO_COMP_ALGO_LWSTOM_BASE+0, //!< Use custom 3DAnalysis algorithm
    VIDEO_COMP_ALGO_3D_ANALYSIS_LWSTOM_01            = VIDEO_COMP_ALGO_LWSTOM_BASE+1, //!< Use custom 3DAnalysis algorithm
    VIDEO_COMP_ALGO_FRC_LWSTOM_00                    = VIDEO_COMP_ALGO_LWSTOM_BASE+0, //!< Use custom frame rate colwerter
    VIDEO_COMP_ALGO_FRC_LWSTOM_01                    = VIDEO_COMP_ALGO_LWSTOM_BASE+1, //!< Use custom frame rate colwerter
    VIDEO_COMP_ALGO_BEN_LWSTOM_00                    = VIDEO_COMP_ALGO_LWSTOM_BASE+0, //!< Use custom deblocking algorithm
    VIDEO_COMP_ALGO_BEN_LWSTOM_01                    = VIDEO_COMP_ALGO_LWSTOM_BASE+1, //!< Use custom deblocking algorithm
} LWAPI_VIDEO_COMPONENT_ALGORITHM;


//! \ingroup vidcontrol
//! Bitmasks for video components' enable at various resolutions
//! Used in LWAPI_GET_VIDEO_STATE_COMPONENT and LWAPI_SET_VIDEO_STATE_COMPONENT.
typedef enum _LWAPI_VIDEO_COMPONENT_ENABLE
{
    VIDEO_COMP_ENA_480i     = 0x00000001, //!<  component is enabled at 480i video resolution
    VIDEO_COMP_ENA_480p     = 0x00000002, //!<  component is enabled at 480p video resolution
    VIDEO_COMP_ENA_576i     = 0x00000004, //!<  component is enabled at 576i video resolution
    VIDEO_COMP_ENA_576p     = 0x00000008, //!<  component is enabled at 576p video resolution
    VIDEO_COMP_ENA_720p     = 0x00000010, //!<  component is enabled at 720p video resolution
    VIDEO_COMP_ENA_1080i    = 0x00000020, //!<  component is enabled at 1080i video resolution
    VIDEO_COMP_ENA_1080p    = 0x00000040, //!<  component is enabled at 1080p video resolution
} LWAPI_VIDEO_COMPONENT_ENABLE;


//! \ingroup vidcontrol
//! Packet that facilitates retrieving information about a video component \n
//! Used in LwAPI_GetVideoState().
typedef struct _LWAPI_GET_VIDEO_STATE_COMPONENT
{
    LwU32   version;                    //!<  (IN)  LWAPI version that matches LWAPI_GET_VIDEO_STATE_COMPONENT_VER
    LwU32   componentID;                //!<  (IN)  identify the individual component, one of LWAPI_VIDEO_STATE_COMPONENT_xxx enums
    LwU32   bIsSupported        : 1;    //!<  (OUT) set if this component feature is supported
    LwU32   bIsOverridenByUser  : 1;    //!<  (OUT) set if component is overriden by user's choice
    LwU32   reserved1           : 30;   //!<  (OUT) reserved for future expansion
    LwU32   isEnabled;                  //!<  (OUT) set if component is enabled, one or more of LWAPI_VIDEO_COMPONENT_ENABLE bitmasks
    LwU32   milwalue;                   //!<  (OUT) min valid value
    LwU32   maxValue;                   //!<  (OUT) max valid value
    LwU32   totalSteps;                 //!<  (OUT) number of steps between min and max
    LwU32   defaultValue;               //!<  (OUT) pre-defined LWPU default
    LwU32   unityValue;                 //!<  (OUT) unity is the disable value for a component
    LwU32   lwrrentValueActive;         //!<  (OUT) value in use
    LwU64   defaultAlgo;                //!<  (OUT) default algo, one or more of #LWAPI_VIDEO_COMPONENT_ALGORITHM enums
    LwU64   lwrrentAlgoActive;          //!<  (OUT) Algorithm in use, one or more of #LWAPI_VIDEO_COMPONENT_ALGORITHM enums
    union
    {
        LwU64 qwReserved[9];            
        struct
        {
            LwU32   dwAppKey;           //!< (IN) Secret key to authenticate the caller, used ONLY in LwAPI_SetVideoState()
            LwU32   bTopPriority   : 1; //!< (OUT)Indicates that these settings have precedence over D3D LwAPI settings;  valid ONLY in LwAPI_GetVideoState()
            LwU32   bHasLwstomAlgo : 1; //!< (OUT)Indicates whether Out-of-process application has custom algorithm data
            LwU32   bReserved      : 30;//!< (OUT)Reserved for expansion   
            struct
            {
                LwU64   pData;          //!< (IN) Buffer to hold the retrieved custom algorithm data
                LwU32   dwSize;         //!< (IN) Size in Bytes of the above buffer, must be <= LWAPI_VIDEO_STATE_MAX_LWSTOM_ALGO_SIZE.
            } lwstomAlgo;
        } appInfo; 
    }; 
} LWAPI_GET_VIDEO_STATE_COMPONENT;

//! \ingroup vidcontrol
//! Used in LWAPI_GET_VIDEO_STATE_COMPONENT.
#define LWAPI_GET_VIDEO_STATE_COMPONENT_VER  MAKE_LWAPI_VERSION(LWAPI_GET_VIDEO_STATE_COMPONENT,1)

//! \ingroup vidcontrol
//! Return status after attempting to set a video component
//! Used in LWAPI_SET_VIDEO_STATE_COMPONENT.
typedef enum _LWAPI_VIDEO_COMP_RETURN_STATUS
{
    VIDEO_COMP_STATUS_SUCCESS                   = 0x00000000, //!< Video component is set successfully
    VIDEO_COMP_STATUS_UNSUCCESSFUL              = 0x00000001, //!< Failed to set video component
    VIDEO_COMP_STATUS_COMPONENT_NOT_SUPPORTED   = 0x00000002, //!< Video component is not supported
    VIDEO_COMP_STATUS_VALUE_OUT_OF_RANGE        = 0x00000004, //!< Video component's value is invalid and does not fall into range
    VIDEO_COMP_STATUS_ALGO_NOT_RECOGNIZED       = 0x00000008, //!< Video component's algorithm is invalid 
    VIDEO_COMP_STATUS_OVERRIDDEN_BY_USER        = 0x00000010, //!< Request not completed because of user-mandated override
    VIDEO_COMP_STATUS_Y_GAMMA_ENABLED           = 0x00000020, //!< Cannot set RGB-gamma because Y-Gamma is already enabled
    VIDEO_COMP_STATUS_RGB_GAMMA_ENABLED         = 0x00000040, //!< Cannot set Y-gamma because RGB-Gamma is already enabled
} LWAPI_VIDEO_COMP_RETURN_STATUS;

// Packet containing information to allow setting the video component

#define LWAPI_VIDEO_STATE_MAX_LWSTOM_ALGO_SIZE 128

//! \ingroup vidcontrol
//! Used in LwAPI_SetVideoState().
typedef struct _LWAPI_SET_VIDEO_STATE_COMPONENT
{
    LwU32   version;                        //!< (IN) LWAPI version that matches LWAPI_SET_VIDEO_STATE_COMPONENT_VER
    LwU32   componentID;                    //!< (IN) identify the individual component, one of LWAPI_VIDEO_STATE_COMPONENT_xxx enums
    LwU32   enable;                         //!< (IN) flag to enable setting of component, one or more of LWAPI_VIDEO_COMPONENT_ENABLE bitmasks
    LwU32   setToValue;                     //!< (IN) value to use
    LwU64   setToAlgo;                      //!< (IN) algorithm to use
    LwU32   retStatus;                      //!< (OUT) result of video-component-set operation; a combination of VIDEO_COMP_STATUS_xxx bitmasks 
    LwU32   reserved;

    union
    {
        LwU64 qwReserved[4];
        struct
        {
            LwU32   dwAppKey;               //!< (IN) Secret key to authenticate the caller, ONLY used in LwAPI_SetVideoState
            LwU32   bTopPriority       : 1; //!< (IN) Force these settings to have priority over D3D LwAPI settings, ONLY valid in LwAPI_GetVideoState
            LwU32   bHasLwstomAlgo     : 1; //!< (IN) Out-of-process application has custom algorithm data
            LwU32   bReserved          : 30;//!< (IN) reserved for expansion
            struct
            {
                LwU64   pData;              //!< (IN) (Used only when bHasLwstomAlgo == 1) Pointer to the custom algorithm data.
                LwU32   dwSize;             //!< (IN) (Used only when bHasLwstomAlgo == 1) Size in Bytes of the custom algorithm data, must be <= LWAPI_VIDEO_STATE_MAX_LWSTOM_ALGO_SIZE.
            } lwstomAlgo;
        } appInfo; 
    }; 
} LWAPI_SET_VIDEO_STATE_COMPONENT;


//! \ingroup vidcontrol
//! Used in LWAPI_SET_VIDEO_STATE_COMPONENT.
#define LWAPI_SET_VIDEO_STATE_COMPONENT_VER  MAKE_LWAPI_VERSION(LWAPI_SET_VIDEO_STATE_COMPONENT,1)

#endif // ifndef LW_VIDEO_COMPONENTS_DEFINE



//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetVideoState(LwDisplayHandle hLwDisplay, LWAPI_GET_VIDEO_STATE_COMPONENT *pGetVidStateComp);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SetVideoState
//
//! DESCRIPTION:    This API that allows callers to set a particular video state component. It is the responsibility
//!                  of the caller to fill the secret application key that enables authentication of the caller.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]     hLwDisplay(IN)     LWPU Display selection \n
//!                                    It can be #LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]     pSetVidStateComp   LWAPI_SET_VIDEO_STATE_COMPONENT packet containing 
//!                                    a valid component ID and a valid application secret key.                                  
//! \retval ::LWAPI_OK  
//! \retval ::LWAPI_ERROR
//! \retval ::LWAPI_ILWALID_ARGUMENT
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetVideoState(LwDisplayHandle hLwDisplay, LWAPI_SET_VIDEO_STATE_COMPONENT *pSetVidStateComp);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SetFrameRateNotify
//
//! \fn LwAPI_SetFrameRateNotify(LwDisplayHandle hLwDisplay, LWAPI_FRAME_RATE_NOTIFY_INFO* pFRNotifyInfo)
//! DESCRIPTION:     This API signals the driver to turn on/off notification to
//!                  the service application of the video frame rate. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 175
//!
//!  \param [in]    hLwDisplay     LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated 
//!                                from LwAPI_EnumLWidiaDisplayHandle().
//!  \param [in]    pFRNotifyInfo  Pointer to the supplied LWAPI_FRAME_RATE_NOTIFY_INFO struct.
//!
//!  \retval ::LWAPI_OK 
//!  \retval ::LWAPI_ERROR 
//!  \retval ::LWAPI_ILWALID_ARGUMENT
//!
//!  \ingroup vidcontrol
//
///////////////////////////////////////////////////////////////////////////////    


//! \ingroup vidcontrol
//! Structure containing the video frame rate notification instructions - used in LwAPI_SetFrameRateNotify()
typedef struct _LWAPI_FRAME_RATE_NOTIFY_INFO
{
    LwU32   version;                //!< (IN) Version of this struct constructed from the macro #LWAPI_FRAME_RATE_NOTIFY_INFO_VER
    LwU64   hWnd;                   //!< (IN) The window handle of the service application handling the RR adjust
    LwU32   bEnable         : 1;    //!< (IN) To turn feature ON/OFF
    LwU32   bReserved       : 31;   //!< (IN/OUT) Reserved for later use
} LWAPI_FRAME_RATE_NOTIFY_INFO;


//! \ingroup vidcontrol
//! Macro for constructing the version field of  LWAPI_FRAME_RATE_NOTIFY_INFO
#define LWAPI_FRAME_RATE_NOTIFY_INFO_VER  MAKE_LWAPI_VERSION(LWAPI_FRAME_RATE_NOTIFY_INFO,1)


//! \ingroup vidcontrol
LWAPI_INTERFACE LwAPI_SetFrameRateNotify(LwDisplayHandle hLwDisplay, LWAPI_FRAME_RATE_NOTIFY_INFO* pFRNotifyInfo);







///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SetPVExtName
//
//! DESCRIPTION:     This API specifies the name of the PureVideo extension DLL
//!                  to be used when custom algorithms are
//!                  enabled via LwAPI_SetVideoState() calls.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! 
//! \since Release: 185
//!
//! \param [in]    hLwDisplay   LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated
//!                             from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]    szDllName    Name of the DLL to be used for custom algorithms
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_ILWALID_ARGUMENT 
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetPVExtName(LwDisplayHandle hLwDisplay, const char *szDllName);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GetPVExtName
//
//! DESCRIPTION:     This API retrieves the name of the PureVideo extension DLL
//!                  to be used when custom algorithms are
//!                  enabled via LwAPI_SetVideoState() calls.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! 
//! \since Release: 190
//!
//! \param [in]      hLwDisplay  LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated
//!                              from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]      szDllName   Name of the DLL that's lwrrently registered with the driver
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_ILWALID_ARGUMENT 
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetPVExtName(LwDisplayHandle hLwDisplay, LwAPI_String szDllName);

//! SUPPORTED OS:  Windows XP and higher
//!
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SetPVExtProfile
//
//! DESCRIPTION:     This API specifies the profile number that the PureVideo 
//!                  extension DLL should use.
//!
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! 
//! \since Release: 190
//!
//! \param [in]     hLwDisplay  LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE
//!                             or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]     dwProfile   The profile number 
//!
//! \retval ::LWAPI_OK                completed request
//! \retval ::LWAPI_ERROR             miscellaneous error oclwrred
//! \retval ::LWAPI_ILWALID_ARGUMENT  Invalid input parameter
//!
//! \ingroup vidcontrol 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SetPVExtProfile(LwDisplayHandle hLwDisplay, LwU32 dwProfile);

//! SUPPORTED OS:  Windows XP and higher
//!

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GetPVExtProfile
//
//! DESCRIPTION:     This API retrieves the profile number that the PureVideo 
//!                  extension DLL is set to use.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! 
//! \since Release: 190
//!
//! \param [in]     hLwDisplay    LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE
//!                               or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle()
//! \param [out]    pProfile      The returned profile number
//!
//! \retval ::LWAPI_OK                completed request
//! \retval ::LWAPI_ERROR             miscellaneous error oclwrred
//! \retval ::LWAPI_ILWALID_ARGUMENT  Invalid input parameter
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetPVExtProfile(LwDisplayHandle hLwDisplay, LwU32* pProfile);



#ifndef LW_STEREO_VIDEO_FORMAT_DEFINE
#define LW_STEREO_VIDEO_FORMAT_DEFINE


//! \ingroup vidcontrol
typedef enum _LW_STEREO_VIDEO_FORMAT
{
    LW_STEREO_VIDEO_FORMAT_NOT_STEREO         = 0,

    LW_STEREO_VIDEO_FORMAT_SIDE_BY_SIDE_LR    = 1,
    LW_STEREO_VIDEO_FORMAT_SIDE_BY_SIDE_RL    = 2,
    LW_STEREO_VIDEO_FORMAT_TOP_BOTTOM_LR      = 3,
    LW_STEREO_VIDEO_FORMAT_TOP_BOTTOM_RL      = 4,
    LW_STEREO_VIDEO_FORMAT_ROW_INTERLEAVE_LR  = 5,
    LW_STEREO_VIDEO_FORMAT_ROW_INTERLEAVE_RL  = 6,
    LW_STEREO_VIDEO_FORMAT_TWO_FRAMES_LR      = 7,
    LW_STEREO_VIDEO_FORMAT_MONO_PLUS_OFFSET   = 8,

    LW_STEREO_VIDEO_FORMAT_LAST               = 9,
} LW_STEREO_VIDEO_FORMAT;

#endif // LW_STEREO_VIDEO_FORMAT_DEFINE

//! \ingroup vidcontrol
typedef struct _LW_VIDEO_STEREO_INFO {
    LwU32                     dwVersion;         //!< Must be LW_VIDEO_STEREO_INFO_VER
    LW_STEREO_VIDEO_FORMAT    eFormat;           //!< Stereo format of the surface (please note that format LW_STEREO_VIDEO_FORMAT_TWO_FRAMES_LR is invalid for this LwAPI)
    LwS32                     sViewOffset;       //!< Signed offset of each view (positive offset indicating left view is shifted left)
    LwU32                     bStereoEnable : 1; //!< Whether stereo rendering should be enabled (if FALSE, only left view will be used)
} LW_VIDEO_STEREO_INFO;

//! \ingroup vidcontrol
//! Macro for constructing the version field of ::_LW_VIDEO_STEREO_INFO
#define LW_VIDEO_STEREO_INFO_VER  MAKE_LWAPI_VERSION(LW_VIDEO_STEREO_INFO, 1)



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION_NAME:   LwAPI_VideoSetStereoInfo
//
//!   DESCRIPTION:   This API specifies the stereo format of the video source.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      hLwDisplay   LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE
//!                               or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]      pStereoInfo  The stereo format.
//!
//! \retval ::LWAPI_OK                completed request
//! \retval ::LWAPI_ERROR             miscellaneous error oclwrred
//! \retval ::LWAPI_ILWALID_ARGUMENT  Invalid input parameter
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VideoSetStereoInfo(LwDisplayHandle hLwDisplay, LW_VIDEO_STEREO_INFO* pStereoInfo);




//! SUPPORTED OS:  Windows XP and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION_NAME:   LwAPI_VideoGetStereoInfo
//
//!   DESCRIPTION:   This API retrieves the stereo format of the video source (as set by 
//!                  LwAPI_VideoSetStereoInfo()). 
//!
//! \param [in]     hLwDisplay        LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE
//!                                   or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in,out] pStereoInfo       The stereo format returned
//!
//! \retval ::LWAPI_OK                 completed request
//! \retval ::LWAPI_ERROR              miscellaneous error oclwrred
//! \retval ::LWAPI_ILWALID_ARGUMENT   Invalid input parameter
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VideoGetStereoInfo(LwDisplayHandle hLwDisplay, LW_VIDEO_STEREO_INFO* pStereoInfo);




///////////////////////////////////////////////////////////////////////////////
// Structs and enums related to Video Ctrl
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup vidcontrol
//! @{

//! Used in LwAPI_VideoCtrl(). 
typedef enum _LWAPI_VIDEO_CTRL_REQUEST
{
    LWAPI_VCTL_REQ_NONE                     = 0x00000000,
    LWAPI_VCTL_REQ_DI_BOB                   = 0x00000001, //!< Use bob
    LWAPI_VCTL_REQ_DI_MEDIAN                = 0x00000002, //!< Use fweave (do not use on LW4x GPUs)
    LWAPI_VCTL_REQ_DI_WEAVE                 = 0x00000004, //!< Use weave
    LWAPI_VCTL_REQ_DI_ADAPTIVE              = 0x00000008, //!< Use adaptive (do not use on LW1x GPUs; note - this is default for most LW3x GPUs and all LW4x GPUs.)
    LWAPI_VCTL_REQ_DI_EDGE_FULL             = 0x00000010, //!< Use full edge with adaptive (LW4x GPUs only)
    LWAPI_VCTL_REQ_DI_EDGE_SIMPLE           = 0x00000020, //!< Use simple edge with adaptive (LW4x GPUs only)
    LWAPI_VCTL_REQ_GAMMA_DISABLE            = 0x00000040, //!< Disable gamma
    LWAPI_VCTL_REQ_709EXT_ENABLE            = 0x00000080, //!< Enable 709 ext shader
    LWAPI_VCTL_REQ_709EXT_DISABLE           = 0x00000100, //!< Disable 709 ext shader
    LWAPI_VCTL_REQ_601EXT_DISABLE           = 0x00000200, //!< Disable 601 ext
    LWAPI_VCTL_REQ_OVERDRIVE_DISABLE        = 0x00000400, //!< Disable overdrive
    LWAPI_VCTL_REQ_COLORTEMP_DISABLE        = 0x00000800, //!< Disable color temp adjustment
    LWAPI_VCTL_REQ_ILW32_DISABLE            = 0x00001000, //!< Disable ilw32
    LWAPI_VCTL_REQ_VP_DISABLE               = 0x00002000, //!< Disable vp
    LWAPI_VCTL_REQ_DI_GRADIENT_FULL         = 0x00004000, //!< Use full gradient with adaptive (LW4x only)
    LWAPI_VCTL_REQ_DI_GRADIENT_SIMPLE       = 0x00008000, //!< Use simple gradient with adaptive (LW4x only)
    LWAPI_VCTL_REQ_ILW22_DISABLE            = 0x00010000, //!< Disable ilw22
    LWAPI_VCTL_REQ_DI_SIMPLE_ADAPTIVE       = 0x00020000, //!< Use simple adaptive
    LWAPI_VCTL_REQ_NO_PROCESSING            = 0x00040000, //!< No vid quality processing
    LWAPI_VCTL_REQ_DI_ONLY                  = 0x00080000, //!< No vid quality processing other than DI
    LWAPI_VCTL_REQ_NR_ONLY                  = 0x00100000, //!< No vid quality processing other than NR
    LWAPI_VCTL_REQ_EE_ONLY                  = 0x00200000, //!< No vid quality processing other than EE
    LWAPI_VCTL_REQ_CADENCE_ONLY             = 0x00400000, //!< No vid quality processing other than CADENCE
    LWAPI_VCTL_REQ_XFER_XTRA_SAME           = 0x00800000, //!< On video blit to csc, first transfer to the same format
    LWAPI_VCTL_REQ_XFER_XTRA_LW12           = 0x01000000, //!< On video blit to csc, first transfer to LW12
    LWAPI_VCTL_REQ_XFER_XTRA_YUY2           = 0x02000000, //!< On video blit to csc, first transfer to YUV2
    LWAPI_VCTL_REQ_XFER_XTRA_SCALE          = 0x04000000, //!< On video blit to csc, first transfer to scaled to 1.5 OR specified width/height
    LWAPI_VCTL_REQ_DI_ADVANCED              = 0x08000000, //!< Advanced Deinterlace
    LWAPI_VCTL_REQ_DI_DIR_SPATIAL           = 0x10000000, //!< Advanced Dir Spatial enable/disable spatial dir interp
    LWAPI_VCTL_REQ_DI_CADENCE               = 0x20000000, //!< Advanced Cadence enable disable
    LWAPI_VCTL_REQ_DI_VOF                   = 0x40000000, //!< VOF enable/disable
    LWAPI_VCTL_REQ_XFER_XTRA_ARGB           = 0x80000000, //!< On video blit to csc, first transfer to ArgB
} LWAPI_VIDEO_CTRL_REQUEST;



//! Used in LwAPI_VideoCtrl().
typedef enum _LWAPI_VIDEO_CTRL_REQUEST2
{
    LWAPI_VCTL2_REQ_10BITOVERLAY_ENABLE        = 0x00000001, //!< Enable 10 bit overlay
    LWAPI_VCTL2_REQ_VP2_SCALING_ENABLE         = 0x00000002, //!< Enable vp2 scaling
    LWAPI_VCTL2_REQ_VP2_SCALING_DISABLE        = 0x00000004, //!< Disable vp2 scaling
    LWAPI_VCTL2_REQ_CAPTURE_UNIQUE_FRAME       = 0x00000008, //!< Disable vp2 scaling
} LWAPI_VIDEO_CTRL_REQUEST2;



//! Video caps  
typedef enum _LWAPI_VIDEO_CTRL_CAPS_FLAG
{
    LWAPI_VIDEO_CTRL_CAPS_NONE                     = 0x00000000,
    LWAPI_VIDEO_CTRL_CAPS_MEDIAN_DI                = 0x00000001, //!< Supports median
    LWAPI_VIDEO_CTRL_CAPS_SPAD_DI                  = 0x00000002, //!< Supports spad
    LWAPI_VIDEO_CTRL_CAPS_ADV_DI                   = 0x00000004, //!< Supports adv and edge
    LWAPI_VIDEO_CTRL_CAPS_GAMMA                    = 0x00000008, //!< Supports gamma
    LWAPI_VIDEO_CTRL_CAPS_709EXT                   = 0x00000010, //!< Supports 709ext
    LWAPI_VIDEO_CTRL_CAPS_OVERDRIVE                = 0x00000020, //!< Supports overdrive
    LWAPI_VIDEO_CTRL_CAPS_COLORTEMP                = 0x00000040, //!< Supports colortemp
    LWAPI_VIDEO_CTRL_CAPS_ILWAPI32                 = 0x00000080, //!< Supports iLWAPI32
    LWAPI_VIDEO_CTRL_CAPS_VP                       = 0x00000100, //!< Supports VP
    LWAPI_VIDEO_CTRL_CAPS_ILWAPI22                 = 0x00000200, //!< Supports iLWAPI22
    LWAPI_VIDEO_CTRL_CAPS_XFER_XTRA                = 0x00000400, //!< Supports xfer xtra requests
    LWAPI_VIDEO_CTRL_CAPS_LWAPI24                  = 0x00000800, //!< Supports LWAPI24
} LWAPI_VIDEO_CTRL_CAPS_FLAG;





//! IDs related to video control - used in #LWAPI_VIDEO_CTRL
typedef enum _LWAPI_VIDEO_CTRL_ID
{
    LWAPI_VIDEO_CTRL_ID_NONE     = -1,   //!< Placeholder for invalid control ID
    LWAPI_VIDEO_CTRL_ID_REQ1         ,   //!< Veracity requests
    LWAPI_VIDEO_CTRL_ID_REQ2         ,   //!< Veracity requests
    LWAPI_VIDEO_CTRL_ID_CAPTURE      ,   //!< For veracity video capture information
    LWAPI_VIDEO_CTRL_ID_PERF         ,   //!< For veracity performance test
    LWAPI_VIDEO_CTRL_ID_LAST         ,   //!< All valid controls defined before this one
} LWAPI_VIDEO_CTRL_ID;



//! Get/set/reset video control flags - used in #LWAPI_VIDEO_CTRL
typedef enum _LWAPI_VIDEO_CTRL_FLAG
{
    LWAPI_VIDEO_CTRL_FLAG_SET            = 1, //!< 1 : Set Ctrl
    LWAPI_VIDEO_CTRL_FLAG_GET               , //!< 2 : Get Ctrl
    LWAPI_VIDEO_CTRL_FLAG_RESET             , //!< 3 : Reset Ctrl
} LWAPI_VIDEO_CTRL_FLAG;



//! Used in LWAPI_VIDEO_CTRL_V2
typedef enum _LWAPI_VIDEO_CAPTURE_FLAG
{
    LWAPI_VIDEO_CAPTURE_STOP             = 0x00000001,
    LWAPI_VIDEO_CAPTURE_SOURCE_ALSO      = 0x00000002,
    LWAPI_VIDEO_CAPTURE_ALLFRAMES        = 0x00000004,
    LWAPI_VIDEO_CAPTURE_NEWBUFFER        = 0x00000008,
} LWAPI_VIDEO_CAPTURE_FLAG;



//! Used in LWAPI_VIDEO_CTRL_V2
typedef enum _LWAPI_VIDEO_CAPTURE_POINT
{
    LWAPI_VIDEO_CAPTURE_POINT_NONE                     = 0,
    LWAPI_VIDEO_CAPTURE_POINT_OVERLAY_FLIP             = 1,
    LWAPI_VIDEO_CAPTURE_POINT_VIDEO_BLIT               = 2,
    LWAPI_VIDEO_CAPTURE_POINT_DELETED_RENDER_MPEG      = 3, 
    LWAPI_VIDEO_CAPTURE_POINT_DELETED_RENDER_WMV9      = 4,
    LWAPI_VIDEO_CAPTURE_POINT_PROCAMP_OUTPUT           = 5,
    LWAPI_VIDEO_CAPTURE_POINT_DI_OUTPUT                = 6,
    LWAPI_VIDEO_CAPTURE_POINT_DELETED_SUBPIC_OUTPUT    = 7,
    LWAPI_VIDEO_CAPTURE_POINT_CSC_OUTPUT               = 8,
    LWAPI_VIDEO_CAPTURE_POINT_DELETED_ILW32_OUTPUT     = 9,
    LWAPI_VIDEO_CAPTURE_POINT_UNLOCK                   = 10,
    LWAPI_VIDEO_CAPTURE_POINT_DELETED_00               = 11,
    LWAPI_VIDEO_CAPTURE_POINT_MOCOMP_END_FRAME         = 12,
    LWAPI_VIDEO_CAPTURE_POINT_DELETED_MOCOMP_H264      = 13,
    LWAPI_VIDEO_CAPTURE_POINT_MIRROR                   = 14,
    LWAPI_VIDEO_CAPTURE_POINT_BLIT32_DST               = 15,
    LWAPI_VIDEO_CAPTURE_POINT_FE_SP_BLEND              = 16,
    LWAPI_VIDEO_CAPTURE_POINT_BE_SP_BLEND              = 17,
    LWAPI_VIDEO_CAPTURE_POINT_VP_OUTPUT                = 18,
    LWAPI_VIDEO_CAPTURE_POINT_DELETED_MOCOMP_VC1       = 19,
    LWAPI_VIDEO_CAPTURE_POINT_YUV_OUT                  = 20,
    LWAPI_VIDEO_CAPTURE_POINT_NR_OUTPUT                = 21,
    LWAPI_VIDEO_CAPTURE_POINT_ADI_OUTPUT               = 22,
    LWAPI_VIDEO_CAPTURE_POINT_MSDEC_OUTPUT             = 23,
} LWAPI_VIDEO_CAPTURE_POINT;





//! Packet that facilitates retrieving information about a video control - used in LwAPI_VideoCtrl() 
typedef struct _LWAPI_VIDEO_CTRL_V1
{
    LwU32   version;                    //!< (IN) LWAPI version that matches LWAPI_VIDEO_CTRL_VER
    LwU32   ctrlID;                     //!< (IN) Identify the individual ctrl, one of #LWAPI_VIDEO_CTRL_ID enums
    LwU32   ctrlFlag;                   //!< (IN) Set/Get/Reset #LWAPI_VIDEO_CTRL_FLAG enums
    LwU32   retStatus;                  //!< (OUT) Return Status, see #LWAPI_VIDEO_CTRL_RETURN_STATUS
    union                               //!< (IN/OUT) Parameters
    {
        LwU32   parm[8];     
        LwU32   diagCtrlReq1;
        LwU32   diagCtrlReq2;
    } u;
    LwU64   reserved3[10];              //!< (OUT) reserved for future expansion
} LWAPI_VIDEO_CTRL_V1;



//! Used in LwAPI_VideoCtrl()
typedef struct _LWAPI_VIDEO_CTRL_V2
{
    LwU32   version;                    //!< (IN) LWAPI version that matches LWAPI_VIDEO_CTRL_VER
    LwU32   ctrlID;                     //!< (IN) Identify the individual control; one of #LWAPI_VIDEO_CTRL_ID enums
    LwU32   ctrlFlag;                   //!< (IN) Set/Get/Reset #LWAPI_VIDEO_CTRL_FLAG enums
    LwU32   retStatus;                  //!< (OUT) Return Status, see #LWAPI_VIDEO_CTRL_RETURN_STATUS
    LwU32   bResetDiagCtrlInfo : 1;     //!< Reset driverdata variables based on it
    LwU32   bReserved : 31;             //!< Reserved for future expansion
    union                               //!< (IN/OUT) parameters
    {
        LwU32   parm[8];
        struct
        {
            LwU32   diagCtrlReq1;
            LwU32   diagCtrlReq2;
        } diagCtrlRequest;
        struct
        {
            LwU32 captureBufferAdd;         //!< (IN/OUT) Address of the veracity capture buffer
            LwU32 captureFlags;             //!<          See #LWAPI_VIDEO_CAPTURE_FLAG  
            LwU32 captureBufferSize;        //!< (IN/OUT) Size of the buffer
            LwU32 capturePoint;             //!< (IN/OUT) Where frame capture takes place, see #LWAPI_VIDEO_CAPTURE_POINT
            LwU32 captureFrameIndex;        //!< (IN/OUT) Number of the frame to capture
            LwU32 captureFrameRange : 16;   //!< (IN/OUT) The range of frames to capture
            LwU32 reserved2 : 16;           //!< Reserved for future expansion
        } captureInfo;
        struct
        {
            LwU32 startFrameIdx;            //!< (IN)  Frame index for starting the perf test 
            LwU32 endFrameIdx;              //!< (IN)  Frame index for ending the perf test 
            LwU32 bEnablePerf : 1;          //!< (IN)  Perf test is enabled 
            LwU32 reserved2 : 31;           //!< Reserved for future expansion
        } perftestInfo;
    } u;

    struct
    {
        LwU32            dwVideoControlDiagInfoBits;
        LwU32            dwVideoControlDiagInfo2Bits;
        LwU32            dwVideoControlDiagCapsBits;
    } diagVideoControlInfo;             //!< (IN/OUT) Storage for pDriverdata->lwVideoControlDiagInfo
    struct
    {
        LwU32            dwTargetWidth;
        LwU32            dwTargetHeight;
    } diagVideoControlParm;             //!< (IN/OUT) Storage for pDriverdata->lwVideoControlDiagParm
    LwU64   reserved3[7];               //!< (OUT) Reserved for future expansion
} LWAPI_VIDEO_CTRL_V2;




//! For backward compatibility  
typedef LWAPI_VIDEO_CTRL_V2 LWAPI_VIDEO_CTRL;


//! Macro for constructing the version field of LWAPI_VIDEO_CTRL_V1
#define LWAPI_VIDEO_CTRL_VER1  MAKE_LWAPI_VERSION(LWAPI_VIDEO_CTRL_V1,1)

//! Macro for constructing the version field of LWAPI_VIDEO_CTRL_V2
#define LWAPI_VIDEO_CTRL_VER2  MAKE_LWAPI_VERSION(LWAPI_VIDEO_CTRL_V2,2)

//! For backward compatibility  
#define LWAPI_VIDEO_CTRL_VER   LWAPI_VIDEO_CTRL_VER2



//!< Return status after attempting to set a video control 
typedef enum _LWAPI_VIDEO_CTRL_RETURN_STATUS
{
    LWAPI_VIDEO_CTRL_STATUS_SUCCESS                        = 0x00000000, //!< Video control is set successfully.
    LWAPI_VIDEO_CTRL_STATUS_UNSUCCESSFUL                   = 0x00000001, // 
    LWAPI_VIDEO_CTRL_STATUS_CTRL_NOT_SUPPORTED             = 0x00000002, //!< Invalid Ctrl
    LWAPI_VIDEO_CTRL_STATUS_CTRL_FLAG_ILWALID              = 0x00000003, //!< Invalid Flag.
    LWAPI_VIDEO_CTRL_STATUS_CTRL_FIELD_NOT_SUPPORTED       = 0x00000004, //!< Unsupported Field in Ctrl
    LWAPI_VIDEO_CTRL_STATUS_CAPTURE_PENDING                = 0x00000005, //!< Capture not completed 
} LWAPI_VIDEO_CTRL_RETURN_STATUS;

//! @}

 
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_VideoCtrl
//
//! DESCRIPTION:    This function allows callers to tweak a particular video control.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 173
//!
//! \param [in]    hLwDisplay        LWPU Display selection. It can be #LWAPI_DEFAULT_HANDLE or a handle enumerated
//!                                  from LwAPI_EnumLWidiaDisplayHandle().
//! \param [in]    pVideoCtrl        LWAPI_VIDEO_CTRL packet containing a valid ctrl ID (LWAPI_VIDEO_CTRL_ID) and flag 
//!                                  (LWAPI_VIDEO_CTRL_FLAG) for GET/RESET/SET video control information. 
//!
//!  \retval       LWAPI_OK                 Completed request
//!  \retval       LWAPI_ERROR              Miscellaneous error oclwrred
//!  \retval       LWAPI_ILWALID_ARGUMENT   Invalid input parameter
//!
//!  \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VideoCtrl(LwDisplayHandle hLwDisplay, LWAPI_VIDEO_CTRL *pVideoCtrl);





//! \ingroup vidcontrol
//! @{

// enums and structs related to video control points
#define LWAPI_MAX_CONTROL_POINT_DATA_SIZE_IN_BYTES  0x100
#define LWAPI_MAX_CONTROL_POINTS_PER_PACKET  20

typedef enum _LWAPI_VIDEO_CONTROL_RETURN_STATUS
{
    LWAPI_VIDEO_CONTROL_STATUS_SUCCESS = 0,
    LWAPI_VIDEO_CONTROL_STATUS_UNSUCCESSFUL,
    LWAPI_VIDEO_CONTROL_STATUS_COMPONENT_NOT_SUPPORTED,
    LWAPI_VIDEO_CONTROL_STATUS_VALUE_OUT_OF_RANGE,
    LWAPI_VIDEO_CONTROL_STATUS_DATA_TYPE_MISMATCH,
    LWAPI_VIDEO_CONTROL_STATUS_FLAG_ILWALID,
    LWAPI_VIDEO_CONTROL_STATUS_UNREGISTERED,
    LWAPI_VIDEO_CONTROL_STATUS_ILWALID_ARGUMENT,
    LWAPI_VIDEO_CONTROL_STATUS_ILWALID_ID,
    LWAPI_VIDEO_CONTROL_STATUS_ILWALID_DATA_SIZE,
    LWAPI_VIDEO_CONTROL_STATUS_DISABLED,
} LWAPI_VIDEO_CONTROL_RETURN_STATUS;

//! video control points, update the lwVidCtrlPointNames[] array in lwdisp.cpp as well when adding a new ID.
typedef enum _LWAPI_VIDEO_CONTROL_POINT_ID
{
    LWAPI_CPID_FIRST = -1,

    LWAPI_CPID_NoiseReductionStrength,
    LWAPI_CPID_EdgeEnhancementStrength,
    LWAPI_CPID_BrightnessValue,
    LWAPI_CPID_ContrastValue,
    LWAPI_CPID_HueValue,
    LWAPI_CPID_Saturatiolwalue,
    LWAPI_CPID_GammaValueR,
    LWAPI_CPID_GammaValueG,
    LWAPI_CPID_GammaValueB,
    LWAPI_CPID_DeInterlacingAlgo,
    LWAPI_CPID_CadenceDetectionAlgo,
    LWAPI_CPID_SubPictureBlendingMode,
    LWAPI_CPID_ColorSpace,
    LWAPI_CPID_ColorRange,
    LWAPI_CPID_DynamicContrastEnhancement,
    LWAPI_CPID_Scaling,
    LWAPI_CPID_GamutRemap,
    LWAPI_CPID_SkinToneCorrection,
    LWAPI_CPID_DurationTrackingActive,
    
    // append here 

    LWAPI_CPID_LAST, // must be last
} LWAPI_VIDEO_CONTROL_POINT_ID;

//! update the lwVidCtrlPointDataTypes[] array in lwdisp.cpp as well when adding a new Datatype.
typedef enum _LWAPI_VIDEO_CONTROL_POINT_DATATYPE
{
    LWAPI_CPDT_UNKNOWN = 0,
    LWAPI_CPDT_Integer,
    LWAPI_CPDT_Float,
    LWAPI_CPDT_String,
    LWAPI_CPDT_Binary,
    LWAPI_CPDT_LAST,
} LWAPI_VIDEO_CONTROL_POINT_DATATYPE;

//! update the lwVidCtrlPointGranularity[] array in lwdisp.cpp as well when adding a new Granularity type.
typedef enum _LWAPI_CONTROL_POINT_GRANULARITY
{
    LWAPI_CPG_UNKNOWN = 0,
    LWAPI_CPG_InitTime,
    LWAPI_CPG_PerFrame,
} LWAPI_CONTROL_POINT_GRANULARITY;

typedef enum _LWAPI_VIDEO_CONTROL_GET_FLAG
{
    LWAPI_CP_FLAG_GET_UNKNOWN = 0,
    LWAPI_CP_FLAG_GET_COUNT,
    LWAPI_CP_FLAG_GET_DETAILS,
} LWAPI_VIDEO_CONTROL_GET_FLAG;

typedef enum _LWAPI_VIDEO_CONTROL_COMPONENT_ALGORITHM
{
    // Color space formats
    LW_VCTRL_ColorSpaceBase            = 0x1000,
    LW_VCTRL_ColorSpace601             = (LW_VCTRL_ColorSpaceBase) + 0x01,  //!< ITU-R BT.601
    LW_VCTRL_ColorSpace709             = (LW_VCTRL_ColorSpaceBase) + 0x02,  //!< ITU-R BT.709
    LW_VCTRL_ColorSpaceLast            = (LW_VCTRL_ColorSpaceBase) + 0x03,

    // Color range formats
    LW_VCTRL_ColorRangeBase            = 0x1100,
    LW_VCTRL_ColorRangeStd             = (LW_VCTRL_ColorRangeBase) + 0x01,  //!< color range of (0-255)
    LW_VCTRL_ColorRangeExt             = (LW_VCTRL_ColorRangeBase) + 0x02,  //!< color range of (16-235)
    LW_VCTRL_ColorRangeLast            = (LW_VCTRL_ColorRangeBase) + 0x03,

    // Deinterlacing Algos 
    LW_VCTRL_DIBase                    = 0x2000,
    LW_VCTRL_DIBob                     = (LW_VCTRL_DIBase) + 0x01,  //!< Perform Bob deinterlacing
    LW_VCTRL_DIMedian                  = (LW_VCTRL_DIBase) + 0x02,  //!< Use median filter 
    LW_VCTRL_DI3x3                     = (LW_VCTRL_DIBase) + 0x03,  //!< Perform a 3x3 adaptive deinterlacing
    LW_VCTRL_DIAdaptiveFourField       = (LW_VCTRL_DIBase) + 0x04,  //!< Perform four field motion adaptive deinterlacing
    LW_VCTRL_DIDirectionalSpatial      = (LW_VCTRL_DIBase) + 0x05,  //!< Use directional spatial deinterlacing for SD
    LW_VCTRL_DIOnePass                 = (LW_VCTRL_DIBase) + 0x06,  //!< Use One Pass deinterlacing
    LW_VCTRL_DISony                    = (LW_VCTRL_DIBase) + 0x07,  //!< Use Sony deinterlacing Algo
    LW_VCTRL_DILast                    = (LW_VCTRL_DIBase) + 0x08,

    // Cadence detection Algos 
    LW_VCTRL_CadenceBase               = 0x3000,
    LW_VCTRL_CadenceBasic              = (LW_VCTRL_CadenceBase) + 0x01,  //!< Basic cadence detection Algo
    LW_VCTRL_CadenceVideoOnFilm        = (LW_VCTRL_CadenceBase) + 0x02,  //!< Use video on film cadence detection
    LW_VCTRL_CadenceAdv                = (LW_VCTRL_CadenceBase) + 0x03,  //!< Advanced cadence detection Algo
    LW_VCTRL_CadenceLast               = (LW_VCTRL_CadenceBase) + 0x04,
    
    // Dynamic Contrast Color Enhancement Algos
    LW_VCTRL_DCCEBase                  = 0x4000,
    LW_VCTRL_DCCELow                   = (LW_VCTRL_DCCEBase) + 0x01,    //!< DCCE Low
    LW_VCTRL_DCCEMedium                = (LW_VCTRL_DCCEBase) + 0x02,    //!< DCCE Medium
    LW_VCTRL_DCCEHigh                  = (LW_VCTRL_DCCEBase) + 0x03,    //!< DCCE High
    LW_VCTRL_DCCELast                  = (LW_VCTRL_DCCEBase) + 0x04,
    
    // Scaling Algos
    LW_VCTRL_ScalingBase               = 0x5000,
    LW_VCTRL_ScalingSimple             = (LW_VCTRL_ScalingBase) + 0x01,  //!< Simple Shader Scaling
    LW_VCTRL_Scaling4x4Filter          = (LW_VCTRL_ScalingBase) + 0x02,  //!< Scaling by 4x4 filter
    LW_VCTRL_ScalingSony               = (LW_VCTRL_ScalingBase) + 0x03,  //!< Sony Scaling Algo          
    LW_VCTRL_ScalingLast               = (LW_VCTRL_ScalingBase) + 0x04,

    // Gamut Remap Algos
    LW_VCTRL_GamutRemapBase            = 0x6000,
    LW_VCTRL_GamutRemapSony            = (LW_VCTRL_GamutRemapBase) + 0x01, //!< Sony Gamut Remap Algo
    LW_VCTRL_GamutRemapLast            = (LW_VCTRL_GamutRemapBase) + 0x02,  

    // Skin-Tone Correction levels
    LW_VCTRL_SkinToneCorrectionBase    = 0x7000,
    LW_VCTRL_SkinToneCorrectionSqueeze = (LW_VCTRL_SkinToneCorrectionBase) + 0x01, //!< Turn the skin tone correction to a low setting
    LW_VCTRL_SkinToneCorrectionRed     = (LW_VCTRL_SkinToneCorrectionBase) + 0x02, //!< Turn the skin tone correction to a medium setting
    LW_VCTRL_SkinToneCorrectionYellow  = (LW_VCTRL_SkinToneCorrectionBase) + 0x03, //!< Turn the skin tone correction to a high setting 
    LW_VCTRL_SkinToneCorrectionLast    = (LW_VCTRL_SkinToneCorrectionBase) + 0x04,
     
} LWAPI_VIDEO_CONTROL_COMPONENT_ALGORITHM;

typedef struct _LWAPI_VIDEO_CONTROL_POINT_DESC
{
    LWAPI_VIDEO_CONTROL_POINT_ID        eID;
    LWAPI_VIDEO_CONTROL_POINT_DATATYPE  eType;
    LWAPI_CONTROL_POINT_GRANULARITY     eGranularity;
    LwU32                               dwDataSize;
    LwU32                               adwReserved[4];
} LWAPI_VIDEO_CONTROL_POINT_DESC;

typedef struct _LWAPI_VID_CTRL_POINT_DESC_STRINGS
{
    LWAPI_VIDEO_CONTROL_POINT_ID    eID;
    LwAPI_ShortString               szControlPoint; //!< ControlPoint name
    LwAPI_ShortString               szDataType;     //!< control point data type
    LwAPI_ShortString               szGranularity;  //!< control point Granularity
    LwAPI_ShortString               szReserved1;    //!< reserved for future expansion
} LWAPI_VID_CTRL_POINT_DESC_STRINGS;

typedef struct _LWAPI_VIDEO_CONTROL_POINT_DESC_PACKET
{
    LwU32                           version; //!< (IN) LWAPI version that matches LWAPI_VIDEO_CONTROL_POINT_DESC_PACKET_VER
    LwU32                           dwReturnStatus; //!< (OUT) one of the LWAPI_VIDEO_CONTROL_RETURN_STATUS
    LWAPI_VIDEO_CONTROL_GET_FLAG    eGetID; //!< (IN) get total CP count or CP details
    LWAPI_VIDEO_CONTROL_POINT_DESC  astCtrlPointDesc[LWAPI_MAX_CONTROL_POINTS_PER_PACKET]; //!< (OUT) details of supported control points
    LwU32                           dwCPCount; //!< (OUT) total count of enumerated control points
    LwU32                           dwStartCPCount; //!< (IN) starting CP count when reading the data
    LwU64                           aqwReserved[3]; //!< (IN/OUT) reserved for future expansion
} LWAPI_VIDEO_CONTROL_POINT_DESC_PACKET;

//! Macro for contructing the version field of ::_LWAPI_VIDEO_CONTROL_POINT_DESC_PACKET
#define LWAPI_VIDEO_CONTROL_POINT_DESC_PACKET_VER MAKE_LWAPI_VERSION(LWAPI_VIDEO_CONTROL_POINT_DESC_PACKET,1)

typedef enum _LWAPI_VID_CTRL_COMMAND
{
    LWAPI_VideoCtrlPoint_Set = 1,
    LWAPI_VideoCtrlPoint_Reset = 2,
    LWAPI_VideoCtrlPoint_ResetAll = 3,
} LWAPI_VID_CTRL_COMMAND;


typedef struct _LWAPI_VIDEO_CONTROL_POINT_DATA_PACKET
{
    LwU32                               version; //!< (IN) LWAPI version that matches LWAPI_VIDEO_CONTROL_POINT_DATA_PACKET_VER
    LwU32                               dwReturnStatus; //!< (OUT) one of the LWAPI_VIDEO_CONTROL_RETURN_STATUS
    LWAPI_VID_CTRL_COMMAND              eCommand;       //!< (IN) one of LWAPI_VideoCtrlPoint_XXX enums
    LWAPI_VIDEO_CONTROL_POINT_ID        eID;            //!< (IN) control point ID
    LWAPI_VIDEO_CONTROL_POINT_DATATYPE  eType;          //!< (IN) data type
    union                                               //!< anonymous union 
    {
        void*                           pData;          //!< (IN) pointer to control point data 
        LwU64                           qwDataPad;      //!< pad up to 64 bit on 32 bit systems
    };
    LwU32                               dwDataSize;     //!< (IN) control point data size 
    LwU32                               adwReserved[4]; //!< (IN/OUT) reserved for future expansion 
} LWAPI_VIDEO_CONTROL_POINT_DATA_PACKET;

//! Macro for contructing the version field of ::LWAPI_VIDEO_CONTROL_POINT_DATA_PACKET
#define LWAPI_VIDEO_CONTROL_POINT_DATA_PACKET_VER   MAKE_LWAPI_VERSION(LWAPI_VIDEO_CONTROL_POINT_DATA_PACKET,1)

typedef struct _LWAPI_VIDEO_CONTROL_POINT_DATA
{
    LWAPI_VID_CTRL_COMMAND              eCommand;
    LWAPI_VIDEO_CONTROL_POINT_ID        eID;
    LwU32                               dwReturnStatus;
    LWAPI_VIDEO_CONTROL_POINT_DATATYPE  eType;
    LwU32                               dwStartOffset;
    LwU8                                abyData[LWAPI_MAX_CONTROL_POINT_DATA_SIZE_IN_BYTES]; //!< control point data
    LwU32                               dwPacketDataSize; //!< size of current packet
    LwU32                               dwDataSize; //!< total size of control point data 
} LWAPI_VIDEO_CONTROL_POINT_DATA;

typedef struct _LWAPI_VIDEO_CONTROL_POINT_REGISTER
{
    LwU64   qwCPSupportedBitFlags; //!< to be passed to KMD/XP in order to set supported bit of control points
} LWAPI_VIDEO_CONTROL_POINT_REGISTER;

typedef enum _LWAPI_VIDEO_CONTROL_ID
{
    LWAPI_VID_CTRL_ENUM = 1,
    LWAPI_VID_CTRL_GET,
    LWAPI_VID_CTRL_SET,
    LWAPI_VID_CTRL_REGISTER,
    LWAPI_VID_CTRL_LAST, //!< must be last 
} LWAPI_VIDEO_CONTROL_ID;

//!! struct to be passed to KMD 
typedef struct _LWAPI_VIDEO_CONTROL
{
    LwU32       dwCtrlID; //!< (IN) identify the individual ctrl, one of LWAPI_VID_CTRL_XXX enums
    union
    {
        LWAPI_VIDEO_CONTROL_POINT_DESC_PACKET  stVidCtrlPointDesc; //!< (IN/OUT)
        LWAPI_VIDEO_CONTROL_POINT_DATA         stVidCtrlPointData; //!< (IN/OUT)
        LWAPI_VIDEO_CONTROL_POINT_REGISTER     stVidCtrlPointReg; //!< (IN/OUT)
    };
} LWAPI_VIDEO_CONTROL;

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_EnumerateVideoControlPoints
//
//! \code
//! DESCRIPTION:     API that enumerates all supported video control points to the caller 
//!                  caller will first call it with GET_COUNT flag. Then this API will be called repeatedly with 
//!                  GET_DETAILS flag until all the control points get enumerated.
//!
//! PARAMETERS:      hLwDisplay(IN)           - LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle 
//!                                             enumerated from LwAPI_EnumLWidiaDisplayHandle().
//!                  pControlPointDesc(IN/OUT)- LWAPI_VIDEO_CONTROL_POINT_DESC_PACKET containing details of all 
//!                                             supported control points (LWAPI_VIDEO_CONTROL_POINT_DESC) and total count 
//!                  pCPDescNamesArray(OUT)   - Array of LWAPI_VID_CTRL_POINT_DESC_STRINGS structs of size LWAPI_MAX_CONTROL_POINTS_PER_PACKET.
//!                                              Strings will be filled if not NULL.
//! SUPPORTED OS:  Windows XP and higher
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_EnumerateVideoControlPoints(LwDisplayHandle hLwDisplay, 
                                                  LWAPI_VIDEO_CONTROL_POINT_DESC_PACKET* pControlPointDesc, 
                                                  LWAPI_VID_CTRL_POINT_DESC_STRINGS* pCPDescNamesArray);
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_VideoControl
//
//! \code
//! DESCRIPTION:     API that allows the caller to set one video control point value and 
//!                  reset one/all control point value(s)
//!
//! PARAMETERS:      hLwDisplay(IN)        - LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle 
//!                                          enumerated from LwAPI_EnumLWidiaDisplayHandle().
//!                  pControlPointData(IN) - LWAPI_VIDEO_CONTROL_POINT_DATA_PACKET containing a flag(eCommand) for 
//!                                          set one/ reset one/ reset all.
//!                                          For setting one CP other inputs are:
//!                                              a valid control point ID (LWAPI_VIDEO_CONTROL_POINT_ID),
//!                                              eType (LWAPI_VIDEO_CONTROL_POINT_DATATYPE), 
//!                                              data size and 
//!                                              data pointer 
//!                                          For resetting one CP other inputs are:
//!                                              a valid control point ID (LWAPI_VIDEO_CONTROL_POINT_ID).
//!                                          For resetting all CPs only the eCommand flag is required.
//! SUPPORTED OS:  Windows XP and higher
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_VideoControl(LwDisplayHandle hLwDisplay, LWAPI_VIDEO_CONTROL_POINT_DATA_PACKET* pControlPointData);

//! @}







//! \ingroup vidcontrol
//! @{

// enums and structs related to video data providers 

#define LWAPI_MAX_DATA_PROVIDER_DETAILS    10
#define LWAPI_MAX_CAPTURE_IMAGES           8
#define LWAPI_MAX_CAPTURE_EXTRA_INFO       8
#define LWAPI_MAX_PULL_MODEL_DP_DATA_SIZE_IN_BYTES  476


#define LWAPI_MAX_APPLIED_ALGO_PER_STREAM_RUN  30      //!< This is thrice that of MAX_ALGO_PER_STREAM_RUN defined in driver as of now.
                                                       //!< We have kept extra space to accomodate any future changes.

#define LWAPI_VIDEO_MAX_STREAMS                     12 //!< This is twice that of MAX_STREAMS defined 
                                                       //!< in driver as of now.We have kept extra space to accomodate 
                                                       //!< any future changes.

#define LWAPI_VIDEO_NAME_MAX_LENGTH                260 //!< same as MAX_PATH defined in windows
#define LWAPI_MAX_FUNCTION_CALLS_TO_TRACK          100  //!< Taking duration of 100 call per function


typedef enum _LWAPI_VIDEO_DATA_PROVIDER_STATUS
{
    LWAPI_DP_STATUS_SUCCESS = 0,
    LWAPI_DP_STATUS_UNSUCCESSFUL,
    LWAPI_DP_STATUS_ILWALID_ID,
    LWAPI_DP_STATUS_VALUE_OUT_OF_RANGE,
    LWAPI_DP_STATUS_ILWALID_DATA_SIZE,
    LWAPI_DP_STATUS_FLAG_ILWALID,
    LWAPI_DP_STATUS_NOT_INTIALIZED,
    LWAPI_DP_STATUS_ILWALID_ARGUMENT,
    LWAPI_DP_STATUS_DISABLED,
    LWAPI_DP_STATUS_MAX_CLIENT_REACHED,
    LWAPI_DP_STATUS_CLIENT_NOT_PRESENT,
    LWAPI_DP_STATUS_MAX_DP_PER_CLIENT_REACHED,
} LWAPI_VIDEO_DATA_PROVIDER_STATUS;

//! update the lwVidDataProviderNames[] array in lwdisp.cpp as well when adding a new Data Provider ID.
typedef enum _LWAPI_VIDEO_DATA_PROVIDER_ID
{
    LWAPI_DPID_ILWALID = -1,
    LWAPI_DPID_DECODEDFRAMECOUNT,
    LWAPI_DPID_VPPSURFACECOUNT,
    LWAPI_DPID_VP2CYCLES,
    LWAPI_DPID_IMAGEBUFFER,
    LWAPI_DPID_FIXEDBUGS,
    LWAPI_DPID_ILWTCWEAVEMODE,

    LWAPI_DPID_IMAGEBUFFER_OVERLAY_INTERNAL,
    LWAPI_DPID_IMAGEBUFFER_OVERLAY_EXTERNAL,
    LWAPI_DPID_IMAGEBUFFER_SHADER_DCCE,
    LWAPI_DPID_IMAGEBUFFER_SHADER_GAMUT_REMAP,
    LWAPI_DPID_IMAGEBUFFER_SHADER_GAMMA,
    LWAPI_DPID_IMAGEBUFFER_SHADER_PROCAMP,
    LWAPI_DPID_IMAGEBUFFER_SHADER_CSC,
    LWAPI_DPID_IMAGEBUFFER_SHADER_EE,
    LWAPI_DPID_IMAGEBUFFER_SHADER_FE,
    LWAPI_DPID_IMAGEBUFFER_SHADER_FMTXFER,
    LWAPI_DPID_IMAGEBUFFER_SHADER_NR,
    LWAPI_DPID_IMAGEBUFFER_SHADER_BLEND,
    LWAPI_DPID_IMAGEBUFFER_SHADER_SCALE,
    LWAPI_DPID_IMAGEBUFFER_4x4_SCALE,
    LWAPI_DPID_IMAGEBUFFER_COMPOSITOR_D3D,
    LWAPI_DPID_IMAGEBUFFER_DECODE,
    LWAPI_DPID_IMAGEBUFFER_SHADER_DI,
    LWAPI_DPID_IMAGEBUFFER_SHADER_ROTATE,
    LWAPI_DPID_DXVA_APPLIED_ALGORITHMS,
    LWAPI_DPID_BLITTER_APPLIED_ALGORITHMS,
    LWAPI_DPID_CALL_DURATION,
    LWAPI_DPID_IMAGEBUFFER_COMPOSITOR_VIC,
    LWAPI_DPID_IMAGEBUFFER_DMA_TRANSFER,
    LWAPI_DPID_IMAGEBUFFER_PRESENT_STEREO_LEFT,
    LWAPI_DPID_IMAGEBUFFER_PRESENT_STEREO_RIGHT,
    LWAPI_DPID_IMAGEBUFFER_UPDATE_OVERLAY_LEFT,
    LWAPI_DPID_IMAGEBUFFER_UPDATE_OVERLAY_RIGHT,
    LWAPI_DPID_IMAGEBUFFER_FLIP_OVERLAY_LEFT,
    LWAPI_DPID_IMAGEBUFFER_FLIP_OVERLAY_RIGHT,
    // append here 
    LWAPI_DPID_LAST, // must be the last
} LWAPI_VIDEO_DATA_PROVIDER_ID;

typedef enum _LWAPI_VIDEO_DATA_PROVIDER_CAPTURE_STATUS
{
    LWAPI_DP_STATUS_CAPTURE_OFF = 0,
    LWAPI_DP_STATUS_CAPTURE_GENERIC_ERROR,
    LWAPI_DP_STATUS_CAPTURE_PENDING,
    LWAPI_DP_STATUS_CAPTURE_PENDING_SRC,
    LWAPI_DP_STATUS_CAPTURE_COMPLETE,
    LWAPI_DP_STATUS_CAPTURE_BUFFER_TOO_SMALL,
} LWAPI_VIDEO_DATA_PROVIDER_CAPTURE_STATUS;

typedef struct _LWAPI_VIDEO_DATA_PROVIDER_DESC
{
    LWAPI_VIDEO_DATA_PROVIDER_ID    eID;
    LwU32                           dwPeriod;
    LwU32                           dwBufferSize;
    LwU32                           dwBufferCount;
    LwU32                           bIsPullModelDataProvider:  1; //!< 0: Push model , 1: Pull model 
    LwU32                           bReserved1              : 31;
    LwU64                           aqwReserved2[3];
} LWAPI_VIDEO_DATA_PROVIDER_DESC;

//! names to be returned to APP. used inside LWAPI
typedef struct _LWAPI_VID_DATA_PROVIDER_DESC_STRINGS
{
    LWAPI_VIDEO_DATA_PROVIDER_ID    eID;
    LwAPI_ShortString               szDataProviderName; //!< name of the Data Provider
    LwAPI_ShortString               szReserved1; //!< reserved for future expansion
    LwAPI_ShortString               szReserved2; //!< reserved for future expansion
} LWAPI_VID_DATA_PROVIDER_DESC_STRINGS;

typedef enum _LWAPI_VID_DATA_PROVIDER_GET_FLAG
{
    LWAPI_DP_GET_COUNT = 0,
    LWAPI_DP_GET_DETAILS,
    LWAPI_DP_GET_REGISTERED_COUNT,
} LWAPI_VID_DATA_PROVIDER_GET_FLAG;

typedef struct _LWAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR
{
    LwU32                            version; //!< (IN) version that matches LWAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR_VER
    LwU32                            dwStatus; //!< (OUT) one of the LWAPI_VIDEO_DATA_PROVIDER_RETURN_STATUS 
    LWAPI_VID_DATA_PROVIDER_GET_FLAG eGetID; //!< (IN) get total DP count or DP details
    LwU32                            dwStartDPCount; //!< (IN) starting DP count when reading the data
    LwU32                            dwDPCount; //!< (OUT) DP count returned
    LWAPI_VIDEO_DATA_PROVIDER_DESC   astDataProviderDetails[LWAPI_MAX_DATA_PROVIDER_DETAILS]; //!< (OUT) DP description
    LwU32                            adwReserved[5]; //!< (IN/OUT) reserved for future expansion
} LWAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR;

//! Macro for constructing the version field of ::_LWAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR
#define LWAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR_VER MAKE_LWAPI_VERSION(LWAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_EnumVideoDataProviders
//
//! \code
//! DESCRIPTION:     API that enumerates all available data providers to the caller.
//!                  Users are suggested to prefer Push model data providers to Pull model ones, as pull model Data 
//!                  Providers are more inlwrsive.
//!
//! PARAMETERS:      hLwDisplay(IN)        - LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle 
//!                                         enumerated from LwAPI_EnumLWidiaDisplayHandle().
//!                  pVideoDataProviderDesc(IN) - LWAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR containing a valid get ID
//!                                          (LWAPI_VID_DATA_PROVIDER_GET_FLAG), 
//!                                          First client calls with LWAPI_DP_GET_COUNT flag.
//!                                          Then it calls repeatedly with LWAPI_DP_GET_DETAILS flag to get the 
//!                                          data provider description.
//!                                          Additionally, using the flag LWAPI_DP_GET_REGISTERED_COUNT returns
//!                                          the number of registered DPIDs across all clients in dwDPCount.
//!                  pDataProvDescNamesArray(OUT) - LWAPI_VID_DATA_PROVIDER_DESC_STRINGS array of size LWAPI_MAX_DATA_PROVIDER_DETAILS.
//!                                          The array is filled up if not NULL.
//! SUPPORTED OS:  Windows XP and higher
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_EnumVideoDataProviders(LwDisplayHandle hLwDisplay, 
                                             LWAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR* pVideoDataProviderDesc, 
                                             LWAPI_VID_DATA_PROVIDER_DESC_STRINGS* pDataProvDescNamesArray);




//! struct used for registering / unregistering data providers.
typedef struct _LWAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO
{
    LwU32                       version;            //!< (IN) version that matches LWAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO_VER
    LwU32                       dwStatus;           //!< (OUT) one of the LW_VIDEO_DATA_PROVIDER_STATUS 
    LWAPI_VIDEO_DATA_PROVIDER_ID   eID;             //!< (IN) ID of the data provider 
    LwU32                       dwClientID;         //!< (IN) process ID of the client
    LwU32                       dwBufferCount;      //!, (IN) number of buffers in the buffer array
    LwU32                       dwBufferSize;       //!< (IN) size of the buffer 
    LwU64                       qwBufferArrayAdd;   //!< (IN) address of the client allocated buffer array 
    LwU32                       dwCapturePoint;     //!< (IN) capture point mask for current DP 
    LwU32                       dwNotifyPeriod;     //!< (IN) number of frames between two conselwtive notifications
    LwU64                       qwEventHandle;      //!< (IN) event handle used for synchronization 
    LwU32                       dwFrameStart;       //!< (IN) frame number to start capture (first frame is 1!)
    LwU32                       dwFrameEnd;         //!< (IN) frame number to end capture
    LwU32                       bEmulationMode : 1; //!< (IN) flag to indicate if emulation mode dump is enabled.
    LwU32                       bReserved      :31; //!< (IN) reserved for future boolean flags.
    LwU32                       dwReserved;         //!< (IN/OUT) reserved for future expansion 
    LwU64                       aqwReserved[3];     //!< (IN/OUT) reserved for future expansion 
} LWAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO;

//! Macro for constructing the version field of ::_LWAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO
#define LWAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO_VER MAKE_LWAPI_VERSION(LWAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_RegisterVideoDataProvider
//
//! \code
//! DESCRIPTION:     API that allow caller to register a video data provider 
//!
//! PARAMETERS:      hLwDisplay(IN)        - LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle 
//!                                          enumerated from LwAPI_EnumLWidiaDisplayHandle().
//!                  pDataProviderReg(IN)  - LWAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO containing 
//!                                          a valid data provider ID (eID), 
//!                                          a client ID(dwClientID), 
//!                                          address of the Buffer Array(qwBufferArrayAdd), 
//!                                          buffer count in array(dwBufferCount), 
//!                                          buffer size(dwBufferSize), 
//!                                          capture points (dwCapturePoint), 
//!                                          an event handle used for synchronization(qwEventHandle).
//! SUPPORTED OS:  Windows XP and higher
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_RegisterVideoDataProvider(LwDisplayHandle hLwDisplay, 
                                                LWAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO* pDataProviderReg);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_UnregisterVideoDataProvider
//
//! \code
//! DESCRIPTION:     API that allow caller to register a video data provider 
//!
//! PARAMETERS:      hLwDisplay(IN)        - LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle 
//!                                          enumerated from LwAPI_EnumLWidiaDisplayHandle().
//!                  pDataProviderReg(IN)  - LWAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO containing 
//!                                          a valid data provider ID (eID), 
//!                                          a client ID(dwClientID).
//! SUPPORTED OS:  Windows XP and higher
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_UnregisterVideoDataProvider(LwDisplayHandle hLwDisplay, 
                                                LWAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO* pDataProviderReg);

//! Internal struct used to get values of pull model data providers
typedef struct _LWAPI_PULL_MODEL_DATA_PACKET
{
    LwU32                           dwStatus;
    LWAPI_VIDEO_DATA_PROVIDER_ID    eID;
    LwU32                           dwBufferCount;
    LwU32                           dwBufferSize;
    LwU32                           dwStartOffset;
    LwU8                            abyData[LWAPI_MAX_PULL_MODEL_DP_DATA_SIZE_IN_BYTES];
    LwU32                           dwClientID;
} LWAPI_PULL_MODEL_DATA_PACKET;

typedef struct _LWAPI_VIDEO_DATA_GET
{
    LwU32                           version;        //!< (IN) version that matches LWAPI_VIDEO_DATA_GET_VER
    LwU32                           dwStatus;       //!< (OUT) one of the LW_VIDEO_DATA_PROVIDER_STATUS 
    LWAPI_VIDEO_DATA_PROVIDER_ID    eID;            //!< (IN) Video Data Provider ID 
    LwU32                           dwClientID;     //!< (IN) process ID of the client 
    LwU32                           dwBufferSize;   //!< (IN) size (in bytes) of each data element in the array
    LwU32                           dwBufferCount;  //!< (IN) number of elements in the array 
    union                                           //!< anonymous union 
    {
        void*                       pBuffArray;     //!< (IN) base address of buffer array 
        LwU64                       pPad;           //!< ensure proper sizing on 64bit OS 
    };
    LwU32                           dwReserved[3];  //!< (IN/OUT) reserved for future expansion 
} LWAPI_VIDEO_DATA_GET;

//! Macro for constructing the version field of ::_LWAPI_VIDEO_DATA_GET
#define LWAPI_VIDEO_DATA_GET_VER MAKE_LWAPI_VERSION(LWAPI_VIDEO_DATA_GET,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GetVideoData
//
//! \code
//! DESCRIPTION:     API that allow caller to retrieve video data for a pull model data provider. Total size of 
//!                  the data array is limited to LWAPI_MAX_PULL_MODEL_DP_DATA_SIZE_IN_BYTES.
//!                  The caller should use this method as infrequently as possible, preferably after completion of 
//!                  one playback session.
//!
//! PARAMETERS:      hLwDisplay(IN)   - LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle 
//!                                     enumerated from LwAPI_EnumLWidiaDisplayHandle().
//!                  pVidDataGet(IN)  - LWAPI_VIDEO_DATA_GET containing 
//!                                      a valid data provider ID (eID), 
//!                                      a client ID(dwClientID),
//!                                      data size,
//!                                      data Pointer,
//!                                      buffer count.
//! SUPPORTED OS:  Windows XP and higher
//!
//! RETURN STATUS: 
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetVideoData(LwDisplayHandle hLwDisplay, LWAPI_VIDEO_DATA_GET* pVidDataGet);




//! structures used for user allocated capture buffer, to be used for DPID_ImageBuffer.
typedef struct _LWAPI_IMAGE_BUFFER
{
    LwU32   dwDataSize;         //<! size of segment in bytes
    LwU32   dwPixelType;        //!< FOURCC code, or 1,2,3,4 for n-byte RGB data
    LwU32   dwHeight;           //!< height in pels
    LwU32   dwWidth;            //!< width in pels
    LwU32   bytesPerPixel:  3;  //!< number of bytes per pixel : width*bytesPerPixel = image data on each line
    LwU32   bReserved1   : 29;  //!< reserved for future expansion
    LwU32   dwPitch;            //!< pitch in bytes
    LwU32   dwInfo1;            //!< general info relevant to this pixeltype
    LwU32   dwInfo2;            //!< more general info
    union                       //!< anonymous union
    {
        LwU8*   pImgData;       //!< Pointer to data for this buffer
        LwU64   qwPad;          //!< pad up to 64 bit on 32 bit systems 
    };
    LwU64   aqwReserved2[2];    //!< reserved for future expansion
} LWAPI_IMAGE_BUFFER;


//! description of algo enum, name and flags. 
typedef struct _LWAPI_ALGO_DETAILS
{
    LwU32           dwAlgoID;             //!< DWORD corresponding to enums NRLuma/NRChroma/DI3x3/DIdirspat etc.
    char            cAlgoName[LWAPI_VIDEO_NAME_MAX_LENGTH];
    LwU64           qwflags[LWAPI_VIDEO_MAX_STREAMS];
} LWAPI_ALGO_DETAILS;

typedef struct _LWAPI_VIDEO_APPLIED_ALGOS_PER_STREAM
{
    LwU32                 dwAppliedAlgoCount;
    LWAPI_ALGO_DETAILS    astAppliedAlgoList[LWAPI_MAX_APPLIED_ALGO_PER_STREAM_RUN];
} LWAPI_VIDEO_APPLIED_ALGOS_PER_STREAM;

typedef struct _LWAPI_VIDEO_APPLIED_ALGOS_PER_VID_PROC_INSTANCE
{
    LwU32                                  dwVidProcInstanceIndex;
    char                                   cVidProcInstanceName[LWAPI_VIDEO_NAME_MAX_LENGTH];
    LwU32                                  dwNumStreams;
    LWAPI_VIDEO_APPLIED_ALGOS_PER_STREAM   astAppliedAlgosPerStream[LWAPI_VIDEO_MAX_STREAMS];
} LWAPI_VIDEO_APPLIED_ALGOS_PER_VID_PROC_INSTANCE;

typedef struct _LWAPI_VIDEO_APPLIED_ALGOS_BUFFER
{
    LwU32                                               dwCaptureStatus;
    LWAPI_VIDEO_APPLIED_ALGOS_PER_VID_PROC_INSTANCE     stAppliedAlgosPerVidProcInstance;
} LWAPI_VIDEO_APPLIED_ALGOS_BUFFER;


typedef enum _LWAPI_FUNCTION_NAME
{
    LWAPI_DecodeExelwte = 0,
    LWAPI_DecodeBeginFrame,
    LWAPI_DecodeEndFrame,
    LWAPI_VideoProcessBlt,
    LWAPI_ExtensionExelwte,
    LWAPI_FlipOverlay,            //!< LWMOverlay::FlipOverlay
    LWAPI_FlipOverlayLwApi,       //!< LWMOverlay::FlipOverlayLwApi
    LWAPI_OverlayTransfer,        //!< LWMOverlay::OverlayTransfer
    LWAPI_lwRenderDeinterlace,    //!< ->XP
    LWAPI_PresentVideoShow,       //!< CVideoOverlay::PresentVideoShow -> XP
    LWAPI_LAST_FUNCTION,          //!< Total number of functions
}LWAPI_FUNCTION_NAME;

typedef struct _LWAPI_VIDEO_FUNCTION_CALL_INFO
{
    LWAPI_FUNCTION_NAME          eFunctionName;
    LwU32                        iCallNumber;
    LwU32                        bIsFunctionActive;
    LwU64                        iCallDuration[LWAPI_MAX_FUNCTION_CALLS_TO_TRACK];
} LWAPI_VIDEO_FUNCTION_CALL_INFO;


typedef struct _LWAPI_VIDEO_CALL_DURATION_BUFFER
{
    LwU32                                           dwCaptureStatus;
    LWAPI_VIDEO_FUNCTION_CALL_INFO                  stCallDurationInfo[LWAPI_LAST_FUNCTION];
} LWAPI_VIDEO_CALL_DURATION_BUFFER;



typedef struct _LWAPI_VIDEO_CAPTURE_BUFFER
{
    LwU32           dwCaptureStatus;        //!< LWAPI_VIDEO_DATA_PROVIDER_CAPTURE_STATUS
    LwU32           dwCapturePoint;         //!< At what point was this frame captured
    LwU32           dwCaptureFrameIndex;    //!< What frame number is to be captured
    LwU32           dwCaptureBufferSize;    //!< Size of the buffer (including this header)
    LwU32           dwLwrrentFrameIndex;    //!< What the frame number is now
    LwU32           dwImageCount;           //!< Number of image buffers used
    LWAPI_IMAGE_BUFFER  astImage[LWAPI_MAX_CAPTURE_IMAGES];

    LwU32           bCaptureSource    :  1;  //!< additional segments store source fields/frames (for deinterlace capture)
    LwU32           bCaptureAllFrames :  1;  //!< set only if we're capturing all frames (or at least more than just one)
    LwU32           byDecodedFrameType:  8;  //!< field (0=Progressive/1=A/2=B/3=Unknown) corresponding to decoded frame
    LwU32           reserved1         : 22;  //!< reserved for future expansion

    LwU32           dwCaptureFrameRange;    //!< set the range of frames to capture (typically only used for
                                            //!, golden captures on emulation)
    LwU32           dwDecodedFrameCount;    //!< Frame count of decoded frame corresponding to this buffer
    LwU32           dwUsedBufferSpace;      //!< Size used in the buffer (including this header)
    LwU32           dwSrcCount;
    LwU32           adwExtraInfo[LWAPI_MAX_CAPTURE_EXTRA_INFO]; //!< Extra info about this capture (specific to capture type)
    LwU32           dwVersion;              //!< Version number for distinguishing between this and earlier form of LWAPI_VIDEO_CAPTURE_BUFFER
                                            //!< Version 2 has two additional members dwAppliedAlgoCount and astAppliedAlgoList
    LwU32           dwReserved2[2];         //!< reserved for future expansion
    LwU32           dwAppliedAlgoCount;
    LWAPI_ALGO_DETAILS astAppliedAlgoList[LWAPI_MAX_APPLIED_ALGO_PER_STREAM_RUN];

    // Image buffer data immediately follows this struct in memory. astImage[i].pImgData points into it

} LWAPI_VIDEO_CAPTURE_BUFFER;

//! Macro for constructing the version field of ::_LWAPI_VIDEO_CAPTURE_BUFFER
#define LWAPI_VIDEO_CAPTURE_BUFFER_VER MAKE_LWAPI_VERSION(LWAPI_VIDEO_CAPTURE_BUFFER,2)


typedef struct _LWAPI_VIDEO_ILWTC_WEAVEMODE_BUFFER
{
    LwU32           dwCaptureStatus;        //!< LW_VIDEO_DATA_PROVIDER_CAPTURE_STATUS        
    LwU32           dwWeaveMode;            //!< dwWeaveMode stores the WeaveMode decision
    LwU32           dwReserved[2];          //!< reserved for future expansion    
}LWAPI_VIDEO_ILWTC_WEAVEMODE_BUFFER;

//! video capture points used for image capture 
typedef enum _LWAPI_VIDEO_CAPTURE_POINTS
{
    LWAPI_VIDEO_CAPTURE_NONE           = 0x00000000,
    LWAPI_VIDEO_CAPTURE_DECODE         = 0x00000001,
    LWAPI_VIDEO_CAPTURE_OVERLAY        = 0x00000002,
    LWAPI_VIDEO_CAPTURE_BLIT           = 0x00000004,
    LWAPI_VIDEO_CAPTURE_VPBLIT         = 0x00000008,
    LWAPI_VIDEO_CAPTURE_UNLOCK         = 0x00000010,
    LWAPI_VIDEO_CAPTURE_FE             = 0x00000020,
    LWAPI_VIDEO_CAPTURE_EE             = 0x00000040,
    LWAPI_VIDEO_CAPTURE_NR             = 0x00000080,
    LWAPI_VIDEO_CAPTURE_DI             = 0x00000100,
    LWAPI_VIDEO_CAPTURE_ILWTC          = 0x00000200,
    LWAPI_VIDEO_CAPTURE_PROCAMP_CSC    = 0x00000400,
    LWAPI_VIDEO_CAPTURE_GAMMA          = 0x00000800,
    LWAPI_VIDEO_CAPTURE_GAMUT_REMAP    = 0x00001000,
    LWAPI_VIDEO_CAPTURE_DCCE           = 0x00002000,
    LWAPI_VIDEO_CAPTURE_BLEND          = 0x00004000,
    LWAPI_VIDEO_CAPTURE_SCALE          = 0x00008000,
    LWAPI_VIDEO_CAPTURE_COMPOSITOR     = 0x00010000,
} LWAPI_VIDEO_CAPTURE_POINTS;

//! Internal functions and structs for Video Data Providers.
typedef enum _LWAPI_VID_DATA_PROVIDER_CTRL_ID
{
    LW_DATA_PROVIDER_ENUM = 1,
    LW_DATA_PROVIDER_REGISTER = 2,
    LW_DATA_PROVIDER_UNREGISTER = 3,
    LW_DATA_PROVIDER_PULL_MODEL_GET = 6,

    LW_DATA_PROVIDER_CTRL_LAST = 7,
} LWAPI_VID_DATA_PROVIDER_CTRL_ID;

//! internal common struct to be passed to KMD/XP
typedef struct _LWAPI_VID_DATA_PROVIDER_CTRL
{
    LwU32           dwCtrlID; //!< (IN) one of the LW_DATA_PROVIDER_xxx enums 
    union //!< anonymous union 
    {
        LwU64 qwParams[70]; // this is to ensure proper sizing with the driver 

        LWAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR           stDataProviderDesc; //!< (IN/OUT)
        LWAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO    stDataProviderReg; //!< (IN/OUT)
        LWAPI_PULL_MODEL_DATA_PACKET                   stPullModelData; //!< (IN/OUT)
    };
} LWAPI_VID_DATA_PROVIDER_CTRL;

//! @}






//! \addtogroup vidcontrol
//! @{


//! See LW_VIDEO_GET_SURFACE_INFO
#define MAX_VIDEO_SURFACE_COUNT 64


//! See LW_VIDEO_STATE_INFO
#define LW_MAX_VID_PP_INSTANCE 8

//! DX Version used by app - used in LW_VIDEO_DECODE_STREAM_INFO_V2
typedef enum _D3D_Version
{
    D3D_Version_9  = 9,
    D3D_Version_11 = 11,
} D3D_Version;
 
//! DirectX VA decode stream information - used in LW_VIDEO_DXVA_INFO
typedef struct _LW_VIDEO_DECODE_STREAM_INFO_V1
{
    LwU32   streamIndex;                    //!< (IN)  Selected stream
    LwU32   processID;                      //!< (OUT) Application process ID
    LwU32   streamSrcWidth;                 //!< (OUT) Width
    LwU32   streamSrcHeight;                //!< (OUT) Height
    LwU32   streamFormat;                   //!< (OUT) Stream encode format
}LW_VIDEO_DECODE_STREAM_INFO_V1;

//! DirectX VA decode stream information - used in LW_VIDEO_DXVA_INFO
typedef struct _LW_VIDEO_DECODE_STREAM_INFO_V2
{
    LwU32   streamIndex;                    //!< (IN)  Selected stream
    LwU32   processID;                      //!< (OUT) Application process ID
    LwU32   streamSrcWidth;                 //!< (OUT) Width
    LwU32   streamSrcHeight;                //!< (OUT) Height
    LwU32   streamFormat;                   //!< (OUT) Stream encode format
    D3D_Version dxVersion;                  //!< (OUT) DX Version used by App
}LW_VIDEO_DECODE_STREAM_INFO_V2;


typedef LW_VIDEO_DECODE_STREAM_INFO_V2 LW_VIDEO_DECODE_STREAM_INFO;

//!  DirectX VA information obtained by LwAPI_Video_GetDXVAInfo() 
typedef struct _LW_VIDEO_DXVA_INFO_V1
{
    LwU32   version;                        //!< (IN) Version constructed by the macro #LW_VIDEO_DXVA_INFO_VER
    LwU32   dxvaObjectCount;                //!<  No DirectX VA object created
    LW_VIDEO_DECODE_STREAM_INFO_V1 streamInfo[LW_MAX_VID_STREAMS];
} LW_VIDEO_DXVA_INFO_V1;

typedef struct _LW_VIDEO_DXVA_INFO_V2
{
    LwU32   version;                        //!< (IN) Version constructed by the macro #LW_VIDEO_DXVA_INFO_VER
    LwU32   dxvaObjectCount;                //!<  No DirectX VA object created
    LW_VIDEO_DECODE_STREAM_INFO streamInfo[LW_MAX_VID_STREAMS];
} LW_VIDEO_DXVA_INFO_V2;


//! Macro for constructing the version field of structure LW_VIDEO_DXVA_INFO
typedef LW_VIDEO_DXVA_INFO_V2 LW_VIDEO_DXVA_INFO; 
#define LW_VIDEO_DXVA_INFO_VER_1  MAKE_LWAPI_VERSION(LW_VIDEO_DXVA_INFO_V1,1)
#define LW_VIDEO_DXVA_INFO_VER_2  MAKE_LWAPI_VERSION(LW_VIDEO_DXVA_INFO_V2,2)
#define LW_VIDEO_DXVA_INFO_VER    LW_VIDEO_DXVA_INFO_VER_2
//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Video_GetDXVAInfo
//
//! DESCRIPTION:     This API retrieves DirectX VA decode information for SWAK.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 175
//!
//! \param [in]   hLwDisplay    LWPU Display selection. It can be #LWAPI_DEFAULT_HANDLE or a handle enumerated 
//!                             from LwAPI_EnumLWidiaDisplayHandle().
//! \param [out]  pDxvaInfo     Structure for retrieving DirectX VA information
//!
//! \retval ::LWAPI_OK
//! \retval ::LWAPI_ILWALID_ARGUMENT
//! \retval ::LWAPI_API_NOT_INTIALIZED
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION
//! \retval ::LWAPI_ERROR
//! 
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Video_GetDXVAInfo(LwDisplayHandle hLwDisplay, LW_VIDEO_DXVA_INFO *pDxvaInfo);


//! \addtogroup vidcontrol
//! @{


//! Video overlay information obtained by LwAPI_Video_GetOverlayInfo()
typedef struct
{
    LwU32   version;                        //!< (IN) Version constructed by macro #LW_VIDEO_OVERLAY_INFO_VER
    LwU8    overlayInUse;                   //!< (OUT) Boolean:Is overlay in use
    LwU32   overlaySurfaceCount;            //!< (OUT) Number of overlay surfaces created
} LW_VIDEO_OVERLAY_INFO_V1;

typedef enum _LWAPI_VIDEO_OVERLAY_FLAGS
{
    LWAPI_OVERLAY_FLAG_UNKNOWN = 0,
    LWAPI_OVERLAY_FLAG_D3DAPI,
    LWAPI_OVERLAY_FLAG_LWAPI,
} LWAPI_VIDEO_OVERLAY_FLAGS;

typedef struct
{
    LwU32                      version;                        //!< (IN) Version constructed by macro #LW_VIDEO_OVERLAY_INFO_VER
    LwU8                       overlayInUse;                   //!< (OUT) Boolean:Is overlay in use
    LwU32                      overlaySurfaceCount;            //!< (OUT) Number of overlay surfaces created
    LwU8                       overlaySurfaceBPP[LW_MAX_HEADS];//!< (OUT) BPP of surface (tells us whether RGB or YUY2)
    LWAPI_VIDEO_OVERLAY_FLAGS  overlayFlags[LW_MAX_HEADS];     //!< (OUT) Overlay API details (from LWAPI_VIDEO_OVERLAY_FLAGS)
    LW_RECT                    overlaySrcRect[LW_MAX_HEADS];   //!< (OUT) Input dimension
    LW_RECT                    overlayDestRect[LW_MAX_HEADS];  //!< (OUT) Output dimension (to be displayed)
} LW_VIDEO_OVERLAY_INFO_V2;

//! Macro for constructing the version field of LW_VIDEO_OVERLAY_INFO
typedef LW_VIDEO_OVERLAY_INFO_V2 LW_VIDEO_OVERLAY_INFO; 

#define LW_VIDEO_OVERLAY_INFO_VER_1  MAKE_LWAPI_VERSION(LW_VIDEO_OVERLAY_INFO_V1,1)
#define LW_VIDEO_OVERLAY_INFO_VER_2  MAKE_LWAPI_VERSION(LW_VIDEO_OVERLAY_INFO_V2,2)
#define LW_VIDEO_OVERLAY_INFO_VER    LW_VIDEO_OVERLAY_INFO_VER_2

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Video_GetOverlayInfo
//
//! DESCRIPTION:     This API retrieves video overlay information for SWAK
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 175
//!
//! \param [in]      hLwDisplay              LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated 
//!                                          from LwAPI_EnumLWidiaDisplayHandle().
//! \param [out]     pVideoOverlayInfo       Structure for retrieving video overlay information
//!
//! \retval ::LWAPI_OK
//! \retval ::LWAPI_ILWALID_ARGUMENT
//! \retval ::LWAPI_API_NOT_INTIALIZED
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION
//! \retval ::LWAPI_ERROR
//! 
//! \ingroup vidcontrol 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Video_GetOverlayInfo(LwDisplayHandle hLwDisplay, LW_VIDEO_OVERLAY_INFO *pVideoOverlayInfo);





//! \addtogroup vidcontrol
//! @{

//! Video surface width, height, format, and size information - used in _LW_VIDEO_GET_SURFACE_INFO 
typedef struct _LW_VIDEO_SURFACE_INFO
{
    LwU32   surfaceWidth;                 //!< (OUT) Surface width
    LwU32   surfaceHeight;                //!< (OUT) Surface height
    LwU32   surfaceFormat;                //!< (OUT) FOURCC format
    LwU32   surfaceSize;                  //!< (OUT) Surface size in KB
}LW_VIDEO_SURFACE_INFO;


//! Video surface count obtained by LwAPI_Video_GetVideoSurfaceCount()
typedef struct _LW_VIDEO_GET_SURFACE_COUNT
{
    LwU32   version;                      //!< (IN)  Version constructed by the macro #LW_VIDEO_GET_SURFACE_COUNT_VER
    LwU32   surfaceFormat;                //!< (IN)  FOURCC format
    LwU32   videoSurfaceCount;            //!< (OUT) Video surface count
} LW_VIDEO_GET_SURFACE_COUNT;


//! Macro for constructing the version field of LW_VIDEO_GET_SURFACE_COUNT
#define LW_VIDEO_GET_SURFACE_COUNT_VER  MAKE_LWAPI_VERSION(LW_VIDEO_GET_SURFACE_COUNT,1)

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Video_GetVideoSurfaceCount
//
//! DESCRIPTION:     This API gets the video surface count for a specific FOURCC format.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 175
//!
//! \param [in]      hLwDisplay          LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated 
//!                                      from LwAPI_EnumLWidiaDisplayHandle().
//! \param [out]     pVideoSurfaceCount  Structure for retrieving video surface count
//!
//! \retval ::LWAPI_OK
//! \retval ::LWAPI_ILWALID_ARGUMENT
//! \retval ::LWAPI_API_NOT_INTIALIZED
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION
//! \retval ::LWAPI_ERROR
//!
//!  \ingroup vidcontrol 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Video_GetVideoSurfaceCount(LwDisplayHandle hLwDisplay, LW_VIDEO_GET_SURFACE_COUNT *pVideoSurfaceCount);





//! \addtogroup vidcontrol
//! @{

//! Video surface information - obtained by LwAPI_Video_GetVideoSurfaceInfo()
typedef struct  _LW_VIDEO_GET_SURFACE_INFO
{
    LwU32   version;                                            //!< (IN) Structure version constructed by macro #LW_VIDEO_GET_SURFACE_INFO_VER
    LwU32   surfaceFormat;                                      //!< (IN) FOURCC format
    LwU32   startSurfCount;                                     //!< (IN) starting surface count
    LwU32   videoSurfaceCount;                                  //!< (OUT) videoSurfaceCount
    LW_VIDEO_SURFACE_INFO  surfaceInfo[MAX_VIDEO_SURFACE_COUNT];//!< (OUT) video Surface information
} LW_VIDEO_GET_SURFACE_INFO;


//! Macro for constructing the version field of structure LW_VIDEO_GET_SURFACE_INFO
#define LW_VIDEO_GET_SURFACE_INFO_VER  MAKE_LWAPI_VERSION(LW_VIDEO_GET_SURFACE_INFO,1)

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Video_GetVideoSurfaceInfo
//
//! DESCRIPTION:     This API gets detailed video surface information for a given FOURCC format
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 175
//!
//! \param [in]     hLwDisplay          LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated 
//!                                     from LwAPI_EnumLWidiaDisplayHandle().
//! \param [out]    pVideoSurfaceInfo   Structure for retrieving detailed information for video surfaces of given FOURCC
//!
//! \retval ::LWAPI_OK
//! \retval ::LWAPI_ILWALID_ARGUMENT
//! \retval ::LWAPI_API_NOT_INTIALIZED
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION
//! \retval ::LWAPI_ERROR
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Video_GetVideoSurfaceInfo(LwDisplayHandle hLwDisplay, LW_VIDEO_GET_SURFACE_INFO *pVideoSurfaceInfo);






//! \addtogroup vidcontrol
//! @{

//! Video stream state - used in _LW_VIDEO_STATE_INFO
typedef struct _LW_VIDEO_STREAM_STATE_V1
{
    LwU32   streamIndex;                                            //!< (OUT) Stream Index
    LwU32   surfaceWidth;                                           //!< (OUT) width
    LwU32   surfaceHeight;                                          //!< (OUT) height
    LwU8    gdiDisplayName[32];                                     //!< (OUT) gdiName corresponding to the video window
    LWAPI_GET_VIDEO_STATE_COMPONENT vidComponent[LWAPI_VIDEO_STATE_COMPONENT_ID_LAST];
    LwU32   bVICInUse;                                              //!< (OUT) flag to display whether VIC is in use
    LwU32   dwReserved[8];                                          //!< (OUT) reserved DWORDS for future use (helps prevent 
}LW_VIDEO_STREAM_STATE_V1;

typedef struct _LW_VIDEO_STREAM_STATE_V2
{
    LwU32   streamIndex;                                            //!< (OUT) Stream Index
    LwU32   surfaceWidth;                                           //!< (OUT) width
    LwU32   surfaceHeight;                                          //!< (OUT) height
    LwU8    gdiDisplayName[32];                                     //!< (OUT) gdiName corresponding to the video window
    LWAPI_GET_VIDEO_STATE_COMPONENT vidComponent[LWAPI_VIDEO_STATE_COMPONENT_ID_LAST];
    LwU32   bVICInUse;                                              //!< (OUT) flag to display whether VIC is in use
    LwU32   dwReserved[8];                                          //!< (OUT) reserved DWORDS for future use (helps prevent 
    D3D_Version   dxVersion;                                        //!< (OUT) DxVersion used by App.
}LW_VIDEO_STREAM_STATE_V2;


typedef LW_VIDEO_STREAM_STATE_V2 LW_VIDEO_STREAM_STATE;


//! Video stream surface information - obtained by LwAPI_Video_GetVideoStateInfo() 
typedef struct
{
    LwU32                   version;                            //!< (IN) Version info constructed by macro #LW_VIDEO_STATE_INFO_VER
    LwU32                   streamCount;                        //!< (OUT) number of DirectX VA video processing devices created
    LW_VIDEO_STREAM_STATE_V1   streamInfo[LW_MAX_VID_PP_INSTANCE];
}LW_VIDEO_STATE_INFO_V1;

typedef struct
{
    LwU32                   version;                            //!< (IN) Version info constructed by macro #LW_VIDEO_STATE_INFO_VER
    LwU32                   streamCount;                        //!< (OUT) number of DirectX VA video processing devices created
    LW_VIDEO_STREAM_STATE   streamInfo[LW_MAX_VID_PP_INSTANCE];
 }LW_VIDEO_STATE_INFO_V2;


//! Macro for constructing the version field of LW_VIDEO_STATE_INFO

typedef LW_VIDEO_STATE_INFO_V2     LW_VIDEO_STATE_INFO; 
#define LW_VIDEO_STATE_INFO_VER_1  MAKE_LWAPI_VERSION(LW_VIDEO_STATE_INFO_V1,1)
#define LW_VIDEO_STATE_INFO_VER_2  MAKE_LWAPI_VERSION(LW_VIDEO_STATE_INFO_V2,2)
#define LW_VIDEO_STATE_INFO_VER    LW_VIDEO_STATE_INFO_VER_2

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Video_GetVideoStateInfo
//
//! DESCRIPTION:     This API retrieves state information for different video streams
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 175
//!
//! \param [in]    hLwDisplay(IN)    LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated 
//!                                  from LwAPI_EnumLWidiaDisplayHandle().
//! \param [out]   pVideoStateInfo   Structure of state information for different video streams 
//!
//! \retval ::LWAPI_OK
//! \retval ::LWAPI_ILWALID_ARGUMENT
//! \retval ::LWAPI_API_NOT_INTIALIZED
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION
//! \retval ::LWAPI_ERROR
//!
//!  \ingroup vidcontrol 
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Video_GetVideoStateInfo(LwDisplayHandle hLwDisplay, LW_VIDEO_STATE_INFO *pVideoStateInfo);



//! \addtogroup vidcontrol
//! @{


//! See _LW_VIDEO_GET_INFO
typedef enum _LW_VIDEO_QUERY_ID
{
    LW_VIDEO_GET_DXVA_INFO,
    LW_VIDEO_GET_OVERLAY_INFO,
    LW_VIDEO_GET_VIDEO_SURFACE_COUNT,
    LW_VIDEO_GET_SURFACE_DETAIL,
    LW_VIDEO_GET_STATE_INFO,
    LW_VIDEO_GET_COMMAND_LAST
} LW_VIDEO_QUERY_ID;



typedef struct _LW_VIDEO_GET_INFO
{
    LwU32               version;            //! (IN) Version constructed by macro #LW_VIDEO_GET_INFO_VER
    LW_VIDEO_QUERY_ID   queryID;            //! (IN) Query type
    union
    {
        LW_VIDEO_DXVA_INFO          getDxvaInfo;
        LW_VIDEO_OVERLAY_INFO       getOverlayInfo;
        LW_VIDEO_GET_SURFACE_COUNT  getVideoSurfaceCount;
        LW_VIDEO_GET_SURFACE_INFO   getVideoSurfaceInfo;
        LW_VIDEO_STATE_INFO         getVideoStateInfo;
    };
} LW_VIDEO_GET_INFO;


//! Macro for constructing the version field of LW_VIDEO_GET_INFO
#define LW_VIDEO_GET_INFO_VER  MAKE_LWAPI_VERSION(LW_VIDEO_GET_INFO,1)

//! @}






//! \ingroup vidcontrol
//! @{

typedef struct _LW_VIDEO_LOCATION_MAP
{
    LwU32 vidPnSrcId;
    LwU32 head;
    LwU32 displayId;
    LwU8  gdiDisplayName[32];
} LW_VIDEO_LOCATION_MAP;

typedef struct _LW_VIDEO_GET_VID_LOCATION_MAP
{
    LwU32   version;                        //!< (IN)version info
    LW_VIDEO_LOCATION_MAP vidLocMap;
} LW_VIDEO_GET_VID_LOCATION_MAP;

//! Macro for constructing theversion field of ::_LW_VIDEO_GET_VID_LOCATION_MAP
#define LW_VIDEO_GET_VID_LOCATION_MAP_VER  MAKE_LWAPI_VERSION(LW_VIDEO_GET_VID_LOCATION_MAP,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetVidLocMap
//
//! \code
//! PARAMETERS:    hLwDisplay(IN) - LWPU Display selection. It can be LWAPI_DEFAULT_HANDLE or a handle enumerated from LwAPI_EnumLWidiaDisplayHandle().
//!                pGetVidLocMap(OUT) - The VID_LOC_MAP associated with the selected display handle hLwDisplay.
//!
//!   DESCRIPTION: Returns the VideoLocationMap associated with a physical GPU handle.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: lwGPUHandle is not valid; hLwDisp is NULL
//!                LWAPI_OK: one handle was returned
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GetVidLocMap(LwDisplayHandle hLwDisplay, LW_VIDEO_GET_VID_LOCATION_MAP *pGetVidLocMap);



//! \ingroup vidcontrol
//! @{

//!<struct _LW_ENC_CONFIG_H264
//!<H264 encoder configuration parameters
 
typedef struct _LW_ENCODE_CODEC_H264
{
    LwU32                            profile;                                     //!< Specifies the encoding profile
    LwU32                            level;                                       //!< Specifies the encoding level
    LwU32                            numSlices;                                   //!< Specifies number of slices
    LwU32                            intraRefreshCnt ;                            //!< Specifies the number of frames over which intra refresh will happen
    LwU32                            transform8x8Mode;                            //!< Specifies the adaptive transform 8x8 mode
    LwU32                            numRefFrames;                                //!< Specifies the DPB size used for encoding. Setting it to 0 will let driver use the default dpb size
    LwU32                            sliceMode;                                   //!< This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices
    LwU32                            sliceModeData;                               //!< Specifies the parameter needed for sliceMode
    LwU32                            bSVCTemporalFlag                    :1;      //!< Set to 1 to enable SVC temporal
    LwU32                            bHierarchicalPFrames                :1;      //!< Set to 1 to enable hierarchical PFrames
    LwU32                            bHierarchicalBFrames                :1;      //!< Set to 1 to enable hierarchical BFrames
    LwU32                            bRepeatSPSPPS                       :1;      //!< Set to 1 to enable writing of Sequence and Picture parameter for every IDR frame
    LwU32                            bSeparateColourPlaneFlag            :1;      //!< Set to 1 to enable 4:4:4 separate colour planes         
    LwU32                            bVleCabacEnable                     :1;      //!< Specifies entropy coding mode(0-CAVLC, 1-CABAC)
    LwU32                            bDeblockingFilterControlPresentFlag :1;      //!< Specifies whether deblocking is needed
    LwU32                            reserved1                           :25;
    LwU32                            reserved2[7];                               //!< size of struct is 128 bytes
} LW_ENCODE_CODEC_H264_V1;

typedef LW_ENCODE_CODEC_H264_V1 LW_ENCODE_CODEC_H264;

typedef union _LW_ENCODE_CODEC
{
    LW_ENCODE_CODEC_H264_V1                h264Config;                  //!<  Specifies the H.264-specific encoder configuration 
    LwU32                                  reserved[32];
} LW_ENCODE_CODEC;

typedef struct _LW_ENCODE_INSTANCE_INFO
{
    LwU32                            processId;                      //!< Process ID
    LwU32                            instanceId;                     //!< Instance ID- Id of the encode instance(a single process may create multiple encode instances)
    LwU32                            codecType;                      //!< codecType
    LwU32                            idrPeriod;                      //!< Specifies the IDR interval. If not set, this is made equal to gopLength in LW_ENC_CONFIG.
    LwU32                            rateControlMode;                //!< Specifies the rate control mode
    LwU32                            maxqp[3];                       //!< Specifies the maximum QP used for rate control
    LwU32                            minqp[3];                       //!< Specifies the minimum QP used for rate control
    LwU32                            vbvBufferSize;                  //!< Specifies the VBV(HRD) buffer size. in bits. Set 0 to use the default VBV  buffer size.
    LwU32                            vbvInitialDelay;                //!< Specifies the VBV(HRD) initial delay in bits. Set 0 to use the default VBV  initial delay
    LwU32                            hrdBitRate;                     //!< Specifies the maximum bitrate for the encoded output. This is used for VBR and ignored for CBR mode.
    LwU32                            rcAvgBitRate;                   //!< Specifies the average bitrate(in bits/sec) used for encoding.
    LwU32                            frmFldMode;                     //!< Specifies the frame/field mode
    LwU32                            encodeWidth;                    //!< o/p width
    LwU32                            encodeHeight;                   //!< o/p height
    LwU32                            darWidth;                       //!< Specifies the display aspect ratio Width
    LwU32                            darHeight;                      //!< Specifies the display aspect ratio Height
    double                           frameRate;                      //!< Specifies the frame rate used for encoding in frames per second
    LwU32                            numBFrames;                     //!< Specifies the number of B frames
    LwU32                            gopILength;                     //!< Specifies the number of pictures in one GOP. Low latency application client can set goplength to LWENC_INFINITE_GOPLENGTH so that keyframes are not inserted automatically
    LwU32                            msencPreset;                    //!< Specifies the encoder preset
    LW_ENCODE_CODEC                  encodeCodec;                    //!< [in]: Specifies the codec specific config parameters through this union
    struct _LW_ENCODE_INSTANCE_INFO* pNext;
    LwU32                            bEnableExternalHints     :1;    //!< Set to 1 to enable external ME hints for the current frame. 
    LwU32                            path                     :1;    //!< Default:0(DXVA) .Set to 1 (Lwlwvid)
    LwU32                            reserved1                :30;
    LwU32                            reserved2[4];
} LW_ENCODE_INSTANCE_INFO_V1;

typedef LW_ENCODE_INSTANCE_INFO_V1 LW_ENCODE_INSTANCE_INFO;

typedef struct _LW_ENCODE_INSTANCE
{
    LwU32                           version;                             //!< struct version
    LwU32                           instCount;                           //!< number of encode application instances
    LW_ENCODE_INSTANCE_INFO_V1*     pEncInfo;                            //!< head of the linked list
    LwU32                           bGetInstanceInfoFlag                 :1;// set to 0 to retrieve instance_count and 1 to retrieve instance info 
    LwU32                           reserved1                            :31;
    LwU32                           reserved2[4];
} LW_ENCODE_INSTANCE_V1;

typedef LW_ENCODE_INSTANCE_V1       LW_ENCODE_INSTANCE;
#define LW_ENCODE_INSTANCE_VER1     MAKE_LWAPI_VERSION(LW_ENCODE_INSTANCE_V1,1)
#define LW_ENCODE_INSTANCE_VER      LW_ENCODE_INSTANCE_VER1


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Video_GetEncodeInfo
//
//! \code
//! DESCRIPTION:     This API is used to retrieve encode information for lwrrently running encode instances
//!
//! SUPPORTED OS:  Windows Vista and higher,  Mac OS X
//!
//! \Since Release:322
//!
//! PARAMETERS:      pEncodeInfo(OUT)        - structure for retrieving encode information per instance
//! RETURN STATUS:   This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with
//!                  specific meaning for this API, they are listed below.
//!                  LWAPI_LWIDIA_DEVICE_NOT_FOUND - Display Handle is default
//! \endcode
//! \ingroup diagapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Video_GetEncodeInfo(__inout LW_ENCODE_INSTANCE *pEncodeInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Video_SetEncodeInfo
//
//! \code
//! DESCRIPTION:     This API is used to set encode information by lwrrently running encode instances
//!
//! SUPPORTED OS:  Windows Vista and higher,  Mac OS X
//!
//!
//!
//! PARAMETERS:      pEncodeInfo(IN)        - structure carrying encode information per instance
//! RETURN STATUS:   This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with
//!                  specific meaning for this API, they are listed below.
//!                  LWAPI_LWIDIA_DEVICE_NOT_FOUND - Display Handle is default
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Video_SetEncodeInfo(__in LW_ENCODE_INSTANCE *pEncodeInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Video_ReleaseEncodeInfo
//
//! \code
//! DESCRIPTION:     This API is used to release KMD surfaces after the encode instance finishes exelwtion
//!
//! SUPPORTED OS:  Windows Vista and higher,  Mac OS X
//!
//!
//!
//! PARAMETERS:      processId(IN),instanceId(IN)        - providing instance-id,process-id of instance to be deleted
//! RETURN STATUS:   This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with
//!                  specific meaning for this API, they are listed below.
//!                  LWAPI_LWIDIA_DEVICE_NOT_FOUND - Display Handle is default
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Video_ReleaseEncodeInfo(__in LwU32 processId, __in LwU32 instanceId);

//! @}
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Audio_EnumDeviceHandle
//
//! \code
//! PARAMETERS:    thisEnum (IN)              - index of audio device for which device handle is requested
//!                hDeviceObject (OUT)        - pointer to LwAudioHandle
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! DESCRIPTION:   Enumerates Audio devices present in the system
//!                
//!
//! RETURN STATUS: 
//!                LWAPI_OK - completed request
//!                LWAPI_ERROR - miscellaneous error oclwrred
//!                LWAPI_ILWALID_ARGUMENT - invalid input parameter
//!                LWAPI_MATCHING_DEVICE_NOT_FOUND - No Lwpu HDA device installed
//!                LWAPI_END_ENUMERATION - thisEnum is greater than the number of lwpu audio devices in system
//! \endcode
//! \ingroup audioapi
///////////////////////////////////////////////////////////////////////////////

LWAPI_INTERFACE LwAPI_Audio_EnumDeviceHandle(LwU32 thisEnum, LwAudioHandle* hDeviceObject);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Audio_GetDeviceParameters
//
//! \fn LwAPI_Audio_GetDeviceParameters(LwAudioHandle LwAudioHandle, LW_AUDIO_PARAMETERS *pLW_AUDIO_PARAMETERS)
//! \code
//! PARAMETERS:    LwAudioHandle (IN)............... - LwAudioHandle value
//!                pLW_AUDIO_PARAMETERS (OUT)        - pointer to LW_AUDIO_PARAMETERS structure
//!                                  
//! SUPPORTED OS:  Windows XP and higher
//!
//! DESCRIPTION:   Provides various Audio Device Property values
//!
//! RETURN STATUS: 
//!                LWAPI_OK - completed request
//!                LWAPI_ERROR - miscellaneous error oclwrred
//!                LWAPI_ILWALID_ARGUMENT - invalid input parameter
//!                LWAPI_ILWALID_HANDLE - invalid handle to device
//!                LWAPI_INCOMPATIBLE_STRUCT_VERSION - Incompatible struct version
//! \endcode
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup audioapi
//! @{

typedef enum _LW_AUDIO_CHANNEL
{
    LW_AUDIO_CHAN_0 =          (1 << 0),
    LW_AUDIO_CHAN_1 =          (1 << 1),
    LW_AUDIO_CHAN_2 =          (1 << 2),
    LW_AUDIO_CHAN_3 =          (1 << 3),
    LW_AUDIO_CHAN_4 =          (1 << 4),
    LW_AUDIO_CHAN_5 =          (1 << 5),
    LW_AUDIO_CHAN_6 =          (1 << 6),
    LW_AUDIO_CHAN_7 =          (1 << 7),
    LW_AUDIO_CHAN_8 =          (1 << 8),
    LW_AUDIO_CHAN_9 =          (1 << 9),
    LW_AUDIO_CHAN_10 =         (1 << 10)
}LW_AUDIO_CHANNEL;

typedef enum _LW_AUDIO_SIZE
{
    LW_AUDIO_SIZE_16BIT =      (1 << 0),
    LW_AUDIO_SIZE_20BIT =      (1 << 1),
    LW_AUDIO_SIZE_24BIT =      (1 << 2),
}LW_AUDIO_SIZE;

typedef enum _LW_AUDIO_RATE
{
    LW_AUDIO_RATE_32000 =      (1 << 8),
    LW_AUDIO_RATE_44100 =      (1 << 9),
    LW_AUDIO_RATE_48000 =      (1 << 10),
    LW_AUDIO_RATE_88200 =      (1 << 11),
    LW_AUDIO_RATE_96000 =      (1 << 12),
    LW_AUDIO_RATE_176400 =     (1 << 13),
    LW_AUDIO_RATE_192000 =     (1 << 14),
}LW_AUDIO_RATE;

typedef enum _LW_AUDIO_FORMAT
{
    LW_AUDIO_FORMAT_LPCM =     (1 << 1),  //!< Linear PCM (e.g., IEC 60958)
    LW_AUDIO_FORMAT_AC3 =      (1 << 2),  //!< AC-3
    LW_AUDIO_FORMAT_MPEG1 =    (1 << 3),  //!< MPEG1 (Layers 1 & 2)
    LW_AUDIO_FORMAT_MP3 =      (1 << 4),  //!< MP3 (MPEG1 Layer 3)
    LW_AUDIO_FORMAT_MPEG2 =    (1 << 5),  //!< MPEG2 (multichannel)
    LW_AUDIO_FORMAT_AAC =      (1 << 6),  //!< AAC
    LW_AUDIO_FORMAT_DTS =      (1 << 7),  //!< DTS
    LW_AUDIO_FORMAT_ATRAC =    (1 << 8),  //!< ATRAC
    LW_AUDIO_FORMAT_SACD =     (1 << 9),  //!< One Bit Audio
    LW_AUDIO_FORMAT_DDPLUS =   (1 << 10), //!< Dolby Digital +
    LW_AUDIO_FORMAT_DTSHD =    (1 << 11), //!< DTS-HD
    LW_AUDIO_FORMAT_MAT =      (1 << 12), //!< MAT (MLP)
    LW_AUDIO_FORMAT_DST =      (1 << 13), //!< DST
    LW_AUDIO_FORMAT_WMAPRO =   (1 << 14), //!< WMA Pro
    LW_AUDIO_FORMAT_RESERVED = (1 << 15), //!< Reserved for audio format 15
}LW_AUDIO_FORMAT;

typedef struct _LW_AUDIO_PARAMETERS
{
    LwU32 version;                //!< Strulwre version
    
    LwU32 venID;                  //!< Vendor ID
    LwU32 devID;                  //!< Developer ID
    LwU32 revID;                  //!< Revision ID
    
    LwU32 paramVersion;           //!< Parameter versioning used inside audio Driver
    
    //Contents of audio HeadScratch registers
    LwU32 regH0S0;                //!< LW_PDISP_AUDIO_HEAD0_SCRATCH0
    LwU32 regH0S1;                //!< LW_PDISP_AUDIO_HEAD0_SCRATCH1
    LwU32 regH1S0;                //!< LW_PDISP_AUDIO_HEAD1_SCRATCH0
    LwU32 regH1S1;                //!< LW_PDISP_AUDIO_HEAD1_SCRATCH1
    LwU32 regLPCM;                //!< LW_PDISP_AUDIO_EXAUD_LPCM
    
    // Current audio stream properties
    LwU32 lwrrentState:1;         //!< State of current audio stream
    LwU32 lwrrentChan;            //!< Number of channels in current audio stream
    LwU32 lwrrentRate;            //!< Bitrate of current audio stream
    LwU32 lwrrentSampleSize;      //!< samplesize for current audio stream
    
    //Device maximum settings
    LwU32 maxState:1;             //!< State of Device maximum settings (Valid/Invalid)
    LwU32 maxRate;                //!< Bitrates allowed by LWHDA codec present
    LwU32 maxSampleSize;          //!< SampleSizes allowed by LWHDA codec present
    LwU32 maxFormats;             //!< SampleSIzes allowed by LWHDA codec present
    LwU32 maxChan;                //!< SampleSizes allowed by LWHDA codec present
    
    //Driver sink settings 
    LwU32 sinkState:1;            //!< State of Driver Sink settings (Valid/Invalid)
    LwU32 sinkRate;               //!< Bitrates allowed by LWHDA codec present
    LwU32 sinkSampleSize;         //!< SampleSizes allowed by sink device present
    LwU32 sinkFormats;            //!< SampleSIzes allowed by sink devicec present
    LwU32 sinkChan;               //!< SampleSizes allowed by sink device present
    
    //Driver override settings
    LwU32 overrideState:1;        //!< State of Driver Overrides (Valid/Invalid)
    LwU32 overrideRate;           //!< Bitrates overrided
    LwU32 overrideSampleSize;     //!< SampleSizes overrided
    LwU32 overrideFormats;        //!< SampleSIzes overrided
    LwU32 overrideChan;           //!< SampleSizes overrided

} LW_AUDIO_PARAMETERS;

//! Macro for constructing the version field of ::_LW_AUDIO_PARAMETERS
#define LW_AUDIO_PARAMETERS_VER  MAKE_LWAPI_VERSION(LW_AUDIO_PARAMETERS,1)

//! @}

//! \ingroup audioapi
LWAPI_INTERFACE LwAPI_Audio_GetDeviceParameters(LwAudioHandle LwAudioHandle, LW_AUDIO_PARAMETERS *pLW_AUDIO_PARAMETERS);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Audio_SetDeviceParametersOverride
//
//! \code
//! PARAMETERS:    LwAudioHandle (IN)                - LwAudioHandle value
//!                pLW_AUDIO_PARAMETERS (IN)         - pointer to LW_AUDIO_PARAMETERS structure
//!                                  
//! SUPPORTED OS:  Windows XP and higher
//!
//! DESCRIPTION:   Sets various override parameters of Audio Device
//!
//! RETURN STATUS: 
//!                LWAPI_OK - completed request
//!                LWAPI_ERROR - miscellaneous error oclwrred
//!                LWAPI_ILWALID_ARGUMENT - invalid input parameter
//!                LWAPI_ILWALID_HANDLE - invalid handle to device
//!                LWAPI_INCOMPATIBLE_STRUCT_VERSION - Incompatible struct version
//! \endcode
//! \ingroup audioapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Audio_SetDeviceParametersOverride(LwAudioHandle LwAudioHandle, LW_AUDIO_PARAMETERS *pLW_AUDIO_PARAMETERS);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SelwreAudio_GetSelwreAudioAPIRevision
//!
//! DESCRIPTION:    Returns the Secure Audio API revision.
//! \deprecated  Do not use this function - it is deprecated in release 313. Instead, use LwAPI_SelwreAudio_CheckAPICompatibility.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!
//! \param [out]     lwSelwreAudioAPIRevision               Revision number of Secure Audio API.
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup selwreaudioapi
//! @{

//! Secure Audio API REVISION
//! Client uses this revision in LwAPI_SelwreAudio_CheckAPICompatibility API to establish compatability between client API and driver.
#define LW_SELWRE_AUDIO_API_REVISION  0x00010001

//! Content key header version
#define LW_CONTENT_KEY_HEADER_VERSION 0x01

//! Secure Audio Flags
#define LW_CONTENT_KEY_HEADER_KEY_IS_PLAINTEXT          LW_BIT(1)   //!< Flags bit #1, leave to 0 if content key is sent already encrypted
#define LW_CONTENT_KEY_HEADER_OOS_ENABLED               LW_BIT(2)   //!< Flags bit #2, Set if input stream has Kepler out-of-sync detection counter bytes enabled

//! Content key is copied as-is from the WAVEFORMATEXTENSIBLE data extension area
#define LW_CONTENT_KEY_HEADER_KEYLENGTH 16
#define LW_CONTENT_KEY_HEADER_IVLENGTH  16

//! Size of content key header structure.
#define LW_CONTENT_KEY_HEADER_SIZE sizeof(LW_CONTENT_KEY_HEADER)

typedef struct _LW_CONTENT_KEY_HEADER
{
    LwU8 version;                               //!< versioning maintained inside the audio driver
    LwU8 contentKeyHeaderLength;                //!< Size of the structure
    LwU8 flags;                                 //!< flag values specified above
    LwU8 counterWrapAround;                     //!< Counter value to be used in case of OOSD enabled
    LwU8 iv[LW_CONTENT_KEY_HEADER_IVLENGTH];    //!< Initial counter value used for data encryption using content key
    LwU8 key[LW_CONTENT_KEY_HEADER_KEYLENGTH];  //!< Content Key expected to be encrypted by the session key by the application.
} LW_CONTENT_KEY_HEADER;

//! @}

//! \ingroup selwreaudioapi
__lwapi_deprecated_function("Do not use this function - it is deprecated in release 313. Instead, use LwAPI_SelwreAudio_CheckAPICompatibility.")
LWAPI_INTERFACE LwAPI_SelwreAudio_GetSelwreAudioAPIRevision(__out LwU32* lwSelwreAudioAPIRevision);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SelwreAudio_CheckAPICompatibility
//!
//! DESCRIPTION:    Checks API and Driver compatibility with the client. Return value LWAPI_OK suggests that the client is using compatible API version with the system driver. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 313
//!
//! \param [in]    endpointID                   Pointer to an endpoint ID string. The caller typically obtains this string from the IMMDevice::GetId method
//! \param [in]    lwSelwreAudioAPIRevision     Revision number of Secure Audio API.
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SelwreAudio_CheckAPICompatibility( __in LwAPI_LPCWSTR endpointID, __in LwU32 lwSelwreAudioAPIRevision);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SelwreAudio_GetLwstomFormatGUID
//
//! DESCRIPTION:    This API gets the subformat GUID as the input parameter and returns corresponding subformat for encrypted audio.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!
//! \param [in/out]    SubFormat    GUID for audio subformat
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//!
//! \ingroup selwreaudioapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SelwreAudio_GetLwstomFormatGUID(__inout LwGUID* subFormat);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SelwreAudio_NegotiateDHExchange
//
//! DESCRIPTION:    This API assists the application in negotiating Diffie-Hellman Key exchange with the audio hardware to establish the session Key.
//!                 Application generates the Challenge token for DH Key exchange (256 BYTE array of random numbers).
//!                 API communicates the Challenge token with HW. HW in turn generates the ResponseToken.
//!                 API provides this ResponseToken (256 BYTE) to the application. Application uses this ResponseToken to generate the session key.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!
//! \param [in]    endpointID                   Pointer to an endpoint ID string. The caller typically obtains this string from the IMMDevice::GetId method
//! \param [in]    challengeToken               ChallengeToken for DH Key exchange
//! \param [out]   responseToken                ResponseToken for DH Key exchange
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//! \retval ::LWAPI_INCOMPATIBLE_AUDIO_DRIVER
//!
//! \ingroup selwreaudioapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SelwreAudio_NegotiateDHExchange( __in LwAPI_LPCWSTR endpointID, __in LwU8* challengeToken, __out LwU8* responseToken );

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SelwreAudio_ComputeSessionKey
//
//! DESCRIPTION:    This API negotiates Session key with audio HW. 
//!                 In this case Application is transparent to DH key exchange and it is completely handled by API.
//!                 Application gets ready-made SessionKey. Internally this API uses calls LwAPI_SelwreAudio_NegotiateDHExchange.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!
//! \param [in]    endpointID                  Pointer to an endpoint ID string. The caller typically obtains this string from the IMMDevice::GetId method
//! \param [out]   sessionKey                  This key will be used to encrypt the content key generated by the application.
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//! \retval ::LWAPI_INCOMPATIBLE_AUDIO_DRIVER
//!
//! \ingroup selwreaudioapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SelwreAudio_ComputeSessionKey(__in LwAPI_LPCWSTR endpointID, __out LwU8* sessionKey);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SelwreAudio_PollOOSDState
//
//! DESCRIPTION:    While audio stream is playing this API probes into audio driver for every few seconds to detect whether the stream is 'Out of Sync' (OOSD).
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!
//! \param [in]    endpointID                  Pointer to an endpoint ID string. The caller typically obtains this string from the IMMDevice::GetId method
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//! \retval ::LWAPI_STREAM_IS_OUT_OF_SYNC
//!           LWAPI_INCOMPATIBLE_AUDIO_DRIVER
//!
//! \ingroup selwreaudioapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SelwreAudio_PollOOSDState(__in LwAPI_LPCWSTR endpointID);






//! \ingroup gpuaudio
//! @{
typedef enum {
    LW_GPU_AUDIO_DE_LIST_TYPE_DEFAULT = 0, //!< Defaults to adapter
    LW_GPU_AUDIO_DE_LIST_TYPE_ADAPTER,
    LW_GPU_AUDIO_DE_LIST_TYPE_CONNECTOR,
} LW_AUDIO_PRIORITY_ENUM;

typedef struct
{
    LwU32  version;                 //!< Only element 0 must be properly set   
    LwU32  deviceEntry;             //!< The lower index in the array has higher priority
} LW_AUDIO_PRIORITY_ENTRY_V1;

typedef LW_AUDIO_PRIORITY_ENTRY_V1       LW_AUDIO_PRIORITY_ENTRY;
#define LW_AUDIO_PRIORITY_ENTRY_VER1     MAKE_LWAPI_VERSION(LW_AUDIO_PRIORITY_ENTRY_V1,1)
#define LW_AUDIO_PRIORITY_ENTRY_VER      LW_AUDIO_PRIORITY_ENTRY_VER1

//! @}



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GPU_GetAudioDeviceEntryPriorityList
//
//! \code
//! DESCRIPTION:     This API gets the current priority list for audio device entries (DE).
//!                  The first DE on the list has higher priority than the next.
//!                  The list can be from the adapter or specific connector.
//!                  Number of entries per connector may vary and may be less than
//!                  the adapter's number.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:     rootConnectorId(IN)    : The displayId of the connector
//!                                          when used with LW_GPU_AUDIO_DE_LIST_TYPE_ADAPTER, changes DE priority list of all connectors
//!                                          on the logical GPU where displayId is located.
//!                 type(IN)               : Indicates the desired operation: on adapter or on connector.
//!                 pDeviceEntries(IN/OUT) : Pointer to LW_AUDIO_PRIORITY_ENTRY struct; each entry represents a device entry
//1                                          On return, if *pNumEntries is not zero, this is populated with deviceEntry values.
//!                                          Storage space must be provided by the caller.
//!                 pNumEntries(IN/OUT)    : Number of pDeviceEntries (IN); number of pDeviceEntries that is valid.
//!                                          When *pNumEntries is zero, it returns only the count entries in *pNumEntries (OUT); in this case, pDeviceEntries may be NULL.
//!                                          When *pNumEntries is not zero, pDeviceEntries[] returns the DE values.
//!
//! RETURN STATUS:
//!                  LWAPI_OK                          - completed request
//!                  LWAPI_API_NOT_INTIALIZED          - LWAPI not initialized
//!                  LWAPI_ERROR                       - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT            - Invalid input parameter.
//!                  LWAPI_INCOMPATIBLE_STRUCT_VERSION - *pDeviceEntries version incompatible
//! \endcode
//! \ingroup gpuaudio
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetAudioDeviceEntryPriorityList(LwU32 rootConnectorId, LW_AUDIO_PRIORITY_ENUM type, LW_AUDIO_PRIORITY_ENTRY* pDeviceEntries, LwU32* pNumEntries);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_GPU_SetAudioDeviceEntryPriorityList
//
//! \code
//! DESCRIPTION:     This API changes the priority list for audio device entries (DE).
//!                  The first DE on the list has a higher priority than the next.
//!                  The list can be from the adapter or specific connector.
//!                  Number of entries per connector may vary and may be less than
//!                  the adapter's number.
//!                  When setting the adapter's list, the list on all audio-capable
//!                  connectors on the adapter are adjusted accordingly.
//!                  When setting a specific connector, only that connector's list
//!                  is updated.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:     rootConnectorId(IN)    : The displayId of the connector
//!                                          when used with LW_GPU_AUDIO_DE_LIST_TYPE_ADAPTER, changes DE priority list of all connectors
//!                                          on the logical gpu where displayId is located
//!                 type(IN)               : Indicates desired operation: on adapter or on connector.
//!                 pDeviceEntries(IN)     : Pointer to an LW_AUDIO_PRIORITY_ENTRY struct; each entry represents a device entry.
//!                                          Each entry must be deviceEntry value must be less than the value in *pNumEntries.
//!                 pNumEntries(IN)        : Number of pDeviceEntries (IN); number of pDeviceEntries that are valid.
//!
//! RETURN STATUS:
//!                  LWAPI_OK                          - completed request
//!                  LWAPI_API_NOT_INTIALIZED          - LWAPI not initialized
//!                  LWAPI_ERROR                       - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT            - Invalid input parameter.
//!                  LWAPI_INCOMPATIBLE_STRUCT_VERSION - *pDeviceEntries version incompatible
//! \endcode
//! \ingroup gpuaudio
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetAudioDeviceEntryPriorityList(LwU32 rootConnectorId, LW_AUDIO_PRIORITY_ENUM type, LW_AUDIO_PRIORITY_ENTRY* pDeviceEntries, LwU32* pNumEntries);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GPU_GetMaxAudioStreamCount
//
//
//! DESCRIPTION: This API retrieves the maximum number of audio streams supported per adapter and/or per connector.
//!              Returns zero on architecture that doesn't support audio streams.
//!
//! HOW TO USE:   1) To query the maximum number of audio streams supported per physicalGpu basis,                   \n
//!                  the input can be the displayId of any of the monitors connected to the physicalGpu.             
//!               2) To query the maximum number of audio streams supported per connector basis,                     \n
//!                  the input should be the the displayId of the root connector. Note that this will also return the count per GPU.
//!
//!               Note : This API returns the "Max" and not "Total" audio streams for a given GPU/connector.        \n    
//!                      1) e.g. if a connector has 4 audio capable monitors connected to it but can drive a max of 2 audio streams,
//!                              the return value would be 2 and not 4.                                             \n
//!                      2) Similarly, if a GPU has 2 audio capable connectors A and B; both have 3 audio capable monitors connected each; 
//!                         If A can drive a max of 4 audio streams and B a max of 2, the return value for this GPU would be 4 and not 4+2 nor 3+3.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    displayId                    displayId of the monitor connected to a GPU or displayId of a connector
//! \param [out]   pGpuAudioStreamsCount        Max number of audio streams for this GPU
//! \param [out]   pConnectorAudioStreamsCount  Max number of audio streams for this Connector
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with specific 
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpuaudio
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetMaxAudioStreamCount(__in LwU32 displayId, __out_opt LwU32 *pGpuAudioStreamsCount, __out_opt LwU32 *pConnectorAudioStreamsCount);


//! \ingroup gpuaudio
//! @{

#define LWAPI_MAX_AUDIO_STREAMS_PER_CONNECTOR   16

//! Input state type values for Get Audio Interface
#define LW_GET_AUDIO_STREAMS_STATE_TYPE_DEFAULT         LW_BIT(0) //!< the fallback device, recallwlated on each topology change/modeset. 
                                                                  //!< lwrrently defined as the lowest DPMST address that supports audio on an active video stream. 
                                                                  //!< there can only be one, and there must be one. used when automatically selecting a new preferred.
#define LW_GET_AUDIO_STREAMS_STATE_TYPE_PREFERRED       LW_BIT(1) //!< An audio device is considered preferred :-
                                                                  //!< An audio device which got selected by the user (or)
                                                                  //!< An audio device that is active for more than 30 sec automatically becomes preferred
                                                                  
#define LW_GET_AUDIO_STREAMS_STATE_TYPE_ENABLED         LW_BIT(2) //!< An audio device is considered enabled if it is audio capable, 
                                                                  //!< may or may not be allowed to export it's audio capabilities to the audio subsystem
                                                                  //!< If bit is not set then audio device is disabled means the device was disabled by the user
                                                                  
#define LW_GET_AUDIO_STREAMS_STATE_TYPE_ACTIVE          LW_BIT(3) //!< An audio device is considered active if it is lwrrently reported to the audio subsytem. 
                                                                  //!< A device has to be enabled in order to be active 
                                                                  //!< If bit is not set then audio device is inactive means the device is not reported to 
                                                                  //!< the audio subsystem

#define LW_GET_AUDIO_STREAMS_STATE_TYPE_MUTED           LW_BIT(4) //!< An audio device is considered muted if it is active but it's not playing audio 
                                                                 //!< If bit is not set then audio device is unmuted
                                                                 //!< Note :Mute/UnMute bit comes into the picture once STATE_TYPE_ACTIVE flag is set



typedef enum _LW_GET_AUDIO_DEVICE_TYPE
{
    LW_GET_AUDIO_ONLY_DEVICE                = 1,
    LW_GET_AUDIO_AND_VIDEO_DEVICE              
} LW_GET_AUDIO_DEVICE_TYPE;

typedef struct
{
    LW_GET_AUDIO_DEVICE_TYPE deviceType;    //!< contains info about device type either independent audio device or video + audio device
    LwU32 stateTypeFlags;                  //!< one or more of LW_GET_AUDIO_STREAMS_STATE_TYPE_* flags
    LwU32 audioStreamDisplayId;           //!< LwAPI Display Id of the DPMST/HDMI audio device
} LW_AUDIO_STREAMS;

typedef struct
 {
     LwU32  version;
     LwU32  audioStreamCount;       //!< Only "audioStreamCount" streams are valid in the below array and rest of the entries will be 0. Should be ignored.
     LW_AUDIO_STREAMS audioStreams[LWAPI_MAX_AUDIO_STREAMS_PER_CONNECTOR];
 } LW_GET_AUDIO_STREAMS_V1;

typedef LW_GET_AUDIO_STREAMS_V1           LW_GET_AUDIO_STREAMS;

#define LW_GET_AUDIO_STREAMS_VER          MAKE_LWAPI_VERSION(LW_GET_AUDIO_STREAMS_V1, 1)

//! @}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_GPU_GetAudioStreams
//
//
//! DESCRIPTION:  This API returns audio capable streams, per connector, which are a subset of audio-capable targets. 
//!               It includes disabled streams which can enabled by LwAPI_GPU_SetAudioStreams().
//! HOW TO USE: \n
//! For DPMST : \n
//!               1) The root display ID should be the display ID of a DPMST connector on a GPU.                 \n
//!               2) LwAPI_GPU_GetConnectedDisplayIds can be used to get the connected displayId's on a GPU.     \n
//!               3) If a DPMST connector is found, then that connector rootdisplayId can be used as input to get the audio streams.  \n
//! For HDMI :  \n
//!               1) LwAPI_GPU_GetConnectedDisplayIds can be used to get the connected displayId's on a GPU.     \n
//!               2) If any LW_MONITOR_CONN_TYPE is HDMI, then that displayId can be used as input to get the audio streams.          \n
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    rootDisplayId         This is the displayId of the DPMST/HDMI connector. 
//! \param [out]   pAudioStreamEntries   Pointer to a LW_GET_AUDIO_STREAMS structure.
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//!
//! \ingroup gpuaudio
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetAudioStreams(__in LwU32 rootDisplayId, __inout LW_GET_AUDIO_STREAMS *pAudioStreamEntries);


//! \ingroup gpuaudio
//! @{

//!< Input Enum values for Set Audio Interface
typedef enum _LW_SET_AUDIO_STREAMS_STATE_ENUM
{
    LW_SET_AUDIO_STREAMS_STATE_ENABLE                  = 1,
    LW_SET_AUDIO_STREAMS_STATE_PREFER                    ,
    LW_SET_AUDIO_STREAMS_STATE_DISABLE                   ,
    LW_SET_AUDIO_STREAMS_STATE_MUTE                      ,
    LW_SET_AUDIO_STREAMS_STATE_UNMUTE                    
} LW_SET_AUDIO_STREAMS_STATE_ENUM;



typedef struct
{
     LwU32  version;
     // IN
     LW_SET_AUDIO_STREAMS_STATE_ENUM type;  //!< [IN] Allows clients to Enable, Disable, Mute or Unmute the streams
     LwU32  rootDisplayId;           //!< [IN] displayId of the DPMST/HDMI connector
     LwU32  audioStreamCount;       //!< [IN] Only "audioStreamCount" streams are valid in the below array and rest of the entries will be 0. Should be ignored.
     LwU32  audioStreamDisplayIds[LWAPI_MAX_AUDIO_STREAMS_PER_CONNECTOR]; //!< [IN] Display Ids of the DPMST/HDMI audio devices
     // OUT
     LwU8   status[LWAPI_MAX_AUDIO_STREAMS_PER_CONNECTOR];              //!< [OUT] returns TRUE or FALSE
} LW_SET_AUDIO_STREAMS_V1;

typedef LW_SET_AUDIO_STREAMS_V1           LW_SET_AUDIO_STREAMS;

#define LW_SET_AUDIO_STREAMS_VER          MAKE_LWAPI_VERSION(LW_SET_AUDIO_STREAMS_V1, 1)


//! @}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_GPU_SetAudioStreams
//
//
//! DESCRIPTION:  This API activates audio streams requested by clients across GPUs.
//!
//! HOW TO USE: \n
//! For DPMST/HDMI:  \n
//!               1) LwAPI_GPU_GetAudioStreams can be used to fetch the audio capable streams                   
//!                     for each connector on which the audio streams need to be activated.      \n
//!          2) pAudioStreamEntries should be assigned an array of LW_SET_AUDIO_STREAMS structures         
//!                     the size of which should be number of connectors on which the audio streams need to be activated. \n
//!               3) For each element in the array, audioStreamDisplayIds should be populated with the displayIds of the target audio devices
//!                  and the audioStreamCount value be set accordingly.  \n
//!               4) Note that for HDMI case, audioStreamCount should always be set to one. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out] pAudioStreamEntries          audioStreamEntries requested by clients to activate
//! \param [in]     audioStreamEntriesCount      number of audioStream entries requested by clients to activate
//!
//! \return   This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes 
//!          with specific meaning for this API, they are listed below.
//!
//! \retval   LWAPI_SET_NOT_ALLOWED One of the passed in displayIds does not correspond to either a HDMI or DP connector. 
//! \retval   LWAPI_OK  The call is successful. However, the caller needs to check the individual status bits of each of the passed in entries if the intended action was successful.
//!    
//! \ingroup gpuaudio
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetAudioStreams(__inout_ecount(audioStreamEntriesCount) LW_SET_AUDIO_STREAMS *pAudioStreamEntries, __in LwU32 audioStreamEntriesCount);


//! \addtogroup drsapi
//! @{


// GPU Profile APIs

LW_DECLARE_HANDLE(LwDRSSessionHandle);
LW_DECLARE_HANDLE(LwDRSProfileHandle);

#define LWAPI_DRS_GLOBAL_PROFILE                             ((LwDRSProfileHandle) -1)

#define LWAPI_SETTING_MAX_VALUES                             100

typedef enum _LWDRS_SETTING_TYPE
{
     LWDRS_DWORD_TYPE,
     LWDRS_BINARY_TYPE,
     LWDRS_STRING_TYPE,
     LWDRS_WSTRING_TYPE
} LWDRS_SETTING_TYPE;

typedef enum _LWDRS_SETTING_LOCATION
{
     LWDRS_LWRRENT_PROFILE_LOCATION,
     LWDRS_GLOBAL_PROFILE_LOCATION,
     LWDRS_BASE_PROFILE_LOCATION,
     LWDRS_DEFAULT_PROFILE_LOCATION
} LWDRS_SETTING_LOCATION;


typedef struct _LWDRS_GPU_SUPPORT
{
    LwU32 vdchip    :  1;
    LwU32 lwdqro     :  1;
    LwU32 lws        :  1;
    LwU32 reserved4  :  1;
    LwU32 reserved5  :  1;
    LwU32 reserved6  :  1;
    LwU32 reserved7  :  1;
    LwU32 reserved8  :  1;
    LwU32 reserved9  :  1;
    LwU32 reserved10 :  1;
    LwU32 reserved11 :  1;
    LwU32 reserved12 :  1;
    LwU32 reserved13 :  1;
    LwU32 reserved14 :  1;
    LwU32 reserved15 :  1;
    LwU32 reserved16 :  1;
    LwU32 reserved17 :  1;
    LwU32 reserved18 :  1;
    LwU32 reserved19 :  1;
    LwU32 reserved20 :  1;
    LwU32 reserved21 :  1;
    LwU32 reserved22 :  1;
    LwU32 reserved23 :  1;
    LwU32 reserved24 :  1;
    LwU32 reserved25 :  1;
    LwU32 reserved26 :  1;
    LwU32 reserved27 :  1;
    LwU32 reserved28 :  1;
    LwU32 reserved29 :  1;
    LwU32 reserved30 :  1;
    LwU32 reserved31 :  1;
    LwU32 reserved32 :  1;
} LWDRS_GPU_SUPPORT;

//! Enum to decide on the datatype of setting value.
typedef struct _LWDRS_BINARY_SETTING 
{
     LwU32                valueLength;               //!< valueLength should always be in number of bytes.
     LwU8                 valueData[LWAPI_BINARY_DATA_MAX];
} LWDRS_BINARY_SETTING;

typedef struct _LWDRS_SETTING_VALUES
{
     LwU32                      version;                //!< Structure Version
     LwU32                      numSettingValues;       //!< Total number of values available in a setting.
     LWDRS_SETTING_TYPE         settingType;            //!< Type of setting value.  
     union                                              //!< Setting can hold either DWORD or Binary value or string. Not mixed types.
     {
         LwU32                      u32DefaultValue;    //!< Accessing default DWORD value of this setting.
         LWDRS_BINARY_SETTING       binaryDefaultValue; //!< Accessing default Binary value of this setting.
                                                        //!< Must be allocated by caller with valueLength specifying buffer size, or only valueLength will be filled in.
         LwAPI_UnicodeString        wszDefaultValue;    //!< Accessing default unicode string value of this setting.
     };
     union                                                //!< Setting values can be of either DWORD, Binary values or String type,
     {                                                    //!< NOT mixed types.
         LwU32                      u32Value;           //!< All possible DWORD values for a setting
         LWDRS_BINARY_SETTING       binaryValue;        //!< All possible Binary values for a setting
         LwAPI_UnicodeString        wszValue;           //!< Accessing current unicode string value of this setting.
     }settingValues[LWAPI_SETTING_MAX_VALUES];
} LWDRS_SETTING_VALUES;

//! Macro for constructing the version field of ::_LWDRS_SETTING_VALUES
#define LWDRS_SETTING_VALUES_VER    MAKE_LWAPI_VERSION(LWDRS_SETTING_VALUES,1)
     
typedef struct _LWDRS_SETTING
{
     LwU32                      version;                //!< Structure Version
     LwAPI_UnicodeString        settingName;            //!< String name of setting
     LwU32                      settingId;              //!< 32 bit setting Id
     LWDRS_SETTING_TYPE         settingType;            //!< Type of setting value.  
     LWDRS_SETTING_LOCATION     settingLocation;        //!< Describes where the value in LwrrentValue comes from. 
     LwU32                      isLwrrentPredefined;    //!< It is different than 0 if the lwrrentValue is a predefined Value, 
                                                        //!< 0 if the lwrrentValue is a user value. 
     LwU32                      isPredefinedValid;      //!< It is different than 0 if the PredefinedValue union contains a valid value. 
     union                                              //!< Setting can hold either DWORD or Binary value or string. Not mixed types.
     {
         LwU32                      u32PredefinedValue;    //!< Accessing default DWORD value of this setting.
         LWDRS_BINARY_SETTING       binaryPredefinedValue; //!< Accessing default Binary value of this setting.
                                                           //!< Must be allocated by caller with valueLength specifying buffer size, 
                                                           //!< or only valueLength will be filled in.
         LwAPI_UnicodeString        wszPredefinedValue;    //!< Accessing default unicode string value of this setting.
     };
     union                                              //!< Setting can hold either DWORD or Binary value or string. Not mixed types.
     {
         LwU32                      u32LwrrentValue;    //!< Accessing current DWORD value of this setting.
         LWDRS_BINARY_SETTING       binaryLwrrentValue; //!< Accessing current Binary value of this setting.
                                                        //!< Must be allocated by caller with valueLength specifying buffer size, 
                                                        //!< or only valueLength will be filled in.
         LwAPI_UnicodeString        wszLwrrentValue;    //!< Accessing current unicode string value of this setting.
     };                                                 
} LWDRS_SETTING;

//! Macro for constructing the version field of ::_LWDRS_SETTING
#define LWDRS_SETTING_VER        MAKE_LWAPI_VERSION(LWDRS_SETTING,1)

typedef struct _LWDRS_APPLICATION_V1
{
     LwU32                      version;            //!< Structure Version
     LwU32                      isPredefined;       //!< Is the application userdefined/predefined
     LwAPI_UnicodeString        appName;            //!< String name of the Application
     LwAPI_UnicodeString        userFriendlyName;   //!< UserFriendly name of the Application
     LwAPI_UnicodeString        launcher;           //!< Indicates the name (if any) of the launcher that starts the application  
} LWDRS_APPLICATION_V1;

typedef struct _LWDRS_APPLICATION_V2
{
     LwU32                      version;            //!< Structure Version
     LwU32                      isPredefined;       //!< Is the application userdefined/predefined
     LwAPI_UnicodeString        appName;            //!< String name of the Application
     LwAPI_UnicodeString        userFriendlyName;   //!< UserFriendly name of the Application
     LwAPI_UnicodeString        launcher;           //!< Indicates the name (if any) of the launcher that starts the Application
     LwAPI_UnicodeString        fileInFolder;       //!< Select this application only if this file is found.
                                                    //!< When specifying multiple files, separate them using the ':' character.
} LWDRS_APPLICATION_V2;

typedef struct _LWDRS_APPLICATION_V3
{
     LwU32                      version;            //!< Structure Version
     LwU32                      isPredefined;       //!< Is the application userdefined/predefined
     LwAPI_UnicodeString        appName;            //!< String name of the Application
     LwAPI_UnicodeString        userFriendlyName;   //!< UserFriendly name of the Application
     LwAPI_UnicodeString        launcher;           //!< Indicates the name (if any) of the launcher that starts the Application
     LwAPI_UnicodeString        fileInFolder;       //!< Select this application only if this file is found.
                                                    //!< When specifying multiple files, separate them using the ':' character.
     LwU32                      isMetro:1;          //!< Windows 8 style app
     LwU32                      reserved:31;        //!< Reserved. Should be 0.
} LWDRS_APPLICATION_V3;

#define LWDRS_APPLICATION_VER_V1        MAKE_LWAPI_VERSION(LWDRS_APPLICATION_V1,1)
#define LWDRS_APPLICATION_VER_V2        MAKE_LWAPI_VERSION(LWDRS_APPLICATION_V2,2)
#define LWDRS_APPLICATION_VER_V3        MAKE_LWAPI_VERSION(LWDRS_APPLICATION_V3,3)

typedef LWDRS_APPLICATION_V3 LWDRS_APPLICATION;
#define LWDRS_APPLICATION_VER LWDRS_APPLICATION_VER_V3

typedef struct _LWDRS_PROFILE
{
     LwU32                      version;            //!< Structure Version
     LwAPI_UnicodeString        profileName;        //!< String name of the Profile
     LWDRS_GPU_SUPPORT          gpuSupport;         //!< This read-only flag indicates the profile support on either
                                                    //!< Lwdqro, or Vdchip, or both.
     LwU32                      isPredefined;       //!< Is the Profile user-defined, or predefined
     LwU32                      numOfApps;          //!< Total number of applications that belong to this profile. Read-only
     LwU32                      numOfSettings;      //!< Total number of settings applied for this Profile. Read-only
} LWDRS_PROFILE;

//! Macro for constructing the version field of ::_LWDRS_PROFILE
#define LWDRS_PROFILE_VER        MAKE_LWAPI_VERSION(LWDRS_PROFILE,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_CreateSession
//
//!   DESCRIPTION: This API allocates memory and initializes the session.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [out]  *phSession Return pointer to the session handle.
//!                
//! \retval ::LWAPI_OK SUCCESS
//! \retval ::LWAPI_ERROR: For miscellaneous errors.
//
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_CreateSession(LwDRSSessionHandle *phSession);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_DestroySession
//
//!   DESCRIPTION: This API frees the allocation: cleanup of LwDrsSession.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in] hSession Input to the session handle.
//!                
//! \retval ::LWAPI_OK SUCCESS
//! \retval ::LWAPI_ERROR For miscellaneous errors.
//
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_DestroySession(LwDRSSessionHandle hSession);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_LoadSettings
//
//!   DESCRIPTION: This API loads and parses the settings data.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in] hSession  Input to the session handle.
//!                
//! \retval ::LWAPI_OK     SUCCESS
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_LoadSettings(LwDRSSessionHandle hSession);


///////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION NAME: LwAPI_DRS_LoadGoldSettings
//
//!   DESCRIPTION: This API loads and parses the settings data from the Gold DB.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   LwDRSSessionHandle  Input to the session handle.
//!
//! \retval ::LWAPI_OK      SUCCESS
//! \retval ::LWAPI_ERROR   For miscellaneous errors.
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_LoadGoldSettings(LwDRSSessionHandle hSession);

///////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION NAME: LwAPI_DRS_DecryptSession
//
//!   DESCRIPTION: This API will decrypt (only the encrypted settings) in the current
//!                Session. This is a private API, those settings are encrypted for
//!                competitive reasons. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   LwDRSSessionHandle  Input to the session handle.
//!
//! \retval ::LWAPI_OK                   SUCCESS
//! \retval ::LWAPI_ERROR                For miscellaneous errors.
//! \retval ::LWAPI_API_NOT_INTIALIZED   When LWAPI has not been initialized.
//! \retval ::LWAPI_ILWALID_ARGUMENT     When hSession is not valid.
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_DecryptSession(__in LwDRSSessionHandle hSession);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_SaveSettings
//
//!   DESCRIPTION: This API saves the settings data to the system.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in] hSession  Input to the session handle.
//!                
//! \retval ::LWAPI_OK    SUCCESS
//! \retval ::LWAPI_ERROR For miscellaneous errors.
//
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_SaveSettings(LwDRSSessionHandle hSession);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_LoadSettingsFromFile
//
//!   DESCRIPTION: This API loads settings from the given file path.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession Input to the session handle
//! \param [in]  fileName Binary File Name/Path
//!                
//! \retval ::LWAPI_OK     SUCCESS
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_LoadSettingsFromFile(LwDRSSessionHandle hSession, LwAPI_UnicodeString fileName);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_SaveSettingsToFile
//
//!   DESCRIPTION: This API saves settings to the given file path.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession  Input to the session handle.
//! \param [in]  fileName  Binary File Name/Path
//!                
//! \retval ::LWAPI_OK     SUCCESS
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_SaveSettingsToFile(LwDRSSessionHandle hSession, LwAPI_UnicodeString fileName);

//! @}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_SaveSettingsToPrdFile
//
//!   DESCRIPTION: This API saves settings to the given file path, in PRD file format.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param  hSession  Input to the session handle.
//! \param  fileName  Binary File Name/Path
//!                
//! \retval ::LWAPI_OK                    SUCCESS
//! \retval ::LWAPI_ILWALID_ARGUMENT      Invalid Session handle or Empty PRD file name
//! \retval ::LWAPI_API_NOT_INTIALIZED    LwAPI initialization failed
//! \retval ::LWAPI_ERROR                 For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_SaveSettingsToPrdFile(LwDRSSessionHandle hSession, LwAPI_UnicodeString fileName);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_LoadSettingsFromPrdFile
//
//!   DESCRIPTION: Ths API loads settings from the given file path, in PRD file format.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param  hSession  Input to the session handle.
//! \param  fileName  Binary File Name/Path
//!                
//! \retval ::LWAPI_OK                    SUCCESS
//! \retval ::LWAPI_ILWALID_ARGUMENT      Invalid Session handle or Empty PRD file name
//! \retval ::LWAPI_API_NOT_INTIALIZED    LwAPI initialization failed
//! \retval ::LWAPI_ERROR                 For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_LoadSettingsFromPrdFile(LwDRSSessionHandle hSession, LwAPI_UnicodeString fileName);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_CreateProfile
//
//!   DESCRIPTION: This API creates an empty profile.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession        Input to the session handle.
//! \param [in]  *pProfileInfo   Input pointer to LWDRS_PROFILE.
//! \param [in]  *phProfile      Returns pointer to profile handle.
//!                
//! \retval ::LWAPI_OK     SUCCESS
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_CreateProfile(LwDRSSessionHandle hSession, LWDRS_PROFILE *pProfileInfo, LwDRSProfileHandle *phProfile);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_DeleteProfile
//
//!   DESCRIPTION: This API deletes a profile or sets it back to a predefined value.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in] hSession  Input to the session handle.
//! \param [in] hProfile  Input profile handle.
//!                
//! \retval ::LWAPI_OK     SUCCESS if the profile is found
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_DeleteProfile(LwDRSSessionHandle hSession, LwDRSProfileHandle hProfile);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_SetLwrrentGlobalProfile
//
//!   DESCRIPTION: This API sets the current global profile in the driver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in] hSession                Input to the session handle.
//! \param [in] wszGlobalProfileName    Input current Global profile name.
//!               
//! \retval ::LWAPI_OK     SUCCESS
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_SetLwrrentGlobalProfile(LwDRSSessionHandle hSession, LwAPI_UnicodeString wszGlobalProfileName);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_GetLwrrentGlobalProfile
//
//!   DESCRIPTION: This API returns the handle to the current global profile.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hSession     Input to the session handle.
//! \param [out]  *phProfile   Returns current Global profile handle.
//!                
//! \retval ::LWAPI_OK     SUCCESS
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_GetLwrrentGlobalProfile(LwDRSSessionHandle hSession, LwDRSProfileHandle *phProfile);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_GetProfileInfo
//
//!   DESCRIPTION: This API gets information about the given profile. User needs to specify the name of the Profile.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession       Input to the session handle.
//! \param [in]  hProfile       Input profile handle.
//! \param [out] *pProfileInfo  Return the profile info.
//!                
//! \retval ::LWAPI_OK     SUCCESS
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_GetProfileInfo(LwDRSSessionHandle hSession, LwDRSProfileHandle hProfile, LWDRS_PROFILE *pProfileInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_SetProfileInfo
//
//!   DESCRIPTION: Specifies flags for a given profile. Lwrrently only the LWDRS_GPU_SUPPORT is
//!                used to update the profile. Neither the name, number of settings or applications
//!                or other profile information can be changed with this function. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession       Input to the session handle.
//! \param [in]  hProfile       Input profile handle.
//! \param [in]  *pProfileInfo  Input the new profile info.
//!                
//! \retval ::LWAPI_OK     SUCCESS
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_SetProfileInfo(LwDRSSessionHandle hSession, LwDRSProfileHandle hProfile, LWDRS_PROFILE *pProfileInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_FindProfileByName
//
//!   DESCRIPTION: This API finds a profile in the current session.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hSession      Input to the session handle.
//! \param [in]   profileName   Input profileName.
//! \param [out]  phProfile     Input profile handle.
//!                
//! \retval ::LWAPI_OK                SUCCESS if the profile is found
//! \retval ::LWAPI_PROFILE_NOT_FOUND if profile is not found
//! \retval ::LWAPI_ERROR             For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_FindProfileByName(LwDRSSessionHandle hSession, LwAPI_UnicodeString profileName, LwDRSProfileHandle* phProfile);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_EnumProfiles
//
//!   DESCRIPTION: This API enumerates through all the profiles in the session.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hSession        Input to the session handle.
//! \param [in]   index           Input the index for enumeration.
//! \param [out]  *phProfile      Returns profile handle.
//!                
//!   RETURN STATUS: LWAPI_OK: SUCCESS if the profile is found
//!                  LWAPI_ERROR: For miscellaneous errors.
//!                  LWAPI_END_ENUMERATION: index exceeds the total number of available Profiles in DB.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_EnumProfiles(LwDRSSessionHandle hSession, LwU32 index, LwDRSProfileHandle *phProfile);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_GetNumProfiles
//
//!   DESCRIPTION: This API obtains the number of profiles in the current session object.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession       Input to the session handle.
//! \param out]  *numProfiles   Returns count of profiles in the current hSession.
//!                
//! \retval ::LWAPI_OK                  SUCCESS
//! \retval ::LWAPI_API_NOT_INTIALIZED  Failed to initialize.
//! \retval ::LWAPI_ILWALID_ARGUMENT    Invalid Arguments.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_GetNumProfiles(LwDRSSessionHandle hSession, LwU32 *numProfiles);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_CreateApplication
//
//!   DESCRIPTION: This API adds an exelwtable name to a profile.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession       Input to the session handle.
//! \param [in]  hProfile       Input profile handle.
//! \param [in]  *pApplication  Input LWDRS_APPLICATION struct with the exelwtable name to be added.
//!                
//! \retval ::LWAPI_OK     SUCCESS
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_CreateApplication(LwDRSSessionHandle hSession, LwDRSProfileHandle  hProfile, LWDRS_APPLICATION *pApplication);
 

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_DeleteApplicationEx
//
//!   DESCRIPTION: This API removes an exelwtable from a profile.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hSession  - Input to the session handle.
//! \param [in]   hProfile  - Input profile handle.
//! \param [in]   *pApp     - Input all the information about the application to be removed.
//!
//! \retval ::LWAPI_OK  SUCCESS
//! \retval ::LWAPI_ERROR For miscellaneous errors.
//! \retval ::LWAPI_EXELWTABLE_PATH_IS_AMBIGUOUS If the path provided could refer to two different exelwtables,
//!                                              this error will be returned.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_DeleteApplicationEx(LwDRSSessionHandle hSession, LwDRSProfileHandle hProfile, LWDRS_APPLICATION *pApp);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_DeleteApplication
//
//!   DESCRIPTION: This API removes an exelwtable name from a profile.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSessionPARAMETERS   Input to the session handle.
//! \param [in]  hProfile             Input profile handle.
//! \param [in]  appName              Input the exelwtable name to be removed.
//!                
//! \retval ::LWAPI_OK     SUCCESS
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//! \retval ::LWAPI_EXELWTABLE_PATH_IS_AMBIGUOUS If the path provided could refer to two different exelwtables,
//!                                              this error will be returned
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_DeleteApplication(LwDRSSessionHandle hSession, LwDRSProfileHandle hProfile, LwAPI_UnicodeString appName);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_GetApplicationInfo
//
//!   DESCRIPTION: This API gets information about the given application.  The input application name
//!                must match exactly what the Profile has stored for the application. 
//!                This function is better used to retrieve application information from a previous
//!                enumeration.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hSession       Input to the session handle.
//! \param [in]   hProfile       Input profile handle.
//! \param [in]   appName        Input application name.
//! \param [out]  *pApplication  Returns LWDRS_APPLICATION struct with all the attributes.
//!                
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//! \retval ::LWAPI_EXELWTABLE_PATH_IS_AMBIGUOUS   The application name could not 
//                                                single out only one exelwtable.
//! \retval ::LWAPI_EXELWTABLE_NOT_FOUND           No application with that name is found on the profile.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_GetApplicationInfo(LwDRSSessionHandle hSession, LwDRSProfileHandle hProfile, LwAPI_UnicodeString appName, LWDRS_APPLICATION *pApplication);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_EnumApplications
//
//!   DESCRIPTION: This API enumerates all the applications in a given profile from the starting index to the maximum length.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      hSession         Input to the session handle.
//! \param [in]      hProfile         Input profile handle.
//! \param [in]      startIndex       Indicates starting index for enumeration.
//! \param [in,out]  *appCount        Input maximum length of the passed in arrays. Returns the actual length.
//! \param [out]     *pApplication    Returns LWDRS_APPLICATION struct with all the attributes.
//!                
//! \retval ::LWAPI_OK               SUCCESS
//! \retval ::LWAPI_ERROR            For miscellaneous errors.
//! \retval ::LWAPI_END_ENUMERATION  startIndex exceeds the total appCount.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_EnumApplications(LwDRSSessionHandle hSession, LwDRSProfileHandle hProfile, LwU32 startIndex, LwU32 *appCount, LWDRS_APPLICATION *pApplication);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_FindApplicationByName
//
//!   DESCRIPTION: This API searches the application and the associated profile for the given application name.
//!                If a fully qualified path is provided, this function will always return the profile
//!                the driver will apply upon running the application (on the path provided).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hSession       Input to the hSession handle
//! \param [in]   appName        Input appName. For best results, provide a fully qualified path of the type
//!                              c:/Folder1/Folder2/App.exe
//! \param [out]  *phProfile     Returns profile handle.
//! \param [out]  *pApplication  Returns LWDRS_APPLICATION struct pointer.
//!                
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                  If there are return error codes with specific meaning for this API, 
//!                  they are listed below:
//! \retval ::LWAPI_APPLICATION_NOT_FOUND          If App not found
//! \retval ::LWAPI_EXELWTABLE_PATH_IS_AMBIGUOUS   If the input appName was not fully qualified, this error might return in the case of multiple matches
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_FindApplicationByName(LwDRSSessionHandle hSession, LwAPI_UnicodeString appName, LwDRSProfileHandle *phProfile, LWDRS_APPLICATION *pApplication);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_SetSetting
//
//!   DESCRIPTION: This API adds/modifies a setting to a profile.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession     Input to the session handle.
//! \param [in]  hProfile     Input profile handle.
//! \param [in]   *pSetting   Input LWDRS_SETTING struct pointer.
//!                
//! \retval ::LWAPI_OK     SUCCESS
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_SetSetting(LwDRSSessionHandle hSession, LwDRSProfileHandle hProfile, LWDRS_SETTING *pSetting);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_GetSetting
//
//!   DESCRIPTION: This API gets information about the given setting.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hSession   Input to the session handle.
//! \param [in]   hProfile   Input profile handle.
//! \param [in]   settingId  Input settingId.
//! \param [out]  *pSetting  Returns all the setting info
//!                
//! \retval ::LWAPI_OK     SUCCESS
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_GetSetting(LwDRSSessionHandle hSession, LwDRSProfileHandle hProfile, LwU32 settingId, LWDRS_SETTING *pSetting);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_EnumSettings
//
//!   DESCRIPTION: This API enumerates all the settings of a given profile from startIndex to the maximum length.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      hSession        Input to the session handle.
//! \param [in]      hProfile        Input profile handle.
//! \param [in]      startIndex      Indicates starting index for enumeration.
//! \param [in,out]  *settingsCount  Input max length of the passed in arrays, Returns the actual length.
//! \param [out]     *pSetting       Returns all the settings info.
//!                
//! \retval ::LWAPI_OK              SUCCESS
//! \retval ::LWAPI_ERROR           For miscellaneous errors.
//! \retval ::LWAPI_END_ENUMERATION startIndex exceeds the total appCount.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_EnumSettings(LwDRSSessionHandle hSession, LwDRSProfileHandle hProfile, LwU32 startIndex, LwU32 *settingsCount, LWDRS_SETTING *pSetting);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_EnumAvailableSettingIds
//
//!   DESCRIPTION: This API enumerates all the Ids of all the settings recognized by LWAPI.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [out]    pSettingIds     User-provided array of length *pMaxCount that LWAPI will fill with IDs.
//! \param [in,out] pMaxCount       Input max length of the passed in array, Returns the actual length.
//!                
//! \retval ::LWAPI_OK     SUCCESS
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//!                  LWAPI_END_ENUMERATION: the provided pMaxCount is not enough to hold all settingIds.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_EnumAvailableSettingIds(LwU32 *pSettingIds, LwU32 *pMaxCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_EnumAvailableSettingValues
//
//!   DESCRIPTION: This API enumerates all available setting values for a given setting.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      settingId          Input settingId.
//! \param [in,out]  maxNumCount        Input max length of the passed in arrays, Returns the actual length.
//! \param [out]     *pSettingValues    Returns all available setting values and its count.
//!                
//! \retval ::LWAPI_OK     SUCCESS
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_EnumAvailableSettingValues(LwU32 settingId, LwU32 *pMaxNumValues, LWDRS_SETTING_VALUES *pSettingValues);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_GetSettingIdFromName
//
//!   DESCRIPTION: This API gets the binary ID of a setting given the setting name.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   settingName  Input Unicode settingName.
//! \param [out]  *pSettingId  Returns corresponding settingId.
//!                
//! \retval ::LWAPI_OK                 SUCCESS if the profile is found
//! \retval ::LWAPI_PROFILE_NOT_FOUND  if profile is not found
//! \retval ::LWAPI_SETTING_NOT_FOUND  if setting is not found
//! \retval ::LWAPI_ERROR              For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_GetSettingIdFromName(LwAPI_UnicodeString settingName, LwU32 *pSettingId);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_GetSettingNameFromId
//
//!   DESCRIPTION: This API gets the setting name given the binary ID.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  settingId        Input settingId.
//! \param [in]  *pSettingName    Returns corresponding Unicode settingName.
//!                
//! \retval ::LWAPI_OK                 SUCCESS if the profile is found
//! \retval ::LWAPI_PROFILE_NOT_FOUND  if profile is not found
//! \retval ::LWAPI_SETTING_NOT_FOUND  if setting is not found
//! \retval ::LWAPI_ERROR              For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_GetSettingNameFromId(LwU32 settingId, LwAPI_UnicodeString *pSettingName);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_DeleteProfileSetting
//
//!   DESCRIPTION: This API deletes a setting or sets it back to predefined value.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession            Input to the session handle.
//! \param [in]  hProfile            Input profile handle.
//! \param [in]  settingId           Input settingId to be deleted.
//!                
//! \retval ::LWAPI_OK     SUCCESS if the profile is found
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
/////////////////////////////////////////////////////////////////////////////// 
LWAPI_INTERFACE LwAPI_DRS_DeleteProfileSetting(LwDRSSessionHandle hSession, LwDRSProfileHandle hProfile, LwU32 settingId);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_RestoreAllDefaults
//
//!   DESCRIPTION: This API restores the whole system to predefined(default) values.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession  Input to the session handle.
//!                
//! \retval ::LWAPI_OK     SUCCESS if the profile is found
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
/////////////////////////////////////////////////////////////////////////////// 
LWAPI_INTERFACE LwAPI_DRS_RestoreAllDefaults(LwDRSSessionHandle hSession);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_RestoreDefaultSettings
//
//!   DESCRIPTION: This API either restores or ignores the given settings to predefined(default) values for 
//!                either a single profile(if valid hProfile is passed) or all profiles(if hProfile is NULL).
//!                Or restores all settings if pSettings = NULL and numSettings = 0.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession    Input to the session handle.
//! \param [in]  hProfile    Input profile handle. If hProfile is NULL, this API will restore/ignore settings for all profiles. 
//! \param [in]  pSettingIds Input list of settingIds to be ignored or restored. pSettings must be NULL if all settings need to be restored.
//! \param [in]  numSettings Input number of settings to be ignored or restored.  numSettings must be 0 if all settings need to be restored.
//! \param [in]  bIgnore     Input flag, if true, ignores else includes the given settings while restoring all profiles.
//!      
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, 
//!         they are listed below.          
//! \retval ::LWAPI_ILWALID_USER_PRIVILEGE
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_RestoreDefaultSettings(__in LwDRSSessionHandle hSession, __in LwDRSProfileHandle hProfile, 
                                                 __in_ecount_opt(numSettings) LwU32 *pSettingIds, 
                                                 __in LwU32 numSettings, __in LwU8 bIgnore);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_RestoreProfileDefault
//
//!   DESCRIPTION: This API restores the given profile to predefined(default) values.
//!                Any and all user specified modifications will be removed. 
//!                If the whole profile was set by the user, the profile will be removed.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession  Input to the session handle.
//! \param [in]  hProfile  Input profile handle.
//!                
//! \retval ::LWAPI_OK              SUCCESS if the profile is found
//! \retval ::LWAPI_ERROR           For miscellaneous errors.
//! \retval ::LWAPI_PROFILE_REMOVED SUCCESS, and the hProfile is no longer valid.
//! \retval ::LWAPI_ERROR           For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_RestoreProfileDefault(LwDRSSessionHandle hSession, LwDRSProfileHandle hProfile);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_RestoreProfileDefaultSetting
//
//!   DESCRIPTION: This API restores the given profile setting to predefined(default) values.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession  Input to the session handle.
//! \param [in]  hProfile  Input profile handle.
//! \param [in]  settingId Input settingId.
//!                
//! \retval ::LWAPI_OK     SUCCESS if the profile is found
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_RestoreProfileDefaultSetting(LwDRSSessionHandle hSession, LwDRSProfileHandle hProfile, LwU32 settingId);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_EnumUISettingValues
//
//!   DESCRIPTION: Enumerate all the settings of a given profile from startIndex to the max length, but only if the setting is User Visible.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      hSession        Input to the session handle.
//! \param [in]      hProfile        Input profile handle.
//! \param [in]      startIndex      Indicates starting index for enumeration.
//! \param [in,out]  *settingsCount  Input max length of the passed in arrays, Returns the actual length.
//! \param [out]     *pSetting       Returns all the settings info.
//!                
//! \retval ::LWAPI_OK               SUCCESS 
//! \retval ::LWAPI_ERROR            For miscellaneous errors.
//! \retval ::LWAPI_END_ENUMERATION  startIndex exceeds the total appCount.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_EnumUISettingValues(LwDRSSessionHandle hSession, LwDRSProfileHandle hProfile, LwU32 startIndex, LwU32 *settingsCount, LWDRS_SETTING *pSetting);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_GetDefaultGlobalProfile
//
//!   DESCRIPTION: This APi returns the handle to the default global profile.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hSession   Input to the session handle.
//! \param [out]  *phProfile Returns default Global profile handle.
//!                
//! \retval ::LWAPI_OK     SUCCESS if the profile is found
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_GetDefaultGlobalProfile(LwDRSSessionHandle hSession, LwDRSProfileHandle *phProfile);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_FindApplicationEx
//
//!   DESCRIPTION: This API searches the DRS db indicated by hSession trying to find an application
//!                as described in the in/out structure pApplication.
//!                If exactMatch is false, follows the same behavior as LwAPI_DRS_FindApplicationByName.
//!                  It will try to see which profile will get applied to an application as described by
//!                  pApplication.
//!                If exactMatch is true, then:
//!                  It will return only if there is an exact match, case insensitive. 
//!                  If FindFile is to be used, this field needs to be initialized.
//!                WARNING: the pApplication structure should be 'zero initialized' to guarantee that
//!                  all the strings it contains are either correct or empty. Lack of initialization can
//!                  result in garbage strings being considered input. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hSession       Input to the hSession handle
//! \param [in]   exactMatch     Boolean indicating whether an exact match is requested
//! \param [in,out]  *pApplication  LWDRS_APPLICATION struct describing the application to look for. If one is found,
//!                              this structure is filled with all information.
//! \param [out]  *phProfile     Returns profile handle.
//!                
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                  If there are return error codes with specific meaning for this API, 
//!                  they are listed below:
//! \retval ::LWAPI_APPLICATION_NOT_FOUND          If App not found
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_FindApplicationEx(__in LwDRSSessionHandle hSession, __in LwU32 exactMatch, __inout LWDRS_APPLICATION *pApplication, __out LwDRSProfileHandle *phProfile);




//! \ingroup drsapi
typedef struct _LWDRS_VERSION_INFORMATION
{
     LwU32                      version;            //!< Structure Version
     LwAPI_LongString           driverTitle;        //!< Is the driver-title string for the latest writer to the DB
     LwAPI_UnicodeString        systemDrsPath;      //!< Is the path to the system location of the DRS DB. SWAK wants this
     LwU32                      changelistNumber;   //!< The changelist when the latest writer to the DB was built
     LwU32                      drslibVersion;      //!< Version of the LwDrsLib, seldom changes
} LWDRS_VERSION_INFORMATION;

//! Macro for constructing the version field of LWDRS_VERSION_INFORMATION
#define LWDRS_VERSION_INFORMATION_VER        MAKE_LWAPI_VERSION(LWDRS_VERSION_INFORMATION,1)

///////////////////////////////////////////////////////////////////////////////
//  This API is meant FOR SWAK USE ONLY.  Please contact
//  sw-lwapi if you wish to use this interface.
//
// FUNCTION NAME: LwAPI_DRS_GetSystemDrsVersion
//
//! \code
//!   DESCRIPTION: Retrieves the version information for the system DRS files. 
//!                It includes the driverTitle (a string), the changelistNumber an a 
//!                lwdrslib version number.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!   PARAMETERS: LWDRS_VERSION_INFORMATION (OUT)  - Structure containing all the version information
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: argument is NULL
//!                LWAPI_OK: The DRS version information is retrieved.
//!                LWAPI_ERROR: For miscellaneous errors.
//!                LWAPI_NOT_SUPPORTED: If the system does not support DRS
//! \endcode
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_GetSystemDrsVersion(LWDRS_VERSION_INFORMATION *pVersionInformation);

///////////////////////////////////////////////////////////////////////////////
//  This API is meant FOR SWAK USE ONLY.  Please contact
//  sw-lwapi if you wish to use this interface.
//
// FUNCTION NAME: LwAPI_DRS_GetGoldDBDrsVersion
//
//! \code
//!   DESCRIPTION: Retrieves the version information for the Gold DB DRS. 
//!                It includes the driverTitle (a string), the changelistNumber an a 
//!                lwdrslib version number.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!   PARAMETERS: LWDRS_VERSION_INFORMATION (OUT)  - Structure containing all the version information
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: argument is NULL
//!                LWAPI_OK: The DRS version information is retrieved.
//!                LWAPI_ERROR: For miscellaneous errors.
//!                LWAPI_NOT_SUPPORTED: If the system does not support DRS
//! \endcode
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_GetGoldDBDrsVersion(LWDRS_VERSION_INFORMATION *pVersionInformation);


///////////////////////////////////////////////////////////////////////////////
//  This API is meant FOR SWAK USE ONLY.  Please contact
//  sw-lwapi if you wish to use this interface.
//
// FUNCTION NAME: LwAPI_DRS_GetGoldDBDrsVersionEx
//
//! \code
//!   DESCRIPTION: Retrieves the version information for the Gold DB DRS. 
//!                It includes the driverTitle (a string), the changelistNumber an a 
//!                lwdrslib version number.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!   PARAMETERS: LWDRS_VERSION_INFORMATION (OUT)  - Structure containing all the version information
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: argument is NULL
//!                LWAPI_OK: The DRS version information is retrieved.
//!                LWAPI_ERROR: For miscellaneous errors.
//!                LWAPI_NOT_SUPPORTED: If the system does not support DRS
//! \endcode
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_GetGoldDBDrsVersionEx(LWDRS_VERSION_INFORMATION *pVersionInformation);


//! \ingroup drsapi
typedef enum _LWDRS_VERSION_TARGET
{
     LWDRS_SYSTEM_DB = 0,
     LWDRS_GOLD_DB,
     LWDRS_UPDATE_DB
} LWDRS_VERSION_TARGET;


///////////////////////////////////////////////////////////////////////////////
//  This API is meant FOR SWAK USE ONLY.  Please contact
//  sw-lwapi if you wish to use this interface.
//
//! \code
//! FUNCTION NAME: LwAPI_DRS_GetDrsVersion
//!
//!   DESCRIPTION: Retrieves the version information for a given DRS DB.
//!                The supported DRS DBs are those of the LWDRS_VERSION_TARGET enum. 
//!                Lwrrently we support the System DB, the Gold DB and the Update DB.
//!                The update is delivered through the GFE deamon or upon user request.
//!                The version is returned on the LWDRS_VERSION_INFORMATION struct, 
//!                it includes the driverTitle (a string), the changelistNumber and a
//!                lwdrslib version number.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!   PARAMETERS: LWDRS_VERSION_TARGET (IN)        - Enum identifying which DRS DB to target
//!   PARAMETERS: LWDRS_VERSION_INFORMATION (OUT)  - Structure containing all the version information
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: argument is NULL, or the enum is not recognized
//!                LWAPI_OK: The DRS version information is retrieved.
//!                LWAPI_FILE_NOT_FOUND : There was no update found
//!                LWAPI_ERROR: For miscellaneous errors.
//!                LWAPI_NOT_SUPPORTED: If the system does not support DRS
//! \endcode
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_GetDrsVersion(LWDRS_VERSION_TARGET target, LWDRS_VERSION_INFORMATION *pVersionInformation);






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_SetBaseProfile
//
//! \code
//!   DESCRIPTION: Sets the current global profile in the driver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!   PARAMETERS: LwDRSSessionHandle(IN)  - Input to the session handle.
//!               LwAPI_UnicodeString(IN) - Input Base profile name.
//!                
//!   RETURN STATUS: LWAPI_OK: SUCCESS
//!                  LWAPI_ERROR: For miscellaneous errors.
//! \endcode
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_SetBaseProfile(LwDRSSessionHandle hSession, LwAPI_UnicodeString wszBaseProfileName);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_GetBaseProfile
//
//!   DESCRIPTION: Returns the handle to the current global profile.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession    Input to the session handle.
//! \param [in]  *phProfile   Returns Base profile handle.
//!                
//! \retval ::LWAPI_OK     SUCCESS if the profile is found
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_GetBaseProfile(LwDRSSessionHandle hSession, LwDRSProfileHandle *phProfile);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_SetSettingEx
//
//!   DESCRIPTION: This API adds/modifies a setting to a Profile, with the option to specify the setting as predefined
//!      Predefined settings are 'default' values for settings and profiles as specified by LWPU.
//!      We do not want these settings being set outside LWPU, but this functionality is needed in order
//!      to implement Coproc on a timely manner in R256. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hSession      Input to the session handle.
//! \param [in]   hProfile      Input profile handle.
//! \param [in]   *pSetting     Input LWDRS_SETTING struct pointer.
//! \param [in]   isPredefined  Input 'boolean' indicating whether the setting is Predefined or not
//! \param [in]   isOverride    Input 'boolean' indicating whether the setting is Override, meaning
//!                             that it has precedence over all ACE settings. Only valid for the Base Profile.
//!                
//! \retval ::LWAPI_OK     SUCCESS if the profile is found
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_SetSettingEx(LwDRSSessionHandle hSession, LwDRSProfileHandle hProfile, LWDRS_SETTING *pSetting, LwU32 isPredefined, LwU32 isOverride);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_GetSettingEx
//
//! \code
//!   DESCRIPTION: Get the information of the given setting, for internal use only
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!   PARAMETERS: LwDRSSessionHandle(IN)  - Input to the session handle.
//!               LwDRSProfileHandle(IN)  - Input profile handle.
//!               LwU32(IN)               - Input settingId.
//!               LWDRS_SETTING(OUT)      - Returns all the setting info
//!               LwU32(OUT)              - Returns whether the setting is Override or not.
//!                
//!   RETURN STATUS: LWAPI_OK: SUCCESS
//!                  LWAPI_ERROR: For miscellaneous errors.
//! \endcode
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_GetSettingEx(LwDRSSessionHandle hSession, LwDRSProfileHandle hProfile, LwU32 settingId, LWDRS_SETTING *pSetting, LwU32 *isOverride);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_CreateApplicationEx
//
//!   DESCRIPTION: This API adds an exelwtable name to a profile, allows to specify the exelwtable as predefined.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession       Input to the session handle.
//! \param [in]  hProfile       Input profile handle.
//! \param [in]  *pApplication  Input LWDRS_APPLICATION struct with the exelwtable name to be added.
//! \param [in]  isPredefined   Input 'boolean' indicating whether the exelwtable is Predefined or not
//!                
//! \retval ::LWAPI_OK     SUCCESS if the profile is found
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_CreateApplicationEx(LwDRSSessionHandle hSession, LwDRSProfileHandle  hProfile, LWDRS_APPLICATION *pApplication, LwU32 isPredefined);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DRS_CreateProfileEx
//
//!   DESCRIPTION: This API creates an empty profile, allowing the profile to be specified as predefined.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hSession          Input to the session handle.
//! \param [in]   *pProfileInfo     Input pointer to LWDRS_PROFILE.
//! \param [out]  *phProfile        Returns pointer to profile handle.
//! \param [in]   isPredefined      Input 'boolean' indicating whether the profile is Predefined or not
//!                
//! \retval ::LWAPI_OK     SUCCESS if the profile is found
//! \retval ::LWAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DRS_CreateProfileEx(LwDRSSessionHandle hSession, LWDRS_PROFILE *pProfileInfo, LwDRSProfileHandle *phProfile, LwU32 isPredefined);
////////////////////////////////////////DP MST SIMULATION APIs/////////////////////////////////////////////////////////////////////////////

//! \ingroup dpmst_fakemodel
typedef struct
{
    LwU32      version;                     //!< Structure version
    LwU32      deviceType;                  //!< 
    LwU32      upstreamPorts;               //!<
    LwU32      downstreamPorts;             //!<
    LwU32      validPorts;                  //!<
    LwU8       edidBuffer[128];             //!< Buffer to hold the edid
    LwU8       GUID[16];                    //!<

    LwU32      hasRevision12          : 1;  //!< 
    LwU32      hasAudio               : 1;  //!< 
    LwU32      reserved               : 30; //!< Should be set to ZERO
} LW_DPFAKE_DEVICE_INFO_V1; 

#define LW_DPFAKE_DEVICE_INFO_VER1   MAKE_LWAPI_VERSION(LW_DPFAKE_DEVICE_INFO_V1,1)
#define LW_DPFAKE_DEVICE_INFO_VER     LW_DPFAKE_DEVICE_INFO_VER1

typedef LW_DPFAKE_DEVICE_INFO_V1 LW_DPFAKE_DEVICE_INFO;

//! \ingroup dpmst_fakemodel
typedef struct
{
    LwU32                   version;                    //!< Structure version
    LwU32                   lanes;                      //!< 
    LwU64                   peakRate;                   //!<
    LwU64                   minRate;                    //!<
    LwU32                   lwrrentUsedPBN;             //!< 
    
    LwU32                   isEnhancedFraming   : 1;    //!< 
    LwU32                   isValid             : 1;    //!< 
    LwU32                   isInput             : 1;    //!< 
    LwU32                   isPlugged           : 1;    //!< 
    LwU32                   isMultiStream       : 1;    //!< 
    LwU32                   reserved            : 27;   //!< Should be set to ZERO
} LW_DPFAKE_DEVICE_CONNECTION_INFO_V1; 

#define LW_DPFAKE_DEVICE_CONNECTION_INFO_VER1   MAKE_LWAPI_VERSION(LW_DPFAKE_DEVICE_CONNECTION_INFO_V1,1)
#define LW_DPFAKE_DEVICE_CONNECTION_INFO_VER     LW_DPFAKE_DEVICE_CONNECTION_INFO_VER1

typedef LW_DPFAKE_DEVICE_CONNECTION_INFO_V1 LW_DPFAKE_DEVICE_CONNECTION_INFO;
   

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DPFAKE_CreateModel
//
//!   DESCRIPTION:  This API creates the DP MST fake model
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! 
//! \param [in]     displayId     The display ID of the DP1.2 connector.
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  LWAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DPFAKE_CreateModel(__in LwU32 displayId);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DPFAKE_DestroyModel
//
//!   DESCRIPTION:  This API destroys the DP MST fake model that was previously created using LwAPI_DPFAKE_CreateModel.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! 
//! \param [in]     displayId     The display ID of the DP1.2 connector.
//! \param [in]     afterMsecs    The delay in milli seconds after which the fake model will be teared down.
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  LWAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DPFAKE_DestroyModel(__in LwU32 displayId, __in LwU32 afterMsecs);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DPFAKE_StopSimulation
//
//!   DESCRIPTION:  This API stops simulation, and replaces FakeModel's AuxBus implementation by the 
//!   saved DD's AuxBus. Real devices can now be connected.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! 
//! \param [in]     displayId     The display ID of the DP1.2 connector.
//! \param [in]     afterMsecs    Delay (in milliseconds) after which to stop simulation
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  LWAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DPFAKE_StopSimulation(__in LwU32 displayId, __in LwU32 afterMsecs);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DPFAKE_StartSimulation
//
//!   DESCRIPTION:  This API saves and replaces DD's AuxBus implementation with DP FakeModel's implementation, 
//!   and starts simulation with deviceID as root (first branch).
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! 
//! \param [in]   displayId         The display ID of the DP1.2 connector.
//! \param [in]   fakeDeviceRootId  Fake device to be set as root (first branch)
//! \param [in]   afterMsecs        Delay (in milliseconds) after which to fire the start simulation event
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  LWAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DPFAKE_StartSimulation(__in LwU32 displayId, __in LwU32 fakeDeviceRootId, __in LwU32 afterMsecs);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DPFAKE_ConnectDevice
//
//!   DESCRIPTION:  This API connects two devices together on the specified ports.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   displayId             The display ID of the DP1.2 connector. 
//! \param [in]   fakeDeviceparentId    Device ID of parent device 
//! \param [in]   fakeDeviceParentPort  Port on parent device
//! \param [in]   fakeDeviceChildId     Device ID of child device
//! \param [in]   fakeDeviceChildPort   Port on child device
//! \param [in]   afterMsecs            Delay (in milliseconds) after which to fire the connect event
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  LWAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DPFAKE_ConnectDevice(__in LwU32 displayId, __in LwU32 fakeDeviceparentId, __in LwU32 fakeDeviceParentPort, __in LwU32 fakeDeviceChildId, __in LwU32 fakeDeviceChildPort, __in LwU32 afterMsecs);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DPFAKE_DisconnectDevice
//
//!   DESCRIPTION:  This API disconnects the specified port on the device with ID fakeDeviceID.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   displayId             The display ID of the DP1.2 connector. 
//! \param [in]   fakeDeviceId          Fake device ID
//! \param [in]   fakeDevicePort        Port to be disconnected
//! \param [in]   afterMsecs            Delay (in milliseconds) after which to fire the disconnect event
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  LWAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DPFAKE_DisconnectDevice(__in LwU32 displayId, __in LwU32 fakeDeviceId, __in LwU32 fakeDevicePort, __in LwU32 afterMsecs);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DPFAKE_NewFakeDevice
//
//!   DESCRIPTION:  This API adds a new device to the DP MST fake model that was previously created using LwAPI_DPFAKE_CreateModel.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   displayId             The display ID of the DP1.2 connector.
//! \param [in]   pDpFakeDeviceInfo     Pointer to LW_DPFAKE_DEVICE_INFO that defines the new device being added. 
//! \param [out]  pFakeDeviceId         Pointer to a LwU32 variable that receives the deviceId of the new fake device that was added
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  LWAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DPFAKE_NewFakeDevice(__in LwU32 displayId, __in LW_DPFAKE_DEVICE_INFO* pDpFakeDeviceInfo, __out LwU32* pFakeDeviceId);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DPFAKE_ChangeBandwidthOnLink
//
//!   DESCRIPTION:  This API changes the bandwidth on the link specified by the deviceID and port number to (newRate, newLanes).
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   displayId             The display ID of the DP1.2 connector.
//! \param [in]   fakeDeviceId          Id of the fake device
//! \param [in]   fakeDevicePort        Port number on the fake device
//! \param [in]   newRate               New Link Rate
//! \param [in]   newLanes              New Number of Lanes
//! \param [in]   isLinkSupportedChange Change LinkSupported (max link config)
//! \param [in]   afterMsecs            Delay (in milliseconds) after which to fire the change bandwidth event
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  LWAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DPFAKE_ChangeBandwidthOnLink(__in LwU32 displayId, __in LwU32 fakeDeviceId, __in LwU32 fakeDevicePort, __in LwU64 newRate, __in LwU32 newLanes, __in LwU8 isLinkSupportedChange, __in LwU32 afterMsecs);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DPFAKE_GetFakeDeviceProperties
//
//!   DESCRIPTION:  This API gets the properties of a fake device.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   displayId             The display ID of the DP1.2 connector.
//! \param [in]   fakeDeviceId          Id of the fake device
//! \param [out]  pDpFakeDeviceInfo     Pointer to LW_DPFAKE_DEVICE_INFO that returns the properties of the device. 
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  LWAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DPFAKE_GetFakeDeviceProperties(__in LwU32 displayId, __in LwU32 fakeDeviceId, __inout LW_DPFAKE_DEVICE_INFO* pDpFakeDeviceInfo);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DPFAKE_GetDeviceConnectionProperties
//
//!   DESCRIPTION:  This API gets the properties of a connection on a fake device.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   displayId                     The display ID of the DP1.2 connector.
//! \param [in]   fakeDeviceID                  Id of the fake device 
//! \param [in]   fakeDevicePort                The port number on the fake device 
//! \param [out]  pDpFakeDeviceConnectionInfo   Pointer to LW_DPFAKE_DEVICE_CONNECTION_INFO that returns the properties of the device. 
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  LWAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DPFAKE_GetDeviceConnectionProperties(__in LwU32 displayId, __in LwU32 fakeDeviceId, __in LwU32 fakeDevicePort, __inout LW_DPFAKE_DEVICE_CONNECTION_INFO* pDpFakeDeviceInfo);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_DPFAKE_CheckSimulationStatus
//
//!   DESCRIPTION:  This API checks on the connector specified by the display ID whether: 1. FakeModel has been built, and 2. Simulation is lwrrently running
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! 
//! \param [in]   displayId       The display ID of the DP1.2 connector.
//! \param [out]  fakeModelStatus   Status whether fake model has already been built on this connector
//! \param [out]  simulationStatus  Status whether simulation is running on this connector
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  LWAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DPFAKE_CheckSimulationStatus(__in LwU32 displayId, __out LwU32* fakeModelStatus, __out LwU32* simulationStatus);




//! \ingroup diagapi
typedef struct
{
    LwU32           version;                           //!< Structure version
    
    LwU32           TDRcount;                          //!< TDR count of the GPU
    LwU32           RCcount;                           //!< Robust Channel(RC) handler call count of the GPU
    LwU32           maxConselwtiveRC;                  //!< Max conselwtive RC count for the GPU
} LW_TDR_INFO_V1;

//! \ingroup diagapi
typedef LW_TDR_INFO_V1 LW_TDR_INFO;

//! \ingroup diagapi
#define LW_TDR_INFO_VER_1 MAKE_LWAPI_VERSION(LW_TDR_INFO_V1,1)

//! \ingroup diagapi
#define LW_TDR_INFO_VER   LW_TDR_INFO_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_GPU_GetTDRInfo
//
//! DESCRIPTION:    This function gets Timeout Detection and Recovery (TDR) information of the GPU, 
//!                 whose Physical GPU Handle is passed as input.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]          hPhysicalGpu     A handle identifying the GPU, whose TDR Information is needed.
//! \param [in,out]      tdrInfo          The pointer for the input structure containing the TDR info.
//!
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//!              Error codes specific to this API are described below.
//!              (None)
//! \ingroup diagapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetTDRInfo(__in LwPhysicalGpuHandle hPhysicalGpu ,__inout LW_TDR_INFO* tdrInfo);









//! \ingroup diagapi
typedef struct _LW_DISPLAYID_ENTRY_V1
{
    LwU32           version;

    LwU32           displayId;                  //!< this is a unique identifier for each device

     /*!
     * The following 3 fields are valid only when there is an associated monitor with this display Id. When the display Id table goes corrupt the 
     * following three fields will have incorrect values. In such cases the direct dump data below will help triage the issues
     */

    LwU32           targetId;                   //!< target Id of the monitor.
    LwU32           monitorHandlePosition;      //!< DD's internal monitor handle position value
    LwU32           deviceId;                   //!< RM display id associated with the monitor. For devices in MST this is dynamically allocated. 

    /*!
     * The following fields are dumped directly from the internal display id table
     */
    LwU32           ddmonitorHandlePosition;    //!< DD's internal monitor handle position value
    LwU32           rmDisplayID;                //!< valid only for for legacy displays. DP 1.2 MultiStream displays will have a dynamically allocated id which will be populated in the above devideId field.
    LwU32           rmRootDisplayID;            //!< DP 1.2 Root Node RM displayId (only used for DP 1.2 MultiStream displays)
    LW_DP_ADDRESS   rmAuxAddress;               //!< DP 1.2 Address (only used for DP 1.2 MultiStream displays)
    LwU32           ddClusterId;                //!< Id of the cluster which is represented by this display Id
} LW_DISPLAYID_ENTRY_V1;

//! \ingroup diagapi
typedef struct _LW_DISPLAYID_ENTRY_V2
{
    LwU32           version;

    LwU32           displayId;                  //!< this is a unique identifier for each device

    /*!
     * The following 3 fields are valid only when there is an associated monitor with this display Id. When the display Id table goes corrupt the 
     * following three fields will have incorrect values. In such cases the direct dump data below will help triage the issues
     */

    LwU32           targetId;                   //!< target Id of the monitor.
    LwU32           monitorHandlePosition;      //!< DD's internal monitor handle position value
    LwU32           deviceId;                   //!< RM display id associated with the monitor. For devices in MST this is dynamically allocated. 

    /*!
     * The following fields are dumped directly from the internal display id table
     */
    LwU32           ddmonitorHandlePosition;    //!< DD's internal monitor handle position value
    LwU32           rmDisplayID;                //!< valid only for for legacy displays. DP 1.2 MultiStream displays will have a dynamically allocated id which will be populated in the above devideId field.
    LwU32           rmRootDisplayID;            //!< DP 1.2 Root Node RM displayId (only used for DP 1.2 MultiStream displays)
    LW_DP_ADDRESS   rmAuxAddress;               //!< DP 1.2 Address (only used for DP 1.2 MultiStream displays)
    LwU32           ddClusterId;                //!< Id of the cluster which is represented by this display Id
    LwU32           auxHashCode;                //!< CRC24 of the aux address + rmOutputId combination
} LW_DISPLAYID_ENTRY_V2;

typedef LW_DISPLAYID_ENTRY_V2 LW_DISPLAYID_ENTRY;

//! \ingroup diagapi
//! Macro for constructing the version field of ::_LW_GPU_DISPLAYIDS
#define LW_DISPLAYID_ENTRY_VER1          MAKE_LWAPI_VERSION(LW_DISPLAYID_ENTRY_V1,1)
#define LW_DISPLAYID_ENTRY_VER2          MAKE_LWAPI_VERSION(LW_DISPLAYID_ENTRY_V2,2)
#define LW_DISPLAYID_ENTRY_VER           LW_DISPLAYID_ENTRY_VER2

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DIAG_DumpAllDisplayIds
//
//!   DESCRIPTION: This API dumps the contents of the internal display ID table
//!
//! HOW TO USE: 1. The first call should be made to get the all display ID count. To get the display ID count, send in \n
//!                  a) hPhysicalGpu    - a valid GPU handle(enumerated using LwAPI_EnumPhysicalGPUs()) as input,      \n
//!                  b) pDisplayIds     - NULL, as we just want to get the display ID count.                           \n 
//!                  c) pDisplayIdCount - a valid pointer to LwU32, whose value is set to ZERO.                        \n
//!                If all parameters are correct and this call is successful, this call will return the display ID's count. \n
//!             2. To get the display ID array, make the second call to LwAPI_GPU_GetAllDisplayIds() with              \n
//!                  a) hPhysicalGpu    - should be same value which was sent in first call,                           \n
//!                  b) pDisplayIds     - pointer to the display ID array allocated by caller based on display ID count,    \n 
//!                                       eg. malloc(sizeof(LW_DISPLAYID_ENTRY) * pDisplayIdCount).                     \n
//!                  c) pDisplayIdCount - a valid pointer to LwU32. This indicates for how many display IDs            \n
//!                                       the memory is allocated(pDisplayIds) by the caller.                          \n
//!                If all parameters are correct and this call is successful, this call will return the display ID array and actual
//!                display ID count (which was obtained in the first call to LwAPI_DIAG_DumpAllDisplayIds). If the input display ID count is
//!                less than the actual display ID count, it will overwrite the input and give the pDisplayIdCount as actual count and the
//!                API will return LWAPI_INSUFFICIENT_BUFFER.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     hPhysicalGpu         GPU selection.
//! \param [in,out] pDisplayIds          Pointer to an array of LW_DISPLAYID_ENTRY structure, each entry represents one displayID 
//!                                      and its attributes.
//! \param [in,out] pDisplayIdCount      As input, this parameter indicates the number of display's id's for which caller has 
//!                                      allocated the memory. As output, it will return the actual number of display IDs.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval  LWAPI_INSUFFICIENT_BUFFER  When the input buffer(pDisplayIds) is less than the actual number of display IDs, this API 
//!                                     will return LWAPI_INSUFFICIENT_BUFFER. 
//!
//! \ingroup diagapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DIAG_DumpAllDisplayIds(__in LwPhysicalGpuHandle hPhysicalGpu, __inout_ecount_part_opt(*pDisplayIdCount, *pDisplayIdCount) LW_DISPLAYID_ENTRY* pDisplayIds, __inout LwU32* pDisplayIdCount);







//! \ingroup diagapi
//! @{

typedef struct
{
    LwU32   version;                //!< Structure version
    LwU32   sensorIndex;            //!< Index of requested internal thermal sensor

    LwS32   hotspotOffset;          //!< Hotspot offset of the sensor.  Signed fixed-point value with 8 decimal bits.   

} LW_DIAG_THERMAL_SENSOR_INFO_V1;

typedef LW_DIAG_THERMAL_SENSOR_INFO_V1      LW_DIAG_THERMAL_SENSOR_INFO;

#define LW_DIAG_THERMAL_SENSOR_INFO_VER_1   MAKE_LWAPI_VERSION(LW_DIAG_THERMAL_SENSOR_INFO_V1,1)
#define LW_DIAG_THERMAL_SENSOR_INFO_VER     LW_DIAG_THERMAL_SENSOR_INFO_VER_1

//! @} 



///////////////////////////////////////////////////////////////////////////////
//! \code
//! FUNCTION NAME:   LwAPI_Diag_GetThermalSensorInfo
//!
//! DESCRIPTION:     Retrieves LWPU-private thermal sensor information.  Full
//!                      description of all-applicable characteristics of the 
//!                      thermal sensor.
//!
//!                      NOTE: This API lwrrently only returns the hotspot
//!                      offset.  We'll soon be expanding it to return all
//!                      thermal characteristics.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS :     pThermalSensorInfo(IN/OUT) - Pointer in which to return the hotspot
//!                      offset.  This is actually a fixed point value with 8 decimal bits.
//!
//! RETURN STATUS:
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_ILWALID_ARGUMENT - NULL pointer passed (pHotspotOffset)
//!    LWAPI_HANDLE_ILWALIDATED - handle passed has been ilwalidated (see user guide)
//!    LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    LWAPI_NOT_SUPPORTED - thermal sensor info call is not supported
//! \endcode
//! \ingroup diagapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Diag_GetThermalSensorInfo(LwPhysicalGpuHandle hPhysicalGpu, LW_DIAG_THERMAL_SENSOR_INFO *pThermalSensorInfo);

///////////////////////////////////////////////////////////////////////////////
//! \code
//! FUNCTION NAME: LwAPI_GPU_MapGpuTimestampToUsermode
//!
//! DESCRIPTION:   Maps the timestamp struct for the specified GPU.  This timestamp is from the GPU-internal
//!                timer which represents the number of nanoseconds since 00:00 GMT, January 1, 1970.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!         INPUT:  LwPhysicalGpuHandle hPhysicalGpu,  // Handle to the physical gpu
//!                 LwU32 bUnmap,                      // Set to true to unmap the timestamp
//!
//!        OUTPUT:  void** ppMappedTimestamp,          // The mapped memory.  Returns NULL if unmap is true.
//!                 LwU32* pStructSizeInBytes          // Size of the mapped struct.  Allows for client validation.
//! \endcode
//! \ingroup diagapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_MapGpuTimestampToUsermode(LwPhysicalGpuHandle hPhysicalGpu, LwU32 bUnmap, LwU64** ppMappedTimestamp, LwU32* pStructSizeInBytes);








/////////////////////////////////////////////////////////////////////////////////

 /*************** LWPU MOBILE SOFTWARE INSTRUMENTATION API ******************\
 * Instrumentation API provides an interface for the user to collect power,    *
 * performance statistics from the various sensor locations on the board.      *
 * Since each board (E415, E417,...) will have different measurement locations,*
 * the user first has to  query what is available. The  list of locations,     *
 * measurements and sample rates will be passed as part of the capture settings*
 * to open the session. When session was started the measurements are taken at *
 * sample rates specified, at all the locations and samples are in kernel.     *
 * After stop/ session timout, data collected is retrived and session is closed*
 * for reuse. Only one client and one session were supported.                  *
 * For more information see                                                    *
 *   https://engwiki/index.php/Mobile_Software_Instrumentation_API             *
 \*****************************************************************************/

/////////////////////////////////////////////////////////////////////////////////

    
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SwInstr_GetInterfaceRevision
//
//!   \fn LwAPI_SwInstr_GetInterfaceRevision(LW_SWINSTR_REVISION *pLwSwInstrRev)
//!   DESCRIPTION: This function returns the LWPU Interface revision in structure LW_SWINSTR_REVISION.
//!
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \retval ::LWAPI_ILWALID_ARGUMENT             
//!  \retval ::LWAPI_OK                          
//!  \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  
/////////////////////////////////////////////////////////////////////////////////

//! \ingroup instapi
//! Structure containing the interface revision - used in LwAPI_SwInstr_GetInterfaceRevision()
typedef struct
{
    LwU32  version;         //!< Structure version, constructed from the macro #LW_SWINSTR_REVISION_VER
    LwU8   revMin;        
    LwU8   revMaj;
    LwU8   verMin;
    LwU8   verMaj;
} LW_SWINSTR_REVISION;


//! \ingroup instapi
//! Macro for constructing the version field for LW_SWINSTR_REVISION.
#define LW_SWINSTR_REVISION_VER MAKE_LWAPI_VERSION(LW_SWINSTR_REVISION,1)


//! \ingroup instapi
LWAPI_INTERFACE LwAPI_SwInstr_GetInterfaceRevision(LW_SWINSTR_REVISION *pLwSwInstrRev);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SwInstr_GetSensorPoints
//
//!  \fn LwAPI_SwInstr_GetSensorPoints(LW_SWINSTR_SENSOR_POINTS *pLwSwInstrSensorPoints)
//!  DESCRIPTION: This function returns the sensor points for the board.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \retval ::LWAPI_ILWALID_ARGUMENT             
//!  \retval ::LWAPI_OK                          
//!  \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION 
/////////////////////////////////////////////////////////////////////////////


//! \addtogroup instapi
//! @{

//! Valid subsystems for sensor points - used in LW_SWINSTR_SENSOR_LOCATION
typedef enum _LW_SWINSTR_SENSOR_SUBSYSTEM
{    
    LW_SENSOR_SUBSYSTEM_CPU         = 0x01,
    LW_SENSOR_SUBSYSTEM_GPU         = 0x02,
    LW_SENSOR_SUBSYSTEM_CHIPSET     = 0x04,
    LW_SENSOR_SUBSYSTEM_MEMORY      = 0x08,
    LW_SENSOR_SUBSYSTEM_DISPLAY     = 0x10,
    LW_SENSOR_SUBSYSTEM_NETWORK     = 0x20,
    LW_SENSOR_SUBSYSTEM_PS          = 0x40,
    LW_SENSOR_SUBSYSTEM_SKIN        = 0x80,
    LW_SENSOR_SUBSYSTEM_ALL         = 0xFFFFFFFF,    
} LW_SWINSTR_SENSOR_SUBSYSTEM;


//! Valid sensor components - used in LW_SWINSTR_SENSOR_LOCATION
typedef enum _LW_SWINSTR_SENSOR_COMPONENT
{    
    LW_SENSOR_COMPONENT_CORE        = 0x01,
    LW_SENSOR_COMPONENT_MEMORY      = 0x02,
    LW_SENSOR_COMPONENT_BUS         = 0x04,
    LW_SENSOR_COMPONENT_PS          = 0x08,
    LW_SENSOR_COMPONENT_ALL         = 0xFFFFFFFF,
} LW_SWINSTR_SENSOR_COMPONENT;


//! Valid GPU subsystem/core partitions - used in LW_SWINSTR_SENSOR_LOCATION
typedef enum _LW_SWINSTR_SENSOR_GPU_CORE_PARTITION
{ 
    LW_SENSOR_PARTITION_GPU_FB         = 0x01,
    LW_SENSOR_PARTITION_GPU_RENDER     = 0x02,
    LW_SENSOR_PARTITION_GPU_HOST       = 0x04,
    LW_SENSOR_PARTITION_GPU_DISPLAY    = 0x08,
    LW_SENSOR_PARTITION_GPU_VIDEO      = 0x10,
    LW_SENSOR_PARTITION_GPU_ALL        = 0xFFFFFFFF,
} LW_SWINSTR_SENSOR_GPU_CORE_PARTITION;


//! Valid GPU subsystem/Local Memory component partitions - used in LW_SWINSTR_SENSOR_LOCATION
typedef enum _LW_SWINSTR_SENSOR_GFX_LM_PARTITION
{
    LW_SENSOR_PARTITION_GFX_LM_LOGIC    = 0x01,
    LW_SENSOR_PARTITION_GFX_LM_DATA     = 0x02,
    LW_SENSOR_PARTITION_GFX_LM_TOTAL    = 0xFFFFFFFF,
} LW_SWINSTR_SENSOR_GFX_LM_PARTITION;



//!  Valid GPU subsystem/Bus component partitions - used in LW_SWINSTR_SENSOR_LOCATION
typedef enum _LW_SWINSTR_SENSOR_GFX_BUS_PARTITION
{
    LW_SENSOR_PARTITION_GFX_BUS_PCIE    = 0x01,
    LW_SENSOR_PARTITION_GFX_BUS_MEMORY  = 0x02,
    LW_SENSOR_PARTITION_GFX_BUS_MIO     = 0x04,
    LW_SENSOR_PARTITION_GFX_BUS_TOTAL   = 0xFFFFFFFF,
} LW_SWINSTR_SENSOR_GFX_BUS_PARTITION;



//! Valid measurement types - used in LW_SWINSTR_SENSOR_POINT
typedef enum _LW_SWINSTR_MEASUREMENT_TYPE
{
    LW_SENSOR_MEASURE_UNKNOWN           = 0x00,
    LW_SENSOR_MEASURE_ALTRSVD           = 0x01,
    LW_SENSOR_MEASURE_UTIL              = 0x02,
    LW_SENSOR_MEASURE_PERF_STATE        = 0x04,
    LW_SENSOR_MEASURE_ABS_POWER         = 0x08,
    LW_SENSOR_MEASURE_TEMP              = 0x10,  
    LW_SENSOR_MEASURE_REL_POWER         = 0x20,
} LW_SWINSTR_MEASUREMENT_TYPE;



//! Defines the sensor location  - used in LW_SWINSTR_SENSOR_POINT
typedef struct
{
    LwU32 subSystem;          //!< Of type #LW_SWINSTR_SENSOR_SUBSYSTEM
    LwU32 component;          //!< Of type #LW_SWINSTR_SENSOR_COMPONENT
    LwU32 partition;          //!< Of type #LW_SWINSTR_SENSOR_GPU_CORE_PARTITION
                              //!< or #LW_SWINSTR_SENSOR_GFX_LM_PARTITION
                              //!< or #LW_SWINSTR_SENSOR_GFX_BUS_PARTITION
                              
    LwU32 instance;           //!< Specifies bitmask for GPUs to be used
} LW_SWINSTR_SENSOR_LOCATION;



//! Defines a sensor point - used in LW_SWINSTR_SENSOR_POINTS
typedef struct
{
    LW_SWINSTR_SENSOR_LOCATION sensorLocation;
    LwU32 measurementType;     //!< Of type #LW_SWINSTR_MEASUREMENT_TYPE
} LW_SWINSTR_SENSOR_POINT;




//! Maximum number of sensor points - see LW_SWINSTR_SENSOR_POINTS
#define LW_SWINSTR_MAX_SENSOR_POINTS                     (0x00000020)



//! Lists the sensor points for the board - used in LwAPI_SwInstr_GetSensorPoints()
typedef struct
{   LwU32 version;              //!< Structure version, constructed by macro #LW_SWINSTR_SENSOR_POINTS_VER
    LwU32 numPoints;            //!< The number of sensor points.
    LW_SWINSTR_SENSOR_POINT sensorPoints[LW_SWINSTR_MAX_SENSOR_POINTS];
} LW_SWINSTR_SENSOR_POINTS;



//! Macro for constructing the version field for LW_SWINSTR_SENSOR_POINTS 
#define LW_SWINSTR_SENSOR_POINTS_VER MAKE_LWAPI_VERSION(LW_SWINSTR_SENSOR_POINTS,1)

//! @}


//! \ingroup instapi

LWAPI_INTERFACE LwAPI_SwInstr_GetSensorPoints(LW_SWINSTR_SENSOR_POINTS *pLwSwInstrSensorPoints);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SwInstr_GetCapabilities
//
//!   \fn Instr_GetCapabilities(LW_SWINSTR_CAPTURE_CAPS *pLwSwInstrCapabilities)
//!   DESCRIPTION: This function returns the performance instrumentation engine information for
//!                the associated GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \retval ::LWAPI_ILWALID_ARGUMENT             
//!  \retval ::LWAPI_OK                          
//!  \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  
///////////////////////////////////////////////////////////////////////////////

//! \ingroup instapi
//! Performance instrumentation engine information - used in LwAPI_SwInstr_GetCapabilities()
typedef struct
{
    LwU32 version;       //!< Structure version, constructed by macro #LW_SWINSTR_CAPTURE_CAPS_VER
    struct
    {
        unsigned    bMovingAverage  : 1;    //!< Supports a Moving Average 
        unsigned    bMASampleWindow : 1;    //!< If a moving average sample window can be set
        unsigned    bMAWindowSamples: 1;    //!< If a moving average of measurements (samples or time) can be taken 
        unsigned    powerPosErr     : 7;    //!< Maximum positive deviation (%)
        unsigned    powerNegErr     : 7;    //!< Maximum negative deviation (%)
        unsigned    tempPosErr      : 7;    //!< Maximum positive deviation (%)
        unsigned    tempNegErr      : 7;    //!< Maximum negative deviation (%)
 
    } caps;
    LwU32 maxSamples;                //!< Buffers size limit, 0 = no limit
    LwU32 minMovingAverageWindow;    //!< Minimum moving average window (per bMAWindowSamples)
    LwU32 maxMovingAverageWindow;    //!< Maximum moving avergae window (per bMAWindowSamples) 
    LwU32 minSampleRate;            //!< Minimum sample rate in 0.001 Hz
    LwU32 maxPerfSampleRate;   //!< Maximum performance measurement sample rate
    LwU32 maxPowerSampleRate;  //!< Maximum power measurement sample rate
    LwU32 maxTempSampleRate;   //!< Maximum temperature measurement sample rate
    LwU32 maxUtilSampleRate;   //!< Maximum utility measurement sample rate
} LW_SWINSTR_CAPTURE_CAPS;


//! \ingroup instapi
//! Macro for constructing the version field for LW_SWINSTR_CAPTURE_CAPS. 
#define LW_SWINSTR_CAPTURE_CAPS_VER MAKE_LWAPI_VERSION(LW_SWINSTR_CAPTURE_CAPS,1)


//! \ingroup instapi
LWAPI_INTERFACE LwAPI_SwInstr_GetCapabilities(LW_SWINSTR_CAPTURE_CAPS *pLwSwInstrCapabilities);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SwInstr_OpenCaptureSession
//
//!   \fn LwAPI_SwInstr_OpenCaptureSession(LW_SWINSTR_CAPTURE_SETTINGS *pLwSwInstrCapSets)
//!   DESCRIPTION: This function initiates a capture session. Only one session can be 
//!                opened at a time. 
//!
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \retval ::LWAPI_ILWALID_ARGUMENT             
//!  \retval ::LWAPI_OK                          
//!  \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup instapi
//! Instrumentation capture settings - used by LwAPI_SwInstr_OpenCaptureSession().
typedef struct
{
    LwU32 version;              //!< Structure version, constructed by macro #LW_SWINSTR_CAPTURE_SETTINGS_VER
    LwU32 bufferSize;           //!< Size of the capture settings buffer
    LwU8  bCapturebyTime;       //!< True = byTime, else bycount
    LwU8  powerMode;            //!< True = power sample gives power, else voltage current
    LwU32 value;                //!< if byTime = True, value = total time in ms for capturing instrumentation data 
                                //!< else value = number of instrumentation data samples
    LwU32 powerSampleRate;      //!< Sample rate for capturing power data
    LwU32 perfSampleRate;       //!< Sample rate for capturing performance data
    LwU32 tempSampleRate;       //!< Sample rate for capturing temperature date    
    LwU32 utilSampleRate;       //!< Sample rate for capturing utility data
    LwU32 numPoints;            //!< Total number of sensor points for measuring data  
    LW_SWINSTR_SENSOR_POINT sensorPoints[LW_SWINSTR_MAX_SENSOR_POINTS]; 
}LW_SWINSTR_CAPTURE_SETTINGS;


//! \ingroup instapi
//! Macro for constructing the version field for LW_SWINSTR_CAPTURE_SETTINGS. 
#define LW_SWINSTR_CAPTURE_SETTINGS_VER MAKE_LWAPI_VERSION(LW_SWINSTR_CAPTURE_SETTINGS, 1)

//! \ingroup instapi

LWAPI_INTERFACE LwAPI_SwInstr_OpenCaptureSession(LW_SWINSTR_CAPTURE_SETTINGS *pLwSwInstrCapSets);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SwInstr_CloseCaptureSession
//
//!   DESCRIPTION: This function shuts down a capture session. A session must have been
//!                initiated with a call to LwAPI_SwInstr_OpenCaptureSession90.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \retval ::LWAPI_OK
//!  \retval ::LWAPI_ERROR
//!
//!  \ingroup instapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SwInstr_CloseCaptureSession();

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SwInstr_StartCaptureSession
//
//!   DESCRIPTION: This function starts the capture of software instrumentation data.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \retval ::LWAPI_OK
//!  \retval ::LWAPI_ERROR
//!
//!  \ingroup instapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SwInstr_StartCaptureSession();

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SwInstr_StopCaptureSession
//
//!   DESCRIPTION: This function stops the capture of software instrumentation data.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \retval ::LWAPI_OK
//!  \retval ::LWAPI_ERROR
//!
//!  \ingroup instapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SwInstr_StopCaptureSession();






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SwInstr_GetCaptureData
//
//!   \fn LwAPI_SwInstr_GetCaptureData(LW_SWINSTR_CAPTURE_BUFFER *pLwSwInstrCaptureData,
//!   DESCRIPTION: This function retrieves performance instrumentation data.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \retval ::LWAPI_ILWALID_ARGUMENT             
//!  \retval ::LWAPI_OK                          
//!  \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  
//
//////////////////////////////////////////////////////////////////////////////

//! \addtogroup instapi
//! @{


//! Performance states - used in LW_SWINSTR_SAMPLE
typedef struct
{
    LwU32 lwrrPerfState;     //!< Current performance state
    LwU32 totalPerfStates;   //!< Total performance states supported
} LW_SWINSTR_PERF_SAMPLE;


//! Voltage and current values - used in LW_SWINSTR_POWER_SAMPLE
typedef struct
{
    LwU16 voltage;           //!< Voltage value at the sensor location 
    LwU16 current;           //!< Current value at the sensor location 
} LW_SWINSTR_VOLTAGE_LWRRENT;


//! Power and timestamp when measurement was taken - used in LW_SWINSTR_SAMPLE 
typedef struct 
{
    union
    {
        LwU32 power;         //!< Power value at the sensor location 
        LW_SWINSTR_VOLTAGE_LWRRENT voltageLwrrent;
    } data;
    LwU64 timeStamp;         //!< Time at which measurement is taken
} LW_SWINSTR_POWER_SAMPLE;


//! Temperature and timestamp when measurement was taken - used in LW_SWINSTR_SAMPLE
typedef struct
{
    LwS32 temp;             //!< Temperature at sensor location
    LwU64 timeStamp;        //!< Time when measurement is taken
} LW_SWINSTR_TEMP_SAMPLE;


//! Utilization value and timestamp when measurement was taken - used in LW_SWINSTR_SAMPLE 
typedef struct
{
    LwU32 utilization;      //!< Utilization value at the sensor location
    LwU64 timeStamp;        //!< Time when measurement is taken
} LW_SWINSTR_UTIL_SAMPLE;


//! Sample buffer - used in LW_SWINSTR_CAPTURE_BUFFER
typedef struct
{
    LW_SWINSTR_SENSOR_POINT sensor;   //!< Specifies where the measurement is taken
    union
    {
        LW_SWINSTR_PERF_SAMPLE perfSample;
        LW_SWINSTR_POWER_SAMPLE powerSample;
        LW_SWINSTR_TEMP_SAMPLE tempSample;
        LW_SWINSTR_UTIL_SAMPLE utilSample;
    } sample;                         //!< Measured data 
} LW_SWINSTR_SAMPLE;


//! \ingroup instapi
//! Instrumentation sample capture buffer - used in LwAPI_SwInstr_GetCaptureData()
typedef struct
{
    LwU32 version;                   //!< Structure version constructed by macro #LW_SWINSTR_CAPTURE_BUFFER_VER  
    LwU32 numSamples;                //!< Number of samples collected
    LW_SWINSTR_SAMPLE *pSamples;     //!< Pointer to the sample buffer
} LW_SWINSTR_CAPTURE_BUFFER;


//! Macro for constructing the version field for LW_SWINSTR_CAPTURE_BUFFER
#define LW_SWINSTR_CAPTURE_BUFFER_VER MAKE_LWAPI_VERSION(LW_SWINSTR_CAPTURE_BUFFER,1)

//! @}

 
//! \ingroup instapi
LWAPI_INTERFACE LwAPI_SwInstr_GetCaptureData(LW_SWINSTR_CAPTURE_BUFFER *pLwSwInstrCaptureData,
                                             LwU32 *pSize);
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SwInstr_GetSnapshot
//
//!   \fn LwAPI_SwInstr_GetSnapshot(LW_SWINSTR_CAPTURE_SETTINGS *pCaptureSettings,
//!   DESCRIPTION: This function retrieves a snapshot of instrumentation data.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \retval ::LWAPI_ILWALID_ARGUMENT             
//!  \retval ::LWAPI_OK                          
//!  \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION  
//
//////////////////////////////////////////////////////////////////////////////


//! \ingroup instapi
//! Macro for constructing the version field for LW_SWINSTR_SNAPSHOT_DATA
#define LW_SWINSTR_SNAPSHOT_DATA_VER MAKE_LWAPI_VERSION(LW_SWINSTR_SNAPSHOT_DATA,1)


 
//! \ingroup instapi
LWAPI_INTERFACE LwAPI_SwInstr_GetSnapshot(LW_SWINSTR_CAPTURE_SETTINGS *pCaptureSettings,
                                          LW_SWINSTR_CAPTURE_BUFFER* pLwSwInstrSnapshotData,
                                          LwU32 *pSize);




//! \ingroup diagapi
//! @{

typedef enum _LW_SET_HYBIRD_DIAG_FUNCTION_ID
{
    LWAPI_SET_HYBRID_DIAG_FUNCTION_ACPI_EVAL_METHOD = 0,        //!< Submit ACPI Eval Input Buffer to ACPI
    LWAPI_SET_HYBRID_DIAG_FUNCTION_QUERY_CHILD_RELATIONS,       //!< Ouery ACPIID and ChilduIDs of GPU child devices

    // MUST BE THE LAST ONE!!!  Don't add any new ID after this!!!
    LWAPI_SET_HYBRID_DIAG_NUM_SUPPORTED_FUNCTIONS               //!< # of SET_HYBRID_DIAG functions exported to LWAPI
} LW_SET_HYBRID_DIAG_FUNCTION_ID;

typedef enum _LW_SET_HYBRID_DIAG_MODE_ID
{
    LWAPI_SET_HYBRID_DIAG_MODE_USE_IGPU = 0,           //!< Execute diag function on IGPU escape
    LWAPI_SET_HYBRID_DIAG_MODE_USE_DGPU,               //!< Execute diag function on DGPU escape
    LWAPI_SET_HYBRID_DIAG_MODE_USE_MVIGPU,             //!< Execute diag function on MVIGPU escape
    LWAPI_SET_HYBRID_DIAG_MODE_USE_MVDGPU,             //!< Execute diag function on MVDGPU escape

    // MUST BE THE LAST ONE!!!  Don't add any new ID after this!!!
    LWAPI_SET_HYBRID_DIAG_NUM_SUPPORTED_FUNCTION_MODES          //!< # of SET_HYBRID_DIAG function modes exported to LWAPI
} LW_SET_HYBRID_DIAG_MODE_ID;


#define LW_SET_HYBRID_DIAG_BLOCK_SIZE (64*1024)

typedef struct
{
    LwU32   version;                                    //!< structure version

    LwU32   ulAcpiID;                                   //!< ACPI ID associated with diag function
    LwU32    ulDGPU;                                    //!< DGPU ID asscoiated with diag function
    LW_SET_HYBRID_DIAG_MODE_ID    modeID;                 //!< Desired Hybrid Escape handler for diag function

    LwU32   bufferSize;
    LwU8    buffer[LW_SET_HYBRID_DIAG_BLOCK_SIZE];      //!< Buffer for diag data
} LW_SET_HYBRID_DIAG_BLOCK;

//! Macro for constructing the version field of ::LW_SET_HYBRID_DIAG_BLOCK
#define LW_SET_HYBRID_DIAG_BLOCK_VER MAKE_LWAPI_VERSION(LW_SET_HYBRID_DIAG_BLOCK,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Diag_SetHybridDiag
//
//! \code
//!   DESCRIPTION: Execute a Hybrid Diagnostic function
//!
//!    PARAMETERS: hPhysicalGpu(IN) - GPU selection.
//!                diagFunction(IN) - Hybird Set Diag Function ID.
//!                pDiagBLock(IN/OUT) - pointer to Hybird Set Diag Block
//!
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: hPhysicalGpu or pDiagBlock is null
//!                LWAPI_OK: *pDiagBlock is set
//!                LWAPI_INCOMPATIBLE_STRUCT_VERSION: LW_SET_HYBRID_DIAG_BLOCK version not compatible with driver
//!                LWAPI_LWIDIA_DEVICE_NOT_FOUND: no LWPU GPU driving a display was found
//!                LWAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!                LWAPI_ILWALID_HYBRID_MODE: hybrid mode required by LW_SET_HYBRID_DIAG_BLOCK modeID not available
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Diag_SetHybridDiag(LwPhysicalGpuHandle hPhysicalGpu, LW_SET_HYBRID_DIAG_FUNCTION_ID diagFunction, LW_SET_HYBRID_DIAG_BLOCK *pDiagBlock);

//! @}





//! \ingroup diagapi
//! @{

#define MAX_XCODE_INSTANCE 4

typedef struct _LW_XCODE_ENCODE_INFO
{
    LwU32          version;                        //!< (IN) version of struct
    LwU32          processId;                      //!< (IN/OUT) Process ID
    LwAPI_ShortString   szFramework;               //!< (IN/OUT) Dshow/Clib/MFT
    LwAPI_ShortString   szCodecType;               //!< (IN/OUT) codecType
    LwAPI_ShortString   szProfile;                 //!< (IN/OUT) profile
    LwAPI_ShortString   szPreset;                  //!< (IN/OUT) Preset type
    LwU32          level;                          //!< (IN/OUT) level
    LwAPI_ShortString   szFieldMode;               //!< (IN/OUT) progressive / interlaced
    LwU32          botFldFirst;                    //!< (IN/OUT) if interlaced, specify field order
    LwS32          width;                          //!< (IN/OUT) o/p width
    LwS32          height;                         //!< (IN/OUT) o/p height
    float          aspectRatio;                    //!< (IN/OUT) aspect ratio
    float          frameRate;                      //!< (IN/OUT) Frame rate in fps
    LwU32          bitRateAvg;                     //!< (IN/OUT) bitrate avg in bps
    LwU32          bitRatePeak;                    //!< (IN/OUT) bitrate peak in bps
    LwAPI_ShortString   vbrMode;                   //!< (IN/OUT) VBR/CBR
    LwU32          gpuOffloadLvl;                  //!< (IN/OUT) GPU offload level
    LwU8           bMultiGpu                   :1; //!< (IN/OUT) multi-gpu
    LwU8           reserved                    :7; //!< (IN/OUT) unused bits
    LwU32          totalDevMemUsed;                //!< (IN/OUT) total dev mem used for allocations in KB
} LW_XCODE_ENCODE_INFO_V1;

typedef LW_XCODE_ENCODE_INFO_V1 LW_XCODE_ENCODE_INFO;
#define LW_XCODE_ENCODE_INFO_VER1  MAKE_LWAPI_VERSION(LW_XCODE_ENCODE_INFO_V1,1)
#define LW_XCODE_ENCODE_INFO_VER   LW_XCODE_ENCODE_INFO_VER1


typedef struct _LW_XCODE_ENC_INSTANCE
{
    LwU32  version;
    LwU32  instCount;
    LW_XCODE_ENCODE_INFO encInfo[MAX_XCODE_INSTANCE];
} LW_XCODE_ENC_INSTANCE_V1;

typedef LW_XCODE_ENC_INSTANCE_V1 LW_XCODE_ENC_INSTANCE;
#define LW_XCODE_ENC_INSTANCE_VER1  MAKE_LWAPI_VERSION(LW_XCODE_ENC_INSTANCE_V1,1)
#define LW_XCODE_ENC_INSTANCE_VER   LW_XCODE_ENC_INSTANCE_VER1


typedef struct _LW_XCODE_DECODE_INFO
{
    LwU32          version;                        //!< (IN) version of struct
    LwU32          processId;                      //!< (IN/OUT) Process ID
    LwAPI_ShortString   szDecoderType;             //!< (IN/OUT) DXVA/LWCA HW encoder is in use
    LwU8           bMFTInterface               :1; //!< (IN/OUT) MFT /other interface
    LwU8           reserved                    :7; //!< (IN/OUT) unused bits
    LwAPI_ShortString   szCodecType;               //!< (IN/OUT) codecType
    LwU32          width;                          //!< (IN/OUT) i/p width
    LwU32          height;                         //!< (IN/OUT) i/p height
    LwU32          numDecSurf;                     //!< (IN/OUT) max Number of internal decoded surfaces
    LwAPI_ShortString   szDeinterlaceMode;         //!< (IN/OUT) progressive/interlaced then interlacing mode
    LwU32          outputFormat;                   //!< (IN/OUT) output decoded format (LW12)
    LwU32          targetWidth;                    //!< (IN/OUT) o/p width
    LwU32          targetHeight;                   //!< (IN/OUT) o/p height
    LwU32          numOutputSurf;                  //!< (IN/OUT) number of output surfaces mapped simultaneously
    LW_RECT        display_area;                   //!< (IN/OUT) rect
    LwU32          totalDevMemUsed;                //!< (IN/OUT) total device mem used for allocations in KB
} LW_XCODE_DECODE_INFO_V1;


typedef LW_XCODE_DECODE_INFO_V1 LW_XCODE_DECODE_INFO;
#define LW_XCODE_DECODE_INFO_VER1  MAKE_LWAPI_VERSION(LW_XCODE_DECODE_INFO_V1,1)
#define LW_XCODE_DECODE_INFO_VER   LW_XCODE_DECODE_INFO_VER1

typedef struct _LW_XCODE_DEC_INSTANCE
{
    LwU32  version;
    LwU32  instCount;
    LW_XCODE_DECODE_INFO decInfo[MAX_XCODE_INSTANCE];
} LW_XCODE_DEC_INSTANCE_V1;

typedef LW_XCODE_DEC_INSTANCE_V1 LW_XCODE_DEC_INSTANCE;
#define LW_XCODE_DEC_INSTANCE_VER1  MAKE_LWAPI_VERSION(LW_XCODE_DEC_INSTANCE_V1,1)
#define LW_XCODE_DEC_INSTANCE_VER   LW_XCODE_DEC_INSTANCE_VER1

typedef struct _LW_XCODE_LWAPIDMA_INFO
{
    LwU8  bUpdateFlag                     :1; //!< (IN) update/set flag
    LwU8  reserved                        :7; //!< (IN) unused bits
    LwU32 processId;                          //!< (IN/OUT) appId of app using LWAPI DMA
    LwU32 surfFormat;                         //!< (IN/OUT) surface format
    LW_RECT srcRect;                          //!< (IN/OUT) surface width
    LW_RECT destRect;                         //!< (IN/OUT) surface height
} LW_XCODE_LWAPIDMA_INFO;

typedef struct _LW_XCODE_LWAPIDMA_INSTANCE
{
    LwU32   version;
    LwU32   instCount;
    LW_XCODE_LWAPIDMA_INFO Info[MAX_XCODE_INSTANCE];
} LW_XCODE_LWAPIDMA_INSTANCE_V1;

typedef LW_XCODE_LWAPIDMA_INSTANCE_V1 LW_XCODE_LWAPIDMA_INSTANCE;
#define LW_XCODE_LWAPIDMA_INSTANCE_VER1  MAKE_LWAPI_VERSION(LW_XCODE_LWAPIDMA_INSTANCE_V1,1)
#define LW_XCODE_LWAPIDMA_INSTANCE_VER   LW_XCODE_LWAPIDMA_INSTANCE_VER1


typedef enum _LW_XCODE_QUERY_ID
{
    LW_XCODE_QUERY_ENCODE_INFO,
    LW_XCODE_QUERY_DECODE_INFO,
    LW_XCODE_QUERY_LWAPIDMA_INFO,
    LW_XCODE_QUERY_LAST
} LW_XCODE_QUERY_ID;

typedef struct _LW_XCODE_INFO
{
    LW_XCODE_QUERY_ID   queryID;            //!< (IN) query type
    LwU8                bFlag           :1; //!< (IN) Control flag = 1 for retrieving info
    LwU8                reserved        :7; //!< (IN) unused bits
    union
    {
        LW_XCODE_ENC_INSTANCE             EncodeInfo;
        LW_XCODE_DEC_INSTANCE             DecodeInfo;
        LW_XCODE_LWAPIDMA_INSTANCE        LwapiDMAInfo;
    };
} LW_XCODE_INFO;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Xcode_SetEncodeInfo
//
//! \code
//! DESCRIPTION:     This API is used to set encode information from encode modules into KMD
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      pEncodeInfo(IN)         - structure for passing encode information
//! RETURN STATUS:
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - invalid argument passed
//!                  LWAPI_API_NOT_INTIALIZED - lwapi not initialized
//!                  LWAPI_INCOMPATIBLE_STRUCT_VERSION - version does not match
//!                  LWAPI_LWIDIA_DEVICE_NOT_FOUND - Display Handle is default
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Xcode_SetEncodeInfo( LW_XCODE_ENCODE_INFO *pEncodeInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Xcode_SetDecodeInfo
//
//! \code
//! DESCRIPTION:     This API is used to set decode information from decode modules into KMD
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      pDecodeInfo(IN)        - structure for passing decode information
//! RETURN STATUS:
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - invalid argument passed
//!                  LWAPI_API_NOT_INTIALIZED - lwapi not initialized
//!                  LWAPI_INCOMPATIBLE_STRUCT_VERSION - version does not match
//!                  LWAPI_LWIDIA_DEVICE_NOT_FOUND - Display Handle is default
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Xcode_SetDecodeInfo(LW_XCODE_DECODE_INFO *pDecodeInfo);

//! @}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Xcode_GetEncodeInfo
//
//! \code
//! DESCRIPTION:     This API is used to retrieve encode information for swak
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      pEncodeInfo(OUT)        - structure for retrieving encode information per instance
//! RETURN STATUS:
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - invalid argument passed
//!                  LWAPI_API_NOT_INTIALIZED - lwapi not initialized
//!                  LWAPI_INCOMPATIBLE_STRUCT_VERSION - version does not match
//!                  LWAPI_LWIDIA_DEVICE_NOT_FOUND - Display Handle is default
//! \endcode
//! \ingroup diagapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Xcode_GetEncodeInfo(LW_XCODE_ENC_INSTANCE *pEncodeInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Xcode_GetDecodeInfo
//
//! \code
//! DESCRIPTION:     This API is used to retrieve decode information for swak
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      pDecodeInfo(OUT)        - structure for retrieving decode information per instance
//! RETURN STATUS:
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - invalid argument passed
//!                  LWAPI_API_NOT_INTIALIZED - lwapi not initialized
//!                  LWAPI_INCOMPATIBLE_STRUCT_VERSION - version does not match
//!                  LWAPI_LWIDIA_DEVICE_NOT_FOUND - Display Handle is default
//! \endcode
//! \ingroup diagapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Xcode_GetDecodeInfo(LW_XCODE_DEC_INSTANCE *pDecodeInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Xcode_GetLwapiDMAInfo
//
//! \code
//! DESCRIPTION:     This API is used to get lwapi DMA info for swak
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      pLwapiDMAInfo(OUT)      - structure for retrieving lwapi DMA info.
//! RETURN STATUS:
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - invalid argument passed
//!                  LWAPI_API_NOT_INTIALIZED - lwapi not initialized
//!                  LWAPI_INCOMPATIBLE_STRUCT_VERSION - version does not match
//!                  LWAPI_LWIDIA_DEVICE_NOT_FOUND - Display Handle is default
//! \endcode
//! \ingroup diagapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Xcode_GetLwapiDMAInfo(LW_XCODE_LWAPIDMA_INSTANCE *pLwapiDMAInfo);





//! \ingroup diagapi
//! @{

#define LWAPI_FB_ECC_PARTITION_COUNT 6

typedef enum LW_EDC_FLAGS
{
    LW_EDC_FLAGS_NONE                          = 0x00000000 ,
    LW_EDC_FLAGS_FB_EDC_MAX_DELTAS_FLAGS_RESET = 0x00000001 

} LW_EDC_FLAGS;


typedef struct
{
    LwU32           version;                                   //!< Structure version

    LwU32           maxDeltas[LWAPI_FB_ECC_PARTITION_COUNT];   //!<This output parameter stores LW_PFB_FBPA_CRC_ERROR_MAX_DELTA_VALUE per partition.
                                                               //!<Floor-swept partitions are compacted and extra partition data is set to 0.
    LwU32           crcTickValue;                              //!<This output parameter stores LW_PFB_FBPA_CRC_TICK_VALUE which is needed to callwlate the actual error rate

} LW_EDC_INFO_V1;

typedef LW_EDC_INFO_V1 LW_EDC_INFO;

#define LW_EDC_INFO_VER_1 MAKE_LWAPI_VERSION(LW_EDC_INFO_V1,1)

#define LW_EDC_INFO_VER   LW_EDC_INFO_VER_1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_DIAG_GetEDCInfo
//
//! DESCRIPTION:    This function returns the Error Detection Code Information. 
//!                 It is lwrrently used to query EDC max error deltas for each of the partitions on Frame buffer.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]         hPhysicalGpu                   - Physical Gpu Handle.
//!                                                   
//! \param [in]         flags                          - Additional flags 
//!
//! \param [in,out]     pEDCInfo                       - Pointer to the structure containing EDC info. 
//!
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//!              Error codes specific to this API are described below.
//!              (None)
//!\ingroup diagapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DIAG_GetEDCInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout  LW_EDC_INFO* pEDCInfo, __in LW_EDC_FLAGS flags);




//! \ingroup diagapi
//! @{

#define LW_DISP_CRC_BUFFER_SIZE                         (256)

typedef enum _LWAPI_DISP_CRC_POLL_COMMAND
{
    LWAPI_DISP_CRC_POLL_COMMAND_START,
    LWAPI_DISP_CRC_POLL_COMMAND_READ,
    LWAPI_DISP_CRC_POLL_COMMAND_STOP
} LWAPI_DISP_CRC_POLL_COMMAND;

typedef struct 
{
    LwU32   secs;
    LwU32   uSecs;
}LWAPI_DISP_CRC_TIME_STAMP;

typedef struct 
{
    LwU32 compCRC[LW_DISP_CRC_BUFFER_SIZE];
    LwU32 primeOutputCRC[LW_DISP_CRC_BUFFER_SIZE];
    LwU32 frameNumber[LW_DISP_CRC_BUFFER_SIZE];
    LWAPI_DISP_CRC_TIME_STAMP headTimeStamp;
}LWAPI_DISP_CRC_BUFFER;

typedef struct 
{
    LwU32 version;    // Structure version
    LWAPI_DISP_CRC_POLL_COMMAND command;
    LWAPI_DISP_CRC_BUFFER *pDispCrcBuffer;
    LwPhysicalGpuHandle hPhysicalGPU[LWAPI_MAX_PHYSICAL_GPUS];
    LwU32 validEntryCount[LWAPI_MAX_PHYSICAL_GPUS];
    LwU32 displayOutputId[LWAPI_MAX_PHYSICAL_GPUS];
    LwU32 validGpuCount;
} LWAPI_CONFIG_DISP_CRC_POLLING_PARAMS;

//! Macro for constructing the version field of  LWAPI_CONFIG_DISP_CRC_POLLING_PARAMS
#define LWAPI_CONFIG_DISP_CRC_POLLING_PARAMS_VER  MAKE_LWAPI_VERSION(LWAPI_CONFIG_DISP_CRC_POLLING_PARAMS,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_DIAG_ConfigDispCrcPolling
//
//! \code
//! PARAMETERS:    command              (IN)  - Option to start/read/stop CRCs collection.
//!           pDispCrcBuffer    (IN)  - Pointer to Buffer that gets filled with CRCs.
//!           hPhysicalGPU        (IN)  - Physical GPU handle array of interest.                  
//!                validEntryCount    (IN)  - Array that gets filled with count of valid CRCs.
//!                displayOutputId      (IN)  - outputDisplay Ids on which CRCs should be collected. 
//!           validGpuCount        (IN)  - Count of valid GPU handles filled in hPhysicalGPU[].
//!        
//! SUPPORTED OS:  Windows Vista and higher
//!
//! DESCRIPTION:   Pass allowed inputs commands with the list of GPU handles of interst,
//!                to start/stop CRC collection, as well as to read the CRC buffers.  
//!                Once started, till stop is called, frequent read commands should be called to 
//!                avoid buffer overflows.
//!
//! RETURN STATUS: 
//!                LWAPI_OK                  - completed request
//!                LWAPI_API_NOT_INITIALIZED - lwapi not initialized
//!                LWAPI_ERROR               - miscellaneous error oclwrred
//!                LWAPI_ILWALID_ARGUMENT    - no suitable pixel clock was found
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_DIAG_ConfigDispCrcPolling(LWAPI_CONFIG_DISP_CRC_POLLING_PARAMS *pDispCrcConfigParams);

//! @}



/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_Diag_Escape
//
//!   DESCRIPTION: This API sends an escape to the specified GPU. This is for new feature 
//!                developement only, and should not be used, even internally, 
//!                for any supported tools like SWAK. This allows DD to test 
//!                escape calls directly.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     hPhysicalGpu  - Physical GPU handle, or LWIDIA_DEFAULT_HANDLE
//! \param [in]     escapeId      - Escape ID for escape initialization
//! \param [in,out] pData         - Buffer to pass down via escape
//! \param [in]     dataSize      - Size of pData
//!
//! \retval ::LWAPI_OK  Escape call succeeded.
//! \retval ::LWAPI_ERROR  Escape call failed.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND No LWPU device could be found.
//!
//! \ingroup diagapi
//////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Diag_Escape(LwPhysicalGpuHandle hPhysicalGpu, LwU32 escapeId, void* pData, LwU32 dataSize);

/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_Diag_LwRmAllocRoot
//
//!   DESCRIPTION: This API makes an LwRmAllocRoot call to the RM directly. This is for
//!                new feature development only, and should not be used, even
//!                internally, for any supported tools like SWAK. This allows RM
//!                to test RM features without DD or LwAPI implementations.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!

//! \param [out]  phClient   Handle to the client returned by LwRmAllocRoot
//!
//! \retval ::LWAPI_OK   RmAllocRoot call succeeded.
//! \retval ::LWAPI_ERROR  RmAllocRoot call failed.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND  No LWPU device could be found.
//!
//! \ingroup diagapi
//////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Diag_LwRmAllocRoot(LwU32* phClient);


/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_Diag_LwRmAlloc
//
//!   DESCRIPTION: This API makes an LwRmAlloc call to the RM directly. This is for
//!                new feature development only, and should not be used, even
//!                internally, for any supported tools like SWAK. This allows RM
//!                to test RM features without DD or LwAPI implementations.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      hClient      - See documentation for LwRmAlloc
//! \param [in]      hParent      - See documentation for LwRmAlloc
//! \param [in]      hObject      - See documentation for LwRmAlloc
//! \param [in]      hClass       - See documentation for LwRmAlloc
//! \param [in,out]  pAllocParams - See documentation for LwRmAlloc
//! \param [in]      allocParamSize  - Size of buffer pointed to by pAllocParams
//!
//! \retval ::LWAPI_OK RmAlloc call succeeded.
//! \retval ::LWAPI_ERROR RmAlloc call failed.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND No LWPU device could be found.
//!
//! \ingroup diagapi
//////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Diag_LwRmAlloc(LwU32 hClient, LwU32 hParent, LwU32 hObject, LwU32 hClass, void* pAllocParams, LwU32 allocParamSize);


/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_Diag_LwRmControl
//
//!   DESCRIPTION: Makes an LwRmControl call to the RM directly. This is for
//!                new feature development only, and should not be used, even
//!                internally, for any supported tools like SWAK. This allows RM
//!                to test RM features without DD or LwAPI implementations.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      hClient  - See documentation for LwRmControl
//! \param [in]      hObject  - See documentation for LwRmControl
//! \param [in]      cmd      - See documentation for LwRmControl
//! \param [in,out]  pParams  - See documentation for LwRmControl
//! \param [in]      paramsSize  - Size of buffer pointed to by pParams
//!
//! \retval ::LWAPI_OK RmControl call succeeded.
//! \retval ::LWAPI_ERROR RmControl call failed.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND No LWPU device could be found.
//!
//! \ingroup diagapi
//////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Diag_LwRmControl(LwU32 hClient, LwU32 hObject, LwU32 cmd, void *pParams, LwU32 paramsSize);


/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_Diag_LwRmFree
//
//!   DESCRIPTION: This API makes an LwRmFree call to the RM directly. This is for
//!                new feature development only, and should not be used, even
//!                internally, for any supported tools like SWAK. This allows RM
//!                to test RM features without DD or LwAPI implementations.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hClient  - See documentation for LwRmFree
//! \param [in]   hParent  - See documentation for LwRmFree
//! \param [in]   hObject  - See documentation for LwRmFree
//!
//! \retval ::LWAPI_OK: RmFree call succeeded.
//! \retval ::LWAPI_ERROR: RmAlloc call failed.
//! \retval ::LWAPI_LWIDIA_DEVICE_NOT_FOUND: No LWPU device could be found.
//!
//! \ingroup diagapi
//////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Diag_LwRmFree(LwU32 hClient, LwU32 hParent, LwU32 hObject);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_ToggleICafeFrameTag
//
//!   DESCRIPTION: Toggle frame tagging for ICafe
//!
//! SUPPORTED OS:  Windows XP
//!
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_ToggleICafeFrameTag();

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_ToggleICafeStatsDump
//
//!   DESCRIPTION: Toggle dumping of frame statistics for ICafe
//!
//! SUPPORTED OS:  Windows XP
//!
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_ToggleICafeStatsDump();

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_ToggleICafeImageDump
//
//!   DESCRIPTION: Toggle dumping of image data for ICafe
//!
//! SUPPORTED OS:  Windows XP
//!
//!
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_ToggleICafeImageDump();

//! \ingroup diagapi

#define MAX_PEX_COUNTER_TYPES 26

// PEX counter flags to manipulate the pexCounterMask
#define LWAPI_PEX_COUNTER_TYPE                           0x00000000
#define LWAPI_PEX_COUNTER_RECEIVER_ERRORS                0x00000001
#define LWAPI_PEX_COUNTER_REPLAY_COUNT                   0x00000002
#define LWAPI_PEX_COUNTER_REPLAY_ROLLOVER_COUNT          0x00000004 
#define LWAPI_PEX_COUNTER_BAD_DLLP_COUNT                 0x00000008
#define LWAPI_PEX_COUNTER_BAD_TLP_COUNT                  0x00000010
#define LWAPI_PEX_COUNTER_8B10B_ERRORS_COUNT             0x00000020
#define LWAPI_PEX_COUNTER_SYNC_HEADER_ERRORS_COUNT       0x00000040
#define LWAPI_PEX_COUNTER_LCRC_ERRORS_COUNT              0x00000080
#define LWAPI_PEX_COUNTER_FAILED_L0S_EXITS_COUNT         0x00000100
#define LWAPI_PEX_COUNTER_NAKS_SENT_COUNT                0x00000200
#define LWAPI_PEX_COUNTER_NAKS_RCVD_COUNT                0x00000400
#define LWAPI_PEX_COUNTER_LANE_ERRORS                    0x00000800
#define LWAPI_PEX_COUNTER_L1_TO_RECOVERY_COUNT           0x00001000
#define LWAPI_PEX_COUNTER_L0_TO_RECOVERY_COUNT           0x00002000
#define LWAPI_PEX_COUNTER_RECOVERY_COUNT                 0x00004000
#define LWAPI_PEX_COUNTER_CHIPSET_XMIT_L0S_ENTRY_COUNT   0x00008000
#define LWAPI_PEX_COUNTER_GPU_XMIT_L0S_ENTRY_COUNT       0x00010000
#define LWAPI_PEX_COUNTER_L1_ENTRY_COUNT                 0x00020000
#define LWAPI_PEX_COUNTER_L1P_ENTRY_COUNT                0x00040000
#define LWAPI_PEX_COUNTER_DEEP_L1_ENTRY_COUNT            0x00080000
#define LWAPI_PEX_COUNTER_ASLM_COUNT                     0x00100000
#define LWAPI_PEX_COUNTER_TOTAL_CORR_ERROR_COUNT         0x00200000
#define LWAPI_PEX_COUNTER_CORR_ERROR_COUNT               0x00400000
#define LWAPI_PEX_COUNTER_NON_FATAL_ERROR_COUNT          0x00800000
#define LWAPI_PEX_COUNTER_FATAL_ERROR_COUNT              0x01000000
#define LWAPI_PEX_COUNTER_UNSUPP_REQ_COUNT               0x02000000


typedef struct _LW_PEX_COUNTER_INFO_V1
{
    LwU32  version;
       
    LwU32  pexCounterMask;                      //!< Mask to define which counter values to fetch
    
    LwU32  pexTotalCorrectableErrors;           //!< This parameter gives the total correctable errors which includes
                                                //! LW_XVE_ERROR_COUNTER1 plus LCRC Errors, 8B10B Errors, NAKS and Failed L0s.
    
    LwU16  pexCorrectableErrors;                //!< This parameter only includes LW_XVE_ERROR_COUNTER1 value.

    LwU8   pexTotalNonFatalErrors;              //!< This parameter returns total Non-Fatal Errors which may or may not
                                                //! include Correctable Errors.

    LwU8   pexTotalFatalErrors;                 //!< This parameter returns Total Fatal Errors.

    LwU8   pexTotalUnsupportedReqs;             //!< This parameter returns Total Unsupported Requests.
    
    LwU16  pexCounters[MAX_PEX_COUNTER_TYPES];  //!< This array contains the error counts for each error type as requested from
                                                //! the pexCounterMask. The array indices correspond to the mask bits one-to-one.
    
}LW_PEX_COUNTER_INFO_V1;

//! Structure Versioning
typedef LW_PEX_COUNTER_INFO_V1          LW_PEX_COUNTER_INFO;
#define LWAPI_PEX_COUNTER_INFO_VER1     LWAPI_PEX_COUNTER_INFO_VER
#define LWAPI_PEX_COUNTER_INFO_VER      MAKE_LWAPI_VERSION(LW_PEX_COUNTER_INFO,1)

/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_GetPEXCounters
//
//!   DESCRIPTION: This API gets the current values for PEX counters as specified
//!                in the pexCounterMask mask. This API is supported only on Kepler+
//!                cards.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     hPhysicalGpuHandle  - GPU handle of which PEX counter values are required
//! \param [in/out] info                - Structure which contains the PEX counters array and its statistics.
//!
//! \return : This API can return any of the error codes enumerated in #LwAPI_Status. 
//!           If there are return error codes with specific meaning for this API, they are listed below
//!
//! \ingroup diagapi
//////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Diag_GetPexCounters(__in LwPhysicalGpuHandle hPhysicalGpuHandle, __inout LW_PEX_COUNTER_INFO* info);

/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_ResetPEXCounters
//
//!   DESCRIPTION: This API resets the values of the PEX counters as specified in the pexCounterMask.
//!                The value in the pexCounterMask determines which counters are to be reset. This API 
//!                is supported only on Kepler+ cards.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hPhysicalGpuHandle     - GPU handle of which PEX counter values are required
//! \param [in]  pexCounterMask         - PEX counters mask.
//!
//! \return : This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!           specific meaning for this API, they are listed below
//!
//! \ingroup diagapi
//////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Diag_ResetPexCounters(__in LwPhysicalGpuHandle hPhysicalGpuHandle, __in LwU32 pexCounterMask);



//! \ingroup diagapi

typedef enum _LW_DIAG_GC6_DEBUG_INFO_FLAGS
{
    LW_GC6_DEBUG_INFO_VBIOS_FBCLAMP_ENABLED          = LW_BIT(0),  
    LW_GC6_DEBUG_INFO_VBIOS_IFR_ENABLED              = LW_BIT(1), 
    LW_GC6_DEBUG_INFO_SBIOS_ENABLED                  = LW_BIT(2), 
    LW_GC6_DEBUG_INFO_ROMLESS_OPTIMUS_RESUME_ENABLED = LW_BIT(3), 
    LW_GC6_DEBUG_INFO_ROM_JT_GC6_ENABLED             = LW_BIT(4), 
    LW_GC6_DEBUG_INFO_PGISLAND_PRESENT               = LW_BIT(5), 

} LW_DIAG_GC6_DEBUG_INFO_FLAGS;

typedef enum _LW_DIAG_GC6_CAPS_INFO_FLAGS
{
    LW_GC6_CAPS_INFO_CORE_SEQUENCE_ENABLED          = LW_BIT(0),
    LW_GC6_CAPS_INFO_ROM_SEQUENCE_ENABLED           = LW_BIT(1),

} LW_DIAG_GC6_CAPS_INFO_FLAGS;


typedef struct _LW_DIAG_GC6_DEBUG_INFO_V1
{
    LwU32 version;      //!<LW_DIAG_GC6_DEBUG_INFO struct version
    
    LwU32 gc6DebugInfo; //!<Combination of LW_DIAG_GC6_DEBUG_INFO_FLAGS

} LW_DIAG_GC6_DEBUG_INFO_V1;

typedef struct _LW_DIAG_GC6_DEBUG_INFO_V2
{
    LwU32 version;      //!<LW_DIAG_GC6_DEBUG_INFO struct version
    
    LwU32 gc6DebugInfo; //!<Combination of LW_DIAG_GC6_DEBUG_INFO_FLAGS

    LwU32 gc6CapsInfo;  //!<Combination of LW_DIAG_GC6_CAPS_INFO_FLAGS

} LW_DIAG_GC6_DEBUG_INFO_V2;    

typedef LW_DIAG_GC6_DEBUG_INFO_V2     LW_DIAG_GC6_DEBUG_INFO;

#define LW_DIAG_GC6_DEBUG_INFO_VER1   MAKE_LWAPI_VERSION(LW_DIAG_GC6_DEBUG_INFO_V1,1)
#define LW_DIAG_GC6_DEBUG_INFO_VER2   MAKE_LWAPI_VERSION(LW_DIAG_GC6_DEBUG_INFO_V2,2)
#define LW_DIAG_GC6_DEBUG_INFO_VER    LW_DIAG_GC6_DEBUG_INFO_VER2


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_Diag_GetGC6DebugInfo
//
//! DESCRIPTION:     This API call gives the detailed info required for GC6 tool.                  
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]         hPhysicalGpu  - Physical GPU Handle. 
//! \param [in,out]     pGC6DebugInfo - Pointer to the LW_DIAG_GC6_DEBUG_INFO structure. 
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup diagapi
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Diag_GetGC6DebugInfo(__in LwPhysicalGpuHandle hPhysicalGpu, __inout LW_DIAG_GC6_DEBUG_INFO *pGC6DebugInfo);
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SYS_IsPhysXApplication
//
//! DESCRIPTION:     This API is used to query whether the current application should
//!                  report to KMD as a physX application only.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [out]     isPhysXApplication  Returns true if current application reports to KMD as
//!                                      a physx application only.  
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_IsPhysXApplication(__out LwU32 *isPhysXApplication);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SYS_IsPhysXValidConfig
//
//! DESCRIPTION:     This API is used to query whether physx can be supported on the system.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [out]     isPhysXValidConfig  Returns true if physx can be supported on the system.  
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_IsPhysXValidConfig(__out LwU8 *isPhysXValidConfig);


//! Used in LwAPI_SYS_SetFeatureState() and LwAPI_SYS_GetFeatureState().
typedef enum _LW_FEATURE_ID
{ 
    LW_FEATURE_ID_SGM_CLOCK_LOCK  = 0,             //!< Clock locking for SDI, GSync, Mosaic
                                                   //!< No need to set Physical GPU or displayId for this feature
    LW_FEATURE_ID_PAN_SCAN_STATE = 1,              //!< Pan Scan State of the display. Set displayId of the desired pan scan target.
    LW_FEATURE_ID_VRR_STATE = 2,                   //!< VRR State of VRR capable display. Set displayId of the desired display.
    LW_FEATURE_ID_CONSISTENT_PERF = 3,             //!< Clock locking for consistent performance.
    LW_FEATURE_ID_HYPER_SAMPLING = 4,               //!< hyper sampling on all display of a Gpu. Set hPhysicalGpu of the desired Gpu.
    LW_FEATURE_ID_GC6_NOTIFY_STATE_CHANGE = 5      //!< GC6 State Change Event for GPU logging feature during GC6 state change.
} LW_FEATURE_ID;

typedef enum _LW_FEATURE_ID_VALUE
{ 
    LW_FEATURE_ID_OFF  = 0,     //!< feature on
    LW_FEATURE_ID_ON   = 1,     //!< feature off
} LW_FEATURE_ID_VALUE;

//! \ingroup sysgeneral                
typedef struct _LW_SYS_FEATURE_DATA {
    LwU32                  version;                  //!< Version of this structure
    LW_FEATURE_ID          featureId;                //!< feature Id of the feature
    LW_FEATURE_ID_VALUE    featureIdValue;           //!< status of the feature 
    union
    {
        LwPhysicalGpuHandle    hPhysicalGpu;             //!< (Optional)need to be fill in only if feature configuration requires it
        LwU32                  displayId;                //!< (Optional)need to be fill in only if feature configuration requires it
    };
}LW_SYS_FEATURE_DATA_V1;


//! \ingroup sysgeneral
typedef LW_SYS_FEATURE_DATA_V1 LW_SYS_FEATURE_DATA;
#define LW_SYS_FEATURE_DATA_VER_1   MAKE_LWAPI_VERSION(LW_SYS_FEATURE_DATA_V1,1)
#define LW_SYS_FEATURE_DATA_VER LW_SYS_FEATURE_DATA_VER_1   


//! SUPPORTED OS:  Windows XP and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_SYS_SetFeatureState
//
//! \code
//! DESCRIPTION:    This API sets feature status
//!
//! PARAMETERS:     featureId (IN)  data of feature to be controlled
//!
//! DESCRIPTION:    This API sets feature status
//!
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//!
//! \endcode 
/////////////////////////////////////////////////////////////////////////////// 

LWAPI_INTERFACE LwAPI_SYS_SetFeatureState( __in LW_SYS_FEATURE_DATA featureData);

//! SUPPORTED OS:  Windows XP and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_ SYS _GetFeatureState
//
//! \code
//! PARAMETERS:     featureData(IN/OUT)  data of the feature 
//!
//! DESCRIPTION:    This API Gets the current state of corresponding feature
//!
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//!
//! \endcode 
/////////////////////////////////////////////////////////////////////////////// 

LWAPI_INTERFACE LwAPI_SYS_GetFeatureState(__inout LW_SYS_FEATURE_DATA *featureData);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SYS_GetApprovalCookies
//
//! \fn LwAPI_SYS_GetApprovalCookies(LW_APPROVAL_COOKIES *pApprovalCookies)
//! \code
//! DESCRIPTION: retrieves the approval cookies. These are strings returned 
//!              by the SBIOS and used to allow features like SLI or Coproc.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!  
//! PARAMETERS:     pApprovalCookies (OUT)         - the approval cookie list
//! 
//! 
//! RETURN STATUS:
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_ILWALID_ARGUMENT - one or more args are invalid
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup sysgeneral
typedef enum _LW_APPROVAL_COOKIE_TYPE
{
    LW_APPROVAL_COOKIE_TYPE_UNKNOWN  = 0x00,
    LW_APPROVAL_COOKIE_TYPE_SLI      = 0x01,
    LW_APPROVAL_COOKIE_TYPE_COPROC   = 0x02,
    LW_APPROVAL_COOKIE_TYPE_TEMPLATE = 0x03,
} LW_APPROVAL_COOKIE_TYPE;

//! \ingroup sysgeneral
#define MAX_APPROVAL_COOKIE 4

//! \ingroup sysgeneral
typedef struct
{
    LwU32                   version;                                    //!< structure version
    LwU32                   ApprovalCookieCount;                        //!< the approval cookie count
    LW_APPROVAL_COOKIE_TYPE ApprovalCookieType[MAX_APPROVAL_COOKIE];    //!< the array of approval cookie types
    LwAPI_String            ApprovalCookieString[MAX_APPROVAL_COOKIE];  //!< the array of approval cookie strings
} LW_APPROVAL_COOKIES;

//! \ingroup sysgeneral
//! Macro for constructing the version field of ::LW_APPROVAL_COOKIES
#define LW_APPROVAL_COOKIES_VER  MAKE_LWAPI_VERSION(LW_APPROVAL_COOKIES,1)

//! \ingroup sysgeneral
LWAPI_INTERFACE LwAPI_SYS_GetApprovalCookies(LW_APPROVAL_COOKIES *pApprovalCookies);



//! \addtogroup sysgeneral
//! @{ 

typedef enum _LW_ACPI_EVENT_TYPE
{
    LWAPI_ACPI_EVENT_TYPE_LID_STATE,
    LWAPI_ACPI_EVENT_TYPE_POWER_SOURCE,
    LWAPI_ACPI_EVENT_TYPE_DOCK_STATE,
    LWAPI_ACPI_EVENT_TYPE_TRUST_LID,
    LWAPI_ACPI_EVENT_TYPE_TRUST_DOCK,
} LW_ACPI_EVENT_TYPE;

typedef enum _LW_ACPI_EVENT_DATA
{
    LWAPI_ACPI_EVENT_DATA_LID_OPEN,
    LWAPI_ACPI_EVENT_DATA_LID_CLOSED,
    LWAPI_ACPI_EVENT_DATA_POWER_BATTERY,
    LWAPI_ACPI_EVENT_DATA_POWER_AC,
    LWAPI_ACPI_EVENT_DATA_DOCK_UNDOCKED,
    LWAPI_ACPI_EVENT_DATA_DOCK_DOCKED,
    LWAPI_ACPI_EVENT_DATA_TRUST_LID_DCS,
    LWAPI_ACPI_EVENT_DATA_TRUST_LID_LWIF,
    LWAPI_ACPI_EVENT_DATA_TRUST_LID_ACPI,
    LWAPI_ACPI_EVENT_DATA_TRUST_LID_POLL,
    LWAPI_ACPI_EVENT_DATA_TRUST_DOCK_DCS,
    LWAPI_ACPI_EVENT_DATA_TRUST_DOCK_LWIF,
    LWAPI_ACPI_EVENT_DATA_TRUST_DOCK_ACPI,
    LWAPI_ACPI_EVENT_DATA_TRUST_DOCK_POLL,
} LW_ACPI_EVENT_DATA;

typedef enum _LW_ACPI_EVENT_FORCED_DATA
{
    LWAPI_ACPI_EVENT_FORCED_DATA_NO,
    LWAPI_ACPI_EVENT_FORCED_DATA_YES
} LW_ACPI_EVENT_FORCED_DATA;

//! @}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_SYS_ACPI_NotifyEvent
//
//! \code
//!   DESCRIPTION: This call is used to trigger mobile related systems events in RM.
//!                (lid open/close, dock/undock and power plug/unplug (ac/battery))
//!                This events should be triggered by OS and this is a backdoor to
//!                trigger them during testing.
//!
//!    PARAMETERS: eventType(IN) - type of event (see enum _LW_ACPI_EVENT_TYPE)
//!                eventData(IN) - event specific data (see enum _LW_ACPI_EVENT_DATA)
//!                dataForced(IN) - used to specify whether to trust Lid/Dock state
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: LWAPI_OK: exelwtion succeeded
//!                LWAPI_NOT_SUPPORTED: required notification is NOT supported
//!                LWAPI_ILWALID_ARGUMENT: event type or data are incorrect
//!                LWAPI_ILWALID_HANDLE: invalid GPU handle
//!                LWAPI_ERROR: miscellaneous error
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_ACPI_NotifyEvent(LwPhysicalGpuHandle hPhysicalGpu, LW_ACPI_EVENT_TYPE eventType, LW_ACPI_EVENT_DATA eventData, LW_ACPI_EVENT_FORCED_DATA dataForced);

//! \ingroup sysLWIF
//! LWIF function IDs - used in LwAPI_SYS_LWIF_QuerySupport(), LwAPI_SYS_LWIF_GetValues(), and LwAPI_SYS_LWIF_SetValues().
typedef enum _LW_LWIF_FUNC_ID
{
    LWAPI_LWIF_FUNC_LID_STATUS = 0,      //!< Get lid status
    LWAPI_LWIF_FUNC_DOCKING_STATUS,      //!< Get docking status
    LWAPI_LWIF_FUNC_THERMAL_MONITOR,     //!< GPU thermal monitor
    LWAPI_LWIF_FUNC_BRIGHTNESS_CONTROL,  //!< LCD backlight brightness control
    LWAPI_LWIF_FUNC_POWERMIZER_LIMIT,    //!< PowerMizer level limit
    LWAPI_LWIF_FUNC_DISPLAY_ATTRIBUTES,  //!< Display device hotplug detection
    LWAPI_LWIF_FUNC_HDCP,                //!< Get HDCP keys (High bandwidth Digital Content Protection)
    LWAPI_LWIF_FUNC_DISPLAY_GET_VALUE,   //!< Query display device attribute preferences
    LWAPI_LWIF_FUNC_DISPLAY_SET_VALUE,   //!< Set display device attribute preferences
    LWAPI_LWIF_FUNC_PLATFORM_CONFIG,     //!< Get system memory bandwidth and latency information
    LWAPI_LWIF_FUNC_NUM,                 //!< The number of possible function IDs
} LW_LWIF_FUNC_ID; 


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SYS_LWIF_QuerySupport
//
//! DESCRIPTION: This function queries if an LWIF method (specified by func) is 
//! supported by the system BIOS. \n
//! LWIF is an LWPU extension of the Advanced Configuration and Power Interface (ACPI) that OEMs can choose to implement in their system BIOS. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//! \retval   LWAPI_OK                 The queried LWIF method is supported.
//! \retval   LWAPI_NOT_SUPPORTED      The queried LWIF method is NOT supported.
//! \retval   LWAPI_ILWALID_ARGUMENT   Function ID not recognized.
//! \retval   LWAPI_ERROR              Failed to retrieve support info.
//! \ingroup  sysLWIF
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_LWIF_QuerySupport(LW_LWIF_FUNC_ID func);

//! \ingroup sysLWIF
//! Contains LWIF-related data by display output - used in LwAPI_SYS_LWIF_GetValues() and LwAPI_SYS_LWIF_SetValues().
typedef struct
{
    LwU32   version;
    struct
    {
        LwU32   displayOutputId;       //!< Display output ID
        LwU32   data;                  //!< Contains one or more pieces of data whose type depends on #LWIF_FUNC_REQUEST_ID
    }
    displayData[LWAPI_MAX_DISPLAYS];

    LwU32   validDataSize;    //!< Valid number of entries in the displayData array
} LWIF_FUNC_DATA_SET;


//! \ingroup sysLWIF
#define LWIF_FUNC_DATA_SET_VER  MAKE_LWAPI_VERSION(LWIF_FUNC_DATA_SET,1)


//! \ingroup sysLWIF
//! Category of LWIF-related data - used in LwAPI_SYS_LWIF_GetValues() and LwAPI_SYS_LWIF_SetValues(). 
typedef enum 
{
    LWIF_FUNC_REQUEST_SCALING  = 0,  //!< The data set contains one more display scaling methods (see #LW_SCALING).
    LWIF_FUNC_REQUEST_TVFORMAT = 1,  //!< The data set contains one more display tv formats (see #LW_DISPLAY_TV_FORMAT).
    LWIF_FUNC_REQUEST_NUM,
} LWIF_FUNC_REQUEST_ID;
 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SYS_LWIF_GetValues
//
//! DESCRIPTION: This function gets display attributes from the system BIOS using LWIF. LWIF is an
//!              LWPU extension of the Advanced Configuration and Power
//!              Interface (ACPI) that OEMs can choose to implement in
//!              their system BIOS. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \param [in]   func            LWIF function ID.
//!  \param [in]   dataReqId       Specifies the type of data to return (supported scaling or TV formats) from the system BIOS.
//!  \param [out]  data            Contains one or more pieces of data whose type depends on the #LWIF_FUNC_REQUEST_ID.
//!
//!  \retval ::LWAPI_OK
//!  \retval ::LWAPI_NOT_SUPPORTED
//!  \retval ::LWAPI_ILWALID_ARGUMENT
//!  \retval ::LWAPI_ERROR
//!
//!  \ingroup sysLWIF
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_LWIF_GetValues(LW_LWIF_FUNC_ID func, LWIF_FUNC_REQUEST_ID dataReqId, LWIF_FUNC_DATA_SET *data);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SYS_LWIF_SetValues
//
//! DESCRIPTION: This function sets display attributes in the system BIOS using LWIF. LWIF is an
//!              LWPU extension of the Advanced Configuration and Power
//!              Interface (ACPI) that OEMs can choose to implement in
//!              their system BIOS. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \param [in]   func        LWIF function ID
//!  \param [in]   dataReqId   Specifies the type of data to set (supported scaling or TV formats) in the system BIOS.
//!  \param [in]   data        Contains one or more pieces of data whose type depends on the #LWIF_FUNC_REQUEST_ID.
//!
//!  \retval ::LWAPI_OK
//!  \retval ::LWAPI_NOT_SUPPORTED
//!  \retval ::LWAPI_ILWALID_ARGUMENT
//!  \retval ::LWAPI_ERROR
//!
//!  \ingroup sysLWIF
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_LWIF_SetValues(LW_LWIF_FUNC_ID func, LWIF_FUNC_REQUEST_ID dataReqId, LWIF_FUNC_DATA_SET data);



//! \ingroup sysgeneral
#define LWAPI_MEM_DATA_SIZE 128

//! \ingroup sysLWIF
//! Used in LwAPI_SYS_LWIF_PlatformConfig().
typedef struct 
{
    LwU32    version;
    LwU32    dataBlob[LWAPI_MEM_DATA_SIZE];
    LwU32    dataSize; // size in bytes.
    
}LWIF_FUNC_MEM_BW_INFO;

//! \ingroup sysLWIF
#define LWIF_FUNC_MEM_BW_INFO_VER  MAKE_LWAPI_VERSION(LWIF_FUNC_MEM_BW_INFO,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SYS_LWIF_PlatformConfig
//
//! DESCRIPTION:  This API gets system memory bandwidth and latency information from the SBIOS. LWIF is an
//!              LWPU extension of ACPI that OEMs can choose to implement in
//!              their SBIOS. ACPI stands for Advanced Configuration and Power
//!              Interface.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//! \param  [in]  func   LWIF fun ID.
//! \param [out]  data   contains the return data
//!
//! \retval ::LWAPI_OK                queried LWIF method is supported
//! \retval ::LWAPI_NOT_SUPPORTED     queried LWIF method is NOT supported
//! \retval ::LWAPI_ILWALID_ARGUMENT  function ID not recognized
//! \retval :: LWAPI_ERROR            failed to retrieve support info
//!
//! \ingroup sysLWIF
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_LWIF_PlatformConfig(LW_LWIF_FUNC_ID func, LWIF_FUNC_MEM_BW_INFO *data);


//! \addtogroup sysgeneral
//! @{

//! Used in LW_CPU_INFO
typedef enum _LW_CPU_TYPE
{ 
    LW_CPU_TYPE_UNKNOWN         = 0x00000000,
    LW_CPU_TYPE_P5              = 0x00000001, //!< Intel type
    LW_CPU_TYPE_P55             = 0x00000002, //!< Intel type
    LW_CPU_TYPE_P6              = 0x00000003, //!< Intel type
    LW_CPU_TYPE_P2              = 0x00000004, //!< Intel type
    LW_CPU_TYPE_P2XC            = 0x00000005, //!< Intel type
    LW_CPU_TYPE_CELA            = 0x00000006, //!< Intel type
    LW_CPU_TYPE_P3              = 0x00000007, //!< Intel type
    LW_CPU_TYPE_P3_INTL2        = 0x00000008, //!< Intel type
    LW_CPU_TYPE_P4              = 0x00000009, //!< Intel type
    LW_CPU_TYPE_CORE2           = 0x00000010, //!< Intel type
    LW_CPU_TYPE_CELN_M16H       = 0x00000011, //!< Intel type
    LW_CPU_TYPE_CORE2_EXTRM     = 0x00000012, //!< Intel type

    LW_CPU_TYPE_IA64            = 0x00000020, //!< Intel type

    LW_CPU_TYPE_K5              = 0x00000030, //!< AMD type
    LW_CPU_TYPE_K6              = 0x00000031, //!< AMD type
    LW_CPU_TYPE_K62             = 0x00000032, //!< AMD type
    LW_CPU_TYPE_K63             = 0x00000033, //!< AMD type
    LW_CPU_TYPE_K7              = 0x00000034, //!< AMD type
    LW_CPU_TYPE_K8              = 0x00000035, //!< AMD type
    LW_CPU_TYPE_K10             = 0x00000036, //!< AMD type
    LW_CPU_TYPE_K11             = 0x00000037, //!< AMD type
    LW_CPU_TYPE_C6              = 0x00000060, //!< IDT/Centaur type
    LW_CPU_TYPE_C62             = 0x00000061, //!< IDT/Centaur type
    LW_CPU_TYPE_GX              = 0x00000070, //!< Cyrix type
    LW_CPU_TYPE_M1              = 0x00000071, //!< Cyrix type
    LW_CPU_TYPE_M2              = 0x00000072, //!< Cyrix type
    LW_CPU_TYPE_MGX             = 0x00000073, //!< Cyrix type
    LW_CPU_TYPE_TM_CRUSOE       = 0x00000080, //!< Transmeta type
    LW_CPU_TYPE_PPC603          = 0x00000090, //!< PowerPC type
    LW_CPU_TYPE_PPC604          = 0x00000091, //!< PowerPC type
    LW_CPU_TYPE_PPC750          = 0x00000092, //!< PowerPC type
} LW_CPU_TYPE;


//! Used in LW_CPU_INFO
typedef enum _LW_CPU_CAPABILITIES
{ 
  LW_CPU_CAP_MMX                    = 0x00000001,
  LW_CPU_CAP_SSE                    = 0x00000002,
  LW_CPU_CAP_3DNOW                  = 0x00000004,
  LW_CPU_CAP_SSE2                   = 0x00000008,
  LW_CPU_CAP_SFENCE                 = 0x00000010,
  LW_CPU_CAP_WRITE_COMBINING        = 0x00000020,
  LW_CPU_CAP_ALTIVEC                = 0x00000040,
  LW_CPU_CAP_PUT_NEEDS_IO           = 0x00000080,
  LW_CPU_CAP_NEEDS_WC_WORKAROUND    = 0x00000100,
  LW_CPU_CAP_3DNOW_EXT              = 0x00000200,
  LW_CPU_CAP_MMX_EXT                = 0x00000400,
  LW_CPU_CAP_CMOV                   = 0x00000800,
  LW_CPU_CAP_CLFLUSH                = 0x00001000,
  LW_CPU_CAP_NEEDS_WAR_190854       = 0x00002000,
  LW_CPU_CAP_SSE3                   = 0x00004000,
  LW_CPU_CAP_NEEDS_WAR_124888       = 0x00008000,
  LW_CPU_CAP_HT_CAPABLE             = 0x00010000,
} LW_CPU_CAPABILITIES;


//! Used in LwAPI_SYS_GetCpuInfo().
typedef struct
{
    LwU32 version;                            //!< Structure version

    LW_CPU_TYPE         type;                 //!< Processor type
    LW_CPU_CAPABILITIES capabilities;         //!< Processor capability flags
    LwU32               clock;                //!< Processor speed (MHz)
    LwU32               L1DataCacheSize;      //!< L1 dcache size (KB)
    LwU32               L2DataCacheSize;      //!< L2 dcache size (KB)
    LwU32               dataCacheLineSize;    //!< L1 dcache bytes/line
    LwU32               numLogicalCpus;       //!< Logical processor count
    LwU32               numPhysicalCpus;      //!< Physical processor count
    LwU32               numCoresOnDie;        //!< Number of CPU cores on the die
    LwAPI_ShortString   szEmbeddedName;       //!< Embedded CPU name
} LW_CPU_INFO;

//! Used in LW_CPU_INFO.
#define LW_CPU_INFO_VER  MAKE_LWAPI_VERSION(LW_CPU_INFO,2)

//! Used in LwAPI_SYS_GetCpuInfo()
typedef struct
{
    LwU32 version;                            //!< Structure version

    LW_CPU_TYPE         type;                 //!< Processor type
    LW_CPU_CAPABILITIES capabilities;         //!< Processor capability flags
    LwU32               clock;                //!< Processor speed (MHz)
    LwU32               L1DataCacheSize;      //!< L1 dcache size (KB)
    LwU32               L2DataCacheSize;      //!< L2 dcache size (KB)
    LwU32               dataCacheLineSize;    //!< L1 dcache bytes/line
    LwU32               numLogicalCpus;       //!< Logical processor count
    LwU32               numPhysicalCpus;      //!< Physical processor count
    LwAPI_ShortString   szEmbeddedName;       //!< Embedded CPU name
} LW_CPU_INFO_v1;

//! Used in LW_CPU_INFO_v1.
#define LW_CPU_INFO_VER_1  MAKE_LWAPI_VERSION(LW_CPU_INFO_v1,1)


//! @}

 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SYS_GetCpuInfo
//
//!  This function returns information about the CPU(s) in the system.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 85
//!
//! \retval  LWAPI_ILWALID_ARGUMENT             Argument is NULL.
//! \retval  LWAPI_OK                          *pInfo is now set.
//! \retval  LWAPI_LWIDIA_DEVICE_NOT_FOUND      No LWPU device maps to that display name.
//! \retval  LWAPI_INCOMPATIBLE_STRUCT_VERSION  LW_CPU_INFO version not compatible with driver.
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetCpuInfo(LW_CPU_INFO *pInfo);




//! \addtogroup sysgeneral
//! @{

typedef struct
{
    LwU32               version;            //!< structure version
    LwU32               vendorId;           //!< Chipset vendor identification
    LwU32               deviceId;           //!< Chipset device identification
    LwAPI_ShortString   szVendorName;       //!< Chipset vendor Name
    LwAPI_ShortString   szChipsetName;      //!< Chipset device Name
    LwU32               flags;              //!< Chipset info flags - obsolete
    LwU32               subSysVendorId;     //!< Chipset subsystem vendor identification
    LwU32               subSysDeviceId;     //!< Chipset subsystem device identification 
    LwAPI_ShortString   szSubSysVendorName; //!< subsystem vendor Name
    LwU32               HBvendorId;         //!< Host bridge vendor identification
    LwU32               HBdeviceId;         //!< Host bridge device identification
    LwU32               HBsubSysVendorId;   //!< Host bridge subsystem vendor identification
    LwU32               HBsubSysDeviceId;   //!< Host bridge subsystem device identification

} LW_CHIPSET_INFO_v4;

typedef struct
{
    LwU32               version;            //!< structure version
    LwU32               vendorId;           //!< vendor ID
    LwU32               deviceId;           //!< device ID
    LwAPI_ShortString   szVendorName;       //!< vendor Name
    LwAPI_ShortString   szChipsetName;      //!< device Name
    LwU32               flags;              //!< Chipset info flags - obsolete
    LwU32               subSysVendorId;     //!< subsystem vendor ID
    LwU32               subSysDeviceId;     //!< subsystem device ID
    LwAPI_ShortString   szSubSysVendorName; //!< subsystem vendor Name
} LW_CHIPSET_INFO_v3;

typedef enum
{
    LW_CHIPSET_INFO_HYBRID          = 0x00000001,
} LW_CHIPSET_INFO_FLAGS;

typedef struct
{
    LwU32               version;        //!< structure version
    LwU32               vendorId;       //!< vendor ID
    LwU32               deviceId;       //!< device ID
    LwAPI_ShortString   szVendorName;   //!< vendor Name
    LwAPI_ShortString   szChipsetName;  //!< device Name
    LwU32               flags;          //!< Chipset info flags
} LW_CHIPSET_INFO_v2;

typedef struct
{
    LwU32               version;        //structure version
    LwU32               vendorId;       //vendor ID
    LwU32               deviceId;       //device ID
    LwAPI_ShortString   szVendorName;   //vendor Name
    LwAPI_ShortString   szChipsetName;  //device Name
} LW_CHIPSET_INFO_v1;

#define LW_CHIPSET_INFO_VER_1  MAKE_LWAPI_VERSION(LW_CHIPSET_INFO_v1,1)
#define LW_CHIPSET_INFO_VER_2   MAKE_LWAPI_VERSION(LW_CHIPSET_INFO_v2,2)
#define LW_CHIPSET_INFO_VER_3   MAKE_LWAPI_VERSION(LW_CHIPSET_INFO_v3,3)
#define LW_CHIPSET_INFO_VER_4   MAKE_LWAPI_VERSION(LW_CHIPSET_INFO_v4,4)

#define LW_CHIPSET_INFO         LW_CHIPSET_INFO_v4
#define LW_CHIPSET_INFO_VER     LW_CHIPSET_INFO_VER_4

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SYS_GetChipSetInfo
//
//!  This function returns information about the system's chipset.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 95
//!
//! \retval  LWAPI_ILWALID_ARGUMENT              pChipSetInfo is NULL.
//! \retval  LWAPI_OK                           *pChipSetInfo is now set.
//! \retval  LWAPI_INCOMPATIBLE_STRUCT_VERSION   LW_CHIPSET_INFO version not compatible with driver.
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetChipSetInfo(LW_CHIPSET_INFO *pChipSetInfo);


//! \ingroup sysgeneral
//! Lid and dock information - used in LwAPI_GetLidDockInfo()
typedef struct 
{
    LwU32 version;    //! Structure version, constructed from the macro #LW_LID_DOCK_PARAMS_VER
    LwU32 lwrrentLidState;
    LwU32 lwrrentDockState;
    LwU32 lwrrentLidPolicy;
    LwU32 lwrrentDockPolicy;
    LwU32 forcedLidMechanismPresent;
    LwU32 forcedDockMechanismPresent;
}LW_LID_DOCK_PARAMS;


//! ingroup sysgeneral
#define LW_LID_DOCK_PARAMS_VER  MAKE_LWAPI_VERSION(LW_LID_DOCK_PARAMS,1)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_GetLidDockInfo
//
//! DESCRIPTION: This function returns the current lid and dock information.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//! \retval ::LWAPI_OK  
//! \retval ::LWAPI_ERROR
//! \retval ::LWAPI_NOT_SUPPORTED
//! \retval ::LWAPI_HANDLE_ILWALIDATED
//! \retval ::LWAPI_API_NOT_INTIALIZED 
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetLidAndDockInfo(LW_LID_DOCK_PARAMS *pLidAndDock);




//! \ingroup sysgeneral
//! Used in LwAPI_SYS_GetChipSetSliBondInfo().
typedef struct
{
    LwU32               version;        //!< Structure version
    LwU32               sliBondId;      
    LwAPI_ShortString   szSliBondName;
} LW_CHIPSET_SLI_BOND_INFO;


//! \ingroup sysgeneral
//! Used in LW_CHIPSET_SLI_BOND_INFO.
#define LW_CHIPSET_SLI_BOND_INFO_VER  MAKE_LWAPI_VERSION(LW_CHIPSET_SLI_BOND_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SYS_GetChipSetSliBondInfo
//
//!  DESCRIPTION: This function returns information about the system's chipset SLI bond.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//!  \retval  LWAPI_ILWALID_ARGUMENT              pChipSetSliBondInfo is NULL.
//!  \retval  LWAPI_OK                           *pChipSetSliBondInfo is now set.
//!  \retval  LWAPI_INCOMPATIBLE_STRUCT_VERSION   LW_CHIPSET_SLI_BOND_INFO version is not compatible with the driver.
//!
//!  \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetChipSetSliBondInfo(LW_CHIPSET_SLI_BOND_INFO *pChipSetSliBondInfo);


//! \ingroup sysgeneral
typedef struct
{
    LwU32 version;                      //!< Structure version, constructed from macro below
    LwU32 hwbcId;                       //!< Opaque ID unique to this HWBC
    LwU32 firmwareVersion;              //!< The version of the firmware on the HWBC 
    LwU32 secondaryBus;                 //!< Secondary bus number of this PCIE bridge
    LwU32 subordinateBus;               //!< Subordinate bus number of this PCIE bridge
} LW_HWBC_INFO;

//! \ingroup sysgeneral
//! Macro for constructing the version field of ::LW_HWBC_INFO
#define LW_HWBC_INFO_VER  MAKE_LWAPI_VERSION(LW_HWBC_INFO,1)

//! \ingroup sysgeneral
typedef struct
{
    LwU32 version;  //!< Structure version, constructed from macro below
    LW_HWBC_INFO hwbcInfo[LWAPI_SYSTEM_MAX_HWBCS];
} LW_HWBC_INFO_PARAMS;

//! \ingroup sysgeneral
//! Macro for constructing the version field of ::LW_HWBC_INFO_PARAMS
#define LW_HWBC_INFO_PARAMS_VER  MAKE_LWAPI_VERSION(LW_HWBC_INFO_PARAMS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SYS_GetHwbcInfo
//
//! \code
//!   DESCRIPTION: Returns information about all BR04-based HWBCs (PCIE bridges)
//!                present in the system.
//!
//!   PARAMETERS: pHwbcInfoParams (OUT) - Pointer to a user-allocated LW_HWBC_-
//!                                       INFO_PARAMS structure. This structure
//!                                       contains an array of LW_HWBC_INFO 
//!                                       structures into which HWBC information
//!                                       is placed. There is one entry for each
//!                                       HWBC present in the system. Valid 
//!                                       entries are contiguous, invalid 
//!                                       entries have hwbcId equal to LWAPI_-
//!                                       SYSTEM_HWBC_ILWALID_ID.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: LWAPI_OK: The query was successful.
//!                LWAPI_ERROR: A miscellaneous error oclwrred.
//!                LWAPI_ILWALID_POINTER: The pointer argument is NULL.
//!                LWAPI_HANDLE_ILWALIDATED: LWAPI escape result handle is invalid.
//!                LWAPI_API_NOT_INTIALIZED: LWAPI not initialized.
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetHwbcInfo(LW_HWBC_INFO_PARAMS *pHwbcInfoParams);


//! \ingroup sysgeneral
//! @{

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SYS_SetStereoMetaData
//
//! \fn LwAPI_SYS_SetStereoMetaData(LW_STEREO_METADATA* pLwStereoMetaData)
//! \code
//! DESCRIPTION:     Provides the stereo metadata for frame-packed stereo video's
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      pLwStereoMetaData(IN)  - pointer to the stereo metadata struct
//!
//! RETURN STATUS:
//!                  LWAPI_OK - completed request
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! frame layout
typedef enum _LW_STEREO_PACKED_FRAME_LAYOUT
{
    PACKED_FRAME_LEFT_RIGHT        = 0x0,
    PACKED_FRAME_RIGHT_LEFT        = 0x1,
    PACKED_FRAME_OVER_UNDER        = 0x2,
    PACKED_FRAME_UNDER_OVER        = 0x3,
    PACKED_FRAME_LAST
} LW_STEREO_PACKED_FRAME_LAYOUT;


//! state for the metadata
typedef enum _LW_STEREO_METADATA_STATE
{
    METADATA_STATE_ENABLE          = 0x0,
    METADATA_STATE_DISABLE         = 0x1,
    METADATA_STATE_LAST
} LW_STEREO_METADATA_STATE;

//! stereo command
typedef enum _LW_STEREO_COMMAND
{
    STEREO_COMMAND_ADD_RECORD      = 0x0,
    STEREO_COMMAND_REMOVE_RECORD   = 0x1,
    STEREO_COMMAND_LAST
} LW_STEREO_COMMAND;


//! stereo frame info
typedef struct _LW_STEREO_FRAME_INFO
{
    LwU32                           processID;                  //!< (IN) app process id
    LwU32                           streamSrcWidth;             //!< (IN) width
    LwU32                           streamSrcHeight;            //!< (IN) height
    LW_STEREO_PACKED_FRAME_LAYOUT   streamFormat;               //!< (IN) Stream src layout
    LW_STEREO_COMMAND               stereoCmd;                  //!< (IN) stereo command
    LW_STEREO_METADATA_STATE        stereoState;                //!< (IN) stereo state
    LwU32                           IsFromNPAPIPlugin;          //!< (IN) boolean, true if called by an NPAPI plugin
    LwU32                           dwReserved[7];              //!< (IN) reserved DWORDS for future use
} LW_STEREO_FRAME_INFO;

typedef struct _LW_STEREO_METADATA_V1
{
    LwU32                   version;                            //!< (IN) version info
    LW_STEREO_FRAME_INFO    frameInfo;                          //!< packed frame info
} LW_STEREO_METADATA_V1;


typedef LW_STEREO_METADATA_V1 LW_STEREO_METADATA;
#define LW_STEREO_METADATA_VER1 MAKE_LWAPI_VERSION(LW_STEREO_METADATA_V1,1)
#define LW_STEREO_METADATA_VER  LW_STEREO_METADATA_VER1

LWAPI_INTERFACE LwAPI_SYS_SetStereoMetaData(LW_STEREO_METADATA* pLwStereoMetaData);

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SYS_EnableDisplayHotkeyHandling
//
//! DESCRIPTION:  This function configures the display driver to handle ACPI hotkeys.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//!   \retval     LWAPI_OK     Completed request
//!   \retval     LWAPI_ERROR  Miscellaneous error oclwrred
//!
//!   \ingroup    sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_EnableDisplayHotkeyHandling(void);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SYS_DisableDisplayHotkeyHandling
//
//! DESCRIPTION:  This function configures the display driver to send events only on ACPI 
//!               hotkeys.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//!   \retval     LWAPI_OK     Completed request
//!   \retval     LWAPI_ERROR  Miscellaneous error oclwrred
//!
//!   \ingroup    sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_DisableDisplayHotkeyHandling(void);


//! Used in LwAPI_GPU_GetSmartDimmerConfig and LwAPI_GPU_SetSmartDimmerConfig for aggressivenessLevel.
typedef enum
{
    LW_SMART_DIMMER_LEVEL_OFF = 0,
    LW_SMART_DIMMER_LEVEL_HIGHEST_QUALITY = 1,
    LW_SMART_DIMMER_LEVEL_HIGHER_QUALITY = 2,
    LW_SMART_DIMMER_LEVEL_BALANCED = 3,
    LW_SMART_DIMMER_LEVEL_HIGHER_BATT_LIFE = 4,
    LW_SMART_DIMMER_LEVEL_HIGHEST_BATT_LIFE = 5,
} LW_SMART_DIMMER_LEVEL;
   
#define LW_SMART_DIMMER_DISABLED         LW_SMART_DIMMER_LEVEL_OFF
#define LW_SMART_DIMMER_AGGR_LEVEL_MIN   LW_SMART_DIMMER_LEVEL_HIGHEST_QUALITY
#define LW_SMART_DIMMER_AGGR_LEVEL_MAX   LW_SMART_DIMMER_LEVEL_HIGHEST_BATT_LIFE

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_SYS_GetSmartDimmerLevel
//
//! \code
//! DESCRIPTION:    This API queries the current SmartDimmer state
//!
//! PARAMETERS:     pLevel - Pointer to the variable receiving SmartDimmer state info
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! HOW TO USE:     LwS32 level;
//!                 ret = LwAPI_SYS_GetSmartDimmerLevel(&level);
//!                 On call success:
//!                 level would indicate if the feature is lwrrently disabled 
//!                 or the current aggressiveness level if it is enabled
//!
//! RETURN STATUS:
//!                LWAPI_OK - completed request
//!                LWAPI_ERROR - miscellaneous error oclwrred
//!                LWAPI_NOT_SUPPORTED - SmartDimmer3.0 is not available on the target hardware
//!                LWAPI_ILWALID_ARGUMENT - invalid argument passed
//!                LWAPI_API_NOT_INTIALIZED - lwapi not initialized
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetSmartDimmerLevel(LW_SMART_DIMMER_LEVEL *pLevel);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_SYS_SetSmartDimmerLevel
//
//! \code
//! DESCRIPTION:    This API sets the current SmartDimmer state & level
//!
//! PARAMETERS:     Level - LW_SMART_DIMMER_DISABLED or aggressiveness level if request to enable
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! HOW TO USE:     LwS32 level = 0 (for disable)
//!                             = aggresiveness level (k) (for enable)
//!                 ret = LwAPI_SYS_SetSmartDimmerLevel(level);
//!                 On call success:
//!                 SmartDimmer feature would be enabled or disabled & aggresiveness set to the specified level
//!
//! RETURN STATUS:
//!                 LWAPI_OK - completed request
//!                 LWAPI_ERROR - miscellaneous error oclwrred
//!                 LWAPI_NOT_SUPPORTED - SmartDimmer3.0 feature is either not available on the target hardware 
//!                                       or not supported in the current configuration
//!                 LWAPI_ILWALID_ARGUMENT - invalid argument passed
//!                 LWAPI_API_NOT_INTIALIZED - lwapi not initialized
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_SetSmartDimmerLevel(LW_SMART_DIMMER_LEVEL level);



typedef struct
{
        LwU32                   version;               //!< Version of this structure

    LwU8                    enable;                //!< Enable SD or not (CheetAh only)
    LW_SMART_DIMMER_LEVEL   aggressivenessLevel;   //!< Level 0-5, 0 is min which means "no effect" and 5 is max means "Hightest battery life"
    LwU16                   flickerThreshold;      //!< Specify the min amount the new backlight level must deviate from the current level for SD to update (CheetAh only)
    LwU16                   flickerTimeLimit;      //!< Specify the min amount of time the new backlight level must exceed the current level for SD to update (CheetAh only)
    LwU16                   backlightStep;         //!< Specify the initial step in the backlight correction as a fraction of 255 (CheetAh only)
    LwU16                   backlightTC;           //!< Specify the time-constant of the backlight correction as a fraction of 1024 (CheetAh only)
} LW_SMART_DIMMER_CONFIG_V1;

typedef LW_SMART_DIMMER_CONFIG_V1 LW_SMART_DIMMER_CONFIG;
#define LW_SMART_DIMMER_CONFIG_VER1  MAKE_LWAPI_VERSION(LW_SMART_DIMMER_CONFIG_V1,1)
#define LW_SMART_DIMMER_CONFIG_VER   LW_SMART_DIMMER_CONFIG_VER1
   
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_GPU_GetSmartDimmerConfig
//
//! \code
//! DESCRIPTION:    This API queries the current SmartDimmer config
//!
//! PARAMETERS:     pConfig - Pointer to the variable receiving SmartDimmer config info
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! HOW TO USE:     For big GPU, just setup the aggressivenessLevel of config (Note that set it to 0 also means disable).
//!                 For CheetAh, need to setup all the fields of config. 
//!                 Passing the target GPU handle and the config into this call.  
//!                 On call success:
//!                 config would indicate current status/settings of this feature.
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//!                
//!                LWAPI_NOT_SUPPORTED - SmartDimmer is not available on the target hardware
//!                                      or not supported in the current configuration
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_GetSmartDimmerConfig(LwPhysicalGpuHandle hPhysicalGpu, LW_SMART_DIMMER_CONFIG *pConfig);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_GPU_SetSmartDimmerConfig
//
//! \code
//! DESCRIPTION:    This API sets the current SmartDimmer config
//!
//! PARAMETERS:     config
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! HOW TO USE:     For big GPU, just setup the aggressivenessLevel of config (Note that set it to 0 also means disable).
//!                 For CheetAh, need to setup all the fields of config. 
//!                 Passing the target GPU handle and the config into this call.  
//!                 On call success:
//!                 SmartDimmer feature would be set to the specified config
//!
//! RETURN STATUS:
//! RETURN STATUS: This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//!                
//!                LWAPI_NOT_SUPPORTED - SmartDimmer is not available on the target hardware
//!                                      or not supported in the current configuration
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_GPU_SetSmartDimmerConfig(LwPhysicalGpuHandle hPhysicalGpu, LW_SMART_DIMMER_CONFIG config);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  LwAPI_SYS_NotifySBiosDisplaySwitch
//
//! \code
//! PARAMETERS:     ulDevicesMask(IN) - Display device mask.
//!
//! DESCRIPTION:    This API notifies SBIOS of a display switch to display devices specified by ulDevicesMask
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! HOW TO USE:     ret = LwAPI_NotifySBiosDisplaySwitch(ulDevicesMask);
//!                 On call success:
//!                 SBIOS will be notified of a display switch to the ulDevicesMask specified display devices.
//!
//! RETURN STATUS:
//!                 LWAPI_OK - completed request
//!                 LWAPI_ERROR - miscellaneous error oclwrred
//!                 LWAPI_ILWALID_ARGUMENT - invalid argument passed
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_NotifySBiosDisplaySwitch(LwU32 ulDevicesMask);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_SYS_SetPostOutput
//
//! \fn LwAPI_SYS_SetPostOutput(LwU32 address, LWAPI_POST_PORT_FORMAT format, LwU32 data)
//!
//! DESCRIPTION:     This API sends a byte value to the motherboard POST output.
//!                  This call works only on systems having GPUs with
//!                  engineering VBIOS! Systems with production VBIOS
//!                  will return ::LWAPI_NOT_SUPPORTED.
//!                  Supported address range is 0x80-0x84.
//!
//! HOW TO USE:      
//! \verbatem      ret = LwAPI_SYS_SetPostOutput(address, format, data);
//!                      address - POST port I/O address
//!                      format - format of data field
//!                      data - value to display
//!                              0-255 if _FORMAT_HEX
//!                              0-99  if _FORMAT_BCD 
//!                      (HEX->BCD colwersion is performed by LwAPI)
//! \endverbatem
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_ILWALID_ADDRESS 
//! \retval ::LWAPI_ILWALID_ARGUMENT    Incorrect data value (see limits above)
//! \retval ::LWAPI_NOT_SUPPORTED       The call is not supported (on production VBIOS-es)
//! \retval ::LWAPI_API_NOT_INTIALIZED 
//!
///////////////////////////////////////////////////////////////////////////////


//! \ingroup sysgeneral
//! Used in LwAPI_SYS_SetPostOutput().
typedef enum _LW_SYS_POST_PORT_FORMAT
{
    LWAPI_POST_PORT_FORMAT_HEX  = 0,
    LWAPI_POST_PORT_FORMAT_BCD,
} LWAPI_POST_PORT_FORMAT;

//! \ingroup sysgeneral
LWAPI_INTERFACE LwAPI_SYS_SetPostOutput(LwU32 address, LWAPI_POST_PORT_FORMAT format, LwU32 data);


//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SYS_FixIlwalidDriverState
//
//! \code
//!   DESCRIPTION: This function validates the current driver state, and will
//!                do a driver reload if necessary
//!
//!   PARAMETERS:   None
//!
//! RETURN STATUS: 
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_NOT_SUPPORTED - functionality not supported 
//!    LWAPI_API_NOT_INTIALIZED - lwapi not initialized
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_FixIlwalidDriverState();


//! \ingroup sysgeneral
//! @{

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_SYS_SpbControl
//
//! \fn LwAPI_SYS_SpbControl(LWAPI_SPB_COMMAND command, LWAPI_SPB_LOCALE locale, LwU32 *pParam)
//! \code
//! PARAMETERS:      command (IN)        - SPB control command to be exelwted
//!                  locale (IN)         - locale ID
//!                  param (IN, OUT)     - command specific paramater
//!                                      -- power is specified in (milliwatt)
//!                                      -- temperature in (millidegree Celsius)
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION:     This API call is used to control SPB functionality.
//!                  It is used to get/set single SPB parameter as well as to
//!                  control SPB exelwtion mode.
//!                  LWAPI_SPB_DATA_* commands require correct locale parameter.
//!                  LWAPI_SPB_CMD_* and LWAPI_SPB_SYS_* commands require
//!                  locale to be set to LWAPI_SPB_LOCALE_SYSTEM.
//!                  LWAPI_SYS_CMD_* uses only enums defined
//!                  in LWAPI_SPB_COMMAND_PARAM.
//!                  Other commands that require additional parameter must
//!                  respect required units as specified in parameter
//!                  description.
//!
//!                  Do not use this call unles you work on SPB functionlaity.
//!                  It is still under development and minor changes can occur.
//!
//!
//! RETURN STATUS: 
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_ILWALID_POINTER - NULL argument passed
//!    LWAPI_ILWALID_ARGUMENT - incorrect param value
//!    LWAPI_NO_IMPLEMENTATION - command not implemented
//!    LWAPI_NOT_SUPPORTED - call is not supported
//!    LWAPI_API_NOT_INTIALIZED - LwAPI not initialized
//! \endcode
//
///////////////////////////////////////////////////////////////////////////////


typedef enum _LW_SPB_COMMAND
{
    LWAPI_SPB_CMD_GET_INIT                      = 0x0000,
    LWAPI_SPB_CMD_SET_EXEC,
    LWAPI_SPB_CMD_GET_EXEC,
    LWAPI_SPB_CMD_SET_ACTIONS,
    LWAPI_SPB_CMD_GET_ACTIONS,
    LWAPI_SPB_CMD_SET_LOGIC,
    LWAPI_SPB_CMD_GET_LOGIC,
    LWAPI_SPB_CMD_SET_PREFERENCE,
    LWAPI_SPB_CMD_GET_PREFERENCE,
    LWAPI_SPB_CMD_SET_GPU2CPU_LIMIT,
    LWAPI_SPB_CMD_GET_GPU2CPU_LIMIT,
    LWAPI_SPB_CMD_SET_PMU_SPB_STATE,
    LWAPI_SPB_CMD_GET_PMU_SPB_STATE,

    LWAPI_SPB_SYS_SET_MAX_POWER                 = 0x0100,
    LWAPI_SPB_SYS_GET_MAX_POWER,
    LWAPI_SPB_SYS_SET_COOLING_BUDGET,
    LWAPI_SPB_SYS_GET_COOLING_BUDGET,
    LWAPI_SPB_SYS_SET_INTEGRAL_PERIOD,
    LWAPI_SPB_SYS_GET_INTEGRAL_PERIOD,
    LWAPI_SPB_SYS_SET_RULESET,
    LWAPI_SPB_SYS_GET_RULESET,
    LWAPI_SPB_SYS_GET_RULE_COUNT,
    LWAPI_SPB_SYS_SET_APP_BOOST,
    LWAPI_SPB_SYS_GET_APP_BOOST,
    LWAPI_SPB_SYS_SET_PWR_SUPPLY_MODE,
    LWAPI_SPB_SYS_GET_PWR_SUPPLY_MODE,
    LWAPI_SPB_SYS_GET_VCT_SUPPORT_INFO,
    LWAPI_SPB_SYS_GET_SUPPORTED_FUNCTIONS,

    LWAPI_SPB_DATA_GET_POWER                    = 0x0200,
    LWAPI_SPB_DATA_GET_POWER_DELTA,
    LWAPI_SPB_DATA_GET_POWER_FUTURE,
    LWAPI_SPB_DATA_GET_POWER_LTMAVG,
    LWAPI_SPB_DATA_GET_POWER_INTEGRAL,
    LWAPI_SPB_DATA_GET_POWER_BURDEN,
    LWAPI_SPB_DATA_GET_POWER_INTERMEDIATE,

    LWAPI_SPB_DATA_GET_SENSOR_PARAMETERS        = 0x0210,

    LWAPI_SPB_DATA_GET_TEMP                     = 0x0220,
    LWAPI_SPB_DATA_GET_TEMP_DELTA,
    LWAPI_SPB_DATA_GET_TEMP_FUTURE,

    LWAPI_SPB_DATA_GET_PSTATE                   = 0x0240,
    LWAPI_SPB_DATA_GET_PSTATE_CAP,
    LWAPI_SPB_DATA_GET_PSTATE_MIN,
    LWAPI_SPB_DATA_GET_PSTATE_MAX,
    LWAPI_SPB_DATA_GET_PSTATE_ACTION,
    LWAPI_SPB_DATA_GET_PSTATE_SLFM_PRESENT,
    LWAPI_SPB_CMD_SET_POWER_SIM_STATE           = 0x0250,
    LWAPI_SPB_CMD_GET_POWER_SIM_STATE,
    LWAPI_SPB_DATA_SET_POWER_SIM_DATA,
    LWAPI_SPB_DATA_GET_POWER_SIM_DATA,

    LWAPI_SPB_DATA_PING_SBIOS_FOR_EVENT         = 0x0321

} LWAPI_SPB_COMMAND;

typedef enum _LW_SPB_LOCALE
{
    LWAPI_SPB_LOCALE_SYSTEM                     = 0x0000,
    LWAPI_SPB_LOCALE_CPU_0                      = 0x0100,
    LWAPI_SPB_LOCALE_CPU_1,
    LWAPI_SPB_LOCALE_GPU_0                      = 0x0200,
    LWAPI_SPB_LOCALE_GPU_1

} LWAPI_SPB_LOCALE;

typedef enum _LW_SPB_COMMAND_PARAM
{
    LWAPI_SPB_CMD_DEF_ILWALID               = 0x80000000,
    LWAPI_SPB_CMD_DEF_INIT_NO                        = 0,
    LWAPI_SPB_CMD_DEF_INIT_YES,
    LWAPI_SPB_CMD_DEF_EXEC_STOP                      = 0,
    LWAPI_SPB_CMD_DEF_EXEC_START,
    LWAPI_SPB_CMD_DEF_ACTIONS_OFF                    = 0,
    LWAPI_SPB_CMD_DEF_ACTIONS_ON,
    LWAPI_SPB_CMD_DEF_LOGIC_OFF                      = 0,
    LWAPI_SPB_CMD_DEF_LOGIC_FUZZY,
    LWAPI_SPB_CMD_DEF_LOGIC_DETERMINISTIC,
    LWAPI_SPB_CMD_DEF_PREFERENCE_CPU                 = 0,
    LWAPI_SPB_CMD_DEF_PREFERENCE_GPU,
    LWAPI_SPB_CMD_DEF_PREFERENCE_BOTH,
    LWAPI_SPB_CMD_DEF_PMU_SPB_STATE_OFF              = 0,
    LWAPI_SPB_CMD_DEF_PMU_SPB_STATE_ON,
    LWAPI_SPB_CMD_DEF_PWR_SUPPLY_REAL                = 0,
    LWAPI_SPB_CMD_DEF_PWR_SUPPLY_FAKE_AC,
    LWAPI_SPB_CMD_DEF_PWR_SUPPLY_FAKE_BATT,
    LWAPI_SPB_SYS_DEF_FUNC_SUPPORT          = 0x00000001,
    LWAPI_SPB_SYS_DEF_FUNC_VENTURASTATUS    = 0x00000002,
    LWAPI_SPB_SYS_DEF_FUNC_GETPSS           = 0x00000004,
    LWAPI_SPB_SYS_DEF_FUNC_SETPPC           = 0x00000008,
    LWAPI_SPB_SYS_DEF_FUNC_GETPPC           = 0x00000010,
    LWAPI_SPB_SYS_DEF_FUNC_VENTURACB        = 0x00000020,
    LWAPI_SPB_SYS_DEF_FUNC_SYSPARAMS        = 0x00000040,
    LWAPI_SPB_DATA_DEF_ACTION_DEC_TO_P0              = 0,
    LWAPI_SPB_DATA_DEF_ACTION_DEC_BY_1,
    LWAPI_SPB_DATA_DEF_ACTION_DO_NOTHING,
    LWAPI_SPB_DATA_DEF_ACTION_SET_LWRRENT,
    LWAPI_SPB_DATA_DEF_ACTION_INC_BY_1,
    LWAPI_SPB_DATA_DEF_ACTION_INC_BY_2,
    LWAPI_SPB_DATA_DEF_ACTION_INC_TO_LFM,
    LWAPI_SPB_DATA_DEF_ACTION_INC_TO_SLFM,
    LWAPI_SPB_DATA_DEF_SLFM_PRESENT_NO               = 0,
    LWAPI_SPB_DATA_DEF_SLFM_PRESENT_YES,
    LWAPI_SPB_DATA_DEF_POWER_SIM_STATE_OFF           = 0,
    LWAPI_SPB_DATA_DEF_POWER_SIM_STATE_ON

} LWAPI_SPB_COMMAND_PARAM;


LWAPI_INTERFACE LwAPI_SYS_SpbControl(LWAPI_SPB_COMMAND command, LWAPI_SPB_LOCALE locale, LwU32 *pParam);

//! @}


//! \ingroup sysgeneral
//! @{

#define LWAPI_SPB_BATCH_COMMANDS_MAX 16

typedef struct
{
    LwU32   version;            //!< [in] structure version
    LwU32   cmdCount;           //!< [in,out] number of commands to execute
    LwU32   succeeded;          //!< [out] number of succesfully exelwted commands

    struct
    {
        LWAPI_SPB_COMMAND   command;    //!< [in] SPB command
        LWAPI_SPB_LOCALE    locale;     //!< [in] SPB locale
        LwU32               param;      //!< [in/out] SPB param
    } commands[LWAPI_SPB_BATCH_COMMANDS_MAX];

} LW_SPB_BATCH_COMMAND_STRUCT;

//! Macro for constructing the version field of LW_SPB_BATCH_COMMAND_STRUCT
#define LW_SPB_BATCH_COMMAND_STRUCT_VER  MAKE_LWAPI_VERSION(LW_SPB_BATCH_COMMAND_STRUCT,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_SYS_SpbBatchControl
//
//! \code
//! PARAMETERS:      pCmdStruct (IN, OUT) - Array of SPB commands to be exelwted
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION:     This API call allows exelwtion of multiple SpbControl
//!                  commands. 
//!                  On output each commands[i].param holds output value
//!                  for appropriate command.  If command has failed
//!                  param holds value LWAPI_SPB_CMD_DEF_ILWALID.
//!                  For more details on command/device/param refer to        
//!                  LwAPI_SYS_SpbControl().
//!
//! RETURN STATUS: 
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_ILWALID_POINTER - NULL argument passed
//!    LWAPI_ILWALID_ARGUMENT - incorrect cmdCount value
//!    LWAPI_NO_IMPLEMENTATION - command not implemented
//!    LWAPI_NOT_SUPPORTED - call is not supported
//!    LWAPI_API_NOT_INTIALIZED - LwAPI not initialized
//!    LWAPI_ILWALID_CALL - invalid command/device/param & cmdCount holds # of failing entry
//!    LWAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the INFO struct is not supported
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_SpbBatchControl(LW_SPB_BATCH_COMMAND_STRUCT *pCmdStruct);

//! @}



//! \ingroup sysgeneral
//! @{

#define LWAPI_MAX_SPB_CPU_PSTATE 15

typedef struct
{
    LwU32 version;                 //!< Structure version

    LwU32 numOfCpuPstates;
    // This structure defines CPU PState table entries.
    struct
    {
        LwU32   coreFreq;          //!< MHz (650 = 650MHz)
        LwU32   power;             //!< mW - milliwatt (8200mW = 8.2W)
        LwU32   transitionLatency; //!< us - microseconds (500 = 500us)
        LwU32   busMasterLatency;  //!< us - microseconds (300 = 300us)
        LwU32   control;           //!< see ACPI spec
        LwU32   status;            //!< see ACPI spec
    } cpuPstateTable[LWAPI_MAX_SPB_CPU_PSTATE];

} LW_SPB_GET_CPU_PSTATE_TABLE_V1;

typedef LW_SPB_GET_CPU_PSTATE_TABLE_V1 LW_SPB_GET_CPU_PSTATE_TABLE;

#define LW_SPB_GET_CPU_PSTATE_TABLE_VER_1 MAKE_LWAPI_VERSION(LW_SPB_GET_CPU_PSTATE_TABLE_V1,1)
#define LW_SPB_GET_CPU_PSTATE_TABLE_VER   LW_SPB_GET_CPU_PSTATE_TABLE_VER_1


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_SYS_SpbGetPstateTable
//
//! \code
//! PARAMETERS:      pPstateTable (OUT)     - PState table of CPU
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION:     This API call is used to get SPB PSTATE Table of CPU.
//!
//!                  Do not use this call unles you work on SPB functionlaity.
//!                  It is still under development and minor changes can occur.
//!
//! RETURN STATUS: 
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_ILWALID_POINTER - NULL argument passed
//!    LWAPI_ILWALID_ARGUMENT - incorrect param value
//!    LWAPI_NO_IMPLEMENTATION - command not implemented
//!    LWAPI_NOT_SUPPORTED - call is not supported
//!    LWAPI_API_NOT_INTIALIZED - LwAPI not initialized
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_SpbGetPstateTable(LW_SPB_GET_CPU_PSTATE_TABLE *pPstateTable);

//! @}


//! \ingroup sysgeneral
//! @{

#define LWAPI_SPB_MAX_SENSORS     8

typedef struct
{
    LwU32                  version;                     //!< Structure version

    LwU32 sensorCount;
    // This structure defines Sensor Data for CPU/GPU sensors.
    struct
    {
        LwU32 target;        //!< 0 = CPU sensor; 1 = GPU sensor
        LwU32 type;          //!< 0 = Relative_POWER; 1 = Absolute_POWER
        LwU32 i2cPort;       //!< GPU I2C port for this sensor
        LwU32 i2cAddress;    //!< I2C address for this sensor
        LwU32 configIndex;   //!< Sensor register location
        LwU32 configValue;   //!< Value to write to sensor register
        LwU32 calibIndex;    //!< Calibration register location
        LwU32 calibValue;    //!< Value to write to calibration register
        LwU32 powerIndex;    //!< Power register location
        LwU32 pollFreq;      //!< Frequency to sample sensor (in Hz)
        LwU32 resistor;      //!< Value of sense resistor (in milli-ohms)
    } sensorConfig[LWAPI_SPB_MAX_SENSORS];

} LW_SPB_GET_SENSOR_CONFIG_V1;

typedef LW_SPB_GET_SENSOR_CONFIG_V1 LW_SPB_GET_SENSOR_CONFIG;

#define LW_SPB_GET_SENSOR_CONFIG_VER_1 MAKE_LWAPI_VERSION(LW_SPB_GET_SENSOR_CONFIG_V1,1)
#define LW_SPB_GET_SENSOR_CONFIG_VER   LW_SPB_GET_SENSOR_CONFIG_VER_1


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_SYS_SpbGetSensorConfig
//
//! \code
//! PARAMETERS:      psensorConfig (OUT)   - SPB Sensor Data for CPU/GPU sensor
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION:     This API call is used to get SPB Sensor Data of CPU and GPU.
//!
//!                  Do not use this call unles you work on SPB functionlaity.
//!                  It is still under development and minor changes can occur.
//!
//! RETURN STATUS: 
//!    LWAPI_OK - completed request
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_ILWALID_POINTER - NULL argument passed
//!    LWAPI_ILWALID_ARGUMENT - incorrect param value
//!    LWAPI_NO_IMPLEMENTATION - command not implemented
//!    LWAPI_NOT_SUPPORTED - call is not supported
//!    LWAPI_API_NOT_INTIALIZED - LwAPI not initialized
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_SpbGetSensorConfig(LW_SPB_GET_SENSOR_CONFIG *pSensorConfig);

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// New view APIs 
//
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SYS_GetDisplayIdFromGpuAndOutputId
//
//! DESCRIPTION:     This API colwerts a Physical GPU handle and output ID to a
//!                  display ID.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     hPhysicalGpu   Handle to the physical GPU
//! \param [in]     outputId       Connected display output ID on the 
//!                                target GPU - must only have one bit set
//! \param [out]    displayId      Pointer to an LwU32 which contains
//!                                 the display ID
//!
//! \retval  ::LWAPI_OK - completed request
//! \retval  ::LWAPI_API_NOT_INTIALIZED - LWAPI not initialized
//! \retval  ::LWAPI_ERROR - miscellaneous error oclwrred
//! \retval  ::LWAPI_ILWALID_ARGUMENT - Invalid input parameter.
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetDisplayIdFromGpuAndOutputId(LwPhysicalGpuHandle hPhysicalGpu, LwU32 outputId, LwU32* displayId);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SYS_GetGpuAndOutputIdFromDisplayId
//
//! DESCRIPTION:     This API colwerts a display ID to a Physical GPU handle and output ID.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     displayId       Display ID of display to retrieve 
//!                                 GPU and outputId for
//! \param [out]    hPhysicalGpu    Handle to the physical GPU
//! \param [out]    outputId )      Connected display output ID on the 
//!                                 target GPU will only have one bit set.
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_API_NOT_INTIALIZED 
//! \retval ::LWAPI_ID_OUT_OF_RANGE    The DisplayId corresponds to a 
//!                                    display which is not within the
//!                                    normal outputId range.
//! \retval ::LWAPI_ERROR   
//! \retval ::LWAPI_ILWALID_ARGUMENT 
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetGpuAndOutputIdFromDisplayId(LwU32 displayId, LwPhysicalGpuHandle *hPhysicalGpu, LwU32 *outputId);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SYS_GetPhysicalGpuFromDisplayId
//
//! \code
//! DESCRIPTION:     This API retrieves the Physical GPU handle of the connected display
//!
//! \since Release: 313
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      displayId(IN)     - Display ID of display to retrieve 
//!                                      GPU handle
//!                  hPhysicalGpu(OUT) - Handle to the physical GPU
//!
//! RETURN STATUS:
//!                  LWAPI_OK - completed request
//!                  LWAPI_API_NOT_INTIALIZED - LWAPI not initialized
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter.
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetPhysicalGpuFromDisplayId(LwU32 displayId, LwPhysicalGpuHandle *hPhysicalGpu);


//! \ingroup sysgeneral
//! @{

#define LW_LUID_CONTAINS_EDID             LW_BIT(0) //!< This is Read only flag - Generate a LUID based on the EDID

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SYS_GetLUIDFromDisplayID
//
//! \code
//! DESCRIPTION:   Colwerts a displayId to a LUID.
//! HOW TO USE:    for each PhysicalGpu Query for LwAPI_GPU_GetConnectedDisplayIds to get list of displayId's
//!                On call success:
//!                Use LwAPI_SYS_GetLUIDFromDisplayID function to get a LUID corresponding to the displayId.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      displayId(IN) - Display ID of display to retrieve LUID
//!
//!                  luId(OUT)     - A Locally unique identifier or LUID is a special type of identifier designed
//!                                  to maintain the persistent. LUID is valid across reboots, driver reloads and topology changes.
//!                  flags(IN)     - one or more defines from LW_LUID_CONTAINS_* as valid flags.
//!
//! RETURN STATUS:
//!                  LWAPI_OK - completed request
//!                  LWAPI_API_NOT_INTIALIZED - LWAPI not initialized
//!                  LWAPI_ID_OUT_OF_RANGE - The DisplayId corresponds to a 
//!                                          display which is not within the
//!                                          normal outputId range.
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter.
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetLUIDFromDisplayID(LwU32 displayId, LwU32 flags, LwLUID *luId);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   LwAPI_SYS_GetDisplayIdFromLUID
//
//! \code
//! DESCRIPTION:   Colwerts a LUID to a displayId
//! HOW TO USE:    Client needs to pass a LUID which they already having
//!
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      luId(IN)       - A Locally unique identifier or LUID is a special type of identifier designed 
//!                                   to maintain the persistent. LUID is valid across reboots, driver reloads and topology changes.
//!                                  
//!                  displayId(OUT) - Pointer to an LwU32 which will contain the displayID
//!
//! RETURN STATUS:
//!                  LWAPI_OK - completed request
//!                  LWAPI_API_NOT_INTIALIZED - LWAPI not initialized
//!                  LWAPI_ERROR - miscellaneous error oclwrred
//!                  LWAPI_ILWALID_ARGUMENT - Invalid input parameter.
//!                  LWAPI_MATCHING_DEVICE_NOT_FOUND - The display Id could not be located
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetDisplayIdFromLUID(LwLUID luId, LwU32* displayId);

//! @}







//! \ingroup sysgeneral
//! @{

#define LW_MAX_MDTL_COMBINATIONS         30            //!< as per spec limit

typedef struct _LW_MDTL_COMBINATION_V1

{
    LwU32               ulACPIId1;                  //!< Device ACPI ID 1
    LwU32               ulACPIId2;                  //!< Device ACPI ID 2
    
} LW_MDTL_COMBINATION_V1;

typedef struct _LW_MDTL_COMBINATION_V2
{
    LwU32                 ulACPIId1;                  //!< Device ACPI ID 1
    LwU32                 ulACPIId2;                  //!, Device ACPI ID 2
    LW_TARGET_VIEW_MODE   viewMode;                   //!< LW_VIEW_MODE_STANDARD/CLONE/DUALVIEW

} LW_MDTL_COMBINATION_V2;

typedef LW_MDTL_COMBINATION_V2 LW_MDTL_COMBINATION; 


typedef struct _LW_MDTL_LIST_DATA_V1
{
    LwU32   version;                                               //!< (IN)version info

    LwU32 ulValidMdtlCombinations;                                 //!< Total valid MDTL entries
    LW_MDTL_COMBINATION_V1 mdtlList[LW_MAX_MDTL_COMBINATIONS];     //!< MDTL list containing all possible hot key display combinations

}LW_MDTL_LIST_DATA_V1;



typedef struct _LW_MDTL_LIST_DATA_V2
{
    LwU32   version;                                               //!< (IN)version info
    LwU32 ulValidMdtlCombinations;                                 //!< Total valid MDTL entries
    LW_MDTL_COMBINATION mdtlList[LW_MAX_MDTL_COMBINATIONS];        //!< MDTL list containing all possible hot key display combinations

}LW_MDTL_LIST_DATA_V2;


//! Macro for constructing the version field of ::_LW_MDTL_LIST_DATA
#define LW_MDTL_LIST_DATA_VER1  MAKE_LWAPI_VERSION(LW_MDTL_LIST_DATA_V1,1)
#define LW_MDTL_LIST_DATA_VER2  MAKE_LWAPI_VERSION(LW_MDTL_LIST_DATA_V2,2)
#define LW_MDTL_LIST_DATA_VER LW_MDTL_LIST_DATA_VER2
typedef LW_MDTL_LIST_DATA_V2  LW_MDTL_LIST_DATA;

typedef struct _LW_MDTL_VALID_INDEX_V1
{
    LwU32   version;                                               // (IN)version info
    
    LwU32   ulValidMdtlIndex;                                      // The valid MDTL combination index informed to SBIOS.

}LW_MDTL_VALID_INDEX_V1;

#define LW_MDTL_VALID_INDEX_VER1  MAKE_LWAPI_VERSION(LW_MDTL_VALID_INDEX_V1,1)
#define LW_MDTL_VALID_INDEX_VER LW_MDTL_VALID_INDEX_VER1
typedef LW_MDTL_VALID_INDEX_V1  LW_MDTL_VALID_INDEX;



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_SYS_GetMDTLData
//
//! \code
//! PARAMETERS:      pMdtlData (OUT)         - Out Pointer to the LW_MDTL_LIST_DATA. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION:     This API call is used to get the MDTL List from the Driver.
//!                  If call succeeds,  "pMdtlList" points to the List.
//!
//!
//! RETURN STATUS:
//!    LWAPI_OK - completed request
//!    LWAPI_INCOMPATIBLE_STRUCT_VERSION - LW_MDTL_LIST_DATA structure version mismatch.
//!    LWAPI_ERROR - miscellaneous error oclwrred
//!    LWAPI_ILWALID_POINTER - NULL argument passed
//!    LWAPI_NOT_SUPPORTED - call is not supported
//!    LWAPI_API_NOT_INTIALIZED - LwAPI not initialized
//! \endcode
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetMDTLData(LW_MDTL_LIST_DATA *pMdtlData);

//! @}







///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_SYS_SetValidMDTLIndex
//! \code
//! PARAMETERS:      pMdtlIndexData (IN)         - In Pointer to the LW_MDTL_VALID_INDEX data index data
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION:     This API call sets the MDTL index, chosen by lwsvc, to the SBIOS 
//!                  via display driver
//!
//!
//! RETURN STATUS:
//!    LWAPI_OK - completed request
//!    LWAPI_INCOMPATIBLE_STRUCT_VERSION - LW_MDTL_VALID_INDEX structure version mismatch.
//!    LWAPI_ERROR - An unknown error oclwrred.
//!    LWAPI_ILWALID_POINTER - NULL argument passed
//!    LWAPI_NOT_SUPPORTED - call is not supported
//!    LWAPI_API_NOT_INTIALIZED - LwAPI not initialized
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_SetValidMDTLIndex(LW_MDTL_VALID_INDEX *pMdtlIndexData);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_SYS_VenturaGetState
//
//! \fn LwAPI_SYS_VenturaGetState(LWAPI_VENTURA_STATE *state)
//!
//!  DESCRIPTION:   This API queries the current Ventura state.
//!                  If the call succeeds, the variable state holds one of the following
//!                  values:
//!                  - LWAPI_VENTURA_STATE_UNSUPPORTED - when exelwted on 
//!                  Ventura non-capable system
//!                  - LWAPI_VENTURA_STATE_DISABLED - Ventura control is not
//!                  active (but system is Ventura capable)
//!                  - LWAPI_VENTURA_STATE_ENABLED - Ventura is actively
//!                  managing power consumption to stay within defined budget
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 185
//!
//! \param [out]   state    The current Ventura state
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_ILWALID_POINTER   NULL argument passed
//! \retval ::LWAPI_ILWALID_ARGUMENT  Incorrect param value
//! \retval ::LWAPI_NOT_SUPPORTED 
//! \retval ::LWAPI_API_NOT_INTIALIZED 
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup sysgeneral
//! Used in LwAPI_SYS_VenturaSetState() and LwAPI_SYS_VenturaGetState().
typedef enum _LWAPI_VENTURA_STATE
{
    LWAPI_VENTURA_STATE_UNSUPPORTED,
    LWAPI_VENTURA_STATE_DISABLED,    //!< Deactivate Ventura 
    LWAPI_VENTURA_STATE_ENABLED      //!< Activate Ventura

} LWAPI_VENTURA_STATE;

//! \ingroup sysgeneral
LWAPI_INTERFACE LwAPI_SYS_VenturaGetState(LWAPI_VENTURA_STATE *state);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_SYS_VenturaSetState
//
//! DESCRIPTION:     This API controls the Ventura state.
//!                  See ::LWAPI_VENTURA_STATE for valid state values. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]    state    The new Ventura state
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ERROR
//! \retval ::LWAPI_ILWALID_ARGUMENT 
//! \retval ::LWAPI_NOT_SUPPORTED 
//! \retval ::LWAPI_API_NOT_INTIALIZED 
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_VenturaSetState(LWAPI_VENTURA_STATE state);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_SYS_VenturaGetCoolingBudget
//
//! DESCRIPTION:     This API retrieves the cooling budget that is
//!                  lwrrently being used by Ventura.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 185
//!
//! \param [out]     budget   The current cooling budget (in mW)
//!
//! \retval ::LWAPI_OK 
//! \retval ::LWAPI_ERROR 
//! \retval ::LWAPI_ILWALID_POINTER 
//! \retval ::LWAPI_ILWALID_ARGUMENT 
//! \retval ::LWAPI_NOT_SUPPORTED 
//! \retval ::LWAPI_API_NOT_INTIALIZED 
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_VenturaGetCoolingBudget(LwU32 *budget);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_SYS_VenturaSetCoolingBudget
//
//! DESCRIPTION:     This API call sets the new cooling budget
//!                  that will be used by Ventura.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]      budget    The new cooling budget (in mW)
//!
//! \retval ::LWAPI_OK - completed request
//! \retval ::LWAPI_ERROR - miscellaneous error oclwrred
//! \retval ::LWAPI_ILWALID_ARGUMENT - incorrect param value
//! \retval ::LWAPI_NOT_SUPPORTED - call is not supported
//! \retval ::LWAPI_API_NOT_INTIALIZED - LwAPI not initialized
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_VenturaSetCoolingBudget(LwU32 budget);

//! \ingroup sysgeneral
//! @{
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_SYS_VenturaGetPowerReading
//
//! \fn LwAPI_SYS_VenturaGetPowerReading(LWAPI_VENTURA_DEVICE device, LwU32 *power)
//!
//! \param [in]     device          targeted device
//! \param [out]    power           latest power reading [mW]
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION:     This API call is used to query for latest power reading.
//!                  'Device' describes desired target device .
//!                  If call succeeds, variable 'power' holds device's latest
//!                  power reading in [mW] (1/1000 of Watt).
//!
//!                  Power measurement for device 'system' can be greater than
//!                  sum of power measurements for devices 'cpu_0' and 'gpu_0'
//!                  since additional devices can be introduced in the future.
//!
//! \return 
//!    ::LWAPI_OK,  
//!    ::LWAPI_ERROR, 
//!    ::LWAPI_ILWALID_POINTER, 
//!    ::LWAPI_ILWALID_ARGUMENT, 
//!    ::LWAPI_NOT_SUPPORTED, 
//!    ::LWAPI_API_NOT_INTIALIZED, 
//
///////////////////////////////////////////////////////////////////////////////

//! See LwAPI_SYS_VenturaGetPowerReading().
typedef enum _LWAPI_VENTURA_DEVICE
{
    LWAPI_VENTURA_DEVICE_SYSTEM,
    LWAPI_VENTURA_DEVICE_CPU_0,
    LWAPI_VENTURA_DEVICE_GPU_0

} LWAPI_VENTURA_DEVICE;


LWAPI_INTERFACE LwAPI_SYS_VenturaGetPowerReading(LWAPI_VENTURA_DEVICE device, LwU32 *power);

//! @}





//! \ingroup sysgeneral
typedef enum
{
    LW_SS_FEATURE_LICENSE_MODE_UNKNOWN                  = 0,
    LW_SS_FEATURE_LICENSE_MODE_3DVISION_PANEL           = 1,
    LW_SS_FEATURE_LICENSE_MODE_3DTV_OEM_BULK            = 2,
    LW_SS_FEATURE_LICENSE_MODE_3DTV_END_USER            = 3,
    LW_SS_FEATURE_LICENSE_MODE_3DV_ANY                  = 4,
    LW_SS_FEATURE_LICENSE_MODE_3DTV_PLAYPLUS_END_USER   = 5,
    
    LW_SS_FEATURE_LICENSE_MODE_CSC_OEM_BULK   = 0x100,
    LW_SS_FEATURE_LICENSE_MODE_CSC_END_USER   = 0x200,
    LW_SS_FEATURE_LICENSE_MODE_CSC_ANY        = 0xF00,

    /* Add new feature and license mode here */
} LW_SS_FEATURE_LICENSE_MODE;

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_SYS_CheckLicense
//
//! \code
//!   DESCRIPTION: Check for an effective license for the specified software feature on the system.
//!    PARAMETERS: mode(IN)                            - Feature license mode, must be LW_SS_FEATURE_LICENSE_MODE_*_ANY.
//!                pEffectiveLicenseMode(OUT OPTIONAL) - Return the effective license mode if found.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! 
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: Invalid feature license mode.
//!                LWAPI_OK: Effective license found.
//!                LWAPI_ERROR: No license found or call failed.
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_CheckLicense(LW_SS_FEATURE_LICENSE_MODE mode , LW_SS_FEATURE_LICENSE_MODE *pEffectiveLicenseMode);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_SYS_IdentifyLicense
//
//! \code
//!    DESCRIPTION: Return the session-key encrypted software serial number & 4PID.
//!    PARAMETERS: mode(IN)              - Feature license mode, must be LW_SS_FEATURE_LICENSE_MODE_*_END_USER.
//!                sessionKey(IN)        - 128-bit session encryption key.
//!                random(OUT)           - 256-bit random number.
//!                serialNumber4PID(OUT) - Encrypted feature software serial number, 128 bits, followed by
//!                                        encrypted 4PartID, 128 bits. 4PartID is 64-bit, 0 pre-padding to 128-bit before encryption.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: Invalid feature license mode.
//!                LWAPI_OK: License data returned.
//!                LWAPI_ERROR: Call failed.
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_IdentifyLicense(LW_SS_FEATURE_LICENSE_MODE mode, LwU8 sessionKey[16], LwU8 random[32], LwU8 serialNumber4PID[32]);





/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_SYS_ValidateLicense
//
//! \code 
//!   DESCRIPTION:  Validate the feature license specified by mode.
//!    PARAMETERS: mode(IN) - Feature license mode
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: Invalid feature license mode or invalid pointers.
//!                LWAPI_OK: License validated.
//!                LWAPI_ERROR: No license, invalid license or call failed.
//! \endcode
//! \ingroup sysgeneral
//////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_ValidateLicense(LW_SS_FEATURE_LICENSE_MODE mode);



/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_SYS_GenerateLicense
//
//! \code
//!   DESCRIPTION: Verify double encrypted software serial number. If valid, generate an end-user license and save it to registry.
//!    PARAMETERS: mode(IN)         - Feature license mode, must be LW_SS_FEATURE_LICENSE_MODE_*_END_USER.
//!                sessionKey(IN)   - Session key used in previous call of LwAPI_SYS_IdentifyLicense.
//!                serialNumber(IN) - 128-bit software serial number double encrypted by session key & a feature-specific key shared
//!                                   between DR license-protected client and SEC uCode.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: invalid feature license mode.
//!                LWAPI_OK: Feature license generated and saved.
//!                LWAPI_ERROR: Call failed.
//! \endcode
//! \ingroup sysgeneral 
//////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GenerateLicense(LW_SS_FEATURE_LICENSE_MODE mode , LwU8 sessionKey[16], LwU8 serialNumber[16]);




/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_SYS_RemoveLicense
//
//! \code
//!   DESCRIPTION: Remove end-user feature license saved in registry.
//!    PARAMETERS: mode(IN) - Feature license mode, must be LW_SS_FEATURE_LICENSE_MODE_*_END_USER.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: invalid feature license mode.
//!                LWAPI_OK: Feature license removed or not found.
//!                LWAPI_ERROR: Call failed.
//! \endcode
//! \ingroup sysgeneral
//////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_RemoveLicense(LW_SS_FEATURE_LICENSE_MODE mode);



/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_SYS_SetMiscLicenseInfo
//
//! \code
//!    DESCRIPTION: This API changes the encrypted DR license info in the kernel driver.
//!    PARAMETERS: mode(IN)         - Feature license mode, must be LW_SS_FEATURE_LICENSE_MODE_*_END_USER.
//!                licenseInfo(IN)  - Encrypted DR license info.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: invalid feature license mode.
//!                LWAPI_OK: Succeeded.
//!                LWAPI_ERROR: Call failed.
//! \endcode
//! \ingroup sysgeneral
//////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_SetMiscLicenseInfo(LW_SS_FEATURE_LICENSE_MODE mode, LwU8 licenseInfo[256]);


/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_SYS_ClearMiscLicenseInfo
//
//! \code
//!   DESCRIPTION: This API clears the encrypted DR license info saved in the kernel driver.
//!    PARAMETERS: mode(IN)         - Feature license mode, must be LW_SS_FEATURE_LICENSE_MODE_*_END_USER.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: invalid feature license mode.
//!                LWAPI_OK: License info cleared or not found.
//!                LWAPI_ERROR: Call failed.
//! \endcode
//! \ingroup sysgeneral
//////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_ClearMiscLicenseInfo(LW_SS_FEATURE_LICENSE_MODE mode);




//! \ingroup sysgeneral
//! @{

typedef struct _LW_SS_MISC_LICENSE_INFO_V1
{
    LwU32   version;                //!< (IN)  structure version
    LwU8    isLicensed;             //!< (OUT) true if licensed, otherwise false.
    char    szSerialNumber[128];    //!< (OUT) Serial number if licensed, otherwise empty.
    LwU8    isTrialExpired;         //!< (OUT) true if trial expired, otherwise false; not valid if licensed.
    LwU8    trialDaysLeft;          //!< (OUT) The number of trial days left; not valid if licensed.
} LW_SS_MISC_LICENSE_INFO_V1;

typedef LW_SS_MISC_LICENSE_INFO_V1    LW_SS_MISC_LICENSE_INFO;
#define LW_SS_MISC_LICENSE_INFO_VER1  MAKE_LWAPI_VERSION(LW_SS_MISC_LICENSE_INFO_V1,1)
#define LW_SS_MISC_LICENSE_INFO_VER   LW_SS_MISC_LICENSE_INFO_VER1

//! @}

/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_SYS_GetMiscLicenseInfo
//
//! \code
//!   DESCRIPTION: This API gets the DR license info from the encrypted data saved in the kernel driver.
//!    PARAMETERS: mode(IN)                        - Feature license mode, must be LW_SS_FEATURE_LICENSE_MODE_*_END_USER.
//!                pMiscLicenseInfo [OUT]          - DR license info.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: LWAPI_ILWALID_ARGUMENT: invalid feature license mode, or NULL pointers.
//!                LWAPI_OK: Succeeded.
//!                LWAPI_ERROR: Call failed or no license data set before.
//!                             bIsLicensed set to false, szSerialNumber empty, bIsTrialExpired true, nTrialDaysLeft 0
//! \endcode
//! \ingroup sysgeneral
//////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetMiscLicenseInfo(LW_SS_FEATURE_LICENSE_MODE mode, LW_SS_MISC_LICENSE_INFO *pMiscLicenseInfo);







//! \ingroup sysgeneral
typedef struct _LWAPI_SYS_NBCI_PLATCAPS_PARAMS
{
    LwU32 version;                                    //!< Structure version

    LwU32 is3DEnableHotKeySupported:1;                //!< 1 :3D Stereo Enable-Disable Hotkey Supported.
                                                      //!< 0 :3D Stereo Enable-Disable Hotkey Not Supported.
    LwU32 is3DSeparationHotKeySupported:1;            //!< 1 :3D Stereo Separation.Hotkey Supported.
                                                      //!< 0 :3D Stereo Separation Hotkey Not Supported.
    LwU32 is3DActivateHotKeySupported:1;              //!< 1 :3D Stereo Activate-Deavtivate Hotkey Supported.
                                                      //!< 0 :3D Stereo Activate-Deavtivate Hotkey Not Supported.
    LwU32 reserved:29;
    
} LWAPI_SYS_NBCI_PLATCAPS_PARAMS_V1;

//! \ingroup sysgeneral
typedef LWAPI_SYS_NBCI_PLATCAPS_PARAMS_V1     LWAPI_SYS_NBCI_PLATCAPS_PARAMS;

//! \ingroup sysgeneral
#define LWAPI_SYS_NBCI_PLATCAPS_PARAMS_VER1   MAKE_LWAPI_VERSION(LWAPI_SYS_NBCI_PLATCAPS_PARAMS_V1,1)

//! \ingroup sysgeneral
#define LWAPI_SYS_NBCI_PLATCAPS_PARAMS_VER    LWAPI_SYS_NBCI_PLATCAPS_PARAMS_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_SYS_GetNBCIPlatCaps
//
//! \param [out]    *pParams      Structure containing the out data. This data is 
//!                               the platcaps data returned by SBios.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION:     This API call is used to query for NBCI Platcaps. 
//!                  LWAPI_SYS_NBCI_PLATCAPS_PARAMS contains the out Data which is the platcaps..
//!
//! \retval ::LWAPI_OK - completed request
//! \retval ::LWAPI_ERROR - miscellaneous error oclwrred
//! \retval ::LWAPI_ILWALID_POINTER - NULL argument passed
//! \retval ::LWAPI_NOT_SUPPORTED - call is not supported
//! \retval ::LWAPI_API_NOT_INTIALIZED - LwAPI not initialized
//! \retval ::LWAPI_INCOMPATIBLE_STRUCT_VERSION - Invalid Structure version.
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetNBCIPlatCaps(LWAPI_SYS_NBCI_PLATCAPS_PARAMS *pParams);






//! \ingroup sysgeneral
#define LWAPI_OCA_FINGERPRINT_MAX_BUFFER_SIZE 128

////////////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_SYS_SaveOCAFingerprint
//
//! DESCRIPTION: This API saves the fingerprint data passed in by user into the KMD OCA buffer,
//!              which is later saved in the mini-dump to be sent to OCA site in case of crash.
//!              The size of data, in bytes, present in buffer should not be more than LWAPI_OCA_FINGERPRINT_MAX_BUFFER_SIZE.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  pFingerprintBuffer   pointer to the buffer which contains the 
//!                                   fingerprint data to be saved
//! \param [in]  sizeOfBuffer         size, in Bytes, of the fingerprint data present in the buffer pointed by pFingerprintBuffer.
//!
//! \return      This API can return any of the error codes enumerated in #LwAPI_Status. 
//!              If there are return error codes with specific meaning for this API, they are listed below:
//! \retval ::LWAPI_ILWALID_POINTER pFingerprintBuffer is NULL.
//! \retval ::LWAPI_ARGUMENT_EXCEED_MAX_SIZE sizeOfBuffer is greater than LWAPI_OCA_FINGERPRINT_MAX_BUFFER_SIZE
//!
//! \ingroup sysgeneral
////////////////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_SaveOCAFingerprint(__in_bcount(sizeOfBuffer) const LwU8 *pFingerprintBuffer, __in LwU32 sizeOfBuffer);


////////////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_SYS_GetPipeServerInformation
//
//! DESCRIPTION: This API retrieves the name of the pipe server that our UMD driver are using to relay information.
//!              Besides the name, the API retrieves the version of the pipeServer which indicates how the messages are
//!              to be parsed. \n
//!              This is an internal API for usage only by our tools.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [out] pipeServerName     - pointer to the unicode string to receive the name of the pipe server
//! \param [out] pipeServerVersion  - Version of the pipeServer.
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
////////////////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetPipeServerInformation(__out_bcount_full(sizeof(LwAPI_UnicodeString)) LwAPI_UnicodeString pipeServerName, __out LwU32 *pipeServerVersion);


////////////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_SYS_SetScreenSaverState
//
//! DESCRIPTION: This API notifies the current state of screen saver to RM.
//!              Based on the screen saver state, RM will tune the performance.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] bRunning  -  (Boolean) When set to true , this indicates that the screen saver is running.
//!
//! \return This API can return any of the error codes enumerated in #LwAPI_Status. 
//!                If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
////////////////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_SetScreenSaverState(__in LwU8 bRunning);


//! \ingroup sysgeneral
typedef struct _LWAPI_SYS_ACPIID_MAP
{
    LwU32 version;                                       //!< Structure version

    LwU32 count;                                         //!< Count of valid mapping.
    LwU32 acpiIds[LWAPI_MAX_ACPI_IDS];                   //!< Output ACPI IDs
    LwU32 displayIds[LWAPI_MAX_ACPI_IDS];                //!< Output display ID
    
} LWAPI_SYS_ACPIID_MAP_V1;

//! \ingroup sysgeneral
typedef LWAPI_SYS_ACPIID_MAP_V1     LWAPI_SYS_ACPIID_MAP;

//! \ingroup sysgeneral
#define LWAPI_SYS_ACPIID_MAP_VER1   MAKE_LWAPI_VERSION(LWAPI_SYS_ACPIID_MAP_V1,1)

//! \ingroup sysgeneral
#define LWAPI_SYS_ACPIID_MAP_VER    LWAPI_SYS_ACPIID_MAP_VER1


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SYS_GetACPIIdMappings
//
//!   DESCRIPTION: This API returns ACPI IDs mapping to the corresponding display IDs.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out] pACPIIdMap            Pointer to LWAPI_SYS_ACPIID_MAP structure. 
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetACPIIdMappings( __inout LWAPI_SYS_ACPIID_MAP *pACPIIdMap);


//! \ingroup sysgeneral
typedef struct _LW_VGX_SYS_INFO
{
    LwU32               version;                    //!< Structure version

    LwAPI_LongString    hostDriverVersion;          //!< This field returns the host driver version (LW_VERSION_STRING)
    LwAPI_LongString    hostDriverBranchVersion;    //!< This field returns the host driver version (LW_BUILD_BRANCH_VERSION).
    LwAPI_LongString    hostDriverTitle;            //!< This field returns the host driver title (LW_DISPLAY_DRIVER_TITLE)
    LwAPI_LongString    hostOSVersion;              //!< This field returns the host OS version details
    LwAPI_LongString    pluginDriverTitle;          //!< This field returns the plug-in build title
    LwU32               pluginChangelistNumber;     //!< This field returns the change list value of the plug in 
    LwU32               hostOSChangelistNumber;     //!< This field returns the change list value of the host driver (LW_BUILD_CHANGELIST_NUM)
} LW_VGX_SYS_INFO_V1;

//! \ingroup sysgeneral
typedef LW_VGX_SYS_INFO_V1     LW_VGX_SYS_INFO;

//! \ingroup sysgeneral
#define LW_VGX_SYS_INFO_VER1   MAKE_LWAPI_VERSION(LW_VGX_SYS_INFO_V1,1)

//! \ingroup sysgeneral
#define LW_VGX_SYS_INFO_VER    LW_VGX_SYS_INFO_VER1


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SYS_GetVGXInfo
//
//!   DESCRIPTION: This API returns VGX system information
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out] pVGXSysInfo         Pointer to LW_VGX_SYS_INFO structure. 
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetVGXInfo(__inout LW_VGX_SYS_INFO *pVGXSysInfo);


//! \ingroup sysgeneral 
//! @{
typedef enum _LWAPI_SYS_POWER_STATUS 
{ 
    LWAPI_SYS_EXTERNAL_POWER_STATUS_CONNECTED         = 0x00, 
    LWAPI_SYS_EXTERNAL_POWER_STATUS_NOT_CONNECTED     = 0x01,
} LWAPI_SYS_EXTERNAL_POWER_STATUS; 
 
typedef struct _LW_SYS_GPU_POWER_STATUS_V1
{ 
    LwU32                                   version;                     //! < structure version 
    LwU8                                    busNumber;                   //! < PCI bus number 
    LWAPI_SYS_EXTERNAL_POWER_STATUS         externalPowerStatus;         //! < External power Status 
} LW_SYS_GPU_POWER_STATUS_V1; 
typedef LW_SYS_GPU_POWER_STATUS_V1    LW_SYS_GPU_POWER_STATUS;
#define LW_SYS_GPU_POWER_STATUS_VER1  MAKE_LWAPI_VERSION(LW_SYS_GPU_POWER_STATUS_V1,1)
#define LW_SYS_GPU_POWER_STATUS_VER   LW_SYS_GPU_POWER_STATUS_VER1
 
typedef struct _LW_SYS_POWER_STATUS_V1
{ 
    LwU32                                   version;                     //! < structure version 
    LW_SYS_GPU_POWER_STATUS                *pGpuPowerStatus;             //! < power status for GPU list 
    LwU32                                   gpuCount;                    //! < number of GPUs 
} LW_SYS_POWER_STATUS_V1; 
typedef LW_SYS_POWER_STATUS_V1    LW_SYS_POWER_STATUS;
#define LW_SYS_POWER_STATUS_VER1  MAKE_LWAPI_VERSION(LW_SYS_POWER_STATUS_V1,1)
#define LW_SYS_POWER_STATUS_VER   LW_SYS_POWER_STATUS_VER1
//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SYS_GetPowerStatus
//
//!   DESCRIPTION: This API returns the power status for each LWPU GPU in the system.
//!                The caller ilwokes this API with pGpuPowerStatus = NULL: only the gpuCount is returned, so 
//!                the caller can allocate pGpuPowerStatus and ilwoke the API again to have it filled.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in,out] pPowerStatus         Pointer to LW_SYS_POWER_STATUS structure. 
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetPowerStatus(__inout LW_SYS_POWER_STATUS *pPowerStatus); 



//! \ingroup sysgeneral
typedef struct _LW_SYS_JT_CAPS
{
    LwU32 version;                                    //!< Structure version

    LwU32 isJTEnabled:1;                              //!< 0   :JT Disabled (default).
                                                      //!< 1   :JT Enabled.
    LwU32 LWSREnabled:2;                              //!< 0   :LWSR Disabled (default).
                                                      //!< 1   :LWSR Enabled.
                                                      //!< 2~3 :Reserved
    LwU32 PanelPowerRail:2;                           //!< 0   :Panel & Backlight are powered independent of GPU Power, controlled by FB_CLAMP (default when GC6 is enabled).
                                                      //!< 1   :Same as 0 but with separate control independent of FB_CLAMP.
                                                      //!< 2   :Same as 0 but Panel & Backlight can remain powered in S1 & S3 System Suspend states.
    LwU32 SelfRefreshControllerPowerRail:1;           //!< 0 : SRC remains powered while Panel is powered (default)
                                                      //!< 1 : SRC is powered by Suspend power-rail. (required for S3-SR)
    LwU32 FBPowerRail:2;                              //!< 0   :Standard layout (default for GC6).
                                                      //!< 1   :Isolation and Split Power Rails (GC6-SplitRail).
                                                      //!< 2~3 :Reserved
    LwU32 GPUPowerRail:2;                             //!< 0   :Combined power rail for all GPU (default for single GPU).
                                                      //!< 1   :Separate power rail per-GPU (Required for SLI).
                                                      //!< 2~3 :Reserved
    LwU32 GC6ROM: 1;                                  //!< 0   :External SPI ROM (default)
                                                      //!< 1   :Integrated ROM
    LwU32 PanicTrapHandler: 1;                        //!< 0   :Has SMI handler to handle kernel panic exit while within GC6 (default)
                                                      //!< 1   :No SMI Handler
    LwU32 reserved:20;
} LW_SYS_JT_CAPS_V1;

//! \ingroup sysgeneral
typedef LW_SYS_JT_CAPS_V1     LW_SYS_JT_CAPS;

//! \ingroup sysgeneral
#define LW_SYS_JT_CAPS_VER1   MAKE_LWAPI_VERSION(LW_SYS_JT_CAPS_V1, 1)

//! \ingroup sysgeneral
#define LW_SYS_JT_CAPS_VER    LW_SYS_JT_CAPS_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   LwAPI_SYS_GetJTCaps
//
//! DESCRIPTION:     This API call is used to query for JT(Jefferson Technology) capability of the system. 
//!                  
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in,out]    *jtCaps   Structure containing the out data. This data is returned from SBIOS
//!                               by making an ACPI call to return the capabilities of the platform and status.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetJTCaps(__inout LW_SYS_JT_CAPS *jtCaps);

#define LW_MAX_HW_LWRSOR_BYTES 16384
//! This value should be in sync with LW_ESC_LWAPI_MAX_HW_LWRSOR_BYTES.
//! This comment should not go in headers other than private.


//! \ingroup sysgeneral
typedef enum _LW_LWRSOR_COLOR_FORMAT_FLAGS
{
    LW_LWRSOR_COLOR_FORMAT_NONE          = 0, 
    LW_LWRSOR_COLOR_FORMAT_MONOCHROME    = 1,
    LW_LWRSOR_COLOR_FORMAT_COLOR         = 2,
    LW_LWRSOR_COLOR_FORMAT_MASKED_COLOR  = 3,
} LW_LWRSOR_COLOR_FORMAT_FLAGS;

//! \ingroup sysgeneral
typedef struct _LW_BIT_MAP_DATA
{
    LwU64   ulWidth;      
    LwU64   ulHeight;     
    LwU64   ulPitch;      
    LwU64   ulPlanes;     
    LwU64   ulDepth;      
    LwU8    pBits[LW_MAX_HW_LWRSOR_BYTES]; 
} LW_BIT_MAP_DATA;

//! \ingroup sysgeneral
typedef struct _LW_LWRSOR_INFO
{
    LwU32 version;                              //!< Structure version

    LwU8  isVisible;                            //!< OUT
    LwU32 xHot;                                 //!< OUT
    LwU32 yHot;                                 //!< OUT
    LW_LWRSOR_COLOR_FORMAT_FLAGS formatFlag;    //!< OUT
    LW_BIT_MAP_DATA bitMapData;    
} LW_LWRSOR_INFO_V1;

//! \ingroup sysgeneral
typedef LW_LWRSOR_INFO_V1     LW_LWRSOR_INFO;
#define LW_LWRSOR_INFO_VER1   MAKE_LWAPI_VERSION(LW_LWRSOR_INFO_V1,1)
#define LW_LWRSOR_INFO_VER    LW_LWRSOR_INFO_VER1

////////////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: LwAPI_SYS_GetLwrsorInfo
//
//! DESCRIPTION: This API gets the cursor bit map information.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [inout] lwrsorBitMapInfo  -  Structure containing cursor bit map info.
//!
//! \return : This API can return any of the error codes enumerated in #LwAPI_Status. 
//!  If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
////////////////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetLwrsorInfo(LW_LWRSOR_INFO *lwrsorBitMapInfo);




typedef enum _LW_SYS__MODULE
{
    LW_SYS_MODULE_Cache = 1,      //!< cache memory controller
    LW_SYS_MODULE_Vcp,            //!< vector co-processor
    LW_SYS_MODULE_Host1x,         //!< host1x clock domain
    LW_SYS_MODULE_Display,        //!< display clock domain for display controller
    LW_SYS_MODULE_Ide,            //!< IDE controller
    LW_SYS_MODULE_3d,             //!< 3D graphics clock domain
    LW_SYS_MODULE_Isp,            //!< image signal processor 
    LW_SYS_MODULE_Usb,            //!< USB2 OTG controller
    LW_SYS_MODULE_2d,             //!< 2D graphics clock domain
    LW_SYS_MODULE_Vi,             //!< video input
    LW_SYS_MODULE_Epp,            //!< encoder pre-processor 
    LW_SYS_MODULE_I2s,            //!< I2S controller
    LW_SYS_MODULE_Pwm,            //!< Pulse Width Modulator controller
    LW_SYS_MODULE_Twc,            //!< Three Wire controller
    LW_SYS_MODULE_Hsmmc,          //!< HSMMC controller
    LW_SYS_MODULE_Sdio,           //!< SDIO controller
    LW_SYS_MODULE_NandFlash,      //!< NAND controller
    LW_SYS_MODULE_NandSpeed,      //!< NAND Speed controller module
    LW_SYS_MODULE_I2c,            //!< I2C controller
    LW_SYS_MODULE_Spdif,          //!< Sony Phillips Digital Interface Format controller
    LW_SYS_MODULE_Gpio,           //!< GPIO controller
    LW_SYS_MODULE_Uart,           //!< UART controller
    LW_SYS_MODULE_Timer,          //!< timer controller
    LW_SYS_MODULE_Rtc,            //!< realtime clock controller
    LW_SYS_MODULE_Ac97,           //!< Audio Codec 97 controller
    LW_SYS_MODULE_Coprocessor,    //!< audio/video processor
    LW_SYS_MODULE_Cpu,            //!< application processor
    LW_SYS_MODULE_Bsev,           //!< 
    LW_SYS_MODULE_Bsea,           //!< Audio Bit Stream Engine
    LW_SYS_MODULE_Vde,            //!< video decoder
    LW_SYS_MODULE_Mpe,            //!< Motion Picture Encoder
    LW_SYS_MODULE_Emc,            //!< external memory
    LW_SYS_MODULE_Sprom,          //!< 
    LW_SYS_MODULE_Tvdac,          //!< TVO controller module - TVDAC clock
    LW_SYS_MODULE_Csi,            //!< Camera Serial Interface
    LW_SYS_MODULE_Hdmi,           //!< HDMI
    LW_SYS_MODULE_MipiBaseband,   //!< MIPI baseband controller 
    LW_SYS_MODULE_Tvo,            //!< 
    LW_SYS_MODULE_Dsi,            //!< serial display
    LW_SYS_MODULE_Dvc,            //!< Dynamic Voltage Controller
    LW_SYS_MODULE_Sbc,            //!< SBC controller module
    LW_SYS_MODULE_Xio,            //!< eXtended I/O controller
    LW_SYS_MODULE_Spi,            //!< SPI controller
    LW_SYS_MODULE_NorFlash,       //!< NOR controller
    LW_SYS_MODULE_Slc,            //!< SLink controller
    LW_SYS_MODULE_Fuse,           //!< FUSE controller
    LW_SYS_MODULE_Pmc,            //!< PMIF controller
    LW_SYS_MODULE_StatMon,        //!< system statistics monitor controller
    LW_SYS_MODULE_Kbc,            //!< keyboard controller
    LW_SYS_MODULE_Vg,             //!< VG graphics controller
    LW_SYS_MODULE_ApbDma,         //!< APB DMA controller
    LW_SYS_MODULE_Mc,             //!< memory controller (internal memory and memory arbitration)
    LW_SYS_MODULE_SpdifIn,        //!< S/PDIF controller module - S/PDIF IN clock
    LW_SYS_MODULE_Vfir,           //!< very fast infra-red controller
    LW_SYS_MODULE_Cve,            //!< TVO controller module - CVE clock
    LW_SYS_MODULE_ViSensor,       //!< VI controller module - VI sensor clock
    LW_SYS_MODULE_SystemReset,    //!< specifies entire system, not a valid clock module
    LW_SYS_MODULE_AvpUcq,         //!< AVP UCQ module
    LW_SYS_MODULE_KFuse,          //!< KFUSE controller
    LW_SYS_MODULE_OneWire,        //!< one-wire interface controller
    LW_SYS_MODULE_SyncNor,        //!< sync NOR controller
    LW_SYS_MODULE_Pcie,           //!< Pci express bridge
    LW_SYS_MODULE_Mselect,        //!< memory configuration
    LW_SYS_MODULE_Sata,           //!< sata
    LW_SYS_MODULE_SataOob,        //!< SATA OOB controller module
    LW_SYS_MODULE_HDA,            //!< HD-Audio
    LW_SYS_MODULE_HDA2CODEC,      //!< HDA to Codec X2 controller module
    LW_SYS_MODULE_Apbif,          //!< Advance Peripherial Bus
    LW_SYS_MODULE_MSENC,          //!< video encoder
    LW_SYS_MODULE_DTV,            //!< dtv
    LW_SYS_MODULE_Tsensor,        //!< tsensor
    LW_SYS_MODULE_Atomics,        //!< atomics
    LW_SYS_MODULE_Actmon,         //!< Activity Monitor
    LW_SYS_MODULE_Se,             //!< security engine 
    LW_SYS_MODULE_DAM,            //!< Digital Audio Mixer
    LW_SYS_MODULE_Audio,          //!< audio
    LW_SYS_MODULE_Num,
    LW_SYS_MODULE_UNDEFINED = 0xffffffff,
} LW_SYS_MODULE;


typedef struct 
{
    LwU32                  version;                     //!<  Structure version
    LW_SYS_MODULE          clkModule;    
    LwU32                  instance;                    //!< Instance of module example 0, 1,2 ...               
    LwU32                  frequency;                   //!< Clock frequency (KHz)
    LwU32                  reserved;   
        
} LW_SYS_CLOCK_INFO_V1;

typedef LW_SYS_CLOCK_INFO_V1    LW_SYS_CLOCK_INFO;

#define LW_SYS_CLOCK_INFO_VER1  MAKE_LWAPI_VERSION(LW_SYS_CLOCK_INFO_V1,1)
#define LW_SYS_CLOCK_INFO_VER   LW_SYS_CLOCK_INFO_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SYS_GetClockInfo
//
//! This API returns all clocks on ARM platform 
//!
//! HOW TO USE: 1) make a call to get the number of domains(numSupportedDomain)
//!                using LwAPI_SYS_GetAllClocks by passing the clockInfo as NULL
//!                On call success:
//!             2) Allocate memory (numSupportedDomain * sizeof(LW_SYS_CLOCK_INFO)) based on numSupportedDomain then make a call LwAPI_SYS_GetClockInfo to populate clockInfo
//!
//! SUPPORTED OS:  Windows 8 and higher
//!
//! PARAMETERS:     clockInfo(OUT)  - Pointer to an LW_SYS_CLOCK_INFO struct, each entry represents an instance of module and its attributes
//!                 numSupportedDomain(OUT)- Number of all instances of all modules.
//!                 flags (IN) - reserved(not used yet)
//! \since 
//!  Version: 295.00
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//! \retval        LWAPI_INSUFFICIENT_BUFFER  When the input buffer(clockInfo) is less than the actual number of domains, this API 
//!                                           will return LWAPI_INSUFFICIENT_BUFFER. 
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_GetClockInfo(__out_ecount_full_opt(*numSupportedDomain)LW_SYS_CLOCK_INFO* clockInfo, __inout LwU32* numSupportedDomain, __in LwU32 flags);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SYS_EnableDVFS
//
//! This API enables or disables DVFS. (Dynamic Voltage and Frequency Scaling)
//!
//! SUPPORTED OS:  Windows 8 and higher
//!
//!
//! \param [in] bEnable  -  (Boolean) Enable or disable DVFS.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_EnableDVFS(__in LwU8 bEnable);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_SYS_SetLowestPowerState
//
//! This API sets the lowest power state
//!
//! SUPPORTED OS:  Windows 8 and higher
//!
//!
//! \param [in] lowestPowerState  -  New lowest power state.
//!
//! \return  This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_SYS_SetLowestPowerState(__in LwU32 lowestPowerState);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: LwAPI_Power_Unload
//
//! This function unloads LWAPI library (lwPowerApi.dll)
//! 
//!
//! SUPPORTED OS:  Windows 8 and higher
//!
//!
//! \since 
//!  Version: 295.00
//!
//! \return        This API can return any of the error codes enumerated in #LwAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//! \ingroup lwapifunctions
///////////////////////////////////////////////////////////////////////////////
LWAPI_INTERFACE LwAPI_Power_Unload();


#if (((defined(WIN32) || defined(_WIN32)) && defined(_MSC_VER) && (_MSC_VER <= 1399) && !defined(LWAPI_INTERNAL)) || defined(LWAPI_DEPRECATED_OLD))
#pragma deprecated( LwAPI_SetView, LwAPI_SetViewEx, LwAPI_GetDisplayDriverVersion, LwAPI_GetDisplayDriverMemoryInfo, LwAPI_GetDriverMemoryInfo, LwAPI_EnumAppStatistics, LwAPI_GetPhysicalGPUsFromLogicalGPUInEngineOrder, LwAPI_GPU_GetAllOutputs, LwAPI_GPU_GetConnectedOutputs, LwAPI_GPU_GetConnectedSLIOutputs, LwAPI_GPU_GetConnectedOutputsEx, LwAPI_GPU_GetConnectedOutputsWithLidState, LwAPI_GPU_GetConnectedSLIOutputsWithLidState, LwAPI_GPU_GetConnectedOutputsWithLidStateEx, LwAPI_GPU_GetConnectedSLIOutputsWithLidStateEx, LwAPI_GPU_GetPstatesInfoEx, LwAPI_GPU_PowerLeakageGetStatus, LwAPI_GPU_LwdaEnumComputeCapableGpus, LwAPI_GetTiming, LwAPI_EnumLwstomDisplay, LwAPI_TryLwstomDisplay, LwAPI_RevertLwstomDisplayTrial, LwAPI_DeleteLwstomDisplay, LwAPI_SaveLwstomDisplay, LwAPI_GetView, LwAPI_GetViewEx, LwAPI_SetViewExInternal, LwAPI_Diag_DPCD, LwAPI_Diag_DP_TestPattern, LwAPI_Diag_DP_LaneData, LwAPI_GSync_QueryTopology, LwAPI_GSync_EnableSync, LwAPI_GSync_DisableSync, LwAPI_GSync_SetSyncState, LwAPI_GSync_UpdateSyncPolarity, LwAPI_GSync_UpdateVideoMode, LwAPI_GSync_UpdateSyncInterval, LwAPI_GSync_UpdateSyncSkew, LwAPI_GSync_UpdateSyncStartDelay, LwAPI_GSync_UpdateSyncSource, LwAPI_GSync_QuerySyncParameters, LwAPI_GSync_QuerySyncStatus, LwAPI_GSync_UpdateInterlaceMode, LwAPI_GSync_QueryInterlaceMode, LwAPI_VIO_SetCSC, LwAPI_VIO_GetCSC, LwAPI_VIO_SetGamma, LwAPI_VIO_GetGamma, LwAPI_VIO_SetSyncDelay, LwAPI_VIO_GetSyncDelay, LwAPI_SelwreAudio_GetSelwreAudioAPIRevision )
#endif

#ifndef __LWAPI_EMPTY_SAL
#ifdef __lwapi_undef__ecount
    #undef __ecount
    #undef __lwapi_undef__ecount
#endif
#ifdef __lwapi_undef__bcount
    #undef __bcount
    #undef __lwapi_undef__bcount
#endif
#ifdef __lwapi_undef__in
    #undef __in
    #undef __lwapi_undef__in
#endif
#ifdef __lwapi_undef__in_ecount
    #undef __in_ecount
    #undef __lwapi_undef__in_ecount
#endif
#ifdef __lwapi_undef__in_bcount
    #undef __in_bcount
    #undef __lwapi_undef__in_bcount
#endif
#ifdef __lwapi_undef__in_z
    #undef __in_z
    #undef __lwapi_undef__in_z
#endif
#ifdef __lwapi_undef__in_ecount_z
    #undef __in_ecount_z
    #undef __lwapi_undef__in_ecount_z
#endif
#ifdef __lwapi_undef__in_bcount_z
    #undef __in_bcount_z
    #undef __lwapi_undef__in_bcount_z
#endif
#ifdef __lwapi_undef__in_nz
    #undef __in_nz
    #undef __lwapi_undef__in_nz
#endif
#ifdef __lwapi_undef__in_ecount_nz
    #undef __in_ecount_nz
    #undef __lwapi_undef__in_ecount_nz
#endif
#ifdef __lwapi_undef__in_bcount_nz
    #undef __in_bcount_nz
    #undef __lwapi_undef__in_bcount_nz
#endif
#ifdef __lwapi_undef__out
    #undef __out
    #undef __lwapi_undef__out
#endif
#ifdef __lwapi_undef__out_ecount
    #undef __out_ecount
    #undef __lwapi_undef__out_ecount
#endif
#ifdef __lwapi_undef__out_bcount
    #undef __out_bcount
    #undef __lwapi_undef__out_bcount
#endif
#ifdef __lwapi_undef__out_ecount_part
    #undef __out_ecount_part
    #undef __lwapi_undef__out_ecount_part
#endif
#ifdef __lwapi_undef__out_bcount_part
    #undef __out_bcount_part
    #undef __lwapi_undef__out_bcount_part
#endif
#ifdef __lwapi_undef__out_ecount_full
    #undef __out_ecount_full
    #undef __lwapi_undef__out_ecount_full
#endif
#ifdef __lwapi_undef__out_bcount_full
    #undef __out_bcount_full
    #undef __lwapi_undef__out_bcount_full
#endif
#ifdef __lwapi_undef__out_z
    #undef __out_z
    #undef __lwapi_undef__out_z
#endif
#ifdef __lwapi_undef__out_z_opt
    #undef __out_z_opt
    #undef __lwapi_undef__out_z_opt
#endif
#ifdef __lwapi_undef__out_ecount_z
    #undef __out_ecount_z
    #undef __lwapi_undef__out_ecount_z
#endif
#ifdef __lwapi_undef__out_bcount_z
    #undef __out_bcount_z
    #undef __lwapi_undef__out_bcount_z
#endif
#ifdef __lwapi_undef__out_ecount_part_z
    #undef __out_ecount_part_z
    #undef __lwapi_undef__out_ecount_part_z
#endif
#ifdef __lwapi_undef__out_bcount_part_z
    #undef __out_bcount_part_z
    #undef __lwapi_undef__out_bcount_part_z
#endif
#ifdef __lwapi_undef__out_ecount_full_z
    #undef __out_ecount_full_z
    #undef __lwapi_undef__out_ecount_full_z
#endif
#ifdef __lwapi_undef__out_bcount_full_z
    #undef __out_bcount_full_z
    #undef __lwapi_undef__out_bcount_full_z
#endif
#ifdef __lwapi_undef__out_nz
    #undef __out_nz
    #undef __lwapi_undef__out_nz
#endif
#ifdef __lwapi_undef__out_nz_opt
    #undef __out_nz_opt
    #undef __lwapi_undef__out_nz_opt
#endif
#ifdef __lwapi_undef__out_ecount_nz
    #undef __out_ecount_nz
    #undef __lwapi_undef__out_ecount_nz
#endif
#ifdef __lwapi_undef__out_bcount_nz
    #undef __out_bcount_nz
    #undef __lwapi_undef__out_bcount_nz
#endif
#ifdef __lwapi_undef__inout
    #undef __inout
    #undef __lwapi_undef__inout
#endif
#ifdef __lwapi_undef__inout_ecount
    #undef __inout_ecount
    #undef __lwapi_undef__inout_ecount
#endif
#ifdef __lwapi_undef__inout_bcount
    #undef __inout_bcount
    #undef __lwapi_undef__inout_bcount
#endif
#ifdef __lwapi_undef__inout_ecount_part
    #undef __inout_ecount_part
    #undef __lwapi_undef__inout_ecount_part
#endif
#ifdef __lwapi_undef__inout_bcount_part
    #undef __inout_bcount_part
    #undef __lwapi_undef__inout_bcount_part
#endif
#ifdef __lwapi_undef__inout_ecount_full
    #undef __inout_ecount_full
    #undef __lwapi_undef__inout_ecount_full
#endif
#ifdef __lwapi_undef__inout_bcount_full
    #undef __inout_bcount_full
    #undef __lwapi_undef__inout_bcount_full
#endif
#ifdef __lwapi_undef__inout_z
    #undef __inout_z
    #undef __lwapi_undef__inout_z
#endif
#ifdef __lwapi_undef__inout_ecount_z
    #undef __inout_ecount_z
    #undef __lwapi_undef__inout_ecount_z
#endif
#ifdef __lwapi_undef__inout_bcount_z
    #undef __inout_bcount_z
    #undef __lwapi_undef__inout_bcount_z
#endif
#ifdef __lwapi_undef__inout_nz
    #undef __inout_nz
    #undef __lwapi_undef__inout_nz
#endif
#ifdef __lwapi_undef__inout_ecount_nz
    #undef __inout_ecount_nz
    #undef __lwapi_undef__inout_ecount_nz
#endif
#ifdef __lwapi_undef__inout_bcount_nz
    #undef __inout_bcount_nz
    #undef __lwapi_undef__inout_bcount_nz
#endif
#ifdef __lwapi_undef__ecount_opt
    #undef __ecount_opt
    #undef __lwapi_undef__ecount_opt
#endif
#ifdef __lwapi_undef__bcount_opt
    #undef __bcount_opt
    #undef __lwapi_undef__bcount_opt
#endif
#ifdef __lwapi_undef__in_opt
    #undef __in_opt
    #undef __lwapi_undef__in_opt
#endif
#ifdef __lwapi_undef__in_ecount_opt
    #undef __in_ecount_opt
    #undef __lwapi_undef__in_ecount_opt
#endif
#ifdef __lwapi_undef__in_bcount_opt
    #undef __in_bcount_opt
    #undef __lwapi_undef__in_bcount_opt
#endif
#ifdef __lwapi_undef__in_z_opt
    #undef __in_z_opt
    #undef __lwapi_undef__in_z_opt
#endif
#ifdef __lwapi_undef__in_ecount_z_opt
    #undef __in_ecount_z_opt
    #undef __lwapi_undef__in_ecount_z_opt
#endif
#ifdef __lwapi_undef__in_bcount_z_opt
    #undef __in_bcount_z_opt
    #undef __lwapi_undef__in_bcount_z_opt
#endif
#ifdef __lwapi_undef__in_nz_opt
    #undef __in_nz_opt
    #undef __lwapi_undef__in_nz_opt
#endif
#ifdef __lwapi_undef__in_ecount_nz_opt
    #undef __in_ecount_nz_opt
    #undef __lwapi_undef__in_ecount_nz_opt
#endif
#ifdef __lwapi_undef__in_bcount_nz_opt
    #undef __in_bcount_nz_opt
    #undef __lwapi_undef__in_bcount_nz_opt
#endif
#ifdef __lwapi_undef__out_opt
    #undef __out_opt
    #undef __lwapi_undef__out_opt
#endif
#ifdef __lwapi_undef__out_ecount_opt
    #undef __out_ecount_opt
    #undef __lwapi_undef__out_ecount_opt
#endif
#ifdef __lwapi_undef__out_bcount_opt
    #undef __out_bcount_opt
    #undef __lwapi_undef__out_bcount_opt
#endif
#ifdef __lwapi_undef__out_ecount_part_opt
    #undef __out_ecount_part_opt
    #undef __lwapi_undef__out_ecount_part_opt
#endif
#ifdef __lwapi_undef__out_bcount_part_opt
    #undef __out_bcount_part_opt
    #undef __lwapi_undef__out_bcount_part_opt
#endif
#ifdef __lwapi_undef__out_ecount_full_opt
    #undef __out_ecount_full_opt
    #undef __lwapi_undef__out_ecount_full_opt
#endif
#ifdef __lwapi_undef__out_bcount_full_opt
    #undef __out_bcount_full_opt
    #undef __lwapi_undef__out_bcount_full_opt
#endif
#ifdef __lwapi_undef__out_ecount_z_opt
    #undef __out_ecount_z_opt
    #undef __lwapi_undef__out_ecount_z_opt
#endif
#ifdef __lwapi_undef__out_bcount_z_opt
    #undef __out_bcount_z_opt
    #undef __lwapi_undef__out_bcount_z_opt
#endif
#ifdef __lwapi_undef__out_ecount_part_z_opt
    #undef __out_ecount_part_z_opt
    #undef __lwapi_undef__out_ecount_part_z_opt
#endif
#ifdef __lwapi_undef__out_bcount_part_z_opt
    #undef __out_bcount_part_z_opt
    #undef __lwapi_undef__out_bcount_part_z_opt
#endif
#ifdef __lwapi_undef__out_ecount_full_z_opt
    #undef __out_ecount_full_z_opt
    #undef __lwapi_undef__out_ecount_full_z_opt
#endif
#ifdef __lwapi_undef__out_bcount_full_z_opt
    #undef __out_bcount_full_z_opt
    #undef __lwapi_undef__out_bcount_full_z_opt
#endif
#ifdef __lwapi_undef__out_ecount_nz_opt
    #undef __out_ecount_nz_opt
    #undef __lwapi_undef__out_ecount_nz_opt
#endif
#ifdef __lwapi_undef__out_bcount_nz_opt
    #undef __out_bcount_nz_opt
    #undef __lwapi_undef__out_bcount_nz_opt
#endif
#ifdef __lwapi_undef__inout_opt
    #undef __inout_opt
    #undef __lwapi_undef__inout_opt
#endif
#ifdef __lwapi_undef__inout_ecount_opt
    #undef __inout_ecount_opt
    #undef __lwapi_undef__inout_ecount_opt
#endif
#ifdef __lwapi_undef__inout_bcount_opt
    #undef __inout_bcount_opt
    #undef __lwapi_undef__inout_bcount_opt
#endif
#ifdef __lwapi_undef__inout_ecount_part_opt
    #undef __inout_ecount_part_opt
    #undef __lwapi_undef__inout_ecount_part_opt
#endif
#ifdef __lwapi_undef__inout_bcount_part_opt
    #undef __inout_bcount_part_opt
    #undef __lwapi_undef__inout_bcount_part_opt
#endif
#ifdef __lwapi_undef__inout_ecount_full_opt
    #undef __inout_ecount_full_opt
    #undef __lwapi_undef__inout_ecount_full_opt
#endif
#ifdef __lwapi_undef__inout_bcount_full_opt
    #undef __inout_bcount_full_opt
    #undef __lwapi_undef__inout_bcount_full_opt
#endif
#ifdef __lwapi_undef__inout_z_opt
    #undef __inout_z_opt
    #undef __lwapi_undef__inout_z_opt
#endif
#ifdef __lwapi_undef__inout_ecount_z_opt
    #undef __inout_ecount_z_opt
    #undef __lwapi_undef__inout_ecount_z_opt
#endif
#ifdef __lwapi_undef__inout_ecount_z_opt
    #undef __inout_ecount_z_opt
    #undef __lwapi_undef__inout_ecount_z_opt
#endif
#ifdef __lwapi_undef__inout_bcount_z_opt
    #undef __inout_bcount_z_opt
    #undef __lwapi_undef__inout_bcount_z_opt
#endif
#ifdef __lwapi_undef__inout_nz_opt
    #undef __inout_nz_opt
    #undef __lwapi_undef__inout_nz_opt
#endif
#ifdef __lwapi_undef__inout_ecount_nz_opt
    #undef __inout_ecount_nz_opt
    #undef __lwapi_undef__inout_ecount_nz_opt
#endif
#ifdef __lwapi_undef__inout_bcount_nz_opt
    #undef __inout_bcount_nz_opt
    #undef __lwapi_undef__inout_bcount_nz_opt
#endif
#ifdef __lwapi_undef__deref_ecount
    #undef __deref_ecount
    #undef __lwapi_undef__deref_ecount
#endif
#ifdef __lwapi_undef__deref_bcount
    #undef __deref_bcount
    #undef __lwapi_undef__deref_bcount
#endif
#ifdef __lwapi_undef__deref_out
    #undef __deref_out
    #undef __lwapi_undef__deref_out
#endif
#ifdef __lwapi_undef__deref_out_ecount
    #undef __deref_out_ecount
    #undef __lwapi_undef__deref_out_ecount
#endif
#ifdef __lwapi_undef__deref_out_bcount
    #undef __deref_out_bcount
    #undef __lwapi_undef__deref_out_bcount
#endif
#ifdef __lwapi_undef__deref_out_ecount_part
    #undef __deref_out_ecount_part
    #undef __lwapi_undef__deref_out_ecount_part
#endif
#ifdef __lwapi_undef__deref_out_bcount_part
    #undef __deref_out_bcount_part
    #undef __lwapi_undef__deref_out_bcount_part
#endif
#ifdef __lwapi_undef__deref_out_ecount_full
    #undef __deref_out_ecount_full
    #undef __lwapi_undef__deref_out_ecount_full
#endif
#ifdef __lwapi_undef__deref_out_bcount_full
    #undef __deref_out_bcount_full
    #undef __lwapi_undef__deref_out_bcount_full
#endif
#ifdef __lwapi_undef__deref_out_z
    #undef __deref_out_z
    #undef __lwapi_undef__deref_out_z
#endif
#ifdef __lwapi_undef__deref_out_ecount_z
    #undef __deref_out_ecount_z
    #undef __lwapi_undef__deref_out_ecount_z
#endif
#ifdef __lwapi_undef__deref_out_bcount_z
    #undef __deref_out_bcount_z
    #undef __lwapi_undef__deref_out_bcount_z
#endif
#ifdef __lwapi_undef__deref_out_nz
    #undef __deref_out_nz
    #undef __lwapi_undef__deref_out_nz
#endif
#ifdef __lwapi_undef__deref_out_ecount_nz
    #undef __deref_out_ecount_nz
    #undef __lwapi_undef__deref_out_ecount_nz
#endif
#ifdef __lwapi_undef__deref_out_bcount_nz
    #undef __deref_out_bcount_nz
    #undef __lwapi_undef__deref_out_bcount_nz
#endif
#ifdef __lwapi_undef__deref_inout
    #undef __deref_inout
    #undef __lwapi_undef__deref_inout
#endif
#ifdef __lwapi_undef__deref_inout_z
    #undef __deref_inout_z
    #undef __lwapi_undef__deref_inout_z
#endif
#ifdef __lwapi_undef__deref_inout_ecount
    #undef __deref_inout_ecount
    #undef __lwapi_undef__deref_inout_ecount
#endif
#ifdef __lwapi_undef__deref_inout_bcount
    #undef __deref_inout_bcount
    #undef __lwapi_undef__deref_inout_bcount
#endif
#ifdef __lwapi_undef__deref_inout_ecount_part
    #undef __deref_inout_ecount_part
    #undef __lwapi_undef__deref_inout_ecount_part
#endif
#ifdef __lwapi_undef__deref_inout_bcount_part
    #undef __deref_inout_bcount_part
    #undef __lwapi_undef__deref_inout_bcount_part
#endif
#ifdef __lwapi_undef__deref_inout_ecount_full
    #undef __deref_inout_ecount_full
    #undef __lwapi_undef__deref_inout_ecount_full
#endif
#ifdef __lwapi_undef__deref_inout_bcount_full
    #undef __deref_inout_bcount_full
    #undef __lwapi_undef__deref_inout_bcount_full
#endif
#ifdef __lwapi_undef__deref_inout_z
    #undef __deref_inout_z
    #undef __lwapi_undef__deref_inout_z
#endif
#ifdef __lwapi_undef__deref_inout_ecount_z
    #undef __deref_inout_ecount_z
    #undef __lwapi_undef__deref_inout_ecount_z
#endif
#ifdef __lwapi_undef__deref_inout_bcount_z
    #undef __deref_inout_bcount_z
    #undef __lwapi_undef__deref_inout_bcount_z
#endif
#ifdef __lwapi_undef__deref_inout_nz
    #undef __deref_inout_nz
    #undef __lwapi_undef__deref_inout_nz
#endif
#ifdef __lwapi_undef__deref_inout_ecount_nz
    #undef __deref_inout_ecount_nz
    #undef __lwapi_undef__deref_inout_ecount_nz
#endif
#ifdef __lwapi_undef__deref_inout_bcount_nz
    #undef __deref_inout_bcount_nz
    #undef __lwapi_undef__deref_inout_bcount_nz
#endif
#ifdef __lwapi_undef__deref_ecount_opt
    #undef __deref_ecount_opt
    #undef __lwapi_undef__deref_ecount_opt
#endif
#ifdef __lwapi_undef__deref_bcount_opt
    #undef __deref_bcount_opt
    #undef __lwapi_undef__deref_bcount_opt
#endif
#ifdef __lwapi_undef__deref_out_opt
    #undef __deref_out_opt
    #undef __lwapi_undef__deref_out_opt
#endif
#ifdef __lwapi_undef__deref_out_ecount_opt
    #undef __deref_out_ecount_opt
    #undef __lwapi_undef__deref_out_ecount_opt
#endif
#ifdef __lwapi_undef__deref_out_bcount_opt
    #undef __deref_out_bcount_opt
    #undef __lwapi_undef__deref_out_bcount_opt
#endif
#ifdef __lwapi_undef__deref_out_ecount_part_opt
    #undef __deref_out_ecount_part_opt
    #undef __lwapi_undef__deref_out_ecount_part_opt
#endif
#ifdef __lwapi_undef__deref_out_bcount_part_opt
    #undef __deref_out_bcount_part_opt
    #undef __lwapi_undef__deref_out_bcount_part_opt
#endif
#ifdef __lwapi_undef__deref_out_ecount_full_opt
    #undef __deref_out_ecount_full_opt
    #undef __lwapi_undef__deref_out_ecount_full_opt
#endif
#ifdef __lwapi_undef__deref_out_bcount_full_opt
    #undef __deref_out_bcount_full_opt
    #undef __lwapi_undef__deref_out_bcount_full_opt
#endif
#ifdef __lwapi_undef__deref_out_z_opt
    #undef __deref_out_z_opt
    #undef __lwapi_undef__deref_out_z_opt
#endif
#ifdef __lwapi_undef__deref_out_ecount_z_opt
    #undef __deref_out_ecount_z_opt
    #undef __lwapi_undef__deref_out_ecount_z_opt
#endif
#ifdef __lwapi_undef__deref_out_bcount_z_opt
    #undef __deref_out_bcount_z_opt
    #undef __lwapi_undef__deref_out_bcount_z_opt
#endif
#ifdef __lwapi_undef__deref_out_nz_opt
    #undef __deref_out_nz_opt
    #undef __lwapi_undef__deref_out_nz_opt
#endif
#ifdef __lwapi_undef__deref_out_ecount_nz_opt
    #undef __deref_out_ecount_nz_opt
    #undef __lwapi_undef__deref_out_ecount_nz_opt
#endif
#ifdef __lwapi_undef__deref_out_bcount_nz_opt
    #undef __deref_out_bcount_nz_opt
    #undef __lwapi_undef__deref_out_bcount_nz_opt
#endif
#ifdef __lwapi_undef__deref_inout_opt
    #undef __deref_inout_opt
    #undef __lwapi_undef__deref_inout_opt
#endif
#ifdef __lwapi_undef__deref_inout_ecount_opt
    #undef __deref_inout_ecount_opt
    #undef __lwapi_undef__deref_inout_ecount_opt
#endif
#ifdef __lwapi_undef__deref_inout_bcount_opt
    #undef __deref_inout_bcount_opt
    #undef __lwapi_undef__deref_inout_bcount_opt
#endif
#ifdef __lwapi_undef__deref_inout_ecount_part_opt
    #undef __deref_inout_ecount_part_opt
    #undef __lwapi_undef__deref_inout_ecount_part_opt
#endif
#ifdef __lwapi_undef__deref_inout_bcount_part_opt
    #undef __deref_inout_bcount_part_opt
    #undef __lwapi_undef__deref_inout_bcount_part_opt
#endif
#ifdef __lwapi_undef__deref_inout_ecount_full_opt
    #undef __deref_inout_ecount_full_opt
    #undef __lwapi_undef__deref_inout_ecount_full_opt
#endif
#ifdef __lwapi_undef__deref_inout_bcount_full_opt
    #undef __deref_inout_bcount_full_opt
    #undef __lwapi_undef__deref_inout_bcount_full_opt
#endif
#ifdef __lwapi_undef__deref_inout_z_opt
    #undef __deref_inout_z_opt
    #undef __lwapi_undef__deref_inout_z_opt
#endif
#ifdef __lwapi_undef__deref_inout_ecount_z_opt
    #undef __deref_inout_ecount_z_opt
    #undef __lwapi_undef__deref_inout_ecount_z_opt
#endif
#ifdef __lwapi_undef__deref_inout_bcount_z_opt
    #undef __deref_inout_bcount_z_opt
    #undef __lwapi_undef__deref_inout_bcount_z_opt
#endif
#ifdef __lwapi_undef__deref_inout_nz_opt
    #undef __deref_inout_nz_opt
    #undef __lwapi_undef__deref_inout_nz_opt
#endif
#ifdef __lwapi_undef__deref_inout_ecount_nz_opt
    #undef __deref_inout_ecount_nz_opt
    #undef __lwapi_undef__deref_inout_ecount_nz_opt
#endif
#ifdef __lwapi_undef__deref_inout_bcount_nz_opt
    #undef __deref_inout_bcount_nz_opt
    #undef __lwapi_undef__deref_inout_bcount_nz_opt
#endif
#ifdef __lwapi_undef__deref_opt_ecount
    #undef __deref_opt_ecount
    #undef __lwapi_undef__deref_opt_ecount
#endif
#ifdef __lwapi_undef__deref_opt_bcount
    #undef __deref_opt_bcount
    #undef __lwapi_undef__deref_opt_bcount
#endif
#ifdef __lwapi_undef__deref_opt_out
    #undef __deref_opt_out
    #undef __lwapi_undef__deref_opt_out
#endif
#ifdef __lwapi_undef__deref_opt_out_z
    #undef __deref_opt_out_z
    #undef __lwapi_undef__deref_opt_out_z
#endif
#ifdef __lwapi_undef__deref_opt_out_ecount
    #undef __deref_opt_out_ecount
    #undef __lwapi_undef__deref_opt_out_ecount
#endif
#ifdef __lwapi_undef__deref_opt_out_bcount
    #undef __deref_opt_out_bcount
    #undef __lwapi_undef__deref_opt_out_bcount
#endif
#ifdef __lwapi_undef__deref_opt_out_ecount_part
    #undef __deref_opt_out_ecount_part
    #undef __lwapi_undef__deref_opt_out_ecount_part
#endif
#ifdef __lwapi_undef__deref_opt_out_bcount_part
    #undef __deref_opt_out_bcount_part
    #undef __lwapi_undef__deref_opt_out_bcount_part
#endif
#ifdef __lwapi_undef__deref_opt_out_ecount_full
    #undef __deref_opt_out_ecount_full
    #undef __lwapi_undef__deref_opt_out_ecount_full
#endif
#ifdef __lwapi_undef__deref_opt_out_bcount_full
    #undef __deref_opt_out_bcount_full
    #undef __lwapi_undef__deref_opt_out_bcount_full
#endif
#ifdef __lwapi_undef__deref_opt_inout
    #undef __deref_opt_inout
    #undef __lwapi_undef__deref_opt_inout
#endif
#ifdef __lwapi_undef__deref_opt_inout_ecount
    #undef __deref_opt_inout_ecount
    #undef __lwapi_undef__deref_opt_inout_ecount
#endif
#ifdef __lwapi_undef__deref_opt_inout_bcount
    #undef __deref_opt_inout_bcount
    #undef __lwapi_undef__deref_opt_inout_bcount
#endif
#ifdef __lwapi_undef__deref_opt_inout_ecount_part
    #undef __deref_opt_inout_ecount_part
    #undef __lwapi_undef__deref_opt_inout_ecount_part
#endif
#ifdef __lwapi_undef__deref_opt_inout_bcount_part
    #undef __deref_opt_inout_bcount_part
    #undef __lwapi_undef__deref_opt_inout_bcount_part
#endif
#ifdef __lwapi_undef__deref_opt_inout_ecount_full
    #undef __deref_opt_inout_ecount_full
    #undef __lwapi_undef__deref_opt_inout_ecount_full
#endif
#ifdef __lwapi_undef__deref_opt_inout_bcount_full
    #undef __deref_opt_inout_bcount_full
    #undef __lwapi_undef__deref_opt_inout_bcount_full
#endif
#ifdef __lwapi_undef__deref_opt_inout_z
    #undef __deref_opt_inout_z
    #undef __lwapi_undef__deref_opt_inout_z
#endif
#ifdef __lwapi_undef__deref_opt_inout_ecount_z
    #undef __deref_opt_inout_ecount_z
    #undef __lwapi_undef__deref_opt_inout_ecount_z
#endif
#ifdef __lwapi_undef__deref_opt_inout_bcount_z
    #undef __deref_opt_inout_bcount_z
    #undef __lwapi_undef__deref_opt_inout_bcount_z
#endif
#ifdef __lwapi_undef__deref_opt_inout_nz
    #undef __deref_opt_inout_nz
    #undef __lwapi_undef__deref_opt_inout_nz
#endif
#ifdef __lwapi_undef__deref_opt_inout_ecount_nz
    #undef __deref_opt_inout_ecount_nz
    #undef __lwapi_undef__deref_opt_inout_ecount_nz
#endif
#ifdef __lwapi_undef__deref_opt_inout_bcount_nz
    #undef __deref_opt_inout_bcount_nz
    #undef __lwapi_undef__deref_opt_inout_bcount_nz
#endif
#ifdef __lwapi_undef__deref_opt_ecount_opt
    #undef __deref_opt_ecount_opt
    #undef __lwapi_undef__deref_opt_ecount_opt
#endif
#ifdef __lwapi_undef__deref_opt_bcount_opt
    #undef __deref_opt_bcount_opt
    #undef __lwapi_undef__deref_opt_bcount_opt
#endif
#ifdef __lwapi_undef__deref_opt_out_opt
    #undef __deref_opt_out_opt
    #undef __lwapi_undef__deref_opt_out_opt
#endif
#ifdef __lwapi_undef__deref_opt_out_ecount_opt
    #undef __deref_opt_out_ecount_opt
    #undef __lwapi_undef__deref_opt_out_ecount_opt
#endif
#ifdef __lwapi_undef__deref_opt_out_bcount_opt
    #undef __deref_opt_out_bcount_opt
    #undef __lwapi_undef__deref_opt_out_bcount_opt
#endif
#ifdef __lwapi_undef__deref_opt_out_ecount_part_opt
    #undef __deref_opt_out_ecount_part_opt
    #undef __lwapi_undef__deref_opt_out_ecount_part_opt
#endif
#ifdef __lwapi_undef__deref_opt_out_bcount_part_opt
    #undef __deref_opt_out_bcount_part_opt
    #undef __lwapi_undef__deref_opt_out_bcount_part_opt
#endif
#ifdef __lwapi_undef__deref_opt_out_ecount_full_opt
    #undef __deref_opt_out_ecount_full_opt
    #undef __lwapi_undef__deref_opt_out_ecount_full_opt
#endif
#ifdef __lwapi_undef__deref_opt_out_bcount_full_opt
    #undef __deref_opt_out_bcount_full_opt
    #undef __lwapi_undef__deref_opt_out_bcount_full_opt
#endif
#ifdef __lwapi_undef__deref_opt_out_z_opt
    #undef __deref_opt_out_z_opt
    #undef __lwapi_undef__deref_opt_out_z_opt
#endif
#ifdef __lwapi_undef__deref_opt_out_ecount_z_opt
    #undef __deref_opt_out_ecount_z_opt
    #undef __lwapi_undef__deref_opt_out_ecount_z_opt
#endif
#ifdef __lwapi_undef__deref_opt_out_bcount_z_opt
    #undef __deref_opt_out_bcount_z_opt
    #undef __lwapi_undef__deref_opt_out_bcount_z_opt
#endif
#ifdef __lwapi_undef__deref_opt_out_nz_opt
    #undef __deref_opt_out_nz_opt
    #undef __lwapi_undef__deref_opt_out_nz_opt
#endif
#ifdef __lwapi_undef__deref_opt_out_ecount_nz_opt
    #undef __deref_opt_out_ecount_nz_opt
    #undef __lwapi_undef__deref_opt_out_ecount_nz_opt
#endif
#ifdef __lwapi_undef__deref_opt_out_bcount_nz_opt
    #undef __deref_opt_out_bcount_nz_opt
    #undef __lwapi_undef__deref_opt_out_bcount_nz_opt
#endif
#ifdef __lwapi_undef__deref_opt_inout_opt
    #undef __deref_opt_inout_opt
    #undef __lwapi_undef__deref_opt_inout_opt
#endif
#ifdef __lwapi_undef__deref_opt_inout_ecount_opt
    #undef __deref_opt_inout_ecount_opt
    #undef __lwapi_undef__deref_opt_inout_ecount_opt
#endif
#ifdef __lwapi_undef__deref_opt_inout_bcount_opt
    #undef __deref_opt_inout_bcount_opt
    #undef __lwapi_undef__deref_opt_inout_bcount_opt
#endif
#ifdef __lwapi_undef__deref_opt_inout_ecount_part_opt
    #undef __deref_opt_inout_ecount_part_opt
    #undef __lwapi_undef__deref_opt_inout_ecount_part_opt
#endif
#ifdef __lwapi_undef__deref_opt_inout_bcount_part_opt
    #undef __deref_opt_inout_bcount_part_opt
    #undef __lwapi_undef__deref_opt_inout_bcount_part_opt
#endif
#ifdef __lwapi_undef__deref_opt_inout_ecount_full_opt
    #undef __deref_opt_inout_ecount_full_opt
    #undef __lwapi_undef__deref_opt_inout_ecount_full_opt
#endif
#ifdef __lwapi_undef__deref_opt_inout_bcount_full_opt
    #undef __deref_opt_inout_bcount_full_opt
    #undef __lwapi_undef__deref_opt_inout_bcount_full_opt
#endif
#ifdef __lwapi_undef__deref_opt_inout_z_opt
    #undef __deref_opt_inout_z_opt
    #undef __lwapi_undef__deref_opt_inout_z_opt
#endif
#ifdef __lwapi_undef__deref_opt_inout_ecount_z_opt
    #undef __deref_opt_inout_ecount_z_opt
    #undef __lwapi_undef__deref_opt_inout_ecount_z_opt
#endif
#ifdef __lwapi_undef__deref_opt_inout_bcount_z_opt
    #undef __deref_opt_inout_bcount_z_opt
    #undef __lwapi_undef__deref_opt_inout_bcount_z_opt
#endif
#ifdef __lwapi_undef__deref_opt_inout_nz_opt
    #undef __deref_opt_inout_nz_opt
    #undef __lwapi_undef__deref_opt_inout_nz_opt
#endif
#ifdef __lwapi_undef__deref_opt_inout_ecount_nz_opt
    #undef __deref_opt_inout_ecount_nz_opt
    #undef __lwapi_undef__deref_opt_inout_ecount_nz_opt
#endif
#ifdef __lwapi_undef__deref_opt_inout_bcount_nz_opt
    #undef __deref_opt_inout_bcount_nz_opt
    #undef __lwapi_undef__deref_opt_inout_bcount_nz_opt
#endif
#ifdef __lwapi_success
    #undef __success
    #undef __lwapi_success
#endif
#ifdef __lwapi__Ret_notnull_
    #undef __lwapi__Ret_notnull_
    #undef _Ret_notnull_
#endif
#ifdef __lwapi__Post_writable_byte_size_
    #undef __lwapi__Post_writable_byte_size_
    #undef _Post_writable_byte_size_
#endif
#ifdef __lwapi_Outptr_ 
    #undef __lwapi_Outptr_ 
    #undef _Outptr_ 
#endif

#endif // __LWAPI_EMPTY_SAL

#ifdef __cplusplus
}; //extern "C" {

#endif

#pragma pack(pop)

#endif // _LWAPI_H
