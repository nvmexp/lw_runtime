/*
* Copyright (c) 2017 LWPU Corporation.  All rights reserved.
*
* LWPU Corporation and its licensors retain all intellectual property
* and proprietary rights in and to this software, related documentation
* and any modifications thereto.  Any use, reproduction, disclosure or
* distribution of this software and related documentation without an express
* license agreement from LWPU Corporation is strictly prohibited.
*/

#include "lwntest_cpp.h"
#include "lwn_utils.h"

using namespace lwn;

static DeviceState * g_deviceState;

// Type of program performed during draw call.  These may be mixed with different stages in a single program.
enum ProgramType {
    // Basic separable vertex program that passes through input UV coordinates to the fragment
    // shader.
    BASIC_GLSL_VS = 0,

    // Basic separable fragment program to draw from a given texture based on UV coordinates from the
    // vertex shader.  This is used to draw the result image from compute shader tests.
    BASIC_GLSL_FS,

    // SPIR-V fragment program that uses separate samplers/textures and combines them
    // in different quadrants depending on the UV coordinate interpolated from the Vertex
    // shader output varying.
    SPIRV_SEPARATE_SAMPLER_FS,

    // SPIR-V compute program that uses separate samplers/textures and combines them
    // in different quadrants depending on local thread index and writes the resulting color
    // to a shared image.
    SPIRV_SEPARATE_SAMPLER_CS,

    // GLSL vertex program that uses separate samplers/textures and just passes the handles
    // down stream to fragment shader as flat uvec2's
    GLSL_SEPARATE_SAMPLER_VS,

    // GLSL fragment program that uses separate samplers/textures received as flat uvec2's 
    // from vertex shader and combines them in different quadrants depending on the UV coordinate
    // interpolated from the Vertex shader output varying.
    GLSL_SEPARATE_SAMPLER_FS,

    //// GLSL compute program that uses separate samplers/textures and combines them
    //// in different quadrants depending on local thread index and writes the resulting color
    //// to a shared image.
    GLSL_SEPARATE_SAMPLER_CS,

    ProgramTotalCount
};

// Indicates whether we are testing single bind API calls, or the multi-bind API calls.
enum BindVariant {
    SINGLE_BIND_VARIANT = 0,
    MULTI_BIND_VARIANT,
    NUM_BIND_VARIANTS
};

enum ShaderSourceVariant {
    SHADER_SOURCE_SPIRV = 0,
    SHADER_SOURCE_GLSL,
    NUM_SHADER_SOURCE_VARIANTS
};
// Boilerplate for setting up a screen containing 4 individual cells to draw in to.
static const int CELL_SIZE = lwrrentWindowWidth/4;
static const int CELL_MARGIN = 10;
static const int CELLS_X = lwrrentWindowWidth / CELL_SIZE;
static const int CELLS_Y = lwrrentWindowHeight / CELL_SIZE;

// Width/Height of the image that the compute shader draws into.  This image will be drawn as a texture
// by a subsequent fragment shader.  These are used in the compute shader as SPIR-V specialization constants,
// so they can be changed from here easily.
static const int CS_FS_TEX_WIDTH  = 400;
static const int CS_FS_TEX_HEIGHT = 400;

// SPIR-V specialization constant IDs to let us change the texture size outside of the SPIR-V program.
static const int SPIRV_CONST_NDX_TEX_WIDTH = 0;
static const int SPIRV_CONST_NDX_TEX_HEIGHT = 1;

// NOTE: The below parameters should NOT be changed without modifying the shaders/test code as well.
// The shaders are programmed to assume these values are what they are.
// In the future, with GLSL support, we should be able to more programmatically set these values similar to other LWNtests.
// Lwrrently these can't be specialized since it seems glslang doesn't properly let us use sepcialization constants as
// binding values in "layout(binding = ...)" qualifiers.

static const int TEX_WIDTH = 2;
static const int TEX_HEIGHT = 2;

// Number of textures we draw in the shaders.
#define NUM_TEXTURES_PER_BIND_VARIANT 2

// Number of samplers we draw in the shaders.
#define NUM_SAMPLERS_PER_BIND_VARIANT 2

// Base bind index for separate samplers in all stages.  This is hard-coded into the shader source.
#define SEPARATE_SAMPLER_BASE_NDX 1

// Base bind index for separate textures in all stages.  This is hard-coded into the shader source.
#define SEPARATE_TEXTURE_BASE_SPIRV_NDX 2

// Max binding index for separate textures is 128
#define SEPARATE_TEXTURE_BASE_GLSL_NDX 126

// Printf out any debug messages, such as compilation errors.
#define DEBUG_LOG 0

// Basic vertex shader to set position and pass through UV coordinates.
const char *GLSL_VS_SHADER =
    "#version 440\n"
    "out gl_PerVertex {\n"
    "  vec4 gl_Position;\n"
    "};\n"
    "layout(location = 0) in vec3 position;\n"
    "layout(location = 1) in vec2 uv;\n"
    "layout(location = 0) out vec2 ouv;\n"
    "void main() {\n"
    "  gl_Position = vec4(position, 1.0f);\n"
    "  ouv = uv.xy;\n"
    "}\n";

// Fragment shader to draw the compute shader.
const char *GLSL_FS_SHADER_COMP =
    "#version 440\n"
    "layout(location = 0) in vec2 ouv;\n"
    "layout(location = 0) out vec4 col;\n"
    "layout(binding = 0) uniform sampler2D tex;\n"
    "void main() {\n"
    "  col = texture(tex, ouv);\n"
    "}\n";

// All The SPIR-V binaries are all colwerted from GLSL shader offline by using the Glslang exelwtable binary
// (https://www.khronos.org/opengles/sdk/tools/Reference-Compiler/) with below commands:
// "glslangValidator.exe -V <glslSource.file>".  The "-H" option was used to generate the disassembly text.

// The version of glslang that was used is:
//   Glslang Version: SPIRV99.1321 20-Jul-2016
//   ESSL Version: OpenGL ES GLSL 3.00 glslang LunarG Khronos.SPIRV99.1321 20-Jul-2016
//   GLSL Version: 4.20 glslang LunarG Khronos.SPIRV99.1321 20-Jul-2016
//   SPIR-V Version 0x00010000, Revision 6
//   GLSL.std.450 Version 100, Revision 1
//   Khronos Tool ID 8
//   GL_KHR_vulkan_glsl version 100
//   ARB_GL_gl_spirv version 100

//
// FRAGMENT SPIR-V PROGRAM:
//

// Original GLSL shader:

// #version 440
// layout(location = 0) in vec2 uv;
//
// const int sampBaseNdx = 1;
// const int texBaseNdx = 2;
//
// // Separate samplers
// layout (binding = sampBaseNdx) uniform sampler samp1;
// layout (binding = sampBaseNdx+1) uniform sampler samp2;
//
// // Separate textures
// layout (binding = texBaseNdx) uniform texture2D tex2;
// layout (binding = texBaseNdx+1) uniform texture2D tex3;
//
// layout(location = 0) out vec4 ocolor;
//
// void main() {
//      if (uv.x < 0.5) {
//         if (uv.y < 0.5) {
//             // Lower left quadrant
//             vec2 puv = uv.xy/vec2(0.5, 0.5);
//             ocolor = texture(sampler2D(tex2, samp1), puv);
//         } else {
//             // Upper left quadrant
//             vec2 puv = uv;
//             puv.y -= 0.5;
//             puv = puv/vec2(0.5,0.5);
//             ocolor = texture(sampler2D(tex3, samp1), puv);
//         }
//     } else {
//         if (uv.y < 0.5) {
//             // Lower right quad
//             vec2 puv = uv;
//             puv.x -= 0.5;
//             puv = puv/vec2(0.5,0.5);
//             ocolor = texture(sampler2D(tex2, samp2), puv);
//         } else {
//             // Upper right quad
//             vec2 puv = uv;
//             puv.x -= 0.5;
//             puv.y -= 0.5;
//             puv = puv/vec2(0.5,0.5);
//             ocolor = texture(sampler2D(tex3, samp2), puv);
//         }
//     }
//
// }

// SPIR-V disasm:

//// Module Version 10000
//// Generated by (magic number): 80001
//// Id's are bound by 103
//                              Capability Shader
//               1:             ExtInstImport  "GLSL.std.450"
//                              MemoryModel Logical GLSL450
//                              EntryPoint Fragment 4  "main" 9 33
//                              ExelwtionMode 4 OriginUpperLeft
//                              Source GLSL 440
//                              Name 4  "main"
//                              Name 9  "uv"
//                              Name 27  "puv"
//                              Name 33  "ocolor"
//                              Name 36  "tex2"
//                              Name 40  "samp1"
//                              Name 47  "puv"
//                              Name 56  "tex3"
//                              Name 68  "puv"
//                              Name 77  "samp2"
//                              Name 83  "puv"
//                              Decorate 9(uv) Location 0
//                              Decorate 33(ocolor) Location 0
//                              Decorate 36(tex2) DescriptorSet 0
//                              Decorate 36(tex2) Binding 2
//                              Decorate 40(samp1) DescriptorSet 0
//                              Decorate 40(samp1) Binding 1
//                              Decorate 56(tex3) DescriptorSet 0
//                              Decorate 56(tex3) Binding 3
//                              Decorate 77(samp2) DescriptorSet 0
//                              Decorate 77(samp2) Binding 2
//               2:             TypeVoid
//               3:             TypeFunction 2
//               6:             TypeFloat 32
//               7:             TypeVector 6(float) 2
//               8:             TypePointer Input 7(fvec2)
//           9(uv):      8(ptr) Variable Input
//              10:             TypeInt 32 0
//              11:     10(int) Constant 0
//              12:             TypePointer Input 6(float)
//              15:    6(float) Constant 1056964608
//              16:             TypeBool
//              20:     10(int) Constant 1
//              26:             TypePointer Function 7(fvec2)
//              29:    7(fvec2) ConstantComposite 15 15
//              31:             TypeVector 6(float) 4
//              32:             TypePointer Output 31(fvec4)
//      33(ocolor):     32(ptr) Variable Output
//              34:             TypeImage 6(float) 2D sampled format:Unknown
//              35:             TypePointer UniformConstant 34
//        36(tex2):     35(ptr) Variable UniformConstant
//              38:             TypeSampler
//              39:             TypePointer UniformConstant 38
//       40(samp1):     39(ptr) Variable UniformConstant
//              42:             TypeSampledImage 34
//              49:             TypePointer Function 6(float)
//        56(tex3):     35(ptr) Variable UniformConstant
//       77(samp2):     39(ptr) Variable UniformConstant
//             100:             TypeInt 32 1
//             101:    100(int) Constant 1
//             102:    100(int) Constant 2
//         4(main):           2 Function None 3
//               5:             Label
//         27(puv):     26(ptr) Variable Function
//         47(puv):     26(ptr) Variable Function
//         68(puv):     26(ptr) Variable Function
//         83(puv):     26(ptr) Variable Function
//              13:     12(ptr) AccessChain 9(uv) 11
//              14:    6(float) Load 13
//              17:    16(bool) FOrdLessThan 14 15
//                              SelectionMerge 19 None
//                              BranchConditional 17 18 62
//              18:               Label
//              21:     12(ptr)   AccessChain 9(uv) 20
//              22:    6(float)   Load 21
//              23:    16(bool)   FOrdLessThan 22 15
//                                SelectionMerge 25 None
//                                BranchConditional 23 24 46
//              24:                 Label
//              28:    7(fvec2)     Load 9(uv)
//              30:    7(fvec2)     FDiv 28 29
//                                  Store 27(puv) 30
//              37:          34     Load 36(tex2)
//              41:          38     Load 40(samp1)
//              43:          42     SampledImage 37 41
//              44:    7(fvec2)     Load 27(puv)
//              45:   31(fvec4)     ImageSampleImplicitLod 43 44
//                                  Store 33(ocolor) 45
//                                  Branch 25
//              46:                 Label
//              48:    7(fvec2)     Load 9(uv)
//                                  Store 47(puv) 48
//              50:     49(ptr)     AccessChain 47(puv) 20
//              51:    6(float)     Load 50
//              52:    6(float)     FSub 51 15
//              53:     49(ptr)     AccessChain 47(puv) 20
//                                  Store 53 52
//              54:    7(fvec2)     Load 47(puv)
//              55:    7(fvec2)     FDiv 54 29
//                                  Store 47(puv) 55
//              57:          34     Load 56(tex3)
//              58:          38     Load 40(samp1)
//              59:          42     SampledImage 57 58
//              60:    7(fvec2)     Load 47(puv)
//              61:   31(fvec4)     ImageSampleImplicitLod 59 60
//                                  Store 33(ocolor) 61
//                                  Branch 25
//              25:               Label
//                                Branch 19
//              62:               Label
//              63:     12(ptr)   AccessChain 9(uv) 20
//              64:    6(float)   Load 63
//              65:    16(bool)   FOrdLessThan 64 15
//                                SelectionMerge 67 None
//                                BranchConditional 65 66 82
//              66:                 Label
//              69:    7(fvec2)     Load 9(uv)
//                                  Store 68(puv) 69
//              70:     49(ptr)     AccessChain 68(puv) 11
//              71:    6(float)     Load 70
//              72:    6(float)     FSub 71 15
//              73:     49(ptr)     AccessChain 68(puv) 11
//                                  Store 73 72
//              74:    7(fvec2)     Load 68(puv)
//              75:    7(fvec2)     FDiv 74 29
//                                  Store 68(puv) 75
//              76:          34     Load 36(tex2)
//              78:          38     Load 77(samp2)
//              79:          42     SampledImage 76 78
//              80:    7(fvec2)     Load 68(puv)
//              81:   31(fvec4)     ImageSampleImplicitLod 79 80
//                                  Store 33(ocolor) 81
//                                  Branch 67
//              82:                 Label
//              84:    7(fvec2)     Load 9(uv)
//                                  Store 83(puv) 84
//              85:     49(ptr)     AccessChain 83(puv) 11
//              86:    6(float)     Load 85
//              87:    6(float)     FSub 86 15
//              88:     49(ptr)     AccessChain 83(puv) 11
//                                  Store 88 87
//              89:     49(ptr)     AccessChain 83(puv) 20
//              90:    6(float)     Load 89
//              91:    6(float)     FSub 90 15
//              92:     49(ptr)     AccessChain 83(puv) 20
//                                  Store 92 91
//              93:    7(fvec2)     Load 83(puv)
//              94:    7(fvec2)     FDiv 93 29
//                                  Store 83(puv) 94
//              95:          34     Load 56(tex3)
//              96:          38     Load 77(samp2)
//              97:          42     SampledImage 95 96
//              98:    7(fvec2)     Load 83(puv)
//              99:   31(fvec4)     ImageSampleImplicitLod 97 98
//                                  Store 33(ocolor) 99
//                                  Branch 67
//              67:               Label
//                                Branch 19
//              19:             Label
//                              Return
//                              FunctionEnd

static unsigned char spirv_basic_frag_separate_sampler[] = {
  0x03, 0x02, 0x23, 0x07, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x08, 0x00,
  0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x02, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x47, 0x4c, 0x53, 0x4c, 0x2e, 0x73, 0x74, 0x64, 0x2e, 0x34, 0x35, 0x30,
  0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x07, 0x00, 0x04, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x00, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x10, 0x00, 0x03, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00,
  0x02, 0x00, 0x00, 0x00, 0xb8, 0x01, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x03, 0x00, 0x09, 0x00, 0x00, 0x00, 0x75, 0x76, 0x00, 0x00,
  0x05, 0x00, 0x03, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x70, 0x75, 0x76, 0x00,
  0x05, 0x00, 0x04, 0x00, 0x21, 0x00, 0x00, 0x00, 0x6f, 0x63, 0x6f, 0x6c,
  0x6f, 0x72, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00, 0x24, 0x00, 0x00, 0x00,
  0x74, 0x65, 0x78, 0x32, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00,
  0x28, 0x00, 0x00, 0x00, 0x73, 0x61, 0x6d, 0x70, 0x31, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x03, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x70, 0x75, 0x76, 0x00,
  0x05, 0x00, 0x04, 0x00, 0x38, 0x00, 0x00, 0x00, 0x74, 0x65, 0x78, 0x33,
  0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x03, 0x00, 0x44, 0x00, 0x00, 0x00,
  0x70, 0x75, 0x76, 0x00, 0x05, 0x00, 0x04, 0x00, 0x4d, 0x00, 0x00, 0x00,
  0x73, 0x61, 0x6d, 0x70, 0x32, 0x00, 0x00, 0x00, 0x05, 0x00, 0x03, 0x00,
  0x53, 0x00, 0x00, 0x00, 0x70, 0x75, 0x76, 0x00, 0x47, 0x00, 0x04, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x47, 0x00, 0x04, 0x00, 0x21, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x24, 0x00, 0x00, 0x00,
  0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
  0x24, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x47, 0x00, 0x04, 0x00, 0x28, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x28, 0x00, 0x00, 0x00,
  0x21, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
  0x38, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x47, 0x00, 0x04, 0x00, 0x38, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x4d, 0x00, 0x00, 0x00,
  0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
  0x4d, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x13, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x21, 0x00, 0x03, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x16, 0x00, 0x03, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x17, 0x00, 0x04, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x20, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x15, 0x00, 0x04, 0x00,
  0x0a, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x2b, 0x00, 0x04, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x0c, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f,
  0x14, 0x00, 0x02, 0x00, 0x10, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00,
  0x0a, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x20, 0x00, 0x04, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x05, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x1d, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00,
  0x17, 0x00, 0x04, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x20, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
  0x20, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0x19, 0x00, 0x09, 0x00, 0x22, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x20, 0x00, 0x04, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x22, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x23, 0x00, 0x00, 0x00,
  0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x02, 0x00,
  0x26, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x27, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
  0x27, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x1b, 0x00, 0x03, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00,
  0x20, 0x00, 0x04, 0x00, 0x31, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x23, 0x00, 0x00, 0x00,
  0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
  0x27, 0x00, 0x00, 0x00, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x15, 0x00, 0x04, 0x00, 0x64, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x65, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00,
  0x64, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x36, 0x00, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00,
  0x05, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x1a, 0x00, 0x00, 0x00,
  0x1b, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
  0x1a, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x3b, 0x00, 0x04, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x1a, 0x00, 0x00, 0x00,
  0x53, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00,
  0x0c, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
  0x0b, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x0e, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x05, 0x00,
  0x10, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00,
  0x0f, 0x00, 0x00, 0x00, 0xf7, 0x00, 0x03, 0x00, 0x13, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfa, 0x00, 0x04, 0x00, 0x11, 0x00, 0x00, 0x00,
  0x12, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00,
  0x12, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x00, 0x00,
  0x15, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00,
  0x15, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x05, 0x00, 0x10, 0x00, 0x00, 0x00,
  0x17, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00,
  0xf7, 0x00, 0x03, 0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xfa, 0x00, 0x04, 0x00, 0x17, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
  0x2e, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00, 0x18, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x88, 0x00, 0x05, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x1e, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00,
  0x3e, 0x00, 0x03, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x22, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00,
  0x24, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x26, 0x00, 0x00, 0x00,
  0x29, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x56, 0x00, 0x05, 0x00,
  0x2a, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00,
  0x29, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x2c, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x57, 0x00, 0x05, 0x00,
  0x1f, 0x00, 0x00, 0x00, 0x2d, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x00, 0x00,
  0x2c, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x21, 0x00, 0x00, 0x00,
  0x2d, 0x00, 0x00, 0x00, 0xf9, 0x00, 0x02, 0x00, 0x19, 0x00, 0x00, 0x00,
  0xf8, 0x00, 0x02, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
  0x3e, 0x00, 0x03, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
  0x41, 0x00, 0x05, 0x00, 0x31, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00,
  0x2f, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00,
  0x83, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00,
  0x33, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00,
  0x31, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00,
  0x14, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x35, 0x00, 0x00, 0x00,
  0x34, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x36, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x88, 0x00, 0x05, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x37, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00,
  0x1d, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x2f, 0x00, 0x00, 0x00,
  0x37, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x22, 0x00, 0x00, 0x00,
  0x39, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x26, 0x00, 0x00, 0x00, 0x3a, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
  0x56, 0x00, 0x05, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x00, 0x00,
  0x39, 0x00, 0x00, 0x00, 0x3a, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00,
  0x57, 0x00, 0x05, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x00,
  0x3b, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00,
  0x21, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x00, 0xf9, 0x00, 0x02, 0x00,
  0x19, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00, 0x19, 0x00, 0x00, 0x00,
  0xf9, 0x00, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00,
  0x3e, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x00, 0x00,
  0x3f, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x3f, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x05, 0x00, 0x10, 0x00, 0x00, 0x00,
  0x41, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00,
  0xf7, 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xfa, 0x00, 0x04, 0x00, 0x41, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00,
  0x52, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00, 0x42, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00, 0x45, 0x00, 0x00, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x44, 0x00, 0x00, 0x00,
  0x45, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00, 0x31, 0x00, 0x00, 0x00,
  0x46, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x47, 0x00, 0x00, 0x00,
  0x46, 0x00, 0x00, 0x00, 0x83, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x48, 0x00, 0x00, 0x00, 0x47, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00,
  0x41, 0x00, 0x05, 0x00, 0x31, 0x00, 0x00, 0x00, 0x49, 0x00, 0x00, 0x00,
  0x44, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00,
  0x49, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x4a, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00,
  0x88, 0x00, 0x05, 0x00, 0x07, 0x00, 0x00, 0x00, 0x4b, 0x00, 0x00, 0x00,
  0x4a, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00,
  0x44, 0x00, 0x00, 0x00, 0x4b, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x22, 0x00, 0x00, 0x00, 0x4c, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x26, 0x00, 0x00, 0x00, 0x4e, 0x00, 0x00, 0x00,
  0x4d, 0x00, 0x00, 0x00, 0x56, 0x00, 0x05, 0x00, 0x2a, 0x00, 0x00, 0x00,
  0x4f, 0x00, 0x00, 0x00, 0x4c, 0x00, 0x00, 0x00, 0x4e, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00,
  0x44, 0x00, 0x00, 0x00, 0x57, 0x00, 0x05, 0x00, 0x1f, 0x00, 0x00, 0x00,
  0x51, 0x00, 0x00, 0x00, 0x4f, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00,
  0x3e, 0x00, 0x03, 0x00, 0x21, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00,
  0xf9, 0x00, 0x02, 0x00, 0x43, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00,
  0x52, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x54, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00,
  0x53, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00,
  0x31, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00,
  0x0b, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x56, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 0x83, 0x00, 0x05, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x56, 0x00, 0x00, 0x00,
  0x0f, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00, 0x31, 0x00, 0x00, 0x00,
  0x58, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,
  0x3e, 0x00, 0x03, 0x00, 0x58, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00,
  0x41, 0x00, 0x05, 0x00, 0x31, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x00,
  0x53, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x00,
  0x83, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00, 0x5b, 0x00, 0x00, 0x00,
  0x5a, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00,
  0x31, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00,
  0x14, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x5c, 0x00, 0x00, 0x00,
  0x5b, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x5d, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 0x88, 0x00, 0x05, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x5e, 0x00, 0x00, 0x00, 0x5d, 0x00, 0x00, 0x00,
  0x1d, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x53, 0x00, 0x00, 0x00,
  0x5e, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x22, 0x00, 0x00, 0x00,
  0x5f, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x26, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x4d, 0x00, 0x00, 0x00,
  0x56, 0x00, 0x05, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00,
  0x5f, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00,
  0x57, 0x00, 0x05, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00,
  0x61, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00,
  0x21, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0xf9, 0x00, 0x02, 0x00,
  0x43, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00, 0x43, 0x00, 0x00, 0x00,
  0xf9, 0x00, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00,
  0x13, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x01, 0x00, 0x38, 0x00, 0x01, 0x00
};

//
// COMPUTE SPIR-V PROGRAM
//

// Original GLSL shader:
//
//#version 440
//
//layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
//
//const int sampBaseNdx = 1;
//const int texBaseNdx = 2;
//
//layout(constant_id = 0) const int texWidth = 400;
//layout(constant_id = 1) const int texHeight = 400;
//
//// Large texture to draw to.
//layout(binding=0,rgba32f) uniform image2D image;
//
//// Samplers to sample from
//layout(binding = sampBaseNdx) uniform sampler samp1;
//layout(binding = sampBaseNdx+1) uniform sampler samp2;
//
//// Textures to fetch from.
//layout(binding = texBaseNdx) uniform texture2D tex2;
//layout(binding = texBaseNdx+1) uniform texture2D tex3;
//
//// Offset array index by a uniform in order to stop GLSLC from optimising the loop out.
//void main() {
//
//    // Normalize the globalilwocation id
//    vec2 uv = gl_GlobalIlwocationID.xy;
//    uv /= vec2(texWidth, texHeight);
//    vec4 ocolor = vec4(1.0f, 0.0f, 0.0f, 1.0f);
//
//     if (uv.x < 0.5) {
//        if (uv.y < 0.5) {
//            vec2 puv = uv.xy/vec2(0.5, 0.5);
//            ocolor = texture(sampler2D(tex2, samp1), puv);
//        } else {
//            vec2 puv = uv;
//            puv.y -= 0.5;
//            puv = puv/vec2(0.5,0.5);
//            ocolor = texture(sampler2D(tex3, samp1), puv);
//        }
//    } else {
//        if (uv.y < 0.5) {
//            vec2 puv = uv;
//            puv.x -= 0.5;
//            puv = puv/vec2(0.5,0.5);
//            ocolor = texture(sampler2D(tex2, samp2), puv);
//        } else {
//            vec2 puv = uv;
//            puv.x -= 0.5;
//            puv.y -= 0.5;
//            puv = puv/vec2(0.5,0.5);
//            ocolor = texture(sampler2D(tex3, samp2), puv);
//        }
//    }
//
//
//    imageStore(image, ivec2(gl_GlobalIlwocationID.xy), ocolor);
//}

// SPIR-V disasm:

//// Module Version 10000
//// Generated by (magic number): 80001
//// Id's are bound by 127

//                              Capability Shader
//               1:             ExtInstImport  "GLSL.std.450"
//                              MemoryModel Logical GLSL450
//                              EntryPoint GLCompute 4  "main" 13
//                              ExelwtionMode 4 LocalSize 1 1 1
//                              Source GLSL 440
//                              Name 4  "main"
//                              Name 9  "uv"
//                              Name 13  "gl_GlobalIlwocationID"
//                              Name 28  "ocolor"
//                              Name 47  "puv"
//                              Name 53  "tex2"
//                              Name 57  "samp1"
//                              Name 64  "puv"
//                              Name 72  "tex3"
//                              Name 84  "puv"
//                              Name 93  "samp2"
//                              Name 99  "puv"
//                              Name 118  "image"
//                              Decorate 13(gl_GlobalIlwocationID) BuiltIn GlobalIlwocationId
//                              Decorate 19 SpecId 0
//                              Decorate 21 SpecId 1
//                              Decorate 53(tex2) DescriptorSet 0
//                              Decorate 53(tex2) Binding 2
//                              Decorate 57(samp1) DescriptorSet 0
//                              Decorate 57(samp1) Binding 1
//                              Decorate 72(tex3) DescriptorSet 0
//                              Decorate 72(tex3) Binding 3
//                              Decorate 93(samp2) DescriptorSet 0
//                              Decorate 93(samp2) Binding 2
//                              Decorate 118(image) DescriptorSet 0
//                              Decorate 118(image) Binding 0
//               2:             TypeVoid
//               3:             TypeFunction 2
//               6:             TypeFloat 32
//               7:             TypeVector 6(float) 2
//               8:             TypePointer Function 7(fvec2)
//              10:             TypeInt 32 0
//              11:             TypeVector 10(int) 3
//              12:             TypePointer Input 11(ivec3)
//13(gl_GlobalIlwocationID):     12(ptr) Variable Input
//              14:             TypeVector 10(int) 2
//              18:             TypeInt 32 1
//              19:     18(int) SpecConstant 400
//              21:     18(int) SpecConstant 400
//              26:             TypeVector 6(float) 4
//              27:             TypePointer Function 26(fvec4)
//              29:    6(float) Constant 1065353216
//              30:    6(float) Constant 0
//              31:   26(fvec4) ConstantComposite 29 30 30 29
//              32:     10(int) Constant 0
//              33:             TypePointer Function 6(float)
//              36:    6(float) Constant 1056964608
//              37:             TypeBool
//              41:     10(int) Constant 1
//              49:    7(fvec2) ConstantComposite 36 36
//              51:             TypeImage 6(float) 2D sampled format:Unknown
//              52:             TypePointer UniformConstant 51
//        53(tex2):     52(ptr) Variable UniformConstant
//              55:             TypeSampler
//              56:             TypePointer UniformConstant 55
//       57(samp1):     56(ptr) Variable UniformConstant
//              59:             TypeSampledImage 51
//        72(tex3):     52(ptr) Variable UniformConstant
//       93(samp2):     56(ptr) Variable UniformConstant
//             116:             TypeImage 6(float) 2D nonsampled format:Rgba32f
//             117:             TypePointer UniformConstant 116
//      118(image):    117(ptr) Variable UniformConstant
//             122:             TypeVector 18(int) 2
//             125:     18(int) Constant 1
//             126:     18(int) Constant 2
//         4(main):           2 Function None 3
//               5:             Label
//           9(uv):      8(ptr) Variable Function
//      28(ocolor):     27(ptr) Variable Function
//         47(puv):      8(ptr) Variable Function
//         64(puv):      8(ptr) Variable Function
//         84(puv):      8(ptr) Variable Function
//         99(puv):      8(ptr) Variable Function
//              15:   11(ivec3) Load 13(gl_GlobalIlwocationID)
//              16:   14(ivec2) VectorShuffle 15 15 0 1
//              17:    7(fvec2) ColwertUToF 16
//                              Store 9(uv) 17
//              20:    6(float) ColwertSToF 19
//              22:    6(float) ColwertSToF 21
//              23:    7(fvec2) CompositeConstruct 20 22
//              24:    7(fvec2) Load 9(uv)
//              25:    7(fvec2) FDiv 24 23
//                              Store 9(uv) 25
//                              Store 28(ocolor) 31
//              34:     33(ptr) AccessChain 9(uv) 32
//              35:    6(float) Load 34
//              38:    37(bool) FOrdLessThan 35 36
//                              SelectionMerge 40 None
//                              BranchConditional 38 39 78
//              39:               Label
//              42:     33(ptr)   AccessChain 9(uv) 41
//              43:    6(float)   Load 42
//              44:    37(bool)   FOrdLessThan 43 36
//                                SelectionMerge 46 None
//                                BranchConditional 44 45 63
//              45:                 Label
//              48:    7(fvec2)     Load 9(uv)
//              50:    7(fvec2)     FDiv 48 49
//                                  Store 47(puv) 50
//              54:          51     Load 53(tex2)
//              58:          55     Load 57(samp1)
//              60:          59     SampledImage 54 58
//              61:    7(fvec2)     Load 47(puv)
//              62:   26(fvec4)     ImageSampleExplicitLod 60 61 Lod 30
//                                  Store 28(ocolor) 62
//                                  Branch 46
//              63:                 Label
//              65:    7(fvec2)     Load 9(uv)
//                                  Store 64(puv) 65
//              66:     33(ptr)     AccessChain 64(puv) 41
//              67:    6(float)     Load 66
//              68:    6(float)     FSub 67 36
//              69:     33(ptr)     AccessChain 64(puv) 41
//                                  Store 69 68
//              70:    7(fvec2)     Load 64(puv)
//              71:    7(fvec2)     FDiv 70 49
//                                  Store 64(puv) 71
//              73:          51     Load 72(tex3)
//              74:          55     Load 57(samp1)
//              75:          59     SampledImage 73 74
//              76:    7(fvec2)     Load 64(puv)
//              77:   26(fvec4)     ImageSampleExplicitLod 75 76 Lod 30
//                                  Store 28(ocolor) 77
//                                  Branch 46
//              46:               Label
//                                Branch 40
//              78:               Label
//              79:     33(ptr)   AccessChain 9(uv) 41
//              80:    6(float)   Load 79
//              81:    37(bool)   FOrdLessThan 80 36
//                                SelectionMerge 83 None
//                                BranchConditional 81 82 98
//              82:                 Label
//              85:    7(fvec2)     Load 9(uv)
//                                  Store 84(puv) 85
//              86:     33(ptr)     AccessChain 84(puv) 32
//              87:    6(float)     Load 86
//              88:    6(float)     FSub 87 36
//              89:     33(ptr)     AccessChain 84(puv) 32
//                                  Store 89 88
//              90:    7(fvec2)     Load 84(puv)
//              91:    7(fvec2)     FDiv 90 49
//                                  Store 84(puv) 91
//              92:          51     Load 53(tex2)
//              94:          55     Load 93(samp2)
//              95:          59     SampledImage 92 94
//              96:    7(fvec2)     Load 84(puv)
//              97:   26(fvec4)     ImageSampleExplicitLod 95 96 Lod 30
//                                  Store 28(ocolor) 97
//                                  Branch 83
//              98:                 Label
//             100:    7(fvec2)     Load 9(uv)
//                                  Store 99(puv) 100
//             101:     33(ptr)     AccessChain 99(puv) 32
//             102:    6(float)     Load 101
//             103:    6(float)     FSub 102 36
//             104:     33(ptr)     AccessChain 99(puv) 32
//                                  Store 104 103
//             105:     33(ptr)     AccessChain 99(puv) 41
//             106:    6(float)     Load 105
//             107:    6(float)     FSub 106 36
//             108:     33(ptr)     AccessChain 99(puv) 41
//                                  Store 108 107
//             109:    7(fvec2)     Load 99(puv)
//             110:    7(fvec2)     FDiv 109 49
//                                  Store 99(puv) 110
//             111:          51     Load 72(tex3)
//             112:          55     Load 93(samp2)
//             113:          59     SampledImage 111 112
//             114:    7(fvec2)     Load 99(puv)
//             115:   26(fvec4)     ImageSampleExplicitLod 113 114 Lod 30
//                                  Store 28(ocolor) 115
//                                  Branch 83
//              83:               Label
//                                Branch 40
//              40:             Label
//             119:         116 Load 118(image)
//             120:   11(ivec3) Load 13(gl_GlobalIlwocationID)
//             121:   14(ivec2) VectorShuffle 120 120 0 1
//             123:  122(ivec2) Bitcast 121
//             124:   26(fvec4) Load 28(ocolor)
//                              ImageWrite 119 123 124
//                              Return
//                              FunctionEnd

static unsigned char spirv_basic_comp_separate_sampler[] = {
  0x03, 0x02, 0x23, 0x07, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x08, 0x00,
  0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x02, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x47, 0x4c, 0x53, 0x4c, 0x2e, 0x73, 0x74, 0x64, 0x2e, 0x34, 0x35, 0x30,
  0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x06, 0x00, 0x05, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x00, 0x00,
  0x0d, 0x00, 0x00, 0x00, 0x10, 0x00, 0x06, 0x00, 0x04, 0x00, 0x00, 0x00,
  0x11, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00,
  0xb8, 0x01, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00,
  0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x03, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x75, 0x76, 0x00, 0x00, 0x05, 0x00, 0x08, 0x00,
  0x0d, 0x00, 0x00, 0x00, 0x67, 0x6c, 0x5f, 0x47, 0x6c, 0x6f, 0x62, 0x61,
  0x6c, 0x49, 0x6e, 0x76, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49,
  0x44, 0x00, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00, 0x1c, 0x00, 0x00, 0x00,
  0x6f, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0x00, 0x05, 0x00, 0x03, 0x00,
  0x2f, 0x00, 0x00, 0x00, 0x70, 0x75, 0x76, 0x00, 0x05, 0x00, 0x04, 0x00,
  0x35, 0x00, 0x00, 0x00, 0x74, 0x65, 0x78, 0x32, 0x00, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x04, 0x00, 0x39, 0x00, 0x00, 0x00, 0x73, 0x61, 0x6d, 0x70,
  0x31, 0x00, 0x00, 0x00, 0x05, 0x00, 0x03, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x70, 0x75, 0x76, 0x00, 0x05, 0x00, 0x04, 0x00, 0x48, 0x00, 0x00, 0x00,
  0x74, 0x65, 0x78, 0x33, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x03, 0x00,
  0x54, 0x00, 0x00, 0x00, 0x70, 0x75, 0x76, 0x00, 0x05, 0x00, 0x04, 0x00,
  0x5d, 0x00, 0x00, 0x00, 0x73, 0x61, 0x6d, 0x70, 0x32, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x03, 0x00, 0x63, 0x00, 0x00, 0x00, 0x70, 0x75, 0x76, 0x00,
  0x05, 0x00, 0x04, 0x00, 0x76, 0x00, 0x00, 0x00, 0x69, 0x6d, 0x61, 0x67,
  0x65, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x0d, 0x00, 0x00, 0x00,
  0x0b, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
  0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x47, 0x00, 0x04, 0x00, 0x15, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x35, 0x00, 0x00, 0x00,
  0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
  0x35, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x47, 0x00, 0x04, 0x00, 0x39, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x39, 0x00, 0x00, 0x00,
  0x21, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
  0x48, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x47, 0x00, 0x04, 0x00, 0x48, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x5d, 0x00, 0x00, 0x00,
  0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
  0x5d, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x47, 0x00, 0x04, 0x00, 0x76, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x76, 0x00, 0x00, 0x00,
  0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x02, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x21, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x16, 0x00, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x20, 0x00, 0x00, 0x00, 0x17, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x15, 0x00, 0x04, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x17, 0x00, 0x04, 0x00, 0x0b, 0x00, 0x00, 0x00,
  0x0a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00,
  0x0c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,
  0x3b, 0x00, 0x04, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x17, 0x00, 0x04, 0x00, 0x0e, 0x00, 0x00, 0x00,
  0x0a, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x15, 0x00, 0x04, 0x00,
  0x12, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x32, 0x00, 0x04, 0x00, 0x12, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
  0x90, 0x01, 0x00, 0x00, 0x32, 0x00, 0x04, 0x00, 0x12, 0x00, 0x00, 0x00,
  0x15, 0x00, 0x00, 0x00, 0x90, 0x01, 0x00, 0x00, 0x17, 0x00, 0x04, 0x00,
  0x1a, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
  0x20, 0x00, 0x04, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x1a, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x2b, 0x00, 0x04, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x2c, 0x00, 0x07, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00,
  0x1d, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00,
  0x1d, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00, 0x0a, 0x00, 0x00, 0x00,
  0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00,
  0x21, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x2b, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x3f, 0x14, 0x00, 0x02, 0x00, 0x25, 0x00, 0x00, 0x00,
  0x2b, 0x00, 0x04, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x05, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x31, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00,
  0x19, 0x00, 0x09, 0x00, 0x33, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x20, 0x00, 0x04, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x33, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x34, 0x00, 0x00, 0x00,
  0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x02, 0x00,
  0x37, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x38, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x37, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
  0x38, 0x00, 0x00, 0x00, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x1b, 0x00, 0x03, 0x00, 0x3b, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00,
  0x3b, 0x00, 0x04, 0x00, 0x34, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x38, 0x00, 0x00, 0x00,
  0x5d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x00, 0x09, 0x00,
  0x74, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00,
  0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00,
  0x3b, 0x00, 0x04, 0x00, 0x75, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x17, 0x00, 0x04, 0x00, 0x7a, 0x00, 0x00, 0x00,
  0x12, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00,
  0x12, 0x00, 0x00, 0x00, 0x7d, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x2b, 0x00, 0x04, 0x00, 0x12, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x36, 0x00, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0xf8, 0x00, 0x02, 0x00, 0x05, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x3b, 0x00, 0x04, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x2f, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x3b, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x63, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x0b, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
  0x4f, 0x00, 0x07, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
  0x0f, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x70, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x11, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x6f, 0x00, 0x04, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
  0x6f, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00,
  0x15, 0x00, 0x00, 0x00, 0x50, 0x00, 0x05, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x17, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x88, 0x00, 0x05, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x19, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00,
  0x3e, 0x00, 0x03, 0x00, 0x09, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00,
  0x3e, 0x00, 0x03, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00,
  0x41, 0x00, 0x05, 0x00, 0x21, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00,
  0xb8, 0x00, 0x05, 0x00, 0x25, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00,
  0x23, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0xf7, 0x00, 0x03, 0x00,
  0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfa, 0x00, 0x04, 0x00,
  0x26, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x4e, 0x00, 0x00, 0x00,
  0xf8, 0x00, 0x02, 0x00, 0x27, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00,
  0x21, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
  0x29, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x2b, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x05, 0x00,
  0x25, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x00, 0x00,
  0x24, 0x00, 0x00, 0x00, 0xf7, 0x00, 0x03, 0x00, 0x2e, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfa, 0x00, 0x04, 0x00, 0x2c, 0x00, 0x00, 0x00,
  0x2d, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00,
  0x2d, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x30, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x88, 0x00, 0x05, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
  0x31, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x2f, 0x00, 0x00, 0x00,
  0x32, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x33, 0x00, 0x00, 0x00,
  0x36, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x37, 0x00, 0x00, 0x00, 0x3a, 0x00, 0x00, 0x00, 0x39, 0x00, 0x00, 0x00,
  0x56, 0x00, 0x05, 0x00, 0x3b, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00,
  0x36, 0x00, 0x00, 0x00, 0x3a, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00,
  0x58, 0x00, 0x07, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00,
  0x3c, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x1e, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x1c, 0x00, 0x00, 0x00,
  0x3e, 0x00, 0x00, 0x00, 0xf9, 0x00, 0x02, 0x00, 0x2e, 0x00, 0x00, 0x00,
  0xf8, 0x00, 0x02, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
  0x3e, 0x00, 0x03, 0x00, 0x40, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00,
  0x41, 0x00, 0x05, 0x00, 0x21, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00,
  0x40, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00,
  0x83, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00,
  0x43, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00,
  0x21, 0x00, 0x00, 0x00, 0x45, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x29, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x45, 0x00, 0x00, 0x00,
  0x44, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x46, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x88, 0x00, 0x05, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x47, 0x00, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00,
  0x31, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x47, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x33, 0x00, 0x00, 0x00,
  0x49, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x37, 0x00, 0x00, 0x00, 0x4a, 0x00, 0x00, 0x00, 0x39, 0x00, 0x00, 0x00,
  0x56, 0x00, 0x05, 0x00, 0x3b, 0x00, 0x00, 0x00, 0x4b, 0x00, 0x00, 0x00,
  0x49, 0x00, 0x00, 0x00, 0x4a, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x4c, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x58, 0x00, 0x07, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x4d, 0x00, 0x00, 0x00,
  0x4b, 0x00, 0x00, 0x00, 0x4c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x1e, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x1c, 0x00, 0x00, 0x00,
  0x4d, 0x00, 0x00, 0x00, 0xf9, 0x00, 0x02, 0x00, 0x2e, 0x00, 0x00, 0x00,
  0xf8, 0x00, 0x02, 0x00, 0x2e, 0x00, 0x00, 0x00, 0xf9, 0x00, 0x02, 0x00,
  0x28, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00, 0x4e, 0x00, 0x00, 0x00,
  0x41, 0x00, 0x05, 0x00, 0x21, 0x00, 0x00, 0x00, 0x4f, 0x00, 0x00, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x4f, 0x00, 0x00, 0x00,
  0xb8, 0x00, 0x05, 0x00, 0x25, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00,
  0x50, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0xf7, 0x00, 0x03, 0x00,
  0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfa, 0x00, 0x04, 0x00,
  0x51, 0x00, 0x00, 0x00, 0x52, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00,
  0xf8, 0x00, 0x02, 0x00, 0x52, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
  0x3e, 0x00, 0x03, 0x00, 0x54, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00,
  0x41, 0x00, 0x05, 0x00, 0x21, 0x00, 0x00, 0x00, 0x56, 0x00, 0x00, 0x00,
  0x54, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x56, 0x00, 0x00, 0x00,
  0x83, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00,
  0x57, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00,
  0x21, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00,
  0x20, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x59, 0x00, 0x00, 0x00,
  0x58, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x5a, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x88, 0x00, 0x05, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x5b, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00,
  0x31, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x54, 0x00, 0x00, 0x00,
  0x5b, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x33, 0x00, 0x00, 0x00,
  0x5c, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x37, 0x00, 0x00, 0x00, 0x5e, 0x00, 0x00, 0x00, 0x5d, 0x00, 0x00, 0x00,
  0x56, 0x00, 0x05, 0x00, 0x3b, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00,
  0x5c, 0x00, 0x00, 0x00, 0x5e, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00,
  0x58, 0x00, 0x07, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00,
  0x5f, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x1e, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x1c, 0x00, 0x00, 0x00,
  0x61, 0x00, 0x00, 0x00, 0xf9, 0x00, 0x02, 0x00, 0x53, 0x00, 0x00, 0x00,
  0xf8, 0x00, 0x02, 0x00, 0x62, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
  0x3e, 0x00, 0x03, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x41, 0x00, 0x05, 0x00, 0x21, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00,
  0x63, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00,
  0x83, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00,
  0x66, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00,
  0x21, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00,
  0x20, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x68, 0x00, 0x00, 0x00,
  0x67, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00, 0x21, 0x00, 0x00, 0x00,
  0x69, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x6a, 0x00, 0x00, 0x00,
  0x69, 0x00, 0x00, 0x00, 0x83, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x6b, 0x00, 0x00, 0x00, 0x6a, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00,
  0x41, 0x00, 0x05, 0x00, 0x21, 0x00, 0x00, 0x00, 0x6c, 0x00, 0x00, 0x00,
  0x63, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00,
  0x6c, 0x00, 0x00, 0x00, 0x6b, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x6d, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00,
  0x88, 0x00, 0x05, 0x00, 0x07, 0x00, 0x00, 0x00, 0x6e, 0x00, 0x00, 0x00,
  0x6d, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00,
  0x63, 0x00, 0x00, 0x00, 0x6e, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x33, 0x00, 0x00, 0x00, 0x6f, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x37, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00,
  0x5d, 0x00, 0x00, 0x00, 0x56, 0x00, 0x05, 0x00, 0x3b, 0x00, 0x00, 0x00,
  0x71, 0x00, 0x00, 0x00, 0x6f, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00,
  0x63, 0x00, 0x00, 0x00, 0x58, 0x00, 0x07, 0x00, 0x1a, 0x00, 0x00, 0x00,
  0x73, 0x00, 0x00, 0x00, 0x71, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00,
  0x1c, 0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0xf9, 0x00, 0x02, 0x00,
  0x53, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00, 0x53, 0x00, 0x00, 0x00,
  0xf9, 0x00, 0x02, 0x00, 0x28, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00,
  0x28, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x74, 0x00, 0x00, 0x00,
  0x77, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x0b, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
  0x4f, 0x00, 0x07, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x79, 0x00, 0x00, 0x00,
  0x78, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x04, 0x00, 0x7a, 0x00, 0x00, 0x00,
  0x7b, 0x00, 0x00, 0x00, 0x79, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x1a, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00,
  0x63, 0x00, 0x04, 0x00, 0x77, 0x00, 0x00, 0x00, 0x7b, 0x00, 0x00, 0x00,
  0x7c, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x01, 0x00, 0x38, 0x00, 0x01, 0x00
};

class SamplerTestHelper {
public:
    SamplerTestHelper(void);
    virtual ~SamplerTestHelper();

    // Compile all the shaders into separate programs.  All shader stages treated as separable which makes
    // it easy to mix SPIR-V and GLSL shader stages in a single program.
    void CreatePrograms(Device * device) {
        g_glslcHelper->SetSeparable(LWN_TRUE);

        // Compile the SPIR-V fragment program containing separate samplers/textures
        {
        const LWNuint nShaders = 1;
        LWNshaderStage stages[nShaders];
        stages[0] = LWN_SHADER_STAGE_FRAGMENT;
            unsigned char *spirvBins[1] = { spirv_basic_frag_separate_sampler };

            SpirvParams spvParams;
            spvParams.sizes[0] = sizeof(spirv_basic_frag_separate_sampler);

            m_programs[SPIRV_SEPARATE_SAMPLER_FS] = device->CreateProgram();
            if (!g_glslcHelper->lwnUtil::GLSLCHelper::CompileAndSetShaders(
                reinterpret_cast<LWNprogram *> (m_programs[SPIRV_SEPARATE_SAMPLER_FS]),
                stages, nShaders, (const char **)spirvBins, &spvParams)) {
#if DEBUG_LOG
                printf("Error compiling: %s\n", g_glslcHelper->GetInfoLog());
#endif
            }
        }

        // Compile the SPIR-V compute program containing separate samplers/textures.  Specialize
        // the texture width/height.
        {
            unsigned char *spirvBins[1] = { spirv_basic_comp_separate_sampler };

            SpirvParams spvParams;
            spvParams.sizes[0] = sizeof(spirv_basic_comp_separate_sampler);
            LWNshaderStage stage = LWN_SHADER_STAGE_COMPUTE;

            m_programs[SPIRV_SEPARATE_SAMPLER_CS] = device->CreateProgram();

            g_glslcHelper->AddSpirvSpecializationConstant(LWN_SHADER_STAGE_COMPUTE, SPIRV_CONST_NDX_TEX_WIDTH, CS_FS_TEX_WIDTH);
            g_glslcHelper->AddSpirvSpecializationConstant(LWN_SHADER_STAGE_COMPUTE, SPIRV_CONST_NDX_TEX_HEIGHT, CS_FS_TEX_HEIGHT);

            g_glslcHelper->lwnUtil::GLSLCHelper::CompileAndSetShaders(reinterpret_cast<LWNprogram *> (m_programs[SPIRV_SEPARATE_SAMPLER_CS]),
                &stage, 1, (const char **)spirvBins, &spvParams);

            g_glslcHelper->ClearSpirvSpecializationConstantArrays();
        }

        // Compile a basic GLSL vertex program.
        {
            LWNshaderStage stage = LWN_SHADER_STAGE_VERTEX;
            m_programs[BASIC_GLSL_VS] = device->CreateProgram();
            g_glslcHelper->lwnUtil::GLSLCHelper::CompileAndSetShaders(
                reinterpret_cast<LWNprogram *>(m_programs[BASIC_GLSL_VS]), &stage, 1, &GLSL_VS_SHADER);
        }

        // Compile the basic GLSL fragment shader program
        {
            LWNshaderStage stage = LWN_SHADER_STAGE_FRAGMENT;
            m_programs[BASIC_GLSL_FS] = device->CreateProgram();
            g_glslcHelper->lwnUtil::GLSLCHelper::CompileAndSetShaders(
                reinterpret_cast<LWNprogram *>(m_programs[BASIC_GLSL_FS]), &stage, 1, &GLSL_FS_SHADER_COMP);
        }

        int32_t maxSeparateSamplers = 0;
        int32_t maxSeparateTextures = 0;

        device->GetInteger(lwn::DeviceInfo::SEPARATE_SAMPLER_BINDINGS_PER_STAGE, &maxSeparateSamplers);
        device->GetInteger(lwn::DeviceInfo::SEPARATE_TEXTURE_BINDINGS_PER_STAGE, &maxSeparateTextures);

        assert(maxSeparateSamplers != 0);
        assert(maxSeparateTextures != 0);
        assert(maxSeparateSamplers > SEPARATE_SAMPLER_BASE_NDX);
        assert(maxSeparateTextures > SEPARATE_TEXTURE_BASE_SPIRV_NDX);
        assert(maxSeparateTextures > SEPARATE_TEXTURE_BASE_GLSL_NDX);

        // The following vertex shader defines all the possible samplers and
        // textures in the shader.  This is to exercise compiling maximum
        // number of resources in the shader.  Even though only 2 will actually
        // be used, the usage relies on the input integer uniform values so the compiler will
        // not try to kill any of them.

        VertexShader glsl_separate_sampler_vs_source(440);

        glsl_separate_sampler_vs_source.addExtension(lwShaderExtension::LW_separate_texture_types);
        glsl_separate_sampler_vs_source.addExtension(lwShaderExtension::ARB_bindless_texture);
        glsl_separate_sampler_vs_source <<
            "out gl_PerVertex {\n"
            "  vec4 gl_Position;\n"
            "};\n";

        // Declare all possible separate samplers
        for (int i = 0; i < maxSeparateSamplers; ++i) {
            glsl_separate_sampler_vs_source << "layout (binding = " << i << ") uniform sampler samp" << i << ";\n";
        }
        // Declare all possible separate textures
        for (int i = 0; i < maxSeparateTextures; ++i) {
            glsl_separate_sampler_vs_source << "layout (binding = " << i << ") uniform texture2D tex" << i << ";\n\n";
        }

        glsl_separate_sampler_vs_source <<
            "layout (binding = 0) uniform ConfigUniform {\n"
            // The following 2 separate sampler and 2 separate texture uniforms
            // are used to select which sampler/texture pair to draw the 4
            // quadrants of the cell.
            "    int uniformSamp0Picker;\n"
            "    int uniformSamp1Picker;\n"
            "    int uniformTex0Picker;\n"
            "    int uniformTex1Picker;\n"
            "};\n"
            "layout(location = 0) in vec3 position;\n"
            "layout(location = 1) in vec2 uv;\n"
            "\n"
            "layout(location = 0) out vec2 ouv;\n"
            "layout(location = 1) flat out uvec2 osamp0;\n"
            "layout(location = 2) flat out uvec2 osamp1;\n"
            "layout(location = 3) flat out uvec2 otex0;\n"
            "layout(location = 4) flat out uvec2 otex1;\n"
            "\n"
            "void main() {\n"
            "    gl_Position = vec4(position, 1.0f);\n"
            "    ouv = uv.xy;\n";

        for (int i = 0; i < maxSeparateSamplers; ++i) {
            glsl_separate_sampler_vs_source << "if (uniformSamp0Picker == " << i << ") {\n";
            glsl_separate_sampler_vs_source << "   osamp0 = uvec2(samp" << i << ");\n";
            glsl_separate_sampler_vs_source << "};\n";
            glsl_separate_sampler_vs_source << "if (uniformSamp1Picker == " << i << ") {\n";
            glsl_separate_sampler_vs_source << "   osamp1 = uvec2(samp" << i << ");\n";
            glsl_separate_sampler_vs_source << "};\n";
        }

        for (int i = 0; i < maxSeparateTextures; ++i) {
            glsl_separate_sampler_vs_source << "if (uniformTex0Picker == " << i << ") {\n";
            glsl_separate_sampler_vs_source << "   otex0 = uvec2(tex" << i << ");\n";
            glsl_separate_sampler_vs_source << "};\n";
            glsl_separate_sampler_vs_source << "if (uniformTex1Picker == " << i << ") {\n";
            glsl_separate_sampler_vs_source << "   otex1 = uvec2(tex" << i << ");\n";
            glsl_separate_sampler_vs_source << "};\n";
        }
        glsl_separate_sampler_vs_source << "}\n";

        FragmentShader glsl_separate_sampler_fs_source(440);
        glsl_separate_sampler_fs_source.addExtension(lwShaderExtension::LW_separate_texture_types);
        glsl_separate_sampler_fs_source.addExtension(lwShaderExtension::ARB_bindless_texture);
        glsl_separate_sampler_fs_source <<
            "layout(location = 0) in vec2 uv;\n"
            "// Separate samplers\n"
            "layout (location = 1) flat in uvec2 insamp1;\n"
            "layout (location = 2) flat in uvec2 insamp2;\n"
            "// Separate textures\n"
            "layout (location = 3) flat in uvec2 itex2;\n"
            "layout (location = 4) flat in uvec2 itex3;\n"
            "layout(location = 0) out vec4 ocolor;\n"
            "void main() {\n"
            "     sampler samp1 = sampler(insamp1);\n"
            "     sampler samp2 = sampler(insamp2);\n"
            "     texture2D tex2 = texture2D(itex2);\n"
            "     texture2D tex3 = texture2D(itex3);\n"
            "     if (uv.x < 0.5) {\n"
            "        if (uv.y < 0.5) {\n"
            "            // Lower left quadrant\n"
            "            vec2 puv = uv.xy/vec2(0.5, 0.5);\n"
            "            ocolor = texture(sampler2D(tex2, samp1), puv);\n"
            "        } else {\n"
            "            // Upper left quadrant\n"
            "            vec2 puv = uv;\n"
            "            puv.y -= 0.5;\n"
            "            puv = puv/vec2(0.5,0.5);\n"
            "            ocolor = texture(sampler2D(tex3, samp1), puv);\n"
            "        }\n"
            "    } else {\n"
            "        if (uv.y < 0.5) {\n"
            "            // Lower right quad\n"
            "            vec2 puv = uv;\n"
            "            puv.x -= 0.5;\n"
            "            puv = puv/vec2(0.5,0.5);\n"
            "            ocolor = texture(sampler2D(tex2, samp2), puv);\n"
            "        } else {\n"
            "            // Upper right quad\n"
            "            vec2 puv = uv;\n"
            "            puv.x -= 0.5;\n"
            "            puv.y -= 0.5;\n"
            "            puv = puv/vec2(0.5,0.5);\n"
            "            ocolor = texture(sampler2D(tex3, samp2), puv);\n"
            "        }\n"
            "    }\n"
            "}\n";

        ComputeShader glsl_separate_sampler_cs_source(440);
        glsl_separate_sampler_cs_source.addExtension(lwShaderExtension::LW_separate_texture_types);
        glsl_separate_sampler_cs_source.addExtension(lwShaderExtension::ARB_bindless_texture);
        glsl_separate_sampler_cs_source.addExtension(lwShaderExtension::LW_gpu_shader5);
        glsl_separate_sampler_cs_source.addExtension(lwShaderExtension::LW_desktop_lowp_mediump);
        glsl_separate_sampler_cs_source <<
            "layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;\n"
            "\n"
            "const int sampBaseNdx = " << SEPARATE_SAMPLER_BASE_NDX << ";\n"
            "const int texBaseNdx = " << SEPARATE_TEXTURE_BASE_GLSL_NDX << ";\n"
            "\n"
            "const int texWidth = 400;\n"
            "const int texHeight = 400;\n"
            "\n"
            "// Large texture to draw to.\n"
            "layout(binding=0,rgba32f) uniform image2D image;\n"
            "\n"
            "// Samplers to sample from\n"
            "layout(binding = sampBaseNdx) uniform sampler samp1;\n"
            "layout(binding = sampBaseNdx+1) uniform sampler samp2;\n"
            "\n"
            "// Textures to fetch from.\n"
            "layout(binding = texBaseNdx) uniform mediump texture2D tex2;\n"
            "layout(binding = texBaseNdx+1) uniform mediump texture2D tex3;\n"
            "\n"
            "// Dummy unpack routine to test ARB_bindless_texture colwersions\n"
            "uvec2 doUnpackSamp(uint64_t sam)\n"
            "{\n"
            "    sampler slocal = sampler(sam);\n"
            "    return uvec2(slocal);\n"
            "}\n"
            "// Offset array index by a uniform in order to stop GLSLC from optimising the loop out.\n"
            "\n"
            "void main() {\n"
            "\n"
            "    // Normalize the globalilwocation id\n"
            "    vec2 uv = gl_GlobalIlwocationID.xy;\n"
            "    uv /= vec2(texWidth, texHeight);\n"
            "    vec4 ocolor = vec4(1.0f, 0.0f, 0.0f, 1.0f);\n"
            "\n"
            "    // Do ARB_bindless_texture colwersions\n"
            "    sampler lsamp1 = sampler(doUnpackSamp(uint64_t(samp1)));\n"
            "    sampler lsamp2 = sampler(doUnpackSamp(uint64_t(samp2)));\n"
            "    if (uv.x < 0.5) {\n"
            "        if (uv.y < 0.5) {\n"
            "            vec2 puv = uv.xy/vec2(0.5, 0.5);\n"
            "            ocolor = texture(sampler2D(tex2, lsamp1), puv);\n"
            "        } else {\n"
            "            vec2 puv = uv;\n"
            "            puv.y -= 0.5;\n"
            "            puv = puv/vec2(0.5,0.5);\n"
            "            ocolor = texture(sampler2D(tex3, lsamp1), puv);\n"
            "        }\n"
            "    } else {\n"
            "        if (uv.y < 0.5) {\n"
            "            vec2 puv = uv;\n"
            "            puv.x -= 0.5;\n"
            "            puv = puv/vec2(0.5,0.5);\n"
            "            ocolor = texture(sampler2D(tex2, lsamp2), puv);\n"
            "        } else {\n"
            "            vec2 puv = uv;\n"
            "            puv.x -= 0.5;\n"
            "            puv.y -= 0.5;\n"
            "            puv = puv/vec2(0.5,0.5);\n"
            "            ocolor = texture(sampler2D(tex3, lsamp2), puv);\n"
            "        }\n"
            "    }\n"
            "\n"
            "\n"
            "    imageStore(image, ivec2(gl_GlobalIlwocationID.xy), ocolor);\n"
            "}\n";

        // Compile the GLSL separate sampler vertex shader program
        {
            m_programs[GLSL_SEPARATE_SAMPLER_VS] = device->CreateProgram();
            g_glslcHelper->CompileAndSetShaders(
                reinterpret_cast<LWNprogram *>(m_programs[GLSL_SEPARATE_SAMPLER_VS]), glsl_separate_sampler_vs_source);
        }

        // Compile the GLSL separate sampler fragment shader program
        {
            m_programs[GLSL_SEPARATE_SAMPLER_FS] = device->CreateProgram();
            g_glslcHelper->CompileAndSetShaders(
                reinterpret_cast<LWNprogram *>(m_programs[GLSL_SEPARATE_SAMPLER_FS]), glsl_separate_sampler_fs_source);
        }

        // Compile the GLSL separate sampler compute shader program
        {
            m_programs[GLSL_SEPARATE_SAMPLER_CS] = device->CreateProgram();
            g_glslcHelper->CompileAndSetShaders(
                reinterpret_cast<LWNprogram *>(m_programs[GLSL_SEPARATE_SAMPLER_CS]), glsl_separate_sampler_cs_source);
        }

        g_glslcHelper->SetSeparable(LWN_FALSE);
    }

    void init(Device *device, Queue *queue, QueueCommandBuffer *queueCB) {
        CreatePrograms(device);

        // Set up the vertex format and buffer.
        m_bufpool = new MemoryPoolAllocator(device, NULL, 0x10000, LWN_MEMORY_POOL_TYPE_CPU_COHERENT);

        static const Vertex vertexData[] = {
            { dt::vec3(-1.0, -1.0, 0.0), dt::vec2(0.0, 0.0) },
            { dt::vec3(-1.0, +1.0, 0.0), dt::vec2(1.0, 0.0) },
            { dt::vec3(+1.0, -1.0, 0.0), dt::vec2(0.0, 1.0) },
            { dt::vec3(+1.0, +1.0, 0.0), dt::vec2(1.0, 1.0) },
        };
        m_vertexDataSize = sizeof(vertexData);

        VertexStream stream(sizeof(Vertex));
        LWN_VERTEX_STREAM_ADD_MEMBER(stream, Vertex, position);
        LWN_VERTEX_STREAM_ADD_MEMBER(stream, Vertex, uv);

        m_vertexState = stream.CreateVertexArrayState();
        m_vbo = stream.AllocateVertexBuffer(device, 4, *m_bufpool, vertexData);

        // Allocate textures/samplers/buffers
        m_textureAllocator = new MemoryPoolAllocator(device, NULL, 0x10000, LWN_MEMORY_POOL_TYPE_GPU_ONLY);
        m_coherentAllocator = new MemoryPoolAllocator(device, NULL, 0x10000, LWN_MEMORY_POOL_TYPE_CPU_COHERENT);

        BufferBuilder *buffBuilder = device->CreateBufferBuilder();
        buffBuilder->SetDefaults();

        unsigned char texData[NUM_TEXTURES_PER_BIND_VARIANT][TEX_WIDTH*TEX_HEIGHT * 4] =
        {
            // 4 different colors
            { 255, 255,   0, 255,
              0,   255,   0, 255,
              0,     0, 255, 255,
              0,   255, 255, 255
            },

            // Gray and white checkered pattern
            { 255, 255, 255, 255,
              50,   50,  50, 255,
              50,   50,  50, 255,
              255, 255, 255, 255
            },
        };

        // Buffers to hold our texture data.
        Buffer *pbos[NUM_TEXTURES_PER_BIND_VARIANT];

        // Copy the texture data to the buffers.  These buffers will be used as sources when copying over to individual texture
        // objects.
        for (int lwrrTex = 0; lwrrTex < NUM_TEXTURES_PER_BIND_VARIANT; ++lwrrTex) {
            pbos[lwrrTex] = m_coherentAllocator->allocBuffer(buffBuilder, BUFFER_ALIGN_COPY_READ_BIT, TEX_HEIGHT * TEX_WIDTH * 4);
            unsigned char *texObjPtr = (unsigned char *)pbos[lwrrTex]->Map();
            memcpy(texObjPtr, texData[lwrrTex], sizeof(texData[lwrrTex]));
        }

        // Set up the texture builders and copy over the buffer data to individual textures.
        for (int lwrrBindVariant = 0; lwrrBindVariant < NUM_BIND_VARIANTS; ++lwrrBindVariant) {
            for (int lwrrTextureVariant = 0; lwrrTextureVariant < NUM_TEXTURES_PER_BIND_VARIANT; ++lwrrTextureVariant) {
                TextureBuilder *texBuilder = device->CreateTextureBuilder();
                texBuilder->SetDefaults();
                texBuilder->SetFlags(TextureFlags::IMAGE);
                texBuilder->SetTarget(TextureTarget::TARGET_2D);
                texBuilder->SetSize2D(TEX_WIDTH, TEX_HEIGHT);
                texBuilder->SetFormat(Format::RGBA8);

                Texture * texture = m_textureAllocator->allocTexture(texBuilder);
                LWNuint textureID = texture->GetRegisteredTextureID();
                SeparateTextureHandle handle = device->getSeparateTextureHandle(textureID);
                LWNuint imageID = g_lwnTexIDPool->RegisterImage(texture);

                CopyRegion copyRegion = { 0, 0, 0, TEX_HEIGHT, TEX_WIDTH, 1 };
                queueCB->CopyBufferToTexture(pbos[lwrrTextureVariant]->GetAddress(), texture, NULL, &copyRegion, CopyFlags::NONE);

                m_separateTextureObjects[lwrrBindVariant][lwrrTextureVariant] = SeparateTextureObject(texture, textureID, handle, imageID);
                texBuilder->Free();
            }
        }

        // Set up different samplers to use in the shaders.  Each sampler will use a different Min/Mag filter
        for (int lwrrBindVariant = 0; lwrrBindVariant < NUM_BIND_VARIANTS; ++lwrrBindVariant) {
            for (int lwrrSamplerVariant = 0; lwrrSamplerVariant < NUM_SAMPLERS_PER_BIND_VARIANT; ++lwrrSamplerVariant) {
                SamplerBuilder *sampBuilder = device->CreateSamplerBuilder();
                sampBuilder->SetDefaults();
                sampBuilder->SetWrapMode(WrapMode::CLAMP_TO_EDGE, WrapMode::CLAMP_TO_EDGE, WrapMode::CLAMP_TO_EDGE);

                // Swap sampler objects depending on which variant it is, to make sure that the previous binding variant
                // isn't happening to just be reusing the old binding values.
                if (lwrrBindVariant == lwrrSamplerVariant) {
                    sampBuilder->SetMinMagFilter(MinFilter::LINEAR, MagFilter::LINEAR);
                } else {
                    sampBuilder->SetMinMagFilter(MinFilter::NEAREST, MagFilter::NEAREST);
                }

                Sampler *sampler = sampBuilder->CreateSampler();

                LWNuint id = sampler->GetRegisteredID();

                // Create a separate texture and sampler
                SeparateSamplerHandle handle = device->getSeparateSamplerHandle(id);

                m_separateSamplerObjects[lwrrBindVariant][lwrrSamplerVariant] = SeparateSamplerObject(sampler, id, handle);

                sampBuilder->Free();
            }
        }

        // Create the large image/texture that compute shaders will write into and the fragment shader
        // will draw from.
        {
            TextureBuilder *texBuilder  = device->CreateTextureBuilder();
            texBuilder->SetDefaults();
            texBuilder->SetFlags(TextureFlags::IMAGE);
            texBuilder->SetTarget(TextureTarget::TARGET_2D);
            texBuilder->SetSize2D(CS_FS_TEX_WIDTH, CS_FS_TEX_HEIGHT);
            texBuilder->SetFormat(Format::RGBA8);

            Texture * texture = m_textureAllocator->allocTexture(texBuilder);
            LWNuint textureID = texture->GetRegisteredTextureID();
            LWNuint imageID = g_lwnTexIDPool->RegisterImage(texture);
            texBuilder->Free();

            // Create the sampler
            SamplerBuilder *sampBuilder = device->CreateSamplerBuilder();
            sampBuilder->SetDefaults();
            sampBuilder->SetWrapMode(WrapMode::CLAMP_TO_EDGE, WrapMode::CLAMP_TO_EDGE, WrapMode::CLAMP_TO_EDGE);
            Sampler *sampler = sampBuilder->CreateSampler();
            LWNuint samplerId = sampler->GetRegisteredID();
            sampBuilder->Free();

            // Ge the handle
            TextureHandle texHandle = device->GetTextureHandle(textureID, samplerId);

            m_computeFragmentTextureObject.m_handle = texHandle;
            m_computeFragmentTextureObject.m_imageID = imageID;
            m_computeFragmentTextureObject.m_sampler = sampler;
            m_computeFragmentTextureObject.m_samplerId = samplerId;
            m_computeFragmentTextureObject.m_texture = texture;
            m_computeFragmentTextureObject.m_textureId = textureID;
        }

        // Submit and finish all work to make sure all texture copy operations are finished.
        queueCB->submit();
        queue->Finish();

        for (int i = 0; i < NUM_TEXTURES_PER_BIND_VARIANT; ++i) {
            m_coherentAllocator->freeBuffer(pbos[i]);
        }

        buffBuilder->Free();
    }

    void BindSamplersAndTextures(ShaderStage shaderStage, BindVariant bindVariant, bool hasGLSLSource, QueueCommandBuffer *queueCB)
    {
        if (bindVariant == SINGLE_BIND_VARIANT) {
            // Single bind
            for (int j = 0; j < NUM_TEXTURES_PER_BIND_VARIANT; ++j) {
                queueCB->bindSeparateTexture(shaderStage, hasGLSLSource ? SEPARATE_TEXTURE_BASE_GLSL_NDX + j : SEPARATE_TEXTURE_BASE_SPIRV_NDX + j,
                    (m_separateTextureObjects[bindVariant][j].m_handle));
            }

            for (int j = 0; j < NUM_SAMPLERS_PER_BIND_VARIANT; ++j) {
                queueCB->bindSeparateSampler(shaderStage, SEPARATE_SAMPLER_BASE_NDX + j,
                    (m_separateSamplerObjects[bindVariant][j].m_handle));
            }
        } else {
            // Multi-bind
            SeparateTextureHandle texHandles[NUM_TEXTURES_PER_BIND_VARIANT];
            SeparateSamplerHandle sampHandles[NUM_SAMPLERS_PER_BIND_VARIANT];

            for (int j = 0; j < NUM_TEXTURES_PER_BIND_VARIANT; ++j) {
                texHandles[j] = m_separateTextureObjects[bindVariant][j].m_handle;
            }

            for (int j = 0; j < NUM_SAMPLERS_PER_BIND_VARIANT; ++j) {
                sampHandles[j] = m_separateSamplerObjects[bindVariant][j].m_handle;
            }

            queueCB->BindSeparateTextures(shaderStage, hasGLSLSource ? SEPARATE_TEXTURE_BASE_GLSL_NDX : SEPARATE_TEXTURE_BASE_SPIRV_NDX, 2, texHandles);
            queueCB->BindSeparateSamplers(shaderStage, SEPARATE_SAMPLER_BASE_NDX, 2, sampHandles);
        }
    }

    // Abstract classes create their own draw function.  The function should return the number of cells drawn.  The input
    // <cell> is the current cell being drawn when the function is exelwted.
    virtual int initAndDraw(int cell) = 0;

protected:

    Program * m_programs[ProgramTotalCount];

    struct Vertex {
        dt::vec3 position;
        dt::vec2 uv;
    };

    VertexArrayState m_vertexState;
    MemoryPoolAllocator* m_bufpool;
    MemoryPoolAllocator* m_textureAllocator;
    MemoryPoolAllocator* m_coherentAllocator;
    Buffer *m_vbo;
    LWNuint m_vertexDataSize;

    // Struct to hold separate texture object info
    struct SeparateTextureObject {
        SeparateTextureObject() : m_texture(NULL), m_id(0), m_handle({ 0 }), m_imageID(0) {}

        SeparateTextureObject(Texture * tex, LWNuint texID, SeparateTextureHandle handle, LWNuint imageID) {
            m_texture = tex;
            m_id = texID;
            m_handle = handle;
            m_imageID = imageID;
        }

        Texture *m_texture;
        LWNuint m_id;
        SeparateTextureHandle m_handle;
        LWNuint m_imageID;
    } m_separateTextureObjects [NUM_BIND_VARIANTS][NUM_TEXTURES_PER_BIND_VARIANT];

    // Struct to hold separate sampler object info
    struct SeparateSamplerObject {
        SeparateSamplerObject() : m_sampler(NULL), m_id(0), m_handle({ 0 }) {}

        SeparateSamplerObject(Sampler * samp, LWNuint sampID, SeparateSamplerHandle handle) {
            m_sampler = samp;
            m_id = sampID;
            m_handle = handle;
        }

        Sampler *m_sampler;
        LWNuint m_id;
        SeparateSamplerHandle m_handle;
    } m_separateSamplerObjects [NUM_BIND_VARIANTS][NUM_SAMPLERS_PER_BIND_VARIANT];

    // Holds info for the compute image to draw into for rendering with a fragment
    // shader.
    struct ComputeFragmentTexture {
        Texture *m_texture;
        LWNuint m_textureId;
        TextureHandle m_handle;
        Sampler *m_sampler;
        LWNuint m_samplerId;
        LWNuint m_imageID;
    } m_computeFragmentTextureObject;
};

typedef struct {
    int uniformSamp0Picker;
    int uniformSamp1Picker;
    int uniformTex0Picker;
    int uniformTex1Picker;
} ConfigUniform;

class SeparateSamplerGFXHelper : public SamplerTestHelper {
public:

    // Draw to the current cell and return the number of cells drawn.
    virtual int initAndDraw(int lwrrCell) {
        Device *device = g_deviceState->getDevice();
        Queue *queue = g_deviceState->getQueue();
        QueueCommandBuffer &queueCB = g_deviceState->getQueueCB();

        this->init(device, queue, &queueCB);

        for (int j = 0; j < NUM_SHADER_SOURCE_VARIANTS; j++) {
            for (int i = 0; i < NUM_BIND_VARIANTS; ++i) {

                SetCellViewportScissorPadded(queueCB, lwrrCell % CELLS_X, lwrrCell / CELLS_X, CELL_MARGIN);
                lwrrCell++;
                queueCB.ClearColor(0, 1.0, 0.0, 0.0, 1.0);

                ConfigUniform uboData;
                uboData.uniformTex0Picker = SEPARATE_TEXTURE_BASE_GLSL_NDX;
                uboData.uniformTex1Picker = SEPARATE_TEXTURE_BASE_GLSL_NDX+1;
                uboData.uniformSamp0Picker = SEPARATE_SAMPLER_BASE_NDX;
                uboData.uniformSamp1Picker = SEPARATE_SAMPLER_BASE_NDX+1;

                Buffer *ubo = AllocAndFillBuffer(device, queue, queueCB, (*m_coherentAllocator), &uboData, sizeof(uboData),
                                                 BUFFER_ALIGN_UNIFORM_BIT, false);

                LWNbufferAddress uboAddr = ubo->GetAddress();
                queueCB.BindUniformBuffer(ShaderStage::VERTEX, 0, uboAddr, sizeof(uboData));

                if (j == SHADER_SOURCE_GLSL) {
                    BindSamplersAndTextures(ShaderStage::VERTEX, (BindVariant)i, true /*hasGLSLSource*/, &queueCB);
                } else {
                    BindSamplersAndTextures(ShaderStage::FRAGMENT, (BindVariant)i, false /*hasGLSLSource*/,  &queueCB);
                }

                queueCB.BindVertexArrayState(m_vertexState);
                queueCB.BindVertexBuffer(0, m_vbo->GetAddress(), m_vertexDataSize);

                if (j == SHADER_SOURCE_GLSL) {
                    queueCB.BindProgram(m_programs[GLSL_SEPARATE_SAMPLER_FS], ShaderStageBits::FRAGMENT);
                    queueCB.BindProgram(m_programs[GLSL_SEPARATE_SAMPLER_VS], ShaderStageBits::VERTEX);
                } else {
                    queueCB.BindProgram(m_programs[SPIRV_SEPARATE_SAMPLER_FS], ShaderStageBits::FRAGMENT);
                    queueCB.BindProgram(m_programs[BASIC_GLSL_VS], ShaderStageBits::VERTEX);
                }

                queueCB.DrawArrays(DrawPrimitive::TRIANGLE_STRIP, 0, 4);

                queueCB.submit();
                queue->Finish();
            }
        }
        return NUM_BIND_VARIANTS * NUM_SHADER_SOURCE_VARIANTS;

    }
};

class SeparateSamplerCsHelper : public SamplerTestHelper {
public:

    // Draw to the current cell by sampling separate textures/samplers in the cmopute shader, rendering
    // results to an image, and then running a graphics program to draw the resulting image to the cell.
    // Return the number of cells drawn.
    virtual int initAndDraw(int lwrrCell) {
        Device *device = g_deviceState->getDevice();
        Queue *queue = g_deviceState->getQueue();
        QueueCommandBuffer &queueCB = g_deviceState->getQueueCB();

        this->init(device, queue, &queueCB);

        // Compute portion

        for (int j = 0; j < NUM_SHADER_SOURCE_VARIANTS; j++) {
            if (j == SHADER_SOURCE_GLSL) {
                queueCB.BindProgram(m_programs[GLSL_SEPARATE_SAMPLER_CS], ShaderStageBits::COMPUTE);
            }
            else {
                queueCB.BindProgram(m_programs[SPIRV_SEPARATE_SAMPLER_CS], ShaderStageBits::COMPUTE);
            }
            for (int i = 0; i < NUM_BIND_VARIANTS; ++i) {
                // First dispatch compute to fill in our texture.
                LWNimageHandle ih = device->GetImageHandle(m_computeFragmentTextureObject.m_imageID);
                queueCB.BindImage(ShaderStage::COMPUTE, 0, ih);

                BindSamplersAndTextures(ShaderStage::COMPUTE, (BindVariant)i, j == SHADER_SOURCE_GLSL, &queueCB);

                // Launch, we assume each workgroup has 1 thread (set in shader source) and each workgroup will
                // write to a single texel value in the image.
                queueCB.DispatchCompute(CS_FS_TEX_WIDTH, CS_FS_TEX_HEIGHT, 1);

                queueCB.Barrier(BarrierBits::ORDER_PRIMITIVES | BarrierBits::ILWALIDATE_TEXTURE);

                // Graphics portion to draw the image from the compute shader.
                queueCB.BindProgram(m_programs[BASIC_GLSL_VS], ShaderStageBits::VERTEX);
                queueCB.BindProgram(m_programs[BASIC_GLSL_FS], ShaderStageBits::FRAGMENT);

                LWNtextureHandle texHandle = device->GetTextureHandle(m_computeFragmentTextureObject.m_textureId, m_computeFragmentTextureObject.m_samplerId);

                queueCB.BindTexture(ShaderStage::FRAGMENT, 0, texHandle);

                queueCB.BindVertexArrayState(m_vertexState);
                queueCB.BindVertexBuffer(0, m_vbo->GetAddress(), m_vertexDataSize);

                SetCellViewportScissorPadded(queueCB, lwrrCell % CELLS_X, lwrrCell / CELLS_X, CELL_MARGIN);
                lwrrCell++;
                queueCB.ClearColor(0, 0.0, 0.0, 0.0, 1.0);
                queueCB.DrawArrays(DrawPrimitive::TRIANGLE_STRIP, 0, 4);

                queueCB.submit();
                queue->Finish();
            }
        }
        return NUM_BIND_VARIANTS * NUM_SHADER_SOURCE_VARIANTS;

    }

};

SamplerTestHelper::SamplerTestHelper()
    : m_bufpool(NULL), m_vbo(NULL)
{}

SamplerTestHelper::~SamplerTestHelper() {
    for (int k = 0; k < ProgramTotalCount; k++) {
        m_programs[k]->Free();
    }

    for (int i = 0; i < NUM_BIND_VARIANTS; ++i) {
        for (int j = 0; j < NUM_SAMPLERS_PER_BIND_VARIANT; ++j) {
            m_separateSamplerObjects[i][j].m_sampler->Free();
            m_textureAllocator->freeTexture(m_separateTextureObjects[i][j].m_texture);
        }
    }
    m_computeFragmentTextureObject.m_sampler->Free();
    m_textureAllocator->freeTexture(m_computeFragmentTextureObject.m_texture);

    delete m_bufpool;
    delete m_textureAllocator;
    delete m_coherentAllocator;
}

// ----------------------------- LWNShaderSpirvTest ------------------------------------

class LWNseparateSamplerTest {

public:
    LWNTEST_CppMethods();

};

lwString LWNseparateSamplerTest::getDescription() const
{
    lwStringBuf sb;
    sb << "Test for separate sampler and separate texture support.  This test draws eight "
        "cells, where each cell contains 4 combinations of texture sampling by combining 2 separate "
        "samplers and 2 separate textures inside the shader.\n"
        "\n"
        "The first 4 cells are using graphics programs. First 2 cells use SPIRV programs and remaining"
        "2 use GLSL programs. For SPIRV programs the fragment shader has bindings for 2 separate samplers"
        "and 2 separate textures, while in GLSL programs the vertex shader has bindings for 2 separate"
        "samplers and 2 separate textures.\n"
        "\n"
        "Each quadrant of the cell is drawn by combining the samplers/textures in the fragment shader"
        "depending on UV coordinate and performing a texture lookup."
        "The first and third graphics cell uses single-bind APIs to bind the separate samplers/textures, the "
        "second and fourth graphics cell uses multi-bind APIs to bind the separate samplers/textures.\n"
        "\n"
        "The last 4 cells are using a compute program to combine separate samplers/textures, using SPIRV programs"
        "for first two cells and last two using GLSL programs and similarly "
        "to the fragment shader, but using the globalIlwocationID to get the UV coordinate for the texture lookup.  The results "
        "are then written to an image and a subsequent graphics shader will draw the image.  Again, the first and third compute "
        "cell uses single-bind APIs, and the second and fourth compute cell uses a multi-bind API.\n"
        "\n"
        "A different set of texture data and sampler state is used between multi-bind and single-bind APIs so that "
        "stale data doesn't mask an error in binding the correct textures/samplers.";

    return sb.str();
}

int LWNseparateSamplerTest::isSupported() const
{
    // Check APIs for correct separate sampler/texture support.
    return (lwogCheckLWNGLSLCPackageVersion(41) &&
            lwogCheckLWNAPIVersion(53, 8));
    // TODO : bclack : Minor version bump for GLSLC for this feature??
}

void LWNseparateSamplerTest::doGraphics() const
{
    DisableLWNObjectTracking();

    // Create a new DeviceState which sets the separate texture support flags (we don't do this on the default device), along with
    // any flags set from the global device (such as command-line flags).
    DeviceFlagBits deviceFlags = DeviceState::GetActive()->getDeviceFlags() | DeviceFlagBits::ENABLE_SEPARATE_SAMPLER_TEXTURE_SUPPORT;

    g_deviceState = new DeviceState(deviceFlags);
    if (!g_deviceState || !g_deviceState->isValid()) {
        delete g_deviceState;
        DeviceState::SetDefaultActive();
        LWNFailTest();
        EnableLWNObjectTracking();
        return;
    }
    QueueCommandBuffer &queueCB = g_deviceState->getQueueCB();
    g_deviceState->SetActive();

    cellTestInit(CELLS_X, CELLS_Y);

    g_lwnWindowFramebuffer.bind();
    g_lwnWindowFramebuffer.setViewportScissor();
    queueCB.ClearColor(0, 0.0, 0.0, 0.0, 1.0);

    int lwrrCell = 0;

    // Render the four GFX test cells.
    lwrrCell = SeparateSamplerGFXHelper().initAndDraw(lwrrCell);

    // Render the four compute test cells.
    lwrrCell = SeparateSamplerCsHelper().initAndDraw(lwrrCell);

    delete g_deviceState;
    DeviceState::SetDefaultActive();

    g_lwnQueueCB->resetCounters();
    EnableLWNObjectTracking();
}

OGTEST_CppTest(LWNseparateSamplerTest, lwn_separate_sampler, );
