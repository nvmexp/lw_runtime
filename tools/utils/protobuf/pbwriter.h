/*
 * LWIDIA_COPYRIGHT_BEGIN
 *
 * Copyright 2020-2021 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * LWIDIA_COPYRIGHT_END
 */

#pragma once

#include "pbcommon.h"
#include "lwdiagutils.h"
#include "inc/bytestream.h"

// Namespace and set of classes for writing a protobuf message to a bytestream
// This provides the common implementation, the concrete implementation also
// requires the writer header file generated by protobuf.py which when included
// will create all the necessary classes for writing concrete messages defined
// in the *.proto file

// Dumper/Pusher interface, used for dumping protobuf messages into a ByteStream.
namespace ProtobufWriter
{
    //! Wrapper class for protobuf strings.
    //!
    //! Accepts const string&, const char* as well as pointer+size,
    //! so that it will not copy the string and it avoids using
    //! strlen() if it can.
    class ProtobufString
    {
        public:
            ProtobufString(const string& s)
            : m_Str(s.data()), m_Size(s.size()) { }

            ProtobufString(const char* s)
            : m_Str(s), m_Size(strlen(s)) { }

            ProtobufString(const char* s, size_t size)
            : m_Str(s), m_Size(size) { }

            template<size_t N>
            ProtobufString(const char (&s)[N])
            : m_Str(s), m_Size(N) { }

            const char* data() const { return m_Str; }
            size_t      size() const { return m_Size; }

        private:
            const char* const m_Str;
            const size_t      m_Size;
    };

    //! Provides a way to override the default printing behavior
    enum class Output
    {
        Normal, //!< By default, integers and floats equal to 0 and empty strings are not printed
        Force   //!< Forces printing integers and floats equal to 0 and empty strings
    };

    //! Helper base class for pushing protobuf fields into a ByteStream
    class ProtobufPusher
    {
        public:
            // Primitive protobuf types.
            // The type names are as defined in protobuf specification.
            // The pb_ prefix is prepended by mle.py when generating
            // mle.h in order to avoid clashing with C++ names such
            // as bool/float/string.
            using pb_uint32 = UINT32;
            using pb_uint64 = UINT64;
            using pb_sint32 = INT32;
            using pb_sint64 = INT64;
            using pb_bool   = bool;
            using pb_float  = float;
            using pb_double = double;
            using pb_string = ProtobufString;

            //! The protobuf pusher operates on a foreign/external ByteStream
            //! and does not hold any data on its own
            explicit ProtobufPusher(ByteStream* pBytes)
            : m_pBytes(pBytes)
            {
            }

            ProtobufPusher()                                 = delete;
            ProtobufPusher(const ProtobufPusher&)            = delete;
            ProtobufPusher& operator=(const ProtobufPusher&) = delete;
            ProtobufPusher(ProtobufPusher&&)                 = default;
            ProtobufPusher& operator=(ProtobufPusher&&)      = default;

            const UINT08* data() const { return m_pBytes->data(); }
            size_t        size() const { return m_pBytes->size(); }

            static void PushFieldHeader(ByteStream* pBytes, unsigned fieldIndex, ProtobufCommon::Wire wire);

            //! \brief If enabled, only allow fields marked public to be pushed to the buffer.
            static void EnforceFieldVisibility(bool enable) { s_enforceFieldVisibility = enable; }
            static bool IsFieldVisibilityEnforced() { return s_enforceFieldVisibility; }

        protected:
            ByteStream* GetByteStream() const { return m_pBytes; }

            // Subsequent functions are used to push concrete protobuf
            // fields into the ByteStream.

            void PushField(unsigned fieldIndex, pb_uint32 value, Output how)
            {
                PushField(fieldIndex, static_cast<pb_uint64>(value), how);
            }
            void PushField(unsigned fieldIndex, pb_sint32 value, Output how)
            {
                PushField(fieldIndex, static_cast<pb_sint64>(value), how);
            }
            void PushField(unsigned fieldIndex, pb_uint64 value, Output how);
            void PushField(unsigned fieldIndex, pb_sint64 value, Output how);
            void PushField(unsigned fieldIndex, pb_bool value, Output how);
            void PushField(unsigned fieldIndex, pb_float value, Output how);
            void PushField(unsigned fieldIndex, pb_double value, Output how);
            void PushField(unsigned fieldIndex, pb_string value, Output how);
            void PushField(unsigned fieldIndex, const ProtobufPusher& value, Output how);

            void PushRepeatedField(unsigned fieldIndex, const vector<UINT16>& values);
            void PushRepeatedField(unsigned fieldIndex, const vector<pb_uint32>& values);
            void PushRepeatedField(unsigned fieldIndex, const vector<pb_sint32>& values);
            void PushRepeatedField(unsigned fieldIndex, const vector<pb_uint64>& values);
            void PushRepeatedField(unsigned fieldIndex, const vector<pb_sint64>& values);
            void PushRepeatedField(unsigned fieldIndex, const vector<pb_bool>& values);
            void PushRepeatedField(unsigned fieldIndex, const vector<pb_float>& values);
            void PushRepeatedField(unsigned fieldIndex, const vector<pb_double>& values);

            //! The function for remaining non-packed fields is declared, but there
            //! is no definition.  This will result in linking failure.  This is
            //! on purpose, because non-packed repeated fields must be emitted
            //! explicitly in a loop by the caller.
            template<typename T>
            void PushRepeatedField(unsigned fieldIndex, const vector<T>& values);

        private:
            static bool s_enforceFieldVisibility;
            ByteStream* m_pBytes;
    };

    //! Helper class which prevents picking the wrong member function from
    //! ProtobufPusher-derived classes by accident by wrapping size_t in
    //! a "strong" version.
    class DumpPos
    {
        public:
            explicit DumpPos(size_t pos)
            : m_Pos(pos)
            {
            }

            operator size_t() const
            {
                return m_Pos;
            }

        private:
            size_t m_Pos;
    };

    //! Helper base class used for dumping complex fields (messages)
    //! into a ByteStream.
    class DumperBase
    {
        public:
            explicit DumperBase(size_t dumpPos)
            : m_Pos(dumpPos)
            {
            }
            DumperBase(DumperBase&&)            = default;
            DumperBase& operator=(DumperBase&&) = default;

            DumpPos GetPos() const { return DumpPos(m_Pos); }

        protected:
            void Finish(unsigned fieldIndex, ByteStream* pBytes);

            bool Finished() const { return m_Pos == finished; }

        private:
            static constexpr size_t finished = ~static_cast<size_t>(0);

            size_t m_Pos;
    };

    template<typename T>
    struct MaybeProtobufPusher
    {
        using type = typename conditional<is_base_of<ProtobufPusher, T>::value, T, ProtobufPusher>::type;
    };

    //! Dumps complex protobuf fields (messages) into ByteStream.
    template<typename T, unsigned fieldIndex, bool isFieldPublic>
    struct Dumper: public MaybeProtobufPusher<T>::type, public DumperBase
    {
        Dumper(ByteStream* pBytes, DumpPos dumpPos)
            : MaybeProtobufPusher<T>::type(pBytes), DumperBase(dumpPos)
        {
        }
        ~Dumper()
        {
            if (!Finished())
            {
                Finish();
            }
        }
        Dumper(Dumper&&)            = default;
        Dumper& operator=(Dumper&&) = default;
        Dumper& Finish()
        {
            // Note: For arithmetic types, use EmitValue!
            if (is_base_of<ProtobufPusher, T>::value)
            {
                DumperBase::Finish(fieldIndex, MaybeProtobufPusher<T>::type::GetByteStream());
            }
            return *this;
        }
        template<typename U,
                 enable_if_t<is_same<U, T>::value && !is_base_of<ProtobufPusher, U>::value, int> = 0>
        Dumper& EmitValue(const U& value, Output how = Output::Normal)
        {
            ProtobufPusher::PushField(fieldIndex, value, how);
            return *this;
        }
    };

    //! Used for type deduction from argument passed to Mle::Print()
    template<typename T, unsigned fieldIndex, bool isFieldPublic>
    struct Deductor
    {
    };
}
