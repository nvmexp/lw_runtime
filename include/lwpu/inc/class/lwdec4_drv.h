/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2003-2014 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

/* This file is autogenerated by ref2h.pl.  Do not edit */
// **************************************************************************
//
//       Copyright 1993-2011 LWPU, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user dolwmenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     LWPU, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  LWPU, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     LWPU, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************

#ifndef __LWDEC_DRV_H_
#define __LWDEC_DRV_H_

// TODO: Many fields can be colwerted to bitfields to save memory BW
// TODO: Revisit reserved fields for proper alignment and memory savings

///////////////////////////////////////////////////////////////////////////////
// LWDEC(MSDEC 5) is a single engine solution, and seperates into VLD, MV, IQT,
//                MCFETCH, MC, MCC, REC, DBF, DFBFDMA, HIST etc unit.
//                The class(driver to HW) can mainly seperate into VLD parser
//                and Decoder part to be consistent with original design. And
//                the sequence level info usally set in VLD part. Later codec like
//                VP8 won't name in this way.
// MSVLD: Multi-Standard VLD parser.
//
#define ALIGN_UP(v, n)          (((v) + ((n)-1)) &~ ((n)-1))
#define LWDEC_ALIGN(value)      ALIGN_UP(value,256) // Align to 256 bytes
#define LWDEC_MAX_MPEG2_SLICE   65536 // at 4096*4096, macroblock count = 65536, 1 macroblock per slice

#define LWDEC_CODEC_MPEG1   0
#define LWDEC_CODEC_MPEG2   1
#define LWDEC_CODEC_VC1     2
#define LWDEC_CODEC_H264    3
#define LWDEC_CODEC_MPEG4   4
#define LWDEC_CODEC_DIVX    LWDEC_CODEC_MPEG4
#define LWDEC_CODEC_VP8     5
#define LWDEC_CODEC_HEVC    7
#define LWDEC_CODEC_VP9     9
#define LWDEC_CODEC_HEVC_PARSER 12

// AES encryption
enum
{
    AES128_NONE = 0x0,
    AES128_CTR = 0x1,
    AES128_CBC,
    AES128_ECB,
    AES128_OFB,
    AES128_CTR_LSB16B,
    AES128_CLR_AS_ENCRYPT,
    AES128_RESERVED = 0x7
};

enum
{
    AES128_CTS_DISABLE = 0x0,
    AES128_CTS_ENABLE = 0x1
};

enum
{
    AES128_PADDING_NONE = 0x0,
    AES128_PADDING_CARRY_OVER,
    AES128_PADDING_RFC2630,
    AES128_PADDING_RESERVED = 0x7
};

typedef enum
{
    ENCR_MODE_CTR64         = 0,
    ENCR_MODE_CBC           = 1,
    ENCR_MODE_ECB           = 2,
    ENCR_MODE_ECB_PARTIAL   = 3,
    ENCR_MODE_CBC_PARTIAL   = 4,
    ENCR_MODE_CLEAR_INTO_VPR = 5,     // used for clear stream decoding into VPR.
    ENCR_MODE_FORCE_INTO_VPR = 6,    //  used to force decode output into VPR.
} ENCR_MODE;

// drm_mode configuration
//
// Bit 0:2  AES encryption mode
// Bit 3    CTS (CipherTextStealing) enable/disable
// Bit 4:6  Padding type
// Bit 7:7  Unwrap key enable/disable

#define AES_MODE_MASK           0x7
#define AES_CTS_MASK            0x1
#define AES_PADDING_TYPE_MASK   0x7
#define AES_UNWRAP_KEY_MASK     0x1

#define AES_MODE_SHIFT          0
#define AES_CTS_SHIFT           3
#define AES_PADDING_TYPE_SHIFT  4
#define AES_UNWRAP_KEY_SHIFT    7

#define AES_SET_FLAG(M, C, P)   ((M & AES_MODE_MASK) << AES_MODE_SHIFT) | \
                                ((C & AES_CTS_MASK) << AES_CTS_SHIFT) | \
                                ((P & AES_PADDING_TYPE_MASK) << AES_PADDING_TYPE_SHIFT)

#define AES_GET_FLAG(V, F)      ((V & ((AES_##F##_MASK) <<(AES_##F##_SHIFT))) >> (AES_##F##_SHIFT))

#define DRM_MODE_MASK           0x7f        // Bits 0:6  (0:2 -> AES_MODE, 3 -> AES_CTS, 4:6 -> AES_PADDING_TYPE)
#define AES_GET_DRM_MODE(V)      (V & DRM_MODE_MASK)

enum { DRM_MS_PIFF_CTR  =   AES_SET_FLAG(AES128_CTR, AES128_CTS_DISABLE, AES128_PADDING_CARRY_OVER) };
enum { DRM_MS_PIFF_CBC  =   AES_SET_FLAG(AES128_CBC, AES128_CTS_DISABLE, AES128_PADDING_NONE) };
enum { DRM_MARLIN_CTR   =   AES_SET_FLAG(AES128_CTR, AES128_CTS_DISABLE, AES128_PADDING_NONE) };
enum { DRM_MARLIN_CBC   =   AES_SET_FLAG(AES128_CBC, AES128_CTS_DISABLE, AES128_PADDING_RFC2630) };
enum { DRM_WIDEVINE     =   AES_SET_FLAG(AES128_CBC, AES128_CTS_ENABLE,  AES128_PADDING_NONE) };
enum { DRM_WIDEVINE_CTR =   AES_SET_FLAG(AES128_CTR, AES128_CTS_DISABLE, AES128_PADDING_CARRY_OVER) };
enum { DRM_ULTRA_VIOLET =   AES_SET_FLAG(AES128_CTR_LSB16B, AES128_CTS_DISABLE, AES128_PADDING_NONE) };
enum { DRM_NONE         =   AES_SET_FLAG(AES128_NONE, AES128_CTS_DISABLE, AES128_PADDING_NONE) };
enum { DRM_CLR_AS_ENCRYPT = AES_SET_FLAG(AES128_CLR_AS_ENCRYPT, AES128_CTS_DISABLE, AES128_PADDING_NONE)};

// SSM entry structure
typedef struct _lwdec_ssm_s {
    LwU32 bytes_of_protected_data;//bytes of protected data, follows bytes_of_clear_data. Note: When padding is enabled, it does not include the padding_bytes (1~15), which can be derived by "(16-(bytes_of_protected_data&0xF))&0xF"
    LwU32 bytes_of_clear_data:16; //bytes of clear data, located before bytes_of_protected_data
    LwU32 skip_byte_blk      : 4; //valid when (entry_type==0 && mode = 1)
    LwU32 crypt_byte_blk     : 4; //valid when (entry_type==0 && mode = 1)
    LwU32 skip               : 1; //whether this SSM entry should be skipped or not
    LwU32 last               : 1; //whether this SSM entry is the last one for the whole decoding frame
    LwU32 pad                : 1; //valid when (entry_type==0 && mode==0 && AES_PADDING_TYPE==AES128_PADDING_RFC2630), 0 for pad_end, 1 for pad_begin
    LwU32 mode               : 1; //0 for normal mode, 1 for pattern mode
    LwU32 entry_type         : 1; //0 for DATA, 1 for IV
    LwU32 reserved           : 3;
} lwdec_ssm_s; /* SubSampleMap, 8bytes */

// PASS2 OTF extension structure for SSM support, not exist in lwdec_mpeg4_pic_s (as MPEG4 OTF SW-DRM is not supported yet)
typedef struct _lwdec_pass2_otf_ext_s {
    LwU32 ssm_entry_num      :16; //specifies how many SSM entries (each in unit of 8 bytes) existed in SET_SUB_SAMPLE_MAP_OFFSET surface
    LwU32 ssm_iv_num         :16; //specifies how many SSM IV (each in unit of 16 bytes) existed in SET_SUB_SAMPLE_MAP_IV_OFFSET surface
    LwU32 real_stream_length;     //the real stream length, which is the bitstream length EMD/VLD will get after whole frame SSM processing, sum up of "clear+protected" bytes in SSM entries and removing "non_slice_data/skip".
    LwU32 non_slice_data     :16; //specifies the first many bytes needed to skip, includes only those of "clear+protected" bytes ("padding" bytes excluded)
    LwU32 drm_mode           : 7;
    LwU32 reserved           : 9;
} lwdec_pass2_otf_ext_s; /* 12bytes */

// GIP

/* tile border coefficients of filter */
#define GIP_ASIC_VERT_FILTER_RAM_SIZE       16  /* bytes per pixel */

/* BSD control data of current picture at tile border
 * 11  * 128 bits per 4x4 tile = 128/(8*4) bytes per row */
#define GIP_ASIC_BSD_CTRL_RAM_SIZE          4  /* bytes per row */

/* 8 dc + 8 to boundary + 6*16 + 2*6*64 + 2*64 -> 63 * 16 bytes */
#define GIP_ASIC_SCALING_LIST_SIZE          (16*64)

/* tile border coefficients of filter */
#define GIP_ASIC_VERT_SAO_RAM_SIZE          16  /* bytes per pixel */

/* max number of tiles times width and height (2 bytes each),
 * rounding up to next 16 bytes boundary + one extra 16 byte
 * chunk (HW guys wanted to have this) */
#define GIP_ASIC_TILE_SIZE                  ((20*22*2*2+16+15) & ~0xF)

/* Segment map uses 32 bytes / CTB */
#define GIP_ASIC_VP9_CTB_SEG_SIZE           32

// used for ecdma debug
typedef struct _lwdec_ecdma_config_s
{
    LwU32          ecdma_enable;                               // enable/disable  ecdma
    LwU16          ecdma_blk_x_src;                            // src start position x , it's 64x aligned
    LwU16          ecdma_blk_y_src;                            // src start position y , it's 8x aligned
    LwU16          ecdma_blk_x_dst;                            // dst start position x , it's 64x aligned
    LwU16          ecdma_blk_y_dst;                            // dst start position y , it's 8x aligned
    LwU16          ref_pic_idx;                                // ref(src) picture index , used to derived source picture base address
    LwU16          boundary0_top;                              // src insided tile/partition region top boundary
    LwU16          boundary0_bottom;                           // src insided tile/partition region bottom boundary
    LwU16          boundary1_left;                             // src insided tile/partition region left boundary
    LwU16          boundary1_right;                            // src insided tile/partition region right boundary
    LwU8           blk_copy_flag;                              // blk_copy enable flag.
                                                               // if it's 1 ,ctb_size ==3,ecdma_blk_x_src == boundary1_left and ecdma_blk_y_src == boundary0_top ;
                                                               // if it's 0 ,ecdma_blk_x_src == ecdma_blk_x_dst and ecdma_blk_y_src == ecdma_blk_y_dst;
    LwU8           ctb_size;                                   // ctb_size .0:64x64,1:32x32,2:16x16,3:8x8
} lwdec_ecdma_config_s;

typedef struct _lwdec_status_hevc_s
{
    LwU32 frame_status_intra_cnt;    //Intra block counter, in unit of 8x8 block, IPCM block included
    LwU32 frame_status_inter_cnt;    //Inter block counter, in unit of 8x8 block, SKIP block included
    LwU32 frame_status_skip_cnt;     //Skip block counter, in unit of 8x8 block, blocks having NO/ZERO texture/coeff data
    LwU32 frame_status_fwd_mvx_cnt;  //ABS sum of forward  MVx, one 14bit MVx(integer) per 8x8 block
    LwU32 frame_status_fwd_mvy_cnt;  //ABS sum of forward  MVy, one 14bit MVy(integer) per 8x8 block
    LwU32 frame_status_bwd_mvx_cnt;  //ABS sum of backward MVx, one 14bit MVx(integer) per 8x8 block
    LwU32 frame_status_bwd_mvy_cnt;  //ABS sum of backward MVy, one 14bit MVy(integer) per 8x8 block
    LwU32 error_ctb_pos;             //[15:0] error ctb   position in Y direction, [31:16] error ctb   position in X direction
    LwU32 error_slice_pos;           //[15:0] error slice position in Y direction, [31:16] error slice position in X direction
} lwdec_status_hevc_s;

typedef struct _lwdec_status_vp9_s
{
    LwU32 frame_status_intra_cnt;    //Intra block counter, in unit of 8x8 block, IPCM block included
    LwU32 frame_status_inter_cnt;    //Inter block counter, in unit of 8x8 block, SKIP block included
    LwU32 frame_status_skip_cnt;     //Skip block counter, in unit of 8x8 block, blocks having NO/ZERO texture/coeff data
    LwU32 frame_status_fwd_mvx_cnt;  //ABS sum of forward  MVx, one 14bit MVx(integer) per 8x8 block
    LwU32 frame_status_fwd_mvy_cnt;  //ABS sum of forward  MVy, one 14bit MVy(integer) per 8x8 block
    LwU32 frame_status_bwd_mvx_cnt;  //ABS sum of backward MVx, one 14bit MVx(integer) per 8x8 block
    LwU32 frame_status_bwd_mvy_cnt;  //ABS sum of backward MVy, one 14bit MVy(integer) per 8x8 block
    LwU32 error_ctb_pos;             //[15:0] error ctb   position in Y direction, [31:16] error ctb   position in X direction
    LwU32 error_slice_pos;           //[15:0] error slice position in Y direction, [31:16] error slice position in X direction
} lwdec_status_vp9_s;

typedef struct _lwdec_status_s
{
    LwU32    mbs_correctly_decoded;          // total numers of correctly decoded macroblocks
    LwU32    mbs_in_error;                   // number of error macroblocks.
    LwU32    cycle_count;                    // total cycles taken for execute. read from PERF_DECODE_FRAME_V register
    LwU32    error_status;                   // report error if any
    union 
    {
        lwdec_status_hevc_s hevc;
        lwdec_status_vp9_s vp9;
    };
    LwU32    slice_header_error_code;        // report error in slice header

} lwdec_status_s;

// per 16x16 block, used in hevc/vp9 surface of SetExternalMVBufferOffset when error_external_mv_en = 1
typedef struct _external_mv_s
{
    LwS32    mvx     : 14;   //integrate pixel precision 
    LwS32    mvy     : 14;   //integrate pixel precision
    LwU32    refidx  :  4;
} external_mv_s;

// HEVC
typedef struct _lwdec_hevc_main10_444_ext_s
{
    LwU32 transformSkipRotationEnableFlag : 1;    //sps extension for transform_skip_rotation_enabled_flag
    LwU32 transformSkipContextEnableFlag : 1;     //sps extension for transform_skip_context_enabled_flag
    LwU32 intraBlockCopyEnableFlag :1;            //sps intraBlockCopyEnableFlag, always 0 before spec define it
    LwU32 implicitRdpcmEnableFlag : 1;            //sps implicit_rdpcm_enabled_flag
    LwU32 explicitRdpcmEnableFlag : 1;            //sps explicit_rdpcm_enabled_flag
    LwU32 extendedPrecisionProcessingFlag : 1;    //sps extended_precision_processing_flag,always 0 in current profile
    LwU32 intraSmoothingDisabledFlag : 1;         //sps intra_smoothing_disabled_flag
    LwU32 highPrecisionOffsetsEnableFlag :1;      //sps high_precision_offsets_enabled_flag
    LwU32 fastRiceAdaptationEnableFlag: 1;        //sps fast_rice_adaptation_enabled_flag
    LwU32 cabacBypassAlignmentEnableFlag : 1;     //sps cabac_bypass_alignment_enabled_flag, always 0 in current profile
    LwU32 sps_444_extension_reserved : 22;        //sps reserve for future extension

    LwU32 log2MaxTransformSkipSize : 4 ;          //pps extension log2_max_transform_skip_block_size_minus2, 0...5
    LwU32 crossComponentPredictionEnableFlag: 1;  //pps cross_component_prediction_enabled_flag
    LwU32 chromaQpAdjustmentEnableFlag:1;         //pps chroma_qp_adjustment_enabled_flag
    LwU32 diffLwChromaQpAdjustmentDepth:2;        //pps diff_lw_chroma_qp_adjustment_depth, 0...3
    LwU32 chromaQpAdjustmentTableSize:3;          //pps chroma_qp_adjustment_table_size_minus1+1, 1...6
    LwU32 log2SaoOffsetScaleLuma:3;               //pps log2_sao_offset_scale_luma, max(0,bitdepth-10),maxBitdepth 16 for future.
    LwU32 log2SaoOffsetScaleChroma: 3;            //pps log2_sao_offset_scale_chroma
    LwU32 pps_444_extension_reserved : 15;        //pps reserved
    LwS8  cb_qp_adjustment[6];                    //-[12,+12]
    LwS8  cr_qp_adjustment[6];                    //-[12,+12]
    LwU32 HevcFltAboveOffset;                     // filter above offset respect to filter buffer, 256 bytes unit
    LwU32 HevcSaoAboveOffset;                     // sao    above offset respect to filter buffer, 256 bytes unit
} lwdec_hevc_main10_444_ext_s;

typedef struct _lwdec_hevc_pic_v1_s
{
    // New fields
    //hevc main10 444 extensions
    lwdec_hevc_main10_444_ext_s hevc_main10_444_ext;

    //HEVC skip bytes from beginning setting for secure
    //it is different to the sw_hdr_skip_length who skips the middle of stream of
    //the slice header which is parsed by driver
    LwU32   sw_skip_start_length     : 14;
    LwU32   external_ref_mem_dis     :  1;
    LwU32   error_recovery_start_pos :  2;       //0: from start of frame, 1: from start of slice segment, 2: from error detected ctb, 3: reserved
    LwU32   error_external_mv_en     :  1;
    LwU32   reserved0                : 14;
    // Reserved bits padding
} lwdec_hevc_pic_v1_s;

//No versioning in structure: LWDEC2 (T210 and GM206)
//version v1 : LWDEC3 (T186 and GP100)
//version v2 : LWDEC3.1 (GP10x)

typedef struct _lwdec_hevc_pic_v2_s
{
// mv-hevc field
LwU32  mv_hevc_enable                     :1;
LwU32  nuh_layer_id                       :6;
LwU32  default_ref_layers_active_flag     :1; 
LwU32  NumDirectRefLayers                 :6;
LwU32  max_one_active_ref_layer_flag      :1;
LwU32  NumActiveRefLayerPics              :6;
LwU32  poc_lsb_not_present_flag           :1;
LwU32  reserved0                          :10;
} lwdec_hevc_pic_v2_s;

typedef struct _lwdec_hevc_v3_s{  
// slice level decoding 
LwU32  slice_decoding_enable:1;//1: enable slice level decoding 
LwU32  slice_ec_enable:1;      //1: enable slice error concealment. When slice_ec_enable=1,slice_decoding_enable must be 1; 
LwU32  slice_ec_mv_type:2;     //0: zero mv; 1: co-located mv; 2: external mv;
LwU32  err_detected_sw:1;      //1: indicate sw/driver has detected error already in frame kick mode 
LwU32  slice_ec_slice_type:2;  //0: B slice; 1: P slice ; others: reserved 
LwU32  slice_strm_recfg_en:1;  //enable slice bitstream re-configure or not ;
LwU32  reserved:24;
LwU32  HevcSliceEdgeOffset;// slice edge buffer offset which repsect to filter buffer ,256 bytes as one unit
}lwdec_hevc_pic_v3_s;

typedef struct _lwdec_hevc_pic_s
{
    //The key/IV addr must be 128bit alignment
    LwU32   wrapped_session_key[4];                      //session keys
    LwU32   wrapped_content_key[4];                      //content keys
    LwU32   initialization_vector[4];                    //Ctrl64 initial vector
    // hevc_bitstream_data_info
    LwU32   stream_len;                                  // stream length in one frame
    LwU32   enable_encryption;                           // flag to enable/disable encryption
    LwU32   key_increment   : 6;                         // added to content key after unwrapping
    LwU32   encryption_mode : 4;
    LwU32   key_slot_index  : 4;
    LwU32   ssm_en          : 1;
    LwU32   reserved0       :17;

    // Driver may or may not use based upon need.
    // If 0 then default value of 1<<27 = 298ms @ 450MHz will be used in ucode.
    // Driver can send this value based upon resolution using the formula:
    // gptimer_timeout_value = 3 * (cycles required for one frame)
    LwU32 gptimer_timeout_value;

    // general
    LwU8   tileformat                 : 2 ;   // 0: TBL; 1: KBL; 2: Tile16x16
    LwU8   gob_height                 : 3 ;   // Set GOB height, 0: GOB_2, 1: GOB_4, 2: GOB_8, 3: GOB_16, 4: GOB_32 (LWDEC3 onwards)
    LwU8   reserverd_surface_format   : 3 ;   
    LwU8   sw_start_code_e;                             // 0: stream doesn't contain start codes,1: stream contains start codes
    LwU8   disp_output_mode;                            // 0: Rec.709 8 bit, 1: Rec.709 10 bit, 2: Rec.709 10 bits -> 8 bit, 3: Rec.2020 10 bit -> 8 bit
    LwU8   enable_tile_WAR;                             // for LWDEC4 HW bug 200574909 only, not applicable in LWDEC5
    LwU32  framestride[2];                              // frame buffer stride for luma and chroma
    LwU32  colMvBuffersize;                             // collocated MV buffer size of one picture ,256 bytes unit
    LwU32  HevcSaoBufferOffset;                         // sao buffer offset respect to filter buffer ,256 bytes unit .
    LwU32  HevcBsdCtrlOffset;                           // bsd buffer offset respect to filter buffer ,256 bytes unit .
    // sps
    LwU16 pic_width_in_luma_samples;                      // :15, 48(?)..16384, multiple of 8 (48 is smallest width supported by LWDEC for CTU size 16x16)
    LwU16 pic_height_in_luma_samples;                     // :15, 8..16384, multiple of 8
    LwU32 chroma_format_idc                            : 4; // always 1 (=4:2:0)
    LwU32 bit_depth_luma                               : 4; // 8..12
    LwU32 bit_depth_chroma                             : 4;
    LwU32 log2_min_luma_coding_block_size              : 4; // 3..6
    LwU32 log2_max_luma_coding_block_size              : 4; // 3..6
    LwU32 log2_min_transform_block_size                : 4; // 2..5
    LwU32 log2_max_transform_block_size                : 4; // 2..5
    LwU32 reserved2                                    : 4;

    LwU32 max_transform_hierarchy_depth_inter          : 3; // 0..4
    LwU32 max_transform_hierarchy_depth_intra          : 3; // 0..4
    LwU32 scalingListEnable                            : 1; //
    LwU32 amp_enable_flag                              : 1; //
    LwU32 sample_adaptive_offset_enabled_flag          : 1; //
    LwU32 pcm_enabled_flag                             : 1; //
    LwU32 pcm_sample_bit_depth_luma                    : 4; //
    LwU32 pcm_sample_bit_depth_chroma                  : 4;
    LwU32 log2_min_pcm_luma_coding_block_size          : 4; //
    LwU32 log2_max_pcm_luma_coding_block_size          : 4; //
    LwU32 pcm_loop_filter_disabled_flag                : 1; //
    LwU32 sps_temporal_mvp_enabled_flag                : 1; //
    LwU32 strong_intra_smoothing_enabled_flag          : 1; //
    LwU32 reserved3                                    : 3;
    // pps
    LwU32 dependent_slice_segments_enabled_flag        : 1; //
    LwU32 output_flag_present_flag                     : 1; //
    LwU32 num_extra_slice_header_bits                  : 3; //  0..7 (normally 0)
    LwU32 sign_data_hiding_enabled_flag                : 1; //
    LwU32 cabac_init_present_flag                      : 1; //
    LwU32 num_ref_idx_l0_default_active                : 4; //  1..15
    LwU32 num_ref_idx_l1_default_active                : 4; //  1..15
    LwU32 init_qp                                      : 7; //  0..127, support higher bitdepth
    LwU32 constrained_intra_pred_flag                  : 1; //
    LwU32 transform_skip_enabled_flag                  : 1; //
    LwU32 lw_qp_delta_enabled_flag                     : 1; //
    LwU32 diff_lw_qp_delta_depth                       : 2; //  0..3
    LwU32 reserved4                                    : 5; //

    LwS8  pps_cb_qp_offset                             ; //  -12..12
    LwS8  pps_cr_qp_offset                             ; //  -12..12
    LwS8  pps_beta_offset                              ; //  -12..12
    LwS8  pps_tc_offset                                ; //  -12..12
    LwU32 pps_slice_chroma_qp_offsets_present_flag     : 1; //
    LwU32 weighted_pred_flag                           : 1; //
    LwU32 weighted_bipred_flag                         : 1; //
    LwU32 transquant_bypass_enabled_flag               : 1; //
    LwU32 tiles_enabled_flag                           : 1; // (redundant: = num_tile_columns_minus1!=0 || num_tile_rows_minus1!=0)
    LwU32 entropy_coding_sync_enabled_flag             : 1; //
    LwU32 num_tile_columns                             : 5; // 0..20
    LwU32 num_tile_rows                                : 5; // 0..22
    LwU32 loop_filter_across_tiles_enabled_flag        : 1; //
    LwU32 loop_filter_across_slices_enabled_flag       : 1; //
    LwU32 deblocking_filter_control_present_flag       : 1; //
    LwU32 deblocking_filter_override_enabled_flag      : 1; //
    LwU32 pps_deblocking_filter_disabled_flag          : 1; //
    LwU32 lists_modification_present_flag              : 1; //
    LwU32 log2_parallel_merge_level                    : 3; //  2..4
    LwU32 slice_segment_header_extension_present_flag  : 1; // (normally 0)
    LwU32 reserved5                                    : 6;

    // reference picture related
    LwU8  num_ref_frames;
    LwU8  reserved6;
    LwU16 longtermflag;                                // long term flag for refpiclist.bit 15 for picidx 0, bit 14 for picidx 1,...
    LwU8  initreflistidxl0[16];                        // :5, [refPicidx] 0..15
    LwU8  initreflistidxl1[16];                        // :5, [refPicidx] 0..15
    LwS16 RefDiffPicOrderCnts[16];                     // poc diff between current and reference pictures .[-128,127]
    // misc
    LwU8  IDR_picture_flag;                            // idr flag for current picture
    LwU8  RAP_picture_flag;                            // rap flag for current picture
    LwU8  lwrr_pic_idx;                                // current  picture store buffer index,used to derive the store addess of frame buffer and MV
    LwU8  pattern_id;                                  // used for dithering to select between 2 tables
    LwU16 sw_hdr_skip_length;                          // reference picture inititial related syntax elements(SE) bits in slice header.
                                                       // those SE only decoding once in driver,related bits will flush in HW
    LwU16 reserved7;

    // used for ecdma debug
    lwdec_ecdma_config_s  ecdma_cfg;

    //DXVA on windows
    LwU32   separate_colour_plane_flag : 1;
    LwU32   log2_max_pic_order_cnt_lsb_minus4 : 4;    //0~12
    LwU32   num_short_term_ref_pic_sets : 7 ;  //0~64
    LwU32   num_long_term_ref_pics_sps :  6;  //0~32
    LwU32   bBitParsingDisable : 1 ; //disable parsing
    LwU32   num_delta_pocs_of_rps_idx : 8;
    LwU32   long_term_ref_pics_present_flag : 1;
    LwU32   reserved_dxva : 4;
    //the number of bits for short_term_ref_pic_set()in slice header,dxva API
    LwU32   num_bits_short_term_ref_pics_in_slice;

    // New additions
    lwdec_hevc_pic_v1_s v1;
    lwdec_hevc_pic_v2_s v2;
    lwdec_hevc_pic_v3_s v3;
    lwdec_pass2_otf_ext_s ssm;

} lwdec_hevc_pic_s;

//hevc slice info class
typedef struct _hevc_slice_info_s {  
    LwU32   first_flag    :1;//first slice(s) of frame,must valid for slice EC
    LwU32   err_flag      :1;//error slice(s) .optional info for EC
    LwU32   last_flag     :1;//last slice segment(s) of frame,this bit is must be valid when slice_strm_recfg_en==1 or slice_ec==1   
    LwU32   conceal_partial_slice :1; // indicate do partial slice error conealment for packet loss case 
    LwU32   available     :1; // indicate the slice bitstream is available.
    LwU32   reserved0     :7;
    LwU32   ctb_count     :20;// ctbs counter inside slice(s) .must valid for slice EC
    LwU32   bs_offset; //slice(s) bitstream offset in bitstream buffer (in byte unit) 
    LwU32   bs_length; //slice(s) bitstream length. It is sum of aligned size and skip size and valid slice bitstream size.
    LwU16   start_ctbx; //slice start ctbx ,it's optional,HW can output it in previous slice decoding.
			            //but this is one check points for error
    LwU16   start_ctby; //slice start ctby
 } hevc_slice_info_s;
 

//hevc slice ctx class 
//slice pos and next slice address 
typedef struct  _slice_edge_ctb_pos_ctx_s {  
    LwU32    next_slice_pos_ctbxy;         //2d address in raster scan
    LwU32    next_slice_segment_addr;      //1d address in  tile scan 
}slice_edge_ctb_pos_ctx_s;

//	next slice's first ctb located tile related information
typedef struct  _slice_edge_tile_ctx_s {  
    LwU32    tileInfo1;// Misc tile info includes tile width and tile height and tile col and tile row 
    LwU32    tileInfo2;// Misc tile info includes tile start ctbx and start ctby and tile index 
    LwU32    tileInfo3;// Misc tile info includes  ctb pos inside tile 
} slice_edge_tile_ctx_s;

//frame level stats 
typedef struct  _slice_edge_stats_ctx_s {  
    LwU32    frame_status_intra_cnt;// frame stats for intra block count
    LwU32    frame_status_inter_cnt;// frame stats for inter block count
    LwU32    frame_status_skip_cnt;// frame stats for skip block count
    LwU32    frame_status_fwd_mvx_cnt;// frame stats for sum of  abs fwd mvx
    LwU32    frame_status_fwd_mvy_cnt;// frame stats for sum of  abs fwd mvy
    LwU32    frame_status_bwd_mvx_cnt;// frame stats for sum of  abs bwd mvx
    LwU32    frame_status_bwd_mvy_cnt;// frame stats for sum of  abs bwd mvy
    LwU32    frame_status_mv_cnt_ext;// extension bits of  sum of abs mv to keep full precision.
}slice_edge_stats_ctx_s;

//ctx of vpc_edge unit for tile left 
typedef struct  _slice_vpc_edge_ctx_s {  
    LwU32   reserved;
}slice_vpc_edge_ctx_s;

//ctx of vpc_main unit
typedef struct  _slice_vpc_main_ctx_s {  
    LwU32   reserved;
} slice_vpc_main_ctx_s;

//hevc slice edge ctx class
typedef struct  _slice_edge_ctx_s {  
//ctb pos
slice_edge_ctb_pos_ctx_s  slice_ctb_pos_ctx;
// stats
slice_edge_stats_ctx_s slice_stats_ctx;
// tile info
slice_edge_tile_ctx_s    slice_tile_ctx;
//vpc_edge
slice_vpc_edge_ctx_s  slice_vpc_edge_ctx;
//vpc_main
slice_vpc_main_ctx_s  slice_vpc_main_ctx;
} slice_edge_ctx_s;

//vp9

typedef struct _lwdec_vp9_pic_v1_s
{
    // New fields
    // new_var : xx; // for variables with expanded bitlength, comment on why the new bit legth is required
    // Reserved bits for padding and/or non-HW specific functionality
    LwU32   Vp9FltAboveOffset;  // filter above offset respect to filter buffer, 256 bytes unit
    LwU32   external_ref_mem_dis :  1;
    LwU32   bit_depth            :  4;
    LwU32   error_recovery_start_pos :  2;       //0: from start of frame, 1: from start of slice segment, 2: from error detected ctb, 3: reserved
    LwU32   error_external_mv_en :  1;
    LwU32   Reserved0            : 24;
} lwdec_vp9_pic_v1_s;

enum VP9_FRAME_SFC_ID
{
    VP9_LAST_FRAME_SFC = 0,
    VP9_GOLDEN_FRAME_SFC,
    VP9_ALTREF_FRAME_SFC,
    VP9_LWRR_FRAME_SFC
};

typedef struct _lwdec_vp9_pic_s
{
    // vp9_bitstream_data_info
    //Key and IV address must 128bit alignment
    LwU32   wrapped_session_key[4];                      //session keys
    LwU32   wrapped_content_key[4];                      //content keys
    LwU32   initialization_vector[4];                    //Ctrl64 initial vector
    LwU32   stream_len;                                  // stream length in one frame
    LwU32   enable_encryption;                           // flag to enable/disable encryption
    LwU32   key_increment      : 6;                      // added to content key after unwrapping
    LwU32   encryption_mode    : 4;
    LwU32   sw_hdr_skip_length :14;                      //vp9 skip bytes setting for secure
    LwU32   key_slot_index     : 4;
    LwU32   ssm_en             : 1;
    LwU32   reserved0          : 3;

    // Driver may or may not use based upon need.
    // If 0 then default value of 1<<27 = 298ms @ 450MHz will be used in ucode.
    // Driver can send this value based upon resolution using the formula:
    // gptimer_timeout_value = 3 * (cycles required for one frame)
    LwU32 gptimer_timeout_value;

    //general
    LwU8  tileformat                 : 2 ;   // 0: TBL; 1: KBL; 2: Tile16x16
    LwU8  gob_height                 : 3 ;   // Set GOB height, 0: GOB_2, 1: GOB_4, 2: GOB_8, 3: GOB_16, 4: GOB_32 (LWDEC3 onwards)
    LwU8  reserverd_surface_format   : 3 ;   
    LwU8  reserved1[3];
    LwU32 Vp9BsdCtrlOffset;                           // bsd buffer offset respect to filter buffer ,256 bytes unit .


    //ref_last dimensions
    LwU16  ref0_width;    //ref_last coded width
    LwU16  ref0_height;   //ref_last coded height
    LwU16  ref0_stride[2];    //ref_last stride

    //ref_golden dimensions
    LwU16  ref1_width;    //ref_golden coded width
    LwU16  ref1_height;   //ref_golden coded height
    LwU16  ref1_stride[2];    //ref_golden stride

    //ref_alt dimensions
    LwU16  ref2_width;    //ref_alt coded width
    LwU16  ref2_height;   //ref_alt coded height
    LwU16  ref2_stride[2];    //ref_alt stride


    /* Current frame dimensions */
    LwU16  width;    //pic width
    LwU16  height;   //pic height
    LwU16  framestride[2];   // frame buffer stride for luma and chroma

    LwU8   keyFrame  :1;
    LwU8   prevIsKeyFrame:1;
    LwU8   resolutionChange:1;
    LwU8   errorResilient:1;
    LwU8   prevShowFrame:1;
    LwU8   intraOnly:1;
    LwU8   reserved2 : 2;

    /* DCT coefficient partitions */
    //LwU32    offsetToDctParts;

    LwU8   reserved3[3];
    //LwU8   activeRefIdx[3];//3 bits
    //LwU8   refreshFrameFlags;
    //LwU8   refreshEntropyProbs;
    //LwU8   frameParallelDecoding;
    //LwU8   resetFrameContext;

    LwU8   refFrameSignBias[4];
    LwS8   loopFilterLevel;//6 bits
    LwS8   loopFilterSharpness;//3 bits

    /* Quantization parameters */
    LwU8   qpYAc;
    LwS8   qpYDc;
    LwS8   qpChAc;
    LwS8   qpChDc;

    /* From here down, frame-to-frame persisting stuff */

    LwS8   lossless;
    LwS8   transform_mode;
    LwS8   allow_high_precision_mv;
    LwS8   mcomp_filter_type;
    LwS8   comp_pred_mode;
    LwS8   comp_fixed_ref;
    LwS8   comp_var_ref[2];
    LwS8   log2_tile_columns;
    LwS8   log2_tile_rows;

    /* Segment and macroblock specific values */
    LwU8   segmentEnabled;
    LwU8   segmentMapUpdate;
    LwU8   segmentMapTemporalUpdate;
    LwU8   segmentFeatureMode; /* ABS data or delta data */
    LwU8   segmentFeatureEnable[8][4];
    LwS16  segmentFeatureData[8][4];
    LwS8   modeRefLfEnabled;
    LwS8   mbRefLfDelta[4];
    LwS8   mbModeLfDelta[2];
    LwS8   reserved5;            // for alignment

    // New additions
    lwdec_vp9_pic_v1_s v1;
    lwdec_pass2_otf_ext_s ssm;

} lwdec_vp9_pic_s;

#define LWDEC_VP9HWPAD(x, y) LwU8 x[y]

typedef struct {
    /* last bytes of address 41 */
    LwU8 joints[3];
    LwU8 sign[2];
    /* address 42 */
    LwU8 class0[2][1];
    LwU8 fp[2][3];
    LwU8 class0_hp[2];
    LwU8 hp[2];
    LwU8 classes[2][10];
    /* address 43 */
    LwU8 class0_fp[2][2][3];
    LwU8 bits[2][10];

} lwdec_nmv_context;

typedef struct {
    LwU32 joints[4];
    LwU32 sign[2][2];
    LwU32 classes[2][11];
    LwU32 class0[2][2];
    LwU32 bits[2][10][2];
    LwU32 class0_fp[2][2][4];
    LwU32 fp[2][4];
    LwU32 class0_hp[2][2];
    LwU32 hp[2][2];

} lwdec_nmv_context_counts;

/* Adaptive entropy contexts, padding elements are added to have
 * 256 bit aligned tables for HW access.
 * Compile with TRACE_PROB_TABLES to print bases for each table. */
typedef struct lwdec_vp9AdaptiveEntropyProbs_s
{
    /* address 32 */
    LwU8 inter_mode_prob[7][4];
    LwU8 intra_inter_prob[4];

    /* address 33 */
    LwU8 uv_mode_prob[10][8];
    LwU8 tx8x8_prob[2][1];
    LwU8 tx16x16_prob[2][2];
    LwU8 tx32x32_prob[2][3];
    LwU8 sb_ymode_probB[4][1];
    LwU8 sb_ymode_prob[4][8];

    /* address 37 */
    LwU8 partition_prob[2][16][4];

    /* address 41 */
    LwU8 uv_mode_probB[10][1];
    LwU8 switchable_interp_prob[4][2];
    LwU8 comp_inter_prob[5];
    LwU8 mbskip_probs[3];
    LWDEC_VP9HWPAD(pad1, 1);

    lwdec_nmv_context nmvc;

    /* address 44 */
    LwU8 single_ref_prob[5][2];
    LwU8 comp_ref_prob[5];
    LWDEC_VP9HWPAD(pad2, 17);

    /* address 45 */
    LwU8 probCoeffs[2][2][6][6][4];
    LwU8 probCoeffs8x8[2][2][6][6][4];
    LwU8 probCoeffs16x16[2][2][6][6][4];
    LwU8 probCoeffs32x32[2][2][6][6][4];

} lwdec_vp9AdaptiveEntropyProbs_t;

/* Entropy contexts */
typedef struct lwdec_vp9EntropyProbs_s
{
    /* Default keyframe probs */
    /* Table formatted for 256b memory, probs 0to7 for all tables followed by
     * probs 8toN for all tables.
     * Compile with TRACE_PROB_TABLES to print bases for each table. */

    LwU8 kf_bmode_prob[10][10][8];

    /* Address 25 */
    LwU8 kf_bmode_probB[10][10][1];
    LwU8 ref_pred_probs[3];
    LwU8 mb_segment_tree_probs[7];
    LwU8 segment_pred_probs[3];
    LwU8 ref_scores[4];
    LwU8 prob_comppred[2];
    LWDEC_VP9HWPAD(pad1, 9);

    /* Address 29 */
    LwU8 kf_uv_mode_prob[10][8];
    LwU8 kf_uv_mode_probB[10][1];
    LWDEC_VP9HWPAD(pad2, 6);

    lwdec_vp9AdaptiveEntropyProbs_t a;    /* Probs with backward adaptation */

} lwdec_vp9EntropyProbs_t;

/* Counters for adaptive entropy contexts */
typedef struct lwdec_vp9EntropyCounts_s
{
    LwU32 inter_mode_counts[7][3][2];
    LwU32 sb_ymode_counts[4][10];
    LwU32 uv_mode_counts[10][10];
    LwU32 partition_counts[16][4];
    LwU32 switchable_interp_counts[4][3];
    LwU32 intra_inter_count[4][2];
    LwU32 comp_inter_count[5][2];
    LwU32 single_ref_count[5][2][2];
    LwU32 comp_ref_count[5][2];
    LwU32 tx32x32_count[2][4];
    LwU32 tx16x16_count[2][3];
    LwU32 tx8x8_count[2][2];
    LwU32 mbskip_count[3][2];

    lwdec_nmv_context_counts nmvcount;

    LwU32 countCoeffs[2][2][6][6][4];
    LwU32 countCoeffs8x8[2][2][6][6][4];
    LwU32 countCoeffs16x16[2][2][6][6][4];
    LwU32 countCoeffs32x32[2][2][6][6][4];

    LwU32 countEobs[4][2][2][6][6];

} lwdec_vp9EntropyCounts_t;

// Legacy codecs encryption parameters
typedef struct _lwdec_pass2_otf_s {
    LwU32   wrapped_session_key[4];  // session keys
    LwU32   wrapped_content_key[4];  // content keys
    LwU32   initialization_vector[4];// Ctrl64 initial vector
    LwU32   enable_encryption : 1;   // flag to enable/disable encryption
    LwU32   key_increment     : 6;   // added to content key after unwrapping
    LwU32   encryption_mode   : 4;
    LwU32   key_slot_index    : 4;
    LwU32   ssm_en            : 1;
    LwU32   reserved1         :16;   // reserved
} lwdec_pass2_otf_s; // 0x10 bytes

typedef struct _lwdec_display_param_s
{
    LwU32 enableTFOutput    : 1; //=1, enable dbfdma to output the display surface; if disable, then the following configure on tf is useless.
    //remap for VC1
    LwU32 VC1MapYFlag       : 1;
    LwU32 MapYValue         : 3;
    LwU32 VC1MapUVFlag      : 1;
    LwU32 MapUVValue        : 3;
    //tf
    LwU32 OutStride         : 8;
    LwU32 TilingFormat      : 3;
    LwU32 OutputStructure   : 1; //(0=frame, 1=field)
    LwU32 reserved0         :11;
    LwS32 OutputTop[2];                   // in units of 256
    LwS32 OutputBottom[2];                // in units of 256
    //histogram
    LwU32 enableHistogram   : 1; // enable histogram info collection.
    LwU32 HistogramStartX   :12; // start X of Histogram window
    LwU32 HistogramStartY   :12; // start Y of Histogram window
    LwU32 reserved1         : 7;
    LwU32 HistogramEndX     :12; // end X of Histogram window
    LwU32 HistogramEndY     :12; // end y of Histogram window
    LwU32 reserved2         : 8;
} lwdec_display_param_s;  // size 0x1c bytes

// H.264
typedef struct _lwdec_dpb_entry_s  // 16 bytes
{
    LwU32 index          : 7;    // uncompressed frame buffer index
    LwU32 col_idx        : 5;    // index of associated co-located motion data buffer
    LwU32 state          : 2;    // bit1(state)=1: top field used for reference, bit1(state)=1: bottom field used for reference
    LwU32 is_long_term   : 1;    // 0=short-term, 1=long-term
    LwU32 not_existing   : 1;    // 1=marked as non-existing
    LwU32 is_field       : 1;    // set if unpaired field or complementary field pair
    LwU32 top_field_marking : 4;
    LwU32 bottom_field_marking : 4;
    LwU32 output_memory_layout : 1;  // Set according to picture level output LW12/LW24 setting.
    LwU32 reserved       : 6;
    LwU32 FieldOrderCnt[2];      // : 2*32 [top/bottom]
    LwU32 FrameIdx;                       // : 16   short-term: FrameNum (16 bits), long-term: LongTermFrameIdx (4 bits)
} lwdec_dpb_entry_s;

typedef struct _lwdec_h264_pic_s
{
    lwdec_pass2_otf_s encryption_params;
    LwU8  eos[16];
    LwU8  explicitEOSPresentFlag;
    LwU8  hint_dump_en; //enable COLOMV surface dump for all frames, which includes hints of "MV/REFIDX/QP/CBP/MBPART/MBTYPE", lwbug: 200212874
    LwU8  reserved0[2];
    LwU32 stream_len;
    LwU32 slice_count;
    LwU32 mbhist_buffer_size;     // to pass buffer size of MBHIST_BUFFER

    // Driver may or may not use based upon need.
    // If 0 then default value of 1<<27 = 298ms @ 450MHz will be used in ucode.
    // Driver can send this value based upon resolution using the formula:
    // gptimer_timeout_value = 3 * (cycles required for one frame)
    LwU32 gptimer_timeout_value;

    // Fields from msvld_h264_seq_s
    LwS32 log2_max_pic_order_cnt_lsb_minus4;
    LwS32 delta_pic_order_always_zero_flag;
    LwS32 frame_mbs_only_flag;
    LwU32 PicWidthInMbs;
    LwU32 FrameHeightInMbs;

    LwU32 tileFormat                 : 2 ;   // 0: TBL; 1: KBL; 2: Tile16x16
    LwU32 gob_height                 : 3 ;   // Set GOB height, 0: GOB_2, 1: GOB_4, 2: GOB_8, 3: GOB_16, 4: GOB_32 (LWDEC3 onwards)
    LwU32 reserverd_surface_format   : 27;   

    // Fields from msvld_h264_pic_s
    LwU32 entropy_coding_mode_flag;
    LwS32 pic_order_present_flag;
    LwS32 num_ref_idx_l0_active_minus1;
    LwS32 num_ref_idx_l1_active_minus1;
    LwS32 deblocking_filter_control_present_flag;
    LwS32 redundant_pic_cnt_present_flag;
    LwU32 transform_8x8_mode_flag;

    // Fields from mspdec_h264_picture_setup_s
    LwU32 pitch_luma;                    // Luma pitch
    LwU32 pitch_chroma;                  // chroma pitch

    LwU32 luma_top_offset;               // offset of luma top field in units of 256
    LwU32 luma_bot_offset;               // offset of luma bottom field in units of 256
    LwU32 luma_frame_offset;             // offset of luma frame in units of 256
    LwU32 chroma_top_offset;             // offset of chroma top field in units of 256
    LwU32 chroma_bot_offset;             // offset of chroma bottom field in units of 256
    LwU32 chroma_frame_offset;           // offset of chroma frame in units of 256
    LwU32 HistBufferSize;                // in units of 256

    LwU32 MbaffFrameFlag           : 1;  //
    LwU32 direct_8x8_inference_flag: 1;  //
    LwU32 weighted_pred_flag       : 1;  //
    LwU32 constrained_intra_pred_flag:1; //
    LwU32 ref_pic_flag             : 1;  // reference picture (nal_ref_idc != 0)
    LwU32 field_pic_flag           : 1;  //
    LwU32 bottom_field_flag        : 1;  //
    LwU32 second_field             : 1;  // second field of complementary reference field
    LwU32 log2_max_frame_num_minus4: 4;  //  (0..12)
    LwU32 chroma_format_idc        : 2;  //
    LwU32 pic_order_cnt_type       : 2;  //  (0..2)
    LwS32 pic_init_qp_minus26               : 6;  // : 6 (-26..+25)
    LwS32 chroma_qp_index_offset            : 5;  // : 5 (-12..+12)
    LwS32 second_chroma_qp_index_offset     : 5;  // : 5 (-12..+12)

    LwU32 weighted_bipred_idc      : 2;  // : 2 (0..2)
    LwU32 LwrrPicIdx               : 7;  // : 7  uncompressed frame buffer index
    LwU32 LwrrColIdx               : 5;  // : 5  index of associated co-located motion data buffer
    LwU32 frame_num                : 16; //
    LwU32 frame_surfaces           : 1;  // frame surfaces flag
    LwU32 output_memory_layout     : 1;  // 0: LW12; 1:LW24. Field pair must use the same setting.

    LwS32 LwrrFieldOrderCnt[2];                   // : 32 [Top_Bottom], [0]=TopFieldOrderCnt, [1]=BottomFieldOrderCnt
    lwdec_dpb_entry_s dpb[16];
    LwU8  WeightScale[6][4][4];         // : 6*4*4*8 in raster scan order (not zig-zag order)
    LwU8  WeightScale8x8[2][8][8];      // : 2*8*8*8 in raster scan order (not zig-zag order)

    // mvc setup info, must be zero if not mvc
    LwU8 num_inter_view_refs_lX[2];         // number of inter-view references
    LwS8 reserved1[14];                               // reserved for alignment
    LwS8 inter_view_refidx_lX[2][16];         // DPB indices (must also be marked as long-term)

    // lossless decode (At the time of writing this manual, x264 and JM encoders, differ in Intra_8x8 reference sample filtering)
    LwU32 lossless_ipred8x8_filter_enable        : 1;       // = 0, skips Intra_8x8 reference sample filtering, for vertical and horizontal predictions (x264 encoded streams); = 1, filter Intra_8x8 reference samples (JM encoded streams)
    LwU32 qpprime_y_zero_transform_bypass_flag   : 1;       // determines the transform bypass mode
    LwU32 reserved2                              : 30;      // kept for alignment; may be used for other parameters

    lwdec_display_param_s displayPara;
    lwdec_pass2_otf_ext_s ssm;

} lwdec_h264_pic_s;

// VC-1 Scratch buffer
typedef enum _vc1_fcm_e
{
    FCM_PROGRESSIVE = 0,
    FCM_FRAME_INTERLACE = 2,
    FCM_FIELD_INTERLACE = 3
} vc1_fcm_e;

typedef enum _syntax_vc1_ptype_e
{
    PTYPE_I       = 0,
    PTYPE_P       = 1,
    PTYPE_B       = 2,
    PTYPE_BI      = 3, //PTYPE_BI is not used to config register LW_CLWDEC_VLD_PIC_INFO_COMMON. field LW_CLWDEC_VLD_PIC_INFO_COMMON_PIC_CODING_VC1 is only 2 bits. I and BI pictures are configured with same value. Please refer to manual.
    PTYPE_SKIPPED = 4
} syntax_vc1_ptype_e;

// 7.1.1.32, Table 46 etc.
enum vc1_mvmode_e
{
    MVMODE_MIXEDMV                = 0,
    MVMODE_1MV                    = 1,
    MVMODE_1MV_HALFPEL            = 2,
    MVMODE_1MV_HALFPEL_BILINEAR   = 3,
    MVMODE_INTENSITY_COMPENSATION = 4
};

// 9.1.1.42, Table 105
typedef enum _vc1_fptype_e
{
    FPTYPE_I_I = 0,
    FPTYPE_I_P,
    FPTYPE_P_I,
    FPTYPE_P_P,
    FPTYPE_B_B,
    FPTYPE_B_BI,
    FPTYPE_BI_B,
    FPTYPE_BI_BI
} vc1_fptype_e;

// Table 43 (7.1.1.31.2)
typedef enum _vc1_dqprofile_e
{
    DQPROFILE_ALL_FOUR_EDGES  = 0,
    DQPROFILE_DOUBLE_EDGE     = 1,
    DQPROFILE_SINGLE_EDGE     = 2,
    DQPROFILE_ALL_MACROBLOCKS = 3
} vc1_dqprofile_e;

typedef struct _lwdec_vc1_pic_s
{
    lwdec_pass2_otf_s encryption_params;
    LwU8  eos[16];                    // to pass end of stream data separately if not present in bitstream surface
    LwU8  prefixStartCode[4];         // used for dxva to pass prefix start code.
    LwU32 bitstream_offset;           // offset in words from start of bitstream surface if there is gap.
    LwU8  explicitEOSPresentFlag;     // to indicate that eos[] is used for passing end of stream data.
    LwU8  reserved0[3];
    LwU32 stream_len;
    LwU32 slice_count;
    LwU32 scratch_pic_buffer_size;

    // Driver may or may not use based upon need.
    // If 0 then default value of 1<<27 = 298ms @ 450MHz will be used in ucode.
    // Driver can send this value based upon resolution using the formula:
    // gptimer_timeout_value = 3 * (cycles required for one frame)
    LwU32 gptimer_timeout_value;

    // Fields from vc1_seq_s
    LwU16 FrameWidth;     // actual frame width
    LwU16 FrameHeight;    // actual frame height

    LwU8 profile;        // 1 = SIMPLE or MAIN, 2 = ADVANCED
    LwU8 postprocflag;
    LwU8 pulldown;
    LwU8 interlace;

    LwU8 tfcntrflag;
    LwU8 finterpflag;
    LwU8 psf;
    LwU8 tileFormat                 : 2 ;   // 0: TBL; 1: KBL; 2: Tile16x16
    LwU8 gob_height                 : 3 ;   // Set GOB height, 0: GOB_2, 1: GOB_4, 2: GOB_8, 3: GOB_16, 4: GOB_32 (LWDEC3 onwards)
    LwU8 reserverd_surface_format   : 3 ;   

    // simple,main
    LwU8 multires;
    LwU8 syncmarker;
    LwU8 rangered;
    LwU8 maxbframes;

    // Fields from vc1_entrypoint_s
    LwU8 dquant;
    LwU8 panscan_flag;
    LwU8 refdist_flag;
    LwU8 quantizer;

    LwU8 extended_mv;
    LwU8 extended_dmv;
    LwU8 overlap;
    LwU8 vstransform;

    // Fields from vc1_scratch_s
    LwS8 refdist;
    LwS8 reserved1[3];               // for alignment

    // Fields from vld_vc1_pic_s
    vc1_fcm_e fcm;
    syntax_vc1_ptype_e ptype;
    LwS32 tfcntr;
    LwS32 rptfrm;
    LwS32 tff;
    LwS32 rndctrl;
    LwS32 pqindex;
    LwS32 halfqp;
    LwS32 pquantizer;
    LwS32 postproc;
    LwS32 condover;
    LwS32 transacfrm;
    LwS32 transacfrm2;
    LwS32 transdctab;
    LwS32 pqdiff;
    LwS32 abspq;
    LwS32 dquantfrm;
    vc1_dqprofile_e dqprofile;
    LwS32 dqsbedge;
    LwS32 dqdbedge;
    LwS32 dqbilevel;
    LwS32 mvrange;
    enum vc1_mvmode_e mvmode;
    enum vc1_mvmode_e mvmode2;
    LwS32 lumscale;
    LwS32 lumshift;
    LwS32 mvtab;
    LwS32 cbptab;
    LwS32 ttmbf;
    LwS32 ttfrm;
    LwS32 bfraction;
    vc1_fptype_e fptype;
    LwS32 numref;
    LwS32 reffield;
    LwS32 dmvrange;
    LwS32 intcompfield;
    LwS32 lumscale1;  //  type was LwS8 in ucode
    LwS32 lumshift1;  //  type was LwS8 in ucode
    LwS32 lumscale2;  //  type was LwS8 in ucode
    LwS32 lumshift2;  //  type was LwS8 in ucode
    LwS32 mbmodetab;
    LwS32 imvtab;
    LwS32 icbptab;
    LwS32 fourmvbptab;
    LwS32 fourmvswitch;
    LwS32 intcomp;
    LwS32 twomvbptab;
    // simple,main
    LwS32 rangeredfrm;

    // Fields from pdec_vc1_pic_s
    LwU32   HistBufferSize;                  // in units of 256
    // frame buffers
    LwU32   FrameStride[2];                  // [y_c]
    LwU32   luma_top_offset;                 // offset of luma top field in units of 256
    LwU32   luma_bot_offset;                 // offset of luma bottom field in units of 256
    LwU32   luma_frame_offset;               // offset of luma frame in units of 256
    LwU32   chroma_top_offset;               // offset of chroma top field in units of 256
    LwU32   chroma_bot_offset;               // offset of chroma bottom field in units of 256
    LwU32   chroma_frame_offset;             // offset of chroma frame in units of 256

    LwU16 CodedWidth;                      // entrypoint specific
    LwU16 CodedHeight;                     // entrypoint specific

    LwU8  loopfilter;                      // entrypoint specific
    LwU8  fastuvmc;                        // entrypoint specific
    LwU8  output_memory_layout;            // picture specific
    LwU8  ref_memory_layout[2];            // picture specific 0: fwd, 1: bwd
    LwU8  reserved3[3];                    // for alignment

    lwdec_display_param_s displayPara;
    lwdec_pass2_otf_ext_s ssm;

} lwdec_vc1_pic_s;

// MPEG-2
typedef struct _lwdec_mpeg2_pic_s
{
    lwdec_pass2_otf_s encryption_params;
    LwU8  eos[16];
    LwU8  explicitEOSPresentFlag;
    LwU8  reserved0[3];
    LwU32 stream_len;
    LwU32 slice_count;

    // Driver may or may not use based upon need.
    // If 0 then default value of 1<<27 = 298ms @ 450MHz will be used in ucode.
    // Driver can send this value based upon resolution using the formula:
    // gptimer_timeout_value = 3 * (cycles required for one frame)
    LwU32 gptimer_timeout_value;

    // Fields from vld_mpeg2_seq_pic_info_s
    LwU16 FrameWidth;                   // actual frame width
    LwU16 FrameHeight;                  // actual frame height
    LwU8  picture_structure;            // 0 => Reserved, 1 => Top field, 2 => Bottom field, 3 => Frame picture. Table 6-14.
    LwU8  picture_coding_type;          // 0 => Forbidden, 1 => I, 2 => P, 3 => B, 4 => D (for MPEG-2). Table 6-12.
    LwU8  intra_dc_precision;           // 0 => 8 bits, 1=> 9 bits, 2 => 10 bits, 3 => 11 bits. Table 6-13.
    LwS8  frame_pred_frame_dct;         // as in section 6.3.10
    LwS8  concealment_motion_vectors;   // as in section 6.3.10
    LwS8  intra_vlc_format;             // as in section 6.3.10
    LwU8  tileFormat                 : 2 ;   // 0: TBL; 1: KBL; 2: Tile16x16
    LwU8  gob_height                 : 3 ;   // Set GOB height, 0: GOB_2, 1: GOB_4, 2: GOB_8, 3: GOB_16, 4: GOB_32 (LWDEC3 onwards)
    LwU8  reserverd_surface_format   : 3 ;   

    LwS8 reserved1;                     // always 0
    LwS8 f_code[4];                  // as in section 6.3.10

    // Fields from pdec_mpeg2_picture_setup_s
    LwU16 PicWidthInMbs;
    LwU16 FrameHeightInMbs;
    LwU32 pitch_luma;
    LwU32 pitch_chroma;
    LwU32 luma_top_offset;
    LwU32 luma_bot_offset;
    LwU32 luma_frame_offset;
    LwU32 chroma_top_offset;
    LwU32 chroma_bot_offset;
    LwU32 chroma_frame_offset;
    LwU32 HistBufferSize;
    LwU16 output_memory_layout;
    LwU16 alternate_scan;
    LwU16 secondfield;
    /******************************/
    // Got rid of the union kept for compatibility with LWDEC1.
    // Removed field mpeg2, and kept rounding type.
    // LWDEC1 ucode is not using the mpeg2 field, instead using codec type from the methods.
    // Rounding type should only be set for Divx3.11.
    LwU16 rounding_type;
    /******************************/
    LwU32 MbInfoSizeInBytes;
    LwU32 q_scale_type;
    LwU32 top_field_first;
    LwU32 full_pel_fwd_vector;
    LwU32 full_pel_bwd_vector;
    LwU8  quant_mat_8x8intra[64];
    LwU8  quant_mat_8x8nonintra[64];
    LwU32 ref_memory_layout[2]; //0:for fwd; 1:for bwd

    lwdec_display_param_s displayPara;
    lwdec_pass2_otf_ext_s ssm;

} lwdec_mpeg2_pic_s;

// MPEG-4
typedef struct _lwdec_mpeg4_pic_s
{
    lwdec_pass2_otf_s encryption_params;
    LwU8  eos[16];
    LwU8  explicitEOSPresentFlag;
    LwU8  reserved2[3];     // for alignment
    LwU32 stream_len;
    LwU32 slice_count;
    LwU32 scratch_pic_buffer_size;

    // Driver may or may not use based upon need.
    // If 0 then default value of 1<<27 = 298ms @ 450MHz will be used in ucode.
    // Driver can send this value based upon resolution using the formula:
    // gptimer_timeout_value = 3 * (cycles required for one frame)
    LwU32 gptimer_timeout_value;

    // Fields from vld_mpeg4_seq_s
    LwS16 FrameWidth;                     // :13 video_object_layer_width
    LwS16 FrameHeight;                    // :13 video_object_layer_height
    LwU8  vop_time_increment_bitcount;    // : 5 1..16
    LwS8  resync_marker_disable;          // : 1
    LwU8  tileFormat                 : 2 ;   // 0: TBL; 1: KBL; 2: Tile16x16
    LwU8  gob_height                 : 3 ;   // Set GOB height, 0: GOB_2, 1: GOB_4, 2: GOB_8, 3: GOB_16, 4: GOB_32 (LWDEC3 onwards)
    LwU8  reserverd_surface_format   : 3 ;   
    LwS8  reserved3;                      // for alignment

    // Fields from pdec_mpeg4_picture_setup_s
    LwS32 width;                              // : 13
    LwS32 height;                             // : 13

    LwU32 FrameStride[2];            // [y_c]
    LwU32 luma_top_offset;           // offset of luma top field in units of 256
    LwU32 luma_bot_offset;           // offset of luma bottom field in units of 256
    LwU32 luma_frame_offset;         // offset of luma frame in units of 256
    LwU32 chroma_top_offset;         // offset of chroma top field in units of 256
    LwU32 chroma_bot_offset;         // offset of chroma bottom field in units of 256
    LwU32 chroma_frame_offset;       // offset of chroma frame in units of 256

    LwU32 HistBufferSize;            // in units of 256, History buffer size

    LwS32 trd[2];                             // : 16, temporal reference frame distance (only needed for B-VOPs)
    LwS32 trb[2];                             // : 16, temporal reference B-VOP distance from fwd reference frame (only needed for B-VOPs)

    LwS32 divx_flags;                         // : 16 (bit 0: DivX interlaced chroma rounding, bit 1: Divx 4 boundary padding, bit 2: Divx IDCT)

    LwS16 vop_fcode_forward;                // : 1...7
    LwS16 vop_fcode_backward;               // : 1...7

    LwU8 interlaced;               // : 1
    LwU8 quant_type;               // : 1
    LwU8 quarter_sample;           // : 1
    LwU8 short_video_header;       // : 1

    LwU8 lwrr_output_memory_layout; // : 1 0:LW12; 1:LW24
    LwU8 ptype;                    // picture type: 0 for PTYPE_I, 1 for PTYPE_P, 2 for PTYPE_B, 3 for PTYPE_BI, 4 for PTYPE_SKIPPED
    LwU8 rnd;                      // : 1, rounding mode
    LwU8 alternate_vertical_scan_flag; // : 1

    LwU8 top_field_flag;           // : 1
    LwU8 reserved0[3];             // alignment purpose

    LwU8 intra_quant_mat[64];      // : 64*8
    LwU8 nonintra_quant_mat[64];   // : 64*8
    LwU8 ref_memory_layout[2];    //0:for fwd; 1:for bwd
    LwU8 reserved1[34];            // 256 byte alignemnt till now

    lwdec_display_param_s displayPara;

} lwdec_mpeg4_pic_s;

// VP8
enum VP8_FRAME_TYPE
{
    VP8_KEYFRAME = 0,
    VP8_INTERFRAME = 1
};

enum VP8_FRAME_SFC_ID
{
    VP8_GOLDEN_FRAME_SFC = 0,
    VP8_ALTREF_FRAME_SFC,
    VP8_LAST_FRAME_SFC,
    VP8_LWRR_FRAME_SFC
};

typedef struct _lwdec_vp8_pic_s
{
    lwdec_pass2_otf_s encryption_params;

    // Driver may or may not use based upon need.
    // If 0 then default value of 1<<27 = 298ms @ 450MHz will be used in ucode.
    // Driver can send this value based upon resolution using the formula:
    // gptimer_timeout_value = 3 * (cycles required for one frame)
    LwU32 gptimer_timeout_value;

    LwU16 FrameWidth;     // actual frame width
    LwU16 FrameHeight;    // actual frame height

    LwBool keyFrame;        // 1: key frame; 0: not
    LwU8   version;
    LwU8   tileFormat                 : 2 ;   // 0: TBL; 1: KBL; 2: Tile16x16
    LwU8   gob_height                 : 3 ;   // Set GOB height, 0: GOB_2, 1: GOB_4, 2: GOB_8, 3: GOB_16, 4: GOB_32 (LWDEC3 onwards)
    LwU8   reserverd_surface_format   : 3 ;   
    LwU8   errorConcealOn;  // 1: error conceal on; 0: off

    LwU32  firstPartSize;   // the size of first partition(frame header and mb header partition)

    // ctx
    LwU32   HistBufferSize;                  // in units of 256
    LwU32   VLDBufferSize;                   // in units of 1
    // current frame buffers
    LwU32   FrameStride[2];                  // [y_c]
    LwU32   luma_top_offset;                 // offset of luma top field in units of 256
    LwU32   luma_bot_offset;                 // offset of luma bottom field in units of 256
    LwU32   luma_frame_offset;               // offset of luma frame in units of 256
    LwU32   chroma_top_offset;               // offset of chroma top field in units of 256
    LwU32   chroma_bot_offset;               // offset of chroma bottom field in units of 256
    LwU32   chroma_frame_offset;             // offset of chroma frame in units of 256

    lwdec_display_param_s displayPara;

    // decode picture buffere related
    LwS8 lwrrent_output_memory_layout;
    LwS8 output_memory_layout[3];  // output LW12/LW24 setting. item 0:golden; 1: altref; 2: last

    LwU8 segmentation_feature_data_update;
    LwU8 reserved1[3];

    // ucode return result
    LwU32 resultValue;      // ucode return the picture header info; includes copy_buffer_to_golden etc.
    LwU32 partition_offset[8];            // byte offset to each token partition (used for encrypted streams only)

    lwdec_pass2_otf_ext_s ssm;

} lwdec_vp8_pic_s; // size is 0xc0

// PASS1

//Sample means the entire frame is encrypted with a single IV, and subsample means a given frame may be encrypted in multiple chunks with different IVs.
#define NUM_SUBSAMPLES      32

typedef struct _bytes_of_data_s
{
    LwU32    clear_bytes;                    // clear bytes per subsample
    LwU32    encypted_bytes;                 // encrypted bytes per subsample

} bytes_of_data_s;

typedef struct _lwdec_pass1_input_data_s
{
    bytes_of_data_s sample_size[NUM_SUBSAMPLES];    // clear/encrypted bytes per subsample
    LwU32    initialization_vector[NUM_SUBSAMPLES][4];   // Ctrl64 initial vector per subsample
    LwU8     IvValid[NUM_SUBSAMPLES];        // each element will tell whether IV is valid for that subsample or not.
    LwU32    stream_len;                     // encrypted bitstream size.
    LwU32    clearBufferSize;                // allocated size of clear buffer size
    LwU32    reencryptBufferSize;            // allocated size of reencrypted buffer size
    LwU32    vp8coeffPartitonBufferSize;     // allocated buffer for vp8 coeff partition buffer
    LwU32    PrevWidth;                        // required for VP9
    LwU32    num_nals        :16;            // number of subsamples in a frame
    LwU32    drm_mode        : 8;            // DRM mode
    LwU32    key_sel         : 4;            // key select from keyslot
    LwU32    codec           : 4;            // codecs selection
    LwU32    TotalSizeOfClearData;           // Used with Pattern based encryption
    LwU32    SliceHdrOffset;                 // This is used with pattern mode encryption where data before slice hdr comes in clear.
    LwU32    EncryptBlkCnt   :16;
    LwU32    SkipBlkCnt      :16;
} lwdec_pass1_input_data_s;

#define VP8_MAX_TOKEN_PARTITIONS     8
#define VP9_MAX_FRAMES_IN_SUPERFRAME 8

typedef struct _lwdec_pass1_output_data_s
{
    LwU32    clear_header_size;              // h264/vc1/mpeg2/vp8, decrypted pps/sps/part of slice header info, 128 bits aligned
    LwU32    reencrypt_data_size;            // h264/vc1/mpeg2, slice level data, vp8 mb header info, 128 bits aligned
    LwU32    clear_token_data_size;          // vp8, clear token data saved in VPR, 128 bits aligned
    LwU32    key_increment   : 6;            // added to content key after unwrapping
    LwU32    encryption_mode : 4;            // encryption mode
    LwU32    bReEncrypted    : 1;            // set to 0 if no re-encryption is done.
    LwU32    bvp9SuperFrame  : 1;            // set to 1 for vp9 superframe
    LwU32    vp9NumFramesMinus1    : 3;      // set equal to numFrames-1 for vp9superframe. Max 8 frames are possible in vp9 superframe.
    LwU32    reserved1       :17;            // reserved, 32 bit alignment
    LwU32    wrapped_session_key[4];         // session keys
    LwU32    wrapped_content_key[4];         // content keys
    LwU32    initialization_vector[4];       // Ctrl64 initial vector
    union {
        LwU32    partition_size[VP8_MAX_TOKEN_PARTITIONS];            // size of each token partition (used for encrypted streams of VP8)
        LwU32    vp9_frame_sizes[VP9_MAX_FRAMES_IN_SUPERFRAME];       // frame size information for all frames in vp9 superframe.
    };
    LwU32    vp9_clear_hdr_size[VP9_MAX_FRAMES_IN_SUPERFRAME];          // clear header size for each frame in vp9 superframe.
} lwdec_pass1_output_data_s;

#endif // __DRV_LWDEC_H_
