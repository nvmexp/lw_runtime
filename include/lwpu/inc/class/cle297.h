/*
 * LWIDIA_COPYRIGHT_BEGIN
 *
 * Copyright 2010 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * LWIDIA_COPYRIGHT_END
 */
#ifndef _cl_e297_h_
#define _cl_e297_h_

#include "lwtypes.h"
#define LW_E2_THREED                             (0xE297)
#define LWE297_ADDRBITS_PER_UNIT  8
#define LW_LWE297_CTL_INCR_SYNCPT_NB_CONDS        4

#define LWE297_CTL_INCR_SYNCPT_0                                  (0x0)
#define LWE297_CTL_INCR_SYNCPT_0_COND                             15:8
#define LWE297_CTL_INCR_SYNCPT_0_COND_IMMEDIATE                   0x00000000
#define LWE297_CTL_INCR_SYNCPT_0_COND_OP_DONE                     0x00000001
#define LWE297_CTL_INCR_SYNCPT_0_COND_RD_DONE                     0x00000002
#define LWE297_CTL_INCR_SYNCPT_0_COND_REG_WR_SAFE                 0x00000003
#define LWE297_CTL_INCR_SYNCPT_0_COND_COND_4                      0x00000004
#define LWE297_CTL_INCR_SYNCPT_0_COND_COND_5                      0x00000005
#define LWE297_CTL_INCR_SYNCPT_0_COND_COND_6                      0x00000006
#define LWE297_CTL_INCR_SYNCPT_0_COND_COND_7                      0x00000007
#define LWE297_CTL_INCR_SYNCPT_0_COND_COND_8                      0x00000008
#define LWE297_CTL_INCR_SYNCPT_0_COND_COND_9                      0x00000009
#define LWE297_CTL_INCR_SYNCPT_0_COND_COND_10                     0x0000000a
#define LWE297_CTL_INCR_SYNCPT_0_COND_COND_11                     0x0000000b
#define LWE297_CTL_INCR_SYNCPT_0_COND_COND_12                     0x0000000c
#define LWE297_CTL_INCR_SYNCPT_0_COND_COND_13                     0x0000000d
#define LWE297_CTL_INCR_SYNCPT_0_COND_COND_14                     0x0000000e
#define LWE297_CTL_INCR_SYNCPT_0_COND_COND_15                     0x0000000f
#define LWE297_CTL_INCR_SYNCPT_0_INDX                             7:0


// If SOFT_RESET is set, then all internal state
// of the client syncpt block will be reset.
// To do soft reset, first set SOFT_RESET of
// all host1x clients affected, then clear all
// SOFT_RESETs.
#define LWE297_CTL_INCR_SYNCPT_CNTRL_0                            (0x1)
#define LWE297_CTL_INCR_SYNCPT_CNTRL_0_NO_STALL                   8:8
#define LWE297_CTL_INCR_SYNCPT_CNTRL_0_SOFT_RESET                  0:0


#define LWE297_CTL_INCR_SYNCPT_ERROR_0                            (0x2)
#define LWE297_CTL_INCR_SYNCPT_ERROR_0_COND_STATUS                31:0

// Reserved address 3 [0x3] 
// Reserved address 4 [0x4] 
// Reserved address 5 [0x5] 
// Reserved address 6 [0x6] 
// Reserved address 7 [0x7] 
// just in case names were redefined using macros


// INTR_STATS maintains a vector of interrupt sources which are lwrrently signaling to the host (level sensitive)
//
// CTXSW_INT:
// When setup receives a context switch, it first compares the channel_id (that came along with the context
// switch request) against the active channel_id.  If the two channel_ids are the same -or- CTXSW_INT_EN is
// DISABLE, it sends an ACK back to the host acknowledging the context switch immediately. If the channel_ids
// are different -and- CTXSW_INT_EN is ENABLE, setup asserts an interrupt to the CPU and waits for the CPU to
// store the current context's state (assuming it is valid) and restore the new context's state (assuming it
// is valid). The CPU then writes the CTXSW_CHANNEL LAST field with the NEXT field's value to cause a CTXSW_ACK
// to be sent to the host, restarting DMA input to the new channel.
//

#define LWE297_CTL_INTSTATUS_0                                    (0x8)
#define LWE297_CTL_INTSTATUS_0_CTXSW_INT                          0:0


#define LWE297_CTL_INTENABLE_0                                    (0x9)
#define LWE297_CTL_INTENABLE_0_CTXSW_INT                           0:0
#define LWE297_CTL_INTENABLE_0_CTXSW_INT_DISABLE                  0x00000000
#define LWE297_CTL_INTENABLE_0_CTXSW_INT_ENABLE                   0x00000001


/*
 * Context switch register.  Should be common to all modules.  Includes the
 * current channel/class (which is writable by SW) and the next channel/class
 * (which the hardware sets when it receives a context switch).
 * Context switch works like this:
 * Any context switch request triggers an interrupt to the host and causes the
 * new channel/class to be stored in NEXT_CHANNEL/NEXT_CLASS (see
 * vmod/chexample).  SW sees that there is a context switch interrupt and does
 * the necessary operations to make the module ready to receive traffic from
 * the new context.  It clears the context switch interrupt and writes
 * LWRR_CHANNEL/CLASS to the same value as NEXT_CHANNEL/CLASS, which causes a
 * context switch acknowledge packet to be sent to the host.  This completes
 * the context switch and allows the host to continue sending data to the
 * module.
 * Context switches can also be pre-loaded.  If LWRR_CLASS/CHANNEL are written
 * and updated to the next CLASS/CHANNEL before the context switch request
 * oclwrs, an acknowledge will be generated by the module and no interrupt will
 * be triggered.  This is one way for software to avoid dealing with context
 * switch interrupts.
 * Another way to avoid context switch interrupts is to set the AUTO_ACK bit.
 * This bit tells the module to automatically acknowledge any incoming context
 * switch requests without triggering an interrupt.  LWRR_* and NEXT_* will be
 * updated by the module so they will always be current.
 *
 *  AUTO_ACK: Automatically acknowledge any incoming context switch requests
 *
 */

#define LWE297_CTL_CTXSW_0                                        (0xa)
#define LWE297_CTL_CTXSW_0_NEXT_CHANNEL                           31:28
#define LWE297_CTL_CTXSW_0_NEXT_CLASS                             25:16
#define LWE297_CTL_CTXSW_0_LWRR_CHANNEL                           15:12
#define LWE297_CTL_CTXSW_0_AUTO_ACK                               11:11
#define LWE297_CTL_CTXSW_0_AUTO_ACK_MANUAL                        0x00000000
#define LWE297_CTL_CTXSW_0_AUTO_ACK_AUTOACK                       0x00000001
#define LWE297_CTL_CTXSW_0_LWRR_CLASS                             9:0


/*
 *
 * STAT - statistics gathering control registers
 *
 * There are LW_GR3D_NUM_STAT_SETS independent sets of statistics counters.
 * Each counter set collects information from a specified probe point about
 * how many clocks have elapsed while counting was active, how many transfers
 * happened (typically this means the downstream block was ready and the
 * upstream block had valid data), how many clocks were spent waiting
 * (typically this means the upstream block  had valid data available at its
 * output but the downstream block was stalled), and how many times collection
 * itself was enabled. Counters are controlled from two places, the STAT[]
 * register's EN field and the last value of the global INSTRUMENT register's
 * STAT_EN field which was seen passing the probe point (this could be used
 * to track mode changes, e.g. if you think an app is toggling blending on
 * and off too often instead of sorting by rendering mode, you can add a hook
 * into the driver to enable INSTRUMENT STAT_EN only when blending is enabled,
 * and then count the number of times you see it toggling inside the pipe.
 * In combination with the pixel count being collected, you can see if the
 * average length that a mode is enabled for seems efficient or not, i.e.
 * pixels / times enabled == size of batches of pixels between mode changes,
 * independent of how many triangles were sent).
 *
 * The STAT[i] register is written (through the command buffer) to control
 * which statistics are being gathered. EN is used as a master gate to enable
 * counting in conjunction with the last value of the STAT_EN field of the
 * INSTRUMENT register which flowed past the probe point. BLK selects which
 * point a given set of counters will be monitoring.
 *
 * Typical operation would be enable STAT[].EN, send an
 * INSTRUMENT register down the pipeline (possibly correlated with API mode settings
 * such as blend mode, etc.) with the STAT_EN field set, wait for rendering to
 * complete and read back the counters. It is also possible to read the counters
 * as they are actively counting, but be aware that counts read this way will not
 * be atomic across the entire set. Also be aware that writing STAT[].EN through
 * the command buffer is asynchronous to the read path, so flushing the command
 * buffer is necessary if precise counts are desired.
 *
 * The _COUNT registers are read-write.  They can be context-switched if necessary.
 * To reset the counter values, write a zero to them.
 *
 * ====== STAT PROBE POINT DOCUMENTATION ======
 *
 * The following table dolwments the use of the stat probe points.  In order to
 * reduce needless repetition, the following rules apply:
 *
 * 1) If not otherwise noted, the STEN probe point counts the number of clocks that
 *    the local copy of STAT_EN was enabled for that probe point.  This means that
 *    the CLK_COUNT register will have the number of clocks that the stat was
 *    enabled as seen by that probe point (and the EN_COUNT will have the number
 *    of times STAT_EN was enabled).  Some probe points reuse the STEN signal to
 *    communicate other information, which will be noted in the table.  For these
 *    probe points, the EN_COUNT counter usually does not provide useful information.
 *
 * 2) If .XFER or .WAIT is omitted, then that signal isn't used by that probe point.
 *
 * 3) Some probe points measure traffic on bus interfaces between the modules.  For
 *    these probe points, the probe signals are defined as follows:
 *      XFER: number of transfers on that bus (upstream valid, downstream not stalled).
 *      WAIT: number of stalls due to downstream busy (upstream valid, downstream stalled).
 *      STEN: number of clocks that stat collection was enabled (STEN_EN = 1)
 *    These probe points will be marked as BUS in the table below.
 *
 * 4) Some probe points redefine the three signals to count something that can increment
 *    more than once per clock, like a count of bytes.  These probe points encode the
 *    total count via the three signals by scaling the three counters.  For these signals,
 *    software should gather the final count with
 *      total = XFER_COUNT + 2 * WAIT_COUNT + 4 * CLK_COUNT
 *    These probe points will be marked with TOTAL in the table below.
 *
 * 5) Some probe points come in pairs, for example VPE_THREAD0 and VPE_THREAD1.  These
 *    are usually identical except for being duplicated.  In this instance, they correspond
 *    to the two VPE threads.  In other instances, such as the FDC request busses, they
 *    correspond to the ability to issue multiple requests in a single clock.  Typically,
 *    these counters are uninteresting singly, and software must sum their values to
 *    get an aggregate count.  For example, to see how many memory cache line read requests
 *    QRAST made to FDC for Z, you would need to compute FDC_QZRD0.XFER + FDC_QZRD1.XFER.
 *    These probe points will be marked by name as FDC_QZRD[01].  It should be understood
 *    that this corresponds to two probe points that are meant to be aclwmulated as one.
 *    Note that not all probe points that end with a number are necessarily meant to be
 *    used this way, only ones marked as such below.
 *
 * 6) The notes below are somewhat terse - for example, VPE_INSTISSUE.XFER is described
 *    as "instructions issued".  It should be inferred that this is a count of VPE
 *    instructions issued (since this is a VPE stat).  Also in general, the words
 *    "number of" have been removed from the descriptions.
 *
 * Probe point      Signal  Function
 * ===========      ======  ========
 * IDX_HRD:               : BUS host2idx (inbound host bus)
 * IDX_HWR:               : BUS idx2host (outbound host bus)
 * IDX_MEMRDREQ      .XFER: mem read line requests
 *                   .WAIT: clocks waiting to issue mem request
 * IDX_MEMRDRET      .XFER: mem read lines returned
 *                   .WAIT: clocks stalled on mem read return
 * IDX_DMAACC        .XFER: DMA cache accesses
 *                   .WAIT: DMA cache misses
 * IDX_IDXFETCH      .XFER: indices fetched
 *                   .WAIT: clocks stalled on index fetch
 * IDX_IDXLINES      .XFER: lines of memory fetched for indices
 *                   .WAIT: clocks stalled on mem return for indices
 * IDX_IDXCOUNTS     .XFER: 8-bit indices fetched
 *                   .WAIT: 16-bit indices fetched
 *                   .STEN: 32-bit indices fetched
 * IDX_VTXFETCH      .XFER: vertices fetched
 *                   .WAIT: clocks stalled on vertex fetch
 * IDX_VTXWORDS           : TOTAL number of DWORDs of vertex data fetched
 * IDX_VTXCACHE      .XFER: vertex cache accesses (or vertex count)
 *                   .WAIT: vertex cache misses (or transform count)
 * IDX_VTXSTALL      .XFER: clocks stalled because ibufs busy
 *                   .WAIT: clocks stalled because obufs busy
 * IDX_PRIMSTALL     .XFER: clocks stalled because prim fifo full
 *                   .WAIT: clocks stalled because transform not ready
 * IDX_PRIMS         .XFER: primitives (points + lines + tris)
 *                   .WAIT: DRAW_PRIM commands
 * IDX_POINTS        .XFER: points
 *                   .WAIT: point DRAW_PRIM commands
 * IDX_LINES         .XFER: lines
 *                   .WAIT: line DRAW_PRIM commands
 * IDX_TRIS          .XFER: triangles
 *                   .WAIT: triangle DRAW_PRIM commands
 * VPE_CLIPATADR     .XFER: attribute reads from clip
 *                   .WAIT: attribute loads from idx
 * VPE_INSTISSUE     .XFER: instructions issued
 *                   .WAIT: clocks running but stalled
 * VPE_STALL         .XFER: clocks of data stall
 *                   .WAIT: clocks of other stall
 * VPE_THREAD[01]    .XFER: threads run (n = thread_id)
 *                   .WAIT: clocks waiting to launch thread (n = thread_id)
 * CLIP                   : BUS idx2clip (clip primitive input)
 * CLIP_QRETIRE      .XFER: trangles retired from qrast
 *                   .WAIT: clocks waiting for tram
 * CLIP_VPE          .XFER: transforms finished
 * CLIP_ATRD         .XFER: attribute reads
 * CLIP_TRIVREJ      .XFER: trivially-rejected triangles
 *                   .WAIT: trivially-rejected lines
 *                   .STEN: trivially-rejected points
 * CLIP_DEGEN        .XFER: degenerate triangles
 *                   .WAIT: degenerate lines
 * CLIP_ZEROAREA     .XFER: zero-area triangles
 *                   .WAIT: zero-area lines
 *                   .STEN: zero-area points
 * CLIP_REJECT       .XFER: clipped-away triangles
 *                   .WAIT: clipped-away lines
 *                   .STEN: clipped-away points
 * CLIP_LWLL         .XFER: face-lwlled triangles
 *                   .WAIT: clip-generated face-lwlled triangles
 * CLIP_NEWTRI       .XFER: new triangles generated by clipping
 *                   .WAIT: triangles requiring clipping
 * CLIP_NEWLINE      .XFER: new lines generated by clipping
 *                   .WAIT: lines requiring clipping
 * CLIP_LR           .XFER: left edges clipped
 *                   .WAIT: right edges clipped
 * CLIP_TB           .XFER: top edges clipped
 *                   .WAIT: bottom edges clipped
 * CLIP_NF           .XFER: near edges clipped
 *                   .WAIT: far edges clipped
 * CLIP_UC           .XFER: user clip edges clipped (SC25/AP15 only)
 * SETUP_COV              : BUS clip2setup_cov
 * SETUP_Z                : BUS clip2setup_z
 * QRAST_SRDAT[01]        : BUS fdc2qrast_s[01]_rdat (stencil half-lines read)
 * QRAST_SB          .XFER: quad scoreboard clears
 *                   .WAIT: fully-covered quad scoreboard clears
 * QRAST_VRDAT[01]        : BUS fdc2qrast_v[01]_rdat (vcaa half-lines read)
 * QRAST_ZRDAT[01]        : BUS fdc2qrast_z[01]_rdat (depth half-lines read)
 * QRAST_PSEQ             : BUS pseq2qrast (pseq input from qrast)
 * QRAST                  : BUS setup2qrast (qrast input from setup)
 * QRAST_SBPIX       .XFER: scoreboarded quads
 *                   .WAIT: clocks stalled on scoreboard
 * QRAST_QZLWLL      .XFER: quads
 *                   .WAIT: quads fully depth lwlled
 * QRAST_QZKILL      .XFER: quads
 *                   .WAIT: quads guard-band lwlled
 * QRAST_QSLWLL      .XFER: quads
 *                   .WAIT: quads fully stencil lwlled
 * QRAST_QVLWLL      .XFER: quads
 *                   .WAIT: quads fully non-center-covered quads (vcaa update)
 * QRAST_COARSE      .XFER: corse quad lines processed
 *                   .WAIT: empty quad lines (coarse dead clocks)
 * QRAST_FINE        .XFER: coarse valid, fine not ready
 *                   .WAIT: coarse not valid, fine ready
 * QRAST_CACHE[01]   .XFER: count of qrast fetches for row 0 (n=col) (not partilwlarly useful)
 *                    WAIT: count of qrast fetches for row 1 (n=col) (not partilwlarly useful)
 *                    STEN: count of qrast fetches for row 2 (n=col) (not partilwlarly useful)
 * QRAST_PRIMS       .XFER: primitives
 *                   .WAIT: lwlled primitives
 * QRAST_FLUSH       .XFER: register/pixel boundaries
 *                   .WAIT: output fifo empty flushes (synthesized PSEQ_FLUSH)
 * PSEQ_DWR               : BUS dwr2pseq (recirlwlation) (untested)
 * PSEQ_RDAT              : BUS fdc2pseq_[01]_rdat (half-lines read) (untested)
 * PSEQ_RDATCMD      .XFER: non-pixel-related memory traffic (untested)
 * PSEQ                   : BUS qrast2pseq (pseq input)
 * PSEQ_QPKT         .XFER: register packets from qrast
 *                   .WAIT: live pixels from qrast
 *                   .STEN: non-center pixels from qrast
 * PSEQ_QZS          .XFER: Z_FAIL pixels from qrast
 *                   .WAIT: S_FAIL pixels from qrast
 *                   .STEN: killed pixels from qrast
 * PSEQ_PKT          .XFER: total register packets
 *                   .WAIT: total live pixels
 *                   .STEN: total killed pixels
 * PSEQ_ZS           .XFER: total Z_FAIL pixels
 *                   .WAIT: total S_FAIL pixels
 *                   .STEN: total killed pixels
 * PSEQ_NOP          .XFER: recirlwlated killed pixels
 *                   .WAIT: recirlwlated conditionally non-exelwted pixels
 *                   .STEN: early-killed recirlwlated quads
 * PSEQ_CMD0         .XFER: clocks exelwting pixel packets
 *                   .WAIT: clocks waiting on gather
 *                   .STEN: clocks doing immediate writes
 * PSEQ_CMD1         .XFER: gather mem requests
 *                   .WAIT: fill requests
 *                   .STEN: brances exelwted
 * PSEQ_LOAD         .XFER: LD instructions
 *                   .WAIT: R20 instructions
 *                   .STEN: R80 instructions
 * PSEQ_FETCH        .XFER: total pixels with LD instructions
 *                   .WAIT: killed pixels with LD instructions and READ_KILLED
 *                   .STEN: non-center pixels with LD instructions and READ_NON_CENTER
 * PSEQ_FETCHNOEX    .XFER: total pixels with LD instructions and NO_EXELWTE
 *                   .WAIT: killed pixels with LD instructions, READ_KILLED and NO_EXELWTE
 *                   .STEN: non-ceenter pixels with LD instructions, READ_NON_CENTER and NO_EXELWTE
 * PSEQ_CACHE        .XFER: instructions with CACHE_PERSISTENT
 *                   .WAIT: gathers with CACHE_PERSISTENT
 * PSEQ_RECIRC0      .XFER: high-water-mark events (MAX_OUT hit)
 *                   .WAIT: recirc stalls due to MIN_OUT
 *                   .STEN: flushes due to register write
 * PSEQ_RECIRC1      .XFER: clocks recirc path stalled
 *                   .WAIT: clocks recirc path stalled with no qrast input
 *                   .STEN: clocks recirc path stalled while PSEQ command drains
 * PSEQ_RECIRC2      .XFER: recirc caused by QUAD_ID aliasing
 *                   .WAIT: clocks stalled by QUAD_ID aliasing
 * PSEQ_EPOCH        .XFER: number of fills exelwted (number of epochs)
 *                   .WAIT: PC writes from QRAST (number of shader bindings)
 * PSEQ_REQWAIT      .XFER: clocks waiting for instruction mem req issue
 *                   .WAIT: clocks waiting for gather mem req issue
 *                   .STEN: clocks waiting for fill mem req issue
 * PSEQ_RETWAIT      .XFER: clocks waiting for instruction mem read return
 *                   .WAIT: clocks waiting for gather mem read return
 *                   .STEN: clocks waiting for fill mem read return
 * ATRAST_TRAM            : BUS clip2atrast_tram (untested)
 * ATRAST_TOP             : BUS pseq2atrast (atrast input) (untested)
 * ATRAST_BOT             : BUS atrast2tex (atrast output) (untested)
 * ATRAST_SLOPE           : BUS setup2atrast_slopes (untested)
 * TEX                    : unimplemented
 * TEX_MEMRDREQ      .XFER: mem read line requests
 *                   .WAIT: clocks waiting to issue mem request
 * TEX_MEMRDRET      .XFER: mem read lines returned
 *                   .WAIT: clocks stalled on mem read return
 * TEX_CACHEACC           : TOTAL lines of cache access
 * TEX_CACHEMISS          : TOTAL lines of cache miss
 * TEX_FETCH         .XFER: pixels with texture ops
 *                   .WAIT: pixels fetching textures
 *                   .STEN: killed pixels fetching textures
 * TEX_FETCHNOEX     .XFER: pixels with texture ops and NO_EXELWTE
 *                   .WAIT: pixels that would have fetched textures but for NO_EXELWTE
 *                   .STEN: killed pixes that would have fetched textures but for NO_EXELWTE
 * TEX_FILTER0       .XFER: pixels fetching textures
 *                   .WAIT: bilerps (or nearest) performed
 *                   .STEN: quads trilinear optimized
 * TEX_FILTER1       .XFER: magnified texture ops
 *                   .WAIT: pixels fetching texture with aniso
 *                   .STEN: aniso bilerps performed
 * TEX_LODHIST0      .XFER: level 0 bilerps
 *                   .WAIT: level 1 bilerps
 *                   .STEN: level 2 bilerps
 * TEX_LODHIST1      .XFER: level 3 bilerps
 *                   .WAIT: level 4 bilerps
 *                   .STEN: level 5 and greater bilerps
 * TEX_ANISOHIST0    .XFER: 1x aniso (not including aniso-disabled) bilerps
 *                   .WAIT: 2x aniso bilerps
 *                   .STEN: 3x aniso bilerps
 * TEX_ANISOHIST1    .XFER: 4x-5x aniso bilerps
 *                   .WAIT: 6x-9x aniso bilerps
 *                   .STEN: 10x and greater bilerps
 * TEX_ANISOFINE0    .XFER: fine 1x aniso (not including aniso-disabled) bilerps
 *                   .WAIT: fine 2x aniso bilerps
 *                   .STEN: fine 3x aniso bilerps
 * TEX_ANISOFINE1    .XFER: fine 4x-5x aniso bilerps
 *                   .WAIT: fine 6x-9x aniso bilerps
 *                   .STEN: fine 10x and greater bilerps
 * TEX_LATHIDE       .XFER: cycles stalled on pix packet latency-hiding fifo (light testing)
 *                   .WAIT: cycles stalled on mem latency-hiding fifo (light testing)
 * TEX_PERFDEG       .XFER: bubbles inserted during 128b to 256b mem return expansion (light testing)
 * ALU_BOT                : BUS alu2dwr (alu output)
 * ALU_TOP                : BUS tex2alu (alu input)
 * DWR                    : unimplemented
 * DWR_STORE         .XFER: ST instructions (not including ST_R20, ST_R80)
 *                   .WAIT: ST_R20 instructions
 *                   .STEN: ST_R80 instructions
 * DWR_WRITE         .XFER: pixels with ST instructions (not including ST_R20, ST_R80)
 *                   .WAIT: pixels with ST_R20 instructions
 *                   .STEN: pixels with ST_R80 instructions
 * DWR_WRITENOEX     .XFER: pixels with ST instructions and NO_EXELWTE
 *                   .WAIT: pixels with ST_R20 instructions and NO_EXELWTE
 *                   .STEN: pixels with ST_R80 instructions and NO_EXELWTE
 * DWR_SPILL         .XFER: pixel packets spilled
 *                   .WAIT: clocks waiting for spill request grant
 * DWR_FLUSH         .XFER: flushes issued to fdc
 *                   .WAIT: clocks waiting for flush
 * DWR_LATEOPS       .XFER: stencil ops performed (incl non-written packets)
 *                   .WAIT: logic ops performed (incl non-written packets)
 * DWR_CACHE         .XFER: ST instructions with CACHE_PERSISTENT
 *                   .WAIT: ST instructions with CACHE_READ_CLEAN
 * FDC_DWR[01]            : BUS dwr2fdc_[01]_wreq (dwr write requests to fdc)
 * FDC_IMEMRDREQ     .XFER: internal mem read line requests
 *                   .WAIT: internal mem read requests rejected
 *                   .STEN: internal mem read data lines returned
 * FDC_EMEMRDREQ     .XFER: external mem read line requests
 *                   .WAIT: external mem read requests rejected
 *                   .STEN: external mem read data lines returned
 * FDC_IMEMWRREQ     .XFER: internal mem write line requests
 *                   .WAIT: internal mem write requests rejected
 *                   .STEN: internal mem write lines confirmed
 * FDC_EMEMWRREQ     .XFER: external mem write line requests
 *                   .WAIT: external mem write requests rejected
 *                   .STEN: external mem write lines confirmed
 * FDC_PSEQ[01]           : BUS pseq2fdc_[01]_rreq (pseq read request to fdc)
 * FDC_SBPSEQ             : BUS pseq2fdc_sb (scoreboard packet from pseq)
 * FDC_QSRD[01]           : BUS qrast2fdc_s[01]_rreq (qrast stencil read req to fdc)
 * FDC_QSWR[01]           : BUS qrast2fdc_s[01]_wreq (qrast stencil write req to fdc)
 * FDC_SBQRAST            : BUS qrast2fdc_sb (scoreboard packet from qrast)
 * FDC_QVRD[01]           : BUS qrast2fdc_v[01]_rreq (qrast vcaa read req to fdc)
 * FDC_QVWR[01]           : BUS qrast2fdc_v[01]_wreq (qrast vcaa write req to fdc)
 * FDC_QZRD[01]           : BUS qrast2fdc_z[01]_rreq (qrast depth read req to fdc)
 * FDC_QZWR[01]           : BUS qrast2fdc_z[01]_wreq (qrast depth write req to fdc)
 * FDC_L2RD[0123]    .XFER: L2 lines read by non-mc clients from bank n (=0..3)
 *                   .WAIT: clocks with one client stalled on bank n (=0..3) read
 *                   .STEN: clocks with two or more clients stalled on bank n (=0..3) read
 * FDC_L2RD[4567]         : as above, but for banks (4..7) (only SC25/AP15)
 * FDC_L2WR[0123]    .XFER: L2 lines written by non-mc clients from bank n (=0..3)
 *                   .WAIT: clocks with one client stalled on bank n (=0..3) write
 *                   .STEN: clocks with two or more clients stalled on bank n (=0..3) write
 * FDC_L2WR[4567]         : as above, but for banks (4..7) (only SC25/AP15)
 * FDC_L2MC          .XFER: lines read by mc client from all banks
 *                   .WAIT: lines written by mc client to all banks
 *                   .STEN: read-clean lines evicted by mc (flushed to memory)
 * FDC_L2RDEVICT     .XFER: L2 lines evicted on read (MG20 only)
 *                   .WAIT: clocks waiting for read evict
 *                   .STEN: persistent lines evicted by read
 * FDC_L2RDEVICT[01]      : as above, but for two banks (SC25/AP15 only)
 * FDC_L2WREVICT     .XFER: L2 lines evicted on write (MG20 only)
 *                   .WAIT: clocks waiting for write evict
 *                   .STEN: persistent lines evicted by write
 * FDC_L2WREVICT[01]      : as above, but for two banks (SC25/AP15 only)
 * FDC_WRSNOOP       .WAIT: write snoop hits
 * FDC_SBSNOOP       .WAIT: scoreboard snoop hits
 *                   .STEN: qrast scoreboard snoop hits
 * FDC_RDTAGSTALL    .XFER: read clocks stalled on max count (MG20 only)
 * FDC_RDTAGSTALL[01].XFER: read clocks stalled on max count (SC25/AP15 only)
 * FDC_WRTAGSTALL    .XFER: write clocks stalled on max count (MG20 only)
 * FDC_WRTAGSTALL[01].XFER: write clocks stalled on max count (SC25/AP15 only)
 *
 */

// Register LWE297_CTL_STAT_0  
#define LWE297_CTL_STAT_0                           0xc
// enable this counter set
#define LWE297_CTL_STAT_0_EN                               0:0

// select probe point
#define LWE297_CTL_STAT_0_BLK                              8:1
#define LWE297_CTL_STAT_0_BLK_IDX_HRD                     0x00000000
#define LWE297_CTL_STAT_0_BLK_IDX_HWR                     0x00000001
#define LWE297_CTL_STAT_0_BLK_IDX_MEMRDREQ                        0x00000002
#define LWE297_CTL_STAT_0_BLK_IDX_MEMRDRET                        0x00000003
#define LWE297_CTL_STAT_0_BLK_IDX_DMAACC                  0x00000004
#define LWE297_CTL_STAT_0_BLK_IDX_IDXFETCH                        0x00000005
#define LWE297_CTL_STAT_0_BLK_IDX_IDXLINES                        0x00000006
#define LWE297_CTL_STAT_0_BLK_IDX_IDXCOUNTS                       0x00000007
#define LWE297_CTL_STAT_0_BLK_IDX_VTXFETCH                        0x00000008
#define LWE297_CTL_STAT_0_BLK_IDX_VTXWORDS                        0x00000009
#define LWE297_CTL_STAT_0_BLK_IDX_VTXCACHE                        0x0000000a
#define LWE297_CTL_STAT_0_BLK_IDX_VTXSTALL                        0x0000000b
#define LWE297_CTL_STAT_0_BLK_IDX_PRIMSTALL                       0x0000000c
#define LWE297_CTL_STAT_0_BLK_IDX_PRIMS                   0x0000000d
#define LWE297_CTL_STAT_0_BLK_IDX_POINTS                  0x0000000e
#define LWE297_CTL_STAT_0_BLK_IDX_LINES                   0x0000000f
#define LWE297_CTL_STAT_0_BLK_IDX_TRIS                    0x00000010
#define LWE297_CTL_STAT_0_BLK_VPE_CLIPATADR                       0x00000011
#define LWE297_CTL_STAT_0_BLK_VPE_INSTISSUE                       0x00000012
#define LWE297_CTL_STAT_0_BLK_VPE_STALL                   0x00000013
#define LWE297_CTL_STAT_0_BLK_VPE_THREAD0                 0x00000014
#define LWE297_CTL_STAT_0_BLK_VPE_THREAD1                 0x00000015
#define LWE297_CTL_STAT_0_BLK_CLIP                        0x00000016
#define LWE297_CTL_STAT_0_BLK_CLIP_QRETIRE                        0x00000017
#define LWE297_CTL_STAT_0_BLK_CLIP_VPE                    0x00000018
#define LWE297_CTL_STAT_0_BLK_CLIP_ATRD                   0x00000019
#define LWE297_CTL_STAT_0_BLK_CLIP_TRIVREJ                        0x0000001a
#define LWE297_CTL_STAT_0_BLK_CLIP_DEGEN                  0x0000001b
#define LWE297_CTL_STAT_0_BLK_CLIP_ZEROAREA                       0x0000001c
#define LWE297_CTL_STAT_0_BLK_CLIP_REJECT                 0x0000001d
#define LWE297_CTL_STAT_0_BLK_CLIP_LWLL                   0x0000001e
#define LWE297_CTL_STAT_0_BLK_CLIP_NEWTRI                 0x0000001f
#define LWE297_CTL_STAT_0_BLK_CLIP_NEWLINE                        0x00000020
#define LWE297_CTL_STAT_0_BLK_CLIP_LR                     0x00000021
#define LWE297_CTL_STAT_0_BLK_CLIP_TB                     0x00000022
#define LWE297_CTL_STAT_0_BLK_CLIP_NF                     0x00000023
#define LWE297_CTL_STAT_0_BLK_CLIP_UC                     0x00000024
#define LWE297_CTL_STAT_0_BLK_SETUP_COV                   0x00000025
#define LWE297_CTL_STAT_0_BLK_SETUP_Z                     0x00000026
#define LWE297_CTL_STAT_0_BLK_QRAST_SRDAT0                        0x00000027
#define LWE297_CTL_STAT_0_BLK_QRAST_SRDAT1                        0x00000028
#define LWE297_CTL_STAT_0_BLK_QRAST_SB                    0x00000029
#define LWE297_CTL_STAT_0_BLK_QRAST_VRDAT0                        0x0000002a
#define LWE297_CTL_STAT_0_BLK_QRAST_VRDAT1                        0x0000002b
#define LWE297_CTL_STAT_0_BLK_QRAST_ZRDAT0                        0x0000002c
#define LWE297_CTL_STAT_0_BLK_QRAST_ZRDAT1                        0x0000002d
#define LWE297_CTL_STAT_0_BLK_QRAST_PSEQ                  0x0000002e
#define LWE297_CTL_STAT_0_BLK_QRAST                       0x0000002f
#define LWE297_CTL_STAT_0_BLK_QRAST_SBPIX                 0x00000030
#define LWE297_CTL_STAT_0_BLK_QRAST_QZLWLL                        0x00000031
#define LWE297_CTL_STAT_0_BLK_QRAST_QZKILL                        0x00000032
#define LWE297_CTL_STAT_0_BLK_QRAST_QSLWLL                        0x00000033
#define LWE297_CTL_STAT_0_BLK_QRAST_QVLWLL                        0x00000034
#define LWE297_CTL_STAT_0_BLK_QRAST_COARSE                        0x00000035
#define LWE297_CTL_STAT_0_BLK_QRAST_FINE                  0x00000036
#define LWE297_CTL_STAT_0_BLK_QRAST_CACHE0                        0x00000037
#define LWE297_CTL_STAT_0_BLK_QRAST_CACHE1                        0x00000038
#define LWE297_CTL_STAT_0_BLK_QRAST_PRIMS                 0x00000039
#define LWE297_CTL_STAT_0_BLK_QRAST_FLUSH                 0x0000003a
#define LWE297_CTL_STAT_0_BLK_PSEQ_DWR                    0x0000003b
#define LWE297_CTL_STAT_0_BLK_PSEQ_RDAT                   0x0000003c
#define LWE297_CTL_STAT_0_BLK_PSEQ_RDATCMD                        0x0000003d
#define LWE297_CTL_STAT_0_BLK_PSEQ                        0x0000003e
#define LWE297_CTL_STAT_0_BLK_PSEQ_QPKT                   0x0000003f
#define LWE297_CTL_STAT_0_BLK_PSEQ_QZS                    0x00000040
#define LWE297_CTL_STAT_0_BLK_PSEQ_PKT                    0x00000041
#define LWE297_CTL_STAT_0_BLK_PSEQ_ZS                     0x00000042
#define LWE297_CTL_STAT_0_BLK_PSEQ_NOP                    0x00000043
#define LWE297_CTL_STAT_0_BLK_PSEQ_CMD0                   0x00000044
#define LWE297_CTL_STAT_0_BLK_PSEQ_CMD1                   0x00000045
#define LWE297_CTL_STAT_0_BLK_PSEQ_LOAD                   0x00000046
#define LWE297_CTL_STAT_0_BLK_PSEQ_FETCH                  0x00000047
#define LWE297_CTL_STAT_0_BLK_PSEQ_FETCHNOEX                      0x00000048
#define LWE297_CTL_STAT_0_BLK_PSEQ_CACHE                  0x00000049
#define LWE297_CTL_STAT_0_BLK_PSEQ_RECIRC0                        0x0000004a
#define LWE297_CTL_STAT_0_BLK_PSEQ_RECIRC1                        0x0000004b
#define LWE297_CTL_STAT_0_BLK_PSEQ_RECIRC2                        0x0000004c
#define LWE297_CTL_STAT_0_BLK_PSEQ_EPOCH                  0x0000004d
#define LWE297_CTL_STAT_0_BLK_PSEQ_REQWAIT                        0x0000004e
#define LWE297_CTL_STAT_0_BLK_PSEQ_RETWAIT                        0x0000004f
#define LWE297_CTL_STAT_0_BLK_ATRAST_TRAM                 0x00000050
#define LWE297_CTL_STAT_0_BLK_ATRAST_SLOPE                        0x00000051
#define LWE297_CTL_STAT_0_BLK_ATRAST_TOP                  0x00000052
#define LWE297_CTL_STAT_0_BLK_ATRAST_BOT                  0x00000053
#define LWE297_CTL_STAT_0_BLK_TEX                 0x00000054
#define LWE297_CTL_STAT_0_BLK_TEX_MEMRDREQ                        0x00000055
#define LWE297_CTL_STAT_0_BLK_TEX_MEMRDRET                        0x00000056
#define LWE297_CTL_STAT_0_BLK_TEX_CACHEACC                        0x00000057
#define LWE297_CTL_STAT_0_BLK_TEX_CACHEMISS                       0x00000058
#define LWE297_CTL_STAT_0_BLK_TEX_FETCH                   0x00000059
#define LWE297_CTL_STAT_0_BLK_TEX_FETCHNOEX                       0x0000005a
#define LWE297_CTL_STAT_0_BLK_TEX_FILTER0                 0x0000005b
#define LWE297_CTL_STAT_0_BLK_TEX_FILTER1                 0x0000005c
#define LWE297_CTL_STAT_0_BLK_TEX_LODHIST0                        0x0000005d
#define LWE297_CTL_STAT_0_BLK_TEX_LODHIST1                        0x0000005e
#define LWE297_CTL_STAT_0_BLK_TEX_ANISOHIST0                      0x0000005f
#define LWE297_CTL_STAT_0_BLK_TEX_ANISOHIST1                      0x00000060
#define LWE297_CTL_STAT_0_BLK_TEX_ANISOFINE0                      0x00000061
#define LWE297_CTL_STAT_0_BLK_TEX_ANISOFINE1                      0x00000062
#define LWE297_CTL_STAT_0_BLK_TEX_LATHIDE                 0x00000063
#define LWE297_CTL_STAT_0_BLK_TEX_PERFDEG                 0x00000064
#define LWE297_CTL_STAT_0_BLK_ALU_TOP                     0x00000065
#define LWE297_CTL_STAT_0_BLK_ALU_BOT                     0x00000066
#define LWE297_CTL_STAT_0_BLK_DWR                 0x00000067
#define LWE297_CTL_STAT_0_BLK_DWR_STORE                   0x00000068
#define LWE297_CTL_STAT_0_BLK_DWR_WRITE                   0x00000069
#define LWE297_CTL_STAT_0_BLK_DWR_WRITENOEX                       0x0000006a
#define LWE297_CTL_STAT_0_BLK_DWR_SPILL                   0x0000006b
#define LWE297_CTL_STAT_0_BLK_DWR_FLUSH                   0x0000006c
#define LWE297_CTL_STAT_0_BLK_DWR_LATEOPS                 0x0000006d
#define LWE297_CTL_STAT_0_BLK_DWR_CACHE                   0x0000006e
#define LWE297_CTL_STAT_0_BLK_FDC_DWR0                    0x0000006f
#define LWE297_CTL_STAT_0_BLK_FDC_DWR1                    0x00000070
#define LWE297_CTL_STAT_0_BLK_FDC_IMEMRDREQ                       0x00000071
#define LWE297_CTL_STAT_0_BLK_FDC_EMEMRDREQ                       0x00000072
#define LWE297_CTL_STAT_0_BLK_FDC_IMEMWRREQ                       0x00000073
#define LWE297_CTL_STAT_0_BLK_FDC_EMEMWRREQ                       0x00000074
#define LWE297_CTL_STAT_0_BLK_FDC_PSEQ0                   0x00000075
#define LWE297_CTL_STAT_0_BLK_FDC_PSEQ1                   0x00000076
#define LWE297_CTL_STAT_0_BLK_FDC_SBPSEQ                  0x00000077
#define LWE297_CTL_STAT_0_BLK_FDC_QSRD0                   0x00000078
#define LWE297_CTL_STAT_0_BLK_FDC_QSRD1                   0x00000079
#define LWE297_CTL_STAT_0_BLK_FDC_QSWR0                   0x0000007a
#define LWE297_CTL_STAT_0_BLK_FDC_QSWR1                   0x0000007b
#define LWE297_CTL_STAT_0_BLK_FDC_SBQRAST                 0x0000007c
#define LWE297_CTL_STAT_0_BLK_FDC_QVRD0                   0x0000007d
#define LWE297_CTL_STAT_0_BLK_FDC_QVRD1                   0x0000007e
#define LWE297_CTL_STAT_0_BLK_FDC_QVWR0                   0x0000007f
#define LWE297_CTL_STAT_0_BLK_FDC_QVWR1                   0x00000080
#define LWE297_CTL_STAT_0_BLK_FDC_QZRD0                   0x00000081
#define LWE297_CTL_STAT_0_BLK_FDC_QZRD1                   0x00000082
#define LWE297_CTL_STAT_0_BLK_FDC_QZWR0                   0x00000083
#define LWE297_CTL_STAT_0_BLK_FDC_QZWR1                   0x00000084
#define LWE297_CTL_STAT_0_BLK_FDC_L2RD0                   0x00000085
#define LWE297_CTL_STAT_0_BLK_FDC_L2RD1                   0x00000086
#define LWE297_CTL_STAT_0_BLK_FDC_L2RD2                   0x00000087
#define LWE297_CTL_STAT_0_BLK_FDC_L2RD3                   0x00000088
#define LWE297_CTL_STAT_0_BLK_FDC_L2RD4                   0x00000089
#define LWE297_CTL_STAT_0_BLK_FDC_L2RD5                   0x0000008a
#define LWE297_CTL_STAT_0_BLK_FDC_L2RD6                   0x0000008b
#define LWE297_CTL_STAT_0_BLK_FDC_L2RD7                   0x0000008c
#define LWE297_CTL_STAT_0_BLK_FDC_L2WR0                   0x0000008d
#define LWE297_CTL_STAT_0_BLK_FDC_L2WR1                   0x0000008e
#define LWE297_CTL_STAT_0_BLK_FDC_L2WR2                   0x0000008f
#define LWE297_CTL_STAT_0_BLK_FDC_L2WR3                   0x00000090
#define LWE297_CTL_STAT_0_BLK_FDC_L2WR4                   0x00000091
#define LWE297_CTL_STAT_0_BLK_FDC_L2WR5                   0x00000092
#define LWE297_CTL_STAT_0_BLK_FDC_L2WR6                   0x00000093
#define LWE297_CTL_STAT_0_BLK_FDC_L2WR7                   0x00000094
#define LWE297_CTL_STAT_0_BLK_FDC_L2MC                    0x00000095
#define LWE297_CTL_STAT_0_BLK_FDC_L2RDEVICT0                      0x00000096
#define LWE297_CTL_STAT_0_BLK_FDC_L2RDEVICT1                      0x00000097
#define LWE297_CTL_STAT_0_BLK_FDC_L2WREVICT0                      0x00000098
#define LWE297_CTL_STAT_0_BLK_FDC_L2WREVICT1                      0x00000099
#define LWE297_CTL_STAT_0_BLK_FDC_WRSNOOP                 0x0000009a
#define LWE297_CTL_STAT_0_BLK_FDC_SBSNOOP                 0x0000009b
#define LWE297_CTL_STAT_0_BLK_FDC_RDTAGSTALL0                     0x0000009c
#define LWE297_CTL_STAT_0_BLK_FDC_RDTAGSTALL1                     0x0000009d
#define LWE297_CTL_STAT_0_BLK_FDC_WRTAGSTALL0                     0x0000009e
#define LWE297_CTL_STAT_0_BLK_FDC_WRTAGSTALL1                     0x0000009f
#define LWE297_CTL_STAT_0_BLK_NUM_BLOCKS                  0x000000a0

// stat counter overflow
// Hardware sets this to one whenever one of
// counters overflows.  Cleared by software.
#define LWE297_CTL_STAT_0_OVF                              31:31


// Register LWE297_CTL_STAT  
#define LWE297_CTL_STAT                             0xc
// enable this counter set
#define LWE297_CTL_STAT_EN                         0:0

// select probe point
#define LWE297_CTL_STAT_BLK                        8:1
#define LWE297_CTL_STAT_BLK_IDX_HRD                       0x00000000
#define LWE297_CTL_STAT_BLK_IDX_HWR                       0x00000001
#define LWE297_CTL_STAT_BLK_IDX_MEMRDREQ                  0x00000002
#define LWE297_CTL_STAT_BLK_IDX_MEMRDRET                  0x00000003
#define LWE297_CTL_STAT_BLK_IDX_DMAACC                    0x00000004
#define LWE297_CTL_STAT_BLK_IDX_IDXFETCH                  0x00000005
#define LWE297_CTL_STAT_BLK_IDX_IDXLINES                  0x00000006
#define LWE297_CTL_STAT_BLK_IDX_IDXCOUNTS                 0x00000007
#define LWE297_CTL_STAT_BLK_IDX_VTXFETCH                  0x00000008
#define LWE297_CTL_STAT_BLK_IDX_VTXWORDS                  0x00000009
#define LWE297_CTL_STAT_BLK_IDX_VTXCACHE                  0x0000000a
#define LWE297_CTL_STAT_BLK_IDX_VTXSTALL                  0x0000000b
#define LWE297_CTL_STAT_BLK_IDX_PRIMSTALL                 0x0000000c
#define LWE297_CTL_STAT_BLK_IDX_PRIMS                     0x0000000d
#define LWE297_CTL_STAT_BLK_IDX_POINTS                    0x0000000e
#define LWE297_CTL_STAT_BLK_IDX_LINES                     0x0000000f
#define LWE297_CTL_STAT_BLK_IDX_TRIS                      0x00000010
#define LWE297_CTL_STAT_BLK_VPE_CLIPATADR                 0x00000011
#define LWE297_CTL_STAT_BLK_VPE_INSTISSUE                 0x00000012
#define LWE297_CTL_STAT_BLK_VPE_STALL                     0x00000013
#define LWE297_CTL_STAT_BLK_VPE_THREAD0                   0x00000014
#define LWE297_CTL_STAT_BLK_VPE_THREAD1                   0x00000015
#define LWE297_CTL_STAT_BLK_CLIP                  0x00000016
#define LWE297_CTL_STAT_BLK_CLIP_QRETIRE                  0x00000017
#define LWE297_CTL_STAT_BLK_CLIP_VPE                      0x00000018
#define LWE297_CTL_STAT_BLK_CLIP_ATRD                     0x00000019
#define LWE297_CTL_STAT_BLK_CLIP_TRIVREJ                  0x0000001a
#define LWE297_CTL_STAT_BLK_CLIP_DEGEN                    0x0000001b
#define LWE297_CTL_STAT_BLK_CLIP_ZEROAREA                 0x0000001c
#define LWE297_CTL_STAT_BLK_CLIP_REJECT                   0x0000001d
#define LWE297_CTL_STAT_BLK_CLIP_LWLL                     0x0000001e
#define LWE297_CTL_STAT_BLK_CLIP_NEWTRI                   0x0000001f
#define LWE297_CTL_STAT_BLK_CLIP_NEWLINE                  0x00000020
#define LWE297_CTL_STAT_BLK_CLIP_LR                       0x00000021
#define LWE297_CTL_STAT_BLK_CLIP_TB                       0x00000022
#define LWE297_CTL_STAT_BLK_CLIP_NF                       0x00000023
#define LWE297_CTL_STAT_BLK_CLIP_UC                       0x00000024
#define LWE297_CTL_STAT_BLK_SETUP_COV                     0x00000025
#define LWE297_CTL_STAT_BLK_SETUP_Z                       0x00000026
#define LWE297_CTL_STAT_BLK_QRAST_SRDAT0                  0x00000027
#define LWE297_CTL_STAT_BLK_QRAST_SRDAT1                  0x00000028
#define LWE297_CTL_STAT_BLK_QRAST_SB                      0x00000029
#define LWE297_CTL_STAT_BLK_QRAST_VRDAT0                  0x0000002a
#define LWE297_CTL_STAT_BLK_QRAST_VRDAT1                  0x0000002b
#define LWE297_CTL_STAT_BLK_QRAST_ZRDAT0                  0x0000002c
#define LWE297_CTL_STAT_BLK_QRAST_ZRDAT1                  0x0000002d
#define LWE297_CTL_STAT_BLK_QRAST_PSEQ                    0x0000002e
#define LWE297_CTL_STAT_BLK_QRAST                 0x0000002f
#define LWE297_CTL_STAT_BLK_QRAST_SBPIX                   0x00000030
#define LWE297_CTL_STAT_BLK_QRAST_QZLWLL                  0x00000031
#define LWE297_CTL_STAT_BLK_QRAST_QZKILL                  0x00000032
#define LWE297_CTL_STAT_BLK_QRAST_QSLWLL                  0x00000033
#define LWE297_CTL_STAT_BLK_QRAST_QVLWLL                  0x00000034
#define LWE297_CTL_STAT_BLK_QRAST_COARSE                  0x00000035
#define LWE297_CTL_STAT_BLK_QRAST_FINE                    0x00000036
#define LWE297_CTL_STAT_BLK_QRAST_CACHE0                  0x00000037
#define LWE297_CTL_STAT_BLK_QRAST_CACHE1                  0x00000038
#define LWE297_CTL_STAT_BLK_QRAST_PRIMS                   0x00000039
#define LWE297_CTL_STAT_BLK_QRAST_FLUSH                   0x0000003a
#define LWE297_CTL_STAT_BLK_PSEQ_DWR                      0x0000003b
#define LWE297_CTL_STAT_BLK_PSEQ_RDAT                     0x0000003c
#define LWE297_CTL_STAT_BLK_PSEQ_RDATCMD                  0x0000003d
#define LWE297_CTL_STAT_BLK_PSEQ                  0x0000003e
#define LWE297_CTL_STAT_BLK_PSEQ_QPKT                     0x0000003f
#define LWE297_CTL_STAT_BLK_PSEQ_QZS                      0x00000040
#define LWE297_CTL_STAT_BLK_PSEQ_PKT                      0x00000041
#define LWE297_CTL_STAT_BLK_PSEQ_ZS                       0x00000042
#define LWE297_CTL_STAT_BLK_PSEQ_NOP                      0x00000043
#define LWE297_CTL_STAT_BLK_PSEQ_CMD0                     0x00000044
#define LWE297_CTL_STAT_BLK_PSEQ_CMD1                     0x00000045
#define LWE297_CTL_STAT_BLK_PSEQ_LOAD                     0x00000046
#define LWE297_CTL_STAT_BLK_PSEQ_FETCH                    0x00000047
#define LWE297_CTL_STAT_BLK_PSEQ_FETCHNOEX                        0x00000048
#define LWE297_CTL_STAT_BLK_PSEQ_CACHE                    0x00000049
#define LWE297_CTL_STAT_BLK_PSEQ_RECIRC0                  0x0000004a
#define LWE297_CTL_STAT_BLK_PSEQ_RECIRC1                  0x0000004b
#define LWE297_CTL_STAT_BLK_PSEQ_RECIRC2                  0x0000004c
#define LWE297_CTL_STAT_BLK_PSEQ_EPOCH                    0x0000004d
#define LWE297_CTL_STAT_BLK_PSEQ_REQWAIT                  0x0000004e
#define LWE297_CTL_STAT_BLK_PSEQ_RETWAIT                  0x0000004f
#define LWE297_CTL_STAT_BLK_ATRAST_TRAM                   0x00000050
#define LWE297_CTL_STAT_BLK_ATRAST_SLOPE                  0x00000051
#define LWE297_CTL_STAT_BLK_ATRAST_TOP                    0x00000052
#define LWE297_CTL_STAT_BLK_ATRAST_BOT                    0x00000053
#define LWE297_CTL_STAT_BLK_TEX                   0x00000054
#define LWE297_CTL_STAT_BLK_TEX_MEMRDREQ                  0x00000055
#define LWE297_CTL_STAT_BLK_TEX_MEMRDRET                  0x00000056
#define LWE297_CTL_STAT_BLK_TEX_CACHEACC                  0x00000057
#define LWE297_CTL_STAT_BLK_TEX_CACHEMISS                 0x00000058
#define LWE297_CTL_STAT_BLK_TEX_FETCH                     0x00000059
#define LWE297_CTL_STAT_BLK_TEX_FETCHNOEX                 0x0000005a
#define LWE297_CTL_STAT_BLK_TEX_FILTER0                   0x0000005b
#define LWE297_CTL_STAT_BLK_TEX_FILTER1                   0x0000005c
#define LWE297_CTL_STAT_BLK_TEX_LODHIST0                  0x0000005d
#define LWE297_CTL_STAT_BLK_TEX_LODHIST1                  0x0000005e
#define LWE297_CTL_STAT_BLK_TEX_ANISOHIST0                        0x0000005f
#define LWE297_CTL_STAT_BLK_TEX_ANISOHIST1                        0x00000060
#define LWE297_CTL_STAT_BLK_TEX_ANISOFINE0                        0x00000061
#define LWE297_CTL_STAT_BLK_TEX_ANISOFINE1                        0x00000062
#define LWE297_CTL_STAT_BLK_TEX_LATHIDE                   0x00000063
#define LWE297_CTL_STAT_BLK_TEX_PERFDEG                   0x00000064
#define LWE297_CTL_STAT_BLK_ALU_TOP                       0x00000065
#define LWE297_CTL_STAT_BLK_ALU_BOT                       0x00000066
#define LWE297_CTL_STAT_BLK_DWR                   0x00000067
#define LWE297_CTL_STAT_BLK_DWR_STORE                     0x00000068
#define LWE297_CTL_STAT_BLK_DWR_WRITE                     0x00000069
#define LWE297_CTL_STAT_BLK_DWR_WRITENOEX                 0x0000006a
#define LWE297_CTL_STAT_BLK_DWR_SPILL                     0x0000006b
#define LWE297_CTL_STAT_BLK_DWR_FLUSH                     0x0000006c
#define LWE297_CTL_STAT_BLK_DWR_LATEOPS                   0x0000006d
#define LWE297_CTL_STAT_BLK_DWR_CACHE                     0x0000006e
#define LWE297_CTL_STAT_BLK_FDC_DWR0                      0x0000006f
#define LWE297_CTL_STAT_BLK_FDC_DWR1                      0x00000070
#define LWE297_CTL_STAT_BLK_FDC_IMEMRDREQ                 0x00000071
#define LWE297_CTL_STAT_BLK_FDC_EMEMRDREQ                 0x00000072
#define LWE297_CTL_STAT_BLK_FDC_IMEMWRREQ                 0x00000073
#define LWE297_CTL_STAT_BLK_FDC_EMEMWRREQ                 0x00000074
#define LWE297_CTL_STAT_BLK_FDC_PSEQ0                     0x00000075
#define LWE297_CTL_STAT_BLK_FDC_PSEQ1                     0x00000076
#define LWE297_CTL_STAT_BLK_FDC_SBPSEQ                    0x00000077
#define LWE297_CTL_STAT_BLK_FDC_QSRD0                     0x00000078
#define LWE297_CTL_STAT_BLK_FDC_QSRD1                     0x00000079
#define LWE297_CTL_STAT_BLK_FDC_QSWR0                     0x0000007a
#define LWE297_CTL_STAT_BLK_FDC_QSWR1                     0x0000007b
#define LWE297_CTL_STAT_BLK_FDC_SBQRAST                   0x0000007c
#define LWE297_CTL_STAT_BLK_FDC_QVRD0                     0x0000007d
#define LWE297_CTL_STAT_BLK_FDC_QVRD1                     0x0000007e
#define LWE297_CTL_STAT_BLK_FDC_QVWR0                     0x0000007f
#define LWE297_CTL_STAT_BLK_FDC_QVWR1                     0x00000080
#define LWE297_CTL_STAT_BLK_FDC_QZRD0                     0x00000081
#define LWE297_CTL_STAT_BLK_FDC_QZRD1                     0x00000082
#define LWE297_CTL_STAT_BLK_FDC_QZWR0                     0x00000083
#define LWE297_CTL_STAT_BLK_FDC_QZWR1                     0x00000084
#define LWE297_CTL_STAT_BLK_FDC_L2RD0                     0x00000085
#define LWE297_CTL_STAT_BLK_FDC_L2RD1                     0x00000086
#define LWE297_CTL_STAT_BLK_FDC_L2RD2                     0x00000087
#define LWE297_CTL_STAT_BLK_FDC_L2RD3                     0x00000088
#define LWE297_CTL_STAT_BLK_FDC_L2RD4                     0x00000089
#define LWE297_CTL_STAT_BLK_FDC_L2RD5                     0x0000008a
#define LWE297_CTL_STAT_BLK_FDC_L2RD6                     0x0000008b
#define LWE297_CTL_STAT_BLK_FDC_L2RD7                     0x0000008c
#define LWE297_CTL_STAT_BLK_FDC_L2WR0                     0x0000008d
#define LWE297_CTL_STAT_BLK_FDC_L2WR1                     0x0000008e
#define LWE297_CTL_STAT_BLK_FDC_L2WR2                     0x0000008f
#define LWE297_CTL_STAT_BLK_FDC_L2WR3                     0x00000090
#define LWE297_CTL_STAT_BLK_FDC_L2WR4                     0x00000091
#define LWE297_CTL_STAT_BLK_FDC_L2WR5                     0x00000092
#define LWE297_CTL_STAT_BLK_FDC_L2WR6                     0x00000093
#define LWE297_CTL_STAT_BLK_FDC_L2WR7                     0x00000094
#define LWE297_CTL_STAT_BLK_FDC_L2MC                      0x00000095
#define LWE297_CTL_STAT_BLK_FDC_L2RDEVICT0                        0x00000096
#define LWE297_CTL_STAT_BLK_FDC_L2RDEVICT1                        0x00000097
#define LWE297_CTL_STAT_BLK_FDC_L2WREVICT0                        0x00000098
#define LWE297_CTL_STAT_BLK_FDC_L2WREVICT1                        0x00000099
#define LWE297_CTL_STAT_BLK_FDC_WRSNOOP                   0x0000009a
#define LWE297_CTL_STAT_BLK_FDC_SBSNOOP                   0x0000009b
#define LWE297_CTL_STAT_BLK_FDC_RDTAGSTALL0                       0x0000009c
#define LWE297_CTL_STAT_BLK_FDC_RDTAGSTALL1                       0x0000009d
#define LWE297_CTL_STAT_BLK_FDC_WRTAGSTALL0                       0x0000009e
#define LWE297_CTL_STAT_BLK_FDC_WRTAGSTALL1                       0x0000009f
#define LWE297_CTL_STAT_BLK_NUM_BLOCKS                    0x000000a0

// stat counter overflow
// Hardware sets this to one whenever one of
// counters overflows.  Cleared by software.
#define LWE297_CTL_STAT_OVF                        31:31


// Register LWE297_CTL_STAT_1  
#define LWE297_CTL_STAT_1                           0xd
// enable this counter set
#define LWE297_CTL_STAT_1_EN                               0:0

// select probe point
#define LWE297_CTL_STAT_1_BLK                              8:1
#define LWE297_CTL_STAT_1_BLK_IDX_HRD                     0x00000000
#define LWE297_CTL_STAT_1_BLK_IDX_HWR                     0x00000001
#define LWE297_CTL_STAT_1_BLK_IDX_MEMRDREQ                        0x00000002
#define LWE297_CTL_STAT_1_BLK_IDX_MEMRDRET                        0x00000003
#define LWE297_CTL_STAT_1_BLK_IDX_DMAACC                  0x00000004
#define LWE297_CTL_STAT_1_BLK_IDX_IDXFETCH                        0x00000005
#define LWE297_CTL_STAT_1_BLK_IDX_IDXLINES                        0x00000006
#define LWE297_CTL_STAT_1_BLK_IDX_IDXCOUNTS                       0x00000007
#define LWE297_CTL_STAT_1_BLK_IDX_VTXFETCH                        0x00000008
#define LWE297_CTL_STAT_1_BLK_IDX_VTXWORDS                        0x00000009
#define LWE297_CTL_STAT_1_BLK_IDX_VTXCACHE                        0x0000000a
#define LWE297_CTL_STAT_1_BLK_IDX_VTXSTALL                        0x0000000b
#define LWE297_CTL_STAT_1_BLK_IDX_PRIMSTALL                       0x0000000c
#define LWE297_CTL_STAT_1_BLK_IDX_PRIMS                   0x0000000d
#define LWE297_CTL_STAT_1_BLK_IDX_POINTS                  0x0000000e
#define LWE297_CTL_STAT_1_BLK_IDX_LINES                   0x0000000f
#define LWE297_CTL_STAT_1_BLK_IDX_TRIS                    0x00000010
#define LWE297_CTL_STAT_1_BLK_VPE_CLIPATADR                       0x00000011
#define LWE297_CTL_STAT_1_BLK_VPE_INSTISSUE                       0x00000012
#define LWE297_CTL_STAT_1_BLK_VPE_STALL                   0x00000013
#define LWE297_CTL_STAT_1_BLK_VPE_THREAD0                 0x00000014
#define LWE297_CTL_STAT_1_BLK_VPE_THREAD1                 0x00000015
#define LWE297_CTL_STAT_1_BLK_CLIP                        0x00000016
#define LWE297_CTL_STAT_1_BLK_CLIP_QRETIRE                        0x00000017
#define LWE297_CTL_STAT_1_BLK_CLIP_VPE                    0x00000018
#define LWE297_CTL_STAT_1_BLK_CLIP_ATRD                   0x00000019
#define LWE297_CTL_STAT_1_BLK_CLIP_TRIVREJ                        0x0000001a
#define LWE297_CTL_STAT_1_BLK_CLIP_DEGEN                  0x0000001b
#define LWE297_CTL_STAT_1_BLK_CLIP_ZEROAREA                       0x0000001c
#define LWE297_CTL_STAT_1_BLK_CLIP_REJECT                 0x0000001d
#define LWE297_CTL_STAT_1_BLK_CLIP_LWLL                   0x0000001e
#define LWE297_CTL_STAT_1_BLK_CLIP_NEWTRI                 0x0000001f
#define LWE297_CTL_STAT_1_BLK_CLIP_NEWLINE                        0x00000020
#define LWE297_CTL_STAT_1_BLK_CLIP_LR                     0x00000021
#define LWE297_CTL_STAT_1_BLK_CLIP_TB                     0x00000022
#define LWE297_CTL_STAT_1_BLK_CLIP_NF                     0x00000023
#define LWE297_CTL_STAT_1_BLK_CLIP_UC                     0x00000024
#define LWE297_CTL_STAT_1_BLK_SETUP_COV                   0x00000025
#define LWE297_CTL_STAT_1_BLK_SETUP_Z                     0x00000026
#define LWE297_CTL_STAT_1_BLK_QRAST_SRDAT0                        0x00000027
#define LWE297_CTL_STAT_1_BLK_QRAST_SRDAT1                        0x00000028
#define LWE297_CTL_STAT_1_BLK_QRAST_SB                    0x00000029
#define LWE297_CTL_STAT_1_BLK_QRAST_VRDAT0                        0x0000002a
#define LWE297_CTL_STAT_1_BLK_QRAST_VRDAT1                        0x0000002b
#define LWE297_CTL_STAT_1_BLK_QRAST_ZRDAT0                        0x0000002c
#define LWE297_CTL_STAT_1_BLK_QRAST_ZRDAT1                        0x0000002d
#define LWE297_CTL_STAT_1_BLK_QRAST_PSEQ                  0x0000002e
#define LWE297_CTL_STAT_1_BLK_QRAST                       0x0000002f
#define LWE297_CTL_STAT_1_BLK_QRAST_SBPIX                 0x00000030
#define LWE297_CTL_STAT_1_BLK_QRAST_QZLWLL                        0x00000031
#define LWE297_CTL_STAT_1_BLK_QRAST_QZKILL                        0x00000032
#define LWE297_CTL_STAT_1_BLK_QRAST_QSLWLL                        0x00000033
#define LWE297_CTL_STAT_1_BLK_QRAST_QVLWLL                        0x00000034
#define LWE297_CTL_STAT_1_BLK_QRAST_COARSE                        0x00000035
#define LWE297_CTL_STAT_1_BLK_QRAST_FINE                  0x00000036
#define LWE297_CTL_STAT_1_BLK_QRAST_CACHE0                        0x00000037
#define LWE297_CTL_STAT_1_BLK_QRAST_CACHE1                        0x00000038
#define LWE297_CTL_STAT_1_BLK_QRAST_PRIMS                 0x00000039
#define LWE297_CTL_STAT_1_BLK_QRAST_FLUSH                 0x0000003a
#define LWE297_CTL_STAT_1_BLK_PSEQ_DWR                    0x0000003b
#define LWE297_CTL_STAT_1_BLK_PSEQ_RDAT                   0x0000003c
#define LWE297_CTL_STAT_1_BLK_PSEQ_RDATCMD                        0x0000003d
#define LWE297_CTL_STAT_1_BLK_PSEQ                        0x0000003e
#define LWE297_CTL_STAT_1_BLK_PSEQ_QPKT                   0x0000003f
#define LWE297_CTL_STAT_1_BLK_PSEQ_QZS                    0x00000040
#define LWE297_CTL_STAT_1_BLK_PSEQ_PKT                    0x00000041
#define LWE297_CTL_STAT_1_BLK_PSEQ_ZS                     0x00000042
#define LWE297_CTL_STAT_1_BLK_PSEQ_NOP                    0x00000043
#define LWE297_CTL_STAT_1_BLK_PSEQ_CMD0                   0x00000044
#define LWE297_CTL_STAT_1_BLK_PSEQ_CMD1                   0x00000045
#define LWE297_CTL_STAT_1_BLK_PSEQ_LOAD                   0x00000046
#define LWE297_CTL_STAT_1_BLK_PSEQ_FETCH                  0x00000047
#define LWE297_CTL_STAT_1_BLK_PSEQ_FETCHNOEX                      0x00000048
#define LWE297_CTL_STAT_1_BLK_PSEQ_CACHE                  0x00000049
#define LWE297_CTL_STAT_1_BLK_PSEQ_RECIRC0                        0x0000004a
#define LWE297_CTL_STAT_1_BLK_PSEQ_RECIRC1                        0x0000004b
#define LWE297_CTL_STAT_1_BLK_PSEQ_RECIRC2                        0x0000004c
#define LWE297_CTL_STAT_1_BLK_PSEQ_EPOCH                  0x0000004d
#define LWE297_CTL_STAT_1_BLK_PSEQ_REQWAIT                        0x0000004e
#define LWE297_CTL_STAT_1_BLK_PSEQ_RETWAIT                        0x0000004f
#define LWE297_CTL_STAT_1_BLK_ATRAST_TRAM                 0x00000050
#define LWE297_CTL_STAT_1_BLK_ATRAST_SLOPE                        0x00000051
#define LWE297_CTL_STAT_1_BLK_ATRAST_TOP                  0x00000052
#define LWE297_CTL_STAT_1_BLK_ATRAST_BOT                  0x00000053
#define LWE297_CTL_STAT_1_BLK_TEX                 0x00000054
#define LWE297_CTL_STAT_1_BLK_TEX_MEMRDREQ                        0x00000055
#define LWE297_CTL_STAT_1_BLK_TEX_MEMRDRET                        0x00000056
#define LWE297_CTL_STAT_1_BLK_TEX_CACHEACC                        0x00000057
#define LWE297_CTL_STAT_1_BLK_TEX_CACHEMISS                       0x00000058
#define LWE297_CTL_STAT_1_BLK_TEX_FETCH                   0x00000059
#define LWE297_CTL_STAT_1_BLK_TEX_FETCHNOEX                       0x0000005a
#define LWE297_CTL_STAT_1_BLK_TEX_FILTER0                 0x0000005b
#define LWE297_CTL_STAT_1_BLK_TEX_FILTER1                 0x0000005c
#define LWE297_CTL_STAT_1_BLK_TEX_LODHIST0                        0x0000005d
#define LWE297_CTL_STAT_1_BLK_TEX_LODHIST1                        0x0000005e
#define LWE297_CTL_STAT_1_BLK_TEX_ANISOHIST0                      0x0000005f
#define LWE297_CTL_STAT_1_BLK_TEX_ANISOHIST1                      0x00000060
#define LWE297_CTL_STAT_1_BLK_TEX_ANISOFINE0                      0x00000061
#define LWE297_CTL_STAT_1_BLK_TEX_ANISOFINE1                      0x00000062
#define LWE297_CTL_STAT_1_BLK_TEX_LATHIDE                 0x00000063
#define LWE297_CTL_STAT_1_BLK_TEX_PERFDEG                 0x00000064
#define LWE297_CTL_STAT_1_BLK_ALU_TOP                     0x00000065
#define LWE297_CTL_STAT_1_BLK_ALU_BOT                     0x00000066
#define LWE297_CTL_STAT_1_BLK_DWR                 0x00000067
#define LWE297_CTL_STAT_1_BLK_DWR_STORE                   0x00000068
#define LWE297_CTL_STAT_1_BLK_DWR_WRITE                   0x00000069
#define LWE297_CTL_STAT_1_BLK_DWR_WRITENOEX                       0x0000006a
#define LWE297_CTL_STAT_1_BLK_DWR_SPILL                   0x0000006b
#define LWE297_CTL_STAT_1_BLK_DWR_FLUSH                   0x0000006c
#define LWE297_CTL_STAT_1_BLK_DWR_LATEOPS                 0x0000006d
#define LWE297_CTL_STAT_1_BLK_DWR_CACHE                   0x0000006e
#define LWE297_CTL_STAT_1_BLK_FDC_DWR0                    0x0000006f
#define LWE297_CTL_STAT_1_BLK_FDC_DWR1                    0x00000070
#define LWE297_CTL_STAT_1_BLK_FDC_IMEMRDREQ                       0x00000071
#define LWE297_CTL_STAT_1_BLK_FDC_EMEMRDREQ                       0x00000072
#define LWE297_CTL_STAT_1_BLK_FDC_IMEMWRREQ                       0x00000073
#define LWE297_CTL_STAT_1_BLK_FDC_EMEMWRREQ                       0x00000074
#define LWE297_CTL_STAT_1_BLK_FDC_PSEQ0                   0x00000075
#define LWE297_CTL_STAT_1_BLK_FDC_PSEQ1                   0x00000076
#define LWE297_CTL_STAT_1_BLK_FDC_SBPSEQ                  0x00000077
#define LWE297_CTL_STAT_1_BLK_FDC_QSRD0                   0x00000078
#define LWE297_CTL_STAT_1_BLK_FDC_QSRD1                   0x00000079
#define LWE297_CTL_STAT_1_BLK_FDC_QSWR0                   0x0000007a
#define LWE297_CTL_STAT_1_BLK_FDC_QSWR1                   0x0000007b
#define LWE297_CTL_STAT_1_BLK_FDC_SBQRAST                 0x0000007c
#define LWE297_CTL_STAT_1_BLK_FDC_QVRD0                   0x0000007d
#define LWE297_CTL_STAT_1_BLK_FDC_QVRD1                   0x0000007e
#define LWE297_CTL_STAT_1_BLK_FDC_QVWR0                   0x0000007f
#define LWE297_CTL_STAT_1_BLK_FDC_QVWR1                   0x00000080
#define LWE297_CTL_STAT_1_BLK_FDC_QZRD0                   0x00000081
#define LWE297_CTL_STAT_1_BLK_FDC_QZRD1                   0x00000082
#define LWE297_CTL_STAT_1_BLK_FDC_QZWR0                   0x00000083
#define LWE297_CTL_STAT_1_BLK_FDC_QZWR1                   0x00000084
#define LWE297_CTL_STAT_1_BLK_FDC_L2RD0                   0x00000085
#define LWE297_CTL_STAT_1_BLK_FDC_L2RD1                   0x00000086
#define LWE297_CTL_STAT_1_BLK_FDC_L2RD2                   0x00000087
#define LWE297_CTL_STAT_1_BLK_FDC_L2RD3                   0x00000088
#define LWE297_CTL_STAT_1_BLK_FDC_L2RD4                   0x00000089
#define LWE297_CTL_STAT_1_BLK_FDC_L2RD5                   0x0000008a
#define LWE297_CTL_STAT_1_BLK_FDC_L2RD6                   0x0000008b
#define LWE297_CTL_STAT_1_BLK_FDC_L2RD7                   0x0000008c
#define LWE297_CTL_STAT_1_BLK_FDC_L2WR0                   0x0000008d
#define LWE297_CTL_STAT_1_BLK_FDC_L2WR1                   0x0000008e
#define LWE297_CTL_STAT_1_BLK_FDC_L2WR2                   0x0000008f
#define LWE297_CTL_STAT_1_BLK_FDC_L2WR3                   0x00000090
#define LWE297_CTL_STAT_1_BLK_FDC_L2WR4                   0x00000091
#define LWE297_CTL_STAT_1_BLK_FDC_L2WR5                   0x00000092
#define LWE297_CTL_STAT_1_BLK_FDC_L2WR6                   0x00000093
#define LWE297_CTL_STAT_1_BLK_FDC_L2WR7                   0x00000094
#define LWE297_CTL_STAT_1_BLK_FDC_L2MC                    0x00000095
#define LWE297_CTL_STAT_1_BLK_FDC_L2RDEVICT0                      0x00000096
#define LWE297_CTL_STAT_1_BLK_FDC_L2RDEVICT1                      0x00000097
#define LWE297_CTL_STAT_1_BLK_FDC_L2WREVICT0                      0x00000098
#define LWE297_CTL_STAT_1_BLK_FDC_L2WREVICT1                      0x00000099
#define LWE297_CTL_STAT_1_BLK_FDC_WRSNOOP                 0x0000009a
#define LWE297_CTL_STAT_1_BLK_FDC_SBSNOOP                 0x0000009b
#define LWE297_CTL_STAT_1_BLK_FDC_RDTAGSTALL0                     0x0000009c
#define LWE297_CTL_STAT_1_BLK_FDC_RDTAGSTALL1                     0x0000009d
#define LWE297_CTL_STAT_1_BLK_FDC_WRTAGSTALL0                     0x0000009e
#define LWE297_CTL_STAT_1_BLK_FDC_WRTAGSTALL1                     0x0000009f
#define LWE297_CTL_STAT_1_BLK_NUM_BLOCKS                  0x000000a0

// stat counter overflow
// Hardware sets this to one whenever one of
// counters overflows.  Cleared by software.
#define LWE297_CTL_STAT_1_OVF                              31:31


// Register LWE297_CTL_STAT_CLK_COUNT_0  
#define LWE297_CTL_STAT_CLK_COUNT_0                                 0xe
// typically clocks which INSTRUMENT.STAT_EN at STAT.BLK were true
#define LWE297_CTL_STAT_CLK_COUNT_0_VAL                            31:0


// Register LWE297_CTL_STAT_CLK_COUNT  
#define LWE297_CTL_STAT_CLK_COUNT                           0xe
// typically clocks which INSTRUMENT.STAT_EN at STAT.BLK were true
#define LWE297_CTL_STAT_CLK_COUNT_VAL                              31:0


// Register LWE297_CTL_STAT_CLK_COUNT_1  
#define LWE297_CTL_STAT_CLK_COUNT_1                                 0xf
// typically clocks which INSTRUMENT.STAT_EN at STAT.BLK were true
#define LWE297_CTL_STAT_CLK_COUNT_1_VAL                            31:0


// Register LWE297_CTL_STAT_XFER_COUNT_0  
#define LWE297_CTL_STAT_XFER_COUNT_0                                0x10
// typically count of valid & !stall for pipeline buses
#define LWE297_CTL_STAT_XFER_COUNT_0_VAL                           31:0


// Register LWE297_CTL_STAT_XFER_COUNT  
#define LWE297_CTL_STAT_XFER_COUNT                                  0x10
// typically count of valid & !stall for pipeline buses
#define LWE297_CTL_STAT_XFER_COUNT_VAL                             31:0


// Register LWE297_CTL_STAT_XFER_COUNT_1  
#define LWE297_CTL_STAT_XFER_COUNT_1                                0x11
// typically count of valid & !stall for pipeline buses
#define LWE297_CTL_STAT_XFER_COUNT_1_VAL                           31:0


// Register LWE297_CTL_STAT_WAIT_COUNT_0  
#define LWE297_CTL_STAT_WAIT_COUNT_0                                0x12
// typically count of valid & stall for pipeline buses
#define LWE297_CTL_STAT_WAIT_COUNT_0_VAL                           31:0


// Register LWE297_CTL_STAT_WAIT_COUNT  
#define LWE297_CTL_STAT_WAIT_COUNT                                  0x12
// typically count of valid & stall for pipeline buses
#define LWE297_CTL_STAT_WAIT_COUNT_VAL                             31:0


// Register LWE297_CTL_STAT_WAIT_COUNT_1  
#define LWE297_CTL_STAT_WAIT_COUNT_1                                0x13
// typically count of valid & stall for pipeline buses
#define LWE297_CTL_STAT_WAIT_COUNT_1_VAL                           31:0


// Register LWE297_CTL_STAT_EN_COUNT_0  
#define LWE297_CTL_STAT_EN_COUNT_0                                  0x14
// typically number of times INSTRUMENT.STAT_EN at STAT.BLK went from false to true
#define LWE297_CTL_STAT_EN_COUNT_0_VAL                             31:0


// Register LWE297_CTL_STAT_EN_COUNT  
#define LWE297_CTL_STAT_EN_COUNT                            0x14
// typically number of times INSTRUMENT.STAT_EN at STAT.BLK went from false to true
#define LWE297_CTL_STAT_EN_COUNT_VAL                               31:0


// Register LWE297_CTL_STAT_EN_COUNT_1  
#define LWE297_CTL_STAT_EN_COUNT_1                                  0x15
// typically number of times INSTRUMENT.STAT_EN at STAT.BLK went from false to true
#define LWE297_CTL_STAT_EN_COUNT_1_VAL                             31:0

// --------------------------------------------------------------------------
// 
// Copyright (c) 2004, LWPU Corp.
// All Rights Reserved.
// 
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of LWPU Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of LWPU Corp.
// 
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
// 
// --------------------------------------------------------------------------
// 
// LWE297_idx.spec
#define LWE297_IDX_NUM_ATTR        16
// This array sets the base address for each attribute, along with the format for each.
// It is an interleaved array with ATTR_BASE in the even words and the other fields in
// the odd words.  Attributes are fetched based on the index at an address specified by
// ATTR_BASE + index * ATTR_STRIDE.  The computed address can be arbitrarily aligned.
// Attributes are format-colwerted to 4x FP32 from their original format and size (1-4).
// Attributes with size less than 4 are padded with defaults of 0.0 for y/z and 1.0 for w.
//
// ATTR_[BASE|STRIDE|SIZE|FMT] are only used to describe the input attributes.  They have
// nothing to do with output attributes.

// Register LWE297_IDX_ATTRIBUTE_0  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_0                              0x100
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_0_ATTR_BASE                           31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_0_ATTR_STRIDE                         19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_0_ATTR_SIZE                           6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_0_ATTR_FMT                            3:0
#define LWE297_IDX_ATTRIBUTE_0_ATTR_FMT_U8                        0x00000000
#define LWE297_IDX_ATTRIBUTE_0_ATTR_FMT_U8N                       0x00000001
#define LWE297_IDX_ATTRIBUTE_0_ATTR_FMT_S8                        0x00000002
#define LWE297_IDX_ATTRIBUTE_0_ATTR_FMT_S8N                       0x00000003
#define LWE297_IDX_ATTRIBUTE_0_ATTR_FMT_U16                       0x00000004
#define LWE297_IDX_ATTRIBUTE_0_ATTR_FMT_U16N                      0x00000005
#define LWE297_IDX_ATTRIBUTE_0_ATTR_FMT_S16                       0x00000006
#define LWE297_IDX_ATTRIBUTE_0_ATTR_FMT_S16N                      0x00000007
#define LWE297_IDX_ATTRIBUTE_0_ATTR_FMT_U32                       0x00000008
#define LWE297_IDX_ATTRIBUTE_0_ATTR_FMT_U32N                      0x00000009
#define LWE297_IDX_ATTRIBUTE_0_ATTR_FMT_S32                       0x0000000a
#define LWE297_IDX_ATTRIBUTE_0_ATTR_FMT_S32N                      0x0000000b
#define LWE297_IDX_ATTRIBUTE_0_ATTR_FMT_X32                       0x0000000c
#define LWE297_IDX_ATTRIBUTE_0_ATTR_FMT_F32                       0x0000000d
#define LWE297_IDX_ATTRIBUTE_0_ATTR_FMT_H16                       0x0000000e


// Register LWE297_IDX_ATTRIBUTE  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE                                0x100
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_ATTR_BASE                             31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_ATTR_STRIDE                           19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_ATTR_SIZE                             6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_ATTR_FMT                              3:0
#define LWE297_IDX_ATTRIBUTE_ATTR_FMT_U8                  0x00000000
#define LWE297_IDX_ATTRIBUTE_ATTR_FMT_U8N                 0x00000001
#define LWE297_IDX_ATTRIBUTE_ATTR_FMT_S8                  0x00000002
#define LWE297_IDX_ATTRIBUTE_ATTR_FMT_S8N                 0x00000003
#define LWE297_IDX_ATTRIBUTE_ATTR_FMT_U16                 0x00000004
#define LWE297_IDX_ATTRIBUTE_ATTR_FMT_U16N                        0x00000005
#define LWE297_IDX_ATTRIBUTE_ATTR_FMT_S16                 0x00000006
#define LWE297_IDX_ATTRIBUTE_ATTR_FMT_S16N                        0x00000007
#define LWE297_IDX_ATTRIBUTE_ATTR_FMT_U32                 0x00000008
#define LWE297_IDX_ATTRIBUTE_ATTR_FMT_U32N                        0x00000009
#define LWE297_IDX_ATTRIBUTE_ATTR_FMT_S32                 0x0000000a
#define LWE297_IDX_ATTRIBUTE_ATTR_FMT_S32N                        0x0000000b
#define LWE297_IDX_ATTRIBUTE_ATTR_FMT_X32                 0x0000000c
#define LWE297_IDX_ATTRIBUTE_ATTR_FMT_F32                 0x0000000d
#define LWE297_IDX_ATTRIBUTE_ATTR_FMT_H16                 0x0000000e


// Register LWE297_IDX_ATTRIBUTE_1  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_1                              0x101
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_1_ATTR_BASE                           31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_1_ATTR_STRIDE                         19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_1_ATTR_SIZE                           6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_1_ATTR_FMT                            3:0
#define LWE297_IDX_ATTRIBUTE_1_ATTR_FMT_U8                        0x00000000
#define LWE297_IDX_ATTRIBUTE_1_ATTR_FMT_U8N                       0x00000001
#define LWE297_IDX_ATTRIBUTE_1_ATTR_FMT_S8                        0x00000002
#define LWE297_IDX_ATTRIBUTE_1_ATTR_FMT_S8N                       0x00000003
#define LWE297_IDX_ATTRIBUTE_1_ATTR_FMT_U16                       0x00000004
#define LWE297_IDX_ATTRIBUTE_1_ATTR_FMT_U16N                      0x00000005
#define LWE297_IDX_ATTRIBUTE_1_ATTR_FMT_S16                       0x00000006
#define LWE297_IDX_ATTRIBUTE_1_ATTR_FMT_S16N                      0x00000007
#define LWE297_IDX_ATTRIBUTE_1_ATTR_FMT_U32                       0x00000008
#define LWE297_IDX_ATTRIBUTE_1_ATTR_FMT_U32N                      0x00000009
#define LWE297_IDX_ATTRIBUTE_1_ATTR_FMT_S32                       0x0000000a
#define LWE297_IDX_ATTRIBUTE_1_ATTR_FMT_S32N                      0x0000000b
#define LWE297_IDX_ATTRIBUTE_1_ATTR_FMT_X32                       0x0000000c
#define LWE297_IDX_ATTRIBUTE_1_ATTR_FMT_F32                       0x0000000d
#define LWE297_IDX_ATTRIBUTE_1_ATTR_FMT_H16                       0x0000000e


// Register LWE297_IDX_ATTRIBUTE_2  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_2                              0x102
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_2_ATTR_BASE                           31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_2_ATTR_STRIDE                         19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_2_ATTR_SIZE                           6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_2_ATTR_FMT                            3:0
#define LWE297_IDX_ATTRIBUTE_2_ATTR_FMT_U8                        0x00000000
#define LWE297_IDX_ATTRIBUTE_2_ATTR_FMT_U8N                       0x00000001
#define LWE297_IDX_ATTRIBUTE_2_ATTR_FMT_S8                        0x00000002
#define LWE297_IDX_ATTRIBUTE_2_ATTR_FMT_S8N                       0x00000003
#define LWE297_IDX_ATTRIBUTE_2_ATTR_FMT_U16                       0x00000004
#define LWE297_IDX_ATTRIBUTE_2_ATTR_FMT_U16N                      0x00000005
#define LWE297_IDX_ATTRIBUTE_2_ATTR_FMT_S16                       0x00000006
#define LWE297_IDX_ATTRIBUTE_2_ATTR_FMT_S16N                      0x00000007
#define LWE297_IDX_ATTRIBUTE_2_ATTR_FMT_U32                       0x00000008
#define LWE297_IDX_ATTRIBUTE_2_ATTR_FMT_U32N                      0x00000009
#define LWE297_IDX_ATTRIBUTE_2_ATTR_FMT_S32                       0x0000000a
#define LWE297_IDX_ATTRIBUTE_2_ATTR_FMT_S32N                      0x0000000b
#define LWE297_IDX_ATTRIBUTE_2_ATTR_FMT_X32                       0x0000000c
#define LWE297_IDX_ATTRIBUTE_2_ATTR_FMT_F32                       0x0000000d
#define LWE297_IDX_ATTRIBUTE_2_ATTR_FMT_H16                       0x0000000e


// Register LWE297_IDX_ATTRIBUTE_3  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_3                              0x103
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_3_ATTR_BASE                           31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_3_ATTR_STRIDE                         19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_3_ATTR_SIZE                           6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_3_ATTR_FMT                            3:0
#define LWE297_IDX_ATTRIBUTE_3_ATTR_FMT_U8                        0x00000000
#define LWE297_IDX_ATTRIBUTE_3_ATTR_FMT_U8N                       0x00000001
#define LWE297_IDX_ATTRIBUTE_3_ATTR_FMT_S8                        0x00000002
#define LWE297_IDX_ATTRIBUTE_3_ATTR_FMT_S8N                       0x00000003
#define LWE297_IDX_ATTRIBUTE_3_ATTR_FMT_U16                       0x00000004
#define LWE297_IDX_ATTRIBUTE_3_ATTR_FMT_U16N                      0x00000005
#define LWE297_IDX_ATTRIBUTE_3_ATTR_FMT_S16                       0x00000006
#define LWE297_IDX_ATTRIBUTE_3_ATTR_FMT_S16N                      0x00000007
#define LWE297_IDX_ATTRIBUTE_3_ATTR_FMT_U32                       0x00000008
#define LWE297_IDX_ATTRIBUTE_3_ATTR_FMT_U32N                      0x00000009
#define LWE297_IDX_ATTRIBUTE_3_ATTR_FMT_S32                       0x0000000a
#define LWE297_IDX_ATTRIBUTE_3_ATTR_FMT_S32N                      0x0000000b
#define LWE297_IDX_ATTRIBUTE_3_ATTR_FMT_X32                       0x0000000c
#define LWE297_IDX_ATTRIBUTE_3_ATTR_FMT_F32                       0x0000000d
#define LWE297_IDX_ATTRIBUTE_3_ATTR_FMT_H16                       0x0000000e


// Register LWE297_IDX_ATTRIBUTE_4  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_4                              0x104
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_4_ATTR_BASE                           31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_4_ATTR_STRIDE                         19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_4_ATTR_SIZE                           6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_4_ATTR_FMT                            3:0
#define LWE297_IDX_ATTRIBUTE_4_ATTR_FMT_U8                        0x00000000
#define LWE297_IDX_ATTRIBUTE_4_ATTR_FMT_U8N                       0x00000001
#define LWE297_IDX_ATTRIBUTE_4_ATTR_FMT_S8                        0x00000002
#define LWE297_IDX_ATTRIBUTE_4_ATTR_FMT_S8N                       0x00000003
#define LWE297_IDX_ATTRIBUTE_4_ATTR_FMT_U16                       0x00000004
#define LWE297_IDX_ATTRIBUTE_4_ATTR_FMT_U16N                      0x00000005
#define LWE297_IDX_ATTRIBUTE_4_ATTR_FMT_S16                       0x00000006
#define LWE297_IDX_ATTRIBUTE_4_ATTR_FMT_S16N                      0x00000007
#define LWE297_IDX_ATTRIBUTE_4_ATTR_FMT_U32                       0x00000008
#define LWE297_IDX_ATTRIBUTE_4_ATTR_FMT_U32N                      0x00000009
#define LWE297_IDX_ATTRIBUTE_4_ATTR_FMT_S32                       0x0000000a
#define LWE297_IDX_ATTRIBUTE_4_ATTR_FMT_S32N                      0x0000000b
#define LWE297_IDX_ATTRIBUTE_4_ATTR_FMT_X32                       0x0000000c
#define LWE297_IDX_ATTRIBUTE_4_ATTR_FMT_F32                       0x0000000d
#define LWE297_IDX_ATTRIBUTE_4_ATTR_FMT_H16                       0x0000000e


// Register LWE297_IDX_ATTRIBUTE_5  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_5                              0x105
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_5_ATTR_BASE                           31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_5_ATTR_STRIDE                         19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_5_ATTR_SIZE                           6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_5_ATTR_FMT                            3:0
#define LWE297_IDX_ATTRIBUTE_5_ATTR_FMT_U8                        0x00000000
#define LWE297_IDX_ATTRIBUTE_5_ATTR_FMT_U8N                       0x00000001
#define LWE297_IDX_ATTRIBUTE_5_ATTR_FMT_S8                        0x00000002
#define LWE297_IDX_ATTRIBUTE_5_ATTR_FMT_S8N                       0x00000003
#define LWE297_IDX_ATTRIBUTE_5_ATTR_FMT_U16                       0x00000004
#define LWE297_IDX_ATTRIBUTE_5_ATTR_FMT_U16N                      0x00000005
#define LWE297_IDX_ATTRIBUTE_5_ATTR_FMT_S16                       0x00000006
#define LWE297_IDX_ATTRIBUTE_5_ATTR_FMT_S16N                      0x00000007
#define LWE297_IDX_ATTRIBUTE_5_ATTR_FMT_U32                       0x00000008
#define LWE297_IDX_ATTRIBUTE_5_ATTR_FMT_U32N                      0x00000009
#define LWE297_IDX_ATTRIBUTE_5_ATTR_FMT_S32                       0x0000000a
#define LWE297_IDX_ATTRIBUTE_5_ATTR_FMT_S32N                      0x0000000b
#define LWE297_IDX_ATTRIBUTE_5_ATTR_FMT_X32                       0x0000000c
#define LWE297_IDX_ATTRIBUTE_5_ATTR_FMT_F32                       0x0000000d
#define LWE297_IDX_ATTRIBUTE_5_ATTR_FMT_H16                       0x0000000e


// Register LWE297_IDX_ATTRIBUTE_6  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_6                              0x106
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_6_ATTR_BASE                           31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_6_ATTR_STRIDE                         19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_6_ATTR_SIZE                           6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_6_ATTR_FMT                            3:0
#define LWE297_IDX_ATTRIBUTE_6_ATTR_FMT_U8                        0x00000000
#define LWE297_IDX_ATTRIBUTE_6_ATTR_FMT_U8N                       0x00000001
#define LWE297_IDX_ATTRIBUTE_6_ATTR_FMT_S8                        0x00000002
#define LWE297_IDX_ATTRIBUTE_6_ATTR_FMT_S8N                       0x00000003
#define LWE297_IDX_ATTRIBUTE_6_ATTR_FMT_U16                       0x00000004
#define LWE297_IDX_ATTRIBUTE_6_ATTR_FMT_U16N                      0x00000005
#define LWE297_IDX_ATTRIBUTE_6_ATTR_FMT_S16                       0x00000006
#define LWE297_IDX_ATTRIBUTE_6_ATTR_FMT_S16N                      0x00000007
#define LWE297_IDX_ATTRIBUTE_6_ATTR_FMT_U32                       0x00000008
#define LWE297_IDX_ATTRIBUTE_6_ATTR_FMT_U32N                      0x00000009
#define LWE297_IDX_ATTRIBUTE_6_ATTR_FMT_S32                       0x0000000a
#define LWE297_IDX_ATTRIBUTE_6_ATTR_FMT_S32N                      0x0000000b
#define LWE297_IDX_ATTRIBUTE_6_ATTR_FMT_X32                       0x0000000c
#define LWE297_IDX_ATTRIBUTE_6_ATTR_FMT_F32                       0x0000000d
#define LWE297_IDX_ATTRIBUTE_6_ATTR_FMT_H16                       0x0000000e


// Register LWE297_IDX_ATTRIBUTE_7  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_7                              0x107
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_7_ATTR_BASE                           31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_7_ATTR_STRIDE                         19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_7_ATTR_SIZE                           6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_7_ATTR_FMT                            3:0
#define LWE297_IDX_ATTRIBUTE_7_ATTR_FMT_U8                        0x00000000
#define LWE297_IDX_ATTRIBUTE_7_ATTR_FMT_U8N                       0x00000001
#define LWE297_IDX_ATTRIBUTE_7_ATTR_FMT_S8                        0x00000002
#define LWE297_IDX_ATTRIBUTE_7_ATTR_FMT_S8N                       0x00000003
#define LWE297_IDX_ATTRIBUTE_7_ATTR_FMT_U16                       0x00000004
#define LWE297_IDX_ATTRIBUTE_7_ATTR_FMT_U16N                      0x00000005
#define LWE297_IDX_ATTRIBUTE_7_ATTR_FMT_S16                       0x00000006
#define LWE297_IDX_ATTRIBUTE_7_ATTR_FMT_S16N                      0x00000007
#define LWE297_IDX_ATTRIBUTE_7_ATTR_FMT_U32                       0x00000008
#define LWE297_IDX_ATTRIBUTE_7_ATTR_FMT_U32N                      0x00000009
#define LWE297_IDX_ATTRIBUTE_7_ATTR_FMT_S32                       0x0000000a
#define LWE297_IDX_ATTRIBUTE_7_ATTR_FMT_S32N                      0x0000000b
#define LWE297_IDX_ATTRIBUTE_7_ATTR_FMT_X32                       0x0000000c
#define LWE297_IDX_ATTRIBUTE_7_ATTR_FMT_F32                       0x0000000d
#define LWE297_IDX_ATTRIBUTE_7_ATTR_FMT_H16                       0x0000000e


// Register LWE297_IDX_ATTRIBUTE_8  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_8                              0x108
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_8_ATTR_BASE                           31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_8_ATTR_STRIDE                         19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_8_ATTR_SIZE                           6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_8_ATTR_FMT                            3:0
#define LWE297_IDX_ATTRIBUTE_8_ATTR_FMT_U8                        0x00000000
#define LWE297_IDX_ATTRIBUTE_8_ATTR_FMT_U8N                       0x00000001
#define LWE297_IDX_ATTRIBUTE_8_ATTR_FMT_S8                        0x00000002
#define LWE297_IDX_ATTRIBUTE_8_ATTR_FMT_S8N                       0x00000003
#define LWE297_IDX_ATTRIBUTE_8_ATTR_FMT_U16                       0x00000004
#define LWE297_IDX_ATTRIBUTE_8_ATTR_FMT_U16N                      0x00000005
#define LWE297_IDX_ATTRIBUTE_8_ATTR_FMT_S16                       0x00000006
#define LWE297_IDX_ATTRIBUTE_8_ATTR_FMT_S16N                      0x00000007
#define LWE297_IDX_ATTRIBUTE_8_ATTR_FMT_U32                       0x00000008
#define LWE297_IDX_ATTRIBUTE_8_ATTR_FMT_U32N                      0x00000009
#define LWE297_IDX_ATTRIBUTE_8_ATTR_FMT_S32                       0x0000000a
#define LWE297_IDX_ATTRIBUTE_8_ATTR_FMT_S32N                      0x0000000b
#define LWE297_IDX_ATTRIBUTE_8_ATTR_FMT_X32                       0x0000000c
#define LWE297_IDX_ATTRIBUTE_8_ATTR_FMT_F32                       0x0000000d
#define LWE297_IDX_ATTRIBUTE_8_ATTR_FMT_H16                       0x0000000e


// Register LWE297_IDX_ATTRIBUTE_9  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_9                              0x109
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_9_ATTR_BASE                           31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_9_ATTR_STRIDE                         19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_9_ATTR_SIZE                           6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_9_ATTR_FMT                            3:0
#define LWE297_IDX_ATTRIBUTE_9_ATTR_FMT_U8                        0x00000000
#define LWE297_IDX_ATTRIBUTE_9_ATTR_FMT_U8N                       0x00000001
#define LWE297_IDX_ATTRIBUTE_9_ATTR_FMT_S8                        0x00000002
#define LWE297_IDX_ATTRIBUTE_9_ATTR_FMT_S8N                       0x00000003
#define LWE297_IDX_ATTRIBUTE_9_ATTR_FMT_U16                       0x00000004
#define LWE297_IDX_ATTRIBUTE_9_ATTR_FMT_U16N                      0x00000005
#define LWE297_IDX_ATTRIBUTE_9_ATTR_FMT_S16                       0x00000006
#define LWE297_IDX_ATTRIBUTE_9_ATTR_FMT_S16N                      0x00000007
#define LWE297_IDX_ATTRIBUTE_9_ATTR_FMT_U32                       0x00000008
#define LWE297_IDX_ATTRIBUTE_9_ATTR_FMT_U32N                      0x00000009
#define LWE297_IDX_ATTRIBUTE_9_ATTR_FMT_S32                       0x0000000a
#define LWE297_IDX_ATTRIBUTE_9_ATTR_FMT_S32N                      0x0000000b
#define LWE297_IDX_ATTRIBUTE_9_ATTR_FMT_X32                       0x0000000c
#define LWE297_IDX_ATTRIBUTE_9_ATTR_FMT_F32                       0x0000000d
#define LWE297_IDX_ATTRIBUTE_9_ATTR_FMT_H16                       0x0000000e


// Register LWE297_IDX_ATTRIBUTE_10  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_10                             0x10a
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_10_ATTR_BASE                          31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_10_ATTR_STRIDE                        19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_10_ATTR_SIZE                          6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_10_ATTR_FMT                           3:0
#define LWE297_IDX_ATTRIBUTE_10_ATTR_FMT_U8                       0x00000000
#define LWE297_IDX_ATTRIBUTE_10_ATTR_FMT_U8N                      0x00000001
#define LWE297_IDX_ATTRIBUTE_10_ATTR_FMT_S8                       0x00000002
#define LWE297_IDX_ATTRIBUTE_10_ATTR_FMT_S8N                      0x00000003
#define LWE297_IDX_ATTRIBUTE_10_ATTR_FMT_U16                      0x00000004
#define LWE297_IDX_ATTRIBUTE_10_ATTR_FMT_U16N                     0x00000005
#define LWE297_IDX_ATTRIBUTE_10_ATTR_FMT_S16                      0x00000006
#define LWE297_IDX_ATTRIBUTE_10_ATTR_FMT_S16N                     0x00000007
#define LWE297_IDX_ATTRIBUTE_10_ATTR_FMT_U32                      0x00000008
#define LWE297_IDX_ATTRIBUTE_10_ATTR_FMT_U32N                     0x00000009
#define LWE297_IDX_ATTRIBUTE_10_ATTR_FMT_S32                      0x0000000a
#define LWE297_IDX_ATTRIBUTE_10_ATTR_FMT_S32N                     0x0000000b
#define LWE297_IDX_ATTRIBUTE_10_ATTR_FMT_X32                      0x0000000c
#define LWE297_IDX_ATTRIBUTE_10_ATTR_FMT_F32                      0x0000000d
#define LWE297_IDX_ATTRIBUTE_10_ATTR_FMT_H16                      0x0000000e


// Register LWE297_IDX_ATTRIBUTE_11  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_11                             0x10b
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_11_ATTR_BASE                          31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_11_ATTR_STRIDE                        19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_11_ATTR_SIZE                          6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_11_ATTR_FMT                           3:0
#define LWE297_IDX_ATTRIBUTE_11_ATTR_FMT_U8                       0x00000000
#define LWE297_IDX_ATTRIBUTE_11_ATTR_FMT_U8N                      0x00000001
#define LWE297_IDX_ATTRIBUTE_11_ATTR_FMT_S8                       0x00000002
#define LWE297_IDX_ATTRIBUTE_11_ATTR_FMT_S8N                      0x00000003
#define LWE297_IDX_ATTRIBUTE_11_ATTR_FMT_U16                      0x00000004
#define LWE297_IDX_ATTRIBUTE_11_ATTR_FMT_U16N                     0x00000005
#define LWE297_IDX_ATTRIBUTE_11_ATTR_FMT_S16                      0x00000006
#define LWE297_IDX_ATTRIBUTE_11_ATTR_FMT_S16N                     0x00000007
#define LWE297_IDX_ATTRIBUTE_11_ATTR_FMT_U32                      0x00000008
#define LWE297_IDX_ATTRIBUTE_11_ATTR_FMT_U32N                     0x00000009
#define LWE297_IDX_ATTRIBUTE_11_ATTR_FMT_S32                      0x0000000a
#define LWE297_IDX_ATTRIBUTE_11_ATTR_FMT_S32N                     0x0000000b
#define LWE297_IDX_ATTRIBUTE_11_ATTR_FMT_X32                      0x0000000c
#define LWE297_IDX_ATTRIBUTE_11_ATTR_FMT_F32                      0x0000000d
#define LWE297_IDX_ATTRIBUTE_11_ATTR_FMT_H16                      0x0000000e


// Register LWE297_IDX_ATTRIBUTE_12  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_12                             0x10c
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_12_ATTR_BASE                          31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_12_ATTR_STRIDE                        19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_12_ATTR_SIZE                          6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_12_ATTR_FMT                           3:0
#define LWE297_IDX_ATTRIBUTE_12_ATTR_FMT_U8                       0x00000000
#define LWE297_IDX_ATTRIBUTE_12_ATTR_FMT_U8N                      0x00000001
#define LWE297_IDX_ATTRIBUTE_12_ATTR_FMT_S8                       0x00000002
#define LWE297_IDX_ATTRIBUTE_12_ATTR_FMT_S8N                      0x00000003
#define LWE297_IDX_ATTRIBUTE_12_ATTR_FMT_U16                      0x00000004
#define LWE297_IDX_ATTRIBUTE_12_ATTR_FMT_U16N                     0x00000005
#define LWE297_IDX_ATTRIBUTE_12_ATTR_FMT_S16                      0x00000006
#define LWE297_IDX_ATTRIBUTE_12_ATTR_FMT_S16N                     0x00000007
#define LWE297_IDX_ATTRIBUTE_12_ATTR_FMT_U32                      0x00000008
#define LWE297_IDX_ATTRIBUTE_12_ATTR_FMT_U32N                     0x00000009
#define LWE297_IDX_ATTRIBUTE_12_ATTR_FMT_S32                      0x0000000a
#define LWE297_IDX_ATTRIBUTE_12_ATTR_FMT_S32N                     0x0000000b
#define LWE297_IDX_ATTRIBUTE_12_ATTR_FMT_X32                      0x0000000c
#define LWE297_IDX_ATTRIBUTE_12_ATTR_FMT_F32                      0x0000000d
#define LWE297_IDX_ATTRIBUTE_12_ATTR_FMT_H16                      0x0000000e


// Register LWE297_IDX_ATTRIBUTE_13  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_13                             0x10d
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_13_ATTR_BASE                          31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_13_ATTR_STRIDE                        19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_13_ATTR_SIZE                          6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_13_ATTR_FMT                           3:0
#define LWE297_IDX_ATTRIBUTE_13_ATTR_FMT_U8                       0x00000000
#define LWE297_IDX_ATTRIBUTE_13_ATTR_FMT_U8N                      0x00000001
#define LWE297_IDX_ATTRIBUTE_13_ATTR_FMT_S8                       0x00000002
#define LWE297_IDX_ATTRIBUTE_13_ATTR_FMT_S8N                      0x00000003
#define LWE297_IDX_ATTRIBUTE_13_ATTR_FMT_U16                      0x00000004
#define LWE297_IDX_ATTRIBUTE_13_ATTR_FMT_U16N                     0x00000005
#define LWE297_IDX_ATTRIBUTE_13_ATTR_FMT_S16                      0x00000006
#define LWE297_IDX_ATTRIBUTE_13_ATTR_FMT_S16N                     0x00000007
#define LWE297_IDX_ATTRIBUTE_13_ATTR_FMT_U32                      0x00000008
#define LWE297_IDX_ATTRIBUTE_13_ATTR_FMT_U32N                     0x00000009
#define LWE297_IDX_ATTRIBUTE_13_ATTR_FMT_S32                      0x0000000a
#define LWE297_IDX_ATTRIBUTE_13_ATTR_FMT_S32N                     0x0000000b
#define LWE297_IDX_ATTRIBUTE_13_ATTR_FMT_X32                      0x0000000c
#define LWE297_IDX_ATTRIBUTE_13_ATTR_FMT_F32                      0x0000000d
#define LWE297_IDX_ATTRIBUTE_13_ATTR_FMT_H16                      0x0000000e


// Register LWE297_IDX_ATTRIBUTE_14  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_14                             0x10e
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_14_ATTR_BASE                          31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_14_ATTR_STRIDE                        19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_14_ATTR_SIZE                          6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_14_ATTR_FMT                           3:0
#define LWE297_IDX_ATTRIBUTE_14_ATTR_FMT_U8                       0x00000000
#define LWE297_IDX_ATTRIBUTE_14_ATTR_FMT_U8N                      0x00000001
#define LWE297_IDX_ATTRIBUTE_14_ATTR_FMT_S8                       0x00000002
#define LWE297_IDX_ATTRIBUTE_14_ATTR_FMT_S8N                      0x00000003
#define LWE297_IDX_ATTRIBUTE_14_ATTR_FMT_U16                      0x00000004
#define LWE297_IDX_ATTRIBUTE_14_ATTR_FMT_U16N                     0x00000005
#define LWE297_IDX_ATTRIBUTE_14_ATTR_FMT_S16                      0x00000006
#define LWE297_IDX_ATTRIBUTE_14_ATTR_FMT_S16N                     0x00000007
#define LWE297_IDX_ATTRIBUTE_14_ATTR_FMT_U32                      0x00000008
#define LWE297_IDX_ATTRIBUTE_14_ATTR_FMT_U32N                     0x00000009
#define LWE297_IDX_ATTRIBUTE_14_ATTR_FMT_S32                      0x0000000a
#define LWE297_IDX_ATTRIBUTE_14_ATTR_FMT_S32N                     0x0000000b
#define LWE297_IDX_ATTRIBUTE_14_ATTR_FMT_X32                      0x0000000c
#define LWE297_IDX_ATTRIBUTE_14_ATTR_FMT_F32                      0x0000000d
#define LWE297_IDX_ATTRIBUTE_14_ATTR_FMT_H16                      0x0000000e


// Register LWE297_IDX_ATTRIBUTE_15  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_15                             0x10f
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_15_ATTR_BASE                          31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_15_ATTR_STRIDE                        19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_15_ATTR_SIZE                          6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_15_ATTR_FMT                           3:0
#define LWE297_IDX_ATTRIBUTE_15_ATTR_FMT_U8                       0x00000000
#define LWE297_IDX_ATTRIBUTE_15_ATTR_FMT_U8N                      0x00000001
#define LWE297_IDX_ATTRIBUTE_15_ATTR_FMT_S8                       0x00000002
#define LWE297_IDX_ATTRIBUTE_15_ATTR_FMT_S8N                      0x00000003
#define LWE297_IDX_ATTRIBUTE_15_ATTR_FMT_U16                      0x00000004
#define LWE297_IDX_ATTRIBUTE_15_ATTR_FMT_U16N                     0x00000005
#define LWE297_IDX_ATTRIBUTE_15_ATTR_FMT_S16                      0x00000006
#define LWE297_IDX_ATTRIBUTE_15_ATTR_FMT_S16N                     0x00000007
#define LWE297_IDX_ATTRIBUTE_15_ATTR_FMT_U32                      0x00000008
#define LWE297_IDX_ATTRIBUTE_15_ATTR_FMT_U32N                     0x00000009
#define LWE297_IDX_ATTRIBUTE_15_ATTR_FMT_S32                      0x0000000a
#define LWE297_IDX_ATTRIBUTE_15_ATTR_FMT_S32N                     0x0000000b
#define LWE297_IDX_ATTRIBUTE_15_ATTR_FMT_X32                      0x0000000c
#define LWE297_IDX_ATTRIBUTE_15_ATTR_FMT_F32                      0x0000000d
#define LWE297_IDX_ATTRIBUTE_15_ATTR_FMT_H16                      0x0000000e


// Register LWE297_IDX_ATTRIBUTE_16  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_16                             0x110
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_16_ATTR_BASE                          31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_16_ATTR_STRIDE                        19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_16_ATTR_SIZE                          6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_16_ATTR_FMT                           3:0
#define LWE297_IDX_ATTRIBUTE_16_ATTR_FMT_U8                       0x00000000
#define LWE297_IDX_ATTRIBUTE_16_ATTR_FMT_U8N                      0x00000001
#define LWE297_IDX_ATTRIBUTE_16_ATTR_FMT_S8                       0x00000002
#define LWE297_IDX_ATTRIBUTE_16_ATTR_FMT_S8N                      0x00000003
#define LWE297_IDX_ATTRIBUTE_16_ATTR_FMT_U16                      0x00000004
#define LWE297_IDX_ATTRIBUTE_16_ATTR_FMT_U16N                     0x00000005
#define LWE297_IDX_ATTRIBUTE_16_ATTR_FMT_S16                      0x00000006
#define LWE297_IDX_ATTRIBUTE_16_ATTR_FMT_S16N                     0x00000007
#define LWE297_IDX_ATTRIBUTE_16_ATTR_FMT_U32                      0x00000008
#define LWE297_IDX_ATTRIBUTE_16_ATTR_FMT_U32N                     0x00000009
#define LWE297_IDX_ATTRIBUTE_16_ATTR_FMT_S32                      0x0000000a
#define LWE297_IDX_ATTRIBUTE_16_ATTR_FMT_S32N                     0x0000000b
#define LWE297_IDX_ATTRIBUTE_16_ATTR_FMT_X32                      0x0000000c
#define LWE297_IDX_ATTRIBUTE_16_ATTR_FMT_F32                      0x0000000d
#define LWE297_IDX_ATTRIBUTE_16_ATTR_FMT_H16                      0x0000000e


// Register LWE297_IDX_ATTRIBUTE_17  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_17                             0x111
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_17_ATTR_BASE                          31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_17_ATTR_STRIDE                        19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_17_ATTR_SIZE                          6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_17_ATTR_FMT                           3:0
#define LWE297_IDX_ATTRIBUTE_17_ATTR_FMT_U8                       0x00000000
#define LWE297_IDX_ATTRIBUTE_17_ATTR_FMT_U8N                      0x00000001
#define LWE297_IDX_ATTRIBUTE_17_ATTR_FMT_S8                       0x00000002
#define LWE297_IDX_ATTRIBUTE_17_ATTR_FMT_S8N                      0x00000003
#define LWE297_IDX_ATTRIBUTE_17_ATTR_FMT_U16                      0x00000004
#define LWE297_IDX_ATTRIBUTE_17_ATTR_FMT_U16N                     0x00000005
#define LWE297_IDX_ATTRIBUTE_17_ATTR_FMT_S16                      0x00000006
#define LWE297_IDX_ATTRIBUTE_17_ATTR_FMT_S16N                     0x00000007
#define LWE297_IDX_ATTRIBUTE_17_ATTR_FMT_U32                      0x00000008
#define LWE297_IDX_ATTRIBUTE_17_ATTR_FMT_U32N                     0x00000009
#define LWE297_IDX_ATTRIBUTE_17_ATTR_FMT_S32                      0x0000000a
#define LWE297_IDX_ATTRIBUTE_17_ATTR_FMT_S32N                     0x0000000b
#define LWE297_IDX_ATTRIBUTE_17_ATTR_FMT_X32                      0x0000000c
#define LWE297_IDX_ATTRIBUTE_17_ATTR_FMT_F32                      0x0000000d
#define LWE297_IDX_ATTRIBUTE_17_ATTR_FMT_H16                      0x0000000e


// Register LWE297_IDX_ATTRIBUTE_18  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_18                             0x112
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_18_ATTR_BASE                          31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_18_ATTR_STRIDE                        19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_18_ATTR_SIZE                          6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_18_ATTR_FMT                           3:0
#define LWE297_IDX_ATTRIBUTE_18_ATTR_FMT_U8                       0x00000000
#define LWE297_IDX_ATTRIBUTE_18_ATTR_FMT_U8N                      0x00000001
#define LWE297_IDX_ATTRIBUTE_18_ATTR_FMT_S8                       0x00000002
#define LWE297_IDX_ATTRIBUTE_18_ATTR_FMT_S8N                      0x00000003
#define LWE297_IDX_ATTRIBUTE_18_ATTR_FMT_U16                      0x00000004
#define LWE297_IDX_ATTRIBUTE_18_ATTR_FMT_U16N                     0x00000005
#define LWE297_IDX_ATTRIBUTE_18_ATTR_FMT_S16                      0x00000006
#define LWE297_IDX_ATTRIBUTE_18_ATTR_FMT_S16N                     0x00000007
#define LWE297_IDX_ATTRIBUTE_18_ATTR_FMT_U32                      0x00000008
#define LWE297_IDX_ATTRIBUTE_18_ATTR_FMT_U32N                     0x00000009
#define LWE297_IDX_ATTRIBUTE_18_ATTR_FMT_S32                      0x0000000a
#define LWE297_IDX_ATTRIBUTE_18_ATTR_FMT_S32N                     0x0000000b
#define LWE297_IDX_ATTRIBUTE_18_ATTR_FMT_X32                      0x0000000c
#define LWE297_IDX_ATTRIBUTE_18_ATTR_FMT_F32                      0x0000000d
#define LWE297_IDX_ATTRIBUTE_18_ATTR_FMT_H16                      0x0000000e


// Register LWE297_IDX_ATTRIBUTE_19  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_19                             0x113
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_19_ATTR_BASE                          31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_19_ATTR_STRIDE                        19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_19_ATTR_SIZE                          6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_19_ATTR_FMT                           3:0
#define LWE297_IDX_ATTRIBUTE_19_ATTR_FMT_U8                       0x00000000
#define LWE297_IDX_ATTRIBUTE_19_ATTR_FMT_U8N                      0x00000001
#define LWE297_IDX_ATTRIBUTE_19_ATTR_FMT_S8                       0x00000002
#define LWE297_IDX_ATTRIBUTE_19_ATTR_FMT_S8N                      0x00000003
#define LWE297_IDX_ATTRIBUTE_19_ATTR_FMT_U16                      0x00000004
#define LWE297_IDX_ATTRIBUTE_19_ATTR_FMT_U16N                     0x00000005
#define LWE297_IDX_ATTRIBUTE_19_ATTR_FMT_S16                      0x00000006
#define LWE297_IDX_ATTRIBUTE_19_ATTR_FMT_S16N                     0x00000007
#define LWE297_IDX_ATTRIBUTE_19_ATTR_FMT_U32                      0x00000008
#define LWE297_IDX_ATTRIBUTE_19_ATTR_FMT_U32N                     0x00000009
#define LWE297_IDX_ATTRIBUTE_19_ATTR_FMT_S32                      0x0000000a
#define LWE297_IDX_ATTRIBUTE_19_ATTR_FMT_S32N                     0x0000000b
#define LWE297_IDX_ATTRIBUTE_19_ATTR_FMT_X32                      0x0000000c
#define LWE297_IDX_ATTRIBUTE_19_ATTR_FMT_F32                      0x0000000d
#define LWE297_IDX_ATTRIBUTE_19_ATTR_FMT_H16                      0x0000000e


// Register LWE297_IDX_ATTRIBUTE_20  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_20                             0x114
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_20_ATTR_BASE                          31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_20_ATTR_STRIDE                        19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_20_ATTR_SIZE                          6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_20_ATTR_FMT                           3:0
#define LWE297_IDX_ATTRIBUTE_20_ATTR_FMT_U8                       0x00000000
#define LWE297_IDX_ATTRIBUTE_20_ATTR_FMT_U8N                      0x00000001
#define LWE297_IDX_ATTRIBUTE_20_ATTR_FMT_S8                       0x00000002
#define LWE297_IDX_ATTRIBUTE_20_ATTR_FMT_S8N                      0x00000003
#define LWE297_IDX_ATTRIBUTE_20_ATTR_FMT_U16                      0x00000004
#define LWE297_IDX_ATTRIBUTE_20_ATTR_FMT_U16N                     0x00000005
#define LWE297_IDX_ATTRIBUTE_20_ATTR_FMT_S16                      0x00000006
#define LWE297_IDX_ATTRIBUTE_20_ATTR_FMT_S16N                     0x00000007
#define LWE297_IDX_ATTRIBUTE_20_ATTR_FMT_U32                      0x00000008
#define LWE297_IDX_ATTRIBUTE_20_ATTR_FMT_U32N                     0x00000009
#define LWE297_IDX_ATTRIBUTE_20_ATTR_FMT_S32                      0x0000000a
#define LWE297_IDX_ATTRIBUTE_20_ATTR_FMT_S32N                     0x0000000b
#define LWE297_IDX_ATTRIBUTE_20_ATTR_FMT_X32                      0x0000000c
#define LWE297_IDX_ATTRIBUTE_20_ATTR_FMT_F32                      0x0000000d
#define LWE297_IDX_ATTRIBUTE_20_ATTR_FMT_H16                      0x0000000e


// Register LWE297_IDX_ATTRIBUTE_21  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_21                             0x115
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_21_ATTR_BASE                          31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_21_ATTR_STRIDE                        19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_21_ATTR_SIZE                          6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_21_ATTR_FMT                           3:0
#define LWE297_IDX_ATTRIBUTE_21_ATTR_FMT_U8                       0x00000000
#define LWE297_IDX_ATTRIBUTE_21_ATTR_FMT_U8N                      0x00000001
#define LWE297_IDX_ATTRIBUTE_21_ATTR_FMT_S8                       0x00000002
#define LWE297_IDX_ATTRIBUTE_21_ATTR_FMT_S8N                      0x00000003
#define LWE297_IDX_ATTRIBUTE_21_ATTR_FMT_U16                      0x00000004
#define LWE297_IDX_ATTRIBUTE_21_ATTR_FMT_U16N                     0x00000005
#define LWE297_IDX_ATTRIBUTE_21_ATTR_FMT_S16                      0x00000006
#define LWE297_IDX_ATTRIBUTE_21_ATTR_FMT_S16N                     0x00000007
#define LWE297_IDX_ATTRIBUTE_21_ATTR_FMT_U32                      0x00000008
#define LWE297_IDX_ATTRIBUTE_21_ATTR_FMT_U32N                     0x00000009
#define LWE297_IDX_ATTRIBUTE_21_ATTR_FMT_S32                      0x0000000a
#define LWE297_IDX_ATTRIBUTE_21_ATTR_FMT_S32N                     0x0000000b
#define LWE297_IDX_ATTRIBUTE_21_ATTR_FMT_X32                      0x0000000c
#define LWE297_IDX_ATTRIBUTE_21_ATTR_FMT_F32                      0x0000000d
#define LWE297_IDX_ATTRIBUTE_21_ATTR_FMT_H16                      0x0000000e


// Register LWE297_IDX_ATTRIBUTE_22  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_22                             0x116
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_22_ATTR_BASE                          31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_22_ATTR_STRIDE                        19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_22_ATTR_SIZE                          6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_22_ATTR_FMT                           3:0
#define LWE297_IDX_ATTRIBUTE_22_ATTR_FMT_U8                       0x00000000
#define LWE297_IDX_ATTRIBUTE_22_ATTR_FMT_U8N                      0x00000001
#define LWE297_IDX_ATTRIBUTE_22_ATTR_FMT_S8                       0x00000002
#define LWE297_IDX_ATTRIBUTE_22_ATTR_FMT_S8N                      0x00000003
#define LWE297_IDX_ATTRIBUTE_22_ATTR_FMT_U16                      0x00000004
#define LWE297_IDX_ATTRIBUTE_22_ATTR_FMT_U16N                     0x00000005
#define LWE297_IDX_ATTRIBUTE_22_ATTR_FMT_S16                      0x00000006
#define LWE297_IDX_ATTRIBUTE_22_ATTR_FMT_S16N                     0x00000007
#define LWE297_IDX_ATTRIBUTE_22_ATTR_FMT_U32                      0x00000008
#define LWE297_IDX_ATTRIBUTE_22_ATTR_FMT_U32N                     0x00000009
#define LWE297_IDX_ATTRIBUTE_22_ATTR_FMT_S32                      0x0000000a
#define LWE297_IDX_ATTRIBUTE_22_ATTR_FMT_S32N                     0x0000000b
#define LWE297_IDX_ATTRIBUTE_22_ATTR_FMT_X32                      0x0000000c
#define LWE297_IDX_ATTRIBUTE_22_ATTR_FMT_F32                      0x0000000d
#define LWE297_IDX_ATTRIBUTE_22_ATTR_FMT_H16                      0x0000000e


// Register LWE297_IDX_ATTRIBUTE_23  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_23                             0x117
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_23_ATTR_BASE                          31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_23_ATTR_STRIDE                        19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_23_ATTR_SIZE                          6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_23_ATTR_FMT                           3:0
#define LWE297_IDX_ATTRIBUTE_23_ATTR_FMT_U8                       0x00000000
#define LWE297_IDX_ATTRIBUTE_23_ATTR_FMT_U8N                      0x00000001
#define LWE297_IDX_ATTRIBUTE_23_ATTR_FMT_S8                       0x00000002
#define LWE297_IDX_ATTRIBUTE_23_ATTR_FMT_S8N                      0x00000003
#define LWE297_IDX_ATTRIBUTE_23_ATTR_FMT_U16                      0x00000004
#define LWE297_IDX_ATTRIBUTE_23_ATTR_FMT_U16N                     0x00000005
#define LWE297_IDX_ATTRIBUTE_23_ATTR_FMT_S16                      0x00000006
#define LWE297_IDX_ATTRIBUTE_23_ATTR_FMT_S16N                     0x00000007
#define LWE297_IDX_ATTRIBUTE_23_ATTR_FMT_U32                      0x00000008
#define LWE297_IDX_ATTRIBUTE_23_ATTR_FMT_U32N                     0x00000009
#define LWE297_IDX_ATTRIBUTE_23_ATTR_FMT_S32                      0x0000000a
#define LWE297_IDX_ATTRIBUTE_23_ATTR_FMT_S32N                     0x0000000b
#define LWE297_IDX_ATTRIBUTE_23_ATTR_FMT_X32                      0x0000000c
#define LWE297_IDX_ATTRIBUTE_23_ATTR_FMT_F32                      0x0000000d
#define LWE297_IDX_ATTRIBUTE_23_ATTR_FMT_H16                      0x0000000e


// Register LWE297_IDX_ATTRIBUTE_24  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_24                             0x118
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_24_ATTR_BASE                          31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_24_ATTR_STRIDE                        19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_24_ATTR_SIZE                          6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_24_ATTR_FMT                           3:0
#define LWE297_IDX_ATTRIBUTE_24_ATTR_FMT_U8                       0x00000000
#define LWE297_IDX_ATTRIBUTE_24_ATTR_FMT_U8N                      0x00000001
#define LWE297_IDX_ATTRIBUTE_24_ATTR_FMT_S8                       0x00000002
#define LWE297_IDX_ATTRIBUTE_24_ATTR_FMT_S8N                      0x00000003
#define LWE297_IDX_ATTRIBUTE_24_ATTR_FMT_U16                      0x00000004
#define LWE297_IDX_ATTRIBUTE_24_ATTR_FMT_U16N                     0x00000005
#define LWE297_IDX_ATTRIBUTE_24_ATTR_FMT_S16                      0x00000006
#define LWE297_IDX_ATTRIBUTE_24_ATTR_FMT_S16N                     0x00000007
#define LWE297_IDX_ATTRIBUTE_24_ATTR_FMT_U32                      0x00000008
#define LWE297_IDX_ATTRIBUTE_24_ATTR_FMT_U32N                     0x00000009
#define LWE297_IDX_ATTRIBUTE_24_ATTR_FMT_S32                      0x0000000a
#define LWE297_IDX_ATTRIBUTE_24_ATTR_FMT_S32N                     0x0000000b
#define LWE297_IDX_ATTRIBUTE_24_ATTR_FMT_X32                      0x0000000c
#define LWE297_IDX_ATTRIBUTE_24_ATTR_FMT_F32                      0x0000000d
#define LWE297_IDX_ATTRIBUTE_24_ATTR_FMT_H16                      0x0000000e


// Register LWE297_IDX_ATTRIBUTE_25  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_25                             0x119
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_25_ATTR_BASE                          31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_25_ATTR_STRIDE                        19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_25_ATTR_SIZE                          6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_25_ATTR_FMT                           3:0
#define LWE297_IDX_ATTRIBUTE_25_ATTR_FMT_U8                       0x00000000
#define LWE297_IDX_ATTRIBUTE_25_ATTR_FMT_U8N                      0x00000001
#define LWE297_IDX_ATTRIBUTE_25_ATTR_FMT_S8                       0x00000002
#define LWE297_IDX_ATTRIBUTE_25_ATTR_FMT_S8N                      0x00000003
#define LWE297_IDX_ATTRIBUTE_25_ATTR_FMT_U16                      0x00000004
#define LWE297_IDX_ATTRIBUTE_25_ATTR_FMT_U16N                     0x00000005
#define LWE297_IDX_ATTRIBUTE_25_ATTR_FMT_S16                      0x00000006
#define LWE297_IDX_ATTRIBUTE_25_ATTR_FMT_S16N                     0x00000007
#define LWE297_IDX_ATTRIBUTE_25_ATTR_FMT_U32                      0x00000008
#define LWE297_IDX_ATTRIBUTE_25_ATTR_FMT_U32N                     0x00000009
#define LWE297_IDX_ATTRIBUTE_25_ATTR_FMT_S32                      0x0000000a
#define LWE297_IDX_ATTRIBUTE_25_ATTR_FMT_S32N                     0x0000000b
#define LWE297_IDX_ATTRIBUTE_25_ATTR_FMT_X32                      0x0000000c
#define LWE297_IDX_ATTRIBUTE_25_ATTR_FMT_F32                      0x0000000d
#define LWE297_IDX_ATTRIBUTE_25_ATTR_FMT_H16                      0x0000000e


// Register LWE297_IDX_ATTRIBUTE_26  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_26                             0x11a
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_26_ATTR_BASE                          31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_26_ATTR_STRIDE                        19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_26_ATTR_SIZE                          6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_26_ATTR_FMT                           3:0
#define LWE297_IDX_ATTRIBUTE_26_ATTR_FMT_U8                       0x00000000
#define LWE297_IDX_ATTRIBUTE_26_ATTR_FMT_U8N                      0x00000001
#define LWE297_IDX_ATTRIBUTE_26_ATTR_FMT_S8                       0x00000002
#define LWE297_IDX_ATTRIBUTE_26_ATTR_FMT_S8N                      0x00000003
#define LWE297_IDX_ATTRIBUTE_26_ATTR_FMT_U16                      0x00000004
#define LWE297_IDX_ATTRIBUTE_26_ATTR_FMT_U16N                     0x00000005
#define LWE297_IDX_ATTRIBUTE_26_ATTR_FMT_S16                      0x00000006
#define LWE297_IDX_ATTRIBUTE_26_ATTR_FMT_S16N                     0x00000007
#define LWE297_IDX_ATTRIBUTE_26_ATTR_FMT_U32                      0x00000008
#define LWE297_IDX_ATTRIBUTE_26_ATTR_FMT_U32N                     0x00000009
#define LWE297_IDX_ATTRIBUTE_26_ATTR_FMT_S32                      0x0000000a
#define LWE297_IDX_ATTRIBUTE_26_ATTR_FMT_S32N                     0x0000000b
#define LWE297_IDX_ATTRIBUTE_26_ATTR_FMT_X32                      0x0000000c
#define LWE297_IDX_ATTRIBUTE_26_ATTR_FMT_F32                      0x0000000d
#define LWE297_IDX_ATTRIBUTE_26_ATTR_FMT_H16                      0x0000000e


// Register LWE297_IDX_ATTRIBUTE_27  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_27                             0x11b
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_27_ATTR_BASE                          31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_27_ATTR_STRIDE                        19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_27_ATTR_SIZE                          6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_27_ATTR_FMT                           3:0
#define LWE297_IDX_ATTRIBUTE_27_ATTR_FMT_U8                       0x00000000
#define LWE297_IDX_ATTRIBUTE_27_ATTR_FMT_U8N                      0x00000001
#define LWE297_IDX_ATTRIBUTE_27_ATTR_FMT_S8                       0x00000002
#define LWE297_IDX_ATTRIBUTE_27_ATTR_FMT_S8N                      0x00000003
#define LWE297_IDX_ATTRIBUTE_27_ATTR_FMT_U16                      0x00000004
#define LWE297_IDX_ATTRIBUTE_27_ATTR_FMT_U16N                     0x00000005
#define LWE297_IDX_ATTRIBUTE_27_ATTR_FMT_S16                      0x00000006
#define LWE297_IDX_ATTRIBUTE_27_ATTR_FMT_S16N                     0x00000007
#define LWE297_IDX_ATTRIBUTE_27_ATTR_FMT_U32                      0x00000008
#define LWE297_IDX_ATTRIBUTE_27_ATTR_FMT_U32N                     0x00000009
#define LWE297_IDX_ATTRIBUTE_27_ATTR_FMT_S32                      0x0000000a
#define LWE297_IDX_ATTRIBUTE_27_ATTR_FMT_S32N                     0x0000000b
#define LWE297_IDX_ATTRIBUTE_27_ATTR_FMT_X32                      0x0000000c
#define LWE297_IDX_ATTRIBUTE_27_ATTR_FMT_F32                      0x0000000d
#define LWE297_IDX_ATTRIBUTE_27_ATTR_FMT_H16                      0x0000000e


// Register LWE297_IDX_ATTRIBUTE_28  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_28                             0x11c
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_28_ATTR_BASE                          31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_28_ATTR_STRIDE                        19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_28_ATTR_SIZE                          6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_28_ATTR_FMT                           3:0
#define LWE297_IDX_ATTRIBUTE_28_ATTR_FMT_U8                       0x00000000
#define LWE297_IDX_ATTRIBUTE_28_ATTR_FMT_U8N                      0x00000001
#define LWE297_IDX_ATTRIBUTE_28_ATTR_FMT_S8                       0x00000002
#define LWE297_IDX_ATTRIBUTE_28_ATTR_FMT_S8N                      0x00000003
#define LWE297_IDX_ATTRIBUTE_28_ATTR_FMT_U16                      0x00000004
#define LWE297_IDX_ATTRIBUTE_28_ATTR_FMT_U16N                     0x00000005
#define LWE297_IDX_ATTRIBUTE_28_ATTR_FMT_S16                      0x00000006
#define LWE297_IDX_ATTRIBUTE_28_ATTR_FMT_S16N                     0x00000007
#define LWE297_IDX_ATTRIBUTE_28_ATTR_FMT_U32                      0x00000008
#define LWE297_IDX_ATTRIBUTE_28_ATTR_FMT_U32N                     0x00000009
#define LWE297_IDX_ATTRIBUTE_28_ATTR_FMT_S32                      0x0000000a
#define LWE297_IDX_ATTRIBUTE_28_ATTR_FMT_S32N                     0x0000000b
#define LWE297_IDX_ATTRIBUTE_28_ATTR_FMT_X32                      0x0000000c
#define LWE297_IDX_ATTRIBUTE_28_ATTR_FMT_F32                      0x0000000d
#define LWE297_IDX_ATTRIBUTE_28_ATTR_FMT_H16                      0x0000000e


// Register LWE297_IDX_ATTRIBUTE_29  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_29                             0x11d
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_29_ATTR_BASE                          31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_29_ATTR_STRIDE                        19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_29_ATTR_SIZE                          6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_29_ATTR_FMT                           3:0
#define LWE297_IDX_ATTRIBUTE_29_ATTR_FMT_U8                       0x00000000
#define LWE297_IDX_ATTRIBUTE_29_ATTR_FMT_U8N                      0x00000001
#define LWE297_IDX_ATTRIBUTE_29_ATTR_FMT_S8                       0x00000002
#define LWE297_IDX_ATTRIBUTE_29_ATTR_FMT_S8N                      0x00000003
#define LWE297_IDX_ATTRIBUTE_29_ATTR_FMT_U16                      0x00000004
#define LWE297_IDX_ATTRIBUTE_29_ATTR_FMT_U16N                     0x00000005
#define LWE297_IDX_ATTRIBUTE_29_ATTR_FMT_S16                      0x00000006
#define LWE297_IDX_ATTRIBUTE_29_ATTR_FMT_S16N                     0x00000007
#define LWE297_IDX_ATTRIBUTE_29_ATTR_FMT_U32                      0x00000008
#define LWE297_IDX_ATTRIBUTE_29_ATTR_FMT_U32N                     0x00000009
#define LWE297_IDX_ATTRIBUTE_29_ATTR_FMT_S32                      0x0000000a
#define LWE297_IDX_ATTRIBUTE_29_ATTR_FMT_S32N                     0x0000000b
#define LWE297_IDX_ATTRIBUTE_29_ATTR_FMT_X32                      0x0000000c
#define LWE297_IDX_ATTRIBUTE_29_ATTR_FMT_F32                      0x0000000d
#define LWE297_IDX_ATTRIBUTE_29_ATTR_FMT_H16                      0x0000000e


// Register LWE297_IDX_ATTRIBUTE_30  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_30                             0x11e
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_30_ATTR_BASE                          31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_30_ATTR_STRIDE                        19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_30_ATTR_SIZE                          6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_30_ATTR_FMT                           3:0
#define LWE297_IDX_ATTRIBUTE_30_ATTR_FMT_U8                       0x00000000
#define LWE297_IDX_ATTRIBUTE_30_ATTR_FMT_U8N                      0x00000001
#define LWE297_IDX_ATTRIBUTE_30_ATTR_FMT_S8                       0x00000002
#define LWE297_IDX_ATTRIBUTE_30_ATTR_FMT_S8N                      0x00000003
#define LWE297_IDX_ATTRIBUTE_30_ATTR_FMT_U16                      0x00000004
#define LWE297_IDX_ATTRIBUTE_30_ATTR_FMT_U16N                     0x00000005
#define LWE297_IDX_ATTRIBUTE_30_ATTR_FMT_S16                      0x00000006
#define LWE297_IDX_ATTRIBUTE_30_ATTR_FMT_S16N                     0x00000007
#define LWE297_IDX_ATTRIBUTE_30_ATTR_FMT_U32                      0x00000008
#define LWE297_IDX_ATTRIBUTE_30_ATTR_FMT_U32N                     0x00000009
#define LWE297_IDX_ATTRIBUTE_30_ATTR_FMT_S32                      0x0000000a
#define LWE297_IDX_ATTRIBUTE_30_ATTR_FMT_S32N                     0x0000000b
#define LWE297_IDX_ATTRIBUTE_30_ATTR_FMT_X32                      0x0000000c
#define LWE297_IDX_ATTRIBUTE_30_ATTR_FMT_F32                      0x0000000d
#define LWE297_IDX_ATTRIBUTE_30_ATTR_FMT_H16                      0x0000000e


// Register LWE297_IDX_ATTRIBUTE_31  // Attribute address and format
#define LWE297_IDX_ATTRIBUTE_31                             0x11f
// Base address of attribute array
#define LWE297_IDX_ATTRIBUTE_31_ATTR_BASE                          31:0

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define LWE297_IDX_ATTRIBUTE_31_ATTR_STRIDE                        19:8

// Number of components, 1-4
#define LWE297_IDX_ATTRIBUTE_31_ATTR_SIZE                          6:4

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define LWE297_IDX_ATTRIBUTE_31_ATTR_FMT                           3:0
#define LWE297_IDX_ATTRIBUTE_31_ATTR_FMT_U8                       0x00000000
#define LWE297_IDX_ATTRIBUTE_31_ATTR_FMT_U8N                      0x00000001
#define LWE297_IDX_ATTRIBUTE_31_ATTR_FMT_S8                       0x00000002
#define LWE297_IDX_ATTRIBUTE_31_ATTR_FMT_S8N                      0x00000003
#define LWE297_IDX_ATTRIBUTE_31_ATTR_FMT_U16                      0x00000004
#define LWE297_IDX_ATTRIBUTE_31_ATTR_FMT_U16N                     0x00000005
#define LWE297_IDX_ATTRIBUTE_31_ATTR_FMT_S16                      0x00000006
#define LWE297_IDX_ATTRIBUTE_31_ATTR_FMT_S16N                     0x00000007
#define LWE297_IDX_ATTRIBUTE_31_ATTR_FMT_U32                      0x00000008
#define LWE297_IDX_ATTRIBUTE_31_ATTR_FMT_U32N                     0x00000009
#define LWE297_IDX_ATTRIBUTE_31_ATTR_FMT_S32                      0x0000000a
#define LWE297_IDX_ATTRIBUTE_31_ATTR_FMT_S32N                     0x0000000b
#define LWE297_IDX_ATTRIBUTE_31_ATTR_FMT_X32                      0x0000000c
#define LWE297_IDX_ATTRIBUTE_31_ATTR_FMT_F32                      0x0000000d
#define LWE297_IDX_ATTRIBUTE_31_ATTR_FMT_H16                      0x0000000e

// The attribute masks select which input attributes are present (for IDX to fetch and write
// to the VPE input buffers) and which output attributes are present (for VPE to write to
// the VPE output buffers).  They indirectly set the number of vertices in each buffer pool).
//
// Note that it is perfectly reasonable to have bits set in INPUT_ATTR_MASK that are not set
// in OUTPUT_ATTR_MASK (ex: skinning).  It is also perfectly reasonable to have bits set in
// OUTPUT_ATTR_MASK that are not set INPUT_ATTR_MASK (ex: texgen).

// Register LWE297_IDX_ATTR_MASK_0  // Attribute input and output masks
#define LWE297_IDX_ATTR_MASK_0                              0x120
// Input attribute mask
#define LWE297_IDX_ATTR_MASK_0_INPUT_ATTR_MASK                             31:16

// Output attribute mask
#define LWE297_IDX_ATTR_MASK_0_OUTPUT_ATTR_MASK                            15:0

// This sets the index base for DrawElements commands.  It must be natively aligned to the
// DRAW_MODE type.

// Register LWE297_IDX_INDEX_BASE_0  // Index array base
#define LWE297_IDX_INDEX_BASE_0                             0x121
// Base address of index array for DrawElements
#define LWE297_IDX_INDEX_BASE_0_INDEX_BASE                         31:0

// This sets the primitive type and determines if the indices will be directly generated (ARRAY)
// or indirectly fetched from memory (ELE8 / ELE16 / ELE32).  If the mode is ARRAY, a subsequent
// DRAW_PRIM will use vertices in the range START_VTX to START_VTX+VTX_COUNT.  If the mode is
// ELE8/ELE16/ELE32, it will fetch the indices from INDEX_BASE[0] to INDEX_BASE[VTX_COUNT] and
// add the fetched result to START_VTX.  The fetched index size can be 8-, 16- or 32-bits.
//
// Internally, the computed vertex offsets are as wide as START_VTX and use unsigned modulo
// arithmetic.  That means (for example) setting START_VTX=MAX for a DrawElements() command is
// effectively the same as subtracting one from each index.
//
// In addition, an explicit pivot vertex is supplied for TRI_FAN and LINE_LOOP primitives.  For
// the TRI_FAN primitive, the pivot vertex is the first vertex in each triangle (and the DRAW_PRIM
// method should supply all the following vertices).  For LINE_LOOP, the line loop finishes by 
// drawing to the pivot vertex (and the DRAW_PRIM should supply the pivot as the first vertex to
// start the loop).  Note that for DrawElements operations, the PIVOT_VTX value must be the actual
// vertex, not the index offset (the hardware uses PIVOT_VTX directly - it does not fetch
// INDEX_BASE[PIVOT_VTX]).
//
// There are also two command bits, for ilwalidating the vertex cache and the dma cache.  The
// DMA cache should be flushed whenever the attribute data is changed.  The vertex cache should
// be flushed whenever the indices reference different attributes OR the attribute data is changed.

// Register LWE297_IDX_SET_PRIM_0  // Set primitive type and drawing mode.
#define LWE297_IDX_SET_PRIM_0                               0x122
// Set to "1" to ilwalidate vertex cache.  Always
// reads back as "0".
#define LWE297_IDX_SET_PRIM_0_ILWALIDATE_VTXCACHE                          31:31

// Set to "1" to ilwalidate DMA cache.  Always reads
// back as "0".
#define LWE297_IDX_SET_PRIM_0_ILWALIDATE_DMACACHE                          30:30

// Primitive mode:
//      ARRAY   DrawArray()
//      ELE8    DrawElements8()
//      ELE16   DrawElements16()
//      ELE32   DrawElements32()
#define LWE297_IDX_SET_PRIM_0_DRAW_MODE                            29:28
#define LWE297_IDX_SET_PRIM_0_DRAW_MODE_ARRAY                     0x00000000
#define LWE297_IDX_SET_PRIM_0_DRAW_MODE_ELE8                      0x00000001
#define LWE297_IDX_SET_PRIM_0_DRAW_MODE_ELE16                     0x00000002
#define LWE297_IDX_SET_PRIM_0_DRAW_MODE_ELE32                     0x00000003

// Which vertex is flatshade vtx
#define LWE297_IDX_SET_PRIM_0_FLAT_VTX                             27:27
#define LWE297_IDX_SET_PRIM_0_FLAT_VTX_FIRST                      0x00000000
#define LWE297_IDX_SET_PRIM_0_FLAT_VTX_LAST                       0x00000001

// Primitive type
#define LWE297_IDX_SET_PRIM_0_PRIM_TYPE                            26:24
#define LWE297_IDX_SET_PRIM_0_PRIM_TYPE_POINTS                    0x00000000
#define LWE297_IDX_SET_PRIM_0_PRIM_TYPE_LINES                     0x00000001
#define LWE297_IDX_SET_PRIM_0_PRIM_TYPE_LINE_LOOP                 0x00000002
#define LWE297_IDX_SET_PRIM_0_PRIM_TYPE_LINE_STRIP                        0x00000003
#define LWE297_IDX_SET_PRIM_0_PRIM_TYPE_TRIS                      0x00000004
#define LWE297_IDX_SET_PRIM_0_PRIM_TYPE_TRI_STRIP                 0x00000005
#define LWE297_IDX_SET_PRIM_0_PRIM_TYPE_TRI_FAN                   0x00000006

// Start vertex for TRI_FAN, or
// end vertex for LINE_LOOP
#define LWE297_IDX_SET_PRIM_0_PIVOT_VTX                            19:0

// This method draws the primitive as described above.  If a larger primitive is required, multiple
// DRAW_PRIM methods may be ilwoked (and context switching will be allowed between them).  Since
// context switching saves the state of SET_PRIM.PIVOT_VTX, anchored primitives can context switch).
// Note that DRAW_PRIM methods must be broken on whole-primitive boundaries, there is no state
// maintained in the hardware to continue a primitive across DRAW_PRIM methods. This means that:
//
// POINTS can be broken up on any boundary.
//
// LINES must have a multiple of two vertexes and must be broken on a modulo 2 boundary.
//
// LINE_LOOP must be broken into LINE_STRIPS followed by a LINE_LOOP, with each draw after
//   the first one resending the last vertex from the prior draw. Note that the first vertex
//   of the LINE_LOOP does NOT use PIVOT_VTX, only the automatic closing line segment uses it.
//
// LINE_STRIP must have at least two vertexes but can otherwise be broken on any boundary
//   with each subsequent draw resending the last vertex of the prior draw.
//
// TRIS must have a multiple of three vertexes and must be broken on a modulo 3 boundary.
//
// TRI_STRIP must have at least three vertexes and must be broken on a modulo 4 boundary
//   in order to maintain winding, with each subsequent draw resending the prior two vertexes
//   of the prior draw.
//
// TRI_FAN must have at least two vertexes (the third is implicit in the PIVOT_VTX) and can be
//   broken on any boundary, with each subsequent draw resending the last vertex of the prior
//   draw.
//
// Using a VTX_COUNT that is too small to generate a set of whole primitives for the current
// PRIM_TYPE will result in replication of the final vertex until a finishing triangle or
// line is produced.  This final trangle or line will be lwlled since it is degenerate.
//

// Register LWE297_IDX_DRAW_PRIM_0  // Primitive draw command register
#define LWE297_IDX_DRAW_PRIM_0                              0x123
// Count of vertices, minus one
#define LWE297_IDX_DRAW_PRIM_0_VTX_COUNT                           31:20

// Starting offset
#define LWE297_IDX_DRAW_PRIM_0_START_VTX                           19:0

// IDX debug methods

// Register LWE297_IDX_IDX_CTL_0  
#define LWE297_IDX_IDX_CTL_0                                0x124
// Set to 1 by hw when an index
// is fetched in ELE32 mode that
// exceeds the max index value
#define LWE297_IDX_IDX_CTL_0_INDEX_TOO_LARGE                               5:5

// Force transform for every vertex
#define LWE297_IDX_IDX_CTL_0_FORCE_TRANSFORM                               4:4

// Disable DMA cache
#define LWE297_IDX_IDX_CTL_0_DMACACHE_DISABLE                              3:3

// Enable late binding
#define LWE297_IDX_IDX_CTL_0_LATE_BINDING                          2:2

// Enable OBUF compression
#define LWE297_IDX_IDX_CTL_0_VAR_OBUF_SIZE                         1:1

// Enable IBUF compression
#define LWE297_IDX_IDX_CTL_0_VAR_IBUF_SIZE                         0:0


// Register LWE297_IDX_IDX_STAT_0  
#define LWE297_IDX_IDX_STAT_0                               0x125
// IBUF in-use status
#define LWE297_IDX_IDX_STAT_0_IBUF_INUSE                           7:0

//
// Memory Client Interface Async Fifo Optimization Register
// This can only be changed while the pipeline is completely idle.
// Read-Only Instance
//
// Memory Client Interface Fifo Control Register.
// The registers below allow to optimize the synchronization timing in
// the memory client asynchronous fifos. When they can be used depend on
// the client and memory controller clock ratio.
// Additionally, the RDMC_RDFAST/RDCL_RDFAST fields can increase power
// consumption if the asynchronous fifo is implemented as a real ram.
// There is no power impact on latch-based fifos. Flipflop-based fifos
// do not use these fields.
// See recommended settings below.
//
// !! IMPORTANT !!
// The register fields can only be changed when the memory client async
// fifos are empty.
//
// The register field ending with WRCL_MCLE2X (if any) can be set to improve
// async fifo synchronization on the write side by one client clock cycle if
// the memory controller clock frequency is less or equal to twice the client
// clock frequency:
//
//      mcclk_freq <= 2 * clientclk_freq
//
// The register field ending with WRMC_CLLE2X (if any) can be set to improve
// async fifo synchronization on the write side by one memory controller clock
// cycle if the client clock frequency is less or equal to twice the memory
// controller clock frequency:
//
//      clientclk_freq <= 2 * mcclk_freq
//
// The register field ending with RDMC_RDFAST (if any) can be set to improve async
// fifo synchronization on the read side by one memory controller clock cycle.
//
// !! WARNING !!
// RDMC_RDFAST can be used along with WRCL_MCLE2X only when:
//
//       mcclk_freq <= clientclk_freq
//
// The register field ending with RDCL_RDFAST (if any) can be set to improve async
// fifo synchronization on the read side by one client clock cycle.
//
// !! WARNING !!
// RDCL_RDFAST can be used along with WRMC_CLLE2X only when:
//
//       clientclk_freq <= mcclk_freq
//
// RECOMMENDED SETTINGS
// # Client writing to fifo, memory controller reading from fifo
// - mcclk_freq <= clientclk_freq
//     You can enable both RDMC_RDFAST and WRCL_CLLE2X. If one of the fifos is
//     a real ram and power is a concern, you should avoid enabling RDMC_RDFAST.
// - clientclk_freq < mcclk_freq <= 2 * clientclk_freq
//     You can enable RDMC_RDFAST or WRCL_MCLE2X, but because the client clock
//     is slower, you should enable only WRCL_MCLE2X.
// - 2 * clientclk_freq < mcclk_freq
//     You can only enable RDMC_RDFAST. If one of the fifos is a real ram and
//     power is a concern, you should avoid enabling RDMC_RDFAST.
//
// # Memory controller writing to fifo, client reading from fifo
// - clientclk_freq <= mcclk_freq
//     You can enable both RDCL_RDFAST and WRMC_CLLE2X. If one of the fifos is
//     a real ram and power is a concern, you should avoid enabling RDCL_RDFAST.
// - mcclk_freq < clientclk_freq <= 2 * mcclk_freq
//     You can enable RDCL_RDFAST or WRMC_CLLE2X, but because the memory controller
//     clock is slower, you should enable only WRMC_CLLE2X.
// - 2 * mcclk_freq < clientclk_freq
//     You can only enable RDCL_RDFAST. If one of the fifos is a real ram and
//     power is a concern, you should avoid enabling RDCL_RDFAST.
//

// Register LWE297_IDX_LW_MCCIF_FIFOCTRL_RO_0  
#define LWE297_IDX_LW_MCCIF_FIFOCTRL_RO_0                           0x126
#define LWE297_IDX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRCL_MCLE2X                             0:0
#define LWE297_IDX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRCL_MCLE2X_INIT_ENUM                  DISABLE
#define LWE297_IDX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRCL_MCLE2X_DISABLE                    0x00000000
#define LWE297_IDX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRCL_MCLE2X_ENABLE                     0x00000001

#define LWE297_IDX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDMC_RDFAST                             1:1
#define LWE297_IDX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDMC_RDFAST_INIT_ENUM                  DISABLE
#define LWE297_IDX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDMC_RDFAST_DISABLE                    0x00000000
#define LWE297_IDX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDMC_RDFAST_ENABLE                     0x00000001

#define LWE297_IDX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRMC_CLLE2X                             2:2
#define LWE297_IDX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRMC_CLLE2X_INIT_ENUM                  DISABLE
#define LWE297_IDX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRMC_CLLE2X_DISABLE                    0x00000000
#define LWE297_IDX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRMC_CLLE2X_ENABLE                     0x00000001

#define LWE297_IDX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDCL_RDFAST                             3:3
#define LWE297_IDX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDCL_RDFAST_INIT_ENUM                  DISABLE
#define LWE297_IDX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDCL_RDFAST_DISABLE                    0x00000000
#define LWE297_IDX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDCL_RDFAST_ENABLE                     0x00000001

// --------------------------------------------------------------------------
// 
// Copyright (c) 2004, LWPU Corp.
// All Rights Reserved.
// 
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of LWPU Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of LWPU Corp.
// 
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
// 
// --------------------------------------------------------------------------
// 
// LWE297_vpe.spec
#define NUM_IBUF        8
#define NUM_OBUF        16
#define IBUF_RAM_SIZE   64
#define OBUF_RAM_SIZE   64
// we inherit this from the class spec.  maybe we should default it?

// Register LWE297_VPE_MODE_0  // VPE mode
#define LWE297_VPE_MODE_0                           0x200
// Selects if -0 == +0
#define LWE297_VPE_MODE_0_ZERO_MODE                        4:4
#define LWE297_VPE_MODE_0_ZERO_MODE_UNEQUAL                       0x00000000
#define LWE297_VPE_MODE_0_ZERO_MODE_EQUAL                 0x00000001

// Selects shader version
#define LWE297_VPE_MODE_0_SHADER_VERSION                           1:0
#define LWE297_VPE_MODE_0_SHADER_VERSION_V1                       0x00000002
#define LWE297_VPE_MODE_0_SHADER_VERSION_V2                       0x00000003
#define LWE297_VPE_MODE_0_SHADER_VERSION_V3                       0x00000001

// VPE program instruction timeout
// This sets the maximum number of instructions exelwted before the the
// program is terminated.  If a program terminates due to timeout, the
// output is whatever results the program managed to write before
// termination.  The other outputs will be the output defaults (0, 0, 0, 1).
// There is no software-visible indication of this event (other than
// the program output).

// Register LWE297_VPE_TIMEOUT_0  // VPE transform timeout
#define LWE297_VPE_TIMEOUT_0                                0x201
// Max insns exelwted
#define LWE297_VPE_TIMEOUT_0_MAX_INSN_COUNT                        15:0

// Read limits for indexed constant reads.  Used to partition constant space
// between co-resident programs.  Out of range indexed reads return (0, 0, 0, 0).

// Register LWE297_VPE_CONST_READ_LIMIT_0  // VPE constant read limits
#define LWE297_VPE_CONST_READ_LIMIT_0                               0x202
// Upper bound for indexed const reads
#define LWE297_VPE_CONST_READ_LIMIT_0_MAX_CONST_INDEX                              31:16

// Lower bound for indexed const reads
#define LWE297_VPE_CONST_READ_LIMIT_0_MIN_CONST_INDEX                              15:0

// The branchbits (boolean) register is described in the VPE instruction set.
// However, here is a brief overview:
//
// The VPE supports branching, subroutine calls & looping; these are sideband
// registers that can be programmed for static flow control (i.e., branch based
// on a per-draw call boolean).  e.g, given an uber shader:
// 
//    if (g_hasLighting) {
//        normal_eye = mul(modelViewIlwerseTranspose, normal_object);
//        //..  lighting code
//     }
// 
// and then assign g_hasLighting to a branch bit so that you can enable/disable
// "lighting" without changing the shader program.  uber shaders are most relevant
// for OES1.X emulation, but these boolean branch bits can also be used for
// uniform booleans.
// The branch bits are used by the BRB (branch on boolean) and CLB (call on boolean)
// VPE instructions.   The branches are taken based on the state of these bits.

// Register LWE297_VPE_BRANCHBITS_0  // VPE boolean branch bits
#define LWE297_VPE_BRANCHBITS_0                             0x203
// Boolean branch bits
#define LWE297_VPE_BRANCHBITS_0_BRANCHBITS                         31:0

// VPE program starting offset in instruction RAM.

// Register LWE297_VPE_START_0  // VPE program start address
#define LWE297_VPE_START_0                                  0x204
// VPE program start address
#define LWE297_VPE_START_0_START_ADDR                              7:0

//
// The VPE maps two resources: instructions and constants.
// These are both large, so we map them indirectly.  Writing to the base
// address sets the offset of the instruction word (128 bits) or the constant
// vector (4x32 bits) to be written or read.  This address should always be
// aligned to a four-DWORD boundary, since the VPE only supports reading and
// writing full 128-bit instructions and constant vectors even though
// INST_OFFSET and CONST_OFFSET address are DWORD-aligned.  Reads or writes
// of partial instructions or vectors is undefined.
// 
// It is the responsibility of s/w to feed the instructions and constants
// to the VPE (ie the VPE cannot pull instructions or constants).  The most
// efficient way for s/w to do this is using Host to GATHER the data.
//
// Every read or write to INST_DATA or CONST_DATA increments INST_OFFSET or
// CONST_OFFSET.  Every fourth write causes 128-bits of data to be written to
// the VPE; similarly, the first read of every four reads 128 bits and the
// next three reads return the remaining DWORDs.
// NOTE: VPE INST ram is a single ported ram and assumes that writes and reads
// do not happen in the same clock.  Since the reads and writes go through 
// different interfaces (with different latencies), a write  followed
// by a read in the next clock (or the subsequent clock) could result in the INSTR ram receiving read and
// write requests in the same clock.  This will result in wrong data being
// read out. To avoid this hazard writes and reads of the INST ram should
// be separated by atleast two clocks.

// Register LWE297_VPE_INST_OFFSET_0  // VPE instruction indirect address
#define LWE297_VPE_INST_OFFSET_0                            0x205
// Instruction offset (DWORDs)
// used by subsequent writes or
// reads of INST_DATA.  Each
// INST_DATA access increments
// this register.  Instructions
// should be written on 128-bit
// boundaries, so typically this
// register is written with the
// VPE instruction offset times four.
// Using INST_OFFSETs larger than
// LW_GR3D_VPE_NUM_INSNS * 4 is
// undefined.
#define LWE297_VPE_INST_OFFSET_0_INDEX                             9:0


// Register LWE297_VPE_INST_DATA_0  // VPE instruction indirect data
#define LWE297_VPE_INST_DATA_0                              0x206
// Read or write data for the data
// word addressed by INST_OFFSET.
// Each read or write of this
// register increments INST_OFFSET.
// Instructions are 128 bits and
// must be completely read or written
// so typically this register must
// be accessed a multiple of four
// times.
#define LWE297_VPE_INST_DATA_0_INST_DATA                           31:0


// Register LWE297_VPE_CONST_OFFSET_0  // VPE constant indirect address
#define LWE297_VPE_CONST_OFFSET_0                           0x207
// Constant vector offset (DWORDs)
// used by subsequent writes or
// reads of CONST_DATA.  Each
// CONST_DATA access increments
// this register.  Constant vectors
// should be written on 128-bit
// boundaries, so typically this
// register is written with the
// VPE constant offset times four.
// Using CONST_OFFSETs larger than
// LW_GR3D_VPE_NUM_CONST_VECS * 4
// is undefined.
#define LWE297_VPE_CONST_OFFSET_0_INDEX                            9:0


// Register LWE297_VPE_CONST_DATA_0  // VPE constant indirect data
#define LWE297_VPE_CONST_DATA_0                             0x208
// Read or write data for the data
// word addressed by CONST_OFFSET.
// Each read or write of this
// register increments CONST_OFFSET.
// Constant vectors are 128 bits and
// must be completely read or written
// so typically this register must
// be accessed a multiple of four
// times.
#define LWE297_VPE_CONST_DATA_0_CONST_DATA                         31:0

// Debug and CYA methods

// Register LWE297_VPE_GEOM_STALL_0  // Geometry stall
#define LWE297_VPE_GEOM_STALL_0                             0x209
// Number of stall cycles between
// thread launches
#define LWE297_VPE_GEOM_STALL_0_VPE_STALL                          7:0

// Cause a full flush between threads
#define LWE297_VPE_GEOM_STALL_0_VPE_FLUSH                          16:16

// Debug registers

// Register LWE297_VPE_VPE_CTRL_0  // VPE control
#define LWE297_VPE_VPE_CTRL_0                               0x20a
#define LWE297_VPE_VPE_CTRL_0_VPE_CTRL_VPEOR_CLKEN_OVR                             11:11

#define LWE297_VPE_VPE_CTRL_0_VPE_CTRL_VPERF_CLKEN_OVR                             10:10

#define LWE297_VPE_VPE_CTRL_0_VPE_CTRL_VPEOD_CLKEN_OVR                             9:9

#define LWE297_VPE_VPE_CTRL_0_VPE_CTRL_VPEOB_CLKEN_OVR                             8:8

#define LWE297_VPE_VPE_CTRL_0_VPE_CTRL_VPEIB_CLKEN_OVR                             7:7

#define LWE297_VPE_VPE_CTRL_0_VPE_CTRL_VPECR_CLKEN_OVR                             6:6

#define LWE297_VPE_VPE_CTRL_0_VPE_CTRL_VPEIR_CLKEN_OVR                             5:5

#define LWE297_VPE_VPE_CTRL_0_VPE_CTRL_VPEDP_CLKEN_OVR                             4:4

#define LWE297_VPE_VPE_CTRL_0_VPE_CTRL_SPARE0                              3:3

// spare bit 1
#define LWE297_VPE_VPE_CTRL_0_VPE_CTRL_THR2_DISABLE                        2:2

// thread disables 
#define LWE297_VPE_VPE_CTRL_0_VPE_CTRL_THR1_DISABLE                        1:1

#define LWE297_VPE_VPE_CTRL_0_VPE_CTRL_THR0_DISABLE                        0:0


// Register LWE297_VPE_VPE_DEBUG_0  // VPE debug
#define LWE297_VPE_VPE_DEBUG_0                              0x20b
#define LWE297_VPE_VPE_DEBUG_0_VPE_DEBUG_SPARE                             7:7

#define LWE297_VPE_VPE_DEBUG_0_VPE_DEBUG_VTF_SERIAL                        6:6

#define LWE297_VPE_VPE_DEBUG_0_VPE_DEBUG_THREAD_EXCLUSIVE                          5:5

#define LWE297_VPE_VPE_DEBUG_0_VPE_DEBUG_SERIAL_THREADS                            4:4

#define LWE297_VPE_VPE_DEBUG_0_VPE_DEBUG_OLDEST_FIRST                              3:3

#define LWE297_VPE_VPE_DEBUG_0_VPE_DEBUG_SERIALIZE_MODES                           2:2

// Obuf compression enable
#define LWE297_VPE_VPE_DEBUG_0_VPE_DEBUG_OBUF_SIZE                         1:1

// Ibuf compression enable
#define LWE297_VPE_VPE_DEBUG_0_VPE_DEBUG_IBUF_SIZE                         0:0

// VPE microcode format
#define VPE_INSTR_REG_NOP       63
#define VPE_INSTR_OUT_NOP       31

// Packet VPE_4X_INSTR
#define VPE_4X_INSTR_SIZE 127

// last instruction
#define VPE_4X_INSTR_LAST_ROW                   0

// const indexed addr
#define VPE_4X_INSTR_CTX_INDX_ROW                       0

// vertex output write addr
#define VPE_4X_INSTR_OUT_ROW                    0

// scalar reg file write addr
#define VPE_4X_INSTR_SRT_ADDR_ROW                       0

// vector write mask
#define VPE_4X_INSTR_VWE_ROW                    0

// scalar write mask
#define VPE_4X_INSTR_SWE_ROW                    0

// c mux (NA,r,v,c)
#define VPE_4X_INSTR_RC_TYPE_ROW                        0
#define VPE_4X_INSTR_RC_TYPE_ILWAL                      0x00000000
#define VPE_4X_INSTR_RC_TYPE_REG                        0x00000001
#define VPE_4X_INSTR_RC_TYPE_BUF                        0x00000002
#define VPE_4X_INSTR_RC_TYPE_CTX                        0x00000003

// c reg read
#define VPE_4X_INSTR_RC_ROW                     0

// c w swizzle
#define VPE_4X_INSTR_RC_W_EXTR_ROW                      0
#define VPE_4X_INSTR_RC_W_EXTR_X                        0x00000000
#define VPE_4X_INSTR_RC_W_EXTR_Y                        0x00000001
#define VPE_4X_INSTR_RC_W_EXTR_Z                        0x00000002
#define VPE_4X_INSTR_RC_W_EXTR_W                        0x00000003

// c z swizzle
#define VPE_4X_INSTR_RC_Z_EXTR_ROW                      0
#define VPE_4X_INSTR_RC_Z_EXTR_X                        0x00000000
#define VPE_4X_INSTR_RC_Z_EXTR_Y                        0x00000001
#define VPE_4X_INSTR_RC_Z_EXTR_Z                        0x00000002
#define VPE_4X_INSTR_RC_Z_EXTR_W                        0x00000003

// c y swizzle
#define VPE_4X_INSTR_RC_Y_EXTR_ROW                      0
#define VPE_4X_INSTR_RC_Y_EXTR_X                        0x00000000
#define VPE_4X_INSTR_RC_Y_EXTR_Y                        0x00000001
#define VPE_4X_INSTR_RC_Y_EXTR_Z                        0x00000002
#define VPE_4X_INSTR_RC_Y_EXTR_W                        0x00000003

// c x swizzle
#define VPE_4X_INSTR_RC_X_EXTR_ROW                      0
#define VPE_4X_INSTR_RC_X_EXTR_X                        0x00000000
#define VPE_4X_INSTR_RC_X_EXTR_Y                        0x00000001
#define VPE_4X_INSTR_RC_X_EXTR_Z                        0x00000002
#define VPE_4X_INSTR_RC_X_EXTR_W                        0x00000003

// c negate
#define VPE_4X_INSTR_RC_NEG_ROW                 0

// b mux (NA,r,v,c)
#define VPE_4X_INSTR_RB_TYPE_ROW                        0
#define VPE_4X_INSTR_RB_TYPE_ILWAL                      0x00000000
#define VPE_4X_INSTR_RB_TYPE_REG                        0x00000001
#define VPE_4X_INSTR_RB_TYPE_BUF                        0x00000002
#define VPE_4X_INSTR_RB_TYPE_CTX                        0x00000003

// b reg read
#define VPE_4X_INSTR_RB_ROW                     0

// b w swizzle
#define VPE_4X_INSTR_RB_W_EXTR_ROW                      0
#define VPE_4X_INSTR_RB_W_EXTR_X                        0x00000000
#define VPE_4X_INSTR_RB_W_EXTR_Y                        0x00000001
#define VPE_4X_INSTR_RB_W_EXTR_Z                        0x00000002
#define VPE_4X_INSTR_RB_W_EXTR_W                        0x00000003

// b z swizzle
#define VPE_4X_INSTR_RB_Z_EXTR_ROW                      0
#define VPE_4X_INSTR_RB_Z_EXTR_X                        0x00000000
#define VPE_4X_INSTR_RB_Z_EXTR_Y                        0x00000001
#define VPE_4X_INSTR_RB_Z_EXTR_Z                        0x00000002
#define VPE_4X_INSTR_RB_Z_EXTR_W                        0x00000003

// b y swizzle
#define VPE_4X_INSTR_RB_Y_EXTR_ROW                      0
#define VPE_4X_INSTR_RB_Y_EXTR_X                        0x00000000
#define VPE_4X_INSTR_RB_Y_EXTR_Y                        0x00000001
#define VPE_4X_INSTR_RB_Y_EXTR_Z                        0x00000002
#define VPE_4X_INSTR_RB_Y_EXTR_W                        0x00000003

// b x swizzle
#define VPE_4X_INSTR_RB_X_EXTR_ROW                      0
#define VPE_4X_INSTR_RB_X_EXTR_X                        0x00000000
#define VPE_4X_INSTR_RB_X_EXTR_Y                        0x00000001
#define VPE_4X_INSTR_RB_X_EXTR_Z                        0x00000002
#define VPE_4X_INSTR_RB_X_EXTR_W                        0x00000003

// b negate
#define VPE_4X_INSTR_RB_NEG_ROW                 0

// a mux (NA,r,v,c)
#define VPE_4X_INSTR_RA_TYPE_ROW                        0
#define VPE_4X_INSTR_RA_TYPE_ILWAL                      0x00000000
#define VPE_4X_INSTR_RA_TYPE_REG                        0x00000001
#define VPE_4X_INSTR_RA_TYPE_BUF                        0x00000002
#define VPE_4X_INSTR_RA_TYPE_CTX                        0x00000003

// a reg read
#define VPE_4X_INSTR_RA_ROW                     0

// a w swizzle
#define VPE_4X_INSTR_RA_W_EXTR_ROW                      0
#define VPE_4X_INSTR_RA_W_EXTR_X                        0x00000000
#define VPE_4X_INSTR_RA_W_EXTR_Y                        0x00000001
#define VPE_4X_INSTR_RA_W_EXTR_Z                        0x00000002
#define VPE_4X_INSTR_RA_W_EXTR_W                        0x00000003

// a z swizzle
#define VPE_4X_INSTR_RA_Z_EXTR_ROW                      0
#define VPE_4X_INSTR_RA_Z_EXTR_X                        0x00000000
#define VPE_4X_INSTR_RA_Z_EXTR_Y                        0x00000001
#define VPE_4X_INSTR_RA_Z_EXTR_Z                        0x00000002
#define VPE_4X_INSTR_RA_Z_EXTR_W                        0x00000003

// a y swizzle
#define VPE_4X_INSTR_RA_Y_EXTR_ROW                      0
#define VPE_4X_INSTR_RA_Y_EXTR_X                        0x00000000
#define VPE_4X_INSTR_RA_Y_EXTR_Y                        0x00000001
#define VPE_4X_INSTR_RA_Y_EXTR_Z                        0x00000002
#define VPE_4X_INSTR_RA_Y_EXTR_W                        0x00000003

// a x swizzle
#define VPE_4X_INSTR_RA_X_EXTR_ROW                      0
#define VPE_4X_INSTR_RA_X_EXTR_X                        0x00000000
#define VPE_4X_INSTR_RA_X_EXTR_Y                        0x00000001
#define VPE_4X_INSTR_RA_X_EXTR_Z                        0x00000002
#define VPE_4X_INSTR_RA_X_EXTR_W                        0x00000003

// a negate
#define VPE_4X_INSTR_RA_NEG_ROW                 0

// vertex read addr
#define VPE_4X_INSTR_IBUF_ADDR_ROW                      0

// const read addr
#define VPE_4X_INSTR_CTX_ADDR_ROW                       0

// vector op
#define VPE_4X_INSTR_OPCODE_V_ROW                       0
#define VPE_4X_INSTR_OPCODE_V_NOP                       0x00000000
#define VPE_4X_INSTR_OPCODE_V_MOV                       0x00000001
#define VPE_4X_INSTR_OPCODE_V_MUL                       0x00000002
#define VPE_4X_INSTR_OPCODE_V_ADD                       0x00000003
#define VPE_4X_INSTR_OPCODE_V_MAD                       0x00000004
#define VPE_4X_INSTR_OPCODE_V_DP3                       0x00000005
#define VPE_4X_INSTR_OPCODE_V_DPH                       0x00000006
#define VPE_4X_INSTR_OPCODE_V_DP4                       0x00000007
#define VPE_4X_INSTR_OPCODE_V_DST                       0x00000008
#define VPE_4X_INSTR_OPCODE_V_MIN                       0x00000009
#define VPE_4X_INSTR_OPCODE_V_MAX                       0x0000000a
#define VPE_4X_INSTR_OPCODE_V_SLT                       0x0000000b
#define VPE_4X_INSTR_OPCODE_V_SGE                       0x0000000c
#define VPE_4X_INSTR_OPCODE_V_ARL                       0x0000000d
#define VPE_4X_INSTR_OPCODE_V_FRC                       0x0000000e
#define VPE_4X_INSTR_OPCODE_V_FLR                       0x0000000f
#define VPE_4X_INSTR_OPCODE_V_SEQ                       0x00000010
#define VPE_4X_INSTR_OPCODE_V_SFL                       0x00000011
#define VPE_4X_INSTR_OPCODE_V_SGT                       0x00000012
#define VPE_4X_INSTR_OPCODE_V_SLE                       0x00000013
#define VPE_4X_INSTR_OPCODE_V_SNE                       0x00000014
#define VPE_4X_INSTR_OPCODE_V_STR                       0x00000015
#define VPE_4X_INSTR_OPCODE_V_SSG                       0x00000016
#define VPE_4X_INSTR_OPCODE_V_ARR                       0x00000017
#define VPE_4X_INSTR_OPCODE_V_MVA                       0x00000018
#define VPE_4X_INSTR_OPCODE_V_TXL                       0x00000019
#define VPE_4X_INSTR_OPCODE_V_PSH                       0x0000001a
#define VPE_4X_INSTR_OPCODE_V_POP                       0x0000001b
#define VPE_4X_INSTR_OPCODE_V_RSV0                      0x0000001c
#define VPE_4X_INSTR_OPCODE_V_RSV1                      0x0000001d
#define VPE_4X_INSTR_OPCODE_V_RSV2                      0x0000001e
#define VPE_4X_INSTR_OPCODE_V_RSV3                      0x0000001f

// scalar op
#define VPE_4X_INSTR_OPCODE_S_ROW                       0
#define VPE_4X_INSTR_OPCODE_S_NOP                       0x00000000
#define VPE_4X_INSTR_OPCODE_S_MOV                       0x00000001
#define VPE_4X_INSTR_OPCODE_S_RCP                       0x00000002
#define VPE_4X_INSTR_OPCODE_S_RCC                       0x00000003
#define VPE_4X_INSTR_OPCODE_S_RSQ                       0x00000004
#define VPE_4X_INSTR_OPCODE_S_EXP                       0x00000005
#define VPE_4X_INSTR_OPCODE_S_LOG                       0x00000006
#define VPE_4X_INSTR_OPCODE_S_LIT                       0x00000007
#define VPE_4X_INSTR_OPCODE_S_BRA                       0x00000008
#define VPE_4X_INSTR_OPCODE_S_BRI                       0x00000009
#define VPE_4X_INSTR_OPCODE_S_CLA                       0x0000000a
#define VPE_4X_INSTR_OPCODE_S_CLI                       0x0000000b
#define VPE_4X_INSTR_OPCODE_S_RET                       0x0000000c
#define VPE_4X_INSTR_OPCODE_S_LG2                       0x0000000d
#define VPE_4X_INSTR_OPCODE_S_EX2                       0x0000000e
#define VPE_4X_INSTR_OPCODE_S_SIN                       0x0000000f
#define VPE_4X_INSTR_OPCODE_S_COS                       0x00000010
#define VPE_4X_INSTR_OPCODE_S_BRB                       0x00000011
#define VPE_4X_INSTR_OPCODE_S_CLB                       0x00000012
#define VPE_4X_INSTR_OPCODE_S_PSH                       0x00000013
#define VPE_4X_INSTR_OPCODE_S_POP                       0x00000014
#define VPE_4X_INSTR_OPCODE_S_RSV0                      0x00000015

// address scalar select
#define VPE_4X_INSTR_SCALAR_SEL_ROW                     0

// cc w swizzle
#define VPE_4X_INSTR_RCC_W_EXTR_ROW                     0
#define VPE_4X_INSTR_RCC_W_EXTR_X                       0x00000000
#define VPE_4X_INSTR_RCC_W_EXTR_Y                       0x00000001
#define VPE_4X_INSTR_RCC_W_EXTR_Z                       0x00000002
#define VPE_4X_INSTR_RCC_W_EXTR_W                       0x00000003

// cc z swizzle
#define VPE_4X_INSTR_RCC_Z_EXTR_ROW                     0
#define VPE_4X_INSTR_RCC_Z_EXTR_X                       0x00000000
#define VPE_4X_INSTR_RCC_Z_EXTR_Y                       0x00000001
#define VPE_4X_INSTR_RCC_Z_EXTR_Z                       0x00000002
#define VPE_4X_INSTR_RCC_Z_EXTR_W                       0x00000003

// cc y swizzle
#define VPE_4X_INSTR_RCC_Y_EXTR_ROW                     0
#define VPE_4X_INSTR_RCC_Y_EXTR_X                       0x00000000
#define VPE_4X_INSTR_RCC_Y_EXTR_Y                       0x00000001
#define VPE_4X_INSTR_RCC_Y_EXTR_Z                       0x00000002
#define VPE_4X_INSTR_RCC_Y_EXTR_W                       0x00000003

// cc x swizzle
#define VPE_4X_INSTR_RCC_X_EXTR_ROW                     0
#define VPE_4X_INSTR_RCC_X_EXTR_X                       0x00000000
#define VPE_4X_INSTR_RCC_X_EXTR_Y                       0x00000001
#define VPE_4X_INSTR_RCC_X_EXTR_Z                       0x00000002
#define VPE_4X_INSTR_RCC_X_EXTR_W                       0x00000003

// cc compare
#define VPE_4X_INSTR_RCC_COMPARE_ROW                    0
#define VPE_4X_INSTR_RCC_COMPARE_FALSE                  0x00000000
#define VPE_4X_INSTR_RCC_COMPARE_LT                     0x00000001
#define VPE_4X_INSTR_RCC_COMPARE_EQ                     0x00000002
#define VPE_4X_INSTR_RCC_COMPARE_LE                     0x00000003
#define VPE_4X_INSTR_RCC_COMPARE_GT                     0x00000004
#define VPE_4X_INSTR_RCC_COMPARE_NE                     0x00000005
#define VPE_4X_INSTR_RCC_COMPARE_GE                     0x00000006
#define VPE_4X_INSTR_RCC_COMPARE_TRUE                   0x00000007

// writemask mod
#define VPE_4X_INSTR_MOD_WE_ROW                 0

// cc write enable
#define VPE_4X_INSTR_RCC_WEN_ROW                        0

// vector reg write addr
#define VPE_4X_INSTR_RT_ADDR_ROW                        0

// a abs val
#define VPE_4X_INSTR_RA_ABS_ROW                 0

// b abs val
#define VPE_4X_INSTR_RB_ABS_ROW                 0

// c abs val
#define VPE_4X_INSTR_RC_ABS_ROW                 0

// addr reg read addr
#define VPE_4X_INSTR_OFFREG_RA_ROW                      0

// condition code sel
#define VPE_4X_INSTR_CC_SEL_ROW                 0

// saturate output
#define VPE_4X_INSTR_SATURATE_ROW                       0

// vertex read indexed addr
#define VPE_4X_INSTR_IBUF_INDX_ROW                      0

// vertex write indexed addr
#define VPE_4X_INSTR_OBUF_INDX_ROW                      0

// cc write source/mask sel
#define VPE_4X_INSTR_CC_WR_SEL_ROW                      0
#define VPE_4X_INSTR_CC_WR_SEL_SCALAR                   0x00000000
#define VPE_4X_INSTR_CC_WR_SEL_VECTOR                   0x00000001

// vertex write source/mask sel
#define VPE_4X_INSTR_OUT_SEL_ROW                        0
#define VPE_4X_INSTR_OUT_SEL_SCALAR                     0x00000000
#define VPE_4X_INSTR_OUT_SEL_VECTOR                     0x00000001

// --------------------------------------------------------------------------
//
// Copyright (c) 2004, LWPU Corp.
// All Rights Reserved.
//
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of LWPU Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of LWPU Corp.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
//
// --------------------------------------------------------------------------
//
// This file has all the reg/packet definitions related to Setup unit in AR
// This file is included in ar3d.spec
//
//
// clip/setup instruction format
//
// The primary function of these instructions is to link vertex shader outputs with fragment shader inputs.  They direct the clip block to 
// copy VPE OBUF attributes to atrast TRAM rows, where they are read by IPA instructions in the fragment shader.  A secondary function is to 
// provide Z to atrast for late Z processing (i.e., when qrast cannot perform early Z.)
//
// Instructions are 64 bits wide; each is divided into two 32-bit halves called EVEN and ODD.
// The EVEN halves are written to even addresses (0x300, 0x302, ...) and ODD halves to odd addresses (0x301, 0x303, ...).
// Two overlapping sets of fields are given below; EVEN words contain SRC, VC_ROW, TRAM_ROW, Px_LINE_WIDTH, Px_LINE_LENGTH, and Px_POINT.
// ODD words contain Px_TRAM_COL, Px_TRAM_FMT, and Px_TRI_SHADE_MODE.
//
// If SRC is VPE,
// Each VPE attribute (row) maps to exactly one TRAM row, but to arbitrary
// columns.  VC_ROW gives the VPE attribute number. Each P<N>_TRAM_FMT/COL specifies the destination format 
// and location for VPE column N.  VC_ROW uses post-obuf-compression attribute number.  idx's OUTPUT_ATTR_MASK gives the set of valid
// pre-compression obuf attributes; idx and vpe then compress that mask to remove unused slots.  For example, of OUTPUT_ATTR_MASK is 0x9, then
// the valid pre-compression attributes are 0 and 3.  The valid post-compression attributes are 0 and 1.  Clip's VC_ROW uses the latter
// numbering.   Obuf compression reduces the size of each vertex, while allowing vpe shader program to use fixed attribute numbering.
// It permits more vertices to remain cached in obuf, improving performance.
//
// If SRC is not VPE, then only P0_* are used.  A special internal value is used rather than a VPE OBUF attribute.
//
// LINE and POINT primitives are special: they are composed of four corner vertices which are 
// synthesized from 1 or 2 input vertices.  Attributes must likewise be synthesized.  
// Each attribute can be held constant across width and/or height, or interpolated.
// If constant, the input vertex attribute(s) are used unchanged.
//   For points: if "S", attribute is varied from 0 to 1 in X direction.
//               if "T", attribute is varied from 0 to 1 in Y direction. (*)
//               if "DISABLE", attribute is constant (from vertex value)
//   For lines: When LINE_LENGTH is VARYING, attribute is interpolated between V0 and V1 values along length (and LINE_WIDTH is ignored).
//              Else if LINE_LENGTH is CONST and  LINE_WIDTH is VARYING, then attribute is varied from 0 to LINE_MAX_ATTR_W across width.
//              Else if both CONST, then V1 value is used.
//
// Examples:
// 1. for point sprites, texture coordinate S attribute should be Px_POINT=S, and T Px_POINT=T.
//    but other attributes should be set to Px_POINT=DISABLE.  POINT_MAX_S and POINT_MAX_T are 1.0.
//    The texture coordinates will be generated as [0, POINT_MAX_S].
// 2. for antialiased smooth-shaded lines, all attributes should probably be set to LINE_LENGTH=VARYING,
//    and LINE_WIDTH=CONST
//    except the antialiasing texture which should be LINE_WIDTH=VARYING.
//    The minumum value in T can be changed from 0.0 using LINE_MIN_ATTR_W register (sc25 only).
//
// (*) when POINT_PARAM.SCALE_MODE is SHEARED, the "x" and "y" directions are not necessary aligned with X and Y axis,
//     but rather are aligned with the shearing vectors.
//     The maximum value in S and T can be changed from 1.0 using the POINT_MAX_S and POINT_MAX_T registers.
//     The minimum value in S and T can be changed from 0.0 using the POINT_MIN_S and POINT_MIN_T registers (sc25 only).
//

// Register LWE297_SU_INST_0  
#define LWE297_SU_INST_0                            0x300
// source of attribute for TRAM
#define LWE297_SU_INST_0_SRC                               1:0
#define LWE297_SU_INST_0_SRC_VPE                  0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_0_SRC_Z                    0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_0_VC_ROW                            6:3

// TRAM destination row
#define LWE297_SU_INST_0_TRAM_ROW                          14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_0_P0_LINE_WIDTH                             16:16
#define LWE297_SU_INST_0_P0_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_0_P0_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_0_P0_LINE_LENGTH                            17:17
#define LWE297_SU_INST_0_P0_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_0_P0_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_0_P0_POINT                          19:18
#define LWE297_SU_INST_0_P0_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_0_P0_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_0_P0_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_0_P1_LINE_WIDTH                             20:20
#define LWE297_SU_INST_0_P1_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_0_P1_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_0_P1_LINE_LENGTH                            21:21
#define LWE297_SU_INST_0_P1_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_0_P1_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_0_P1_POINT                          23:22
#define LWE297_SU_INST_0_P1_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_0_P1_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_0_P1_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_0_P2_LINE_WIDTH                             24:24
#define LWE297_SU_INST_0_P2_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_0_P2_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_0_P2_LINE_LENGTH                            25:25
#define LWE297_SU_INST_0_P2_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_0_P2_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_0_P2_POINT                          27:26
#define LWE297_SU_INST_0_P2_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_0_P2_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_0_P2_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_0_P3_LINE_WIDTH                             28:28
#define LWE297_SU_INST_0_P3_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_0_P3_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_0_P3_LINE_LENGTH                            29:29
#define LWE297_SU_INST_0_P3_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_0_P3_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_0_P3_POINT                          31:30
#define LWE297_SU_INST_0_P3_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_0_P3_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_0_P3_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_0_P0_TRAM_COL                               1:0

// TRAM column format
#define LWE297_SU_INST_0_P0_TRAM_FMT                               3:2
#define LWE297_SU_INST_0_P0_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_0_P0_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_0_P0_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_0_P0_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_0_P1_TRAM_COL                               5:4

// TRAM column format
#define LWE297_SU_INST_0_P1_TRAM_FMT                               7:6
#define LWE297_SU_INST_0_P1_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_0_P1_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_0_P1_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_0_P1_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_0_P2_TRAM_COL                               9:8

// TRAM column format
#define LWE297_SU_INST_0_P2_TRAM_FMT                               11:10
#define LWE297_SU_INST_0_P2_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_0_P2_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_0_P2_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_0_P2_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_0_P3_TRAM_COL                               13:12

// TRAM column format format
#define LWE297_SU_INST_0_P3_TRAM_FMT                               15:14
#define LWE297_SU_INST_0_P3_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_0_P3_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_0_P3_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_0_P3_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_0_P0_TRI_SHADE_MODE                         16:16
#define LWE297_SU_INST_0_P0_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_0_P0_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_0_P1_TRI_SHADE_MODE                         17:17
#define LWE297_SU_INST_0_P1_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_0_P1_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_0_P2_TRI_SHADE_MODE                         18:18
#define LWE297_SU_INST_0_P2_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_0_P2_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_0_P3_TRI_SHADE_MODE                         19:19
#define LWE297_SU_INST_0_P3_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_0_P3_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST  
#define LWE297_SU_INST                              0x300
// source of attribute for TRAM
#define LWE297_SU_INST_SRC                         1:0
#define LWE297_SU_INST_SRC_VPE                    0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_SRC_Z                      0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_VC_ROW                              6:3

// TRAM destination row
#define LWE297_SU_INST_TRAM_ROW                            14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_P0_LINE_WIDTH                               16:16
#define LWE297_SU_INST_P0_LINE_WIDTH_CONST                        0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_P0_LINE_WIDTH_VARYING                      0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_P0_LINE_LENGTH                              17:17
#define LWE297_SU_INST_P0_LINE_LENGTH_VARYING                     0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_P0_LINE_LENGTH_CONST                       0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_P0_POINT                            19:18
#define LWE297_SU_INST_P0_POINT_DISABLE                   0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_P0_POINT_S                 0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_P0_POINT_T                 0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_P1_LINE_WIDTH                               20:20
#define LWE297_SU_INST_P1_LINE_WIDTH_CONST                        0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_P1_LINE_WIDTH_VARYING                      0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_P1_LINE_LENGTH                              21:21
#define LWE297_SU_INST_P1_LINE_LENGTH_VARYING                     0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_P1_LINE_LENGTH_CONST                       0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_P1_POINT                            23:22
#define LWE297_SU_INST_P1_POINT_DISABLE                   0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_P1_POINT_S                 0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_P1_POINT_T                 0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_P2_LINE_WIDTH                               24:24
#define LWE297_SU_INST_P2_LINE_WIDTH_CONST                        0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_P2_LINE_WIDTH_VARYING                      0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_P2_LINE_LENGTH                              25:25
#define LWE297_SU_INST_P2_LINE_LENGTH_VARYING                     0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_P2_LINE_LENGTH_CONST                       0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_P2_POINT                            27:26
#define LWE297_SU_INST_P2_POINT_DISABLE                   0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_P2_POINT_S                 0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_P2_POINT_T                 0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_P3_LINE_WIDTH                               28:28
#define LWE297_SU_INST_P3_LINE_WIDTH_CONST                        0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_P3_LINE_WIDTH_VARYING                      0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_P3_LINE_LENGTH                              29:29
#define LWE297_SU_INST_P3_LINE_LENGTH_VARYING                     0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_P3_LINE_LENGTH_CONST                       0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_P3_POINT                            31:30
#define LWE297_SU_INST_P3_POINT_DISABLE                   0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_P3_POINT_S                 0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_P3_POINT_T                 0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_P0_TRAM_COL                         1:0

// TRAM column format
#define LWE297_SU_INST_P0_TRAM_FMT                         3:2
#define LWE297_SU_INST_P0_TRAM_FMT_NOP                    0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_P0_TRAM_FMT_LP_LO                  0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_P0_TRAM_FMT_LP_HI                  0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_P0_TRAM_FMT_HP                     0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_P1_TRAM_COL                         5:4

// TRAM column format
#define LWE297_SU_INST_P1_TRAM_FMT                         7:6
#define LWE297_SU_INST_P1_TRAM_FMT_NOP                    0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_P1_TRAM_FMT_LP_LO                  0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_P1_TRAM_FMT_LP_HI                  0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_P1_TRAM_FMT_HP                     0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_P2_TRAM_COL                         9:8

// TRAM column format
#define LWE297_SU_INST_P2_TRAM_FMT                         11:10
#define LWE297_SU_INST_P2_TRAM_FMT_NOP                    0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_P2_TRAM_FMT_LP_LO                  0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_P2_TRAM_FMT_LP_HI                  0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_P2_TRAM_FMT_HP                     0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_P3_TRAM_COL                         13:12

// TRAM column format format
#define LWE297_SU_INST_P3_TRAM_FMT                         15:14
#define LWE297_SU_INST_P3_TRAM_FMT_NOP                    0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_P3_TRAM_FMT_LP_LO                  0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_P3_TRAM_FMT_LP_HI                  0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_P3_TRAM_FMT_HP                     0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_P0_TRI_SHADE_MODE                           16:16
#define LWE297_SU_INST_P0_TRI_SHADE_MODE_SMOOTH                   0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_P0_TRI_SHADE_MODE_FLAT                     0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_P1_TRI_SHADE_MODE                           17:17
#define LWE297_SU_INST_P1_TRI_SHADE_MODE_SMOOTH                   0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_P1_TRI_SHADE_MODE_FLAT                     0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_P2_TRI_SHADE_MODE                           18:18
#define LWE297_SU_INST_P2_TRI_SHADE_MODE_SMOOTH                   0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_P2_TRI_SHADE_MODE_FLAT                     0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_P3_TRI_SHADE_MODE                           19:19
#define LWE297_SU_INST_P3_TRI_SHADE_MODE_SMOOTH                   0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_P3_TRI_SHADE_MODE_FLAT                     0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_1  
#define LWE297_SU_INST_1                            0x301
// source of attribute for TRAM
#define LWE297_SU_INST_1_SRC                               1:0
#define LWE297_SU_INST_1_SRC_VPE                  0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_1_SRC_Z                    0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_1_VC_ROW                            6:3

// TRAM destination row
#define LWE297_SU_INST_1_TRAM_ROW                          14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_1_P0_LINE_WIDTH                             16:16
#define LWE297_SU_INST_1_P0_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_1_P0_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_1_P0_LINE_LENGTH                            17:17
#define LWE297_SU_INST_1_P0_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_1_P0_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_1_P0_POINT                          19:18
#define LWE297_SU_INST_1_P0_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_1_P0_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_1_P0_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_1_P1_LINE_WIDTH                             20:20
#define LWE297_SU_INST_1_P1_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_1_P1_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_1_P1_LINE_LENGTH                            21:21
#define LWE297_SU_INST_1_P1_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_1_P1_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_1_P1_POINT                          23:22
#define LWE297_SU_INST_1_P1_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_1_P1_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_1_P1_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_1_P2_LINE_WIDTH                             24:24
#define LWE297_SU_INST_1_P2_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_1_P2_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_1_P2_LINE_LENGTH                            25:25
#define LWE297_SU_INST_1_P2_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_1_P2_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_1_P2_POINT                          27:26
#define LWE297_SU_INST_1_P2_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_1_P2_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_1_P2_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_1_P3_LINE_WIDTH                             28:28
#define LWE297_SU_INST_1_P3_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_1_P3_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_1_P3_LINE_LENGTH                            29:29
#define LWE297_SU_INST_1_P3_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_1_P3_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_1_P3_POINT                          31:30
#define LWE297_SU_INST_1_P3_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_1_P3_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_1_P3_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_1_P0_TRAM_COL                               1:0

// TRAM column format
#define LWE297_SU_INST_1_P0_TRAM_FMT                               3:2
#define LWE297_SU_INST_1_P0_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_1_P0_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_1_P0_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_1_P0_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_1_P1_TRAM_COL                               5:4

// TRAM column format
#define LWE297_SU_INST_1_P1_TRAM_FMT                               7:6
#define LWE297_SU_INST_1_P1_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_1_P1_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_1_P1_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_1_P1_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_1_P2_TRAM_COL                               9:8

// TRAM column format
#define LWE297_SU_INST_1_P2_TRAM_FMT                               11:10
#define LWE297_SU_INST_1_P2_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_1_P2_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_1_P2_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_1_P2_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_1_P3_TRAM_COL                               13:12

// TRAM column format format
#define LWE297_SU_INST_1_P3_TRAM_FMT                               15:14
#define LWE297_SU_INST_1_P3_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_1_P3_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_1_P3_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_1_P3_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_1_P0_TRI_SHADE_MODE                         16:16
#define LWE297_SU_INST_1_P0_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_1_P0_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_1_P1_TRI_SHADE_MODE                         17:17
#define LWE297_SU_INST_1_P1_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_1_P1_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_1_P2_TRI_SHADE_MODE                         18:18
#define LWE297_SU_INST_1_P2_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_1_P2_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_1_P3_TRI_SHADE_MODE                         19:19
#define LWE297_SU_INST_1_P3_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_1_P3_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_2  
#define LWE297_SU_INST_2                            0x302
// source of attribute for TRAM
#define LWE297_SU_INST_2_SRC                               1:0
#define LWE297_SU_INST_2_SRC_VPE                  0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_2_SRC_Z                    0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_2_VC_ROW                            6:3

// TRAM destination row
#define LWE297_SU_INST_2_TRAM_ROW                          14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_2_P0_LINE_WIDTH                             16:16
#define LWE297_SU_INST_2_P0_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_2_P0_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_2_P0_LINE_LENGTH                            17:17
#define LWE297_SU_INST_2_P0_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_2_P0_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_2_P0_POINT                          19:18
#define LWE297_SU_INST_2_P0_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_2_P0_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_2_P0_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_2_P1_LINE_WIDTH                             20:20
#define LWE297_SU_INST_2_P1_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_2_P1_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_2_P1_LINE_LENGTH                            21:21
#define LWE297_SU_INST_2_P1_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_2_P1_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_2_P1_POINT                          23:22
#define LWE297_SU_INST_2_P1_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_2_P1_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_2_P1_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_2_P2_LINE_WIDTH                             24:24
#define LWE297_SU_INST_2_P2_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_2_P2_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_2_P2_LINE_LENGTH                            25:25
#define LWE297_SU_INST_2_P2_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_2_P2_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_2_P2_POINT                          27:26
#define LWE297_SU_INST_2_P2_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_2_P2_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_2_P2_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_2_P3_LINE_WIDTH                             28:28
#define LWE297_SU_INST_2_P3_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_2_P3_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_2_P3_LINE_LENGTH                            29:29
#define LWE297_SU_INST_2_P3_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_2_P3_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_2_P3_POINT                          31:30
#define LWE297_SU_INST_2_P3_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_2_P3_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_2_P3_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_2_P0_TRAM_COL                               1:0

// TRAM column format
#define LWE297_SU_INST_2_P0_TRAM_FMT                               3:2
#define LWE297_SU_INST_2_P0_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_2_P0_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_2_P0_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_2_P0_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_2_P1_TRAM_COL                               5:4

// TRAM column format
#define LWE297_SU_INST_2_P1_TRAM_FMT                               7:6
#define LWE297_SU_INST_2_P1_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_2_P1_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_2_P1_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_2_P1_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_2_P2_TRAM_COL                               9:8

// TRAM column format
#define LWE297_SU_INST_2_P2_TRAM_FMT                               11:10
#define LWE297_SU_INST_2_P2_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_2_P2_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_2_P2_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_2_P2_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_2_P3_TRAM_COL                               13:12

// TRAM column format format
#define LWE297_SU_INST_2_P3_TRAM_FMT                               15:14
#define LWE297_SU_INST_2_P3_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_2_P3_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_2_P3_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_2_P3_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_2_P0_TRI_SHADE_MODE                         16:16
#define LWE297_SU_INST_2_P0_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_2_P0_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_2_P1_TRI_SHADE_MODE                         17:17
#define LWE297_SU_INST_2_P1_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_2_P1_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_2_P2_TRI_SHADE_MODE                         18:18
#define LWE297_SU_INST_2_P2_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_2_P2_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_2_P3_TRI_SHADE_MODE                         19:19
#define LWE297_SU_INST_2_P3_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_2_P3_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_3  
#define LWE297_SU_INST_3                            0x303
// source of attribute for TRAM
#define LWE297_SU_INST_3_SRC                               1:0
#define LWE297_SU_INST_3_SRC_VPE                  0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_3_SRC_Z                    0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_3_VC_ROW                            6:3

// TRAM destination row
#define LWE297_SU_INST_3_TRAM_ROW                          14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_3_P0_LINE_WIDTH                             16:16
#define LWE297_SU_INST_3_P0_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_3_P0_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_3_P0_LINE_LENGTH                            17:17
#define LWE297_SU_INST_3_P0_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_3_P0_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_3_P0_POINT                          19:18
#define LWE297_SU_INST_3_P0_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_3_P0_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_3_P0_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_3_P1_LINE_WIDTH                             20:20
#define LWE297_SU_INST_3_P1_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_3_P1_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_3_P1_LINE_LENGTH                            21:21
#define LWE297_SU_INST_3_P1_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_3_P1_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_3_P1_POINT                          23:22
#define LWE297_SU_INST_3_P1_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_3_P1_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_3_P1_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_3_P2_LINE_WIDTH                             24:24
#define LWE297_SU_INST_3_P2_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_3_P2_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_3_P2_LINE_LENGTH                            25:25
#define LWE297_SU_INST_3_P2_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_3_P2_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_3_P2_POINT                          27:26
#define LWE297_SU_INST_3_P2_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_3_P2_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_3_P2_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_3_P3_LINE_WIDTH                             28:28
#define LWE297_SU_INST_3_P3_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_3_P3_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_3_P3_LINE_LENGTH                            29:29
#define LWE297_SU_INST_3_P3_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_3_P3_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_3_P3_POINT                          31:30
#define LWE297_SU_INST_3_P3_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_3_P3_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_3_P3_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_3_P0_TRAM_COL                               1:0

// TRAM column format
#define LWE297_SU_INST_3_P0_TRAM_FMT                               3:2
#define LWE297_SU_INST_3_P0_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_3_P0_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_3_P0_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_3_P0_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_3_P1_TRAM_COL                               5:4

// TRAM column format
#define LWE297_SU_INST_3_P1_TRAM_FMT                               7:6
#define LWE297_SU_INST_3_P1_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_3_P1_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_3_P1_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_3_P1_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_3_P2_TRAM_COL                               9:8

// TRAM column format
#define LWE297_SU_INST_3_P2_TRAM_FMT                               11:10
#define LWE297_SU_INST_3_P2_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_3_P2_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_3_P2_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_3_P2_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_3_P3_TRAM_COL                               13:12

// TRAM column format format
#define LWE297_SU_INST_3_P3_TRAM_FMT                               15:14
#define LWE297_SU_INST_3_P3_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_3_P3_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_3_P3_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_3_P3_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_3_P0_TRI_SHADE_MODE                         16:16
#define LWE297_SU_INST_3_P0_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_3_P0_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_3_P1_TRI_SHADE_MODE                         17:17
#define LWE297_SU_INST_3_P1_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_3_P1_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_3_P2_TRI_SHADE_MODE                         18:18
#define LWE297_SU_INST_3_P2_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_3_P2_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_3_P3_TRI_SHADE_MODE                         19:19
#define LWE297_SU_INST_3_P3_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_3_P3_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_4  
#define LWE297_SU_INST_4                            0x304
// source of attribute for TRAM
#define LWE297_SU_INST_4_SRC                               1:0
#define LWE297_SU_INST_4_SRC_VPE                  0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_4_SRC_Z                    0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_4_VC_ROW                            6:3

// TRAM destination row
#define LWE297_SU_INST_4_TRAM_ROW                          14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_4_P0_LINE_WIDTH                             16:16
#define LWE297_SU_INST_4_P0_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_4_P0_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_4_P0_LINE_LENGTH                            17:17
#define LWE297_SU_INST_4_P0_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_4_P0_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_4_P0_POINT                          19:18
#define LWE297_SU_INST_4_P0_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_4_P0_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_4_P0_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_4_P1_LINE_WIDTH                             20:20
#define LWE297_SU_INST_4_P1_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_4_P1_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_4_P1_LINE_LENGTH                            21:21
#define LWE297_SU_INST_4_P1_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_4_P1_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_4_P1_POINT                          23:22
#define LWE297_SU_INST_4_P1_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_4_P1_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_4_P1_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_4_P2_LINE_WIDTH                             24:24
#define LWE297_SU_INST_4_P2_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_4_P2_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_4_P2_LINE_LENGTH                            25:25
#define LWE297_SU_INST_4_P2_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_4_P2_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_4_P2_POINT                          27:26
#define LWE297_SU_INST_4_P2_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_4_P2_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_4_P2_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_4_P3_LINE_WIDTH                             28:28
#define LWE297_SU_INST_4_P3_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_4_P3_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_4_P3_LINE_LENGTH                            29:29
#define LWE297_SU_INST_4_P3_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_4_P3_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_4_P3_POINT                          31:30
#define LWE297_SU_INST_4_P3_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_4_P3_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_4_P3_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_4_P0_TRAM_COL                               1:0

// TRAM column format
#define LWE297_SU_INST_4_P0_TRAM_FMT                               3:2
#define LWE297_SU_INST_4_P0_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_4_P0_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_4_P0_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_4_P0_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_4_P1_TRAM_COL                               5:4

// TRAM column format
#define LWE297_SU_INST_4_P1_TRAM_FMT                               7:6
#define LWE297_SU_INST_4_P1_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_4_P1_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_4_P1_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_4_P1_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_4_P2_TRAM_COL                               9:8

// TRAM column format
#define LWE297_SU_INST_4_P2_TRAM_FMT                               11:10
#define LWE297_SU_INST_4_P2_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_4_P2_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_4_P2_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_4_P2_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_4_P3_TRAM_COL                               13:12

// TRAM column format format
#define LWE297_SU_INST_4_P3_TRAM_FMT                               15:14
#define LWE297_SU_INST_4_P3_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_4_P3_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_4_P3_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_4_P3_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_4_P0_TRI_SHADE_MODE                         16:16
#define LWE297_SU_INST_4_P0_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_4_P0_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_4_P1_TRI_SHADE_MODE                         17:17
#define LWE297_SU_INST_4_P1_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_4_P1_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_4_P2_TRI_SHADE_MODE                         18:18
#define LWE297_SU_INST_4_P2_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_4_P2_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_4_P3_TRI_SHADE_MODE                         19:19
#define LWE297_SU_INST_4_P3_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_4_P3_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_5  
#define LWE297_SU_INST_5                            0x305
// source of attribute for TRAM
#define LWE297_SU_INST_5_SRC                               1:0
#define LWE297_SU_INST_5_SRC_VPE                  0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_5_SRC_Z                    0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_5_VC_ROW                            6:3

// TRAM destination row
#define LWE297_SU_INST_5_TRAM_ROW                          14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_5_P0_LINE_WIDTH                             16:16
#define LWE297_SU_INST_5_P0_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_5_P0_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_5_P0_LINE_LENGTH                            17:17
#define LWE297_SU_INST_5_P0_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_5_P0_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_5_P0_POINT                          19:18
#define LWE297_SU_INST_5_P0_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_5_P0_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_5_P0_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_5_P1_LINE_WIDTH                             20:20
#define LWE297_SU_INST_5_P1_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_5_P1_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_5_P1_LINE_LENGTH                            21:21
#define LWE297_SU_INST_5_P1_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_5_P1_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_5_P1_POINT                          23:22
#define LWE297_SU_INST_5_P1_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_5_P1_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_5_P1_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_5_P2_LINE_WIDTH                             24:24
#define LWE297_SU_INST_5_P2_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_5_P2_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_5_P2_LINE_LENGTH                            25:25
#define LWE297_SU_INST_5_P2_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_5_P2_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_5_P2_POINT                          27:26
#define LWE297_SU_INST_5_P2_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_5_P2_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_5_P2_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_5_P3_LINE_WIDTH                             28:28
#define LWE297_SU_INST_5_P3_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_5_P3_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_5_P3_LINE_LENGTH                            29:29
#define LWE297_SU_INST_5_P3_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_5_P3_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_5_P3_POINT                          31:30
#define LWE297_SU_INST_5_P3_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_5_P3_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_5_P3_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_5_P0_TRAM_COL                               1:0

// TRAM column format
#define LWE297_SU_INST_5_P0_TRAM_FMT                               3:2
#define LWE297_SU_INST_5_P0_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_5_P0_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_5_P0_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_5_P0_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_5_P1_TRAM_COL                               5:4

// TRAM column format
#define LWE297_SU_INST_5_P1_TRAM_FMT                               7:6
#define LWE297_SU_INST_5_P1_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_5_P1_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_5_P1_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_5_P1_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_5_P2_TRAM_COL                               9:8

// TRAM column format
#define LWE297_SU_INST_5_P2_TRAM_FMT                               11:10
#define LWE297_SU_INST_5_P2_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_5_P2_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_5_P2_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_5_P2_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_5_P3_TRAM_COL                               13:12

// TRAM column format format
#define LWE297_SU_INST_5_P3_TRAM_FMT                               15:14
#define LWE297_SU_INST_5_P3_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_5_P3_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_5_P3_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_5_P3_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_5_P0_TRI_SHADE_MODE                         16:16
#define LWE297_SU_INST_5_P0_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_5_P0_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_5_P1_TRI_SHADE_MODE                         17:17
#define LWE297_SU_INST_5_P1_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_5_P1_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_5_P2_TRI_SHADE_MODE                         18:18
#define LWE297_SU_INST_5_P2_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_5_P2_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_5_P3_TRI_SHADE_MODE                         19:19
#define LWE297_SU_INST_5_P3_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_5_P3_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_6  
#define LWE297_SU_INST_6                            0x306
// source of attribute for TRAM
#define LWE297_SU_INST_6_SRC                               1:0
#define LWE297_SU_INST_6_SRC_VPE                  0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_6_SRC_Z                    0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_6_VC_ROW                            6:3

// TRAM destination row
#define LWE297_SU_INST_6_TRAM_ROW                          14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_6_P0_LINE_WIDTH                             16:16
#define LWE297_SU_INST_6_P0_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_6_P0_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_6_P0_LINE_LENGTH                            17:17
#define LWE297_SU_INST_6_P0_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_6_P0_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_6_P0_POINT                          19:18
#define LWE297_SU_INST_6_P0_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_6_P0_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_6_P0_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_6_P1_LINE_WIDTH                             20:20
#define LWE297_SU_INST_6_P1_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_6_P1_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_6_P1_LINE_LENGTH                            21:21
#define LWE297_SU_INST_6_P1_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_6_P1_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_6_P1_POINT                          23:22
#define LWE297_SU_INST_6_P1_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_6_P1_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_6_P1_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_6_P2_LINE_WIDTH                             24:24
#define LWE297_SU_INST_6_P2_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_6_P2_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_6_P2_LINE_LENGTH                            25:25
#define LWE297_SU_INST_6_P2_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_6_P2_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_6_P2_POINT                          27:26
#define LWE297_SU_INST_6_P2_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_6_P2_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_6_P2_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_6_P3_LINE_WIDTH                             28:28
#define LWE297_SU_INST_6_P3_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_6_P3_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_6_P3_LINE_LENGTH                            29:29
#define LWE297_SU_INST_6_P3_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_6_P3_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_6_P3_POINT                          31:30
#define LWE297_SU_INST_6_P3_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_6_P3_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_6_P3_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_6_P0_TRAM_COL                               1:0

// TRAM column format
#define LWE297_SU_INST_6_P0_TRAM_FMT                               3:2
#define LWE297_SU_INST_6_P0_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_6_P0_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_6_P0_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_6_P0_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_6_P1_TRAM_COL                               5:4

// TRAM column format
#define LWE297_SU_INST_6_P1_TRAM_FMT                               7:6
#define LWE297_SU_INST_6_P1_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_6_P1_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_6_P1_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_6_P1_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_6_P2_TRAM_COL                               9:8

// TRAM column format
#define LWE297_SU_INST_6_P2_TRAM_FMT                               11:10
#define LWE297_SU_INST_6_P2_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_6_P2_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_6_P2_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_6_P2_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_6_P3_TRAM_COL                               13:12

// TRAM column format format
#define LWE297_SU_INST_6_P3_TRAM_FMT                               15:14
#define LWE297_SU_INST_6_P3_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_6_P3_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_6_P3_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_6_P3_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_6_P0_TRI_SHADE_MODE                         16:16
#define LWE297_SU_INST_6_P0_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_6_P0_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_6_P1_TRI_SHADE_MODE                         17:17
#define LWE297_SU_INST_6_P1_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_6_P1_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_6_P2_TRI_SHADE_MODE                         18:18
#define LWE297_SU_INST_6_P2_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_6_P2_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_6_P3_TRI_SHADE_MODE                         19:19
#define LWE297_SU_INST_6_P3_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_6_P3_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_7  
#define LWE297_SU_INST_7                            0x307
// source of attribute for TRAM
#define LWE297_SU_INST_7_SRC                               1:0
#define LWE297_SU_INST_7_SRC_VPE                  0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_7_SRC_Z                    0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_7_VC_ROW                            6:3

// TRAM destination row
#define LWE297_SU_INST_7_TRAM_ROW                          14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_7_P0_LINE_WIDTH                             16:16
#define LWE297_SU_INST_7_P0_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_7_P0_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_7_P0_LINE_LENGTH                            17:17
#define LWE297_SU_INST_7_P0_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_7_P0_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_7_P0_POINT                          19:18
#define LWE297_SU_INST_7_P0_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_7_P0_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_7_P0_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_7_P1_LINE_WIDTH                             20:20
#define LWE297_SU_INST_7_P1_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_7_P1_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_7_P1_LINE_LENGTH                            21:21
#define LWE297_SU_INST_7_P1_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_7_P1_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_7_P1_POINT                          23:22
#define LWE297_SU_INST_7_P1_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_7_P1_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_7_P1_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_7_P2_LINE_WIDTH                             24:24
#define LWE297_SU_INST_7_P2_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_7_P2_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_7_P2_LINE_LENGTH                            25:25
#define LWE297_SU_INST_7_P2_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_7_P2_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_7_P2_POINT                          27:26
#define LWE297_SU_INST_7_P2_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_7_P2_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_7_P2_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_7_P3_LINE_WIDTH                             28:28
#define LWE297_SU_INST_7_P3_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_7_P3_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_7_P3_LINE_LENGTH                            29:29
#define LWE297_SU_INST_7_P3_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_7_P3_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_7_P3_POINT                          31:30
#define LWE297_SU_INST_7_P3_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_7_P3_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_7_P3_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_7_P0_TRAM_COL                               1:0

// TRAM column format
#define LWE297_SU_INST_7_P0_TRAM_FMT                               3:2
#define LWE297_SU_INST_7_P0_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_7_P0_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_7_P0_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_7_P0_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_7_P1_TRAM_COL                               5:4

// TRAM column format
#define LWE297_SU_INST_7_P1_TRAM_FMT                               7:6
#define LWE297_SU_INST_7_P1_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_7_P1_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_7_P1_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_7_P1_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_7_P2_TRAM_COL                               9:8

// TRAM column format
#define LWE297_SU_INST_7_P2_TRAM_FMT                               11:10
#define LWE297_SU_INST_7_P2_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_7_P2_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_7_P2_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_7_P2_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_7_P3_TRAM_COL                               13:12

// TRAM column format format
#define LWE297_SU_INST_7_P3_TRAM_FMT                               15:14
#define LWE297_SU_INST_7_P3_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_7_P3_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_7_P3_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_7_P3_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_7_P0_TRI_SHADE_MODE                         16:16
#define LWE297_SU_INST_7_P0_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_7_P0_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_7_P1_TRI_SHADE_MODE                         17:17
#define LWE297_SU_INST_7_P1_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_7_P1_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_7_P2_TRI_SHADE_MODE                         18:18
#define LWE297_SU_INST_7_P2_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_7_P2_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_7_P3_TRI_SHADE_MODE                         19:19
#define LWE297_SU_INST_7_P3_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_7_P3_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_8  
#define LWE297_SU_INST_8                            0x308
// source of attribute for TRAM
#define LWE297_SU_INST_8_SRC                               1:0
#define LWE297_SU_INST_8_SRC_VPE                  0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_8_SRC_Z                    0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_8_VC_ROW                            6:3

// TRAM destination row
#define LWE297_SU_INST_8_TRAM_ROW                          14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_8_P0_LINE_WIDTH                             16:16
#define LWE297_SU_INST_8_P0_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_8_P0_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_8_P0_LINE_LENGTH                            17:17
#define LWE297_SU_INST_8_P0_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_8_P0_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_8_P0_POINT                          19:18
#define LWE297_SU_INST_8_P0_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_8_P0_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_8_P0_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_8_P1_LINE_WIDTH                             20:20
#define LWE297_SU_INST_8_P1_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_8_P1_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_8_P1_LINE_LENGTH                            21:21
#define LWE297_SU_INST_8_P1_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_8_P1_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_8_P1_POINT                          23:22
#define LWE297_SU_INST_8_P1_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_8_P1_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_8_P1_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_8_P2_LINE_WIDTH                             24:24
#define LWE297_SU_INST_8_P2_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_8_P2_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_8_P2_LINE_LENGTH                            25:25
#define LWE297_SU_INST_8_P2_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_8_P2_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_8_P2_POINT                          27:26
#define LWE297_SU_INST_8_P2_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_8_P2_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_8_P2_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_8_P3_LINE_WIDTH                             28:28
#define LWE297_SU_INST_8_P3_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_8_P3_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_8_P3_LINE_LENGTH                            29:29
#define LWE297_SU_INST_8_P3_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_8_P3_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_8_P3_POINT                          31:30
#define LWE297_SU_INST_8_P3_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_8_P3_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_8_P3_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_8_P0_TRAM_COL                               1:0

// TRAM column format
#define LWE297_SU_INST_8_P0_TRAM_FMT                               3:2
#define LWE297_SU_INST_8_P0_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_8_P0_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_8_P0_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_8_P0_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_8_P1_TRAM_COL                               5:4

// TRAM column format
#define LWE297_SU_INST_8_P1_TRAM_FMT                               7:6
#define LWE297_SU_INST_8_P1_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_8_P1_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_8_P1_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_8_P1_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_8_P2_TRAM_COL                               9:8

// TRAM column format
#define LWE297_SU_INST_8_P2_TRAM_FMT                               11:10
#define LWE297_SU_INST_8_P2_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_8_P2_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_8_P2_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_8_P2_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_8_P3_TRAM_COL                               13:12

// TRAM column format format
#define LWE297_SU_INST_8_P3_TRAM_FMT                               15:14
#define LWE297_SU_INST_8_P3_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_8_P3_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_8_P3_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_8_P3_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_8_P0_TRI_SHADE_MODE                         16:16
#define LWE297_SU_INST_8_P0_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_8_P0_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_8_P1_TRI_SHADE_MODE                         17:17
#define LWE297_SU_INST_8_P1_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_8_P1_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_8_P2_TRI_SHADE_MODE                         18:18
#define LWE297_SU_INST_8_P2_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_8_P2_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_8_P3_TRI_SHADE_MODE                         19:19
#define LWE297_SU_INST_8_P3_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_8_P3_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_9  
#define LWE297_SU_INST_9                            0x309
// source of attribute for TRAM
#define LWE297_SU_INST_9_SRC                               1:0
#define LWE297_SU_INST_9_SRC_VPE                  0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_9_SRC_Z                    0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_9_VC_ROW                            6:3

// TRAM destination row
#define LWE297_SU_INST_9_TRAM_ROW                          14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_9_P0_LINE_WIDTH                             16:16
#define LWE297_SU_INST_9_P0_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_9_P0_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_9_P0_LINE_LENGTH                            17:17
#define LWE297_SU_INST_9_P0_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_9_P0_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_9_P0_POINT                          19:18
#define LWE297_SU_INST_9_P0_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_9_P0_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_9_P0_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_9_P1_LINE_WIDTH                             20:20
#define LWE297_SU_INST_9_P1_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_9_P1_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_9_P1_LINE_LENGTH                            21:21
#define LWE297_SU_INST_9_P1_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_9_P1_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_9_P1_POINT                          23:22
#define LWE297_SU_INST_9_P1_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_9_P1_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_9_P1_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_9_P2_LINE_WIDTH                             24:24
#define LWE297_SU_INST_9_P2_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_9_P2_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_9_P2_LINE_LENGTH                            25:25
#define LWE297_SU_INST_9_P2_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_9_P2_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_9_P2_POINT                          27:26
#define LWE297_SU_INST_9_P2_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_9_P2_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_9_P2_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_9_P3_LINE_WIDTH                             28:28
#define LWE297_SU_INST_9_P3_LINE_WIDTH_CONST                      0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_9_P3_LINE_WIDTH_VARYING                    0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_9_P3_LINE_LENGTH                            29:29
#define LWE297_SU_INST_9_P3_LINE_LENGTH_VARYING                   0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_9_P3_LINE_LENGTH_CONST                     0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_9_P3_POINT                          31:30
#define LWE297_SU_INST_9_P3_POINT_DISABLE                 0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_9_P3_POINT_S                       0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_9_P3_POINT_T                       0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_9_P0_TRAM_COL                               1:0

// TRAM column format
#define LWE297_SU_INST_9_P0_TRAM_FMT                               3:2
#define LWE297_SU_INST_9_P0_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_9_P0_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_9_P0_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_9_P0_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_9_P1_TRAM_COL                               5:4

// TRAM column format
#define LWE297_SU_INST_9_P1_TRAM_FMT                               7:6
#define LWE297_SU_INST_9_P1_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_9_P1_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_9_P1_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_9_P1_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_9_P2_TRAM_COL                               9:8

// TRAM column format
#define LWE297_SU_INST_9_P2_TRAM_FMT                               11:10
#define LWE297_SU_INST_9_P2_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_9_P2_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_9_P2_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_9_P2_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_9_P3_TRAM_COL                               13:12

// TRAM column format format
#define LWE297_SU_INST_9_P3_TRAM_FMT                               15:14
#define LWE297_SU_INST_9_P3_TRAM_FMT_NOP                  0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_9_P3_TRAM_FMT_LP_LO                        0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_9_P3_TRAM_FMT_LP_HI                        0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_9_P3_TRAM_FMT_HP                   0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_9_P0_TRI_SHADE_MODE                         16:16
#define LWE297_SU_INST_9_P0_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_9_P0_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_9_P1_TRI_SHADE_MODE                         17:17
#define LWE297_SU_INST_9_P1_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_9_P1_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_9_P2_TRI_SHADE_MODE                         18:18
#define LWE297_SU_INST_9_P2_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_9_P2_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_9_P3_TRI_SHADE_MODE                         19:19
#define LWE297_SU_INST_9_P3_TRI_SHADE_MODE_SMOOTH                 0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_9_P3_TRI_SHADE_MODE_FLAT                   0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_10  
#define LWE297_SU_INST_10                           0x30a
// source of attribute for TRAM
#define LWE297_SU_INST_10_SRC                              1:0
#define LWE297_SU_INST_10_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_10_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_10_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_10_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_10_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_10_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_10_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_10_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_10_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_10_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_10_P0_POINT                         19:18
#define LWE297_SU_INST_10_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_10_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_10_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_10_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_10_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_10_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_10_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_10_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_10_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_10_P1_POINT                         23:22
#define LWE297_SU_INST_10_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_10_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_10_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_10_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_10_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_10_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_10_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_10_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_10_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_10_P2_POINT                         27:26
#define LWE297_SU_INST_10_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_10_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_10_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_10_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_10_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_10_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_10_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_10_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_10_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_10_P3_POINT                         31:30
#define LWE297_SU_INST_10_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_10_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_10_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_10_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_10_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_10_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_10_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_10_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_10_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_10_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_10_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_10_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_10_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_10_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_10_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_10_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_10_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_10_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_10_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_10_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_10_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_10_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_10_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_10_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_10_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_10_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_10_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_10_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_10_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_10_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_10_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_10_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_10_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_10_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_10_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_10_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_10_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_10_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_10_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_11  
#define LWE297_SU_INST_11                           0x30b
// source of attribute for TRAM
#define LWE297_SU_INST_11_SRC                              1:0
#define LWE297_SU_INST_11_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_11_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_11_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_11_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_11_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_11_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_11_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_11_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_11_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_11_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_11_P0_POINT                         19:18
#define LWE297_SU_INST_11_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_11_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_11_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_11_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_11_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_11_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_11_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_11_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_11_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_11_P1_POINT                         23:22
#define LWE297_SU_INST_11_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_11_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_11_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_11_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_11_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_11_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_11_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_11_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_11_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_11_P2_POINT                         27:26
#define LWE297_SU_INST_11_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_11_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_11_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_11_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_11_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_11_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_11_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_11_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_11_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_11_P3_POINT                         31:30
#define LWE297_SU_INST_11_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_11_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_11_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_11_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_11_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_11_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_11_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_11_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_11_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_11_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_11_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_11_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_11_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_11_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_11_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_11_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_11_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_11_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_11_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_11_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_11_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_11_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_11_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_11_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_11_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_11_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_11_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_11_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_11_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_11_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_11_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_11_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_11_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_11_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_11_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_11_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_11_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_11_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_11_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_12  
#define LWE297_SU_INST_12                           0x30c
// source of attribute for TRAM
#define LWE297_SU_INST_12_SRC                              1:0
#define LWE297_SU_INST_12_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_12_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_12_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_12_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_12_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_12_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_12_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_12_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_12_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_12_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_12_P0_POINT                         19:18
#define LWE297_SU_INST_12_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_12_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_12_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_12_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_12_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_12_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_12_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_12_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_12_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_12_P1_POINT                         23:22
#define LWE297_SU_INST_12_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_12_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_12_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_12_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_12_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_12_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_12_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_12_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_12_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_12_P2_POINT                         27:26
#define LWE297_SU_INST_12_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_12_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_12_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_12_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_12_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_12_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_12_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_12_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_12_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_12_P3_POINT                         31:30
#define LWE297_SU_INST_12_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_12_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_12_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_12_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_12_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_12_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_12_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_12_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_12_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_12_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_12_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_12_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_12_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_12_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_12_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_12_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_12_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_12_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_12_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_12_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_12_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_12_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_12_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_12_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_12_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_12_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_12_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_12_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_12_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_12_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_12_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_12_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_12_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_12_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_12_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_12_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_12_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_12_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_12_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_13  
#define LWE297_SU_INST_13                           0x30d
// source of attribute for TRAM
#define LWE297_SU_INST_13_SRC                              1:0
#define LWE297_SU_INST_13_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_13_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_13_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_13_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_13_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_13_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_13_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_13_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_13_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_13_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_13_P0_POINT                         19:18
#define LWE297_SU_INST_13_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_13_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_13_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_13_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_13_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_13_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_13_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_13_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_13_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_13_P1_POINT                         23:22
#define LWE297_SU_INST_13_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_13_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_13_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_13_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_13_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_13_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_13_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_13_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_13_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_13_P2_POINT                         27:26
#define LWE297_SU_INST_13_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_13_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_13_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_13_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_13_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_13_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_13_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_13_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_13_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_13_P3_POINT                         31:30
#define LWE297_SU_INST_13_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_13_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_13_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_13_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_13_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_13_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_13_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_13_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_13_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_13_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_13_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_13_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_13_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_13_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_13_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_13_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_13_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_13_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_13_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_13_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_13_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_13_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_13_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_13_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_13_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_13_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_13_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_13_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_13_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_13_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_13_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_13_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_13_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_13_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_13_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_13_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_13_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_13_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_13_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_14  
#define LWE297_SU_INST_14                           0x30e
// source of attribute for TRAM
#define LWE297_SU_INST_14_SRC                              1:0
#define LWE297_SU_INST_14_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_14_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_14_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_14_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_14_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_14_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_14_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_14_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_14_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_14_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_14_P0_POINT                         19:18
#define LWE297_SU_INST_14_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_14_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_14_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_14_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_14_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_14_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_14_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_14_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_14_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_14_P1_POINT                         23:22
#define LWE297_SU_INST_14_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_14_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_14_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_14_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_14_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_14_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_14_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_14_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_14_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_14_P2_POINT                         27:26
#define LWE297_SU_INST_14_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_14_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_14_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_14_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_14_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_14_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_14_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_14_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_14_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_14_P3_POINT                         31:30
#define LWE297_SU_INST_14_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_14_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_14_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_14_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_14_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_14_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_14_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_14_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_14_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_14_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_14_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_14_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_14_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_14_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_14_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_14_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_14_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_14_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_14_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_14_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_14_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_14_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_14_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_14_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_14_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_14_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_14_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_14_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_14_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_14_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_14_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_14_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_14_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_14_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_14_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_14_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_14_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_14_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_14_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_15  
#define LWE297_SU_INST_15                           0x30f
// source of attribute for TRAM
#define LWE297_SU_INST_15_SRC                              1:0
#define LWE297_SU_INST_15_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_15_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_15_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_15_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_15_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_15_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_15_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_15_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_15_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_15_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_15_P0_POINT                         19:18
#define LWE297_SU_INST_15_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_15_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_15_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_15_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_15_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_15_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_15_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_15_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_15_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_15_P1_POINT                         23:22
#define LWE297_SU_INST_15_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_15_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_15_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_15_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_15_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_15_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_15_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_15_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_15_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_15_P2_POINT                         27:26
#define LWE297_SU_INST_15_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_15_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_15_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_15_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_15_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_15_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_15_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_15_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_15_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_15_P3_POINT                         31:30
#define LWE297_SU_INST_15_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_15_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_15_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_15_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_15_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_15_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_15_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_15_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_15_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_15_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_15_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_15_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_15_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_15_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_15_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_15_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_15_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_15_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_15_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_15_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_15_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_15_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_15_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_15_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_15_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_15_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_15_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_15_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_15_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_15_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_15_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_15_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_15_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_15_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_15_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_15_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_15_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_15_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_15_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_16  
#define LWE297_SU_INST_16                           0x310
// source of attribute for TRAM
#define LWE297_SU_INST_16_SRC                              1:0
#define LWE297_SU_INST_16_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_16_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_16_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_16_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_16_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_16_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_16_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_16_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_16_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_16_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_16_P0_POINT                         19:18
#define LWE297_SU_INST_16_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_16_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_16_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_16_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_16_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_16_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_16_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_16_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_16_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_16_P1_POINT                         23:22
#define LWE297_SU_INST_16_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_16_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_16_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_16_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_16_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_16_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_16_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_16_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_16_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_16_P2_POINT                         27:26
#define LWE297_SU_INST_16_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_16_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_16_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_16_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_16_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_16_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_16_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_16_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_16_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_16_P3_POINT                         31:30
#define LWE297_SU_INST_16_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_16_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_16_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_16_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_16_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_16_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_16_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_16_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_16_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_16_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_16_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_16_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_16_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_16_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_16_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_16_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_16_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_16_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_16_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_16_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_16_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_16_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_16_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_16_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_16_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_16_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_16_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_16_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_16_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_16_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_16_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_16_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_16_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_16_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_16_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_16_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_16_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_16_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_16_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_17  
#define LWE297_SU_INST_17                           0x311
// source of attribute for TRAM
#define LWE297_SU_INST_17_SRC                              1:0
#define LWE297_SU_INST_17_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_17_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_17_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_17_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_17_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_17_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_17_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_17_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_17_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_17_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_17_P0_POINT                         19:18
#define LWE297_SU_INST_17_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_17_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_17_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_17_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_17_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_17_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_17_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_17_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_17_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_17_P1_POINT                         23:22
#define LWE297_SU_INST_17_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_17_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_17_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_17_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_17_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_17_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_17_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_17_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_17_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_17_P2_POINT                         27:26
#define LWE297_SU_INST_17_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_17_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_17_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_17_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_17_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_17_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_17_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_17_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_17_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_17_P3_POINT                         31:30
#define LWE297_SU_INST_17_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_17_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_17_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_17_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_17_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_17_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_17_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_17_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_17_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_17_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_17_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_17_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_17_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_17_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_17_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_17_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_17_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_17_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_17_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_17_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_17_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_17_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_17_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_17_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_17_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_17_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_17_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_17_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_17_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_17_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_17_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_17_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_17_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_17_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_17_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_17_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_17_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_17_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_17_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_18  
#define LWE297_SU_INST_18                           0x312
// source of attribute for TRAM
#define LWE297_SU_INST_18_SRC                              1:0
#define LWE297_SU_INST_18_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_18_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_18_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_18_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_18_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_18_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_18_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_18_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_18_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_18_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_18_P0_POINT                         19:18
#define LWE297_SU_INST_18_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_18_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_18_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_18_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_18_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_18_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_18_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_18_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_18_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_18_P1_POINT                         23:22
#define LWE297_SU_INST_18_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_18_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_18_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_18_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_18_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_18_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_18_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_18_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_18_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_18_P2_POINT                         27:26
#define LWE297_SU_INST_18_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_18_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_18_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_18_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_18_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_18_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_18_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_18_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_18_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_18_P3_POINT                         31:30
#define LWE297_SU_INST_18_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_18_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_18_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_18_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_18_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_18_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_18_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_18_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_18_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_18_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_18_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_18_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_18_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_18_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_18_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_18_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_18_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_18_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_18_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_18_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_18_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_18_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_18_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_18_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_18_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_18_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_18_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_18_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_18_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_18_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_18_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_18_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_18_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_18_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_18_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_18_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_18_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_18_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_18_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_19  
#define LWE297_SU_INST_19                           0x313
// source of attribute for TRAM
#define LWE297_SU_INST_19_SRC                              1:0
#define LWE297_SU_INST_19_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_19_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_19_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_19_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_19_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_19_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_19_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_19_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_19_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_19_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_19_P0_POINT                         19:18
#define LWE297_SU_INST_19_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_19_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_19_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_19_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_19_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_19_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_19_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_19_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_19_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_19_P1_POINT                         23:22
#define LWE297_SU_INST_19_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_19_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_19_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_19_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_19_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_19_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_19_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_19_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_19_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_19_P2_POINT                         27:26
#define LWE297_SU_INST_19_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_19_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_19_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_19_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_19_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_19_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_19_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_19_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_19_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_19_P3_POINT                         31:30
#define LWE297_SU_INST_19_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_19_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_19_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_19_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_19_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_19_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_19_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_19_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_19_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_19_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_19_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_19_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_19_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_19_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_19_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_19_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_19_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_19_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_19_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_19_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_19_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_19_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_19_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_19_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_19_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_19_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_19_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_19_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_19_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_19_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_19_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_19_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_19_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_19_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_19_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_19_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_19_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_19_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_19_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_20  
#define LWE297_SU_INST_20                           0x314
// source of attribute for TRAM
#define LWE297_SU_INST_20_SRC                              1:0
#define LWE297_SU_INST_20_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_20_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_20_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_20_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_20_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_20_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_20_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_20_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_20_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_20_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_20_P0_POINT                         19:18
#define LWE297_SU_INST_20_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_20_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_20_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_20_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_20_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_20_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_20_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_20_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_20_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_20_P1_POINT                         23:22
#define LWE297_SU_INST_20_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_20_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_20_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_20_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_20_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_20_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_20_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_20_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_20_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_20_P2_POINT                         27:26
#define LWE297_SU_INST_20_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_20_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_20_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_20_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_20_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_20_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_20_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_20_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_20_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_20_P3_POINT                         31:30
#define LWE297_SU_INST_20_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_20_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_20_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_20_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_20_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_20_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_20_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_20_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_20_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_20_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_20_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_20_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_20_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_20_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_20_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_20_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_20_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_20_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_20_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_20_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_20_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_20_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_20_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_20_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_20_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_20_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_20_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_20_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_20_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_20_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_20_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_20_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_20_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_20_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_20_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_20_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_20_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_20_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_20_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_21  
#define LWE297_SU_INST_21                           0x315
// source of attribute for TRAM
#define LWE297_SU_INST_21_SRC                              1:0
#define LWE297_SU_INST_21_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_21_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_21_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_21_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_21_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_21_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_21_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_21_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_21_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_21_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_21_P0_POINT                         19:18
#define LWE297_SU_INST_21_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_21_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_21_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_21_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_21_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_21_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_21_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_21_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_21_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_21_P1_POINT                         23:22
#define LWE297_SU_INST_21_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_21_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_21_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_21_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_21_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_21_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_21_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_21_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_21_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_21_P2_POINT                         27:26
#define LWE297_SU_INST_21_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_21_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_21_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_21_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_21_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_21_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_21_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_21_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_21_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_21_P3_POINT                         31:30
#define LWE297_SU_INST_21_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_21_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_21_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_21_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_21_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_21_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_21_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_21_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_21_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_21_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_21_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_21_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_21_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_21_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_21_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_21_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_21_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_21_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_21_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_21_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_21_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_21_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_21_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_21_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_21_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_21_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_21_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_21_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_21_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_21_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_21_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_21_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_21_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_21_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_21_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_21_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_21_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_21_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_21_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_22  
#define LWE297_SU_INST_22                           0x316
// source of attribute for TRAM
#define LWE297_SU_INST_22_SRC                              1:0
#define LWE297_SU_INST_22_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_22_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_22_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_22_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_22_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_22_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_22_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_22_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_22_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_22_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_22_P0_POINT                         19:18
#define LWE297_SU_INST_22_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_22_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_22_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_22_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_22_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_22_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_22_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_22_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_22_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_22_P1_POINT                         23:22
#define LWE297_SU_INST_22_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_22_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_22_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_22_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_22_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_22_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_22_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_22_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_22_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_22_P2_POINT                         27:26
#define LWE297_SU_INST_22_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_22_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_22_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_22_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_22_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_22_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_22_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_22_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_22_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_22_P3_POINT                         31:30
#define LWE297_SU_INST_22_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_22_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_22_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_22_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_22_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_22_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_22_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_22_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_22_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_22_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_22_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_22_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_22_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_22_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_22_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_22_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_22_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_22_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_22_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_22_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_22_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_22_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_22_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_22_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_22_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_22_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_22_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_22_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_22_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_22_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_22_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_22_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_22_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_22_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_22_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_22_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_22_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_22_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_22_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_23  
#define LWE297_SU_INST_23                           0x317
// source of attribute for TRAM
#define LWE297_SU_INST_23_SRC                              1:0
#define LWE297_SU_INST_23_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_23_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_23_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_23_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_23_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_23_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_23_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_23_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_23_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_23_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_23_P0_POINT                         19:18
#define LWE297_SU_INST_23_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_23_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_23_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_23_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_23_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_23_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_23_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_23_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_23_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_23_P1_POINT                         23:22
#define LWE297_SU_INST_23_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_23_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_23_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_23_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_23_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_23_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_23_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_23_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_23_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_23_P2_POINT                         27:26
#define LWE297_SU_INST_23_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_23_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_23_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_23_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_23_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_23_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_23_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_23_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_23_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_23_P3_POINT                         31:30
#define LWE297_SU_INST_23_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_23_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_23_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_23_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_23_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_23_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_23_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_23_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_23_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_23_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_23_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_23_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_23_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_23_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_23_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_23_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_23_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_23_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_23_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_23_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_23_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_23_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_23_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_23_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_23_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_23_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_23_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_23_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_23_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_23_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_23_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_23_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_23_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_23_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_23_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_23_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_23_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_23_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_23_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_24  
#define LWE297_SU_INST_24                           0x318
// source of attribute for TRAM
#define LWE297_SU_INST_24_SRC                              1:0
#define LWE297_SU_INST_24_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_24_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_24_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_24_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_24_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_24_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_24_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_24_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_24_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_24_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_24_P0_POINT                         19:18
#define LWE297_SU_INST_24_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_24_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_24_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_24_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_24_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_24_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_24_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_24_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_24_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_24_P1_POINT                         23:22
#define LWE297_SU_INST_24_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_24_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_24_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_24_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_24_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_24_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_24_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_24_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_24_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_24_P2_POINT                         27:26
#define LWE297_SU_INST_24_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_24_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_24_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_24_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_24_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_24_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_24_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_24_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_24_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_24_P3_POINT                         31:30
#define LWE297_SU_INST_24_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_24_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_24_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_24_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_24_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_24_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_24_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_24_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_24_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_24_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_24_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_24_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_24_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_24_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_24_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_24_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_24_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_24_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_24_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_24_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_24_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_24_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_24_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_24_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_24_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_24_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_24_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_24_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_24_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_24_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_24_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_24_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_24_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_24_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_24_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_24_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_24_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_24_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_24_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_25  
#define LWE297_SU_INST_25                           0x319
// source of attribute for TRAM
#define LWE297_SU_INST_25_SRC                              1:0
#define LWE297_SU_INST_25_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_25_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_25_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_25_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_25_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_25_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_25_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_25_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_25_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_25_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_25_P0_POINT                         19:18
#define LWE297_SU_INST_25_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_25_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_25_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_25_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_25_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_25_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_25_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_25_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_25_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_25_P1_POINT                         23:22
#define LWE297_SU_INST_25_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_25_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_25_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_25_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_25_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_25_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_25_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_25_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_25_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_25_P2_POINT                         27:26
#define LWE297_SU_INST_25_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_25_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_25_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_25_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_25_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_25_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_25_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_25_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_25_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_25_P3_POINT                         31:30
#define LWE297_SU_INST_25_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_25_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_25_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_25_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_25_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_25_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_25_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_25_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_25_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_25_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_25_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_25_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_25_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_25_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_25_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_25_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_25_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_25_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_25_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_25_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_25_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_25_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_25_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_25_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_25_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_25_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_25_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_25_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_25_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_25_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_25_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_25_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_25_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_25_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_25_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_25_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_25_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_25_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_25_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_26  
#define LWE297_SU_INST_26                           0x31a
// source of attribute for TRAM
#define LWE297_SU_INST_26_SRC                              1:0
#define LWE297_SU_INST_26_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_26_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_26_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_26_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_26_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_26_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_26_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_26_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_26_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_26_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_26_P0_POINT                         19:18
#define LWE297_SU_INST_26_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_26_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_26_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_26_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_26_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_26_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_26_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_26_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_26_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_26_P1_POINT                         23:22
#define LWE297_SU_INST_26_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_26_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_26_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_26_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_26_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_26_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_26_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_26_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_26_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_26_P2_POINT                         27:26
#define LWE297_SU_INST_26_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_26_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_26_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_26_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_26_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_26_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_26_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_26_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_26_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_26_P3_POINT                         31:30
#define LWE297_SU_INST_26_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_26_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_26_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_26_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_26_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_26_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_26_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_26_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_26_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_26_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_26_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_26_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_26_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_26_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_26_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_26_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_26_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_26_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_26_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_26_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_26_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_26_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_26_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_26_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_26_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_26_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_26_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_26_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_26_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_26_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_26_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_26_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_26_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_26_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_26_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_26_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_26_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_26_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_26_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_27  
#define LWE297_SU_INST_27                           0x31b
// source of attribute for TRAM
#define LWE297_SU_INST_27_SRC                              1:0
#define LWE297_SU_INST_27_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_27_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_27_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_27_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_27_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_27_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_27_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_27_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_27_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_27_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_27_P0_POINT                         19:18
#define LWE297_SU_INST_27_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_27_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_27_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_27_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_27_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_27_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_27_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_27_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_27_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_27_P1_POINT                         23:22
#define LWE297_SU_INST_27_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_27_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_27_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_27_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_27_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_27_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_27_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_27_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_27_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_27_P2_POINT                         27:26
#define LWE297_SU_INST_27_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_27_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_27_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_27_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_27_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_27_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_27_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_27_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_27_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_27_P3_POINT                         31:30
#define LWE297_SU_INST_27_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_27_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_27_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_27_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_27_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_27_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_27_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_27_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_27_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_27_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_27_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_27_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_27_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_27_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_27_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_27_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_27_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_27_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_27_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_27_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_27_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_27_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_27_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_27_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_27_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_27_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_27_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_27_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_27_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_27_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_27_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_27_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_27_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_27_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_27_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_27_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_27_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_27_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_27_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_28  
#define LWE297_SU_INST_28                           0x31c
// source of attribute for TRAM
#define LWE297_SU_INST_28_SRC                              1:0
#define LWE297_SU_INST_28_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_28_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_28_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_28_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_28_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_28_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_28_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_28_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_28_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_28_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_28_P0_POINT                         19:18
#define LWE297_SU_INST_28_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_28_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_28_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_28_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_28_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_28_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_28_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_28_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_28_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_28_P1_POINT                         23:22
#define LWE297_SU_INST_28_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_28_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_28_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_28_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_28_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_28_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_28_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_28_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_28_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_28_P2_POINT                         27:26
#define LWE297_SU_INST_28_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_28_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_28_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_28_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_28_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_28_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_28_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_28_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_28_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_28_P3_POINT                         31:30
#define LWE297_SU_INST_28_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_28_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_28_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_28_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_28_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_28_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_28_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_28_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_28_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_28_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_28_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_28_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_28_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_28_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_28_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_28_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_28_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_28_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_28_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_28_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_28_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_28_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_28_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_28_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_28_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_28_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_28_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_28_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_28_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_28_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_28_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_28_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_28_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_28_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_28_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_28_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_28_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_28_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_28_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_29  
#define LWE297_SU_INST_29                           0x31d
// source of attribute for TRAM
#define LWE297_SU_INST_29_SRC                              1:0
#define LWE297_SU_INST_29_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_29_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_29_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_29_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_29_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_29_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_29_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_29_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_29_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_29_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_29_P0_POINT                         19:18
#define LWE297_SU_INST_29_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_29_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_29_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_29_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_29_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_29_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_29_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_29_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_29_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_29_P1_POINT                         23:22
#define LWE297_SU_INST_29_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_29_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_29_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_29_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_29_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_29_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_29_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_29_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_29_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_29_P2_POINT                         27:26
#define LWE297_SU_INST_29_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_29_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_29_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_29_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_29_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_29_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_29_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_29_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_29_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_29_P3_POINT                         31:30
#define LWE297_SU_INST_29_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_29_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_29_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_29_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_29_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_29_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_29_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_29_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_29_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_29_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_29_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_29_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_29_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_29_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_29_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_29_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_29_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_29_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_29_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_29_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_29_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_29_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_29_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_29_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_29_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_29_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_29_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_29_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_29_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_29_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_29_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_29_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_29_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_29_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_29_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_29_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_29_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_29_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_29_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_30  
#define LWE297_SU_INST_30                           0x31e
// source of attribute for TRAM
#define LWE297_SU_INST_30_SRC                              1:0
#define LWE297_SU_INST_30_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_30_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_30_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_30_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_30_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_30_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_30_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_30_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_30_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_30_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_30_P0_POINT                         19:18
#define LWE297_SU_INST_30_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_30_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_30_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_30_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_30_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_30_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_30_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_30_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_30_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_30_P1_POINT                         23:22
#define LWE297_SU_INST_30_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_30_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_30_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_30_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_30_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_30_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_30_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_30_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_30_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_30_P2_POINT                         27:26
#define LWE297_SU_INST_30_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_30_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_30_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_30_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_30_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_30_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_30_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_30_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_30_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_30_P3_POINT                         31:30
#define LWE297_SU_INST_30_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_30_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_30_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_30_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_30_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_30_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_30_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_30_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_30_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_30_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_30_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_30_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_30_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_30_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_30_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_30_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_30_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_30_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_30_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_30_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_30_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_30_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_30_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_30_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_30_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_30_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_30_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_30_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_30_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_30_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_30_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_30_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_30_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_30_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_30_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_30_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_30_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_30_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_30_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_31  
#define LWE297_SU_INST_31                           0x31f
// source of attribute for TRAM
#define LWE297_SU_INST_31_SRC                              1:0
#define LWE297_SU_INST_31_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_31_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_31_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_31_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_31_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_31_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_31_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_31_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_31_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_31_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_31_P0_POINT                         19:18
#define LWE297_SU_INST_31_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_31_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_31_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_31_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_31_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_31_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_31_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_31_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_31_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_31_P1_POINT                         23:22
#define LWE297_SU_INST_31_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_31_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_31_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_31_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_31_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_31_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_31_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_31_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_31_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_31_P2_POINT                         27:26
#define LWE297_SU_INST_31_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_31_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_31_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_31_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_31_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_31_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_31_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_31_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_31_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_31_P3_POINT                         31:30
#define LWE297_SU_INST_31_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_31_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_31_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_31_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_31_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_31_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_31_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_31_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_31_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_31_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_31_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_31_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_31_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_31_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_31_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_31_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_31_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_31_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_31_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_31_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_31_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_31_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_31_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_31_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_31_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_31_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_31_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_31_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_31_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_31_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_31_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_31_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_31_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_31_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_31_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_31_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_31_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_31_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_31_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_32  
#define LWE297_SU_INST_32                           0x320
// source of attribute for TRAM
#define LWE297_SU_INST_32_SRC                              1:0
#define LWE297_SU_INST_32_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_32_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_32_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_32_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_32_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_32_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_32_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_32_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_32_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_32_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_32_P0_POINT                         19:18
#define LWE297_SU_INST_32_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_32_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_32_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_32_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_32_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_32_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_32_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_32_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_32_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_32_P1_POINT                         23:22
#define LWE297_SU_INST_32_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_32_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_32_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_32_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_32_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_32_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_32_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_32_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_32_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_32_P2_POINT                         27:26
#define LWE297_SU_INST_32_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_32_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_32_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_32_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_32_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_32_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_32_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_32_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_32_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_32_P3_POINT                         31:30
#define LWE297_SU_INST_32_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_32_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_32_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_32_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_32_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_32_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_32_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_32_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_32_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_32_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_32_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_32_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_32_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_32_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_32_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_32_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_32_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_32_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_32_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_32_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_32_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_32_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_32_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_32_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_32_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_32_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_32_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_32_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_32_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_32_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_32_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_32_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_32_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_32_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_32_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_32_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_32_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_32_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_32_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_33  
#define LWE297_SU_INST_33                           0x321
// source of attribute for TRAM
#define LWE297_SU_INST_33_SRC                              1:0
#define LWE297_SU_INST_33_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_33_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_33_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_33_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_33_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_33_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_33_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_33_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_33_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_33_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_33_P0_POINT                         19:18
#define LWE297_SU_INST_33_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_33_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_33_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_33_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_33_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_33_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_33_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_33_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_33_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_33_P1_POINT                         23:22
#define LWE297_SU_INST_33_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_33_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_33_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_33_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_33_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_33_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_33_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_33_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_33_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_33_P2_POINT                         27:26
#define LWE297_SU_INST_33_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_33_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_33_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_33_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_33_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_33_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_33_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_33_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_33_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_33_P3_POINT                         31:30
#define LWE297_SU_INST_33_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_33_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_33_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_33_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_33_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_33_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_33_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_33_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_33_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_33_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_33_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_33_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_33_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_33_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_33_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_33_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_33_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_33_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_33_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_33_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_33_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_33_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_33_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_33_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_33_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_33_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_33_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_33_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_33_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_33_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_33_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_33_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_33_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_33_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_33_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_33_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_33_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_33_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_33_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_34  
#define LWE297_SU_INST_34                           0x322
// source of attribute for TRAM
#define LWE297_SU_INST_34_SRC                              1:0
#define LWE297_SU_INST_34_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_34_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_34_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_34_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_34_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_34_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_34_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_34_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_34_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_34_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_34_P0_POINT                         19:18
#define LWE297_SU_INST_34_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_34_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_34_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_34_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_34_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_34_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_34_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_34_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_34_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_34_P1_POINT                         23:22
#define LWE297_SU_INST_34_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_34_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_34_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_34_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_34_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_34_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_34_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_34_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_34_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_34_P2_POINT                         27:26
#define LWE297_SU_INST_34_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_34_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_34_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_34_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_34_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_34_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_34_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_34_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_34_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_34_P3_POINT                         31:30
#define LWE297_SU_INST_34_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_34_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_34_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_34_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_34_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_34_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_34_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_34_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_34_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_34_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_34_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_34_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_34_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_34_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_34_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_34_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_34_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_34_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_34_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_34_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_34_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_34_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_34_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_34_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_34_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_34_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_34_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_34_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_34_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_34_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_34_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_34_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_34_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_34_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_34_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_34_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_34_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_34_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_34_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_35  
#define LWE297_SU_INST_35                           0x323
// source of attribute for TRAM
#define LWE297_SU_INST_35_SRC                              1:0
#define LWE297_SU_INST_35_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_35_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_35_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_35_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_35_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_35_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_35_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_35_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_35_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_35_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_35_P0_POINT                         19:18
#define LWE297_SU_INST_35_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_35_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_35_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_35_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_35_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_35_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_35_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_35_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_35_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_35_P1_POINT                         23:22
#define LWE297_SU_INST_35_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_35_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_35_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_35_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_35_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_35_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_35_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_35_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_35_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_35_P2_POINT                         27:26
#define LWE297_SU_INST_35_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_35_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_35_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_35_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_35_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_35_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_35_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_35_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_35_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_35_P3_POINT                         31:30
#define LWE297_SU_INST_35_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_35_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_35_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_35_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_35_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_35_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_35_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_35_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_35_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_35_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_35_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_35_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_35_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_35_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_35_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_35_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_35_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_35_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_35_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_35_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_35_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_35_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_35_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_35_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_35_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_35_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_35_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_35_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_35_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_35_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_35_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_35_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_35_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_35_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_35_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_35_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_35_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_35_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_35_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_36  
#define LWE297_SU_INST_36                           0x324
// source of attribute for TRAM
#define LWE297_SU_INST_36_SRC                              1:0
#define LWE297_SU_INST_36_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_36_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_36_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_36_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_36_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_36_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_36_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_36_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_36_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_36_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_36_P0_POINT                         19:18
#define LWE297_SU_INST_36_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_36_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_36_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_36_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_36_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_36_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_36_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_36_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_36_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_36_P1_POINT                         23:22
#define LWE297_SU_INST_36_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_36_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_36_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_36_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_36_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_36_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_36_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_36_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_36_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_36_P2_POINT                         27:26
#define LWE297_SU_INST_36_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_36_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_36_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_36_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_36_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_36_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_36_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_36_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_36_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_36_P3_POINT                         31:30
#define LWE297_SU_INST_36_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_36_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_36_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_36_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_36_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_36_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_36_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_36_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_36_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_36_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_36_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_36_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_36_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_36_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_36_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_36_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_36_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_36_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_36_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_36_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_36_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_36_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_36_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_36_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_36_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_36_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_36_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_36_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_36_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_36_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_36_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_36_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_36_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_36_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_36_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_36_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_36_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_36_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_36_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_37  
#define LWE297_SU_INST_37                           0x325
// source of attribute for TRAM
#define LWE297_SU_INST_37_SRC                              1:0
#define LWE297_SU_INST_37_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_37_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_37_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_37_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_37_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_37_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_37_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_37_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_37_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_37_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_37_P0_POINT                         19:18
#define LWE297_SU_INST_37_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_37_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_37_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_37_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_37_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_37_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_37_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_37_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_37_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_37_P1_POINT                         23:22
#define LWE297_SU_INST_37_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_37_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_37_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_37_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_37_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_37_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_37_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_37_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_37_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_37_P2_POINT                         27:26
#define LWE297_SU_INST_37_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_37_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_37_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_37_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_37_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_37_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_37_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_37_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_37_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_37_P3_POINT                         31:30
#define LWE297_SU_INST_37_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_37_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_37_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_37_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_37_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_37_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_37_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_37_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_37_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_37_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_37_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_37_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_37_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_37_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_37_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_37_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_37_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_37_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_37_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_37_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_37_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_37_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_37_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_37_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_37_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_37_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_37_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_37_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_37_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_37_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_37_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_37_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_37_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_37_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_37_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_37_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_37_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_37_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_37_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_38  
#define LWE297_SU_INST_38                           0x326
// source of attribute for TRAM
#define LWE297_SU_INST_38_SRC                              1:0
#define LWE297_SU_INST_38_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_38_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_38_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_38_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_38_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_38_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_38_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_38_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_38_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_38_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_38_P0_POINT                         19:18
#define LWE297_SU_INST_38_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_38_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_38_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_38_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_38_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_38_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_38_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_38_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_38_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_38_P1_POINT                         23:22
#define LWE297_SU_INST_38_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_38_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_38_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_38_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_38_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_38_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_38_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_38_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_38_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_38_P2_POINT                         27:26
#define LWE297_SU_INST_38_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_38_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_38_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_38_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_38_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_38_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_38_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_38_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_38_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_38_P3_POINT                         31:30
#define LWE297_SU_INST_38_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_38_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_38_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_38_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_38_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_38_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_38_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_38_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_38_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_38_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_38_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_38_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_38_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_38_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_38_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_38_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_38_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_38_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_38_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_38_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_38_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_38_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_38_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_38_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_38_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_38_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_38_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_38_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_38_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_38_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_38_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_38_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_38_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_38_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_38_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_38_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_38_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_38_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_38_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_39  
#define LWE297_SU_INST_39                           0x327
// source of attribute for TRAM
#define LWE297_SU_INST_39_SRC                              1:0
#define LWE297_SU_INST_39_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_39_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_39_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_39_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_39_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_39_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_39_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_39_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_39_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_39_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_39_P0_POINT                         19:18
#define LWE297_SU_INST_39_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_39_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_39_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_39_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_39_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_39_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_39_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_39_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_39_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_39_P1_POINT                         23:22
#define LWE297_SU_INST_39_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_39_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_39_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_39_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_39_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_39_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_39_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_39_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_39_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_39_P2_POINT                         27:26
#define LWE297_SU_INST_39_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_39_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_39_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_39_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_39_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_39_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_39_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_39_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_39_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_39_P3_POINT                         31:30
#define LWE297_SU_INST_39_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_39_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_39_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_39_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_39_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_39_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_39_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_39_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_39_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_39_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_39_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_39_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_39_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_39_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_39_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_39_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_39_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_39_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_39_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_39_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_39_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_39_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_39_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_39_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_39_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_39_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_39_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_39_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_39_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_39_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_39_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_39_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_39_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_39_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_39_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_39_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_39_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_39_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_39_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_40  
#define LWE297_SU_INST_40                           0x328
// source of attribute for TRAM
#define LWE297_SU_INST_40_SRC                              1:0
#define LWE297_SU_INST_40_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_40_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_40_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_40_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_40_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_40_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_40_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_40_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_40_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_40_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_40_P0_POINT                         19:18
#define LWE297_SU_INST_40_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_40_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_40_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_40_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_40_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_40_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_40_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_40_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_40_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_40_P1_POINT                         23:22
#define LWE297_SU_INST_40_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_40_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_40_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_40_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_40_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_40_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_40_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_40_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_40_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_40_P2_POINT                         27:26
#define LWE297_SU_INST_40_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_40_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_40_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_40_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_40_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_40_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_40_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_40_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_40_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_40_P3_POINT                         31:30
#define LWE297_SU_INST_40_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_40_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_40_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_40_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_40_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_40_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_40_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_40_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_40_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_40_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_40_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_40_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_40_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_40_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_40_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_40_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_40_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_40_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_40_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_40_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_40_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_40_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_40_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_40_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_40_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_40_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_40_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_40_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_40_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_40_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_40_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_40_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_40_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_40_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_40_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_40_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_40_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_40_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_40_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_41  
#define LWE297_SU_INST_41                           0x329
// source of attribute for TRAM
#define LWE297_SU_INST_41_SRC                              1:0
#define LWE297_SU_INST_41_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_41_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_41_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_41_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_41_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_41_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_41_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_41_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_41_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_41_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_41_P0_POINT                         19:18
#define LWE297_SU_INST_41_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_41_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_41_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_41_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_41_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_41_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_41_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_41_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_41_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_41_P1_POINT                         23:22
#define LWE297_SU_INST_41_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_41_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_41_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_41_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_41_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_41_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_41_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_41_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_41_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_41_P2_POINT                         27:26
#define LWE297_SU_INST_41_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_41_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_41_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_41_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_41_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_41_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_41_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_41_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_41_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_41_P3_POINT                         31:30
#define LWE297_SU_INST_41_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_41_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_41_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_41_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_41_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_41_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_41_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_41_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_41_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_41_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_41_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_41_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_41_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_41_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_41_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_41_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_41_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_41_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_41_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_41_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_41_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_41_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_41_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_41_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_41_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_41_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_41_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_41_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_41_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_41_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_41_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_41_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_41_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_41_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_41_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_41_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_41_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_41_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_41_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_42  
#define LWE297_SU_INST_42                           0x32a
// source of attribute for TRAM
#define LWE297_SU_INST_42_SRC                              1:0
#define LWE297_SU_INST_42_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_42_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_42_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_42_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_42_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_42_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_42_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_42_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_42_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_42_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_42_P0_POINT                         19:18
#define LWE297_SU_INST_42_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_42_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_42_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_42_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_42_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_42_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_42_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_42_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_42_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_42_P1_POINT                         23:22
#define LWE297_SU_INST_42_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_42_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_42_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_42_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_42_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_42_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_42_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_42_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_42_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_42_P2_POINT                         27:26
#define LWE297_SU_INST_42_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_42_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_42_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_42_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_42_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_42_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_42_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_42_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_42_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_42_P3_POINT                         31:30
#define LWE297_SU_INST_42_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_42_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_42_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_42_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_42_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_42_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_42_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_42_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_42_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_42_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_42_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_42_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_42_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_42_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_42_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_42_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_42_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_42_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_42_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_42_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_42_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_42_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_42_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_42_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_42_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_42_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_42_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_42_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_42_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_42_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_42_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_42_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_42_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_42_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_42_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_42_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_42_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_42_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_42_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_43  
#define LWE297_SU_INST_43                           0x32b
// source of attribute for TRAM
#define LWE297_SU_INST_43_SRC                              1:0
#define LWE297_SU_INST_43_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_43_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_43_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_43_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_43_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_43_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_43_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_43_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_43_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_43_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_43_P0_POINT                         19:18
#define LWE297_SU_INST_43_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_43_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_43_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_43_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_43_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_43_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_43_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_43_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_43_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_43_P1_POINT                         23:22
#define LWE297_SU_INST_43_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_43_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_43_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_43_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_43_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_43_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_43_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_43_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_43_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_43_P2_POINT                         27:26
#define LWE297_SU_INST_43_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_43_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_43_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_43_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_43_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_43_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_43_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_43_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_43_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_43_P3_POINT                         31:30
#define LWE297_SU_INST_43_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_43_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_43_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_43_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_43_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_43_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_43_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_43_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_43_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_43_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_43_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_43_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_43_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_43_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_43_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_43_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_43_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_43_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_43_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_43_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_43_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_43_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_43_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_43_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_43_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_43_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_43_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_43_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_43_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_43_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_43_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_43_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_43_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_43_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_43_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_43_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_43_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_43_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_43_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_44  
#define LWE297_SU_INST_44                           0x32c
// source of attribute for TRAM
#define LWE297_SU_INST_44_SRC                              1:0
#define LWE297_SU_INST_44_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_44_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_44_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_44_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_44_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_44_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_44_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_44_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_44_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_44_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_44_P0_POINT                         19:18
#define LWE297_SU_INST_44_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_44_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_44_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_44_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_44_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_44_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_44_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_44_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_44_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_44_P1_POINT                         23:22
#define LWE297_SU_INST_44_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_44_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_44_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_44_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_44_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_44_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_44_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_44_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_44_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_44_P2_POINT                         27:26
#define LWE297_SU_INST_44_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_44_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_44_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_44_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_44_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_44_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_44_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_44_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_44_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_44_P3_POINT                         31:30
#define LWE297_SU_INST_44_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_44_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_44_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_44_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_44_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_44_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_44_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_44_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_44_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_44_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_44_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_44_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_44_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_44_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_44_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_44_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_44_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_44_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_44_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_44_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_44_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_44_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_44_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_44_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_44_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_44_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_44_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_44_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_44_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_44_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_44_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_44_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_44_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_44_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_44_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_44_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_44_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_44_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_44_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_45  
#define LWE297_SU_INST_45                           0x32d
// source of attribute for TRAM
#define LWE297_SU_INST_45_SRC                              1:0
#define LWE297_SU_INST_45_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_45_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_45_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_45_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_45_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_45_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_45_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_45_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_45_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_45_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_45_P0_POINT                         19:18
#define LWE297_SU_INST_45_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_45_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_45_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_45_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_45_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_45_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_45_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_45_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_45_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_45_P1_POINT                         23:22
#define LWE297_SU_INST_45_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_45_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_45_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_45_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_45_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_45_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_45_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_45_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_45_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_45_P2_POINT                         27:26
#define LWE297_SU_INST_45_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_45_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_45_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_45_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_45_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_45_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_45_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_45_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_45_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_45_P3_POINT                         31:30
#define LWE297_SU_INST_45_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_45_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_45_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_45_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_45_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_45_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_45_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_45_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_45_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_45_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_45_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_45_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_45_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_45_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_45_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_45_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_45_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_45_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_45_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_45_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_45_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_45_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_45_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_45_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_45_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_45_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_45_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_45_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_45_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_45_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_45_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_45_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_45_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_45_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_45_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_45_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_45_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_45_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_45_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_46  
#define LWE297_SU_INST_46                           0x32e
// source of attribute for TRAM
#define LWE297_SU_INST_46_SRC                              1:0
#define LWE297_SU_INST_46_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_46_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_46_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_46_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_46_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_46_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_46_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_46_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_46_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_46_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_46_P0_POINT                         19:18
#define LWE297_SU_INST_46_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_46_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_46_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_46_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_46_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_46_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_46_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_46_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_46_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_46_P1_POINT                         23:22
#define LWE297_SU_INST_46_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_46_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_46_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_46_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_46_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_46_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_46_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_46_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_46_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_46_P2_POINT                         27:26
#define LWE297_SU_INST_46_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_46_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_46_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_46_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_46_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_46_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_46_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_46_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_46_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_46_P3_POINT                         31:30
#define LWE297_SU_INST_46_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_46_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_46_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_46_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_46_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_46_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_46_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_46_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_46_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_46_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_46_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_46_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_46_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_46_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_46_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_46_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_46_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_46_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_46_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_46_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_46_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_46_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_46_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_46_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_46_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_46_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_46_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_46_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_46_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_46_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_46_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_46_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_46_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_46_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_46_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_46_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_46_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_46_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_46_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_47  
#define LWE297_SU_INST_47                           0x32f
// source of attribute for TRAM
#define LWE297_SU_INST_47_SRC                              1:0
#define LWE297_SU_INST_47_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_47_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_47_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_47_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_47_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_47_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_47_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_47_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_47_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_47_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_47_P0_POINT                         19:18
#define LWE297_SU_INST_47_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_47_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_47_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_47_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_47_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_47_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_47_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_47_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_47_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_47_P1_POINT                         23:22
#define LWE297_SU_INST_47_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_47_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_47_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_47_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_47_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_47_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_47_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_47_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_47_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_47_P2_POINT                         27:26
#define LWE297_SU_INST_47_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_47_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_47_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_47_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_47_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_47_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_47_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_47_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_47_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_47_P3_POINT                         31:30
#define LWE297_SU_INST_47_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_47_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_47_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_47_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_47_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_47_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_47_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_47_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_47_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_47_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_47_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_47_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_47_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_47_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_47_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_47_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_47_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_47_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_47_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_47_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_47_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_47_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_47_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_47_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_47_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_47_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_47_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_47_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_47_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_47_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_47_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_47_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_47_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_47_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_47_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_47_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_47_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_47_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_47_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_48  
#define LWE297_SU_INST_48                           0x330
// source of attribute for TRAM
#define LWE297_SU_INST_48_SRC                              1:0
#define LWE297_SU_INST_48_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_48_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_48_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_48_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_48_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_48_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_48_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_48_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_48_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_48_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_48_P0_POINT                         19:18
#define LWE297_SU_INST_48_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_48_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_48_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_48_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_48_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_48_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_48_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_48_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_48_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_48_P1_POINT                         23:22
#define LWE297_SU_INST_48_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_48_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_48_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_48_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_48_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_48_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_48_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_48_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_48_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_48_P2_POINT                         27:26
#define LWE297_SU_INST_48_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_48_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_48_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_48_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_48_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_48_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_48_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_48_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_48_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_48_P3_POINT                         31:30
#define LWE297_SU_INST_48_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_48_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_48_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_48_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_48_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_48_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_48_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_48_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_48_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_48_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_48_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_48_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_48_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_48_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_48_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_48_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_48_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_48_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_48_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_48_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_48_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_48_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_48_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_48_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_48_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_48_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_48_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_48_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_48_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_48_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_48_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_48_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_48_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_48_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_48_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_48_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_48_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_48_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_48_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_49  
#define LWE297_SU_INST_49                           0x331
// source of attribute for TRAM
#define LWE297_SU_INST_49_SRC                              1:0
#define LWE297_SU_INST_49_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_49_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_49_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_49_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_49_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_49_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_49_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_49_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_49_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_49_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_49_P0_POINT                         19:18
#define LWE297_SU_INST_49_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_49_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_49_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_49_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_49_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_49_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_49_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_49_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_49_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_49_P1_POINT                         23:22
#define LWE297_SU_INST_49_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_49_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_49_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_49_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_49_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_49_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_49_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_49_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_49_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_49_P2_POINT                         27:26
#define LWE297_SU_INST_49_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_49_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_49_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_49_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_49_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_49_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_49_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_49_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_49_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_49_P3_POINT                         31:30
#define LWE297_SU_INST_49_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_49_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_49_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_49_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_49_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_49_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_49_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_49_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_49_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_49_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_49_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_49_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_49_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_49_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_49_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_49_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_49_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_49_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_49_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_49_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_49_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_49_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_49_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_49_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_49_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_49_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_49_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_49_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_49_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_49_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_49_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_49_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_49_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_49_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_49_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_49_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_49_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_49_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_49_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_50  
#define LWE297_SU_INST_50                           0x332
// source of attribute for TRAM
#define LWE297_SU_INST_50_SRC                              1:0
#define LWE297_SU_INST_50_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_50_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_50_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_50_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_50_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_50_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_50_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_50_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_50_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_50_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_50_P0_POINT                         19:18
#define LWE297_SU_INST_50_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_50_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_50_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_50_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_50_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_50_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_50_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_50_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_50_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_50_P1_POINT                         23:22
#define LWE297_SU_INST_50_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_50_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_50_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_50_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_50_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_50_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_50_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_50_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_50_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_50_P2_POINT                         27:26
#define LWE297_SU_INST_50_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_50_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_50_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_50_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_50_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_50_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_50_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_50_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_50_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_50_P3_POINT                         31:30
#define LWE297_SU_INST_50_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_50_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_50_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_50_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_50_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_50_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_50_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_50_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_50_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_50_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_50_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_50_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_50_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_50_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_50_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_50_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_50_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_50_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_50_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_50_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_50_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_50_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_50_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_50_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_50_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_50_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_50_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_50_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_50_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_50_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_50_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_50_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_50_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_50_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_50_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_50_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_50_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_50_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_50_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_51  
#define LWE297_SU_INST_51                           0x333
// source of attribute for TRAM
#define LWE297_SU_INST_51_SRC                              1:0
#define LWE297_SU_INST_51_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_51_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_51_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_51_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_51_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_51_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_51_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_51_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_51_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_51_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_51_P0_POINT                         19:18
#define LWE297_SU_INST_51_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_51_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_51_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_51_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_51_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_51_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_51_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_51_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_51_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_51_P1_POINT                         23:22
#define LWE297_SU_INST_51_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_51_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_51_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_51_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_51_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_51_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_51_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_51_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_51_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_51_P2_POINT                         27:26
#define LWE297_SU_INST_51_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_51_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_51_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_51_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_51_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_51_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_51_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_51_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_51_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_51_P3_POINT                         31:30
#define LWE297_SU_INST_51_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_51_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_51_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_51_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_51_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_51_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_51_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_51_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_51_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_51_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_51_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_51_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_51_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_51_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_51_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_51_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_51_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_51_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_51_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_51_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_51_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_51_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_51_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_51_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_51_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_51_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_51_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_51_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_51_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_51_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_51_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_51_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_51_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_51_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_51_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_51_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_51_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_51_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_51_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_52  
#define LWE297_SU_INST_52                           0x334
// source of attribute for TRAM
#define LWE297_SU_INST_52_SRC                              1:0
#define LWE297_SU_INST_52_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_52_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_52_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_52_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_52_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_52_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_52_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_52_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_52_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_52_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_52_P0_POINT                         19:18
#define LWE297_SU_INST_52_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_52_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_52_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_52_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_52_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_52_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_52_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_52_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_52_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_52_P1_POINT                         23:22
#define LWE297_SU_INST_52_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_52_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_52_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_52_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_52_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_52_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_52_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_52_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_52_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_52_P2_POINT                         27:26
#define LWE297_SU_INST_52_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_52_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_52_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_52_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_52_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_52_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_52_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_52_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_52_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_52_P3_POINT                         31:30
#define LWE297_SU_INST_52_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_52_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_52_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_52_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_52_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_52_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_52_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_52_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_52_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_52_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_52_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_52_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_52_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_52_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_52_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_52_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_52_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_52_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_52_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_52_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_52_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_52_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_52_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_52_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_52_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_52_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_52_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_52_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_52_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_52_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_52_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_52_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_52_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_52_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_52_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_52_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_52_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_52_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_52_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_53  
#define LWE297_SU_INST_53                           0x335
// source of attribute for TRAM
#define LWE297_SU_INST_53_SRC                              1:0
#define LWE297_SU_INST_53_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_53_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_53_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_53_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_53_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_53_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_53_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_53_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_53_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_53_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_53_P0_POINT                         19:18
#define LWE297_SU_INST_53_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_53_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_53_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_53_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_53_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_53_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_53_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_53_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_53_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_53_P1_POINT                         23:22
#define LWE297_SU_INST_53_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_53_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_53_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_53_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_53_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_53_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_53_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_53_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_53_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_53_P2_POINT                         27:26
#define LWE297_SU_INST_53_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_53_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_53_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_53_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_53_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_53_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_53_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_53_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_53_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_53_P3_POINT                         31:30
#define LWE297_SU_INST_53_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_53_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_53_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_53_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_53_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_53_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_53_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_53_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_53_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_53_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_53_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_53_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_53_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_53_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_53_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_53_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_53_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_53_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_53_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_53_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_53_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_53_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_53_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_53_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_53_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_53_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_53_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_53_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_53_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_53_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_53_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_53_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_53_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_53_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_53_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_53_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_53_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_53_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_53_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_54  
#define LWE297_SU_INST_54                           0x336
// source of attribute for TRAM
#define LWE297_SU_INST_54_SRC                              1:0
#define LWE297_SU_INST_54_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_54_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_54_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_54_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_54_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_54_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_54_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_54_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_54_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_54_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_54_P0_POINT                         19:18
#define LWE297_SU_INST_54_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_54_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_54_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_54_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_54_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_54_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_54_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_54_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_54_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_54_P1_POINT                         23:22
#define LWE297_SU_INST_54_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_54_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_54_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_54_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_54_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_54_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_54_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_54_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_54_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_54_P2_POINT                         27:26
#define LWE297_SU_INST_54_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_54_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_54_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_54_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_54_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_54_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_54_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_54_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_54_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_54_P3_POINT                         31:30
#define LWE297_SU_INST_54_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_54_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_54_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_54_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_54_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_54_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_54_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_54_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_54_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_54_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_54_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_54_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_54_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_54_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_54_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_54_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_54_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_54_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_54_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_54_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_54_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_54_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_54_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_54_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_54_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_54_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_54_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_54_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_54_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_54_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_54_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_54_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_54_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_54_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_54_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_54_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_54_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_54_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_54_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_55  
#define LWE297_SU_INST_55                           0x337
// source of attribute for TRAM
#define LWE297_SU_INST_55_SRC                              1:0
#define LWE297_SU_INST_55_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_55_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_55_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_55_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_55_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_55_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_55_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_55_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_55_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_55_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_55_P0_POINT                         19:18
#define LWE297_SU_INST_55_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_55_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_55_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_55_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_55_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_55_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_55_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_55_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_55_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_55_P1_POINT                         23:22
#define LWE297_SU_INST_55_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_55_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_55_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_55_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_55_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_55_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_55_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_55_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_55_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_55_P2_POINT                         27:26
#define LWE297_SU_INST_55_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_55_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_55_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_55_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_55_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_55_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_55_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_55_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_55_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_55_P3_POINT                         31:30
#define LWE297_SU_INST_55_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_55_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_55_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_55_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_55_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_55_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_55_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_55_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_55_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_55_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_55_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_55_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_55_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_55_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_55_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_55_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_55_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_55_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_55_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_55_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_55_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_55_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_55_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_55_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_55_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_55_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_55_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_55_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_55_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_55_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_55_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_55_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_55_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_55_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_55_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_55_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_55_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_55_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_55_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_56  
#define LWE297_SU_INST_56                           0x338
// source of attribute for TRAM
#define LWE297_SU_INST_56_SRC                              1:0
#define LWE297_SU_INST_56_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_56_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_56_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_56_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_56_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_56_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_56_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_56_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_56_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_56_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_56_P0_POINT                         19:18
#define LWE297_SU_INST_56_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_56_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_56_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_56_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_56_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_56_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_56_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_56_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_56_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_56_P1_POINT                         23:22
#define LWE297_SU_INST_56_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_56_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_56_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_56_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_56_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_56_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_56_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_56_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_56_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_56_P2_POINT                         27:26
#define LWE297_SU_INST_56_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_56_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_56_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_56_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_56_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_56_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_56_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_56_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_56_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_56_P3_POINT                         31:30
#define LWE297_SU_INST_56_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_56_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_56_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_56_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_56_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_56_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_56_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_56_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_56_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_56_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_56_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_56_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_56_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_56_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_56_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_56_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_56_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_56_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_56_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_56_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_56_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_56_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_56_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_56_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_56_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_56_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_56_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_56_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_56_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_56_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_56_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_56_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_56_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_56_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_56_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_56_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_56_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_56_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_56_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_57  
#define LWE297_SU_INST_57                           0x339
// source of attribute for TRAM
#define LWE297_SU_INST_57_SRC                              1:0
#define LWE297_SU_INST_57_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_57_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_57_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_57_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_57_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_57_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_57_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_57_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_57_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_57_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_57_P0_POINT                         19:18
#define LWE297_SU_INST_57_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_57_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_57_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_57_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_57_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_57_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_57_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_57_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_57_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_57_P1_POINT                         23:22
#define LWE297_SU_INST_57_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_57_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_57_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_57_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_57_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_57_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_57_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_57_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_57_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_57_P2_POINT                         27:26
#define LWE297_SU_INST_57_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_57_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_57_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_57_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_57_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_57_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_57_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_57_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_57_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_57_P3_POINT                         31:30
#define LWE297_SU_INST_57_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_57_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_57_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_57_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_57_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_57_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_57_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_57_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_57_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_57_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_57_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_57_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_57_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_57_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_57_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_57_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_57_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_57_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_57_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_57_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_57_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_57_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_57_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_57_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_57_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_57_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_57_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_57_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_57_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_57_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_57_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_57_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_57_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_57_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_57_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_57_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_57_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_57_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_57_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_58  
#define LWE297_SU_INST_58                           0x33a
// source of attribute for TRAM
#define LWE297_SU_INST_58_SRC                              1:0
#define LWE297_SU_INST_58_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_58_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_58_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_58_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_58_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_58_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_58_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_58_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_58_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_58_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_58_P0_POINT                         19:18
#define LWE297_SU_INST_58_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_58_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_58_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_58_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_58_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_58_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_58_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_58_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_58_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_58_P1_POINT                         23:22
#define LWE297_SU_INST_58_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_58_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_58_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_58_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_58_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_58_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_58_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_58_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_58_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_58_P2_POINT                         27:26
#define LWE297_SU_INST_58_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_58_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_58_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_58_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_58_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_58_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_58_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_58_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_58_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_58_P3_POINT                         31:30
#define LWE297_SU_INST_58_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_58_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_58_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_58_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_58_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_58_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_58_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_58_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_58_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_58_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_58_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_58_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_58_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_58_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_58_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_58_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_58_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_58_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_58_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_58_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_58_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_58_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_58_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_58_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_58_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_58_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_58_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_58_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_58_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_58_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_58_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_58_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_58_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_58_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_58_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_58_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_58_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_58_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_58_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_59  
#define LWE297_SU_INST_59                           0x33b
// source of attribute for TRAM
#define LWE297_SU_INST_59_SRC                              1:0
#define LWE297_SU_INST_59_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_59_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_59_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_59_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_59_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_59_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_59_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_59_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_59_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_59_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_59_P0_POINT                         19:18
#define LWE297_SU_INST_59_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_59_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_59_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_59_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_59_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_59_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_59_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_59_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_59_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_59_P1_POINT                         23:22
#define LWE297_SU_INST_59_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_59_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_59_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_59_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_59_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_59_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_59_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_59_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_59_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_59_P2_POINT                         27:26
#define LWE297_SU_INST_59_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_59_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_59_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_59_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_59_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_59_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_59_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_59_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_59_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_59_P3_POINT                         31:30
#define LWE297_SU_INST_59_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_59_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_59_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_59_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_59_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_59_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_59_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_59_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_59_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_59_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_59_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_59_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_59_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_59_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_59_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_59_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_59_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_59_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_59_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_59_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_59_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_59_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_59_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_59_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_59_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_59_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_59_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_59_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_59_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_59_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_59_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_59_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_59_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_59_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_59_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_59_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_59_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_59_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_59_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_60  
#define LWE297_SU_INST_60                           0x33c
// source of attribute for TRAM
#define LWE297_SU_INST_60_SRC                              1:0
#define LWE297_SU_INST_60_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_60_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_60_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_60_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_60_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_60_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_60_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_60_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_60_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_60_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_60_P0_POINT                         19:18
#define LWE297_SU_INST_60_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_60_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_60_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_60_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_60_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_60_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_60_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_60_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_60_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_60_P1_POINT                         23:22
#define LWE297_SU_INST_60_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_60_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_60_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_60_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_60_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_60_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_60_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_60_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_60_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_60_P2_POINT                         27:26
#define LWE297_SU_INST_60_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_60_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_60_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_60_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_60_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_60_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_60_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_60_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_60_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_60_P3_POINT                         31:30
#define LWE297_SU_INST_60_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_60_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_60_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_60_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_60_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_60_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_60_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_60_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_60_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_60_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_60_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_60_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_60_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_60_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_60_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_60_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_60_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_60_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_60_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_60_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_60_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_60_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_60_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_60_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_60_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_60_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_60_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_60_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_60_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_60_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_60_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_60_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_60_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_60_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_60_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_60_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_60_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_60_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_60_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_61  
#define LWE297_SU_INST_61                           0x33d
// source of attribute for TRAM
#define LWE297_SU_INST_61_SRC                              1:0
#define LWE297_SU_INST_61_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_61_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_61_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_61_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_61_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_61_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_61_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_61_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_61_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_61_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_61_P0_POINT                         19:18
#define LWE297_SU_INST_61_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_61_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_61_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_61_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_61_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_61_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_61_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_61_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_61_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_61_P1_POINT                         23:22
#define LWE297_SU_INST_61_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_61_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_61_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_61_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_61_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_61_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_61_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_61_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_61_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_61_P2_POINT                         27:26
#define LWE297_SU_INST_61_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_61_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_61_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_61_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_61_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_61_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_61_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_61_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_61_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_61_P3_POINT                         31:30
#define LWE297_SU_INST_61_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_61_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_61_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_61_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_61_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_61_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_61_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_61_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_61_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_61_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_61_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_61_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_61_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_61_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_61_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_61_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_61_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_61_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_61_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_61_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_61_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_61_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_61_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_61_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_61_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_61_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_61_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_61_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_61_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_61_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_61_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_61_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_61_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_61_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_61_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_61_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_61_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_61_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_61_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_62  
#define LWE297_SU_INST_62                           0x33e
// source of attribute for TRAM
#define LWE297_SU_INST_62_SRC                              1:0
#define LWE297_SU_INST_62_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_62_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_62_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_62_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_62_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_62_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_62_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_62_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_62_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_62_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_62_P0_POINT                         19:18
#define LWE297_SU_INST_62_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_62_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_62_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_62_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_62_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_62_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_62_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_62_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_62_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_62_P1_POINT                         23:22
#define LWE297_SU_INST_62_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_62_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_62_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_62_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_62_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_62_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_62_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_62_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_62_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_62_P2_POINT                         27:26
#define LWE297_SU_INST_62_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_62_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_62_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_62_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_62_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_62_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_62_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_62_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_62_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_62_P3_POINT                         31:30
#define LWE297_SU_INST_62_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_62_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_62_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_62_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_62_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_62_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_62_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_62_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_62_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_62_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_62_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_62_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_62_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_62_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_62_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_62_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_62_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_62_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_62_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_62_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_62_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_62_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_62_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_62_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_62_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_62_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_62_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_62_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_62_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_62_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_62_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_62_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_62_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_62_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_62_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_62_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_62_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_62_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_62_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.



// Register LWE297_SU_INST_63  
#define LWE297_SU_INST_63                           0x33f
// source of attribute for TRAM
#define LWE297_SU_INST_63_SRC                              1:0
#define LWE297_SU_INST_63_SRC_VPE                 0x00000000    // // from a VPE attribute

#define LWE297_SU_INST_63_SRC_Z                   0x00000001    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define LWE297_SU_INST_63_VC_ROW                           6:3

// TRAM destination row
#define LWE297_SU_INST_63_TRAM_ROW                         14:9

// How attribute 0 is generated across a line's width
#define LWE297_SU_INST_63_P0_LINE_WIDTH                            16:16
#define LWE297_SU_INST_63_P0_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_63_P0_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define LWE297_SU_INST_63_P0_LINE_LENGTH                           17:17
#define LWE297_SU_INST_63_P0_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_63_P0_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define LWE297_SU_INST_63_P0_POINT                         19:18
#define LWE297_SU_INST_63_P0_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_63_P0_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_63_P0_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define LWE297_SU_INST_63_P1_LINE_WIDTH                            20:20
#define LWE297_SU_INST_63_P1_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_63_P1_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define LWE297_SU_INST_63_P1_LINE_LENGTH                           21:21
#define LWE297_SU_INST_63_P1_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_63_P1_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define LWE297_SU_INST_63_P1_POINT                         23:22
#define LWE297_SU_INST_63_P1_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_63_P1_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_63_P1_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define LWE297_SU_INST_63_P2_LINE_WIDTH                            24:24
#define LWE297_SU_INST_63_P2_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_63_P2_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define LWE297_SU_INST_63_P2_LINE_LENGTH                           25:25
#define LWE297_SU_INST_63_P2_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_63_P2_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define LWE297_SU_INST_63_P2_POINT                         27:26
#define LWE297_SU_INST_63_P2_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_63_P2_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_63_P2_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define LWE297_SU_INST_63_P3_LINE_WIDTH                            28:28
#define LWE297_SU_INST_63_P3_LINE_WIDTH_CONST                     0x00000000    // // constant across width (the typical case)

#define LWE297_SU_INST_63_P3_LINE_WIDTH_VARYING                   0x00000001    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define LWE297_SU_INST_63_P3_LINE_LENGTH                           29:29
#define LWE297_SU_INST_63_P3_LINE_LENGTH_VARYING                  0x00000000    // // Interpolated between two vertices' attributes (the typical case)

#define LWE297_SU_INST_63_P3_LINE_LENGTH_CONST                    0x00000001    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define LWE297_SU_INST_63_P3_POINT                         31:30
#define LWE297_SU_INST_63_P3_POINT_DISABLE                        0x00000000    // // constant (typical case for traditional points)

#define LWE297_SU_INST_63_P3_POINT_S                      0x00000001    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define LWE297_SU_INST_63_P3_POINT_T                      0x00000002    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define LWE297_SU_INST_63_P0_TRAM_COL                              1:0

// TRAM column format
#define LWE297_SU_INST_63_P0_TRAM_FMT                              3:2
#define LWE297_SU_INST_63_P0_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_63_P0_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_63_P0_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_63_P0_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define LWE297_SU_INST_63_P1_TRAM_COL                              5:4

// TRAM column format
#define LWE297_SU_INST_63_P1_TRAM_FMT                              7:6
#define LWE297_SU_INST_63_P1_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_63_P1_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_63_P1_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_63_P1_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define LWE297_SU_INST_63_P2_TRAM_COL                              9:8

// TRAM column format
#define LWE297_SU_INST_63_P2_TRAM_FMT                              11:10
#define LWE297_SU_INST_63_P2_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_63_P2_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_63_P2_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_63_P2_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define LWE297_SU_INST_63_P3_TRAM_COL                              13:12

// TRAM column format format
#define LWE297_SU_INST_63_P3_TRAM_FMT                              15:14
#define LWE297_SU_INST_63_P3_TRAM_FMT_NOP                 0x00000000    // // TRAM column is not written (VPE attr. column 0 ignored)

#define LWE297_SU_INST_63_P3_TRAM_FMT_LP_LO                       0x00000001    // // TRAM column lower half is written in low-precision

#define LWE297_SU_INST_63_P3_TRAM_FMT_LP_HI                       0x00000002    // // TRAM column upper half is written in low-precision

#define LWE297_SU_INST_63_P3_TRAM_FMT_HP                  0x00000003    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define LWE297_SU_INST_63_P0_TRI_SHADE_MODE                        16:16
#define LWE297_SU_INST_63_P0_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_63_P0_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_63_P1_TRI_SHADE_MODE                        17:17
#define LWE297_SU_INST_63_P1_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_63_P1_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_63_P2_TRI_SHADE_MODE                        18:18
#define LWE297_SU_INST_63_P2_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_63_P2_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define LWE297_SU_INST_63_P3_TRI_SHADE_MODE                        19:19
#define LWE297_SU_INST_63_P3_TRI_SHADE_MODE_SMOOTH                        0x00000000    // // attribute interpolated among the three vertices

#define LWE297_SU_INST_63_P3_TRI_SHADE_MODE_FLAT                  0x00000001    // // attribute is constant, from trigger (evoking) vertex.


//
// NOTE: DRAW_POINT is used internally between IDX and CLIP; Software should not write this register.
//
// The load flag defines if the vertex has been loaded since the last use, or if this is a
// (cacheable) reference reuse.
//

// Register LWE297_SU_DRAW_POINT_0  
#define LWE297_SU_DRAW_POINT_0                              0x340
#define LWE297_SU_DRAW_POINT_0_V0_LOAD                             24:24

#define LWE297_SU_DRAW_POINT_0_V0                          3:0

//
// NOTE: DRAW_LINE is used internally between IDX and CLIP; Software should not write this register.
//
// The load flag defines if the vertex has been loaded since the last use, or if this is a
// (cacheable) reference reuse.
//

// Register LWE297_SU_DRAW_LINE_0  
#define LWE297_SU_DRAW_LINE_0                               0x341
#define LWE297_SU_DRAW_LINE_0_V1_LOAD                              25:25

#define LWE297_SU_DRAW_LINE_0_V0_LOAD                              24:24

#define LWE297_SU_DRAW_LINE_0_V1                           11:8

#define LWE297_SU_DRAW_LINE_0_V0                           3:0

//
// NOTE: DRAW_TRI is used internally between IDX and CLIP; Software should not write this register.
//
// The load flag defines if the vertex has been loaded since the last use, or if this is a
// (cacheable) reference reuse.
//

// Register LWE297_SU_DRAW_TRI_0  
#define LWE297_SU_DRAW_TRI_0                                0x342
#define LWE297_SU_DRAW_TRI_0_V2_LOAD                               26:26

#define LWE297_SU_DRAW_TRI_0_V1_LOAD                               25:25

#define LWE297_SU_DRAW_TRI_0_V0_LOAD                               24:24

#define LWE297_SU_DRAW_TRI_0_V2                            19:16

#define LWE297_SU_DRAW_TRI_0_V1                            11:8

#define LWE297_SU_DRAW_TRI_0_V0                            3:0

//
// PARAM Register:
// FIRST_INST: first setup instruction to execute
// LAST_INST: last setup instruction to execute (must be >= FIRST_INST, count does NOT wrap around!)
//   This implies that 0 instructions are not supported.  If 0 are desired, program one instruction that
//   reads from arbitrary obuf row and does 4 NOPs.
// FRONT_FACE: which triangle direction is considered front, for downstream (two-sided stencil two-sided lighting, ...). This has no effect on lwlling.
// LWLL: lwlling control
// SUBPIX_XOFF: subpix adjustment for X. 
// SUBPIX_YOFF: subpix adjustment for Y.
//
// SUBPIX_XOFF and YOFF are added after viewport transform, and hence are screen-space.  
// The format is 2's complement S1.4, meaning bits 0..3 are fraction, bit 4 is integer, and bit 5 is sign bit.  The 6 bits [5:0] have weights
// of -2^1, 2^0, 2^-1, 2^-2, 2^-3, 2^-4 respectively.  The range is therefore [-2, 1.9375].  Common encoded values include:
// 0: 0x0
// -0.5: 0x38
// -1.0: 0x30
// 0.5: 0x08
// 1.0: 0x10
//

// Register LWE297_SU_PARAM_0  
#define LWE297_SU_PARAM_0                           0x343
// first setup instruction to execute
#define LWE297_SU_PARAM_0_FIRST_INST                               4:0

// last setup instruction to execute (count does NOT wrap around!)
#define LWE297_SU_PARAM_0_LAST_INST                        9:5

// which triangle direction is considered FRONT facing (vs. BACK facing).  Does not affect lwlling.
#define LWE297_SU_PARAM_0_FRONT_FACE                               15:15
#define LWE297_SU_PARAM_0_FRONT_FACE_POS                  0x00000000    // // positive-area triangles are FRONT facing

#define LWE297_SU_PARAM_0_FRONT_FACE_NEG                  0x00000001    // // negative-area triangles are FRONT facing


// lwlling control for triangles.  Has no affect on lines or points.
#define LWE297_SU_PARAM_0_LWLL                             17:16
#define LWE297_SU_PARAM_0_LWLL_NONE                       0x00000000    // // lwlling disabled, draw all triangles

#define LWE297_SU_PARAM_0_LWLL_POS                        0x00000001    // // lwll positive area triangles

#define LWE297_SU_PARAM_0_LWLL_NEG                        0x00000002    // // lwll negative area triangles

#define LWE297_SU_PARAM_0_LWLL_BOTH                       0x00000003    // // lwll all triangles


// subpixel adjustment S1.4 (Typically, D3D = 0x00 (0), OGL = 0x38 (-0.5))
#define LWE297_SU_PARAM_0_SUBPIX_XOFF                              23:18

// subpixel adjustment S1.4 (Typically, D3D = 0x00 (0), OGL = 0x38 (-0.5))
#define LWE297_SU_PARAM_0_SUBPIX_YOFF                              29:24

// swaps X and Y coordinates, generating a rotated mirror image.  P1 for mg20.
#define LWE297_SU_PARAM_0_TRANSPOSE_XY                             30:30
#define LWE297_SU_PARAM_0_TRANSPOSE_XY_DISABLE                    0x00000000
#define LWE297_SU_PARAM_0_TRANSPOSE_XY_ENABLE                     0x00000001

// frustum clip enable control.
#define LWE297_SU_PARAM_0_CLIP_ENABLE                              31:31
#define LWE297_SU_PARAM_0_CLIP_ENABLE_INIT_ENUM                   ENABLE
#define LWE297_SU_PARAM_0_CLIP_ENABLE_DISABLE                     0x00000000    // // Frustum clipping not performaed - all primitives are accepted. Software must ensure vertices are within device coordinate range.  Viewport transform, user clipping (if enabled) and area lwll is still performed.

#define LWE297_SU_PARAM_0_CLIP_ENABLE_ENABLE                      0x00000001    // // Frustum clipping is performed as usual


//
// ZBIAS: device-coordinate value added to iterated Z. Each 16 units or fewer (depending on Z surface format) of bias
// guarentees 1 LSB of Z offset, with no z-fighting assuming identical triangulation
// (see ZFACTOR for the other half of the PolygonOffset implementation).
//
// NOTE: software is responsible for disabling this and ZFACTOR for points and lines;
// hardware does not disable it automatically.
//
// The encoding of this register is signed fixed-point integer with 1 sign bit, 1 integer bit, and 20 fraction bits. The range is
// [-2, 2).  Bits 21..0 have weight -2^1, 2^0, 2^-1, ... 2^-20 respectively.
// To colwert an IEEE floating point value to this format, do something like:
//   int int_val = (int)lrintf(fp_bias * (float)(1<<20));    // colwert to int with 20-bit "fraction"
//   zbias.val = min((2 << 20) - 1, max(-2 << 20, int_val)) & 0x3fffff;    // clamp to [-2, 2), and mask to 22 bits.
//
// Note that the range of Z within the chip is [-4, 4) but pixels with Z outside that range are either 
// clamped to [0, 1), or killed, before being written to Z buffer. 
// The purpose of the wider [-4, 4) range is to permit guardband frustum clipping at near and far planes.
// 

// Register LWE297_SU_ZBIAS_0  
#define LWE297_SU_ZBIAS_0                           0x344
// S1.20 device-coordinate value
#define LWE297_SU_ZBIAS_0_VAL                              21:0

//
// ZFACTOR is the 32-bit IEEE FP PolygonOffset z-slope factor.
// Each N will result in a z-bias of N LSB's of the iterated Z
// for each unit of max(|dz/dx|,|dz/dy|) worth of z-slope.
// (see ZBIAS for the other half of the PolygonOffset implementation).
// Note that up to 16 iterated Z units may be required to change Z surface by one unit, since Z surfaces have as few as 16 bits, 
// whereas itereated Z is 20 bits of precision.
//
// NOTE: software is responsible for disabling this and ZBIAS for points and lines;
// hardware does not disable it automatically.
//

// Register LWE297_SU_ZFACTOR_0  
#define LWE297_SU_ZFACTOR_0                                 0x345
// IEEE float value
#define LWE297_SU_ZFACTOR_0_VAL                            31:0

//
// POINT_PARAM controls various aspects of DRAW_POINT operation
//
// When POINT_SIZE_MODE is FIXED, point size comes from the POINT_WIDTH_2 register.
//      Calling that 'pw2', the four corners of generated point are computed as
//               (X0, Y0) = (X - pw2, Y - pw2)
//               (X1, Y1) = (X + pw2, Y + pw2)
//               (X2, Y2) = (X - pw2, Y + pw2)
//               (X3, Y3) = (X + pw2, Y - pw2)
//
// When POINT_SIZE_MODE is PSIZE, point size comes from a component of attribute at obuf[VTX_OFFS].ATTR_COMP.
//      Calling that 'a.x', the four corners of generated point are computed as
//               (X0, Y0) = (X - a.x, Y - a.x)
//               (X1, Y1) = (X + a.x, Y + a.x)
//               (X2, Y2) = (X - a.x, Y + a.x)
//               (X3, Y3) = (X + a.x, Y - a.x)
//
// When POINT_SIZE_MODE is SHEAR, point sizes comes from attribute obuf[VTX_OFFS].
//      Calling that attribute 'a', the four corners of generated point are computed as
//               (X0, Y0) = (X - a.x - a.z, Y - a.y - a.w)
//               (X1, Y1) = (X + a.x + a.z, Y + a.y + a.w)
//               (X2, Y2) = (X - a.x + a.z, Y - a.y + a.w)
//               (X3, Y3) = (X + a.x - a.z, Y + a.y - a.w)
//

// Register LWE297_SU_POINT_PARAM_0  
#define LWE297_SU_POINT_PARAM_0                             0x346
// offset of attribute in obuf for size and/or 
#define LWE297_SU_POINT_PARAM_0_VTX_OFFS                           3:0

// which component of obuf attribute (for PSIZE)
#define LWE297_SU_POINT_PARAM_0_ATTR_COMP                          9:8
#define LWE297_SU_POINT_PARAM_0_ATTR_COMP_X                       0x00000000
#define LWE297_SU_POINT_PARAM_0_ATTR_COMP_Y                       0x00000001
#define LWE297_SU_POINT_PARAM_0_ATTR_COMP_Z                       0x00000002
#define LWE297_SU_POINT_PARAM_0_ATTR_COMP_W                       0x00000003

// control over whether and how the VTX_OFFS vectors are used in point generation
#define LWE297_SU_POINT_PARAM_0_POINT_SIZE_MODE                            11:10
#define LWE297_SU_POINT_PARAM_0_POINT_SIZE_MODE_FIXED                     0x00000000
#define LWE297_SU_POINT_PARAM_0_POINT_SIZE_MODE_PSIZE                     0x00000001
#define LWE297_SU_POINT_PARAM_0_POINT_SIZE_MODE_SHEAR                     0x00000002

// clip points/pointsprites to inner (screen) vs. outer (guardband) frustum.
// In either case, the center of point(sprite) is used.
#define LWE297_SU_POINT_PARAM_0_CLIP_MODE                          12:12
#define LWE297_SU_POINT_PARAM_0_CLIP_MODE_SCREEN                  0x00000000    // // clip to screen edge; wide points may pop in or out.

#define LWE297_SU_POINT_PARAM_0_CLIP_MODE_GUARDBAND                       0x00000001    // // clip to guardband; the guardband_w/_h registers must be inset enough to accomodate
// points' expansion by point_size.


//
// POINT_WIDTH_2 is a 32-bit IEEE FP value representing 1/2 the point width.
// For mg20, the requirement is to support up to glPointSize() of up to 256, and up to 2048x2048 surface size.
// SW should insure that points and lines do not expand beyond 128 pixels past the 2048 boundary.
//

// Register LWE297_SU_POINT_WIDTH_2_0  
#define LWE297_SU_POINT_WIDTH_2_0                           0x347
// IEEE float value
#define LWE297_SU_POINT_WIDTH_2_0_VAL                              31:0

//
// When Px_POINT is S, this value is used for the maximum S value (typically should be 1.0)
//

// Register LWE297_SU_POINT_MAX_S_0  
#define LWE297_SU_POINT_MAX_S_0                             0x348
// IEEE float value
#define LWE297_SU_POINT_MAX_S_0_VAL                        31:0

//
// When Px_POINT is T, this value is used for the maximum T value (typically should be 1.0)
//

// Register LWE297_SU_POINT_MAX_T_0  
#define LWE297_SU_POINT_MAX_T_0                             0x349
// IEEE float value
#define LWE297_SU_POINT_MAX_T_0_VAL                        31:0

//
// When Px_POINT is S, this value is used for the minimum S value (typically should be 0.0)
//

// Register LWE297_SU_POINT_MIN_S_0  
#define LWE297_SU_POINT_MIN_S_0                             0x34a
// IEEE float value
#define LWE297_SU_POINT_MIN_S_0_VAL                        31:0

//
// When Px_POINT is T, this value is used for the minimum T value (typically should be 0.0)
//

// Register LWE297_SU_POINT_MIN_T_0  
#define LWE297_SU_POINT_MIN_T_0                             0x34b
// IEEE float value
#define LWE297_SU_POINT_MIN_T_0_VAL                        31:0

//
// LINE_PARAM controls various aspects of DRAW_LINE operation.
//
// SQUARE-cut lines tend to be slower to draw than FRENCH-cut lines.
// CLIP_MODE of SCREEN may result in more clipping and thus slower performance.
//

// Register LWE297_SU_LINE_PARAM_0  
#define LWE297_SU_LINE_PARAM_0                              0x34c
// style of line end-caps to draw
#define LWE297_SU_LINE_PARAM_0_LWT                         0:0
#define LWE297_SU_LINE_PARAM_0_LWT_FRENCH                 0x00000000    // // line ends are parallel to either X or Y axis

#define LWE297_SU_LINE_PARAM_0_LWT_SQUARE                 0x00000001    // // line ends are perpendilwlar to line


// clip lines to inner (screen) vs. outer (guardband) frustum.  
// in either case, the center of line is used.
#define LWE297_SU_LINE_PARAM_0_CLIP_MODE                           1:1
#define LWE297_SU_LINE_PARAM_0_CLIP_MODE_SCREEN                   0x00000000    // // clipped to screen edge, so that ends may be visible.  

#define LWE297_SU_LINE_PARAM_0_CLIP_MODE_GUARDBAND                        0x00000001    // // if GUARDBAND selected, the guardband_w/_h registers must be inset enough to accomodate
// lines' expandion by line_width_2.


//
// LINE_WIDTH_2 is a 32-bit IEEE FP value representing 1/2 the line width
//

// Register LWE297_SU_LINE_WIDTH_2_0  
#define LWE297_SU_LINE_WIDTH_2_0                            0x34d
// IEEE single-precision float value
#define LWE297_SU_LINE_WIDTH_2_0_VAL                               31:0

//
// LINE_MAX_ATTR_W controls the maximum autogenerated attribute value across line width
// (when INST.Px_LINE_WIDTH is VARYING)
//

// Register LWE297_SU_LINE_MAX_ATTR_W_0  
#define LWE297_SU_LINE_MAX_ATTR_W_0                                 0x34e
// IEEE single-precision float value
#define LWE297_SU_LINE_MAX_ATTR_W_0_VAL                            31:0

//
// LINE_MIN_ATTR_W controls the minimum autogenerated attribute value across line width
// (when INST.Px_LINE_WIDTH is VARYING).
//

// Register LWE297_SU_LINE_MIN_ATTR_W_0  
#define LWE297_SU_LINE_MIN_ATTR_W_0                                 0x34f
// IEEE single-precision float value
#define LWE297_SU_LINE_MIN_ATTR_W_0_VAL                            31:0

// maxiumum drawable dimension
#define LWE297_SETUP_VTX_XY_WIDTH 12
//
// Scissor max and min in X, in whole pixels.    
// These values are unsigned.  The min value is inclusive whereas the max
// value is exclusive.  A scissor rectangle of width 240, at 0, would be 
// encoded as MIN=0, MAX=240. Note that if MIN==MAX, the scissor width is 0. 
//

// Register LWE297_SU_SCISSOR_X_0  
#define LWE297_SU_SCISSOR_X_0                               0x350
// unsigned maximum X value (exclusive)
#define LWE297_SU_SCISSOR_X_0_MAX                          12:0

// unsigned minimum Y value (inclusive)
#define LWE297_SU_SCISSOR_X_0_MIN                          27:16

//
// Scissor max and min in Y, in whole pixels 
// NOTE: Y is measured from the top of the frame buffer (i.e., lower
// address of surface).  This is the opposite of the glScissor() point of
// reference, which is the lower left corner.  These values are unsigned.
// The min value is inclusive whereas the max value is exclusive. A scissor 
// rectangle of height 320, at 0, would be encoded as MIN=0, MAX=320.  Note 
// that if MIN==MAX, the scissor height is 0.
//

// Register LWE297_SU_SCISSOR_Y_0  
#define LWE297_SU_SCISSOR_Y_0                               0x351
// unsigned maximum Y value (exclusive)
#define LWE297_SU_SCISSOR_Y_0_MAX                          12:0

// unsigned minimum Y value (inclusive)
#define LWE297_SU_SCISSOR_Y_0_MIN                          27:16

//
// Viewport/depth-range registers for XYZWHD (32-bit IEEE floats)
//
// NOTE:
//
// The X and Y viewport transforms should map [-1, 1] to [viewport_min, viewport_size+viewport_min).  For example,
// a 240x320 viewport should map X from [-1,1] to [0,240) and Y from [-1,1] to [0,320).
// The X/Y/W/H values must be scaled by LW_GR3D_SNAP_ONE since the output of the viewport
// transformation is assumed to be at subpixel resolution by the hardware.  I.e., the X and Y 
// viewport transforms should yield X in range [0 .. WIDTH*LW_GR3D_SNAP_ONE) (for viewable area - not including guardband)
// and Y in range [0 .. HEIGHT*WIDTH*LW_GR3D_SNAP_ONE].
//
// VIEWPORT_Y gives offset in lines from top (lowest address) of frame buffer; this is different than OpenGL.
//
// The Z viewport transform should map [-1, 1] to [0, 1).  If Z guardband is enabled, the output range can be as large
// as [-4, 4), depending on GUARDBAND_D register.  The output of viewport transform (z * VIEWPORT_D + VIEWPORT_Z) is colwerteed
// in hardware to a fixed-point integer value with 1 sign bit, 2 integer bits, and 20 fractional bits.  The range is [-4, 4).
// Pixels with Z outside of [0,1) are clamped to [0,1) or killed. 
// An example setting is:
//      view_d = (z_far - z_near) / 2.0 
//      view_z = view_d + z_near
//      z_scale = (float)((1 << 20) - 1) / (float)(1 << 20); // map 1 to 1-epsilon
//      VIEWPORT_D = view_d * z_scale
//      VIEWPORT_Z = view_z * z_scale
//

// Register LWE297_SU_VIEWPORT_X_0  // horizontal viewport offset (must be scaled by LW_GR3D_SNAP_ONE)
#define LWE297_SU_VIEWPORT_X_0                              0x352
// IEEE single-precision floating point
#define LWE297_SU_VIEWPORT_X_0_VAL                         31:0


// Register LWE297_SU_VIEWPORT_Y_0  // vertical viewport offset (must be scaled by LW_GR3D_SNAP_ONE)
#define LWE297_SU_VIEWPORT_Y_0                              0x353
// IEEE single-precision floating point
#define LWE297_SU_VIEWPORT_Y_0_VAL                         31:0


// Register LWE297_SU_VIEWPORT_Z_0  // depth viewport offset
#define LWE297_SU_VIEWPORT_Z_0                              0x354
// IEEE single-precision floating point
#define LWE297_SU_VIEWPORT_Z_0_VAL                         31:0


// Register LWE297_SU_VIEWPORT_W_0  // horizontal viewport scale factor (must be scaled by LW_GR3D_SNAP_ONE)
#define LWE297_SU_VIEWPORT_W_0                              0x355
// IEEE single-precision floating point
#define LWE297_SU_VIEWPORT_W_0_VAL                         31:0


// Register LWE297_SU_VIEWPORT_H_0  // vertical viewport scale factor (must be scaled by LW_GR3D_SNAP_ONE)
#define LWE297_SU_VIEWPORT_H_0                              0x356
// IEEE single-precision floating point
#define LWE297_SU_VIEWPORT_H_0_VAL                         31:0


// Register LWE297_SU_VIEWPORT_D_0  // depth viewport scale factor
#define LWE297_SU_VIEWPORT_D_0                              0x357
// IEEE single-precision floating point
#define LWE297_SU_VIEWPORT_D_0_VAL                         31:0

//
// guardband width/height/depth clipcode generation registers (32-bit IEEE floats)
//
// 1.0 == no guardband, > 1.0 results in a guardband that's
// that much bigger than the extent of the device coordinates
// post-viewport, i.e. if you're rendering to 320 wide viewport and hardware handles
// coordinates up to LW_GR3D_XRES, you may compute:
//
//  GUARDBAND_W = LW_GR3D_XRES / (320/2)
//
// But since the viewport is not centered in the guardband frustum, a tighter
// value is given by:
//
//  GUARDBAND_W = (LW_GR3D_XRES - 320/2) / (320/2)
//
// Further, to permit wide points and lines to clip offscreen (rather than pop in/out at screen edge), guardband should be adjusted 
// outword a bit.  The hardware provides adequate headroom for this:
//
//  GUARDBAND_W = MAX(LW_GR3D_XRES + LW_GR3D_MAX_POINT_LINE_SIZE/2 - 320/2, LW_GR3D_XRES + LW_GR3D_MAX_POINT_LINE_SIZE/2) / (320/2)
//
// These equations assume that viewport performs the operation:
//    Xd = 320/2 * Xc + 320/2
// where Xd is device X coordinate, and Xc is clip space coordinate.
//
// The above dislwssion applies to GUARDBAND_W and GUARDBAND_Y.  For Z guardband:
//
//    GUARDBAND_Z = (pow(2.0, (float)LW_GR3D_Z_INT_BITS) - .5) / .5 - pow(2.0, -(float)LW_GR3D_XRES_LOG2)
//
// inner clipcodes are generated by comparing post-transform
// x,y,z to -/+ the transformed w, while the outer clipcodes
// compare against -/+ GUARDBAND_<DIMENSION> * w. Hardware will
// trivial-reject things completely outside the inner -/+w
// rectangle, and trivial accept things completely inside the
// outer -/+GUARDBAND_<DIMENSION>*w rectangle. Complex clipping cases
// are be handled entirely in hardware.  In cases where the vertex
// coordinates are very far apart (> 8,000 screen diameters), the
// intercepts may start losing precision due to the fact that all
// clipping is done in single precision float arithmetic.  Clipping
// cases where the vertices have W's of opposite sign may produce
// non-obvious results.
//

// Register LWE297_SU_GUARDBAND_W_0  // width (x) guardband factor 
#define LWE297_SU_GUARDBAND_W_0                             0x358
// IEEE single-precision floating point
#define LWE297_SU_GUARDBAND_W_0_VAL                        31:0


// Register LWE297_SU_GUARDBAND_H_0  // height (Y) guardband factor
#define LWE297_SU_GUARDBAND_H_0                             0x359
// IEEE single-precision floating point
#define LWE297_SU_GUARDBAND_H_0_VAL                        31:0


// Register LWE297_SU_GUARDBAND_D_0  // depth (Z) guardband factor
#define LWE297_SU_GUARDBAND_D_0                             0x35a
// IEEE single-precision floating point
#define LWE297_SU_GUARDBAND_D_0_VAL                        31:0

//
// User Clip Plane
//
// This register controls the user clip plane.  When enabled,
// clip will fetch a scalar value from the OBUF based on the
// VTX_OFFS and ATTR_COMP parameters.  This value should be
// a plane distance computed by the VPE via a DP4 of the
// homogenous position and a plane equation, which is typically
// computed as ( Nx, Ny, Nz, - P dot N ) for a plane with unit
// normal N and a point on the plane P.  The plane defines a half-
// space where values of the plane distance < 0.0 are clipped.
//
// Note that user clip enable is independent of frustum clip enable.
//

// Register LWE297_SU_UCPLANE_0  
#define LWE297_SU_UCPLANE_0                                 0x35b
// OBUF slot for user plane 0 distance
#define LWE297_SU_UCPLANE_0_VTX_OFFS                               3:0

// component for user plane 0 distance
#define LWE297_SU_UCPLANE_0_ATTR_COMP                              9:8
#define LWE297_SU_UCPLANE_0_ATTR_COMP_X                   0x00000000
#define LWE297_SU_UCPLANE_0_ATTR_COMP_Y                   0x00000001
#define LWE297_SU_UCPLANE_0_ATTR_COMP_Z                   0x00000002
#define LWE297_SU_UCPLANE_0_ATTR_COMP_W                   0x00000003

// enable or disable user clip plane 0
#define LWE297_SU_UCPLANE_0_ENABLE                         10:10
#define LWE297_SU_UCPLANE_0_ENABLE_INIT_ENUM                      DISABLED
#define LWE297_SU_UCPLANE_0_ENABLE_DISABLED                       0x00000000
#define LWE297_SU_UCPLANE_0_ENABLE_ENABLED                        0x00000001


// Register LWE297_SU_UCPLANE  
#define LWE297_SU_UCPLANE                           0x35b
// OBUF slot for user plane 0 distance
#define LWE297_SU_UCPLANE_VTX_OFFS                         3:0

// component for user plane 0 distance
#define LWE297_SU_UCPLANE_ATTR_COMP                        9:8
#define LWE297_SU_UCPLANE_ATTR_COMP_X                     0x00000000
#define LWE297_SU_UCPLANE_ATTR_COMP_Y                     0x00000001
#define LWE297_SU_UCPLANE_ATTR_COMP_Z                     0x00000002
#define LWE297_SU_UCPLANE_ATTR_COMP_W                     0x00000003

// enable or disable user clip plane 0
#define LWE297_SU_UCPLANE_ENABLE                           10:10
#define LWE297_SU_UCPLANE_ENABLE_INIT_ENUM                        DISABLED
#define LWE297_SU_UCPLANE_ENABLE_DISABLED                 0x00000000
#define LWE297_SU_UCPLANE_ENABLE_ENABLED                  0x00000001


// Reserved address 860 [0x35c] 

// Reserved address 861 [0x35d] 

// Reserved address 862 [0x35e] 

// Reserved address 863 [0x35f] 

// Reserved address 864 [0x360] 

// Reserved address 865 [0x361] 

// Reserved address 866 [0x362] 
// reserved space for future expansion
// Second-level clock enable override register
//
// This can override the 2nd level clock enables in case of malfunction.
// Only exposed to software when needed.
//

// Register LWE297_SU_CLKEN_OVERRIDE_0  
#define LWE297_SU_CLKEN_OVERRIDE_0                                  0x363
#define LWE297_SU_CLKEN_OVERRIDE_0_GR3D_SETUPDPCLK_CLKEN_OVR                               0:0
#define LWE297_SU_CLKEN_OVERRIDE_0_GR3D_SETUPDPCLK_CLKEN_OVR_INIT_ENUM                    CLK_GATED
#define LWE297_SU_CLKEN_OVERRIDE_0_GR3D_SETUPDPCLK_CLKEN_OVR_CLK_GATED                    0x00000000
#define LWE297_SU_CLKEN_OVERRIDE_0_GR3D_SETUPDPCLK_CLKEN_OVR_CLK_ALWAYS_ON                        0x00000001


// Register LWE297_SU_CLIP_CLKEN_OVERRIDE_0  
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0                             0x364
// Fine Grain override for the gr3dclipcgclk
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPCGCLK_CLKEN_OVR                        0:0
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPCGCLK_CLKEN_OVR_INIT_ENUM                     CLK_GATED
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPCGCLK_CLKEN_OVR_CLK_GATED                     0x00000000
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPCGCLK_CLKEN_OVR_CLK_ALWAYS_ON                 0x00000001

// Fine Grain override for the gr3dclipccclk
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPCCCLK_CLKEN_OVR                        1:1
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPCCCLK_CLKEN_OVR_INIT_ENUM                     CLK_GATED
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPCCCLK_CLKEN_OVR_CLK_GATED                     0x00000000
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPCCCLK_CLKEN_OVR_CLK_ALWAYS_ON                 0x00000001

// Fine Grain override for the gr3dclipcpclk
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPCPCLK_CLKEN_OVR                        2:2
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPCPCLK_CLKEN_OVR_INIT_ENUM                     CLK_GATED
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPCPCLK_CLKEN_OVR_CLK_GATED                     0x00000000
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPCPCLK_CLKEN_OVR_CLK_ALWAYS_ON                 0x00000001

// Fine Grain override for the gr3dclipvpclk
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPVPCLK_CLKEN_OVR                        3:3
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPVPCLK_CLKEN_OVR_INIT_ENUM                     CLK_GATED
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPVPCLK_CLKEN_OVR_CLK_GATED                     0x00000000
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPVPCLK_CLKEN_OVR_CLK_ALWAYS_ON                 0x00000001

// Fine Grain override for the gr3dcliparclk
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPARCLK_CLKEN_OVR                        4:4
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPARCLK_CLKEN_OVR_INIT_ENUM                     CLK_GATED
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPARCLK_CLKEN_OVR_CLK_GATED                     0x00000000
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPARCLK_CLKEN_OVR_CLK_ALWAYS_ON                 0x00000001

// Fine Grain override for the gr3dclippaclk
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPPACLK_CLKEN_OVR                        5:5
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPPACLK_CLKEN_OVR_INIT_ENUM                     CLK_GATED
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPPACLK_CLKEN_OVR_CLK_GATED                     0x00000000
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPPACLK_CLKEN_OVR_CLK_ALWAYS_ON                 0x00000001

// Fine Grain override for the gr3dclipdzclk
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPDZCLK_CLKEN_OVR                        6:6
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPDZCLK_CLKEN_OVR_INIT_ENUM                     CLK_GATED
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPDZCLK_CLKEN_OVR_CLK_GATED                     0x00000000
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPDZCLK_CLKEN_OVR_CLK_ALWAYS_ON                 0x00000001

// Fine Grain override for the gr3dclipticlk
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPTICLK_CLKEN_OVR                        7:7
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPTICLK_CLKEN_OVR_INIT_ENUM                     CLK_GATED
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPTICLK_CLKEN_OVR_CLK_GATED                     0x00000000
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPTICLK_CLKEN_OVR_CLK_ALWAYS_ON                 0x00000001

// Fine Grain override for the gr3dclipsiclk
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPSICLK_CLKEN_OVR                        8:8
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPSICLK_CLKEN_OVR_INIT_ENUM                     CLK_GATED
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPSICLK_CLKEN_OVR_CLK_GATED                     0x00000000
#define LWE297_SU_CLIP_CLKEN_OVERRIDE_0_CLIPSICLK_CLKEN_OVR_CLK_ALWAYS_ON                 0x00000001

// --------------------------------------------------------------------------
// 
// Copyright (c) 2004, LWPU Corp.
// All Rights Reserved.
// 
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of LWPU Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of LWPU Corp.
// 
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
// 
// --------------------------------------------------------------------------
// 
// This file has all the reg/packet definitions related to Raster unit in AR20
// This file is included by ar3d.spec
#define QRAST_SCOREBOARD_DEPTH  64
#define QRAST_SCOREBOARD_WIDTH  64
#define QRAST_QUAD_COUNT_WIDTH  22
#define QRAST_NUM_EDGES_PER_TRIANGLE    4
#define QRAST_NUM_SAMPLES_PER_PIXEL     5
#define QRAST_NUM_VIRT_SAMPLES_PER_PIXEL        4
#define QRAST_NUM_PIXEL_ROWS_PER_QUAD   2
#define QRAST_NUM_PIXEL_COLS_PER_QUAD   2
#define QRAST_NUM_PIXEL_ROWS_PER_FINE_STAMP     3
#define QRAST_NUM_PIXEL_COLS_PER_FINE_STAMP     3
#define QRAST_FDC_CACHE_LINE_LEN        8
#define QRAST_TILE_HEIGHT_IN_PIXELS     16
#define QRAST_SCOREBOARD_TILE_X_SIZE    16
#define QRAST_SCOREBOARD_TILE_Y_SIZE    16
#define QRAST_SCOREBOARD_SIZE   2048
#define QRAST_SCOREBOARD_CACHEA_SIZE    7
#define QRAST_SCOREBOARD_CACHEB_SIZE    2
#define QRAST_NUM_QRAST_FDC_READ_PORTS  2
#define QRAST_NUM_QRAST_FDC_WRITE_PORTS 2
#define QRAST_ZSER_FIFO_DEPTH   64
// There's no way to define an array in the spec system, so just list out the sample
// points here.
#define QRAST_REAL_SAMP_X       0
#define QRAST_REAL_SAMP_Y       0
#define QRAST_VIRT_A_SAMP_X     6
#define QRAST_VIRT_A_SAMP_Y     2
#define QRAST_VIRT_B_SAMP_X     14
#define QRAST_VIRT_B_SAMP_Y     6
#define QRAST_VIRT_C_SAMP_X     2
#define QRAST_VIRT_C_SAMP_Y     10
#define QRAST_VIRT_D_SAMP_X     10
#define QRAST_VIRT_D_SAMP_Y     14
// General Qrast Programming
//
// There are 4 basic operating modes in QRast: Early mode, Late mode,
// CtoA mode, and OVG mode. Early mode refers to programming QRast to
// perform the depth, stencil, and VCAA operations which update those
// surfaces. Late mode refers to programming QRast to not touch the
// depth, stencil, and VCAA surfaces because the pixel shader is
// modifying the coverage information. In Late mode, the pixel shader
// writes the depth, stencil, and VCAA surfaces. CtoA is an abbreviation
// of Coverage-To-Alpha. In this mode, QRast is computing the fragment
// coverage and passing that information to the shader to use as the
// alpha value in rendering. This is distinct from Late mode in that
// there is no VCAA surface ilwolved in CtoA. OVG is the mode where 2
// passes occur: the first pass renders the coverage information into the
// stencil buffer, and the second pass takes the stencil-coverage data
// and sends it to the shader.
//
// In Early mode, only pixels which pass the pixel tests (e.g. stencil
// test) are sent to the shader. Thus, this mode is synonymous with
// setting OUTPUT_TO_SHADER.PASS_ONLY to ENABLE. When in early mode,
// where QRast is updating the depth, stencil and/or VCAA surfaces, the
// following constraints must be met:
//       It is illegal to set OUTPUT_TO_SHADER.VCAA_OUTPUT to MERGE.
//
// In Late mode, pixels which fail the pixel tests (e.g. stencil test)
// are sent to the shader in addition to pixels which pass the pixel
// tests. This mode is synonymous with setting OUTPUT_TO_SHADER.PASS_ONLY
// to DISABLE. When in late mode where the shader is updating the depth,
// stencil, and/or VCAA surfaces, the following constraints must also be
// met:
//       It is illegal to set OUTPUT_TO_SHADER.SWALLOW_QUADS to ALL.
//
// In OVG mode there are two passes. The first pass writes the coverage
// information into the stencil buffer. The second pass reads the
// stencil-coverage data and sends it down to shader. This mode is
// synonymous with OUTPUT_TO_SHADER.VCAA_OUTPUT set to
// STENCIL_COVERAGE. In this mode there are several additional
// requirements:
//       VCAA_OPERATION.VIRTUAL_AS_REAL must be ENABLED
//       VCAA_OPERATION.SILHOUETTE must be DISABLED.
//       VCAA_OPERATION.TRANSPARENCY must be DISABLED.
//       VCAA_OPERATION.VCAA_ENABLE must be DISABLED.
//       S_ENABLE must be DISABLED (no stencil operations!)
//       OUTPUT_TO_SHADER.PASS_ONLY must be ENABLED.
//
// In CtoA mode, QRast computes the virtual coverage values and treats
// pixels which have virtual-only coverage in the same manner as pixels
// with real coverage. In other words, a pixel with virtual-only coverage
// which passes the depth test will update the depth buffer. Hence this
// mode is synonymous with VCAA_OPERATION.VIRTUAL_AS_REAL is ENABLE with
// OUTPUT_TO_SHADER.VCAA_OUTPUT not set to STENCIL_COVERAGE (see OVG
// above). In CtoA mode, the following constraints must be met:
//       VCAA_OPERATION.SILHOUETTE must be DISABLED
//       VCAA_OPERATION.TRANSPARENCY must be DISABLED
//       OUTPUT_TO_SHADER.SWALLOW_QUADS cannot be VIRTUAL
//
// Finally, independent of the operating mode, two additional rules exist
// for programming QRast:
//       OUTPUT_TO_SHADER.VCAA_OUTPUT can only be set to MERGE when 
//        VCAA_ENABLE is ENABLE.
//       VCAA_OPERATION.SILHOUETTE can only be ENABLED when VCAA_ENABLE 
//        is ENABLE.
//
// S_TEST contains the per-face stencil test operations.  This
// includes the MASK and FUNCTION parameters from the StencilFunc()
// call.  The REF value from StencilFunc() is contained in the
// S_OPERATION register because it is needed by multiple units (as
// opposed to the data here which is needed only by QRAST).

// Register LWE297_QR_S_TEST_0  
#define LWE297_QR_S_TEST_0                                  0x400
// Stencil test mask from StencilFunc()
#define LWE297_QR_S_TEST_0_S_MASK                          7:0

// Stencil function from StencilFunc()
#define LWE297_QR_S_TEST_0_S_FUNC                          10:8
#define LWE297_QR_S_TEST_0_S_FUNC_NEVER                   0x00000000
#define LWE297_QR_S_TEST_0_S_FUNC_LESS                    0x00000001
#define LWE297_QR_S_TEST_0_S_FUNC_EQUAL                   0x00000002
#define LWE297_QR_S_TEST_0_S_FUNC_LEQUAL                  0x00000003
#define LWE297_QR_S_TEST_0_S_FUNC_GREATER                 0x00000004
#define LWE297_QR_S_TEST_0_S_FUNC_NOTEQUAL                        0x00000005
#define LWE297_QR_S_TEST_0_S_FUNC_GEQUAL                  0x00000006
#define LWE297_QR_S_TEST_0_S_FUNC_ALWAYS                  0x00000007


// Register LWE297_QR_S_TEST  
#define LWE297_QR_S_TEST                            0x400
// Stencil test mask from StencilFunc()
#define LWE297_QR_S_TEST_S_MASK                            7:0

// Stencil function from StencilFunc()
#define LWE297_QR_S_TEST_S_FUNC                            10:8
#define LWE297_QR_S_TEST_S_FUNC_NEVER                     0x00000000
#define LWE297_QR_S_TEST_S_FUNC_LESS                      0x00000001
#define LWE297_QR_S_TEST_S_FUNC_EQUAL                     0x00000002
#define LWE297_QR_S_TEST_S_FUNC_LEQUAL                    0x00000003
#define LWE297_QR_S_TEST_S_FUNC_GREATER                   0x00000004
#define LWE297_QR_S_TEST_S_FUNC_NOTEQUAL                  0x00000005
#define LWE297_QR_S_TEST_S_FUNC_GEQUAL                    0x00000006
#define LWE297_QR_S_TEST_S_FUNC_ALWAYS                    0x00000007


// Register LWE297_QR_S_TEST_1  
#define LWE297_QR_S_TEST_1                                  0x401
// Stencil test mask from StencilFunc()
#define LWE297_QR_S_TEST_1_S_MASK                          7:0

// Stencil function from StencilFunc()
#define LWE297_QR_S_TEST_1_S_FUNC                          10:8
#define LWE297_QR_S_TEST_1_S_FUNC_NEVER                   0x00000000
#define LWE297_QR_S_TEST_1_S_FUNC_LESS                    0x00000001
#define LWE297_QR_S_TEST_1_S_FUNC_EQUAL                   0x00000002
#define LWE297_QR_S_TEST_1_S_FUNC_LEQUAL                  0x00000003
#define LWE297_QR_S_TEST_1_S_FUNC_GREATER                 0x00000004
#define LWE297_QR_S_TEST_1_S_FUNC_NOTEQUAL                        0x00000005
#define LWE297_QR_S_TEST_1_S_FUNC_GEQUAL                  0x00000006
#define LWE297_QR_S_TEST_1_S_FUNC_ALWAYS                  0x00000007

// S_CTRL contains the universal stencil controls.  These are values
// that are not per-face, but rather have a single value that applies
// to all faces.  COVERAGE_MERGE is for OVG functionality -- it allows
// the coverage data to be merged with the stencil value.  The
// coverage data is formed by concatenating the virtual coverage bits
// into a 5 bit value (real sample is in bit 0, virtual samples are in
// bits 1-4).

// Register LWE297_QR_S_CTRL_0  
#define LWE297_QR_S_CTRL_0                                  0x402
// NONE: Do not modify the stencil value with coverage.
// Bitwise OR the coverage bits with the stencil value.
// Bitwise XOR the coverage bits with the stencil value.
// Bitwise OR the coverage bits with the ILWERTED stencil value.
#define LWE297_QR_S_CTRL_0_COVERAGE_MERGE                          1:0
#define LWE297_QR_S_CTRL_0_COVERAGE_MERGE_NONE                    0x00000000
#define LWE297_QR_S_CTRL_0_COVERAGE_MERGE_OR                      0x00000001
#define LWE297_QR_S_CTRL_0_COVERAGE_MERGE_XOR                     0x00000002
#define LWE297_QR_S_CTRL_0_COVERAGE_MERGE_OR_NOT                  0x00000003

// Pointer to the stencil surface in the surface tables.  Note that the only
// allowed value for this field is lwrrently LW_GR3D_S_SURF_PTR.
#define LWE297_QR_S_CTRL_0_S_SURF_PTR                              4:2

// DISABLE: The stencil test is disabled.  All pixels pass.
// ENABLE:  The stencil test is enabled.
#define LWE297_QR_S_CTRL_0_S_ENABLE                        5:5
#define LWE297_QR_S_CTRL_0_S_ENABLE_DISABLE                       0x00000000
#define LWE297_QR_S_CTRL_0_S_ENABLE_ENABLE                        0x00000001

// DISABLE: QRAST does not write to the stencil surface (with the
// assumption being that the shader has been modified to
// do it).
// ENABLE: QRAST updates the stencil surface with the result of
// the stencil operation.
#define LWE297_QR_S_CTRL_0_QRAST_FB_WRITE                          6:6
#define LWE297_QR_S_CTRL_0_QRAST_FB_WRITE_DISABLE                 0x00000000
#define LWE297_QR_S_CTRL_0_QRAST_FB_WRITE_ENABLE                  0x00000001

// Z_TEST defines the depth surface and the associated depth test
// operation.  This includes Z_FUNC from DepthFunc(), and depth
// test enable from Enable().

// Register LWE297_QR_Z_TEST_0  
#define LWE297_QR_Z_TEST_0                                  0x403
// Z surface pointer to fetch through.  Note that the only
// allowed value for this field is LW_GR3D_Z_SURF_PTR.
#define LWE297_QR_Z_TEST_0_Z_SURF_PTR                              2:0

// DISABLE: The depth test is disabled.  All pixels pass.
// ENABLE:The depth test is enabled.
#define LWE297_QR_Z_TEST_0_Z_ENABLE                        3:3
#define LWE297_QR_Z_TEST_0_Z_ENABLE_DISABLE                       0x00000000
#define LWE297_QR_Z_TEST_0_Z_ENABLE_ENABLE                        0x00000001

// Z function
#define LWE297_QR_Z_TEST_0_Z_FUNC                          7:4
#define LWE297_QR_Z_TEST_0_Z_FUNC_NEVER                   0x00000000
#define LWE297_QR_Z_TEST_0_Z_FUNC_LESS                    0x00000001
#define LWE297_QR_Z_TEST_0_Z_FUNC_EQUAL                   0x00000002
#define LWE297_QR_Z_TEST_0_Z_FUNC_LEQUAL                  0x00000003
#define LWE297_QR_Z_TEST_0_Z_FUNC_GREATER                 0x00000004
#define LWE297_QR_Z_TEST_0_Z_FUNC_NOTEQUAL                        0x00000005
#define LWE297_QR_Z_TEST_0_Z_FUNC_GEQUAL                  0x00000006
#define LWE297_QR_Z_TEST_0_Z_FUNC_ALWAYS                  0x00000007

// DISABLE: QRAST does not write to the depth surface (with the
// assumption being that the shader has been modified to
// do it).
// ENABLE QRAST updates the depth surface with the result of
// the depth operation.
#define LWE297_QR_Z_TEST_0_QRAST_FB_WRITE                          8:8
#define LWE297_QR_Z_TEST_0_QRAST_FB_WRITE_DISABLE                 0x00000000
#define LWE297_QR_Z_TEST_0_QRAST_FB_WRITE_ENABLE                  0x00000001

// CLAMP: Depth values which are out of range are clamped.
// KILL: Depth values which are out of range kill the pixel.
#define LWE297_QR_Z_TEST_0_Z_CLAMP                         9:9
#define LWE297_QR_Z_TEST_0_Z_CLAMP_CLAMP                  0x00000000
#define LWE297_QR_Z_TEST_0_Z_CLAMP_KILL                   0x00000001

// Normally, Z_CLAMP is performed whenever depth test is enabled. 
// When Z_CLAMP_OVERRIDE is set to ENABLE, the depth computation
// and depth clamp are performed even if the depth test is disabled.
// This is used to clip pixels outside of the [0, 1] range in conjunction
// with clip's z-guard-band.
// Setting Z_CLAMP_OVERRIDE to ENABLE when depth test is enabled 
// (read lwbug:401697) causes extra reads to be issued from qrast
// scoreboard logic.  In order to work-around this, s/w must set
// Z_CLAMP_OVERRIDE to enable only when depth test is disabled.
#define LWE297_QR_Z_TEST_0_Z_CLAMP_OVERRIDE                        10:10
#define LWE297_QR_Z_TEST_0_Z_CLAMP_OVERRIDE_DISABLE                       0x00000000
#define LWE297_QR_Z_TEST_0_Z_CLAMP_OVERRIDE_ENABLE                        0x00000001

// Z_MIN is used to implement the DepthRange functionality.  QRast compares this value against
// the fixed point per fragment Z value, and kills or clamps fragments based on the setting of
// Z_CLAMP above.  The comparison is done prior to Z compression, and hence is performed on the
// 20 bit fixed point Z value computed for the pixel.  SW should program this value based on 
// the smaller of the near and far values provided by the application in DepthRange(n, f) as
// given in the following formula:
//
//      float z_min_float = MIN( n, f );
//      Z_MIN = (floor)(z_min_float * (2^20 - 1) + 0.5f)
//
// Note that I assume here that n and f are [0.0 .. 1.0].

// Register LWE297_QR_Z_MIN_0  
#define LWE297_QR_Z_MIN_0                           0x404
// Depth values below this value are killed or clamped.
#define LWE297_QR_Z_MIN_0_VALUE                            19:0

// Z_MAX is used to implement the DepthRange functionality.  QRast compares this value against
// the fixed point per fragment Z value, and kills or clamps fragments based on the setting of
// Z_CLAMP above.  The comparison is done prior to Z compression, and hence is performed on the
// 20 bit fixed point Z value computed for the pixel.  SW should program this value based on 
// the smaller of the near and far values provided by the application in DepthRange(n, f) as
// given in the following formula:
//
//      float z_max_float = MAX( n, f );
//      Z_MAX = (floor)(z_max_float * (2^20 - 1) + 0.5f)
//
// Note that I assume here that n and f are [0.0 .. 1.0].

// Register LWE297_QR_Z_MAX_0  
#define LWE297_QR_Z_MAX_0                           0x405
// Depth values above this value are killed or clamped.
#define LWE297_QR_Z_MAX_0_VALUE                            19:0

// RAST_OPERATION controls the rasterization order in QRAST.  Note
// that due to the number of delta bits, swathing at more than 16
// pixels wide is going to cause span starts to be inserted, so at
// that point, we should just do the whole line.

// Register LWE297_QR_RAST_OPERATION_0  
#define LWE297_QR_RAST_OPERATION_0                                  0x406
// PIX_8: Rasterize in columns that are 8 pixels wide.
// PIX_16:Rasterize in columns that are 16 pixels wide.
#define LWE297_QR_RAST_OPERATION_0_SWATH_WIDTH                             1:0
#define LWE297_QR_RAST_OPERATION_0_SWATH_WIDTH_PIX_8                      0x00000000
#define LWE297_QR_RAST_OPERATION_0_SWATH_WIDTH_PIX_16                     0x00000001

// DOWN: Always rasterize from top down for any triangle.
// ALTERNATE: When swathing, rasterize columns in alternating directions.
#define LWE297_QR_RAST_OPERATION_0_V_DIRECTION                             2:2
#define LWE297_QR_RAST_OPERATION_0_V_DIRECTION_DOWN                       0x00000000
#define LWE297_QR_RAST_OPERATION_0_V_DIRECTION_ALTERNATE                  0x00000001

// RAST_SCISSOR_SNAP controls the generation and usage of the
// internal qrast scissor rectangle (note that this is separate and
// distinct from the glScissor functionality).  

// Register LWE297_QR_RAST_SCISSOR_SNAP_0  
#define LWE297_QR_RAST_SCISSOR_SNAP_0                               0x407
// NOP: Has no effect on the scissor values.
// Setting the RAST_SCISSOR_SNAP to SAMPLE causes the RAST_BBOX values
// to be immediately transfered to the RAST_SCISSOR values.  This
// has the side effect of setting the RAST_SCISSOR_UPDATE bit.
// Setting the SNAP value to STALL causes the pipe to stall until
// the RAST_SCISSOR_UPDATE bit has been set to '1' by a SAMPLE operation.
#define LWE297_QR_RAST_SCISSOR_SNAP_0_RAST_SCISSOR_SNAP                            1:0
#define LWE297_QR_RAST_SCISSOR_SNAP_0_RAST_SCISSOR_SNAP_NOP                       0x00000000
#define LWE297_QR_RAST_SCISSOR_SNAP_0_RAST_SCISSOR_SNAP_SAMPLE                    0x00000001
#define LWE297_QR_RAST_SCISSOR_SNAP_0_RAST_SCISSOR_SNAP_STALL                     0x00000002

// See RAST_SCISSOR_SNAP.
#define LWE297_QR_RAST_SCISSOR_SNAP_0_RAST_SCISSOR_UPDATE                          2:2

// Writing a '1' here causes the value written to the RAST_SCISSOR_UPDATE
// to be used by the HW.  This allows the driver to restore the state
// of that bit after a context switch.
#define LWE297_QR_RAST_SCISSOR_SNAP_0_RAST_SCISSOR_UPDATE_WRITE                            3:3

// DISABLE: QRAST does not change the value of the RAST_BBOX registers.
// ENABLE:  QRAST updates the RAST_BBOX registers based on pixels which are visible.
#define LWE297_QR_RAST_SCISSOR_SNAP_0_BBOX_ACLWMULATE                              4:4
#define LWE297_QR_RAST_SCISSOR_SNAP_0_BBOX_ACLWMULATE_DISABLE                     0x00000000
#define LWE297_QR_RAST_SCISSOR_SNAP_0_BBOX_ACLWMULATE_ENABLE                      0x00000001

// DISABLE: QRAST does no additional scissoring (see RAST_SCISSOR)
// ENABLE:  QRAST uses the RAST_SCISSOR values in determining visibility.
#define LWE297_QR_RAST_SCISSOR_SNAP_0_RAST_SCISSOR_ENABLE                          5:5
#define LWE297_QR_RAST_SCISSOR_SNAP_0_RAST_SCISSOR_ENABLE_DISABLE                 0x00000000
#define LWE297_QR_RAST_SCISSOR_SNAP_0_RAST_SCISSOR_ENABLE_ENABLE                  0x00000001

// QRAST implements a separate SCISSOR function in addition to the
// usual OpenGL scissor implemented in SETUP.  The QRAST scissor is
// used to scissor the rendered region based on the result of an
// aclwmulated scissor window from the Depth/Stencil/Coverage test.
// See the RAST_SCISSOR_SNAP register for information on programming
// this value automatically.  RAST_SCISSOR_MIN and RAST_SCISSOR_MAX
// contain the current scissor rectangle used for the QRAST scissor.

// Register LWE297_QR_RAST_SCISSOR_MIN_0  
#define LWE297_QR_RAST_SCISSOR_MIN_0                                0x408
// Current QRAST SCISSOR X-MIN. 
#define LWE297_QR_RAST_SCISSOR_MIN_0_X                             12:0

// Current QRAST SCISSOR Y-MIN. 
#define LWE297_QR_RAST_SCISSOR_MIN_0_Y                             28:16


// Register LWE297_QR_RAST_SCISSOR_MAX_0  
#define LWE297_QR_RAST_SCISSOR_MAX_0                                0x409
// Current QRAST SCISSOR Y-MAX.
#define LWE297_QR_RAST_SCISSOR_MAX_0_X                             12:0

// Current QRAST SCISSOR Y-MAX. 
#define LWE297_QR_RAST_SCISSOR_MAX_0_Y                             28:16

// RAST_BBOX_MIN and RAST_BBOX_MAX contained the aclwmulated qrast
// geometry bounding box.  See QRAST_SCISSOR_UPDATE for information
// on transferring this value into the RAST_SCISSOR registers.

// Register LWE297_QR_RAST_BBOX_MIN_0  
#define LWE297_QR_RAST_BBOX_MIN_0                           0x40a
// Aclwmulated bounding box X-MIN. 
#define LWE297_QR_RAST_BBOX_MIN_0_X                        12:0

// Aclwmulated bounding box Y-MIN.
#define LWE297_QR_RAST_BBOX_MIN_0_Y                        28:16


// Register LWE297_QR_RAST_BBOX_MAX_0  
#define LWE297_QR_RAST_BBOX_MAX_0                           0x40b
// Aclwmulated bounding box X-MAX. 
#define LWE297_QR_RAST_BBOX_MAX_0_X                        12:0

// Aclwmulated bounding box Y-MAX. 
#define LWE297_QR_RAST_BBOX_MAX_0_Y                        28:16

// SB_OPERATION is the register which controls how the scoreboard in
// the QRAST unit behaves.  
//
// When the scoreboard is switched off, any pixels which are in the
// pipeline will continue to clear entries in the scoreboard -- no new
// entries will be made for new pixel data, and no new pixels will be
// stalled based on the state of scoreboard.

// Register LWE297_QR_SB_OPERATION_0  
#define LWE297_QR_SB_OPERATION_0                            0x40c
// OFF: The scoreboard is disabled.
// PER_PIXEL: The scoreboard has 1 entry per pixel.  Only one
// oclwrance of each visible pixel is allowed in the pipe
// at any time.
// PER_SAMPLE: The scoreboard has 1 entry per pixel. The scoreboard 
// entry is marked if any real or virtual sample associated with 
// a pixel is covered.
// PSEUDO: This is primarily a test mode.  When used, the scoreboard
// memory is unused (off), but the scoreboard accounding packets continue
// to flow in the system.  This is useful because it enables BLOCKING_MODEs
// other than OFF to work.
#define LWE297_QR_SB_OPERATION_0_GRANULARITY                               1:0
#define LWE297_QR_SB_OPERATION_0_GRANULARITY_OFF                  0x00000000
#define LWE297_QR_SB_OPERATION_0_GRANULARITY_PER_SAMPLE                   0x00000001
#define LWE297_QR_SB_OPERATION_0_GRANULARITY_PER_PIXEL                    0x00000002
#define LWE297_QR_SB_OPERATION_0_GRANULARITY_PSEUDO                       0x00000003

// TABLE: The scoreboard address is dereferenced through a table 
// to allow for maximum travel horizontally or vertically 
// before a collision oclwrs.
// FORMULA: The scoreboard address is computed from the (x,y) directly.
// This maximizes distance for rectangular regions at the cost of
// potential performance in slivery triangles. In tests before tapeout,
// this had better performance.
// RESERVED_1 and RESERVED_2 are present for future use.
#define LWE297_QR_SB_OPERATION_0_INDEX_MODE                        3:2
#define LWE297_QR_SB_OPERATION_0_INDEX_MODE_TABLE                 0x00000000
#define LWE297_QR_SB_OPERATION_0_INDEX_MODE_FORMULA                       0x00000001
#define LWE297_QR_SB_OPERATION_0_INDEX_MODE_RESERVED_1                    0x00000002
#define LWE297_QR_SB_OPERATION_0_INDEX_MODE_RESERVED_2                    0x00000003

// OFF: Triangles are allowed to flow based on the scoreboard state.
// PER_TRI_RAST: The scoreboard blocks at each triangle boundary
// until the triangle has been completely rasterized and early Z'd.
// This mode works in conjunction with a GRANULARITY other than OFF!
// PER_TRI_SHADER: The scoreboard blocks at each triangle boundary
// until the triangle has been completely rendered. This mode works 
// in conjunction with a GRANULARITY other than OFF!
#define LWE297_QR_SB_OPERATION_0_BLOCKING_MODE                             5:4
#define LWE297_QR_SB_OPERATION_0_BLOCKING_MODE_OFF                        0x00000000
#define LWE297_QR_SB_OPERATION_0_BLOCKING_MODE_PER_TRI_RAST                       0x00000001
#define LWE297_QR_SB_OPERATION_0_BLOCKING_MODE_PER_TRI_SHADER                     0x00000002

// A write of '1' to this bit will not be processed 
// until the scoreboard is empty.  This causes the
// pipe below the scoreboard to drain of all pixels if the scoreboard
// has a non-off GRANULARITY.
#define LWE297_QR_SB_OPERATION_0_STALL                             6:6

// A write of '1' to this bit will immediately clear 
// all entries in the scoreboard.
#define LWE297_QR_SB_OPERATION_0_CLEAR                             7:7

// ON: the depth, stencil, and vcaa caches are used to optimize FDC traffic.
// OFF: the depth, stencil, and vcaa caches always miss, increasing FDC traffic.
#define LWE297_QR_SB_OPERATION_0_CACHE                             8:8
#define LWE297_QR_SB_OPERATION_0_CACHE_ON                 0x00000000
#define LWE297_QR_SB_OPERATION_0_CACHE_OFF                        0x00000001

// A write of '1' to this bit will disable any read optimisation logic
// in scoreboard
#define LWE297_QR_SB_OPERATION_0_RD_OPTZ_CYA                               9:9


// Register LWE297_QR_QRAST_CLKEN_OVERRIDE_0  
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0                            0x40d
// CLK_GATED : Enable clock gating for gr3dqrastpixtestclk; 
// CLK_ALWAYS_ON : Disable clock gating for gr3dqrastpixtestclk
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_PIXTEST_CLKEN_OVR                         0:0
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_PIXTEST_CLKEN_OVR_INIT_ENUM                      CLK_GATED
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_PIXTEST_CLKEN_OVR_CLK_GATED                      0x00000000
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_PIXTEST_CLKEN_OVR_CLK_ALWAYS_ON                  0x00000001

#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_FDCIF_CLKEN_OVR                           1:1
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_FDCIF_CLKEN_OVR_INIT_ENUM                        CLK_GATED
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_FDCIF_CLKEN_OVR_CLK_GATED                        0x00000000
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_FDCIF_CLKEN_OVR_CLK_ALWAYS_ON                    0x00000001

#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_TOP_CLKEN_OVR                             2:2
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_TOP_CLKEN_OVR_INIT_ENUM                  CLK_GATED
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_TOP_CLKEN_OVR_CLK_GATED                  0x00000000
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_TOP_CLKEN_OVR_CLK_ALWAYS_ON                      0x00000001

#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_SCOREBOARD_CLKEN_OVR                              3:3
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_SCOREBOARD_CLKEN_OVR_INIT_ENUM                   CLK_GATED
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_SCOREBOARD_CLKEN_OVR_CLK_GATED                   0x00000000
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_SCOREBOARD_CLKEN_OVR_CLK_ALWAYS_ON                       0x00000001

#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_LATENCYFIFO_CLKEN_OVR                             4:4
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_LATENCYFIFO_CLKEN_OVR_INIT_ENUM                  CLK_GATED
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_LATENCYFIFO_CLKEN_OVR_CLK_GATED                  0x00000000
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_LATENCYFIFO_CLKEN_OVR_CLK_ALWAYS_ON                      0x00000001

#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_ZSER_CLKEN_OVR                            5:5
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_ZSER_CLKEN_OVR_INIT_ENUM                 CLK_GATED
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_ZSER_CLKEN_OVR_CLK_GATED                 0x00000000
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_ZSER_CLKEN_OVR_CLK_ALWAYS_ON                     0x00000001

#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_REG_CLKEN_OVR                             6:6
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_REG_CLKEN_OVR_INIT_ENUM                  CLK_GATED
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_REG_CLKEN_OVR_CLK_GATED                  0x00000000
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_REG_CLKEN_OVR_CLK_ALWAYS_ON                      0x00000001

#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_SETUPIF_CLKEN_OVR                         7:7
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_SETUPIF_CLKEN_OVR_INIT_ENUM                      CLK_GATED
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_SETUPIF_CLKEN_OVR_CLK_GATED                      0x00000000
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_SETUPIF_CLKEN_OVR_CLK_ALWAYS_ON                  0x00000001

#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_TIDZSER_CLKEN_OVR                         8:8
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_TIDZSER_CLKEN_OVR_INIT_ENUM                      CLK_GATED
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_TIDZSER_CLKEN_OVR_CLK_GATED                      0x00000000
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_TIDZSER_CLKEN_OVR_CLK_ALWAYS_ON                  0x00000001

#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_PIPE_CLKEN_OVR                            9:9
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_PIPE_CLKEN_OVR_INIT_ENUM                 CLK_GATED
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_PIPE_CLKEN_OVR_CLK_GATED                 0x00000000
#define LWE297_QR_QRAST_CLKEN_OVERRIDE_0_PIPE_CLKEN_OVR_CLK_ALWAYS_ON                     0x00000001

// The VCAA_OPERATION register controls the VCAA computation and
// output within QRAST.  The VCAA computation is disabled whenever
// VCAA_OUTPUT is DISABLED and QRAST_WRITE is disabled.  Turning on
// either or both VCAA_OUTPUT and VCAA_WRITE causes virtual sample
// coverage to be computed.
//
// QRAST_WRITE    controls what data is written by QRAST to the frame buffer.
// TRANSPARENCY  controls whether or not the transparency optimization is enabled.
// SILHOUETTE    controls whether or not the silhouette edge optimization is enabled.
// VCAA_SURF_PTR is the index of the VCAA surface in the global surface table.

// Register LWE297_QR_VCAA_OPERATION_0  
#define LWE297_QR_VCAA_OPERATION_0                                  0x40e
// DISABLE: VCAA data NOT sent to frame buffer by QRAST.
// UNMERGE: Output the fragment coverage data to the frame buffer.
// MERGE: Output MERGED fragment and frame buffer VCAA data to frame buffer.
// ONE: Output all 1's for the coverage data for any touched pixel.
#define LWE297_QR_VCAA_OPERATION_0_QRAST_FB_WRITE                          1:0
#define LWE297_QR_VCAA_OPERATION_0_QRAST_FB_WRITE_DISABLE                 0x00000000
#define LWE297_QR_VCAA_OPERATION_0_QRAST_FB_WRITE_UNMERGE                 0x00000001
#define LWE297_QR_VCAA_OPERATION_0_QRAST_FB_WRITE_MERGE                   0x00000002
#define LWE297_QR_VCAA_OPERATION_0_QRAST_FB_WRITE_ONE                     0x00000003

// DISABLE: Update VCAA for fully covered and partially covered pixels.
// ENABLE: Update VCAA data for partially covered pixels only.
#define LWE297_QR_VCAA_OPERATION_0_TRANSPARENCY                            2:2
#define LWE297_QR_VCAA_OPERATION_0_TRANSPARENCY_DISABLE                   0x00000000
#define LWE297_QR_VCAA_OPERATION_0_TRANSPARENCY_ENABLE                    0x00000001

// Use the pixel Z value from the frame buffer for comparison.
// Use the adjacent or pixel Z value from the frame buffer for comparison.
#define LWE297_QR_VCAA_OPERATION_0_SILHOUETTE                              3:3
#define LWE297_QR_VCAA_OPERATION_0_SILHOUETTE_DISABLE                     0x00000000
#define LWE297_QR_VCAA_OPERATION_0_SILHOUETTE_ENABLE                      0x00000001

// Pointer to the VCAA surface in the surface tables.  Note that the only
// allowed value for this field is lwrrently LW_GR3D_V_SURF_PTR.
#define LWE297_QR_VCAA_OPERATION_0_VCAA_SURF_PTR                           6:4

// DISABLE: Computed virtual samples are always zero.
// ENABLE: Virtual sample coverage computed from geometry, VCAA surface is read
// COMPUTE_ONLY: Virtual sample coverage computed from geometry, VCAA surface is NOT read.
#define LWE297_QR_VCAA_OPERATION_0_VCAA_ENABLE                             8:7
#define LWE297_QR_VCAA_OPERATION_0_VCAA_ENABLE_DISABLE                    0x00000000
#define LWE297_QR_VCAA_OPERATION_0_VCAA_ENABLE_ENABLE                     0x00000001
#define LWE297_QR_VCAA_OPERATION_0_VCAA_ENABLE_COMPUTE_ONLY                       0x00000002

// DISABLE: Only real samples update depth and stencil buffers.
// ENABLE: Real or virtual coverage causes depth and stencil updates.
#define LWE297_QR_VCAA_OPERATION_0_VIRTUAL_AS_REAL                         9:9
#define LWE297_QR_VCAA_OPERATION_0_VIRTUAL_AS_REAL_DISABLE                        0x00000000
#define LWE297_QR_VCAA_OPERATION_0_VIRTUAL_AS_REAL_ENABLE                 0x00000001

// The OUTPUT_TO_SHADER register controls what information is propogate from QRAST to PSEQ.
// This includes VCAA and SCOREBOARD data as well as whether or not any quad at all is sent!

// Register LWE297_QR_OUTPUT_TO_SHADER_0  
#define LWE297_QR_OUTPUT_TO_SHADER_0                                0x40f
// VCAA data NOT sent to PSEQ.
// Output MERGE fragement and frame buffer VCAA data to PSEQ.
// Output UNMERGE fragment VCAA data to PSEQ.
// SMEAR the real sample value to the 4 virtual samples in output to PSEQ.
// For STENCIL_COVERAGE, output the Stencil AND Merged Coverage value (bitwise AND)
#define LWE297_QR_OUTPUT_TO_SHADER_0_VCAA_OUTPUT                           2:0
#define LWE297_QR_OUTPUT_TO_SHADER_0_VCAA_OUTPUT_DISABLE                  0x00000000
#define LWE297_QR_OUTPUT_TO_SHADER_0_VCAA_OUTPUT_MERGE                    0x00000001
#define LWE297_QR_OUTPUT_TO_SHADER_0_VCAA_OUTPUT_UNMERGE                  0x00000002
#define LWE297_QR_OUTPUT_TO_SHADER_0_VCAA_OUTPUT_SMEAR                    0x00000003
#define LWE297_QR_OUTPUT_TO_SHADER_0_VCAA_OUTPUT_STENCIL_COVERAGE                 0x00000004

// This field controls how coverage data is used to determine which
// pixels are sent to PSEQ.  
// OFF: Qrast sends pixels with real and/or virtual coverage to pseq.  So
// this would be the setting for coverage-to-alpha where pixels with only
// virtual coverage should none-the-less be drawn.
// VIRTUAL: Qrast swallows pixels with only virtual coverage. (reals are send to pseq).
// So this would be a typical non-coverage-to-alpha setting where the shader
// only draws pixels that have real coverage.
// ALL: Qrast sends no pixels to pseq.  This is a depth-only rendering setting
// where the shader draws nothing.
#define LWE297_QR_OUTPUT_TO_SHADER_0_SWALLOW_QUADS                         4:3
#define LWE297_QR_OUTPUT_TO_SHADER_0_SWALLOW_QUADS_OFF                    0x00000000
#define LWE297_QR_OUTPUT_TO_SHADER_0_SWALLOW_QUADS_VIRTUAL                        0x00000001
#define LWE297_QR_OUTPUT_TO_SHADER_0_SWALLOW_QUADS_ALL                    0x00000002

// This field controls how the state of pixel tests modifies which pixels
// are sent to PSEQ.  In particular, this field exists to support late vs
// early pixel testing.  When early Z/Stencil/VCAA is used, PASS_ONLY should
// be ENABLE.  When late Stencil/VCAA is used, PASS_ONLY should be DISABLE.
//
// ENABLE:  Only pixels who's real sample PASS the stencil test and depth test are
// sent to PSEQ.  This setting is used in conjunction with early Z/S/VCAA surfaces.
// It prevents pixels which fail stencil, for example, from being passed to the shader.
//
// DISABLE: All covered pixels which are not swallowed are sent to PSEQ, 
// even if they fail the depth or stencil tests.  This is the setting for late stencil
// where the pixel shader must perform the stencil op for any pixel covered by a fragment
// even if it fails depth test or stencil test. This is also the setting for late vcaa where
// DWR could be updating the vcaa surface even when pixels fail depth test.
#define LWE297_QR_OUTPUT_TO_SHADER_0_PASS_ONLY                             5:5
#define LWE297_QR_OUTPUT_TO_SHADER_0_PASS_ONLY_ENABLE                     0x00000000
#define LWE297_QR_OUTPUT_TO_SHADER_0_PASS_ONLY_DISABLE                    0x00000001

// DISABLE: QRAST clears the scoreboard bit as pixels complete Z/S/VCAA processing.
// This causes pixels that are only doing c-writes in shader to go faster.
// ENABLED: PSEQ clears the scoreboard bit when pixels are retired from the shader.
#define LWE297_QR_OUTPUT_TO_SHADER_0_SCOREBOARD_OUTPUT                             6:6
#define LWE297_QR_OUTPUT_TO_SHADER_0_SCOREBOARD_OUTPUT_DISABLE                    0x00000000
#define LWE297_QR_OUTPUT_TO_SHADER_0_SCOREBOARD_OUTPUT_ENABLE                     0x00000001

// 0: disabled.  The delta checker never times out.
// 1..7: enabled.  The delta checker times out in N * 64 clocks of no new quads.
// This behavior is not modelled by the CSIM.
#define LWE297_QR_OUTPUT_TO_SHADER_0_TIMEOUT                               9:7

// PSEQ waits until it has enough work to do before recirlwlating.  When
// this field is DETERMINISTIC, qrast sends out a PSEQ flush when it detects that
// it has no more work to send pseq, yet pseq is waiting for more work before recirlwlating.
// This can be inefficient, but it is deterministic.  PERFORMANCE is not
// deterministic, but is efficient.  It sends a flush whenever the serializer
// fifo goes empty, which depends on timing and hence is not deterministic.
#define LWE297_QR_OUTPUT_TO_SHADER_0_PSEQ_FLUSH                            10:10
#define LWE297_QR_OUTPUT_TO_SHADER_0_PSEQ_FLUSH_PERFORMANCE                       0x00000000
#define LWE297_QR_OUTPUT_TO_SHADER_0_PSEQ_FLUSH_DETERMINISTIC                     0x00000001

// The QRAST_DEBUG is available for future use.

// Register LWE297_QR_QRAST_DEBUG_0  
#define LWE297_QR_QRAST_DEBUG_0                             0x410
// To be defined.
#define LWE297_QR_QRAST_DEBUG_0_VALUE                              31:0


// Register LWE297_QR_QRAST_LIMITS_0  
#define LWE297_QR_QRAST_LIMITS_0                            0x411
// As a CYA, Qrast can limit the number of pixels in flight in qrast 
// by setting this value.  Default is disabled (0).
#define LWE297_QR_QRAST_LIMITS_0_PIX_CNT_QRAST                             11:0

// As a CYA, Qrast can limit the number of pixels in flight after scoreboard
// by setting this value.  Default is disabled (0).
#define LWE297_QR_QRAST_LIMITS_0_PIX_CNT_SHD                               22:12

/////////////////////////////////////////////////////////////////////////////////
// Snooped global registers:
//
// S_OPERATION[2]
// SURFDESC -- Contains the Z surface descriptor.
//             Contains the S surface descriptor
//             Contains the C surface descriptor.
// SURADDR -- Contains the surface address.
/////////////////////////////////////////////////////////////////////////////////
//These packets are RTL specific
//XXX: Could not find a define for number of samples
//XXX: If there is one, replace the 10 in the last column with that

// Packet ROW_RAM
#define ROW_RAM_SIZE 251

#define ROW_RAM_SMP0_IN_ROW                     0

#define ROW_RAM_SMP1_IN_ROW                     0

#define ROW_RAM_SMP2_IN_ROW                     0

#define ROW_RAM_SMP3_IN_ROW                     0

#define ROW_RAM_SMP4_IN_ROW                     0

#define ROW_RAM_SMP5_IN_ROW                     0

#define ROW_RAM_SMP6_IN_ROW                     0

#define ROW_RAM_SMP7_IN_ROW                     0

#define ROW_RAM_SMP8_IN_ROW                     0

#define ROW_RAM_SMP9_IN_ROW                     0

#define ROW_RAM_SMP0_OUT_ROW                    0

#define ROW_RAM_SMP1_OUT_ROW                    0

#define ROW_RAM_SMP2_OUT_ROW                    0

#define ROW_RAM_SMP3_OUT_ROW                    0

#define ROW_RAM_SMP4_OUT_ROW                    0

#define ROW_RAM_SMP5_OUT_ROW                    0

#define ROW_RAM_SMP6_OUT_ROW                    0

#define ROW_RAM_SMP7_OUT_ROW                    0

#define ROW_RAM_SMP8_OUT_ROW                    0

#define ROW_RAM_SMP9_OUT_ROW                    0

#define ROW_RAM_SMP_COVERED_ROW                 0

// --------------------------------------------------------------------------
// 
// Copyright (c) 2005, LWPU Corp.
// All Rights Reserved.
// 
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of LWPU Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of LWPU Corp.
// 
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
// 
// --------------------------------------------------------------------------
// 
// LWE297_pseq.spec
//
//
// OVERVIEW:
// -------------------------------------
// PSEQ (Program Sequencer) controls the recirlwlation of pixels
// through the pixel pipeline.  PSEQ also performs unfiltered data reads,
// to fetch framebuffer data, instruction data, or spilled pixel data.
// PSEQ notifies the gatekeeper in QRAST when quads are removed from the
// recirlwlation loop.
// 
// GLOBAL REGISTERS:
// -------------------------------------
// PSEQ keeps a copy of the following global registers (see
// ar3d.spec for a description of global registers):
// * PIX_ATTR - first_sequence, num_rows, max_qid
// * RAISE - raise signal to send back to host module
// * INSTRUMENT - performance monitoring (mainly for stat gathering)
// * SURFDESC - description of the different surfaces PSEQ can read.
// * SURFADDR - base adddress of the surfaces PSEQ can read.
// * SPILLSURFADDR - base address for the pixel spill surface
// * DITHER_TABLE - to undither framebuffer color loads
//
// NOTES AND RESTRICTIONS: (Please especially note numbers 4 and 5)
// ---------------------------------------------
// 1. PSEQ will not recirlwlate register accesses.  Only SPANSTART
//    packets and pixel data will be recirlwlated.
// 
// 2. PSEQ has two local register regions.  One at the top of the
//    recirlwlation loop, and another at the bottom of the
//    recirlwlation loop.  Registers local to PSEQ_UPPER are not sent
//    on to the rest of the pixel pipeline.  Registers local to
//    PSEQ_LOWER are sent to the rest of the pixel pipeline, and are
//    removed when they arrive from the DWR interface.  This feature is
//    useful for registers that need to be updated at the end of the
//    pixel pipeline.  Registers that update the top of the pixel
//    pipeline like the FLUSH register do not enter the pipeline, but
//    will be discarded after flushing the pipeline.
// 
// 3. PSEQ is the only module in the pipeline that will discard pixel
//    data.  All pixel data will eventually return to the PSEQ from
//    the DWR through a feedback interface.  PSEQ keeps track of how
//    many times the pixel data has gone through the pipeline and
//    whether or not it needs to be retired.
//
// 4. The global PIX_ATTR register must be programmed correctly
//    before any pixel is sent down the pipeline.  
//
// 5. PSEQ has a command table and program counter to control the flow
//    of program fetch and exelwtion.  This functionality allows
//    shaders larger than the modules' instruction tables.  It also
//    allows multiple shaders to be linked together without knowing
//    about each other.  Further detail is in the COMMAND section
//
// 6. The unfiltered data reads are controlled using pseq's instruction
//    table.  Further detail is in the INST_DATA section
//
// LOCAL REGISTERS:
// --------------------------------------

// Register LWE297_PSEQ_FLUSH_0  
#define LWE297_PSEQ_FLUSH_0                                 0x500
// Trigger recirlwlation
// This does not flush any of the
// caches in TEX or DWR.  Also, because it's a local
// register write, PSEQ will discard it after
// flushing the pipeline, and it will not be seen
// by the lower modules (ATRAST, TEX, ALU, DWR).
// This register is safe to write to at any time.
// The value of the FLUSH field is irrelevant; it may
// be 0 or 1 and the FLUSH still oclwrs.
// Any register write will do the same, but this is
// a dummy pseq local register for the times we
// don't have another register we want to write.
// 
// FLUSH also has the side affect of restarting
// a stopped command unit.  This register
// should be in the gather dma stream after the
// last pseq register.  The sooner after the better.
// See GATHER.STOP for more detail
#define LWE297_PSEQ_FLUSH_0_FLUSH                          0:0

// CTL:  pseq control register
// Note: 
//   The largest legal value for CTL.MAX_OUT is 1006 (1023-17)
//   Normally a value this large would hang the fragment pipe.
//   There is an exception when all the exelwtes in the
//   command table are single pass and have STOP, DONE, 
//   or SPILL destinations.
//   There is no benefit to setting a value this large except
//   for testing
//
//   This register doesn't get sunk in pseq until the bottom of the fragment
//   pipe so pseq.dwr_if can see it.

// Register LWE297_PSEQ_CTL_0  
#define LWE297_PSEQ_CTL_0                           0x501
//cya bit, turns on redundant spanstart
// merging (P1 feature)
#define LWE297_PSEQ_CTL_0_MERGE_SPAN_STARTS                        0:0

//cya bit, turns on conselwtive register
// merging (P1 feature)
#define LWE297_PSEQ_CTL_0_MERGE_REGISTERS                          1:1

// Remove killed pixel from loop
// and replace with a spanstart. 
#define LWE297_PSEQ_CTL_0_REMOVE_KILLED_PIXELS                             2:2

// Hint to allow more than one quad
// with the same QID into the pseq fragment loop.
// This can be turned on when there is no 
// ST/LD_R20 or ST/LD_R80 ops in the fragment program. 
#define LWE297_PSEQ_CTL_0_ALLOW_QID_COLLISIONS                             3:3

// This is a high watermark that PSEQ will fill the
// pipeline to before recirlwlating the pixels
//  
// - When this register is set to 0, pseq goes into
// passthrough mode.  Passthrough mode ignores the 
// command table.  Pixels are processed in a single
// pass where the LWE297_GLOBAL_PIX_ATTR register provides
// the sequence start value for those pixels
// - Otherwise, this register should be set to the
// maximum number of entries in the pipeline less 16
// (largest atomic packet) for optimum performance.
// Setting this register to a higher value will hang
// the pipeline if pixels are recirlwlating
// The optimum recirlwlation value for MG20 is TBD
// (although 320 (0x140) has been used by h/w a lot,
// and 300 (0x12c) should be considered "safe")
#define LWE297_PSEQ_CTL_0_MAX_OUT                          13:4

// This is a low watermark that PSEQ will allow
// the pipeline to drain to before switching back
// out of recirlwlation mode.
//  
// - When recirlwlating pixels, this register 
// should be set to a value between 0 and MAX_OUT
// Setting this register closer to 0 will allow
// the pipeline to get more empty before filling
// again.  Setting a value closer to MAX_OUT will
// cause the pipeline to get more fragmented,
// which may effect cache efficiency.  
//
// Also, this register must be set to 0 for the following
// cases:
// * Single pass shaders.  This is because min_out is
//   only relevant in multipass pixel exelwtion
// * EXECUTE commands without STOP.  For example this command
//   program would need to set MIN_OUT to 0:
//     0 GATHER          0x0,    3
//     1 GATHER.P        0x1000, 500
//     2 GATHER          0x4,    3
//     3 GATHER.P        0x2000, 120
//     4 EXECUTE.RECIRC  0,      24 
//     5 EXECUTE.DONE    30,     4
//     6 BRANCH          ALWAYS, -2
//   while this command program could set MIN_OUT to some
//   value greater than 0:
//     0 GATHER.P        0x100,  500
//     1 EXECUTE.STOP    0,      24
//
// The optimum recirlwlation value for MG20 is TBD
#define LWE297_PSEQ_CTL_0_MIN_OUT                          23:14

// This register is in place, in case we want to do something if a
// shader runs for too long.  There are no current plans to do
// anything.  If we do anything it should be useful to software, and
// not to hard to implement.  Nothing proposed so far meets these goals.

// Register LWE297_PSEQ_TIMEOUT_0  
#define LWE297_PSEQ_TIMEOUT_0                               0x502
#define LWE297_PSEQ_TIMEOUT_0_COUNT                        31:0

// Indexes COMMAND. After each command exelwtes the PC is incremented.
// PC will wrap at the end of the COMMAND table. For example a PC value
// of LW_GR3D_NUM_PSEQ_COMMANDS is the same as a PC value of 0.

// Register LWE297_PSEQ_PC_0  
#define LWE297_PSEQ_PC_0                            0x503
#define LWE297_PSEQ_PC_0_PC                        3:0

// COMMAND contains 16 64 bit commands for pseq to execute.  PC
// indexes this table.  Longer command programs can be reload the
// table using GATHER.P
// 
// opcodes:
//
// GATHER   Gather data from memory and send down the fragment pipe as
//          register writes.  The register address can come from the data
//          read from memory, or can come from a field in this command.
//          The data read back is a dma stream defined by 
//          host1x.spec.  Supported DMA opcodes are INCR and NONINCR.
//
// EXECUTE  Execute a sequence of pixels.
//
// BRANCH   Update the PC to a new location.  
//          conditional branches are a P1 addition.
//          
//
// IMM      P1 feature to insert immediate register writes
//          (this feature has been partially tested by h/w, so s/w may be
//          interested in trying it out)
//
// ST       P1 feature to insert register reads for dw to store to memory
//
//
// Gather fields:
//      OPCODE:     set to GATHER
//      STOP:       Stop all pseq fragment processing while the
//                  gather is running.  A PC or FLUSH register
//                  write within the gather'ed stream will start
//                  pseq up again.
//
//                  This is used to synchronize the pseq with the
//                  registers returned from GATHER.
//
//                  If pseq does not see either of these register writes,
//                  it will wait until the last of the gather data returns
//                  from memory to start exelwting commands again.
//
//                  A dma stream that includes a PSEQ_COMMAND or PSEQ_PC
//                  register must always be gathered using the GATHER.STOP
//                  command.
//
//                  A dma stream that includes a register in the 3D global
//                  address space (like GLOBAL_INST_OFFSET) or a register
//                  in the PSEQ local address space (like PSEQ_INST_DATA)
//                  must use the STOP bit in the GATHER command that gathers
//                  the dma stream in question or in a following GATHER
//                  command but before an EXECUTE command.
//
//                  GATHER STOP Decision tree.
//                    if (dma stream has a PSEQ_COMMAND register or
//                        PSEQ_PC register or
//                        PSEQ_FLUSH register)
//                      GATHER STOP must be 1
//                    else if (dma stream has global or pseq local register)
//                      if (is last gather with global or pseq local registers before an execute command)
//                        GATHER STOP must be 1
//                      else
//                        GATHER STOP should be 0
//                    else
//                      GATHER STOP should be 0
//
//                  A GATHER.STOP can introduce memory latency based delays,
//                  so the chip can perform better when they are only used when
//                  required.
//
//                  legal, well performing examples  (the registers in the dma
//                  stream are listed after the GATHER)
//                    0 GATHER GLOBAL_INST_OFFSET
//                    1 GATHER.STOP PSEQ_INST_DATA + FLUSH
//                    2 EXECUTE
//
//                    0 GATHER GLOBAL_INST_OFFSET
//                    1 GATHER.STOP TEX_INST_DATA + FLUSH
//                    2 EXECUTE
//
//                    0 GATHER.STOP GLOBAL_INST_OFFSET + PSEQ_INST_DATA + FLUSH
//                    1 EXECUTE
//      OFFSET:     (P1 feature) Set to 0
//      INSERT:     (P1 feature) Set to DISABLE
//      TYPE:       (P1 feature) Set to NONINCR
//      COUNT:      Count of 32-bit words to be gathered from memory
//      ADDRESS     Base address of data to be gathered from memory
//                  must be 32-bit aligned
//
// Execute fields:
//      OPCODE:     set to EXECUTE
//      DEST:       destination for pixels at after all sequences
//                  complete.  Also indicates the source for the next
//                  EXECUTE opcode:
//                      RECIRC -- DWR
//                      SPILL  -- FDC
//                      DONE   -- QZ
//                      STOP   -- QZ  (also implies BRANCH 0)
//                  STOP dest will prevent the PC from incrementing.
//                  This can be used for single epoch shaders to
//                  prevent pseq from reloading redundant commands.
//                  STOP is preferred over DONE when a command program
//                  has only a single EXECUTE.  This is because
//                  EXECUTE.STOP is equivalent to an EXECUTE.DONE
//                  followed by a BRANCH ALWAYS -1, but it exelwtes
//                  faster.
//      START:      start sequence number (which sequence number is
//                  the pixels initialized to for the first pass)
//                  this is the start value for row 0 pixel packets
//                  other rows will increment the seq value.
//      COUNT:      total number of sequence numbers exelwted.  This
//                  number has to be an exact multiple of the number of
//                  rows.  (numRows * numPasses)
// Branch fields:
//      OPCODE:     set to BRANCH
//      COND:       condition -- set to ALWAYS 
//                        (other conditions are P1)
//      DEST:       signed offset from current PC (PC will have the
//                  offset added to it's current value instead of +1)
//
// EXAMPLE COMMAND SEQUENCES
//
// Format
// <pc> <opcode> <args>
//
// EXECUTE.S == execute.spill
// EXECUTE.P == execute.stop
// EXECUTE.D == execute.done
// EXECUTE.R == execute.recirc
//
// GATHER.P == gather.stop
//
//
// simple passthrough (single pass) shader
// 0 EXECUTE.P  0,  4
//
// simple single epoch shader
// 0 EXECUTE.P  0,  24
//
// fetch the instructions and execute (single epoch)
// 0 GATHER.P   0x100,  500
// 1 EXECUTE.P  0,      24
//
// When using a single execute command program, execute.stop is preferred over 
// execute.done.  A execute.done program will use more power and will run slower
// than a execute.stop program. For this reason we are not providing a single 
// execute, execute.done example.
//
// fetch the instructions and execute shader and postscript
// 0 GATHER     0x0,    3   // gather main relocation info
// 1 GATHER.P   0x1000, 500 // gather main shader
// 2 GATHER     0x4,    3   // gather postscript relocation info
// 3 GATHER.P   0x2000, 120 // gather postscript
// 4 EXECUTE.R  0,      24  // execute main shader   
// 5 EXECUTE.D  30,     4   // execute postscript and finish   
// 6 BRANCH     ALWAYS, -2  // branch back to 4 (don't need to reload)
//
//
// fetch the instructions/uniforms, and execute shaders. (2 epochs)
// 0 GATHER     0x0,    3   // gather main relocation info
// 1 GATHER.P   0x1000, 500 // gather main shader
// 2 EXECUTE.S  0,      60  // execute main shader and spill   
// 3 GATHER.P   0x1000, 500 // gather main shader
// 4 GATHER     0x4,    3   // gather postscript relocation info
// 5 GATHER.P   0x2000, 120 // gather postscript
// 6 EXECUTE.D  0,      40  // execute main and postscript shaders
// 7 BRANCH     ALWAYS, -7  // branch back to 0
//
//
//
// fetch the instructions, and execute shaders. (2 epochs)
// 0 GATHER.P   0x1000, 500 // gather main shader
// 1 EXECUTE.S  0,      60  // execute main shader and spill   
// 2 GATHER     0x1000, 500 // gather main shader
// 3 GATHER     0x4,    3   // gather postscript relocation info
// 4 GATHER.P   0x2000, 120 // gather postscript
// 5 EXECUTE.D  0,      40  // execute main and postscript
//                          // shaders
// 6 BRANCH     ALWAYS, -6  // branch back to 0
//
//
// command program longer than the command table.  This example 
// includes command table gathers 
//   command_table_0
//     0  GATHER    0x100,  3   // prologue relocation info
//     1  GATHER.P  0x1000, 500 // gather prologue shader
//     2  GATHER    0x103,  3   // main relocation info
//     3  GATHER.P  0x2000, 500 // gather main shader (epoch 1)
//     4  EXECUTE.R 0,      8   // execute prologue
//     5  EXECUTE.S 8,      62  // execute main (epoch 1) 
//     6  GATHER    0x100,  3   // main relocation info
//     7  GATHER.P  0x3000, 500 // gather main shader (epoch 2)
//     8  EXECUTE.S 0,      64  // execute main (epoch 2) 
//     9  GATHER    0x100,  3   // main relocation info
//     10 GATHER.P  0x4000, 500 // gather main shader (epoch 3)
//     11 EXECUTE.S 0,      64  // execute main (epoch 3) 
//     12 GATHER    0x100,  3   // main relocation info
//     13 GATHER.P  0x5000, 500 // gather main shader (epoch 4)
//     14 EXECUTE.S 0,      64  // execute main (epoch 4) 
//     15 GATHER.P  0x34,   34  //gather command_table_1 + pc
//     
//   command_table_1
//     0  GATHER    0x100,  3   // main relocation info
//     1  GATHER.P  0x6000, 500 // gather main shader (epoch 5)
//     2  EXECUTE.S 0,      64  // execute main (epoch 5)
//     3  GATHER.P  0x7000, 500 // gather main shader (epoch 6)
//     4  EXECUTE.D 0,      24  // execute main (epoch 5)
//     5  GATHER.P  0x0,    34  // gather command_table_0 + pc
//
//
// multiple uniform updates and command table update 
//  this example uses p1 gather features (the INCR stuff)
//  also this example requires extra space in pipeline for
//  gathers without spills (so MAX_OUT will have to be reduced)
//
// 0  GATHER.P  0x1000, 500 // gather prologue shader
// 1  GATHER    0x100,  3   // main relocation info
// 2  GATHER.P  0x2000, 500 // gather main shader (epoch 1)
// 3  EXECUTE.R 0,      8   // execute prologue
//
// gather uniforms (register address insertion P1)
// 4  GATHER    0x10024,4,  LWE297_ALU_GLOBALS[12],   INCR 
// 5  GATHER    0x10012,4,  LWE297_ALU_GLOBALS[0],    INCR 
//
// 6  EXECUTE.S 8,      62  //execute main
// 7  GATHER    0x103,  3   //main relocation info
// 8  GATHER.P  0x3000, 500 //gather main shader (epoch 2)
//
// gather uniforms (register address insertion P1)
// 9  GATHER    0x10000,4,  LWE297_ALU_GLOBALS[0],    INCR 
// 10 GATHER    0x10048,4,  LWE297_ALU_GLOBALS[4],    INCR 
// 11 GATHER    0x10012,4,  LWE297_ALU_GLOBALS[8],    INCR 
// 12 GATHER    0x1008, 4,  LWE297_ALU_GLOBALS[12],   INCR 
// 13 GATHER    0x10020,4,  LWE297_ALU_GLOBALS[16],   INCR 
// 14 GATHER    0x10024,4,  LWE297_ALU_GLOBALS[20],   INCR 
//
// 15 GATHER.P  0x34,   34  //gather command table + pc
//
//
// second pass
// gather uniforms (register address insertion P1)
// 0  GATHER    0x10024,4,  LWE297_ALU_GLOBALS[20],INCR 
//
// 1  EXECUTE.S 8,      62  //execute main
// 2  GATHER.P  0x4000, 500 //gather main shader (epoch 3)
//
// gather uniforms (register address insertion P1)
// 3  GATHER    0x10020,4,  LWE297_ALU_GLOBALS[0],    INCR 
// 4  GATHER    0x10032,4,  LWE297_ALU_GLOBALS[4],    INCR   
// 5  GATHER    0x10120,4,  LWE297_ALU_GLOBALS[8],    INCR   
// 6  GATHER    0x10000,4,  LWE297_ALU_GLOBALS[12],   INCR   
// 7  GATHER    0x10024,4,  LWE297_ALU_GLOBALS[16],   INCR   
// 8  GATHER    0x10004,8,  LWE297_ALU_GLOBALS[20],   INCR   
//
// 9  GATHER.P  0x5000, 120 // gather postscript
// 10 EXECUTE.D 0,      40  // execute main and postscript
//                          // shaders (stitched together)
// 11 GATHER.P  0x0,    34  // gather command table + pc
//
//
//
// HANG EXAMPLES, DO NOT EMULATE
//
// too many inserted packets without spill (max_out has to 
// be programmed to allow register writes and pixels to 
// coexist.)
// 0 EXECUTE.R  0,      8
// 1 GATHER     0x1000, 900
// 2 BRANCH     ALWAYS, -2
//
//
// branch to self
// 0 EXECUTE.D  0,      8
// 1 BRANCH     ALWAYS, 0
//
//
// loop without finish
// 0 EXECUTE.R  0,      8
// 1 BRANCH     ALWAYS, -1
//
//
// update command program without GATHER.P
// 0 GATHER      0x2000, 500 // gather main shader (epoch 1)
// 1 EXECUTE.S   0,      8   // execute main shader
// 2 GATHER      0x34,   34  // gather command table + pc
// 3 BRANCH      ALWAYS, -3  // will start exelwting 0, 1 
//                           // before command table is 
//                           // updated undefined behavior 
//                           // -- potential hang
//
// END HANG EXAMPLES, DO NOT EMULATE
//
//
// Register/Packet Defs for COMMAND

// Register LWE297_PSEQ_COMMAND_0  
#define LWE297_PSEQ_COMMAND_0                               0x520
#define LWE297_PSEQ_COMMAND_0_DATA                         31:0


// Register LWE297_PSEQ_COMMAND  
#define LWE297_PSEQ_COMMAND                                 0x520
#define LWE297_PSEQ_COMMAND_DATA                           31:0


// Register LWE297_PSEQ_COMMAND_1  
#define LWE297_PSEQ_COMMAND_1                               0x521
#define LWE297_PSEQ_COMMAND_1_DATA                         31:0


// Register LWE297_PSEQ_COMMAND_2  
#define LWE297_PSEQ_COMMAND_2                               0x522
#define LWE297_PSEQ_COMMAND_2_DATA                         31:0


// Register LWE297_PSEQ_COMMAND_3  
#define LWE297_PSEQ_COMMAND_3                               0x523
#define LWE297_PSEQ_COMMAND_3_DATA                         31:0


// Register LWE297_PSEQ_COMMAND_4  
#define LWE297_PSEQ_COMMAND_4                               0x524
#define LWE297_PSEQ_COMMAND_4_DATA                         31:0


// Register LWE297_PSEQ_COMMAND_5  
#define LWE297_PSEQ_COMMAND_5                               0x525
#define LWE297_PSEQ_COMMAND_5_DATA                         31:0


// Register LWE297_PSEQ_COMMAND_6  
#define LWE297_PSEQ_COMMAND_6                               0x526
#define LWE297_PSEQ_COMMAND_6_DATA                         31:0


// Register LWE297_PSEQ_COMMAND_7  
#define LWE297_PSEQ_COMMAND_7                               0x527
#define LWE297_PSEQ_COMMAND_7_DATA                         31:0


// Register LWE297_PSEQ_COMMAND_8  
#define LWE297_PSEQ_COMMAND_8                               0x528
#define LWE297_PSEQ_COMMAND_8_DATA                         31:0


// Register LWE297_PSEQ_COMMAND_9  
#define LWE297_PSEQ_COMMAND_9                               0x529
#define LWE297_PSEQ_COMMAND_9_DATA                         31:0


// Register LWE297_PSEQ_COMMAND_10  
#define LWE297_PSEQ_COMMAND_10                              0x52a
#define LWE297_PSEQ_COMMAND_10_DATA                        31:0


// Register LWE297_PSEQ_COMMAND_11  
#define LWE297_PSEQ_COMMAND_11                              0x52b
#define LWE297_PSEQ_COMMAND_11_DATA                        31:0


// Register LWE297_PSEQ_COMMAND_12  
#define LWE297_PSEQ_COMMAND_12                              0x52c
#define LWE297_PSEQ_COMMAND_12_DATA                        31:0


// Register LWE297_PSEQ_COMMAND_13  
#define LWE297_PSEQ_COMMAND_13                              0x52d
#define LWE297_PSEQ_COMMAND_13_DATA                        31:0


// Register LWE297_PSEQ_COMMAND_14  
#define LWE297_PSEQ_COMMAND_14                              0x52e
#define LWE297_PSEQ_COMMAND_14_DATA                        31:0


// Register LWE297_PSEQ_COMMAND_15  
#define LWE297_PSEQ_COMMAND_15                              0x52f
#define LWE297_PSEQ_COMMAND_15_DATA                        31:0


// Register LWE297_PSEQ_COMMAND_16  
#define LWE297_PSEQ_COMMAND_16                              0x530
#define LWE297_PSEQ_COMMAND_16_DATA                        31:0


// Register LWE297_PSEQ_COMMAND_17  
#define LWE297_PSEQ_COMMAND_17                              0x531
#define LWE297_PSEQ_COMMAND_17_DATA                        31:0


// Register LWE297_PSEQ_COMMAND_18  
#define LWE297_PSEQ_COMMAND_18                              0x532
#define LWE297_PSEQ_COMMAND_18_DATA                        31:0


// Register LWE297_PSEQ_COMMAND_19  
#define LWE297_PSEQ_COMMAND_19                              0x533
#define LWE297_PSEQ_COMMAND_19_DATA                        31:0


// Register LWE297_PSEQ_COMMAND_20  
#define LWE297_PSEQ_COMMAND_20                              0x534
#define LWE297_PSEQ_COMMAND_20_DATA                        31:0


// Register LWE297_PSEQ_COMMAND_21  
#define LWE297_PSEQ_COMMAND_21                              0x535
#define LWE297_PSEQ_COMMAND_21_DATA                        31:0


// Register LWE297_PSEQ_COMMAND_22  
#define LWE297_PSEQ_COMMAND_22                              0x536
#define LWE297_PSEQ_COMMAND_22_DATA                        31:0


// Register LWE297_PSEQ_COMMAND_23  
#define LWE297_PSEQ_COMMAND_23                              0x537
#define LWE297_PSEQ_COMMAND_23_DATA                        31:0


// Register LWE297_PSEQ_COMMAND_24  
#define LWE297_PSEQ_COMMAND_24                              0x538
#define LWE297_PSEQ_COMMAND_24_DATA                        31:0


// Register LWE297_PSEQ_COMMAND_25  
#define LWE297_PSEQ_COMMAND_25                              0x539
#define LWE297_PSEQ_COMMAND_25_DATA                        31:0


// Register LWE297_PSEQ_COMMAND_26  
#define LWE297_PSEQ_COMMAND_26                              0x53a
#define LWE297_PSEQ_COMMAND_26_DATA                        31:0


// Register LWE297_PSEQ_COMMAND_27  
#define LWE297_PSEQ_COMMAND_27                              0x53b
#define LWE297_PSEQ_COMMAND_27_DATA                        31:0


// Register LWE297_PSEQ_COMMAND_28  
#define LWE297_PSEQ_COMMAND_28                              0x53c
#define LWE297_PSEQ_COMMAND_28_DATA                        31:0


// Register LWE297_PSEQ_COMMAND_29  
#define LWE297_PSEQ_COMMAND_29                              0x53d
#define LWE297_PSEQ_COMMAND_29_DATA                        31:0


// Register LWE297_PSEQ_COMMAND_30  
#define LWE297_PSEQ_COMMAND_30                              0x53e
#define LWE297_PSEQ_COMMAND_30_DATA                        31:0


// Register LWE297_PSEQ_COMMAND_31  
#define LWE297_PSEQ_COMMAND_31                              0x53f
#define LWE297_PSEQ_COMMAND_31_DATA                        31:0

//Generic packet type for COMMAND TABLE

// Packet LWE297_PSEQ_CMD
#define LWE297_PSEQ_CMD_SIZE 32

#define LWE297_PSEQ_CMD_OPCODE_ROW                        0
#define LWE297_PSEQ_CMD_OPCODE_GATHER                     0x00000000
#define LWE297_PSEQ_CMD_OPCODE_EXELWTE                    0x00000001
#define LWE297_PSEQ_CMD_OPCODE_BRANCH                     0x00000002
#define LWE297_PSEQ_CMD_OPCODE_IMM                        0x00000003
#define LWE297_PSEQ_CMD_OPCODE_ST                 0x00000004

#define LWE297_PSEQ_CMD_ARGS0_ROW                 0

#define LWE297_PSEQ_CMD_ARGS1_ROW                 1


// Packet LWE297_PSEQ_GATHER
#define LWE297_PSEQ_GATHER_SIZE 32

// Register Gather
#define LWE297_PSEQ_GATHER_OPCODE                         31:29
#define LWE297_PSEQ_GATHER_OPCODE_GATHER                  0x00000000

// Stop all pseq fragment processing while the
// gather is running.  A PC or FLUSH register
// write within the gather'ed stream will start
// pseq up again.
//
// This is used to synchronize the pseq with the
// registers returned from GATHER.
//
// If pseq does not see either of these register writes,
// it will wait until the last of the gather data returns
// from memory to start exelwting commands again.
//
// A dma stream that includes a PSEQ_COMMAND or PSEQ_PC
// register must always be gathered using the GATHER.STOP
// command.
//
// A dma stream that includes a register in the 3D global
// address space (like GLOBAL_INST_OFFSET) or a register
// in the PSEQ local address space (like PSEQ_INST_DATA)
// must use the STOP bit in the GATHER command that gathers
// the dma stream in question or in a following GATHER
// command but before an EXECUTE command.
//
// GATHER STOP Decision tree.
//   if (dma stream has a PSEQ_COMMAND register or
//                        PSEQ_PC register or
//                        PSEQ_FLUSH register)
//     GATHER STOP must be 1
//   else if (dma stream has global or pseq local register)
//     if (is last gather with global or pseq local registers before an execute command)
//       GATHER STOP must be 1
//     else
//       GATHER STOP should be 0
//   else
//     GATHER STOP should be 0
//
// A GATHER.STOP can introduce memory latency based delays,
// so the chip can perform better when they are only used when
// required.
//
// legal, well performing examples  (the registers in the dma stream are listed after the GATHER)
// 0 GATHER GLOBAL_INST_OFFSET
// 1 GATHER.STOP PSEQ_INST_DATA + FLUSH
// 2 EXECUTE
//
// 0 GATHER GLOBAL_INST_OFFSET
// 1 GATHER.STOP TEX_INST_DATA + FLUSH
// 2 EXECUTE
//
// 0 GATHER.STOP GLOBAL_INST_OFFSET + PSEQ_INST_DATA + FLUSH
// 1 EXECUTE
#define LWE297_PSEQ_GATHER_STOP                           28:28

// (P1 feature) Starting offset (if
// putting opcode into the stream)
#define LWE297_PSEQ_GATHER_OFFSET                         27:16

// (P1 feature) Insert an opcode (type set
// by TYPE, initial offset set by OFFSET)
// immediately before the gathered data stream. 
#define LWE297_PSEQ_GATHER_INSERT                         15:15
#define LWE297_PSEQ_GATHER_INSERT_DISABLE                 0x00000000
#define LWE297_PSEQ_GATHER_INSERT_ENABLE                  0x00000001

// (P1 feature) Type of opcode to be inserted (incrementing or 
// non-incrementing).  Only valid if INSERT is enabled.
#define LWE297_PSEQ_GATHER_TYPE                           14:14
#define LWE297_PSEQ_GATHER_TYPE_NONINCR                   0x00000000
#define LWE297_PSEQ_GATHER_TYPE_INCR                      0x00000001

// Hint the cache to keep the gather 
// reads persistent
#define LWE297_PSEQ_GATHER_CACHE_PERSISTENT               13:13

// Count of 32-bit words to be gathered from memory
#define LWE297_PSEQ_GATHER_COUNT                          12:0

// Base address of chunk to be gathered from memory.  The address is given in words.
#define LWE297_PSEQ_GATHER_ADDRESS                        31:0


// Packet LWE297_PSEQ_EXELWTE
#define LWE297_PSEQ_EXELWTE_SIZE 32

// Instruction execute
#define LWE297_PSEQ_EXELWTE_OPCODE                        31:29
#define LWE297_PSEQ_EXELWTE_OPCODE_EXELWTE                0x00000001

#define LWE297_PSEQ_EXELWTE_UNUSED0                       28:21

// If this execute has a RECIRC dest this must
// be set to the next execute's start
#define LWE297_PSEQ_EXELWTE_NEXT_START                    20:15

// where do the pixels go when execute finishes
#define LWE297_PSEQ_EXELWTE_DEST                          14:13
#define LWE297_PSEQ_EXELWTE_DEST_RECIRC                   0x00000000
#define LWE297_PSEQ_EXELWTE_DEST_SPILL                    0x00000001
#define LWE297_PSEQ_EXELWTE_DEST_DONE                     0x00000002
#define LWE297_PSEQ_EXELWTE_DEST_STOP                     0x00000003

// sequence start index
#define LWE297_PSEQ_EXELWTE_START                         12:7

// sequence count (numRows * numPasses)
#define LWE297_PSEQ_EXELWTE_COUNT                         6:0

#define LWE297_PSEQ_EXELWTE_UNUSED1                       31:0


// Packet LWE297_PSEQ_BRANCH
#define LWE297_PSEQ_BRANCH_SIZE 32

// Command Branch
#define LWE297_PSEQ_BRANCH_OPCODE                         31:29
#define LWE297_PSEQ_BRANCH_OPCODE_BRANCH                  0x00000002

// condition code 
// (ALWAYS is the only cond supported, others P1)
#define LWE297_PSEQ_BRANCH_COND                           28:26
#define LWE297_PSEQ_BRANCH_COND_ALWAYS                    0x00000000
#define LWE297_PSEQ_BRANCH_COND_NEVER                     0x00000001
#define LWE297_PSEQ_BRANCH_COND_AND                       0x00000002
#define LWE297_PSEQ_BRANCH_COND_NAND                      0x00000003
#define LWE297_PSEQ_BRANCH_COND_OR                        0x00000004
#define LWE297_PSEQ_BRANCH_COND_NOR                       0x00000005

// signed offset from PC
// to branch to.
#define LWE297_PSEQ_BRANCH_DEST                           4:0

#define LWE297_PSEQ_BRANCH_UNUSED1                        31:0

//not supported.  P1

// Packet LWE297_PSEQ_IMM
#define LWE297_PSEQ_IMM_SIZE 32

// Immediate register write
#define LWE297_PSEQ_IMM_OPCODE_ROW                        0
#define LWE297_PSEQ_IMM_OPCODE_IMM                        0x00000003

// register offset
#define LWE297_PSEQ_IMM_OFFSET_ROW                        0

#define LWE297_PSEQ_IMM_UNUSED_ROW                        0

// immediate data
#define LWE297_PSEQ_IMM_IMMDATA_ROW                       1

//not supported. P1

// Packet LWE297_PSEQ_ST
#define LWE297_PSEQ_ST_SIZE 32

// Store register to memory
#define LWE297_PSEQ_ST_OPCODE_ROW                 0
#define LWE297_PSEQ_ST_OPCODE_ST                  0x00000004

// register offset
#define LWE297_PSEQ_ST_OFFSET_ROW                 0

// surface (indexes SURFDESC)
#define LWE297_PSEQ_ST_SURF_ROW                   0

// How do we callwlate the offset (incrementing 
// or non-incrementing). 
#define LWE297_PSEQ_ST_TYPE_ROW                   0
#define LWE297_PSEQ_ST_TYPE_NONINCR                       0x00000000
#define LWE297_PSEQ_ST_TYPE_INCR                  0x00000001

#define LWE297_PSEQ_ST_COUNT_ROW                  0

#define LWE297_PSEQ_ST_UNUSED1_ROW                        1

//
// Instruction table offset: controls what indirect entry in the instruction table gets accessed.
// INDEX auto-increments with each access to INST_DATA.
//

// Register LWE297_PSEQ_INST_OFFSET_0  
#define LWE297_PSEQ_INST_OFFSET_0                           0x540
// current read or write target in INST_DATA
#define LWE297_PSEQ_INST_OFFSET_0_INDEX                            5:0

//
//  INST -- An array of pseq load instructions
//
// Pixels flow through the pipeline in "pixel packets".  A given pixel is
// expressed in one to four rows of pixel data, with each row containing four
// 20 bit fields.  These fields typically hold either a 20 bit floating point
// value or two 10 bit fixed point values.  One to four rows of data logically
// constitute a pixel packet.
//
// Pixel packets may recirlwlate through multiple fragment pipe units multiple
// times in order to carry out a complex shader.  In order to keep track of
// things, each row of a pixel packet is assigned a sequence number.  A sequence
// number is unique to a given row and pass of a pixel packet, and is controlled
// by the global register PIX_ATTR, or by pseq's execute command.
//
// Once pseq looks up the proper instruction it will perform the instruction
// indicated (either nop, or load)
// the 
//
// INST fields:
//  OP controls whether or not to preform a load, and what kind of
//      load to do
//
//      NOP --  No operation
//
//      LD  --  Load from memory.  Surfaces read from are described in
//              the SURFDESC section of ar3d.spec supported formats
//              are as follows:
//
//          Raw only:
//              C4X4,
//              Z16, 
//              Z16NL,
//          FX10 colwersion:
//              A8, 
//              L8, 
//              S8,
//              L8A8,
//              B2G3R3,
//              B5G6R5, 
//              B5G5R5A1, 
//              B4G4R4A4,
//              A1B5G5R5, 
//              A4B4G4R4,
//              R8G8B8A8, 
//              B8G8R8A8,
//          FP20 colwersion:
//              A16_float,
//              L16_float,
//              L16A16_float,
//              R16G16B16A16_float,
//              R11G11B10_float,
//
//      LD_R20 -- Load a register from memory.  
//          P32_float
//          P128
//
//      LD_R80 -- Load a register from memory.  
//          P128
//
// Not Supported: DXT1, DXT1C, DXT3, DXT5, ETC, ETC3, ETC5, LATC1, LATC2,
//                R10G10B10_float_A2, B8G8R8G8, G8B8G8R8
//
//
//  READ_KILLED controls whether to perform a load with killed pixels
//      All pixels with a load instruction will perform the load if
//      this bit is set
//      If this bit is disabled the following combinations of pixel
//      state and surface format will perform loads:
//
//      STENCIL will load on S_FAIL Z_FAIL Z_PASS 
//      All other formats will load on Z_PASS 
//
//  READ_NON_CENTER controls whether to perform a load with non_center pixels
//      In addition to the cases listed with the READ_KILLED description, pseq
//      will load in the following cases if READ_NON_CENTER is set
//
//      All formats will load when the pixel is in the NON_CENTER state 
//
//  SURF is an index into the SURFDESC and SURFADDR to describe the target of
//      the load
// 
//  ARGS Opcode specific arguments
// 
//    LD_ARGS -- The arguments for the INST_DATA::eOP_LD opcode
//
//      REG, MOD select a half register output location for the result
//        of the load.  Additional bits from the load will go into
//        adjacent registers (with wrap so that the destination register
//        after R3.H is R0.L)
//
//        10 Bit Destination Load: (REG.MOD -> Registers used)
//        R0.L    -> R0.L
//        R0.H    -> R0.H
//        R1.L    -> R1.L
//        ...
//        R3.H    -> R3.H
//        
//        20 Bit Destination Load: (REG.MOD -> Registers used)
//        R0.L    -> R0.L, R0.H
//        R0.H    -> R0.H, R1.L
//        R1.L    -> R1.L, R1.H
//        ...
//        R3.H    -> R3.H, R0.L
//        
//        30 Bit Destination Load: (REG.MOD -> Registers used)
//        R0.L    -> R0.L, R0.H, R1.L
//        R0.H    -> R0.H, R1.L, R1.H
//        R1.L    -> R1.L, R1.H, R2.L
//        ...
//        R3.H    -> R3.H, R0.L, R0.H
//        
//        40 Bit Destination Load: (REG.MOD -> Registers used)
//        R0.L    -> R0.L, R0.H, R1.L, R1.H
//        R0.H    -> R0.H, R1.L, R1.H, R2.L
//        R1.L    -> R1.L, R1.H, R2.L, R2.H
//        ...
//        R3.H    -> R3.H, R0.L, R0.H, R1.L
//        
//        ...
//        ... (skipping 50, 60, and 70 bit destination loads)
//        ...
//        
//        80 Bit Destination Load: (REG.MOD -> Registers used)
//        R0.L    -> R0.L, R0.H, R1.L, R1.H, R2.L, R2.H, R3.L, R3.H
//        R0.H    -> R0.H, R1.L, R1.H, R2.L, R2.H, R3.L, R3.H, R0.L
//        R1.L    -> R1.L, R1.H, R2.L, R2.H, R3.L, R3.H, R0.L, R0.H
//        ...
//        R3.H    -> R3.H, R0.L, R0.H, R1.L, R1.H, R2.L, R2.H, R3.L
//        
//        component ordering is always red,green,blue,alpha from lsb to msb
//        
//        Fixed point formats load into FX10 registers. For example:
//        
//        REG.MOD==R0.L:     red   -> R0, low
//                           green -> R0, high
//                           blue  -> R1, low
//                           alpha -> R1, high
//        
//        If the format in memory does not contain all the color components the
//        missing components get filled in like this:
//        A8           --   (0x00,0x00,0x00,A   ) 
//        L8           --   (L   ,L   ,L   ,0xFF)
//        L8A8         --   (L   ,L   ,L   ,A   )
//        B2G3R3       --   (R   ,G   ,B   ,0xFF)
//        B5G6R5       --   (R   ,G   ,B   ,0xFF)
//        
//        Floating point formats load into FP20 register. For example:
//        REG.MOD==R0.L:     red   -> R0
//                           green -> R1
//                           blue  -> R2
//                           alpha -> R3
//        
//        Like fixed point formats, if the format in memory does not contain all
//        the color components the missing components get filled in like this:
//        A16_float       --  (0.0 , A  )
//        L16_float       --  (L   , 1.0)
//        L16A16_float    --  (L   , A  )
//        R11G11B10_float --  (R   , G  , B  )
//
//      CLW  If set the load will put the result of a format colwersion in
//        the registers indicated by REG and MOD.
//
//      RAW  If set the load will put the uncolwerted bits of the surface
//        load into the register pair adjacent to the register pair
//        indicated by REG, MOD.
//            REG.MOD     ->  RAW REG.MOD
//            R0.L        ->  R2.L
//            R0.H        ->  R2.H
//            R1.L        ->  R3.L
//            R1.H        ->  R3.H
//            R2.L        ->  R0.L
//            R2.H        ->  R0.H
//            R3.L        ->  R1.L
//            R3.H        ->  R1.H
//
//        The raw bits are packed unchanged into the lsb bits of the lowest
//        specified registers.  For example:
//          REG.MOD==R0.L:
//            8bit formats   ->  R0.L          < 7:0>
//            16bit formats  ->  R0            <16:0>
//            32bit formats  ->  R0,R1         <31:0>
//            64bit formats  ->  R0,R1,R2,R3.L <63:0>
//          
//      Because the fields would overlap, the following formats have undefined 
//      results if both RAW and CLW are enabled:
//      R11G11B10_float
//      R16G16B16A16_float
//
//      LD Args Format
//        Bit        Description
//        1:0        REG: Selects which FP20 register to load
//                                  0 = R0
//                                  1 = R1
//                                  2 = R2
//                                  3 = R3
//        2          MOD:  Selects which half word to load.
//                                  0 = L
//                                  1 = H
//        3          CLW: Load format colwerted bits into REG.MOD
//                                  0 = DISABLE
//                                  1 = ENABLE
//        4          RAW: Load raw  bits into REG+2.MOD
//                                  0 = DISABLE
//                                  1 = ENABLE
//
//
//    LD_R20_ARGS -- The arguments for the INST_DATA::eOP_LD_R20 opcode
//
//    REG  select a register output location for the result of the
//        load.  
//        read to be written to associated half register.  Bit 0 masks
//        the low half-register, and Bit 1 masks the high half-register.
//    
//      OFFSET_REG_EN If enabled the offset for the LD_R20 will come from
//        the half-register specified by OFFSET_REG and OFFSET_MOD.
//        Otherwise, the offset will come from the OFFSET_IMM field.
//        The OFFSET_IMM field overlaps the OFFSET_REG and OFFSET_MOD
//        fields, so they should not be used at the same time.
//    
//      OFFSET_IMM Index into the register array. Used if OFFSET_REG_EN is
//        DISABLED.
//    
//        If the surface is P128 the lower two bits are used to select
//        the 32 bit word from the 128 bit surface. The next 6 bits are
//        used to stride across the surface.
//    
//        If the surface is P32_float all 8 bits are used to stride
//        across the surface.
//    
//      OFFSET_REG, OFFSET_MOD Select the half-register the 8 bit offset
//        will come from.  Used if OFFSET_REG_EN is ENABLED.
//    
//        If the surface is P128 the lower two bits of the selected
//        half-register are used to select the 32 bit word from the 128
//        bit surface. The upper 6 bits are used to stride across the
//        surface.
//    
//        If the surface is P32_float the lower 8 bits of the selected
//        register are used to stride across the surface.
//    
//      OFFSET_TYPE Determines whether there is a unique memory address
//        for each pixel in the pipeline, or a shared memory address
//        for all pixels.  Please see GLOBAL_SURFDEST.ARRAY_STRIDE for
//        info about the different surface stride requirements between LOCAL
//        versus GLOBAL offset types
//        
//        LOCAL  -- unique memory location per pixel, used for temporary pixel data 
//                  storage
//        GLOBAL -- shared memory location for all pixels, can be used for constants
//                  and other global values.
//
//      LD_R20 Args Format
//        Bit        Description
//        1:0        REG: Select which FP20 register to load
//                                  0 = R0
//                                  1 = R1
//                                  2 = R2
//                                  3 = R3
//        13:6       OFFSET_IMM: Used for array formats, 
//                                  index into the array if
//                                  OFFSET_REG_EN == DISABLE
//        9:8        OFFSET_REG: Specifies which register contains
//                                  the 8 bit offset
//                                  0 = R0
//                                  1 = R1
//                                  2 = R2
//                                  3 = R3
//        10         OFFSET_MOD: Specifies which half word contains 
//                                  the 8 bit offset
//                                  0 = L
//                                  1 = H
//        14         OFFSET_REG_EN: Enable offset reg
//                                  0 = DISABLE
//                                  1 = ENABLE
//        
//        15         OFFSET_TYPE: Is the offset a local offset or 
//                                  global offset.
//                                  A local offset uses QID, and offset to 
//                                  determine the memory address, while a global
//                                  offset just uses offset.
//                                  0 = LOCAL
//                                  1 = GLOBAL 
//
//    LD_R80_ARGS -- The arguments for the INST_DATA::eOP_LD_R80 opcode
//    
//        read to be written to associated half register.  
//        ...
//    
//      OFFSET_REG_EN If enabled the offset for the LD_R80 will come from
//        the half-register specified by OFFSET_REG and OFFSET_MOD.
//        Otherwise, the offset will come from the OFFSET_IMM field.
//        The OFFSET_IMM field overlaps the OFFSET_REG and OFFSET_MOD
//        fields, so they should not be used at the same time.
//    
//      OFFSET_IMM Index into the register array. Used if OFFSET_REG_EN is
//        DISABLED.
//    
//        All 6 bits are used to stride across the surface
//    
//      OFFSET_REG, OFFSET_MOD Select the half-register the 6 bit offset
//        will come from.  Used if OFFSET_REG_EN is ENABLED.
//    
//      OFFSET_TYPE  Is there a unique memory address for each pixel in the
//        pipeline, or do all pixels share the same memory address.
//    
//        LOCAL  -- unique address per pixel, used for register spill
//        GLOBAL -- shared address per pixel, can be used for constants
//                  and other global values.
//
//    LD_R80 Args Format
//      Bit        Description
//      13:8       OFFSET_IMM: Used for array formats, 
//                                index into the array if
//                                OFFSET_REG_EN == DISABLE
//      9:8        OFFSET_REG:  Specifies which register contains
//                                the 6 bit offset
//                                0 = R0
//                                1 = R1
//                                2 = R2
//                                3 = R3
//      10         OFFSET_MOD: Specifies which half word contains 
//                                the 6 bit offset
//                                0 = L
//                                1 = H
//      14         OFFSET_REG_EN: Enable offset reg
//                                0 = DISABLE
//                                1 = ENABLE
//
//      15         OFFSET_TYPE: Is the offset a local offset or 
//                                global offset.
//                                A local offset uses QID, and offset to determine
//                                the memory address, while a global offset just
//                                uses offset.
//                                0 = LOCAL
//                                1 = GLOBAL 
//
//

// Register LWE297_PSEQ_INST_DATA_0  
#define LWE297_PSEQ_INST_DATA_0                             0x541
// opcode
#define LWE297_PSEQ_INST_DATA_0_OP                         24:23
#define LWE297_PSEQ_INST_DATA_0_OP_NOP                    0x00000000
#define LWE297_PSEQ_INST_DATA_0_OP_LD                     0x00000001
#define LWE297_PSEQ_INST_DATA_0_OP_LD_R20                 0x00000002
#define LWE297_PSEQ_INST_DATA_0_OP_LD_R80                 0x00000003

// set if load should stay in the fdc cache
#define LWE297_PSEQ_INST_DATA_0_CACHE_PERSISTENT                           22:22

// If ENABLED read pixel even if not in Z_PASS state.
#define LWE297_PSEQ_INST_DATA_0_READ_KILLED                        21:21
#define LWE297_PSEQ_INST_DATA_0_READ_KILLED_DISABLE                       0x00000000
#define LWE297_PSEQ_INST_DATA_0_READ_KILLED_ENABLE                        0x00000001

// If ENABLED read pixel even if  in NON_CENTER state.
#define LWE297_PSEQ_INST_DATA_0_READ_NON_CENTER                            20:20
#define LWE297_PSEQ_INST_DATA_0_READ_NON_CENTER_DISABLE                   0x00000000
#define LWE297_PSEQ_INST_DATA_0_READ_NON_CENTER_ENABLE                    0x00000001

// surface descriptor index for read operations
#define LWE297_PSEQ_INST_DATA_0_SURF                               19:16

// see packets LD_*_ARGS below
#define LWE297_PSEQ_INST_DATA_0_ARGS                               15:0

//WARNING any changes to this packet needs to be
//  reflected in the comments above

// Packet LD_ARGS
#define LD_ARGS_SIZE 16

//Which register is the destination of the load
#define LD_ARGS_REG_ROW                 0
#define LD_ARGS_REG_R0                  0x00000000
#define LD_ARGS_REG_R1                  0x00000001
#define LD_ARGS_REG_R2                  0x00000002
#define LD_ARGS_REG_R3                  0x00000003

//which half word is the destination of the load
#define LD_ARGS_MOD_ROW                 0
#define LD_ARGS_MOD_L                   0x00000000
#define LD_ARGS_MOD_H                   0x00000001

//load format colwerted bits into REG
#define LD_ARGS_CLW_ROW                 0
#define LD_ARGS_CLW_DISABLE                     0x00000000
#define LD_ARGS_CLW_ENABLE                      0x00000001

//if enabled load the raw bits into the adjacent
#define LD_ARGS_RAW_ROW                 0
#define LD_ARGS_RAW_DISABLE                     0x00000000
#define LD_ARGS_RAW_ENABLE                      0x00000001

#define LD_ARGS_RESERVED_ROW                    0

//WARNING any changes to this packet needs to be
//  reflected in the comments above

// Packet LD_R20_ARGS
#define LD_R20_ARGS_SIZE 16

//Which FP20 register to load
#define LD_R20_ARGS_REG_ROW                     0
#define LD_R20_ARGS_REG_R0                      0x00000000
#define LD_R20_ARGS_REG_R1                      0x00000001
#define LD_R20_ARGS_REG_R2                      0x00000002
#define LD_R20_ARGS_REG_R3                      0x00000003

//which L/H bits are read.

//offset -- used for array formats, 
//          index into the array if
//          OFFSET_REG_EN == DISABLE
#define LD_R20_ARGS_OFFSET_IMM_ROW                      0

//which register contains the 8 bit offset
#define LD_R20_ARGS_OFFSET_REG_ROW                      0
#define LD_R20_ARGS_OFFSET_REG_R0                       0x00000000
#define LD_R20_ARGS_OFFSET_REG_R1                       0x00000001
#define LD_R20_ARGS_OFFSET_REG_R2                       0x00000002
#define LD_R20_ARGS_OFFSET_REG_R3                       0x00000003

//which half word contains the 8 bit offset
#define LD_R20_ARGS_OFFSET_MOD_ROW                      0
#define LD_R20_ARGS_OFFSET_MOD_L                        0x00000000
#define LD_R20_ARGS_OFFSET_MOD_H                        0x00000001

//enable offset reg
#define LD_R20_ARGS_OFFSET_REG_EN_ROW                   0
#define LD_R20_ARGS_OFFSET_REG_EN_DISABLE                       0x00000000
#define LD_R20_ARGS_OFFSET_REG_EN_ENABLE                        0x00000001

//Is the offset a local offset or global offset
//a local offset uses x,y,offset to determine
//address, a global offset just uses offset.
#define LD_R20_ARGS_OFFSET_TYPE_ROW                     0
#define LD_R20_ARGS_OFFSET_TYPE_LOCAL                   0x00000000
#define LD_R20_ARGS_OFFSET_TYPE_GLOBAL                  0x00000001

//WARNING any changes to this packet needs to be
//  reflected in the comments above

// Packet LD_R80_ARGS
#define LD_R80_ARGS_SIZE 16

//Which FX10 registers to load

//offset -- used for array formats, 
//          index into the array if
//          OFFSET_REG_EN == DISABLE
#define LD_R80_ARGS_OFFSET_IMM_ROW                      0

//which register contains the 8 bit offset
#define LD_R80_ARGS_OFFSET_REG_ROW                      0
#define LD_R80_ARGS_OFFSET_REG_R0                       0x00000000
#define LD_R80_ARGS_OFFSET_REG_R1                       0x00000001
#define LD_R80_ARGS_OFFSET_REG_R2                       0x00000002
#define LD_R80_ARGS_OFFSET_REG_R3                       0x00000003

//which half word contains the 8 bit offset
#define LD_R80_ARGS_OFFSET_MOD_ROW                      0
#define LD_R80_ARGS_OFFSET_MOD_L                        0x00000000
#define LD_R80_ARGS_OFFSET_MOD_H                        0x00000001

//enable offset reg
#define LD_R80_ARGS_OFFSET_REG_EN_ROW                   0
#define LD_R80_ARGS_OFFSET_REG_EN_DISABLE                       0x00000000
#define LD_R80_ARGS_OFFSET_REG_EN_ENABLE                        0x00000001

//Is the offset a local offset or global offset
//a local offset uses x,y,offset to determine
//address, a global offset just uses offset.
#define LD_R80_ARGS_OFFSET_TYPE_ROW                     0
#define LD_R80_ARGS_OFFSET_TYPE_LOCAL                   0x00000000
#define LD_R80_ARGS_OFFSET_TYPE_GLOBAL                  0x00000001

// DBG  -- Filter debug information
//
//   debug information (cmodel debug statements, instrumentation, etc)
//   will be controlled by the following DBG registers by this
//   formula:
//
//      
// DBG = (((DBG_X_EN == DISABLE)          | ((X >= DBX_X.START) && (X <= DBX_X.END)))
//        && ((DBG_Y_EN == DISABLE)       | ((Y >= DBX_Y.START) && (Y <= DBX_Y.END)))
//        && ((DBG_SEQ_EN == DISABLE)     | ((SEQ >= DBG_CTL.SEQ_START) && (SEQ <= DBG_CTL.SEQ_END)))
//        && ((DBG_COMMAND_EN == DISABLE) | (PC == DBG_CTL.COMMAND)))
// where DBG == 1 means debug is enabled and DBG == 0 means debug
// is disabled
// 
// In other words, debugging will be enabled unless an enabled test fails.
// Command allows us to get a range of sequence numbers by putting
// that range into a single EXECUTE command
// 
// The DBG bit in the pixel packet should be used by all fragment pipe
// modules to turn off instrumentation 
//    (if DBG==0 turn off instrumentation)  
// It should also be used by cmodel to turn off debug messages.  (if
// DBG==0 turn off debug msgs)
//
// Note:  One PSEQ stat PSEQ_RETWAIT.STEN cannot use dbg because it counting 
// how long it is waiting for the pixel packet to come from memory.  
// Since it doesn't know what the packet's dbg bit or x,y is set to, it doesn't 
// know to toggle the stat bit.  This stat will use SEQ and PC to filter, 
// but not X or Y.
// X range -- if DBG_X_EN is enabled then we disable debug for pixels
// outside the range [START,END]

// Register LWE297_PSEQ_DBG_X_0  
#define LWE297_PSEQ_DBG_X_0                                 0x542
#define LWE297_PSEQ_DBG_X_0_START                          21:11

#define LWE297_PSEQ_DBG_X_0_END                            10:0

// Y range -- if DBG_X_EN is enabled then we disable debug for pixels
// outside the range [START,END]

// Register LWE297_PSEQ_DBG_Y_0  
#define LWE297_PSEQ_DBG_Y_0                                 0x543
#define LWE297_PSEQ_DBG_Y_0_START                          21:11

#define LWE297_PSEQ_DBG_Y_0_END                            10:0

// SEQ and COMMAND compare values, and enables.

// Register LWE297_PSEQ_DBG_CTL_0  
#define LWE297_PSEQ_DBG_CTL_0                               0x544
// enable filtering on pixel x
#define LWE297_PSEQ_DBG_CTL_0_X_EN                         0:0
#define LWE297_PSEQ_DBG_CTL_0_X_EN_DISABLE                        0x00000000
#define LWE297_PSEQ_DBG_CTL_0_X_EN_ENABLE                 0x00000001

// enable filtering on pixel y
#define LWE297_PSEQ_DBG_CTL_0_Y_EN                         1:1
#define LWE297_PSEQ_DBG_CTL_0_Y_EN_DISABLE                        0x00000000
#define LWE297_PSEQ_DBG_CTL_0_Y_EN_ENABLE                 0x00000001

// enable filtering on seq number
#define LWE297_PSEQ_DBG_CTL_0_SEQ_EN                               2:2
#define LWE297_PSEQ_DBG_CTL_0_SEQ_EN_DISABLE                      0x00000000
#define LWE297_PSEQ_DBG_CTL_0_SEQ_EN_ENABLE                       0x00000001

// enable filtering on command pc
#define LWE297_PSEQ_DBG_CTL_0_COMMAND_EN                           3:3
#define LWE297_PSEQ_DBG_CTL_0_COMMAND_EN_DISABLE                  0x00000000
#define LWE297_PSEQ_DBG_CTL_0_COMMAND_EN_ENABLE                   0x00000001

// if DBG_SEQ_EN is enabled then we
// disable debug for pixels that are less
// than this SEQ number 
#define LWE297_PSEQ_DBG_CTL_0_SEQ_START                            9:4

// if DBG_SEQ_EN is enabled then we
// disable debug for pixels that are greater
// than this SEQ number 
#define LWE297_PSEQ_DBG_CTL_0_SEQ_END                              17:12

// if DBG_COMMAND_EN is enabled then we disable
// debug for COMMANDS that don't equal this PC
#define LWE297_PSEQ_DBG_CTL_0_COMMAND_PC                           27:24

// Initialize the qid that is inserted into spanstarts packets
// This must be set if lowering the MAX_QID field in the PIXATTR register
// 0 is a good value to set this to in that case.

// Register LWE297_PSEQ_QUAD_ID_0  
#define LWE297_PSEQ_QUAD_ID_0                               0x545
#define LWE297_PSEQ_QUAD_ID_0_INDEX                        7:0

// INTERNAL register to keep the dwr_if control state in sync with the pixels
// that flow through the pipe

// Register LWE297_PSEQ_DWR_IF_STATE_0  
#define LWE297_PSEQ_DWR_IF_STATE_0                                  0x546
//execute start
#define LWE297_PSEQ_DWR_IF_STATE_0_START                           5:0

//execute count
#define LWE297_PSEQ_DWR_IF_STATE_0_COUNT                           12:6

//execute next
#define LWE297_PSEQ_DWR_IF_STATE_0_NEXT                            18:13

//pixels will not be retired at the end of this execute
#define LWE297_PSEQ_DWR_IF_STATE_0_NOT_LAST_EXE                            19:19

// --------------------------------------------------------------------------
// 
// Copyright (c) 2005, LWPU Corp.
// All Rights Reserved.
// 
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of LWPU Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of LWPU Corp.
// 
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
// 
// --------------------------------------------------------------------------
// This spec file contains definitions relevant to the software view of the
// ATRAST processing stage.  Implementation details that are of no consequence
// to software can be found in LWE297_internal.spec.
//
// This file is included by ar3d.spec.
// 
// 
// ATRAST is loosely the attribute interpolator.  It logically fed from pixel
// data sent from QRAST that have lived past any early Z tests.  ATRAST is the
// stage where barycentric interpolants get massaged to yield perspective
// interpolation weights, where lwbemapping setup is done, where higher order
// functions (like log, sin, sqrt) are performed, and ultimately where the
// vertex data is interpolated according to the barycentric weights to yield some
// intermediate value.  Because this unit is programmable there are a dizzying
// number of possible uses.  Typical use cases will be provided as a practical
// means of understanding total unit operation.
// 
// The ATRAST functional pipeline looks like this:
//     (0) Pixel packet of (R0,R1,R2,R3) arrives from PSEQ;
//         in parallel the pixel's 1/W value is computed.
//     (1) optional LWBEMAP permutation of R0..R2.
//     (2) optional MFU (Multi Function Unit) operation
//                      (recip, log, exp, sin, cos, sqrt, recipsqrt)
//     (3) optional two parallel multipliers with various sources/dests
//     (4) optional vertex attribute interpolation (IPA) stage
//     (5) pass (R0,R1,R2,R3) to TEX or recirlwlate to step 1 up to three times
// 
// The more detail explanation follows.
// 
// 
// ---- Instruction sequencing ----
// 
// Pixels flow through the pipeline in "pixel packets".  A given pixel is
// expressed in one to four rows of pixel data, with each row containing four
// 20 bit fields.  These fields hold either a 20 bit floating point value or two
// 10 bit fixed point values.  Other interpretations are used elsewhere in the
// pipeline, but ATRAST only deals with these two.  At any rate, the one to four
// rows of data logically constitute a pixel packet.
// 
// Like the other parts of the MG20 design, pixel packets may recirlwlate through
// multiple units multiple times in order to carry out a complex shader.  In
// order to keep track of things, each row of a pixel packet is assigned a
// sequence number.  A sequence number is unique to a given row and pass of a
// pixel packet, and is controlled by the global register PIX_ATTR.
// 
// ATRAST uses the sequence number to index the REMAP[] table.  The result of
// this indirection is an index into the ATRAST INST[] table along with a count
// of instructions, from zero to three.  When row has a zero instruction count
// it means that the row is unaffected by ATRAST; it still takes one clock to
// process such rows, and the advantage of having the zero encoding is that it
// doesn't take up any space in the INST[] instruction table.  When a row has
// an instruction count of one, it passes through ATRAST once and goes on to
// TEX.  If the count is more than one, the row is recirlwlated through the
// ATRAST unit before being sent off to TEX.  In effect it allows running macro
// sequences on a row without inlwrring the power expense of recirlwlating the
// pixel all the way through the back end of the 3D pipeline.
// 
// 
// ---- 1/W computation ----
// 
// QRAST feeds PSEQ, when then feeds ATRAST with pixel data, one row at a time.
// 
// Each pixel, no matter how many rows it may have, has an associated "1/w"
// value.  ATRAST computes this 1/w value for the pixel at hand with FP20
// precision, and this value is available for computations on any row of
// a pixel later in the ATRAST pipeline.  Logically it is a peer to the
// R0, R1, R2, R3 fields of the row.
// 
// If a row is recirlwlated through the ATRAST locally (because its sequence
// remapping table indicates the row has two or more instructions), this
// stage is NOT part of that recirlwlation. Specifically this means that
// barycentric coordinates A_PER and B_PER can only be computed in the first
// micropass.
// 
// ---- Lwbemapping ----
// 
// This is the first step of the local recirlwlation loop.
// 
// If the LWBE field of INST[] is NOP, then this stage is skipped.
// If the LWBE field of INST[] is R0, then lwbemapping is enabled.
// If either MUL multiplier references the I1 immediate, then the LWBE fie//
// Software reads and writes the REMAP[] table indirectly.
// REMAP_OFFSET supplies the table address and either REMAP_DATA or
// REMAP_DATA_4X access the table entry.
// INDEX auto-increments by one with each access to REMAP_DATA, and wraps
//       on overflow.
// INDEX auto-increments by four with each access to REMAP_DATA_4X, and wraps
//       on overflow.
// BASE is added to the REMAP_DATA and REMAP_DATA_4X OFFSET value(s) on writes.
// Reads to REMAP_DATA or REMAP_DATA_4X return result of addition at the time
//       of the last write to that INDEX.
//

// Register LWE297_AT_REMAP_OFFSET_0  
#define LWE297_AT_REMAP_OFFSET_0                            0x600
#define LWE297_AT_REMAP_OFFSET_0_INDEX                             5:0

#define LWE297_AT_REMAP_OFFSET_0_BASE                              11:6

//
// Remap table - remaps packet sequence #'s to counts and offsets of real INST[]'s
//

// Register LWE297_AT_REMAP_DATA_0  
#define LWE297_AT_REMAP_DATA_0                              0x601
// number of instructions on pixel rows with sequence
// number matching REMAP_OFFSET.INDEX, 0 to 3
#define LWE297_AT_REMAP_DATA_0_COUNT                               1:0

// INST[] index relative to pixel program;
// REMAP_OFFSET.BASE is added to this field on write,
// resulting in an absolute INST[] index.
#define LWE297_AT_REMAP_DATA_0_OFFSET                              7:2

//
// 4X Remap table - 4-at-a-time indirect port for remap tables (can be
// aligned at any REMAP_OFFSET INDEX value).  Like REMAP_DATA operation,
// writes into the OFFSET fields are automatically incremented by the
// current REMAP_OFFSET.BASE value.
//

// Register LWE297_AT_REMAP_DATA_4X_0  
#define LWE297_AT_REMAP_DATA_4X_0                           0x602
// number of instructions on row REMAP_OFFSET.INDEX+0
#define LWE297_AT_REMAP_DATA_4X_0_COUNT0                           1:0

// INST[] index, relative to pixel program
#define LWE297_AT_REMAP_DATA_4X_0_OFFSET0                          7:2

// number of instructions on row REMAP_OFFSET.INDEX+1
#define LWE297_AT_REMAP_DATA_4X_0_COUNT1                           9:8

// INST[] index, relative to pixel program
#define LWE297_AT_REMAP_DATA_4X_0_OFFSET1                          15:10

// number of instructions on row REMAP_OFFSET.INDEX+2
#define LWE297_AT_REMAP_DATA_4X_0_COUNT2                           17:16

// INST[] index, relative to pixel program
#define LWE297_AT_REMAP_DATA_4X_0_OFFSET2                          23:18

// number of instructions on row REMAP_OFFSET.INDEX+3
#define LWE297_AT_REMAP_DATA_4X_0_COUNT3                           25:24

// INST[] index, relative to pixel program
#define LWE297_AT_REMAP_DATA_4X_0_OFFSET3                          31:26

//
// Software reads and writes the INST[] table indirectly.
// INST_OFFSET.INDEX supplies the table address when INST_DATA is accessed
// for both reads and writes.
// INDEX auto-increments with each access to INST_DATA.
// This register will also update the BASE field of REMAP_OFFSET
//      this update will divide the INDEX from INST_OFFSET by the number of words
//      in an single logical alu instruction 
//      (LW_GR3D_ALU_INST_NUM_WORDS * LW_GR3D_NUM_ALUS) 
//

// Register LWE297_AT_INST_OFFSET_0  
#define LWE297_AT_INST_OFFSET_0                             0x603
#define LWE297_AT_INST_OFFSET_0_INDEX                              6:0

// MFU operation can be bypassed by selecting FUNC==NOP, in which case the
// SRC_DST field is moot.
//
// When FUNC != NOP, SRC_DST selects both the input to the MFU as well as
// where the results are saved.
//
// The FUNC mnemonics are pretty terse, so here they are expanded:
//     NOP       no operation, suppressing MFU
//     RCP       reciprocal
//     RSQRT     reciprocal square root
//     LOG2      log base 2
//     EXP2      exponential (power of two)
//     SQRT      square root
//     SIN       sine
//     COS       cosine
//     FRC       fraction, (x-floor(x))
//     EXP2RRO   range reduction for companion EXP2
//     SINRRO    range reduction for companion SIN
//     COSRRO    range reduction for companion COS

// Packet LWE297_AT_FUNC
#define LWE297_AT_FUNC_SIZE 7

// source and destination
#define LWE297_AT_FUNC_SRC_DST_ROW                        0
#define LWE297_AT_FUNC_SRC_DST_R0                 0x00000000
#define LWE297_AT_FUNC_SRC_DST_R1                 0x00000001
#define LWE297_AT_FUNC_SRC_DST_R2                 0x00000002
#define LWE297_AT_FUNC_SRC_DST_R3                 0x00000003
#define LWE297_AT_FUNC_SRC_DST_W                  0x00000004

// the function to compute
#define LWE297_AT_FUNC_FUNC_ROW                   0
#define LWE297_AT_FUNC_FUNC_NOP                   0x00000000
#define LWE297_AT_FUNC_FUNC_RCP                   0x00000001
#define LWE297_AT_FUNC_FUNC_RSQRT                 0x00000002
#define LWE297_AT_FUNC_FUNC_LOG2                  0x00000003
#define LWE297_AT_FUNC_FUNC_EXP2                  0x00000004
#define LWE297_AT_FUNC_FUNC_SQRT                  0x00000005
#define LWE297_AT_FUNC_FUNC_SIN                   0x00000006
#define LWE297_AT_FUNC_FUNC_COS                   0x00000007
#define LWE297_AT_FUNC_FUNC_FRC                   0x00000008
#define LWE297_AT_FUNC_FUNC_EXP2RRO                       0x00000009
#define LWE297_AT_FUNC_FUNC_SINRRO                        0x0000000a
#define LWE297_AT_FUNC_FUNC_COSRRO                        0x0000000b

// For each multiplier, specify the two inputs come from and where the results
// are saved.
//
// DST:
//     NOP     specifying this disables the multiplier altogther and does
//             not change any state.  it also saves power.
//     PER     when the MUL.0 multiplier specifies this, its result is saved
//             in the ALPHA register; when MUL.1 specifies it its results are
//             saved in the BETA register.  These two values are used by the
//             IPA stage as interpolation weights when performing perspective
//             correct interpolation.
//     R0..R3  specifying one of these saves the result into one of the four
//             FP20 fields of the current pixel row.
//
// SRC0 and SRC1:
//     R0..R3  are the four FP20 fields of the current pixel row
//     C0..C3  are the four FP20 constant registers (CONSTANT0[])
//     I0..I1  are the two FP20 immediates.  If I0 is present, then the IPAs
//             are implicitly NOP'd.  If I1 is present, then the IPAs, the
//             LWBE function, and the MFU FUNC are all implicitly NOP'd,
//             as these fields hold the one or two FP20 immediates.
//     W       is the output of the MFU unit when it processes the 1/w value
//             from the barycentric steppers.  reading from this register is
//             invalid unless the MFU computed the result in the same logical
//             instruction.  Another way to state it is it is stateless; it
//             does not persist across instructions.
//     ALPHA   is the barycentric alpha weight (a(x,y)/w0) associated with
//             the current pixel.  Typcally this value is multiplied by W
//             and stored into the interpolation weight register.
//             It may be used only with SRC1.
//     BETA    is the barycentric beta weight (b(x,y)/w1) associated with
//             the current pixel.  Typcally this value is multiplied by W
//             and stored into the interpolation weight register.
//             It may be used only with SRC1.
//     ONE     is the FP20 constant 1.0, accurate to more than 1000 digits

// Packet LWE297_AT_MUL
#define LWE297_AT_MUL_SIZE 11

// destination of the mul
#define LWE297_AT_MUL_DST_ROW                     0
#define LWE297_AT_MUL_DST_NOP                     0x00000000
#define LWE297_AT_MUL_DST_PER                     0x00000001
#define LWE297_AT_MUL_DST_R0                      0x00000004
#define LWE297_AT_MUL_DST_R1                      0x00000005
#define LWE297_AT_MUL_DST_R2                      0x00000006
#define LWE297_AT_MUL_DST_R3                      0x00000007

// one of the 2 sources of the mul
#define LWE297_AT_MUL_SRC1_ROW                    0
#define LWE297_AT_MUL_SRC1_R0                     0x00000000
#define LWE297_AT_MUL_SRC1_R1                     0x00000001
#define LWE297_AT_MUL_SRC1_R2                     0x00000002
#define LWE297_AT_MUL_SRC1_R3                     0x00000003
#define LWE297_AT_MUL_SRC1_C0                     0x00000004
#define LWE297_AT_MUL_SRC1_C1                     0x00000005
#define LWE297_AT_MUL_SRC1_C2                     0x00000006
#define LWE297_AT_MUL_SRC1_C3                     0x00000007
#define LWE297_AT_MUL_SRC1_I0                     0x00000008
#define LWE297_AT_MUL_SRC1_I1                     0x00000009
#define LWE297_AT_MUL_SRC1_W                      0x0000000a
#define LWE297_AT_MUL_SRC1_ALPHA                  0x0000000b
#define LWE297_AT_MUL_SRC1_BETA                   0x0000000c
#define LWE297_AT_MUL_SRC1_ONE                    0x0000000d

// the other source
// ALPHA and BETA are going away here
#define LWE297_AT_MUL_SRC0_ROW                    0
#define LWE297_AT_MUL_SRC0_R0                     0x00000000
#define LWE297_AT_MUL_SRC0_R1                     0x00000001
#define LWE297_AT_MUL_SRC0_R2                     0x00000002
#define LWE297_AT_MUL_SRC0_R3                     0x00000003
#define LWE297_AT_MUL_SRC0_C0                     0x00000004
#define LWE297_AT_MUL_SRC0_C1                     0x00000005
#define LWE297_AT_MUL_SRC0_C2                     0x00000006
#define LWE297_AT_MUL_SRC0_C3                     0x00000007
#define LWE297_AT_MUL_SRC0_I0                     0x00000008
#define LWE297_AT_MUL_SRC0_I1                     0x00000009
#define LWE297_AT_MUL_SRC0_W                      0x0000000a
#define LWE297_AT_MUL_SRC0_ALPHA                  0x0000000b
#define LWE297_AT_MUL_SRC0_BETA                   0x0000000c
#define LWE297_AT_MUL_SRC0_ONE                    0x0000000d

// For each interpolator, specify which set of interpolating weights to use,
// which parameter set to use from the TRAM, and what style of interpolation
// to perform for this bank.
//
// ENTRY:
//    This specifies which attribute to interpolate from the TRAM table.
//    The value is not an absolute TRAM[] index, but rather an offset from
//    the start of the data for that triangle.  The value must be less than
//    or equal to the value programmed into the global register TRI_ATTR,
//    field TRI_ROWS.
//
// PREC:
//    000 = NOP     = no computation/no result
//    001 = ZP      = evaluate fixed point (0.20) Z plane equation
//    010 = HPS     = one high precision interpolation with saturation
//    011 = HPC     = one high precision interpolation with clamping
//    100 = LPS_LPS = two low precision interpolations, with
//                    the high FX10 saturating and the low FX10 saturating
//    101 = LPS_LPC = two low precision interpolations, with
//                    the high FX10 saturating and the low FX10 clamping
//    110 = LPC_LPS = two low precision interpolations, with
//                    the high FX10 clamping and the low FX10 saturating
//    111 = LPC_LPS = two low precision interpolations, with
//                    the high FX10 clamping and the low FX10 clamping

// Packet LWE297_AT_IPA
#define LWE297_AT_IPA_SIZE 7

// which of 16 TRAM[] entries to use
#define LWE297_AT_IPA_ENTRY_ROW                   0

// selecects precision and saturation modes
#define LWE297_AT_IPA_PREC_ROW                    0
#define LWE297_AT_IPA_PREC_NOP                    0x00000000
#define LWE297_AT_IPA_PREC_ZP                     0x00000001
#define LWE297_AT_IPA_PREC_HPS                    0x00000002
#define LWE297_AT_IPA_PREC_HPC                    0x00000003
#define LWE297_AT_IPA_PREC_LPS_LPS                        0x00000004
#define LWE297_AT_IPA_PREC_LPS_LPC                        0x00000005
#define LWE297_AT_IPA_PREC_LPC_LPS                        0x00000006
#define LWE297_AT_IPA_PREC_LPC_LPC                        0x00000007

//
// Instruction indirect port.
// Instructions use variant encodings within one register spec to allow
// single instructions to be pairs of adjacent writes.
// The actual INST[] entry accessed is supplied by INST_OFFSET.INDEX,
// which is incremented after each access to INST_DATA.
//
// The fields below are a union of different uses.  The logical instruction
// is 64 bits wide.  The low (even) word controls the everything except for
// the IPA units; the high (odd) word controls the four IPA units.  However,
// some of these fields get overloaded with immediate data values for use
// by the MUL units, which is what the IMM0, IMM1L, IMM1H subfields are
// specifying.
//

// Register LWE297_AT_INST_DATA_0  // EVEN INDEX values in INST_OFFSET
#define LWE297_AT_INST_DATA_0                               0x604
// Data field for Even Instructions 
#define LWE297_AT_INST_DATA_0_DATA0                        31:0

// high half of MUL I1 FP20 immediate
#define LWE297_AT_INST_DATA_0_IMM1H                        31:22

// Lwbemap enable (R0 means enabled)
#define LWE297_AT_INST_DATA_0_LWBE                         29:29
#define LWE297_AT_INST_DATA_0_LWBE_NOP                    0x00000000
#define LWE297_AT_INST_DATA_0_LWBE_R0                     0x00000001

// transcendental function (LWE297_AT_FUNC)
#define LWE297_AT_INST_DATA_0_FUNC                         28:22

// multiply (LWE297_AT_MUL)
#define LWE297_AT_INST_DATA_0_MUL1                         21:11

// multiply (LWE297_AT_MUL)
// ODD INDEX values in INST_OFFSET
#define LWE297_AT_INST_DATA_0_MUL0                         10:0

// Data field for Odd Instructions
#define LWE297_AT_INST_DATA_0_DATA1                        29:0

// low half of MUL I1 FP20 immediate
#define LWE297_AT_INST_DATA_0_IMM1L                        29:20

// MUL I0 FP20 immediate
#define LWE297_AT_INST_DATA_0_IMM0                         19:0

// attribute interpolation controls (LWE297_AT_IPA)
#define LWE297_AT_INST_DATA_0_IPA3                         27:21

// attribute interpolation controls (LWE297_AT_IPA)
#define LWE297_AT_INST_DATA_0_IPA2                         20:14

// attribute interpolation controls (LWE297_AT_IPA)
#define LWE297_AT_INST_DATA_0_IPA1                         13:7

// attribute interpolation controls (LWE297_AT_IPA)
#define LWE297_AT_INST_DATA_0_IPA0                         6:0

// number of CONST registers available to the multiplier stage in ATRAST
// The constant registers are available for feeding to the MUL inputs.
// Sometimes they are referred to in shorthand as C0 .. Cn.
// Each holds a single FP20 value.

// Register LWE297_AT_CONSTANT0_0  
#define LWE297_AT_CONSTANT0_0                               0x608
// RAST_R format, same as pixel packet registers
#define LWE297_AT_CONSTANT0_0_VAL                          19:0


// Register LWE297_AT_CONSTANT0  
#define LWE297_AT_CONSTANT0                                 0x608
// RAST_R format, same as pixel packet registers
#define LWE297_AT_CONSTANT0_VAL                            19:0


// Register LWE297_AT_CONSTANT0_1  
#define LWE297_AT_CONSTANT0_1                               0x609
// RAST_R format, same as pixel packet registers
#define LWE297_AT_CONSTANT0_1_VAL                          19:0


// Register LWE297_AT_CONSTANT0_2  
#define LWE297_AT_CONSTANT0_2                               0x60a
// RAST_R format, same as pixel packet registers
#define LWE297_AT_CONSTANT0_2_VAL                          19:0


// Register LWE297_AT_CONSTANT0_3  
#define LWE297_AT_CONSTANT0_3                               0x60b
// RAST_R format, same as pixel packet registers
#define LWE297_AT_CONSTANT0_3_VAL                          19:0

// HACK HACK HACK replaced this with project.spec values
//
// The TRAM (Triangle RAM) file is accessed indirectly by software.
// TRAM_OFFSET.INDEX supplies the TRAM[] index whenever TRAM_DATA is accessed
// by software, after which it auto increments by one.
//

// Register LWE297_AT_TRAM_OFFSET_0  
#define LWE297_AT_TRAM_OFFSET_0                             0x60c
// current read or write target in TRAM[]
#define LWE297_AT_TRAM_OFFSET_0_INDEX                              8:0

//
// TRAM_DATA is the register to for accessing the TRAM[] array, after which
// the TRAM_OFFSET.INDEX field increments by one.
// The format of TRAM_DATA is opaque to software, but is defined by TRAM_BF_ZP,
// TRAM_BF_HP, TRAM_BF_LP if you must know.
// 

// Register LWE297_AT_TRAM_DATA_0  
#define LWE297_AT_TRAM_DATA_0                               0x60d
#define LWE297_AT_TRAM_DATA_0_VAL                          31:0

// Second-level clock enable override register
//
// This can override the 2nd level clock enables in case of malfunction.
// Only exposed to software when needed.
//

// Register LWE297_AT_CLKEN_OVERRIDE_0  
#define LWE297_AT_CLKEN_OVERRIDE_0                                  0x60e
#define LWE297_AT_CLKEN_OVERRIDE_0_CORE_CLKEN_OVR                          0:0
#define LWE297_AT_CLKEN_OVERRIDE_0_CORE_CLKEN_OVR_INIT_ENUM                       CLK_GATED
#define LWE297_AT_CLKEN_OVERRIDE_0_CORE_CLKEN_OVR_CLK_GATED                       0x00000000
#define LWE297_AT_CLKEN_OVERRIDE_0_CORE_CLKEN_OVR_CLK_ALWAYS_ON                   0x00000001

#define LWE297_AT_CLKEN_OVERRIDE_0_SLOPES_CLKEN_OVR                        1:1
#define LWE297_AT_CLKEN_OVERRIDE_0_SLOPES_CLKEN_OVR_INIT_ENUM                     CLK_GATED
#define LWE297_AT_CLKEN_OVERRIDE_0_SLOPES_CLKEN_OVR_CLK_GATED                     0x00000000
#define LWE297_AT_CLKEN_OVERRIDE_0_SLOPES_CLKEN_OVR_CLK_ALWAYS_ON                 0x00000001

#define LWE297_AT_CLKEN_OVERRIDE_0_TRAM_CLKEN_OVR                          2:2
#define LWE297_AT_CLKEN_OVERRIDE_0_TRAM_CLKEN_OVR_INIT_ENUM                       CLK_GATED
#define LWE297_AT_CLKEN_OVERRIDE_0_TRAM_CLKEN_OVR_CLK_GATED                       0x00000000
#define LWE297_AT_CLKEN_OVERRIDE_0_TRAM_CLKEN_OVR_CLK_ALWAYS_ON                   0x00000001

#define LWE297_AT_CLKEN_OVERRIDE_0_BARY_CLKEN_OVR                          3:3
#define LWE297_AT_CLKEN_OVERRIDE_0_BARY_CLKEN_OVR_INIT_ENUM                       CLK_GATED
#define LWE297_AT_CLKEN_OVERRIDE_0_BARY_CLKEN_OVR_CLK_GATED                       0x00000000
#define LWE297_AT_CLKEN_OVERRIDE_0_BARY_CLKEN_OVR_CLK_ALWAYS_ON                   0x00000001

#define LWE297_AT_CLKEN_OVERRIDE_0_ONEOVERW_CLKEN_OVR                              4:4
#define LWE297_AT_CLKEN_OVERRIDE_0_ONEOVERW_CLKEN_OVR_INIT_ENUM                   CLK_GATED
#define LWE297_AT_CLKEN_OVERRIDE_0_ONEOVERW_CLKEN_OVR_CLK_GATED                   0x00000000
#define LWE297_AT_CLKEN_OVERRIDE_0_ONEOVERW_CLKEN_OVR_CLK_ALWAYS_ON                       0x00000001

#define LWE297_AT_CLKEN_OVERRIDE_0_MFU_CLKEN_OVR                           5:5
#define LWE297_AT_CLKEN_OVERRIDE_0_MFU_CLKEN_OVR_INIT_ENUM                        CLK_GATED
#define LWE297_AT_CLKEN_OVERRIDE_0_MFU_CLKEN_OVR_CLK_GATED                        0x00000000
#define LWE297_AT_CLKEN_OVERRIDE_0_MFU_CLKEN_OVR_CLK_ALWAYS_ON                    0x00000001

#define LWE297_AT_CLKEN_OVERRIDE_0_MULABS_CLKEN_OVR                        6:6
#define LWE297_AT_CLKEN_OVERRIDE_0_MULABS_CLKEN_OVR_INIT_ENUM                     CLK_GATED
#define LWE297_AT_CLKEN_OVERRIDE_0_MULABS_CLKEN_OVR_CLK_GATED                     0x00000000
#define LWE297_AT_CLKEN_OVERRIDE_0_MULABS_CLKEN_OVR_CLK_ALWAYS_ON                 0x00000001

#define LWE297_AT_CLKEN_OVERRIDE_0_IPAS_CLKEN_OVR                          7:7
#define LWE297_AT_CLKEN_OVERRIDE_0_IPAS_CLKEN_OVR_INIT_ENUM                       CLK_GATED
#define LWE297_AT_CLKEN_OVERRIDE_0_IPAS_CLKEN_OVR_CLK_GATED                       0x00000000
#define LWE297_AT_CLKEN_OVERRIDE_0_IPAS_CLKEN_OVR_CLK_ALWAYS_ON                   0x00000001

// --------------------------------------------------------------------------
//
// Copyright (c) 2004, LWPU Corp.
// All Rights Reserved.
//
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of LWPU Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of LWPU Corp.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
//
// --------------------------------------------------------------------------
//
// =========================================================================
// TEX instruction registers
// =========================================================================
//
// Instruction table offset: controls what indirect entry in the instruction table gets accessed.
// INDEX auto-increments with each access to INST_DATA.
//

// Register LWE297_TEX_INST_OFFSET_0  
#define LWE297_TEX_INST_OFFSET_0                            0x700
// current read or write target in INST_DATA
#define LWE297_TEX_INST_OFFSET_0_INDEX                             5:0

// The TEX instruction defines a texture fetch. The instruction also
// gives control over some of the details of these operations.
//
// The instructions performed, and the order they are performed, is determined
// by the global register PIX_ATTR.
//
//    * The texel addressed by the (s,t) or (s,t,r/face) tuple present in the
//      field indexed by REG_SRC on the surface indexed by SURF_PTR will be
//      fetched and passed to the ALUs in the field indexed by REG_DST.
//
//      What distinguishes a TEX fetch from a COLOR fetch in DF are the
//      following differences:
//          + mipmapped texture surfaces must be a power of two in size;
//            unmipmapped or color surfaces can have an arbitrary size (other
//            than alignment restrictions.)
//          + texture fetches allow a number of filtering options;
//            color fetches are always point sampled.
//          + texture fetches are derived from the callwlated (s,t) coords;
//            color fetches are addressed by the (x,y) coords of the pixel
//          + texture fetches are cached and there is no memory coherence
//            with other writes oclwring in the system, so writes to texture
//            surfaces must be very controlled;
//
//    * The resulting (A)RGB value is
//      expanded to a {4 x s1.8} format and is stored into the registers
//      selected by REG_DST.  Note that the component values are mapped such
//      that a pixel value of 0x00 is mapped to 0.00 and 0xFF is mapped to
//      +1.00.  The values in between are only guaranteed to be monotonically
//      increasing.
//
//      The table below indicates which color channels go to which register
//      fields in the RAST_R packet:
//
//          REG_DST==R0R1: red   -> R0, low
//                         green -> R0, high
//                         blue  -> R1, low
//                         alpha -> R1, high
//
//          REG_DST==R2R3: red   -> R2, low
//                         green -> R2, high
//                         blue  -> R3, low
//                         alpha -> R3, high
// Restrictions:
//    * The mapping of the 8b color component value to s1.8 format is done
//      by incrementing any values >= 0x80 by 1 (equivalent to *256/255)
//      Thus, 0x80 will never be produced by the process.
//
//    * If trilinear filtering is enabled (LERP_MIP) for an instruction,
//      the instruction takes two cycles instead of one.  If the pipeline
//      determines that bilinear filtering will be equivalent to trilinear
//      filtering, bilinear filtering will be done instead, taking a single
//      cycle (this happens when the LOD fraction is close to zero).
//
//    * If a surface surface is of type DXT1/3/5, the COLOR_KEY field should
//      be set to DISABLE as this operations makes no sense.

// Register LWE297_TEX_INST_DATA_0  
#define LWE297_TEX_INST_DATA_0                              0x701
// whether user specified lod is provided in a register
#define LWE297_TEX_INST_DATA_0_USER_LOD                            13:13
#define LWE297_TEX_INST_DATA_0_USER_LOD_DISABLE                   0x00000000
#define LWE297_TEX_INST_DATA_0_USER_LOD_ENABLE                    0x00000001

// whether lod bias is provided in a register
#define LWE297_TEX_INST_DATA_0_USER_LOD_BIAS                               12:12
#define LWE297_TEX_INST_DATA_0_USER_LOD_BIAS_DISABLE                      0x00000000
#define LWE297_TEX_INST_DATA_0_USER_LOD_BIAS_ENABLE                       0x00000001

// whether to fetch killed pixels.  Must be enabled when
// dependent texturing is on and LOD is required, and
// when derivative callwlations are made
#define LWE297_TEX_INST_DATA_0_FETCH_KILLED                        11:11
#define LWE297_TEX_INST_DATA_0_FETCH_KILLED_DISABLE                       0x00000000
#define LWE297_TEX_INST_DATA_0_FETCH_KILLED_ENABLE                        0x00000001

// whether to fetch at all
#define LWE297_TEX_INST_DATA_0_FETCH                               10:10
#define LWE297_TEX_INST_DATA_0_FETCH_DISABLE                      0x00000000
#define LWE297_TEX_INST_DATA_0_FETCH_ENABLE                       0x00000001

// which 2 components of R16G16B16A16_float to read, if applicable
#define LWE297_TEX_INST_DATA_0_COMP_SEL                            7:7
#define LWE297_TEX_INST_DATA_0_COMP_SEL_RG                        0x00000000
#define LWE297_TEX_INST_DATA_0_COMP_SEL_BA                        0x00000001

// Enable ColorKey.  Must disable for DXT1/3/5 formats.
#define LWE297_TEX_INST_DATA_0_COLOR_KEY                           6:6
#define LWE297_TEX_INST_DATA_0_COLOR_KEY_DISABLE                  0x00000000
#define LWE297_TEX_INST_DATA_0_COLOR_KEY_ENABLE                   0x00000001

// reg receiving result of texture fetch
#define LWE297_TEX_INST_DATA_0_REG_DST                             5:5
#define LWE297_TEX_INST_DATA_0_REG_DST_R0R1                       0x00000000
#define LWE297_TEX_INST_DATA_0_REG_DST_R2R3                       0x00000001

// reg containing S, T (and R/face, if applicable) coordinates
#define LWE297_TEX_INST_DATA_0_REG_SRC                             4:4
#define LWE297_TEX_INST_DATA_0_REG_SRC_R0R1R2                     0x00000000
#define LWE297_TEX_INST_DATA_0_REG_SRC_R2R3R0                     0x00000001

// surface pointer to fetch through
#define LWE297_TEX_INST_DATA_0_SURF_PTR                            3:0

// =========================================================================
// Colorkey register
// =========================================================================
// The COLORKEY register is compared against each texel value.  If the raw
// texel value matches the appropriate number of LS bits of Colorkey, then
// the pixel is flagged as killed.  For example, 4b indexed texels compare
// their index to bits [3:0] of COLORKEY; 8b indexed texels are compared
// to bits [7:0]; R5G6R6 texels are compared to bits [15:0]; etc.
//
// In the case of bilinear pixels, if *any* of the four pre-filtered texels
// match the COLORKEY value, the pixel is killed.  In the case of trilinear
// texture filtering, the pixel is killed if *any* of the eight pre-filtered
// texels fetched matches the COLORKEY.
//
// This register is enabled by field COLOR_KEY in the instruction (INST[]);
// it must be disabled for the DXT1/3/5 formats.

// Register LWE297_TEX_COLORKEY_0  
#define LWE297_TEX_COLORKEY_0                               0x702
#define LWE297_TEX_COLORKEY_0_VALUE                        31:0

// TEXADDR contains the base address for the texture surfaces.  The SURF_PTR field from INST
// will index into this table.
// Any write to TEXADDR, TEXDESC, or FLUSH will cause a texture cache flush.

// Register LWE297_TEX_TEXADDR_0  
#define LWE297_TEX_TEXADDR_0                                0x710
// This surface base address should be 16-byte aligned
#define LWE297_TEX_TEXADDR_0_BASE_ADDRESS                          31:0


// Register LWE297_TEX_TEXADDR  
#define LWE297_TEX_TEXADDR                                  0x710
// This surface base address should be 16-byte aligned
#define LWE297_TEX_TEXADDR_BASE_ADDRESS                            31:0


// Register LWE297_TEX_TEXADDR_1  
#define LWE297_TEX_TEXADDR_1                                0x711
// This surface base address should be 16-byte aligned
#define LWE297_TEX_TEXADDR_1_BASE_ADDRESS                          31:0


// Register LWE297_TEX_TEXADDR_2  
#define LWE297_TEX_TEXADDR_2                                0x712
// This surface base address should be 16-byte aligned
#define LWE297_TEX_TEXADDR_2_BASE_ADDRESS                          31:0


// Register LWE297_TEX_TEXADDR_3  
#define LWE297_TEX_TEXADDR_3                                0x713
// This surface base address should be 16-byte aligned
#define LWE297_TEX_TEXADDR_3_BASE_ADDRESS                          31:0


// Register LWE297_TEX_TEXADDR_4  
#define LWE297_TEX_TEXADDR_4                                0x714
// This surface base address should be 16-byte aligned
#define LWE297_TEX_TEXADDR_4_BASE_ADDRESS                          31:0


// Register LWE297_TEX_TEXADDR_5  
#define LWE297_TEX_TEXADDR_5                                0x715
// This surface base address should be 16-byte aligned
#define LWE297_TEX_TEXADDR_5_BASE_ADDRESS                          31:0


// Register LWE297_TEX_TEXADDR_6  
#define LWE297_TEX_TEXADDR_6                                0x716
// This surface base address should be 16-byte aligned
#define LWE297_TEX_TEXADDR_6_BASE_ADDRESS                          31:0


// Register LWE297_TEX_TEXADDR_7  
#define LWE297_TEX_TEXADDR_7                                0x717
// This surface base address should be 16-byte aligned
#define LWE297_TEX_TEXADDR_7_BASE_ADDRESS                          31:0


// Register LWE297_TEX_TEXADDR_8  
#define LWE297_TEX_TEXADDR_8                                0x718
// This surface base address should be 16-byte aligned
#define LWE297_TEX_TEXADDR_8_BASE_ADDRESS                          31:0


// Register LWE297_TEX_TEXADDR_9  
#define LWE297_TEX_TEXADDR_9                                0x719
// This surface base address should be 16-byte aligned
#define LWE297_TEX_TEXADDR_9_BASE_ADDRESS                          31:0


// Register LWE297_TEX_TEXADDR_10  
#define LWE297_TEX_TEXADDR_10                               0x71a
// This surface base address should be 16-byte aligned
#define LWE297_TEX_TEXADDR_10_BASE_ADDRESS                         31:0


// Register LWE297_TEX_TEXADDR_11  
#define LWE297_TEX_TEXADDR_11                               0x71b
// This surface base address should be 16-byte aligned
#define LWE297_TEX_TEXADDR_11_BASE_ADDRESS                         31:0


// Register LWE297_TEX_TEXADDR_12  
#define LWE297_TEX_TEXADDR_12                               0x71c
// This surface base address should be 16-byte aligned
#define LWE297_TEX_TEXADDR_12_BASE_ADDRESS                         31:0


// Register LWE297_TEX_TEXADDR_13  
#define LWE297_TEX_TEXADDR_13                               0x71d
// This surface base address should be 16-byte aligned
#define LWE297_TEX_TEXADDR_13_BASE_ADDRESS                         31:0


// Register LWE297_TEX_TEXADDR_14  
#define LWE297_TEX_TEXADDR_14                               0x71e
// This surface base address should be 16-byte aligned
#define LWE297_TEX_TEXADDR_14_BASE_ADDRESS                         31:0


// Register LWE297_TEX_TEXADDR_15  
#define LWE297_TEX_TEXADDR_15                               0x71f
// This surface base address should be 16-byte aligned
#define LWE297_TEX_TEXADDR_15_BASE_ADDRESS                         31:0

// --------------------------------------------------------------------------
// Notes on TEXDESC (a packed array of 64bit surface formats).
//
// TRILINEAR_OPT, LERP_MAG/MIN/MIP, LOD_BIAS, MAX_ANISO,
// SURF_FORMAT, LAYOUT, MIRROR_S/T and CLAMP_S/T bits are in
// the even addresses
//
// WIDTH, HEIGHT, LOG2_WIDTH, LOG2_HEIGHT, LOD_MIN/MAX,
// BASE_LEVEL_ONLY, NORMALIZE, NON_POWER_OF_TWO and ARRAY_MAX
// are in the odd addresses
//
// Non power of two textures use WIDTH, HEIGHT and NORMALIZE
// and don't use LOG2_WIDTH, LOG2_HEIGHT, LOD_MIN/MAX, LERP_MIP
//
// Power of two textures use the opposite set of fields
//
// SURF_PTR field of INST is used to index into this table 2*SURF_PTR+0 for even fields and
// 2*SURF_PTR+1 for odd fields
//
// WIDTH, HEIGHT, LOG2_WIDTH, LOG2_HEIGHT
// Units are texels
// The use of the WIDTH and HEIGHT fields are mutually exclusive with the
// use of the LOG2_WIDTH and LOG2_HEIGHT fields. Use WIDTH for non-power-of-two
// surfaces, and use LOG2_WIDTH and LOG2_HEIGHT for power-of-two textures.
//
// LOG2_WIDTH, LOG2_HEIGHT
// For texture surfaces using mipmaps these need to be set to the log2 of
// the width and height (in texels) of level 0.
//
// NORMALIZE (sc25 only).
// When enabled, s/t are assumed to be in the range [0..1].  When disabled,
// s/t are assumed to be in the rance [0..WIDTH], [0..HEIGHT].
// Note that mg20 does not support unnormalized s/t.
//
// TRILINEAR_OPT
// makes the lod "stick around" at integer values SLOPE_2 means a computed
// value of e.g. 1.0..1.25 will be mapped to 1.0, and a value of 1.75..2.0
// will be mapped to 2.0. Values in between (1.25..1.75) will be mapped to
// 1.0..2.0 (i.e. a slope of 2)
//
// SURF_FORMAT
// Describes the format the data is stored in memory
// (S=stencil, C=coverage/predicate, I=intensity, L=luminance, A=alpha, B=blue,
//  G=green, R=red, Z=depth, P=pixel_packet)
// For floating point textures, tex writes to destination registers as follow:
//  L16_float, A16_float, and L16A16_float write to [even, odd] with (L,A)
//  R11G11B10_float writes to [even, odd, nextEven] with (R,G,B)
//  R16G16B16A16_float writes to [even, odd] with the selected pair of components
//
// Supported formats: (S=stencil, C=coverage/predicate,
//                     L=luminance, A=alpha, B=blue, G=green, R=red, 
//                     Z=depth, P=pixel_packet)
//  4 bpp:  DXT1, DXT1C, ETC, LATC1
//  8 bpp:  L8, A8, B2G3R3, DXT3, DXT5, ETC3, ETC5, LATC2
// 16 bpp:  L8A8, B5G6R5, A1B5G5R5, B5G5R5A1, A4B4G4R4, B4G4R4A4
//          A16_float, L16_float
// 32 bpp: R8G8B8A8, B8G8R8A8, L16A16_float, R11G11B10_float
// 64 bpp: R16G16B16A16_float, 
//
// Not Supported: S8, C4X4, Z16, Z16NL, R10G10B10_float_A2
//
// LAYOUT
// Please refer to ar3d.spec for description of swizzling and tiling.
//
// CLAMP_S CLAMP_T
// WRAP -- ignore the integer part of the texture coords so that the texture will
//         repeat.
// CLAMP -- clamp the texture coords to the range (0,1) such that it stays within
//         the texture proper
//
// MIRROR_S MIRROR_T
// If mirror is followed by wrap, this effectively defines a texture map twice as
// large as the original texture in which the additional half, for each mirrored
// texture coordinate, is a mirror image of the original texture.
//
//  S/U  -3  -2  -1   0   1   2   3
//  2^N-1 +       +       +       +
//         \     / \     / \     / 
//          \   /   \   /   \   /
//           \ /     \ /     \ /
//  0         +       +       +
//
// And if mirror is followed by clamp, the absolute value of the texture
// coordinates are computed prior to clamping.
//
//  S/U  -3  -2  -1   0   1   2   3
//  2^N-1 --------+       +--------
//                 \     /
//                  \   / 
//                   \ /
//   0                +
//
// Please note that any write to TEXADDR, TEXDESC, or FLUSH will cause a texture
// cache flush.
//
// Programming guideline:
// 1. One should set LOD_MAX to min(TEXTURE_MAX_LOD, maximum available lod).
// 2. One should set BASE_LEVEL_ONLY to (maximum available lod == 0).
//
// The order of evaluation of texture parameters are as follow (variables in caps
// are from the register fields):
//     log2ratio = log2major - log2minor
//     log2ratio = min(log2ratio, log2major)
//     log2ratio -= ANISO_BIAS
//     log2ratio = clamp(log2ratio, 0, log2(MAX_ANISO))
//     lod = log2major - log2ratio
//     lod += LOD_BIAS + USER_LOD_BIAS
//     if (TRILINEAR_OPT)
//         lod = tri_opt(lod)
//     lod = clamp(lod, LOD_MIN, LOD_MAX)
//     magnify = lod <= 0
//     if (!LERP_MIP)
//         lod = round(lod)
//     lod = clamp(lod, 0, max_available_lod)
//
// Restrictions:
// 1. Textures can be no larger than 2k x 2k texels.
// 2. Any single texture can be no larger than 64MB.
// 3. Non-power-of-two textures/lwbemaps/arrays do not support mipmapping or anisotropic filtering.
// 4. Non-power-of-two textures/lwbemaps/arrays do not support wrap, just clamp to edge.
// 5. Lwbemaps do not support anisotropic filtering.
// 6. Lwbemaps do not support texture wrap modes other than clamp to edge.
// 7. For power-of-two textures/faces/slices, a mipmap stack should be 32B 
//    aligned, individual levels within the stack should be 16B aligned.
// 8. All non-power-of-two textures/faces/slices are aligned to 1024B.
// 9. non-power-of-two textures widths (post-swizzled) are padded 
//    to 64B multiples.  This means that SWIZZLED layout surfaces have different
//    multiples based on the number of bits per pixel.
//       SWIZZLED layout pre-swizzle width alignment:
//       4bpp - 8bpp -- aligned to 16B multiples
//       16bpp - 64bpp -- aligned to 32B multiples
// 10.non-power-of-two texture faces/slices heights are padded to multiples
//    of 16
// 11.In XY_TILED_SWIZZLED LAYOUT, mipmap levels that have widths < 64B or 
//    heights < 16 are switched to SWIZZLED LAYOUT, the other mipmap levels
//    stay XY_TILED_SWIZZLED
// 12.All power-of-two face/slice sizes are padded to multiples of 1024B
// --------------------------------------------------------------------------

// Register LWE297_TEX_TEXDESC_0  
#define LWE297_TEX_TEXDESC_0                                0x720
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_0_WIDTH                         31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_0_HEIGHT                        19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. NON-POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_0_NORMALIZE                             7:7
#define LWE297_TEX_TEXDESC_0_NORMALIZE_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_0_NORMALIZE_ENABLE                     0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_0_LOG2_WIDTH                            31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_0_LOG2_HEIGHT                           27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_0_LOD_MIN                               23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_0_LOD_MAX                               15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_0_BASE_LEVEL_ONLY                               7:7
#define LWE297_TEX_TEXDESC_0_BASE_LEVEL_ONLY_DISABLE                      0x00000000
#define LWE297_TEX_TEXDESC_0_BASE_LEVEL_ONLY_ENABLE                       0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_0_NON_POWER_OF_TWO                              6:6
#define LWE297_TEX_TEXDESC_0_NON_POWER_OF_TWO_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_0_NON_POWER_OF_TWO_ENABLE                      0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_0_ARRAY_MAX                             5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_0_TRILINEAR_OPT                         30:30
#define LWE297_TEX_TEXDESC_0_TRILINEAR_OPT_DISABLE                        0x00000000
#define LWE297_TEX_TEXDESC_0_TRILINEAR_OPT_ENABLE                 0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_0_LERP_MAG                              29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_0_LERP_MIN                              28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_0_LERP_MIP                              27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_0_LOD_BIAS                              26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_0_MAX_ANISO                             17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_0_SURF_FORMAT                           13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_0_LWBEMAP                               7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_0_LAYOUT                        6:4
#define LWE297_TEX_TEXDESC_0_LAYOUT_LINEAR                        0x00000000
#define LWE297_TEX_TEXDESC_0_LAYOUT_SWIZZLED                      0x00000001
#define LWE297_TEX_TEXDESC_0_LAYOUT_TILED_LINEAR                  0x00000002
#define LWE297_TEX_TEXDESC_0_LAYOUT_TILED_SWIZZLED                        0x00000003
#define LWE297_TEX_TEXDESC_0_LAYOUT_XY_TILED_LINEAR                       0x00000004
#define LWE297_TEX_TEXDESC_0_LAYOUT_XY_TILED_SWIZZLED                     0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_0_MIRROR_S                              3:3
#define LWE297_TEX_TEXDESC_0_MIRROR_S_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_0_MIRROR_S_ENABLE                      0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_0_MIRROR_T                              2:2
#define LWE297_TEX_TEXDESC_0_MIRROR_T_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_0_MIRROR_T_ENABLE                      0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_0_CLAMP_S                               1:1
#define LWE297_TEX_TEXDESC_0_CLAMP_S_WRAP                 0x00000000
#define LWE297_TEX_TEXDESC_0_CLAMP_S_CLAMP                        0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_0_CLAMP_T                               0:0
#define LWE297_TEX_TEXDESC_0_CLAMP_T_WRAP                 0x00000000
#define LWE297_TEX_TEXDESC_0_CLAMP_T_CLAMP                        0x00000001


// Register LWE297_TEX_TEXDESC  
#define LWE297_TEX_TEXDESC                                  0x720
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_WIDTH                           31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_HEIGHT                          19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_NORMALIZE                               7:7
#define LWE297_TEX_TEXDESC_NORMALIZE_DISABLE                      0x00000000
#define LWE297_TEX_TEXDESC_NORMALIZE_ENABLE                       0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_LOG2_WIDTH                              31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_LOG2_HEIGHT                             27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_LOD_MIN                         23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_LOD_MAX                         15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_BASE_LEVEL_ONLY                         7:7
#define LWE297_TEX_TEXDESC_BASE_LEVEL_ONLY_DISABLE                        0x00000000
#define LWE297_TEX_TEXDESC_BASE_LEVEL_ONLY_ENABLE                 0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_NON_POWER_OF_TWO                        6:6
#define LWE297_TEX_TEXDESC_NON_POWER_OF_TWO_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_NON_POWER_OF_TWO_ENABLE                        0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_ARRAY_MAX                               5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_TRILINEAR_OPT                           30:30
#define LWE297_TEX_TEXDESC_TRILINEAR_OPT_DISABLE                  0x00000000
#define LWE297_TEX_TEXDESC_TRILINEAR_OPT_ENABLE                   0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_LERP_MAG                        29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_LERP_MIN                        28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_LERP_MIP                        27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_LOD_BIAS                        26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_MAX_ANISO                               17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_SURF_FORMAT                             13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_LWBEMAP                         7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_LAYOUT                          6:4
#define LWE297_TEX_TEXDESC_LAYOUT_LINEAR                  0x00000000
#define LWE297_TEX_TEXDESC_LAYOUT_SWIZZLED                        0x00000001
#define LWE297_TEX_TEXDESC_LAYOUT_TILED_LINEAR                    0x00000002
#define LWE297_TEX_TEXDESC_LAYOUT_TILED_SWIZZLED                  0x00000003
#define LWE297_TEX_TEXDESC_LAYOUT_XY_TILED_LINEAR                 0x00000004
#define LWE297_TEX_TEXDESC_LAYOUT_XY_TILED_SWIZZLED                       0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_MIRROR_S                        3:3
#define LWE297_TEX_TEXDESC_MIRROR_S_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_MIRROR_S_ENABLE                        0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_MIRROR_T                        2:2
#define LWE297_TEX_TEXDESC_MIRROR_T_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_MIRROR_T_ENABLE                        0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_CLAMP_S                         1:1
#define LWE297_TEX_TEXDESC_CLAMP_S_WRAP                   0x00000000
#define LWE297_TEX_TEXDESC_CLAMP_S_CLAMP                  0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_CLAMP_T                         0:0
#define LWE297_TEX_TEXDESC_CLAMP_T_WRAP                   0x00000000
#define LWE297_TEX_TEXDESC_CLAMP_T_CLAMP                  0x00000001


// Register LWE297_TEX_TEXDESC_1  
#define LWE297_TEX_TEXDESC_1                                0x721
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_1_WIDTH                         31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_1_HEIGHT                        19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_1_NORMALIZE                             7:7
#define LWE297_TEX_TEXDESC_1_NORMALIZE_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_1_NORMALIZE_ENABLE                     0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_1_LOG2_WIDTH                            31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_1_LOG2_HEIGHT                           27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_1_LOD_MIN                               23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_1_LOD_MAX                               15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_1_BASE_LEVEL_ONLY                               7:7
#define LWE297_TEX_TEXDESC_1_BASE_LEVEL_ONLY_DISABLE                      0x00000000
#define LWE297_TEX_TEXDESC_1_BASE_LEVEL_ONLY_ENABLE                       0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_1_NON_POWER_OF_TWO                              6:6
#define LWE297_TEX_TEXDESC_1_NON_POWER_OF_TWO_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_1_NON_POWER_OF_TWO_ENABLE                      0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_1_ARRAY_MAX                             5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_1_TRILINEAR_OPT                         30:30
#define LWE297_TEX_TEXDESC_1_TRILINEAR_OPT_DISABLE                        0x00000000
#define LWE297_TEX_TEXDESC_1_TRILINEAR_OPT_ENABLE                 0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_1_LERP_MAG                              29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_1_LERP_MIN                              28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_1_LERP_MIP                              27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_1_LOD_BIAS                              26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_1_MAX_ANISO                             17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_1_SURF_FORMAT                           13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_1_LWBEMAP                               7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_1_LAYOUT                        6:4
#define LWE297_TEX_TEXDESC_1_LAYOUT_LINEAR                        0x00000000
#define LWE297_TEX_TEXDESC_1_LAYOUT_SWIZZLED                      0x00000001
#define LWE297_TEX_TEXDESC_1_LAYOUT_TILED_LINEAR                  0x00000002
#define LWE297_TEX_TEXDESC_1_LAYOUT_TILED_SWIZZLED                        0x00000003
#define LWE297_TEX_TEXDESC_1_LAYOUT_XY_TILED_LINEAR                       0x00000004
#define LWE297_TEX_TEXDESC_1_LAYOUT_XY_TILED_SWIZZLED                     0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_1_MIRROR_S                              3:3
#define LWE297_TEX_TEXDESC_1_MIRROR_S_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_1_MIRROR_S_ENABLE                      0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_1_MIRROR_T                              2:2
#define LWE297_TEX_TEXDESC_1_MIRROR_T_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_1_MIRROR_T_ENABLE                      0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_1_CLAMP_S                               1:1
#define LWE297_TEX_TEXDESC_1_CLAMP_S_WRAP                 0x00000000
#define LWE297_TEX_TEXDESC_1_CLAMP_S_CLAMP                        0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_1_CLAMP_T                               0:0
#define LWE297_TEX_TEXDESC_1_CLAMP_T_WRAP                 0x00000000
#define LWE297_TEX_TEXDESC_1_CLAMP_T_CLAMP                        0x00000001


// Register LWE297_TEX_TEXDESC_2  
#define LWE297_TEX_TEXDESC_2                                0x722
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_2_WIDTH                         31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_2_HEIGHT                        19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_2_NORMALIZE                             7:7
#define LWE297_TEX_TEXDESC_2_NORMALIZE_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_2_NORMALIZE_ENABLE                     0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_2_LOG2_WIDTH                            31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_2_LOG2_HEIGHT                           27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_2_LOD_MIN                               23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_2_LOD_MAX                               15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_2_BASE_LEVEL_ONLY                               7:7
#define LWE297_TEX_TEXDESC_2_BASE_LEVEL_ONLY_DISABLE                      0x00000000
#define LWE297_TEX_TEXDESC_2_BASE_LEVEL_ONLY_ENABLE                       0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_2_NON_POWER_OF_TWO                              6:6
#define LWE297_TEX_TEXDESC_2_NON_POWER_OF_TWO_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_2_NON_POWER_OF_TWO_ENABLE                      0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_2_ARRAY_MAX                             5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_2_TRILINEAR_OPT                         30:30
#define LWE297_TEX_TEXDESC_2_TRILINEAR_OPT_DISABLE                        0x00000000
#define LWE297_TEX_TEXDESC_2_TRILINEAR_OPT_ENABLE                 0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_2_LERP_MAG                              29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_2_LERP_MIN                              28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_2_LERP_MIP                              27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_2_LOD_BIAS                              26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_2_MAX_ANISO                             17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_2_SURF_FORMAT                           13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_2_LWBEMAP                               7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_2_LAYOUT                        6:4
#define LWE297_TEX_TEXDESC_2_LAYOUT_LINEAR                        0x00000000
#define LWE297_TEX_TEXDESC_2_LAYOUT_SWIZZLED                      0x00000001
#define LWE297_TEX_TEXDESC_2_LAYOUT_TILED_LINEAR                  0x00000002
#define LWE297_TEX_TEXDESC_2_LAYOUT_TILED_SWIZZLED                        0x00000003
#define LWE297_TEX_TEXDESC_2_LAYOUT_XY_TILED_LINEAR                       0x00000004
#define LWE297_TEX_TEXDESC_2_LAYOUT_XY_TILED_SWIZZLED                     0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_2_MIRROR_S                              3:3
#define LWE297_TEX_TEXDESC_2_MIRROR_S_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_2_MIRROR_S_ENABLE                      0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_2_MIRROR_T                              2:2
#define LWE297_TEX_TEXDESC_2_MIRROR_T_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_2_MIRROR_T_ENABLE                      0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_2_CLAMP_S                               1:1
#define LWE297_TEX_TEXDESC_2_CLAMP_S_WRAP                 0x00000000
#define LWE297_TEX_TEXDESC_2_CLAMP_S_CLAMP                        0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_2_CLAMP_T                               0:0
#define LWE297_TEX_TEXDESC_2_CLAMP_T_WRAP                 0x00000000
#define LWE297_TEX_TEXDESC_2_CLAMP_T_CLAMP                        0x00000001


// Register LWE297_TEX_TEXDESC_3  
#define LWE297_TEX_TEXDESC_3                                0x723
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_3_WIDTH                         31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_3_HEIGHT                        19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_3_NORMALIZE                             7:7
#define LWE297_TEX_TEXDESC_3_NORMALIZE_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_3_NORMALIZE_ENABLE                     0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_3_LOG2_WIDTH                            31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_3_LOG2_HEIGHT                           27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_3_LOD_MIN                               23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_3_LOD_MAX                               15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_3_BASE_LEVEL_ONLY                               7:7
#define LWE297_TEX_TEXDESC_3_BASE_LEVEL_ONLY_DISABLE                      0x00000000
#define LWE297_TEX_TEXDESC_3_BASE_LEVEL_ONLY_ENABLE                       0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_3_NON_POWER_OF_TWO                              6:6
#define LWE297_TEX_TEXDESC_3_NON_POWER_OF_TWO_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_3_NON_POWER_OF_TWO_ENABLE                      0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_3_ARRAY_MAX                             5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_3_TRILINEAR_OPT                         30:30
#define LWE297_TEX_TEXDESC_3_TRILINEAR_OPT_DISABLE                        0x00000000
#define LWE297_TEX_TEXDESC_3_TRILINEAR_OPT_ENABLE                 0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_3_LERP_MAG                              29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_3_LERP_MIN                              28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_3_LERP_MIP                              27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_3_LOD_BIAS                              26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_3_MAX_ANISO                             17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_3_SURF_FORMAT                           13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_3_LWBEMAP                               7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_3_LAYOUT                        6:4
#define LWE297_TEX_TEXDESC_3_LAYOUT_LINEAR                        0x00000000
#define LWE297_TEX_TEXDESC_3_LAYOUT_SWIZZLED                      0x00000001
#define LWE297_TEX_TEXDESC_3_LAYOUT_TILED_LINEAR                  0x00000002
#define LWE297_TEX_TEXDESC_3_LAYOUT_TILED_SWIZZLED                        0x00000003
#define LWE297_TEX_TEXDESC_3_LAYOUT_XY_TILED_LINEAR                       0x00000004
#define LWE297_TEX_TEXDESC_3_LAYOUT_XY_TILED_SWIZZLED                     0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_3_MIRROR_S                              3:3
#define LWE297_TEX_TEXDESC_3_MIRROR_S_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_3_MIRROR_S_ENABLE                      0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_3_MIRROR_T                              2:2
#define LWE297_TEX_TEXDESC_3_MIRROR_T_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_3_MIRROR_T_ENABLE                      0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_3_CLAMP_S                               1:1
#define LWE297_TEX_TEXDESC_3_CLAMP_S_WRAP                 0x00000000
#define LWE297_TEX_TEXDESC_3_CLAMP_S_CLAMP                        0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_3_CLAMP_T                               0:0
#define LWE297_TEX_TEXDESC_3_CLAMP_T_WRAP                 0x00000000
#define LWE297_TEX_TEXDESC_3_CLAMP_T_CLAMP                        0x00000001


// Register LWE297_TEX_TEXDESC_4  
#define LWE297_TEX_TEXDESC_4                                0x724
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_4_WIDTH                         31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_4_HEIGHT                        19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_4_NORMALIZE                             7:7
#define LWE297_TEX_TEXDESC_4_NORMALIZE_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_4_NORMALIZE_ENABLE                     0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_4_LOG2_WIDTH                            31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_4_LOG2_HEIGHT                           27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_4_LOD_MIN                               23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_4_LOD_MAX                               15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_4_BASE_LEVEL_ONLY                               7:7
#define LWE297_TEX_TEXDESC_4_BASE_LEVEL_ONLY_DISABLE                      0x00000000
#define LWE297_TEX_TEXDESC_4_BASE_LEVEL_ONLY_ENABLE                       0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_4_NON_POWER_OF_TWO                              6:6
#define LWE297_TEX_TEXDESC_4_NON_POWER_OF_TWO_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_4_NON_POWER_OF_TWO_ENABLE                      0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_4_ARRAY_MAX                             5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_4_TRILINEAR_OPT                         30:30
#define LWE297_TEX_TEXDESC_4_TRILINEAR_OPT_DISABLE                        0x00000000
#define LWE297_TEX_TEXDESC_4_TRILINEAR_OPT_ENABLE                 0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_4_LERP_MAG                              29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_4_LERP_MIN                              28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_4_LERP_MIP                              27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_4_LOD_BIAS                              26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_4_MAX_ANISO                             17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_4_SURF_FORMAT                           13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_4_LWBEMAP                               7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_4_LAYOUT                        6:4
#define LWE297_TEX_TEXDESC_4_LAYOUT_LINEAR                        0x00000000
#define LWE297_TEX_TEXDESC_4_LAYOUT_SWIZZLED                      0x00000001
#define LWE297_TEX_TEXDESC_4_LAYOUT_TILED_LINEAR                  0x00000002
#define LWE297_TEX_TEXDESC_4_LAYOUT_TILED_SWIZZLED                        0x00000003
#define LWE297_TEX_TEXDESC_4_LAYOUT_XY_TILED_LINEAR                       0x00000004
#define LWE297_TEX_TEXDESC_4_LAYOUT_XY_TILED_SWIZZLED                     0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_4_MIRROR_S                              3:3
#define LWE297_TEX_TEXDESC_4_MIRROR_S_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_4_MIRROR_S_ENABLE                      0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_4_MIRROR_T                              2:2
#define LWE297_TEX_TEXDESC_4_MIRROR_T_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_4_MIRROR_T_ENABLE                      0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_4_CLAMP_S                               1:1
#define LWE297_TEX_TEXDESC_4_CLAMP_S_WRAP                 0x00000000
#define LWE297_TEX_TEXDESC_4_CLAMP_S_CLAMP                        0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_4_CLAMP_T                               0:0
#define LWE297_TEX_TEXDESC_4_CLAMP_T_WRAP                 0x00000000
#define LWE297_TEX_TEXDESC_4_CLAMP_T_CLAMP                        0x00000001


// Register LWE297_TEX_TEXDESC_5  
#define LWE297_TEX_TEXDESC_5                                0x725
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_5_WIDTH                         31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_5_HEIGHT                        19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_5_NORMALIZE                             7:7
#define LWE297_TEX_TEXDESC_5_NORMALIZE_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_5_NORMALIZE_ENABLE                     0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_5_LOG2_WIDTH                            31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_5_LOG2_HEIGHT                           27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_5_LOD_MIN                               23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_5_LOD_MAX                               15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_5_BASE_LEVEL_ONLY                               7:7
#define LWE297_TEX_TEXDESC_5_BASE_LEVEL_ONLY_DISABLE                      0x00000000
#define LWE297_TEX_TEXDESC_5_BASE_LEVEL_ONLY_ENABLE                       0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_5_NON_POWER_OF_TWO                              6:6
#define LWE297_TEX_TEXDESC_5_NON_POWER_OF_TWO_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_5_NON_POWER_OF_TWO_ENABLE                      0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_5_ARRAY_MAX                             5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_5_TRILINEAR_OPT                         30:30
#define LWE297_TEX_TEXDESC_5_TRILINEAR_OPT_DISABLE                        0x00000000
#define LWE297_TEX_TEXDESC_5_TRILINEAR_OPT_ENABLE                 0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_5_LERP_MAG                              29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_5_LERP_MIN                              28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_5_LERP_MIP                              27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_5_LOD_BIAS                              26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_5_MAX_ANISO                             17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_5_SURF_FORMAT                           13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_5_LWBEMAP                               7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_5_LAYOUT                        6:4
#define LWE297_TEX_TEXDESC_5_LAYOUT_LINEAR                        0x00000000
#define LWE297_TEX_TEXDESC_5_LAYOUT_SWIZZLED                      0x00000001
#define LWE297_TEX_TEXDESC_5_LAYOUT_TILED_LINEAR                  0x00000002
#define LWE297_TEX_TEXDESC_5_LAYOUT_TILED_SWIZZLED                        0x00000003
#define LWE297_TEX_TEXDESC_5_LAYOUT_XY_TILED_LINEAR                       0x00000004
#define LWE297_TEX_TEXDESC_5_LAYOUT_XY_TILED_SWIZZLED                     0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_5_MIRROR_S                              3:3
#define LWE297_TEX_TEXDESC_5_MIRROR_S_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_5_MIRROR_S_ENABLE                      0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_5_MIRROR_T                              2:2
#define LWE297_TEX_TEXDESC_5_MIRROR_T_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_5_MIRROR_T_ENABLE                      0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_5_CLAMP_S                               1:1
#define LWE297_TEX_TEXDESC_5_CLAMP_S_WRAP                 0x00000000
#define LWE297_TEX_TEXDESC_5_CLAMP_S_CLAMP                        0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_5_CLAMP_T                               0:0
#define LWE297_TEX_TEXDESC_5_CLAMP_T_WRAP                 0x00000000
#define LWE297_TEX_TEXDESC_5_CLAMP_T_CLAMP                        0x00000001


// Register LWE297_TEX_TEXDESC_6  
#define LWE297_TEX_TEXDESC_6                                0x726
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_6_WIDTH                         31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_6_HEIGHT                        19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_6_NORMALIZE                             7:7
#define LWE297_TEX_TEXDESC_6_NORMALIZE_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_6_NORMALIZE_ENABLE                     0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_6_LOG2_WIDTH                            31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_6_LOG2_HEIGHT                           27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_6_LOD_MIN                               23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_6_LOD_MAX                               15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_6_BASE_LEVEL_ONLY                               7:7
#define LWE297_TEX_TEXDESC_6_BASE_LEVEL_ONLY_DISABLE                      0x00000000
#define LWE297_TEX_TEXDESC_6_BASE_LEVEL_ONLY_ENABLE                       0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_6_NON_POWER_OF_TWO                              6:6
#define LWE297_TEX_TEXDESC_6_NON_POWER_OF_TWO_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_6_NON_POWER_OF_TWO_ENABLE                      0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_6_ARRAY_MAX                             5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_6_TRILINEAR_OPT                         30:30
#define LWE297_TEX_TEXDESC_6_TRILINEAR_OPT_DISABLE                        0x00000000
#define LWE297_TEX_TEXDESC_6_TRILINEAR_OPT_ENABLE                 0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_6_LERP_MAG                              29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_6_LERP_MIN                              28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_6_LERP_MIP                              27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_6_LOD_BIAS                              26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_6_MAX_ANISO                             17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_6_SURF_FORMAT                           13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_6_LWBEMAP                               7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_6_LAYOUT                        6:4
#define LWE297_TEX_TEXDESC_6_LAYOUT_LINEAR                        0x00000000
#define LWE297_TEX_TEXDESC_6_LAYOUT_SWIZZLED                      0x00000001
#define LWE297_TEX_TEXDESC_6_LAYOUT_TILED_LINEAR                  0x00000002
#define LWE297_TEX_TEXDESC_6_LAYOUT_TILED_SWIZZLED                        0x00000003
#define LWE297_TEX_TEXDESC_6_LAYOUT_XY_TILED_LINEAR                       0x00000004
#define LWE297_TEX_TEXDESC_6_LAYOUT_XY_TILED_SWIZZLED                     0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_6_MIRROR_S                              3:3
#define LWE297_TEX_TEXDESC_6_MIRROR_S_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_6_MIRROR_S_ENABLE                      0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_6_MIRROR_T                              2:2
#define LWE297_TEX_TEXDESC_6_MIRROR_T_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_6_MIRROR_T_ENABLE                      0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_6_CLAMP_S                               1:1
#define LWE297_TEX_TEXDESC_6_CLAMP_S_WRAP                 0x00000000
#define LWE297_TEX_TEXDESC_6_CLAMP_S_CLAMP                        0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_6_CLAMP_T                               0:0
#define LWE297_TEX_TEXDESC_6_CLAMP_T_WRAP                 0x00000000
#define LWE297_TEX_TEXDESC_6_CLAMP_T_CLAMP                        0x00000001


// Register LWE297_TEX_TEXDESC_7  
#define LWE297_TEX_TEXDESC_7                                0x727
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_7_WIDTH                         31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_7_HEIGHT                        19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_7_NORMALIZE                             7:7
#define LWE297_TEX_TEXDESC_7_NORMALIZE_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_7_NORMALIZE_ENABLE                     0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_7_LOG2_WIDTH                            31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_7_LOG2_HEIGHT                           27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_7_LOD_MIN                               23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_7_LOD_MAX                               15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_7_BASE_LEVEL_ONLY                               7:7
#define LWE297_TEX_TEXDESC_7_BASE_LEVEL_ONLY_DISABLE                      0x00000000
#define LWE297_TEX_TEXDESC_7_BASE_LEVEL_ONLY_ENABLE                       0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_7_NON_POWER_OF_TWO                              6:6
#define LWE297_TEX_TEXDESC_7_NON_POWER_OF_TWO_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_7_NON_POWER_OF_TWO_ENABLE                      0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_7_ARRAY_MAX                             5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_7_TRILINEAR_OPT                         30:30
#define LWE297_TEX_TEXDESC_7_TRILINEAR_OPT_DISABLE                        0x00000000
#define LWE297_TEX_TEXDESC_7_TRILINEAR_OPT_ENABLE                 0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_7_LERP_MAG                              29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_7_LERP_MIN                              28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_7_LERP_MIP                              27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_7_LOD_BIAS                              26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_7_MAX_ANISO                             17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_7_SURF_FORMAT                           13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_7_LWBEMAP                               7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_7_LAYOUT                        6:4
#define LWE297_TEX_TEXDESC_7_LAYOUT_LINEAR                        0x00000000
#define LWE297_TEX_TEXDESC_7_LAYOUT_SWIZZLED                      0x00000001
#define LWE297_TEX_TEXDESC_7_LAYOUT_TILED_LINEAR                  0x00000002
#define LWE297_TEX_TEXDESC_7_LAYOUT_TILED_SWIZZLED                        0x00000003
#define LWE297_TEX_TEXDESC_7_LAYOUT_XY_TILED_LINEAR                       0x00000004
#define LWE297_TEX_TEXDESC_7_LAYOUT_XY_TILED_SWIZZLED                     0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_7_MIRROR_S                              3:3
#define LWE297_TEX_TEXDESC_7_MIRROR_S_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_7_MIRROR_S_ENABLE                      0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_7_MIRROR_T                              2:2
#define LWE297_TEX_TEXDESC_7_MIRROR_T_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_7_MIRROR_T_ENABLE                      0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_7_CLAMP_S                               1:1
#define LWE297_TEX_TEXDESC_7_CLAMP_S_WRAP                 0x00000000
#define LWE297_TEX_TEXDESC_7_CLAMP_S_CLAMP                        0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_7_CLAMP_T                               0:0
#define LWE297_TEX_TEXDESC_7_CLAMP_T_WRAP                 0x00000000
#define LWE297_TEX_TEXDESC_7_CLAMP_T_CLAMP                        0x00000001


// Register LWE297_TEX_TEXDESC_8  
#define LWE297_TEX_TEXDESC_8                                0x728
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_8_WIDTH                         31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_8_HEIGHT                        19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_8_NORMALIZE                             7:7
#define LWE297_TEX_TEXDESC_8_NORMALIZE_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_8_NORMALIZE_ENABLE                     0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_8_LOG2_WIDTH                            31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_8_LOG2_HEIGHT                           27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_8_LOD_MIN                               23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_8_LOD_MAX                               15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_8_BASE_LEVEL_ONLY                               7:7
#define LWE297_TEX_TEXDESC_8_BASE_LEVEL_ONLY_DISABLE                      0x00000000
#define LWE297_TEX_TEXDESC_8_BASE_LEVEL_ONLY_ENABLE                       0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_8_NON_POWER_OF_TWO                              6:6
#define LWE297_TEX_TEXDESC_8_NON_POWER_OF_TWO_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_8_NON_POWER_OF_TWO_ENABLE                      0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_8_ARRAY_MAX                             5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_8_TRILINEAR_OPT                         30:30
#define LWE297_TEX_TEXDESC_8_TRILINEAR_OPT_DISABLE                        0x00000000
#define LWE297_TEX_TEXDESC_8_TRILINEAR_OPT_ENABLE                 0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_8_LERP_MAG                              29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_8_LERP_MIN                              28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_8_LERP_MIP                              27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_8_LOD_BIAS                              26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_8_MAX_ANISO                             17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_8_SURF_FORMAT                           13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_8_LWBEMAP                               7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_8_LAYOUT                        6:4
#define LWE297_TEX_TEXDESC_8_LAYOUT_LINEAR                        0x00000000
#define LWE297_TEX_TEXDESC_8_LAYOUT_SWIZZLED                      0x00000001
#define LWE297_TEX_TEXDESC_8_LAYOUT_TILED_LINEAR                  0x00000002
#define LWE297_TEX_TEXDESC_8_LAYOUT_TILED_SWIZZLED                        0x00000003
#define LWE297_TEX_TEXDESC_8_LAYOUT_XY_TILED_LINEAR                       0x00000004
#define LWE297_TEX_TEXDESC_8_LAYOUT_XY_TILED_SWIZZLED                     0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_8_MIRROR_S                              3:3
#define LWE297_TEX_TEXDESC_8_MIRROR_S_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_8_MIRROR_S_ENABLE                      0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_8_MIRROR_T                              2:2
#define LWE297_TEX_TEXDESC_8_MIRROR_T_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_8_MIRROR_T_ENABLE                      0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_8_CLAMP_S                               1:1
#define LWE297_TEX_TEXDESC_8_CLAMP_S_WRAP                 0x00000000
#define LWE297_TEX_TEXDESC_8_CLAMP_S_CLAMP                        0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_8_CLAMP_T                               0:0
#define LWE297_TEX_TEXDESC_8_CLAMP_T_WRAP                 0x00000000
#define LWE297_TEX_TEXDESC_8_CLAMP_T_CLAMP                        0x00000001


// Register LWE297_TEX_TEXDESC_9  
#define LWE297_TEX_TEXDESC_9                                0x729
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_9_WIDTH                         31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_9_HEIGHT                        19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_9_NORMALIZE                             7:7
#define LWE297_TEX_TEXDESC_9_NORMALIZE_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_9_NORMALIZE_ENABLE                     0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_9_LOG2_WIDTH                            31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_9_LOG2_HEIGHT                           27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_9_LOD_MIN                               23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_9_LOD_MAX                               15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_9_BASE_LEVEL_ONLY                               7:7
#define LWE297_TEX_TEXDESC_9_BASE_LEVEL_ONLY_DISABLE                      0x00000000
#define LWE297_TEX_TEXDESC_9_BASE_LEVEL_ONLY_ENABLE                       0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_9_NON_POWER_OF_TWO                              6:6
#define LWE297_TEX_TEXDESC_9_NON_POWER_OF_TWO_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_9_NON_POWER_OF_TWO_ENABLE                      0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_9_ARRAY_MAX                             5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_9_TRILINEAR_OPT                         30:30
#define LWE297_TEX_TEXDESC_9_TRILINEAR_OPT_DISABLE                        0x00000000
#define LWE297_TEX_TEXDESC_9_TRILINEAR_OPT_ENABLE                 0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_9_LERP_MAG                              29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_9_LERP_MIN                              28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_9_LERP_MIP                              27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_9_LOD_BIAS                              26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_9_MAX_ANISO                             17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_9_SURF_FORMAT                           13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_9_LWBEMAP                               7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_9_LAYOUT                        6:4
#define LWE297_TEX_TEXDESC_9_LAYOUT_LINEAR                        0x00000000
#define LWE297_TEX_TEXDESC_9_LAYOUT_SWIZZLED                      0x00000001
#define LWE297_TEX_TEXDESC_9_LAYOUT_TILED_LINEAR                  0x00000002
#define LWE297_TEX_TEXDESC_9_LAYOUT_TILED_SWIZZLED                        0x00000003
#define LWE297_TEX_TEXDESC_9_LAYOUT_XY_TILED_LINEAR                       0x00000004
#define LWE297_TEX_TEXDESC_9_LAYOUT_XY_TILED_SWIZZLED                     0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_9_MIRROR_S                              3:3
#define LWE297_TEX_TEXDESC_9_MIRROR_S_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_9_MIRROR_S_ENABLE                      0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_9_MIRROR_T                              2:2
#define LWE297_TEX_TEXDESC_9_MIRROR_T_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_9_MIRROR_T_ENABLE                      0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_9_CLAMP_S                               1:1
#define LWE297_TEX_TEXDESC_9_CLAMP_S_WRAP                 0x00000000
#define LWE297_TEX_TEXDESC_9_CLAMP_S_CLAMP                        0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_9_CLAMP_T                               0:0
#define LWE297_TEX_TEXDESC_9_CLAMP_T_WRAP                 0x00000000
#define LWE297_TEX_TEXDESC_9_CLAMP_T_CLAMP                        0x00000001


// Register LWE297_TEX_TEXDESC_10  
#define LWE297_TEX_TEXDESC_10                               0x72a
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_10_WIDTH                        31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_10_HEIGHT                               19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_10_NORMALIZE                            7:7
#define LWE297_TEX_TEXDESC_10_NORMALIZE_DISABLE                   0x00000000
#define LWE297_TEX_TEXDESC_10_NORMALIZE_ENABLE                    0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_10_LOG2_WIDTH                           31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_10_LOG2_HEIGHT                          27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_10_LOD_MIN                              23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_10_LOD_MAX                              15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_10_BASE_LEVEL_ONLY                              7:7
#define LWE297_TEX_TEXDESC_10_BASE_LEVEL_ONLY_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_10_BASE_LEVEL_ONLY_ENABLE                      0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_10_NON_POWER_OF_TWO                             6:6
#define LWE297_TEX_TEXDESC_10_NON_POWER_OF_TWO_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_10_NON_POWER_OF_TWO_ENABLE                     0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_10_ARRAY_MAX                            5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_10_TRILINEAR_OPT                        30:30
#define LWE297_TEX_TEXDESC_10_TRILINEAR_OPT_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_10_TRILINEAR_OPT_ENABLE                        0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_10_LERP_MAG                             29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_10_LERP_MIN                             28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_10_LERP_MIP                             27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_10_LOD_BIAS                             26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_10_MAX_ANISO                            17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_10_SURF_FORMAT                          13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_10_LWBEMAP                              7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_10_LAYOUT                               6:4
#define LWE297_TEX_TEXDESC_10_LAYOUT_LINEAR                       0x00000000
#define LWE297_TEX_TEXDESC_10_LAYOUT_SWIZZLED                     0x00000001
#define LWE297_TEX_TEXDESC_10_LAYOUT_TILED_LINEAR                 0x00000002
#define LWE297_TEX_TEXDESC_10_LAYOUT_TILED_SWIZZLED                       0x00000003
#define LWE297_TEX_TEXDESC_10_LAYOUT_XY_TILED_LINEAR                      0x00000004
#define LWE297_TEX_TEXDESC_10_LAYOUT_XY_TILED_SWIZZLED                    0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_10_MIRROR_S                             3:3
#define LWE297_TEX_TEXDESC_10_MIRROR_S_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_10_MIRROR_S_ENABLE                     0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_10_MIRROR_T                             2:2
#define LWE297_TEX_TEXDESC_10_MIRROR_T_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_10_MIRROR_T_ENABLE                     0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_10_CLAMP_S                              1:1
#define LWE297_TEX_TEXDESC_10_CLAMP_S_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_10_CLAMP_S_CLAMP                       0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_10_CLAMP_T                              0:0
#define LWE297_TEX_TEXDESC_10_CLAMP_T_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_10_CLAMP_T_CLAMP                       0x00000001


// Register LWE297_TEX_TEXDESC_11  
#define LWE297_TEX_TEXDESC_11                               0x72b
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_11_WIDTH                        31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_11_HEIGHT                               19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_11_NORMALIZE                            7:7
#define LWE297_TEX_TEXDESC_11_NORMALIZE_DISABLE                   0x00000000
#define LWE297_TEX_TEXDESC_11_NORMALIZE_ENABLE                    0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_11_LOG2_WIDTH                           31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_11_LOG2_HEIGHT                          27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_11_LOD_MIN                              23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_11_LOD_MAX                              15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_11_BASE_LEVEL_ONLY                              7:7
#define LWE297_TEX_TEXDESC_11_BASE_LEVEL_ONLY_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_11_BASE_LEVEL_ONLY_ENABLE                      0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_11_NON_POWER_OF_TWO                             6:6
#define LWE297_TEX_TEXDESC_11_NON_POWER_OF_TWO_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_11_NON_POWER_OF_TWO_ENABLE                     0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_11_ARRAY_MAX                            5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_11_TRILINEAR_OPT                        30:30
#define LWE297_TEX_TEXDESC_11_TRILINEAR_OPT_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_11_TRILINEAR_OPT_ENABLE                        0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_11_LERP_MAG                             29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_11_LERP_MIN                             28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_11_LERP_MIP                             27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_11_LOD_BIAS                             26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_11_MAX_ANISO                            17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_11_SURF_FORMAT                          13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_11_LWBEMAP                              7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_11_LAYOUT                               6:4
#define LWE297_TEX_TEXDESC_11_LAYOUT_LINEAR                       0x00000000
#define LWE297_TEX_TEXDESC_11_LAYOUT_SWIZZLED                     0x00000001
#define LWE297_TEX_TEXDESC_11_LAYOUT_TILED_LINEAR                 0x00000002
#define LWE297_TEX_TEXDESC_11_LAYOUT_TILED_SWIZZLED                       0x00000003
#define LWE297_TEX_TEXDESC_11_LAYOUT_XY_TILED_LINEAR                      0x00000004
#define LWE297_TEX_TEXDESC_11_LAYOUT_XY_TILED_SWIZZLED                    0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_11_MIRROR_S                             3:3
#define LWE297_TEX_TEXDESC_11_MIRROR_S_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_11_MIRROR_S_ENABLE                     0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_11_MIRROR_T                             2:2
#define LWE297_TEX_TEXDESC_11_MIRROR_T_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_11_MIRROR_T_ENABLE                     0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_11_CLAMP_S                              1:1
#define LWE297_TEX_TEXDESC_11_CLAMP_S_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_11_CLAMP_S_CLAMP                       0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_11_CLAMP_T                              0:0
#define LWE297_TEX_TEXDESC_11_CLAMP_T_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_11_CLAMP_T_CLAMP                       0x00000001


// Register LWE297_TEX_TEXDESC_12  
#define LWE297_TEX_TEXDESC_12                               0x72c
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_12_WIDTH                        31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_12_HEIGHT                               19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_12_NORMALIZE                            7:7
#define LWE297_TEX_TEXDESC_12_NORMALIZE_DISABLE                   0x00000000
#define LWE297_TEX_TEXDESC_12_NORMALIZE_ENABLE                    0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_12_LOG2_WIDTH                           31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_12_LOG2_HEIGHT                          27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_12_LOD_MIN                              23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_12_LOD_MAX                              15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_12_BASE_LEVEL_ONLY                              7:7
#define LWE297_TEX_TEXDESC_12_BASE_LEVEL_ONLY_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_12_BASE_LEVEL_ONLY_ENABLE                      0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_12_NON_POWER_OF_TWO                             6:6
#define LWE297_TEX_TEXDESC_12_NON_POWER_OF_TWO_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_12_NON_POWER_OF_TWO_ENABLE                     0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_12_ARRAY_MAX                            5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_12_TRILINEAR_OPT                        30:30
#define LWE297_TEX_TEXDESC_12_TRILINEAR_OPT_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_12_TRILINEAR_OPT_ENABLE                        0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_12_LERP_MAG                             29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_12_LERP_MIN                             28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_12_LERP_MIP                             27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_12_LOD_BIAS                             26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_12_MAX_ANISO                            17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_12_SURF_FORMAT                          13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_12_LWBEMAP                              7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_12_LAYOUT                               6:4
#define LWE297_TEX_TEXDESC_12_LAYOUT_LINEAR                       0x00000000
#define LWE297_TEX_TEXDESC_12_LAYOUT_SWIZZLED                     0x00000001
#define LWE297_TEX_TEXDESC_12_LAYOUT_TILED_LINEAR                 0x00000002
#define LWE297_TEX_TEXDESC_12_LAYOUT_TILED_SWIZZLED                       0x00000003
#define LWE297_TEX_TEXDESC_12_LAYOUT_XY_TILED_LINEAR                      0x00000004
#define LWE297_TEX_TEXDESC_12_LAYOUT_XY_TILED_SWIZZLED                    0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_12_MIRROR_S                             3:3
#define LWE297_TEX_TEXDESC_12_MIRROR_S_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_12_MIRROR_S_ENABLE                     0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_12_MIRROR_T                             2:2
#define LWE297_TEX_TEXDESC_12_MIRROR_T_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_12_MIRROR_T_ENABLE                     0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_12_CLAMP_S                              1:1
#define LWE297_TEX_TEXDESC_12_CLAMP_S_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_12_CLAMP_S_CLAMP                       0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_12_CLAMP_T                              0:0
#define LWE297_TEX_TEXDESC_12_CLAMP_T_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_12_CLAMP_T_CLAMP                       0x00000001


// Register LWE297_TEX_TEXDESC_13  
#define LWE297_TEX_TEXDESC_13                               0x72d
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_13_WIDTH                        31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_13_HEIGHT                               19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_13_NORMALIZE                            7:7
#define LWE297_TEX_TEXDESC_13_NORMALIZE_DISABLE                   0x00000000
#define LWE297_TEX_TEXDESC_13_NORMALIZE_ENABLE                    0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_13_LOG2_WIDTH                           31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_13_LOG2_HEIGHT                          27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_13_LOD_MIN                              23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_13_LOD_MAX                              15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_13_BASE_LEVEL_ONLY                              7:7
#define LWE297_TEX_TEXDESC_13_BASE_LEVEL_ONLY_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_13_BASE_LEVEL_ONLY_ENABLE                      0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_13_NON_POWER_OF_TWO                             6:6
#define LWE297_TEX_TEXDESC_13_NON_POWER_OF_TWO_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_13_NON_POWER_OF_TWO_ENABLE                     0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_13_ARRAY_MAX                            5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_13_TRILINEAR_OPT                        30:30
#define LWE297_TEX_TEXDESC_13_TRILINEAR_OPT_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_13_TRILINEAR_OPT_ENABLE                        0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_13_LERP_MAG                             29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_13_LERP_MIN                             28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_13_LERP_MIP                             27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_13_LOD_BIAS                             26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_13_MAX_ANISO                            17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_13_SURF_FORMAT                          13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_13_LWBEMAP                              7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_13_LAYOUT                               6:4
#define LWE297_TEX_TEXDESC_13_LAYOUT_LINEAR                       0x00000000
#define LWE297_TEX_TEXDESC_13_LAYOUT_SWIZZLED                     0x00000001
#define LWE297_TEX_TEXDESC_13_LAYOUT_TILED_LINEAR                 0x00000002
#define LWE297_TEX_TEXDESC_13_LAYOUT_TILED_SWIZZLED                       0x00000003
#define LWE297_TEX_TEXDESC_13_LAYOUT_XY_TILED_LINEAR                      0x00000004
#define LWE297_TEX_TEXDESC_13_LAYOUT_XY_TILED_SWIZZLED                    0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_13_MIRROR_S                             3:3
#define LWE297_TEX_TEXDESC_13_MIRROR_S_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_13_MIRROR_S_ENABLE                     0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_13_MIRROR_T                             2:2
#define LWE297_TEX_TEXDESC_13_MIRROR_T_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_13_MIRROR_T_ENABLE                     0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_13_CLAMP_S                              1:1
#define LWE297_TEX_TEXDESC_13_CLAMP_S_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_13_CLAMP_S_CLAMP                       0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_13_CLAMP_T                              0:0
#define LWE297_TEX_TEXDESC_13_CLAMP_T_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_13_CLAMP_T_CLAMP                       0x00000001


// Register LWE297_TEX_TEXDESC_14  
#define LWE297_TEX_TEXDESC_14                               0x72e
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_14_WIDTH                        31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_14_HEIGHT                               19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_14_NORMALIZE                            7:7
#define LWE297_TEX_TEXDESC_14_NORMALIZE_DISABLE                   0x00000000
#define LWE297_TEX_TEXDESC_14_NORMALIZE_ENABLE                    0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_14_LOG2_WIDTH                           31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_14_LOG2_HEIGHT                          27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_14_LOD_MIN                              23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_14_LOD_MAX                              15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_14_BASE_LEVEL_ONLY                              7:7
#define LWE297_TEX_TEXDESC_14_BASE_LEVEL_ONLY_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_14_BASE_LEVEL_ONLY_ENABLE                      0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_14_NON_POWER_OF_TWO                             6:6
#define LWE297_TEX_TEXDESC_14_NON_POWER_OF_TWO_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_14_NON_POWER_OF_TWO_ENABLE                     0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_14_ARRAY_MAX                            5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_14_TRILINEAR_OPT                        30:30
#define LWE297_TEX_TEXDESC_14_TRILINEAR_OPT_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_14_TRILINEAR_OPT_ENABLE                        0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_14_LERP_MAG                             29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_14_LERP_MIN                             28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_14_LERP_MIP                             27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_14_LOD_BIAS                             26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_14_MAX_ANISO                            17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_14_SURF_FORMAT                          13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_14_LWBEMAP                              7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_14_LAYOUT                               6:4
#define LWE297_TEX_TEXDESC_14_LAYOUT_LINEAR                       0x00000000
#define LWE297_TEX_TEXDESC_14_LAYOUT_SWIZZLED                     0x00000001
#define LWE297_TEX_TEXDESC_14_LAYOUT_TILED_LINEAR                 0x00000002
#define LWE297_TEX_TEXDESC_14_LAYOUT_TILED_SWIZZLED                       0x00000003
#define LWE297_TEX_TEXDESC_14_LAYOUT_XY_TILED_LINEAR                      0x00000004
#define LWE297_TEX_TEXDESC_14_LAYOUT_XY_TILED_SWIZZLED                    0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_14_MIRROR_S                             3:3
#define LWE297_TEX_TEXDESC_14_MIRROR_S_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_14_MIRROR_S_ENABLE                     0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_14_MIRROR_T                             2:2
#define LWE297_TEX_TEXDESC_14_MIRROR_T_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_14_MIRROR_T_ENABLE                     0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_14_CLAMP_S                              1:1
#define LWE297_TEX_TEXDESC_14_CLAMP_S_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_14_CLAMP_S_CLAMP                       0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_14_CLAMP_T                              0:0
#define LWE297_TEX_TEXDESC_14_CLAMP_T_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_14_CLAMP_T_CLAMP                       0x00000001


// Register LWE297_TEX_TEXDESC_15  
#define LWE297_TEX_TEXDESC_15                               0x72f
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_15_WIDTH                        31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_15_HEIGHT                               19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_15_NORMALIZE                            7:7
#define LWE297_TEX_TEXDESC_15_NORMALIZE_DISABLE                   0x00000000
#define LWE297_TEX_TEXDESC_15_NORMALIZE_ENABLE                    0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_15_LOG2_WIDTH                           31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_15_LOG2_HEIGHT                          27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_15_LOD_MIN                              23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_15_LOD_MAX                              15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_15_BASE_LEVEL_ONLY                              7:7
#define LWE297_TEX_TEXDESC_15_BASE_LEVEL_ONLY_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_15_BASE_LEVEL_ONLY_ENABLE                      0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_15_NON_POWER_OF_TWO                             6:6
#define LWE297_TEX_TEXDESC_15_NON_POWER_OF_TWO_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_15_NON_POWER_OF_TWO_ENABLE                     0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_15_ARRAY_MAX                            5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_15_TRILINEAR_OPT                        30:30
#define LWE297_TEX_TEXDESC_15_TRILINEAR_OPT_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_15_TRILINEAR_OPT_ENABLE                        0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_15_LERP_MAG                             29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_15_LERP_MIN                             28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_15_LERP_MIP                             27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_15_LOD_BIAS                             26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_15_MAX_ANISO                            17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_15_SURF_FORMAT                          13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_15_LWBEMAP                              7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_15_LAYOUT                               6:4
#define LWE297_TEX_TEXDESC_15_LAYOUT_LINEAR                       0x00000000
#define LWE297_TEX_TEXDESC_15_LAYOUT_SWIZZLED                     0x00000001
#define LWE297_TEX_TEXDESC_15_LAYOUT_TILED_LINEAR                 0x00000002
#define LWE297_TEX_TEXDESC_15_LAYOUT_TILED_SWIZZLED                       0x00000003
#define LWE297_TEX_TEXDESC_15_LAYOUT_XY_TILED_LINEAR                      0x00000004
#define LWE297_TEX_TEXDESC_15_LAYOUT_XY_TILED_SWIZZLED                    0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_15_MIRROR_S                             3:3
#define LWE297_TEX_TEXDESC_15_MIRROR_S_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_15_MIRROR_S_ENABLE                     0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_15_MIRROR_T                             2:2
#define LWE297_TEX_TEXDESC_15_MIRROR_T_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_15_MIRROR_T_ENABLE                     0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_15_CLAMP_S                              1:1
#define LWE297_TEX_TEXDESC_15_CLAMP_S_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_15_CLAMP_S_CLAMP                       0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_15_CLAMP_T                              0:0
#define LWE297_TEX_TEXDESC_15_CLAMP_T_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_15_CLAMP_T_CLAMP                       0x00000001


// Register LWE297_TEX_TEXDESC_16  
#define LWE297_TEX_TEXDESC_16                               0x730
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_16_WIDTH                        31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_16_HEIGHT                               19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_16_NORMALIZE                            7:7
#define LWE297_TEX_TEXDESC_16_NORMALIZE_DISABLE                   0x00000000
#define LWE297_TEX_TEXDESC_16_NORMALIZE_ENABLE                    0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_16_LOG2_WIDTH                           31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_16_LOG2_HEIGHT                          27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_16_LOD_MIN                              23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_16_LOD_MAX                              15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_16_BASE_LEVEL_ONLY                              7:7
#define LWE297_TEX_TEXDESC_16_BASE_LEVEL_ONLY_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_16_BASE_LEVEL_ONLY_ENABLE                      0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_16_NON_POWER_OF_TWO                             6:6
#define LWE297_TEX_TEXDESC_16_NON_POWER_OF_TWO_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_16_NON_POWER_OF_TWO_ENABLE                     0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_16_ARRAY_MAX                            5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_16_TRILINEAR_OPT                        30:30
#define LWE297_TEX_TEXDESC_16_TRILINEAR_OPT_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_16_TRILINEAR_OPT_ENABLE                        0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_16_LERP_MAG                             29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_16_LERP_MIN                             28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_16_LERP_MIP                             27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_16_LOD_BIAS                             26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_16_MAX_ANISO                            17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_16_SURF_FORMAT                          13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_16_LWBEMAP                              7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_16_LAYOUT                               6:4
#define LWE297_TEX_TEXDESC_16_LAYOUT_LINEAR                       0x00000000
#define LWE297_TEX_TEXDESC_16_LAYOUT_SWIZZLED                     0x00000001
#define LWE297_TEX_TEXDESC_16_LAYOUT_TILED_LINEAR                 0x00000002
#define LWE297_TEX_TEXDESC_16_LAYOUT_TILED_SWIZZLED                       0x00000003
#define LWE297_TEX_TEXDESC_16_LAYOUT_XY_TILED_LINEAR                      0x00000004
#define LWE297_TEX_TEXDESC_16_LAYOUT_XY_TILED_SWIZZLED                    0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_16_MIRROR_S                             3:3
#define LWE297_TEX_TEXDESC_16_MIRROR_S_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_16_MIRROR_S_ENABLE                     0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_16_MIRROR_T                             2:2
#define LWE297_TEX_TEXDESC_16_MIRROR_T_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_16_MIRROR_T_ENABLE                     0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_16_CLAMP_S                              1:1
#define LWE297_TEX_TEXDESC_16_CLAMP_S_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_16_CLAMP_S_CLAMP                       0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_16_CLAMP_T                              0:0
#define LWE297_TEX_TEXDESC_16_CLAMP_T_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_16_CLAMP_T_CLAMP                       0x00000001


// Register LWE297_TEX_TEXDESC_17  
#define LWE297_TEX_TEXDESC_17                               0x731
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_17_WIDTH                        31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_17_HEIGHT                               19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_17_NORMALIZE                            7:7
#define LWE297_TEX_TEXDESC_17_NORMALIZE_DISABLE                   0x00000000
#define LWE297_TEX_TEXDESC_17_NORMALIZE_ENABLE                    0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_17_LOG2_WIDTH                           31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_17_LOG2_HEIGHT                          27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_17_LOD_MIN                              23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_17_LOD_MAX                              15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_17_BASE_LEVEL_ONLY                              7:7
#define LWE297_TEX_TEXDESC_17_BASE_LEVEL_ONLY_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_17_BASE_LEVEL_ONLY_ENABLE                      0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_17_NON_POWER_OF_TWO                             6:6
#define LWE297_TEX_TEXDESC_17_NON_POWER_OF_TWO_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_17_NON_POWER_OF_TWO_ENABLE                     0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_17_ARRAY_MAX                            5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_17_TRILINEAR_OPT                        30:30
#define LWE297_TEX_TEXDESC_17_TRILINEAR_OPT_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_17_TRILINEAR_OPT_ENABLE                        0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_17_LERP_MAG                             29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_17_LERP_MIN                             28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_17_LERP_MIP                             27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_17_LOD_BIAS                             26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_17_MAX_ANISO                            17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_17_SURF_FORMAT                          13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_17_LWBEMAP                              7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_17_LAYOUT                               6:4
#define LWE297_TEX_TEXDESC_17_LAYOUT_LINEAR                       0x00000000
#define LWE297_TEX_TEXDESC_17_LAYOUT_SWIZZLED                     0x00000001
#define LWE297_TEX_TEXDESC_17_LAYOUT_TILED_LINEAR                 0x00000002
#define LWE297_TEX_TEXDESC_17_LAYOUT_TILED_SWIZZLED                       0x00000003
#define LWE297_TEX_TEXDESC_17_LAYOUT_XY_TILED_LINEAR                      0x00000004
#define LWE297_TEX_TEXDESC_17_LAYOUT_XY_TILED_SWIZZLED                    0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_17_MIRROR_S                             3:3
#define LWE297_TEX_TEXDESC_17_MIRROR_S_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_17_MIRROR_S_ENABLE                     0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_17_MIRROR_T                             2:2
#define LWE297_TEX_TEXDESC_17_MIRROR_T_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_17_MIRROR_T_ENABLE                     0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_17_CLAMP_S                              1:1
#define LWE297_TEX_TEXDESC_17_CLAMP_S_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_17_CLAMP_S_CLAMP                       0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_17_CLAMP_T                              0:0
#define LWE297_TEX_TEXDESC_17_CLAMP_T_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_17_CLAMP_T_CLAMP                       0x00000001


// Register LWE297_TEX_TEXDESC_18  
#define LWE297_TEX_TEXDESC_18                               0x732
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_18_WIDTH                        31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_18_HEIGHT                               19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_18_NORMALIZE                            7:7
#define LWE297_TEX_TEXDESC_18_NORMALIZE_DISABLE                   0x00000000
#define LWE297_TEX_TEXDESC_18_NORMALIZE_ENABLE                    0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_18_LOG2_WIDTH                           31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_18_LOG2_HEIGHT                          27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_18_LOD_MIN                              23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_18_LOD_MAX                              15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_18_BASE_LEVEL_ONLY                              7:7
#define LWE297_TEX_TEXDESC_18_BASE_LEVEL_ONLY_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_18_BASE_LEVEL_ONLY_ENABLE                      0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_18_NON_POWER_OF_TWO                             6:6
#define LWE297_TEX_TEXDESC_18_NON_POWER_OF_TWO_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_18_NON_POWER_OF_TWO_ENABLE                     0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_18_ARRAY_MAX                            5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_18_TRILINEAR_OPT                        30:30
#define LWE297_TEX_TEXDESC_18_TRILINEAR_OPT_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_18_TRILINEAR_OPT_ENABLE                        0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_18_LERP_MAG                             29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_18_LERP_MIN                             28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_18_LERP_MIP                             27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_18_LOD_BIAS                             26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_18_MAX_ANISO                            17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_18_SURF_FORMAT                          13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_18_LWBEMAP                              7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_18_LAYOUT                               6:4
#define LWE297_TEX_TEXDESC_18_LAYOUT_LINEAR                       0x00000000
#define LWE297_TEX_TEXDESC_18_LAYOUT_SWIZZLED                     0x00000001
#define LWE297_TEX_TEXDESC_18_LAYOUT_TILED_LINEAR                 0x00000002
#define LWE297_TEX_TEXDESC_18_LAYOUT_TILED_SWIZZLED                       0x00000003
#define LWE297_TEX_TEXDESC_18_LAYOUT_XY_TILED_LINEAR                      0x00000004
#define LWE297_TEX_TEXDESC_18_LAYOUT_XY_TILED_SWIZZLED                    0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_18_MIRROR_S                             3:3
#define LWE297_TEX_TEXDESC_18_MIRROR_S_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_18_MIRROR_S_ENABLE                     0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_18_MIRROR_T                             2:2
#define LWE297_TEX_TEXDESC_18_MIRROR_T_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_18_MIRROR_T_ENABLE                     0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_18_CLAMP_S                              1:1
#define LWE297_TEX_TEXDESC_18_CLAMP_S_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_18_CLAMP_S_CLAMP                       0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_18_CLAMP_T                              0:0
#define LWE297_TEX_TEXDESC_18_CLAMP_T_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_18_CLAMP_T_CLAMP                       0x00000001


// Register LWE297_TEX_TEXDESC_19  
#define LWE297_TEX_TEXDESC_19                               0x733
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_19_WIDTH                        31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_19_HEIGHT                               19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_19_NORMALIZE                            7:7
#define LWE297_TEX_TEXDESC_19_NORMALIZE_DISABLE                   0x00000000
#define LWE297_TEX_TEXDESC_19_NORMALIZE_ENABLE                    0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_19_LOG2_WIDTH                           31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_19_LOG2_HEIGHT                          27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_19_LOD_MIN                              23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_19_LOD_MAX                              15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_19_BASE_LEVEL_ONLY                              7:7
#define LWE297_TEX_TEXDESC_19_BASE_LEVEL_ONLY_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_19_BASE_LEVEL_ONLY_ENABLE                      0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_19_NON_POWER_OF_TWO                             6:6
#define LWE297_TEX_TEXDESC_19_NON_POWER_OF_TWO_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_19_NON_POWER_OF_TWO_ENABLE                     0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_19_ARRAY_MAX                            5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_19_TRILINEAR_OPT                        30:30
#define LWE297_TEX_TEXDESC_19_TRILINEAR_OPT_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_19_TRILINEAR_OPT_ENABLE                        0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_19_LERP_MAG                             29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_19_LERP_MIN                             28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_19_LERP_MIP                             27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_19_LOD_BIAS                             26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_19_MAX_ANISO                            17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_19_SURF_FORMAT                          13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_19_LWBEMAP                              7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_19_LAYOUT                               6:4
#define LWE297_TEX_TEXDESC_19_LAYOUT_LINEAR                       0x00000000
#define LWE297_TEX_TEXDESC_19_LAYOUT_SWIZZLED                     0x00000001
#define LWE297_TEX_TEXDESC_19_LAYOUT_TILED_LINEAR                 0x00000002
#define LWE297_TEX_TEXDESC_19_LAYOUT_TILED_SWIZZLED                       0x00000003
#define LWE297_TEX_TEXDESC_19_LAYOUT_XY_TILED_LINEAR                      0x00000004
#define LWE297_TEX_TEXDESC_19_LAYOUT_XY_TILED_SWIZZLED                    0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_19_MIRROR_S                             3:3
#define LWE297_TEX_TEXDESC_19_MIRROR_S_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_19_MIRROR_S_ENABLE                     0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_19_MIRROR_T                             2:2
#define LWE297_TEX_TEXDESC_19_MIRROR_T_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_19_MIRROR_T_ENABLE                     0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_19_CLAMP_S                              1:1
#define LWE297_TEX_TEXDESC_19_CLAMP_S_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_19_CLAMP_S_CLAMP                       0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_19_CLAMP_T                              0:0
#define LWE297_TEX_TEXDESC_19_CLAMP_T_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_19_CLAMP_T_CLAMP                       0x00000001


// Register LWE297_TEX_TEXDESC_20  
#define LWE297_TEX_TEXDESC_20                               0x734
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_20_WIDTH                        31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_20_HEIGHT                               19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_20_NORMALIZE                            7:7
#define LWE297_TEX_TEXDESC_20_NORMALIZE_DISABLE                   0x00000000
#define LWE297_TEX_TEXDESC_20_NORMALIZE_ENABLE                    0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_20_LOG2_WIDTH                           31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_20_LOG2_HEIGHT                          27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_20_LOD_MIN                              23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_20_LOD_MAX                              15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_20_BASE_LEVEL_ONLY                              7:7
#define LWE297_TEX_TEXDESC_20_BASE_LEVEL_ONLY_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_20_BASE_LEVEL_ONLY_ENABLE                      0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_20_NON_POWER_OF_TWO                             6:6
#define LWE297_TEX_TEXDESC_20_NON_POWER_OF_TWO_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_20_NON_POWER_OF_TWO_ENABLE                     0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_20_ARRAY_MAX                            5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_20_TRILINEAR_OPT                        30:30
#define LWE297_TEX_TEXDESC_20_TRILINEAR_OPT_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_20_TRILINEAR_OPT_ENABLE                        0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_20_LERP_MAG                             29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_20_LERP_MIN                             28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_20_LERP_MIP                             27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_20_LOD_BIAS                             26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_20_MAX_ANISO                            17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_20_SURF_FORMAT                          13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_20_LWBEMAP                              7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_20_LAYOUT                               6:4
#define LWE297_TEX_TEXDESC_20_LAYOUT_LINEAR                       0x00000000
#define LWE297_TEX_TEXDESC_20_LAYOUT_SWIZZLED                     0x00000001
#define LWE297_TEX_TEXDESC_20_LAYOUT_TILED_LINEAR                 0x00000002
#define LWE297_TEX_TEXDESC_20_LAYOUT_TILED_SWIZZLED                       0x00000003
#define LWE297_TEX_TEXDESC_20_LAYOUT_XY_TILED_LINEAR                      0x00000004
#define LWE297_TEX_TEXDESC_20_LAYOUT_XY_TILED_SWIZZLED                    0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_20_MIRROR_S                             3:3
#define LWE297_TEX_TEXDESC_20_MIRROR_S_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_20_MIRROR_S_ENABLE                     0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_20_MIRROR_T                             2:2
#define LWE297_TEX_TEXDESC_20_MIRROR_T_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_20_MIRROR_T_ENABLE                     0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_20_CLAMP_S                              1:1
#define LWE297_TEX_TEXDESC_20_CLAMP_S_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_20_CLAMP_S_CLAMP                       0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_20_CLAMP_T                              0:0
#define LWE297_TEX_TEXDESC_20_CLAMP_T_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_20_CLAMP_T_CLAMP                       0x00000001


// Register LWE297_TEX_TEXDESC_21  
#define LWE297_TEX_TEXDESC_21                               0x735
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_21_WIDTH                        31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_21_HEIGHT                               19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_21_NORMALIZE                            7:7
#define LWE297_TEX_TEXDESC_21_NORMALIZE_DISABLE                   0x00000000
#define LWE297_TEX_TEXDESC_21_NORMALIZE_ENABLE                    0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_21_LOG2_WIDTH                           31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_21_LOG2_HEIGHT                          27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_21_LOD_MIN                              23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_21_LOD_MAX                              15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_21_BASE_LEVEL_ONLY                              7:7
#define LWE297_TEX_TEXDESC_21_BASE_LEVEL_ONLY_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_21_BASE_LEVEL_ONLY_ENABLE                      0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_21_NON_POWER_OF_TWO                             6:6
#define LWE297_TEX_TEXDESC_21_NON_POWER_OF_TWO_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_21_NON_POWER_OF_TWO_ENABLE                     0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_21_ARRAY_MAX                            5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_21_TRILINEAR_OPT                        30:30
#define LWE297_TEX_TEXDESC_21_TRILINEAR_OPT_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_21_TRILINEAR_OPT_ENABLE                        0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_21_LERP_MAG                             29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_21_LERP_MIN                             28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_21_LERP_MIP                             27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_21_LOD_BIAS                             26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_21_MAX_ANISO                            17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_21_SURF_FORMAT                          13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_21_LWBEMAP                              7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_21_LAYOUT                               6:4
#define LWE297_TEX_TEXDESC_21_LAYOUT_LINEAR                       0x00000000
#define LWE297_TEX_TEXDESC_21_LAYOUT_SWIZZLED                     0x00000001
#define LWE297_TEX_TEXDESC_21_LAYOUT_TILED_LINEAR                 0x00000002
#define LWE297_TEX_TEXDESC_21_LAYOUT_TILED_SWIZZLED                       0x00000003
#define LWE297_TEX_TEXDESC_21_LAYOUT_XY_TILED_LINEAR                      0x00000004
#define LWE297_TEX_TEXDESC_21_LAYOUT_XY_TILED_SWIZZLED                    0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_21_MIRROR_S                             3:3
#define LWE297_TEX_TEXDESC_21_MIRROR_S_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_21_MIRROR_S_ENABLE                     0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_21_MIRROR_T                             2:2
#define LWE297_TEX_TEXDESC_21_MIRROR_T_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_21_MIRROR_T_ENABLE                     0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_21_CLAMP_S                              1:1
#define LWE297_TEX_TEXDESC_21_CLAMP_S_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_21_CLAMP_S_CLAMP                       0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_21_CLAMP_T                              0:0
#define LWE297_TEX_TEXDESC_21_CLAMP_T_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_21_CLAMP_T_CLAMP                       0x00000001


// Register LWE297_TEX_TEXDESC_22  
#define LWE297_TEX_TEXDESC_22                               0x736
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_22_WIDTH                        31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_22_HEIGHT                               19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_22_NORMALIZE                            7:7
#define LWE297_TEX_TEXDESC_22_NORMALIZE_DISABLE                   0x00000000
#define LWE297_TEX_TEXDESC_22_NORMALIZE_ENABLE                    0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_22_LOG2_WIDTH                           31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_22_LOG2_HEIGHT                          27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_22_LOD_MIN                              23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_22_LOD_MAX                              15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_22_BASE_LEVEL_ONLY                              7:7
#define LWE297_TEX_TEXDESC_22_BASE_LEVEL_ONLY_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_22_BASE_LEVEL_ONLY_ENABLE                      0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_22_NON_POWER_OF_TWO                             6:6
#define LWE297_TEX_TEXDESC_22_NON_POWER_OF_TWO_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_22_NON_POWER_OF_TWO_ENABLE                     0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_22_ARRAY_MAX                            5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_22_TRILINEAR_OPT                        30:30
#define LWE297_TEX_TEXDESC_22_TRILINEAR_OPT_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_22_TRILINEAR_OPT_ENABLE                        0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_22_LERP_MAG                             29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_22_LERP_MIN                             28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_22_LERP_MIP                             27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_22_LOD_BIAS                             26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_22_MAX_ANISO                            17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_22_SURF_FORMAT                          13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_22_LWBEMAP                              7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_22_LAYOUT                               6:4
#define LWE297_TEX_TEXDESC_22_LAYOUT_LINEAR                       0x00000000
#define LWE297_TEX_TEXDESC_22_LAYOUT_SWIZZLED                     0x00000001
#define LWE297_TEX_TEXDESC_22_LAYOUT_TILED_LINEAR                 0x00000002
#define LWE297_TEX_TEXDESC_22_LAYOUT_TILED_SWIZZLED                       0x00000003
#define LWE297_TEX_TEXDESC_22_LAYOUT_XY_TILED_LINEAR                      0x00000004
#define LWE297_TEX_TEXDESC_22_LAYOUT_XY_TILED_SWIZZLED                    0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_22_MIRROR_S                             3:3
#define LWE297_TEX_TEXDESC_22_MIRROR_S_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_22_MIRROR_S_ENABLE                     0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_22_MIRROR_T                             2:2
#define LWE297_TEX_TEXDESC_22_MIRROR_T_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_22_MIRROR_T_ENABLE                     0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_22_CLAMP_S                              1:1
#define LWE297_TEX_TEXDESC_22_CLAMP_S_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_22_CLAMP_S_CLAMP                       0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_22_CLAMP_T                              0:0
#define LWE297_TEX_TEXDESC_22_CLAMP_T_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_22_CLAMP_T_CLAMP                       0x00000001


// Register LWE297_TEX_TEXDESC_23  
#define LWE297_TEX_TEXDESC_23                               0x737
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_23_WIDTH                        31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_23_HEIGHT                               19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_23_NORMALIZE                            7:7
#define LWE297_TEX_TEXDESC_23_NORMALIZE_DISABLE                   0x00000000
#define LWE297_TEX_TEXDESC_23_NORMALIZE_ENABLE                    0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_23_LOG2_WIDTH                           31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_23_LOG2_HEIGHT                          27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_23_LOD_MIN                              23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_23_LOD_MAX                              15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_23_BASE_LEVEL_ONLY                              7:7
#define LWE297_TEX_TEXDESC_23_BASE_LEVEL_ONLY_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_23_BASE_LEVEL_ONLY_ENABLE                      0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_23_NON_POWER_OF_TWO                             6:6
#define LWE297_TEX_TEXDESC_23_NON_POWER_OF_TWO_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_23_NON_POWER_OF_TWO_ENABLE                     0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_23_ARRAY_MAX                            5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_23_TRILINEAR_OPT                        30:30
#define LWE297_TEX_TEXDESC_23_TRILINEAR_OPT_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_23_TRILINEAR_OPT_ENABLE                        0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_23_LERP_MAG                             29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_23_LERP_MIN                             28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_23_LERP_MIP                             27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_23_LOD_BIAS                             26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_23_MAX_ANISO                            17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_23_SURF_FORMAT                          13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_23_LWBEMAP                              7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_23_LAYOUT                               6:4
#define LWE297_TEX_TEXDESC_23_LAYOUT_LINEAR                       0x00000000
#define LWE297_TEX_TEXDESC_23_LAYOUT_SWIZZLED                     0x00000001
#define LWE297_TEX_TEXDESC_23_LAYOUT_TILED_LINEAR                 0x00000002
#define LWE297_TEX_TEXDESC_23_LAYOUT_TILED_SWIZZLED                       0x00000003
#define LWE297_TEX_TEXDESC_23_LAYOUT_XY_TILED_LINEAR                      0x00000004
#define LWE297_TEX_TEXDESC_23_LAYOUT_XY_TILED_SWIZZLED                    0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_23_MIRROR_S                             3:3
#define LWE297_TEX_TEXDESC_23_MIRROR_S_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_23_MIRROR_S_ENABLE                     0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_23_MIRROR_T                             2:2
#define LWE297_TEX_TEXDESC_23_MIRROR_T_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_23_MIRROR_T_ENABLE                     0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_23_CLAMP_S                              1:1
#define LWE297_TEX_TEXDESC_23_CLAMP_S_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_23_CLAMP_S_CLAMP                       0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_23_CLAMP_T                              0:0
#define LWE297_TEX_TEXDESC_23_CLAMP_T_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_23_CLAMP_T_CLAMP                       0x00000001


// Register LWE297_TEX_TEXDESC_24  
#define LWE297_TEX_TEXDESC_24                               0x738
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_24_WIDTH                        31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_24_HEIGHT                               19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_24_NORMALIZE                            7:7
#define LWE297_TEX_TEXDESC_24_NORMALIZE_DISABLE                   0x00000000
#define LWE297_TEX_TEXDESC_24_NORMALIZE_ENABLE                    0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_24_LOG2_WIDTH                           31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_24_LOG2_HEIGHT                          27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_24_LOD_MIN                              23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_24_LOD_MAX                              15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_24_BASE_LEVEL_ONLY                              7:7
#define LWE297_TEX_TEXDESC_24_BASE_LEVEL_ONLY_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_24_BASE_LEVEL_ONLY_ENABLE                      0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_24_NON_POWER_OF_TWO                             6:6
#define LWE297_TEX_TEXDESC_24_NON_POWER_OF_TWO_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_24_NON_POWER_OF_TWO_ENABLE                     0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_24_ARRAY_MAX                            5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_24_TRILINEAR_OPT                        30:30
#define LWE297_TEX_TEXDESC_24_TRILINEAR_OPT_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_24_TRILINEAR_OPT_ENABLE                        0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_24_LERP_MAG                             29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_24_LERP_MIN                             28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_24_LERP_MIP                             27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_24_LOD_BIAS                             26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_24_MAX_ANISO                            17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_24_SURF_FORMAT                          13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_24_LWBEMAP                              7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_24_LAYOUT                               6:4
#define LWE297_TEX_TEXDESC_24_LAYOUT_LINEAR                       0x00000000
#define LWE297_TEX_TEXDESC_24_LAYOUT_SWIZZLED                     0x00000001
#define LWE297_TEX_TEXDESC_24_LAYOUT_TILED_LINEAR                 0x00000002
#define LWE297_TEX_TEXDESC_24_LAYOUT_TILED_SWIZZLED                       0x00000003
#define LWE297_TEX_TEXDESC_24_LAYOUT_XY_TILED_LINEAR                      0x00000004
#define LWE297_TEX_TEXDESC_24_LAYOUT_XY_TILED_SWIZZLED                    0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_24_MIRROR_S                             3:3
#define LWE297_TEX_TEXDESC_24_MIRROR_S_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_24_MIRROR_S_ENABLE                     0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_24_MIRROR_T                             2:2
#define LWE297_TEX_TEXDESC_24_MIRROR_T_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_24_MIRROR_T_ENABLE                     0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_24_CLAMP_S                              1:1
#define LWE297_TEX_TEXDESC_24_CLAMP_S_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_24_CLAMP_S_CLAMP                       0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_24_CLAMP_T                              0:0
#define LWE297_TEX_TEXDESC_24_CLAMP_T_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_24_CLAMP_T_CLAMP                       0x00000001


// Register LWE297_TEX_TEXDESC_25  
#define LWE297_TEX_TEXDESC_25                               0x739
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_25_WIDTH                        31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_25_HEIGHT                               19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_25_NORMALIZE                            7:7
#define LWE297_TEX_TEXDESC_25_NORMALIZE_DISABLE                   0x00000000
#define LWE297_TEX_TEXDESC_25_NORMALIZE_ENABLE                    0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_25_LOG2_WIDTH                           31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_25_LOG2_HEIGHT                          27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_25_LOD_MIN                              23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_25_LOD_MAX                              15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_25_BASE_LEVEL_ONLY                              7:7
#define LWE297_TEX_TEXDESC_25_BASE_LEVEL_ONLY_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_25_BASE_LEVEL_ONLY_ENABLE                      0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_25_NON_POWER_OF_TWO                             6:6
#define LWE297_TEX_TEXDESC_25_NON_POWER_OF_TWO_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_25_NON_POWER_OF_TWO_ENABLE                     0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_25_ARRAY_MAX                            5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_25_TRILINEAR_OPT                        30:30
#define LWE297_TEX_TEXDESC_25_TRILINEAR_OPT_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_25_TRILINEAR_OPT_ENABLE                        0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_25_LERP_MAG                             29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_25_LERP_MIN                             28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_25_LERP_MIP                             27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_25_LOD_BIAS                             26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_25_MAX_ANISO                            17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_25_SURF_FORMAT                          13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_25_LWBEMAP                              7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_25_LAYOUT                               6:4
#define LWE297_TEX_TEXDESC_25_LAYOUT_LINEAR                       0x00000000
#define LWE297_TEX_TEXDESC_25_LAYOUT_SWIZZLED                     0x00000001
#define LWE297_TEX_TEXDESC_25_LAYOUT_TILED_LINEAR                 0x00000002
#define LWE297_TEX_TEXDESC_25_LAYOUT_TILED_SWIZZLED                       0x00000003
#define LWE297_TEX_TEXDESC_25_LAYOUT_XY_TILED_LINEAR                      0x00000004
#define LWE297_TEX_TEXDESC_25_LAYOUT_XY_TILED_SWIZZLED                    0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_25_MIRROR_S                             3:3
#define LWE297_TEX_TEXDESC_25_MIRROR_S_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_25_MIRROR_S_ENABLE                     0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_25_MIRROR_T                             2:2
#define LWE297_TEX_TEXDESC_25_MIRROR_T_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_25_MIRROR_T_ENABLE                     0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_25_CLAMP_S                              1:1
#define LWE297_TEX_TEXDESC_25_CLAMP_S_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_25_CLAMP_S_CLAMP                       0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_25_CLAMP_T                              0:0
#define LWE297_TEX_TEXDESC_25_CLAMP_T_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_25_CLAMP_T_CLAMP                       0x00000001


// Register LWE297_TEX_TEXDESC_26  
#define LWE297_TEX_TEXDESC_26                               0x73a
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_26_WIDTH                        31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_26_HEIGHT                               19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_26_NORMALIZE                            7:7
#define LWE297_TEX_TEXDESC_26_NORMALIZE_DISABLE                   0x00000000
#define LWE297_TEX_TEXDESC_26_NORMALIZE_ENABLE                    0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_26_LOG2_WIDTH                           31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_26_LOG2_HEIGHT                          27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_26_LOD_MIN                              23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_26_LOD_MAX                              15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_26_BASE_LEVEL_ONLY                              7:7
#define LWE297_TEX_TEXDESC_26_BASE_LEVEL_ONLY_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_26_BASE_LEVEL_ONLY_ENABLE                      0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_26_NON_POWER_OF_TWO                             6:6
#define LWE297_TEX_TEXDESC_26_NON_POWER_OF_TWO_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_26_NON_POWER_OF_TWO_ENABLE                     0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_26_ARRAY_MAX                            5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_26_TRILINEAR_OPT                        30:30
#define LWE297_TEX_TEXDESC_26_TRILINEAR_OPT_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_26_TRILINEAR_OPT_ENABLE                        0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_26_LERP_MAG                             29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_26_LERP_MIN                             28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_26_LERP_MIP                             27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_26_LOD_BIAS                             26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_26_MAX_ANISO                            17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_26_SURF_FORMAT                          13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_26_LWBEMAP                              7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_26_LAYOUT                               6:4
#define LWE297_TEX_TEXDESC_26_LAYOUT_LINEAR                       0x00000000
#define LWE297_TEX_TEXDESC_26_LAYOUT_SWIZZLED                     0x00000001
#define LWE297_TEX_TEXDESC_26_LAYOUT_TILED_LINEAR                 0x00000002
#define LWE297_TEX_TEXDESC_26_LAYOUT_TILED_SWIZZLED                       0x00000003
#define LWE297_TEX_TEXDESC_26_LAYOUT_XY_TILED_LINEAR                      0x00000004
#define LWE297_TEX_TEXDESC_26_LAYOUT_XY_TILED_SWIZZLED                    0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_26_MIRROR_S                             3:3
#define LWE297_TEX_TEXDESC_26_MIRROR_S_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_26_MIRROR_S_ENABLE                     0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_26_MIRROR_T                             2:2
#define LWE297_TEX_TEXDESC_26_MIRROR_T_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_26_MIRROR_T_ENABLE                     0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_26_CLAMP_S                              1:1
#define LWE297_TEX_TEXDESC_26_CLAMP_S_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_26_CLAMP_S_CLAMP                       0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_26_CLAMP_T                              0:0
#define LWE297_TEX_TEXDESC_26_CLAMP_T_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_26_CLAMP_T_CLAMP                       0x00000001


// Register LWE297_TEX_TEXDESC_27  
#define LWE297_TEX_TEXDESC_27                               0x73b
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_27_WIDTH                        31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_27_HEIGHT                               19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_27_NORMALIZE                            7:7
#define LWE297_TEX_TEXDESC_27_NORMALIZE_DISABLE                   0x00000000
#define LWE297_TEX_TEXDESC_27_NORMALIZE_ENABLE                    0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_27_LOG2_WIDTH                           31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_27_LOG2_HEIGHT                          27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_27_LOD_MIN                              23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_27_LOD_MAX                              15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_27_BASE_LEVEL_ONLY                              7:7
#define LWE297_TEX_TEXDESC_27_BASE_LEVEL_ONLY_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_27_BASE_LEVEL_ONLY_ENABLE                      0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_27_NON_POWER_OF_TWO                             6:6
#define LWE297_TEX_TEXDESC_27_NON_POWER_OF_TWO_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_27_NON_POWER_OF_TWO_ENABLE                     0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_27_ARRAY_MAX                            5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_27_TRILINEAR_OPT                        30:30
#define LWE297_TEX_TEXDESC_27_TRILINEAR_OPT_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_27_TRILINEAR_OPT_ENABLE                        0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_27_LERP_MAG                             29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_27_LERP_MIN                             28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_27_LERP_MIP                             27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_27_LOD_BIAS                             26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_27_MAX_ANISO                            17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_27_SURF_FORMAT                          13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_27_LWBEMAP                              7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_27_LAYOUT                               6:4
#define LWE297_TEX_TEXDESC_27_LAYOUT_LINEAR                       0x00000000
#define LWE297_TEX_TEXDESC_27_LAYOUT_SWIZZLED                     0x00000001
#define LWE297_TEX_TEXDESC_27_LAYOUT_TILED_LINEAR                 0x00000002
#define LWE297_TEX_TEXDESC_27_LAYOUT_TILED_SWIZZLED                       0x00000003
#define LWE297_TEX_TEXDESC_27_LAYOUT_XY_TILED_LINEAR                      0x00000004
#define LWE297_TEX_TEXDESC_27_LAYOUT_XY_TILED_SWIZZLED                    0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_27_MIRROR_S                             3:3
#define LWE297_TEX_TEXDESC_27_MIRROR_S_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_27_MIRROR_S_ENABLE                     0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_27_MIRROR_T                             2:2
#define LWE297_TEX_TEXDESC_27_MIRROR_T_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_27_MIRROR_T_ENABLE                     0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_27_CLAMP_S                              1:1
#define LWE297_TEX_TEXDESC_27_CLAMP_S_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_27_CLAMP_S_CLAMP                       0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_27_CLAMP_T                              0:0
#define LWE297_TEX_TEXDESC_27_CLAMP_T_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_27_CLAMP_T_CLAMP                       0x00000001


// Register LWE297_TEX_TEXDESC_28  
#define LWE297_TEX_TEXDESC_28                               0x73c
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_28_WIDTH                        31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_28_HEIGHT                               19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_28_NORMALIZE                            7:7
#define LWE297_TEX_TEXDESC_28_NORMALIZE_DISABLE                   0x00000000
#define LWE297_TEX_TEXDESC_28_NORMALIZE_ENABLE                    0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_28_LOG2_WIDTH                           31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_28_LOG2_HEIGHT                          27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_28_LOD_MIN                              23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_28_LOD_MAX                              15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_28_BASE_LEVEL_ONLY                              7:7
#define LWE297_TEX_TEXDESC_28_BASE_LEVEL_ONLY_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_28_BASE_LEVEL_ONLY_ENABLE                      0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_28_NON_POWER_OF_TWO                             6:6
#define LWE297_TEX_TEXDESC_28_NON_POWER_OF_TWO_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_28_NON_POWER_OF_TWO_ENABLE                     0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_28_ARRAY_MAX                            5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_28_TRILINEAR_OPT                        30:30
#define LWE297_TEX_TEXDESC_28_TRILINEAR_OPT_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_28_TRILINEAR_OPT_ENABLE                        0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_28_LERP_MAG                             29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_28_LERP_MIN                             28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_28_LERP_MIP                             27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_28_LOD_BIAS                             26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_28_MAX_ANISO                            17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_28_SURF_FORMAT                          13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_28_LWBEMAP                              7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_28_LAYOUT                               6:4
#define LWE297_TEX_TEXDESC_28_LAYOUT_LINEAR                       0x00000000
#define LWE297_TEX_TEXDESC_28_LAYOUT_SWIZZLED                     0x00000001
#define LWE297_TEX_TEXDESC_28_LAYOUT_TILED_LINEAR                 0x00000002
#define LWE297_TEX_TEXDESC_28_LAYOUT_TILED_SWIZZLED                       0x00000003
#define LWE297_TEX_TEXDESC_28_LAYOUT_XY_TILED_LINEAR                      0x00000004
#define LWE297_TEX_TEXDESC_28_LAYOUT_XY_TILED_SWIZZLED                    0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_28_MIRROR_S                             3:3
#define LWE297_TEX_TEXDESC_28_MIRROR_S_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_28_MIRROR_S_ENABLE                     0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_28_MIRROR_T                             2:2
#define LWE297_TEX_TEXDESC_28_MIRROR_T_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_28_MIRROR_T_ENABLE                     0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_28_CLAMP_S                              1:1
#define LWE297_TEX_TEXDESC_28_CLAMP_S_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_28_CLAMP_S_CLAMP                       0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_28_CLAMP_T                              0:0
#define LWE297_TEX_TEXDESC_28_CLAMP_T_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_28_CLAMP_T_CLAMP                       0x00000001


// Register LWE297_TEX_TEXDESC_29  
#define LWE297_TEX_TEXDESC_29                               0x73d
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_29_WIDTH                        31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_29_HEIGHT                               19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_29_NORMALIZE                            7:7
#define LWE297_TEX_TEXDESC_29_NORMALIZE_DISABLE                   0x00000000
#define LWE297_TEX_TEXDESC_29_NORMALIZE_ENABLE                    0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_29_LOG2_WIDTH                           31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_29_LOG2_HEIGHT                          27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_29_LOD_MIN                              23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_29_LOD_MAX                              15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_29_BASE_LEVEL_ONLY                              7:7
#define LWE297_TEX_TEXDESC_29_BASE_LEVEL_ONLY_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_29_BASE_LEVEL_ONLY_ENABLE                      0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_29_NON_POWER_OF_TWO                             6:6
#define LWE297_TEX_TEXDESC_29_NON_POWER_OF_TWO_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_29_NON_POWER_OF_TWO_ENABLE                     0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_29_ARRAY_MAX                            5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_29_TRILINEAR_OPT                        30:30
#define LWE297_TEX_TEXDESC_29_TRILINEAR_OPT_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_29_TRILINEAR_OPT_ENABLE                        0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_29_LERP_MAG                             29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_29_LERP_MIN                             28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_29_LERP_MIP                             27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_29_LOD_BIAS                             26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_29_MAX_ANISO                            17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_29_SURF_FORMAT                          13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_29_LWBEMAP                              7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_29_LAYOUT                               6:4
#define LWE297_TEX_TEXDESC_29_LAYOUT_LINEAR                       0x00000000
#define LWE297_TEX_TEXDESC_29_LAYOUT_SWIZZLED                     0x00000001
#define LWE297_TEX_TEXDESC_29_LAYOUT_TILED_LINEAR                 0x00000002
#define LWE297_TEX_TEXDESC_29_LAYOUT_TILED_SWIZZLED                       0x00000003
#define LWE297_TEX_TEXDESC_29_LAYOUT_XY_TILED_LINEAR                      0x00000004
#define LWE297_TEX_TEXDESC_29_LAYOUT_XY_TILED_SWIZZLED                    0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_29_MIRROR_S                             3:3
#define LWE297_TEX_TEXDESC_29_MIRROR_S_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_29_MIRROR_S_ENABLE                     0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_29_MIRROR_T                             2:2
#define LWE297_TEX_TEXDESC_29_MIRROR_T_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_29_MIRROR_T_ENABLE                     0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_29_CLAMP_S                              1:1
#define LWE297_TEX_TEXDESC_29_CLAMP_S_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_29_CLAMP_S_CLAMP                       0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_29_CLAMP_T                              0:0
#define LWE297_TEX_TEXDESC_29_CLAMP_T_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_29_CLAMP_T_CLAMP                       0x00000001


// Register LWE297_TEX_TEXDESC_30  
#define LWE297_TEX_TEXDESC_30                               0x73e
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_30_WIDTH                        31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_30_HEIGHT                               19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_30_NORMALIZE                            7:7
#define LWE297_TEX_TEXDESC_30_NORMALIZE_DISABLE                   0x00000000
#define LWE297_TEX_TEXDESC_30_NORMALIZE_ENABLE                    0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_30_LOG2_WIDTH                           31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_30_LOG2_HEIGHT                          27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_30_LOD_MIN                              23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_30_LOD_MAX                              15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_30_BASE_LEVEL_ONLY                              7:7
#define LWE297_TEX_TEXDESC_30_BASE_LEVEL_ONLY_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_30_BASE_LEVEL_ONLY_ENABLE                      0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_30_NON_POWER_OF_TWO                             6:6
#define LWE297_TEX_TEXDESC_30_NON_POWER_OF_TWO_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_30_NON_POWER_OF_TWO_ENABLE                     0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_30_ARRAY_MAX                            5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_30_TRILINEAR_OPT                        30:30
#define LWE297_TEX_TEXDESC_30_TRILINEAR_OPT_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_30_TRILINEAR_OPT_ENABLE                        0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_30_LERP_MAG                             29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_30_LERP_MIN                             28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_30_LERP_MIP                             27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_30_LOD_BIAS                             26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_30_MAX_ANISO                            17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_30_SURF_FORMAT                          13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_30_LWBEMAP                              7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_30_LAYOUT                               6:4
#define LWE297_TEX_TEXDESC_30_LAYOUT_LINEAR                       0x00000000
#define LWE297_TEX_TEXDESC_30_LAYOUT_SWIZZLED                     0x00000001
#define LWE297_TEX_TEXDESC_30_LAYOUT_TILED_LINEAR                 0x00000002
#define LWE297_TEX_TEXDESC_30_LAYOUT_TILED_SWIZZLED                       0x00000003
#define LWE297_TEX_TEXDESC_30_LAYOUT_XY_TILED_LINEAR                      0x00000004
#define LWE297_TEX_TEXDESC_30_LAYOUT_XY_TILED_SWIZZLED                    0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_30_MIRROR_S                             3:3
#define LWE297_TEX_TEXDESC_30_MIRROR_S_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_30_MIRROR_S_ENABLE                     0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_30_MIRROR_T                             2:2
#define LWE297_TEX_TEXDESC_30_MIRROR_T_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_30_MIRROR_T_ENABLE                     0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_30_CLAMP_S                              1:1
#define LWE297_TEX_TEXDESC_30_CLAMP_S_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_30_CLAMP_S_CLAMP                       0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_30_CLAMP_T                              0:0
#define LWE297_TEX_TEXDESC_30_CLAMP_T_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_30_CLAMP_T_CLAMP                       0x00000001


// Register LWE297_TEX_TEXDESC_31  
#define LWE297_TEX_TEXDESC_31                               0x73f
// Width of surface. used by npot textures
#define LWE297_TEX_TEXDESC_31_WIDTH                        31:20

// Height of surface. used by npot textures
#define LWE297_TEX_TEXDESC_31_HEIGHT                               19:8

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define LWE297_TEX_TEXDESC_31_NORMALIZE                            7:7
#define LWE297_TEX_TEXDESC_31_NORMALIZE_DISABLE                   0x00000000
#define LWE297_TEX_TEXDESC_31_NORMALIZE_ENABLE                    0x00000001

// Log2 (width of surface) Union
#define LWE297_TEX_TEXDESC_31_LOG2_WIDTH                           31:28

// Log2 (height of surface) Union
#define LWE297_TEX_TEXDESC_31_LOG2_HEIGHT                          27:24

// finest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_31_LOD_MIN                              23:16

// coarsest LOD to sample from .LW_GR3D_LOD_BIAS_FRAC_BITS format
#define LWE297_TEX_TEXDESC_31_LOD_MAX                              15:8

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define LWE297_TEX_TEXDESC_31_BASE_LEVEL_ONLY                              7:7
#define LWE297_TEX_TEXDESC_31_BASE_LEVEL_ONLY_DISABLE                     0x00000000
#define LWE297_TEX_TEXDESC_31_BASE_LEVEL_ONLY_ENABLE                      0x00000001

// Texture dimensions are not power-of-two
#define LWE297_TEX_TEXDESC_31_NON_POWER_OF_TWO                             6:6
#define LWE297_TEX_TEXDESC_31_NON_POWER_OF_TWO_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_31_NON_POWER_OF_TWO_ENABLE                     0x00000001

// Array has slices 0..ARRAY_MAX
#define LWE297_TEX_TEXDESC_31_ARRAY_MAX                            5:0

// Enable trilinear optimization
#define LWE297_TEX_TEXDESC_31_TRILINEAR_OPT                        30:30
#define LWE297_TEX_TEXDESC_31_TRILINEAR_OPT_DISABLE                       0x00000000
#define LWE297_TEX_TEXDESC_31_TRILINEAR_OPT_ENABLE                        0x00000001

// bilerp fine level
#define LWE297_TEX_TEXDESC_31_LERP_MAG                             29:29

// bilerp coarse level
#define LWE297_TEX_TEXDESC_31_LERP_MIN                             28:28

// lerp between levels
#define LWE297_TEX_TEXDESC_31_LERP_MIP                             27:27

// lod bias, signed with .LW_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define LWE297_TEX_TEXDESC_31_LOD_BIAS                             26:18

// maximum aniso ratio minus one
#define LWE297_TEX_TEXDESC_31_MAX_ANISO                            17:14

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define LWE297_TEX_TEXDESC_31_SURF_FORMAT                          13:8

// suface is a lwbemap (array max should be 5)
#define LWE297_TEX_TEXDESC_31_LWBEMAP                              7:7

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define LWE297_TEX_TEXDESC_31_LAYOUT                               6:4
#define LWE297_TEX_TEXDESC_31_LAYOUT_LINEAR                       0x00000000
#define LWE297_TEX_TEXDESC_31_LAYOUT_SWIZZLED                     0x00000001
#define LWE297_TEX_TEXDESC_31_LAYOUT_TILED_LINEAR                 0x00000002
#define LWE297_TEX_TEXDESC_31_LAYOUT_TILED_SWIZZLED                       0x00000003
#define LWE297_TEX_TEXDESC_31_LAYOUT_XY_TILED_LINEAR                      0x00000004
#define LWE297_TEX_TEXDESC_31_LAYOUT_XY_TILED_SWIZZLED                    0x00000005

// mirror the s coordinate
#define LWE297_TEX_TEXDESC_31_MIRROR_S                             3:3
#define LWE297_TEX_TEXDESC_31_MIRROR_S_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_31_MIRROR_S_ENABLE                     0x00000001

// mirror the t coordiante
#define LWE297_TEX_TEXDESC_31_MIRROR_T                             2:2
#define LWE297_TEX_TEXDESC_31_MIRROR_T_DISABLE                    0x00000000
#define LWE297_TEX_TEXDESC_31_MIRROR_T_ENABLE                     0x00000001

// type of clamp for s coordinate
#define LWE297_TEX_TEXDESC_31_CLAMP_S                              1:1
#define LWE297_TEX_TEXDESC_31_CLAMP_S_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_31_CLAMP_S_CLAMP                       0x00000001

// type of clamp for t coordinate
#define LWE297_TEX_TEXDESC_31_CLAMP_T                              0:0
#define LWE297_TEX_TEXDESC_31_CLAMP_T_WRAP                        0x00000000
#define LWE297_TEX_TEXDESC_31_CLAMP_T_CLAMP                       0x00000001

// Texture control register containing miscellaneous enable and control bits.
// ANISO_BIAS scales the number of aniso bilerps down
// It should normally be non-zero, since zero means that even the slightest
// anisotropy will cause at least 2 aniso bilerps
// ANISO_OPT makes the aniso ratio "stick around" at integer values
// SLOPE_2 means a computed value of e.g. 1.0..1.5 will be mapped to 1.0, and
// a value of 1.5..2.0 will be mapped to 1.0..2.0 (i.e. a slope of 2)
// FLOOR makes the aniso ratio stick to the closest lower integer
// FLOOR_EVEN makes the aniso ratio stick to the closest lower even number
// Field TEXTURE_CACHE_EN enables/disables the texture cache for debug.
// It should normally be programmed to ENABLE and left alone.

// Register LWE297_TEX_TEXCTL_0  
#define LWE297_TEX_TEXCTL_0                                 0x740
// Aniso bias decreases lg2(ratio) by 0..7/8
#define LWE297_TEX_TEXCTL_0_ANISO_BIAS                             6:4

// Enable aniso optimization
#define LWE297_TEX_TEXCTL_0_ANISO_OPT                              3:2
#define LWE297_TEX_TEXCTL_0_ANISO_OPT_DISABLE                     0x00000000
#define LWE297_TEX_TEXCTL_0_ANISO_OPT_SLOPE_2                     0x00000001
#define LWE297_TEX_TEXCTL_0_ANISO_OPT_FLOOR                       0x00000002
#define LWE297_TEX_TEXCTL_0_ANISO_OPT_FLOOR_EVEN                  0x00000003

// Enable texture cache
#define LWE297_TEX_TEXCTL_0_TEXTURE_CACHE_EN                               0:0
#define LWE297_TEX_TEXCTL_0_TEXTURE_CACHE_EN_DISABLE                      0x00000000
#define LWE297_TEX_TEXCTL_0_TEXTURE_CACHE_EN_ENABLE                       0x00000001


// Register LWE297_TEX_CLKEN_OVERRIDE_0  
#define LWE297_TEX_CLKEN_OVERRIDE_0                                 0x741
// Fine Grain override for the gr3dclipcgclk
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXPBCLK_CLKEN_OVR                             0:0
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXPBCLK_CLKEN_OVR_INIT_ENUM                  CLK_GATED
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXPBCLK_CLKEN_OVR_CLK_GATED                  0x00000000
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXPBCLK_CLKEN_OVR_CLK_ALWAYS_ON                      0x00000001

// Fine Grain override for the gr3dclipccclk
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXPPBCLK_CLKEN_OVR                            1:1
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXPPBCLK_CLKEN_OVR_INIT_ENUM                 CLK_GATED
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXPPBCLK_CLKEN_OVR_CLK_GATED                 0x00000000
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXPPBCLK_CLKEN_OVR_CLK_ALWAYS_ON                     0x00000001

// Fine Grain override for the gr3dclipcpclk
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXLODCLK_CLKEN_OVR                            2:2
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXLODCLK_CLKEN_OVR_INIT_ENUM                 CLK_GATED
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXLODCLK_CLKEN_OVR_CLK_GATED                 0x00000000
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXLODCLK_CLKEN_OVR_CLK_ALWAYS_ON                     0x00000001

// Fine Grain override for the gr3dclipvpclk
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXFORMATCLK_CLKEN_OVR                         3:3
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXFORMATCLK_CLKEN_OVR_INIT_ENUM                      CLK_GATED
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXFORMATCLK_CLKEN_OVR_CLK_GATED                      0x00000000
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXFORMATCLK_CLKEN_OVR_CLK_ALWAYS_ON                  0x00000001

// Fine Grain override for the gr3dcliparclk
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXLODLOWERDPCLK_CLKEN_OVR                             4:4
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXLODLOWERDPCLK_CLKEN_OVR_INIT_ENUM                  CLK_GATED
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXLODLOWERDPCLK_CLKEN_OVR_CLK_GATED                  0x00000000
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXLODLOWERDPCLK_CLKEN_OVR_CLK_ALWAYS_ON                      0x00000001

// Fine Grain override for the gr3dclippaclk
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXNONBYPCLK_CLKEN_OVR                         5:5
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXNONBYPCLK_CLKEN_OVR_INIT_ENUM                      CLK_GATED
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXNONBYPCLK_CLKEN_OVR_CLK_GATED                      0x00000000
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXNONBYPCLK_CLKEN_OVR_CLK_ALWAYS_ON                  0x00000001

// Fine Grain override for the gr3dclipdzclk
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXCACHECLK_CLKEN_OVR                          6:6
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXCACHECLK_CLKEN_OVR_INIT_ENUM                       CLK_GATED
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXCACHECLK_CLKEN_OVR_CLK_GATED                       0x00000000
#define LWE297_TEX_CLKEN_OVERRIDE_0_TEXCACHECLK_CLKEN_OVR_CLK_ALWAYS_ON                   0x00000001

//tex has aniso or not in project spec file now
//define TEX_ANISO_PRESENT 1;
//
// Memory Client Interface Async Fifo Optimization Register
// This can only be changed while the pipeline is completely idle.
// Read-Only Instance
// Memory Client Interface Fifo Control Register.
// The registers below allow to optimize the synchronization timing in
// the memory client asynchronous fifos. When they can be used depend on
// the client and memory controller clock ratio.
// Additionally, the RDMC_RDFAST/RDCL_RDFAST fields can increase power
// consumption if the asynchronous fifo is implemented as a real ram.
// There is no power impact on latch-based fifos. Flipflop-based fifos
// do not use these fields.
// See recommended settings below.
//
// !! IMPORTANT !!
// The register fields can only be changed when the memory client async
// fifos are empty.
//
// The register field ending with WRCL_MCLE2X (if any) can be set to improve
// async fifo synchronization on the write side by one client clock cycle if
// the memory controller clock frequency is less or equal to twice the client
// clock frequency:
//
//      mcclk_freq <= 2 * clientclk_freq
//
// The register field ending with WRMC_CLLE2X (if any) can be set to improve
// async fifo synchronization on the write side by one memory controller clock
// cycle if the client clock frequency is less or equal to twice the memory
// controller clock frequency:
//
//      clientclk_freq <= 2 * mcclk_freq
//
// The register field ending with RDMC_RDFAST (if any) can be set to improve async
// fifo synchronization on the read side by one memory controller clock cycle.
//
// !! WARNING !!
// RDMC_RDFAST can be used along with WRCL_MCLE2X only when:
//
//       mcclk_freq <= clientclk_freq
//
// The register field ending with RDCL_RDFAST (if any) can be set to improve async
// fifo synchronization on the read side by one client clock cycle.
//
// !! WARNING !!
// RDCL_RDFAST can be used along with WRMC_CLLE2X only when:
//
//       clientclk_freq <= mcclk_freq
//
// RECOMMENDED SETTINGS
// # Client writing to fifo, memory controller reading from fifo
// - mcclk_freq <= clientclk_freq
//     You can enable both RDMC_RDFAST and WRCL_CLLE2X. If one of the fifos is
//     a real ram and power is a concern, you should avoid enabling RDMC_RDFAST.
// - clientclk_freq < mcclk_freq <= 2 * clientclk_freq
//     You can enable RDMC_RDFAST or WRCL_MCLE2X, but because the client clock
//     is slower, you should enable only WRCL_MCLE2X.
// - 2 * clientclk_freq < mcclk_freq
//     You can only enable RDMC_RDFAST. If one of the fifos is a real ram and
//     power is a concern, you should avoid enabling RDMC_RDFAST.
//
// # Memory controller writing to fifo, client reading from fifo
// - clientclk_freq <= mcclk_freq
//     You can enable both RDCL_RDFAST and WRMC_CLLE2X. If one of the fifos is
//     a real ram and power is a concern, you should avoid enabling RDCL_RDFAST.
// - mcclk_freq < clientclk_freq <= 2 * mcclk_freq
//     You can enable RDCL_RDFAST or WRMC_CLLE2X, but because the memory controller
//     clock is slower, you should enable only WRMC_CLLE2X.
// - 2 * mcclk_freq < clientclk_freq
//     You can only enable RDCL_RDFAST. If one of the fifos is a real ram and
//     power is a concern, you should avoid enabling RDCL_RDFAST.
//

// Register LWE297_TEX_LW_MCCIF_FIFOCTRL_RO_0  
#define LWE297_TEX_LW_MCCIF_FIFOCTRL_RO_0                           0x742
#define LWE297_TEX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRCL_MCLE2X                             0:0
#define LWE297_TEX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRCL_MCLE2X_INIT_ENUM                  DISABLE
#define LWE297_TEX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRCL_MCLE2X_DISABLE                    0x00000000
#define LWE297_TEX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRCL_MCLE2X_ENABLE                     0x00000001

#define LWE297_TEX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDMC_RDFAST                             1:1
#define LWE297_TEX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDMC_RDFAST_INIT_ENUM                  DISABLE
#define LWE297_TEX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDMC_RDFAST_DISABLE                    0x00000000
#define LWE297_TEX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDMC_RDFAST_ENABLE                     0x00000001

#define LWE297_TEX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRMC_CLLE2X                             2:2
#define LWE297_TEX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRMC_CLLE2X_INIT_ENUM                  DISABLE
#define LWE297_TEX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRMC_CLLE2X_DISABLE                    0x00000000
#define LWE297_TEX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRMC_CLLE2X_ENABLE                     0x00000001

#define LWE297_TEX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDCL_RDFAST                             3:3
#define LWE297_TEX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDCL_RDFAST_INIT_ENUM                  DISABLE
#define LWE297_TEX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDCL_RDFAST_DISABLE                    0x00000000
#define LWE297_TEX_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDCL_RDFAST_ENABLE                     0x00000001

// --------------------------------------------------------------------------
// 
// Copyright (c) 2004, LWPU Corp.
// All Rights Reserved.
// 
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of LWPU Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of LWPU Corp.
// 
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
// 
// --------------------------------------------------------------------------
// 
//
//
// --------------------------------------------------------------------------
// ALU Instruction Registers
// --------------------------------------------------------------------------
//
// Overview:
// The ALU is the heart of the pixel shader hardware. It consists of 4 parallel units each
// of which computes a floating-point MAD DEST = (A*B+C). An optional second 
// multiplier can be turned on to compute a DP2 instead (A*B + C*D) where C and D can be either FX10 or FP20.
// Each unit has 4 inputs represented as A, B, C, and D.  D can be fixed or floating-point, but
// is restricted to B or C's selection.
//
//
// Remap table offset: controls what indirect entry in the remap table gets accessed.
// INDEX auto-increments with each access to REMAP_DATA (by 4 for accesses to REMAP_DATA_4X)
// BASE is added to the REMAP_DATA and REMAP_DATA_4X OFFSET value(s) on writes.
// Reads to REMAP_DATA or REMAP_DATA_4X return result of addition at the time of the last write to that INDEX.
// Writes to LWE297_GLOBAL_INST_OFFSET will update the index field of this register
// Writes to LWE297_ALU_INST_OFFSET will update the BASE field.
//      this update will divide the INDEX from INST_OFFSET by the number of words
//      in an single logical alu instruction 
//      (LW_GR3D_ALU_INST_NUM_WORDS * LW_GR3D_NUM_ALUS) 

// Register LWE297_ALU_REMAP_OFFSET_0  
#define LWE297_ALU_REMAP_OFFSET_0                           0x800
// current read or write target in REMAP_DATA
#define LWE297_ALU_REMAP_OFFSET_0_INDEX                            5:0

// value to add to OFFSET on write
#define LWE297_ALU_REMAP_OFFSET_0_BASE                             11:6

//
// Remap table - remaps packet sequence #'s to counts and offsets of real INST[]'s
//

// Register LWE297_ALU_REMAP_DATA_0  
#define LWE297_ALU_REMAP_DATA_0                             0x801
#define LWE297_ALU_REMAP_DATA_0_COUNT                              1:0

#define LWE297_ALU_REMAP_DATA_0_OFFSET                             7:2

//
// 4X Remap table - 4-at-a-time indirect port for remap tables (can be aligned at any REMAP_OFFSET INDEX value)
//

// Register LWE297_ALU_REMAP_DATA_4X_0  
#define LWE297_ALU_REMAP_DATA_4X_0                                  0x802
#define LWE297_ALU_REMAP_DATA_4X_0_COUNT0                          1:0

#define LWE297_ALU_REMAP_DATA_4X_0_OFFSET0                         7:2

#define LWE297_ALU_REMAP_DATA_4X_0_COUNT1                          9:8

#define LWE297_ALU_REMAP_DATA_4X_0_OFFSET1                         15:10

#define LWE297_ALU_REMAP_DATA_4X_0_COUNT2                          17:16

#define LWE297_ALU_REMAP_DATA_4X_0_OFFSET2                         23:18

#define LWE297_ALU_REMAP_DATA_4X_0_COUNT3                          25:24

#define LWE297_ALU_REMAP_DATA_4X_0_OFFSET3                         31:26

//
// Instruction table offset: controls what indirect entry in the instruction table gets accessed.
// INDEX auto-increments with each access to INST_DATA.
// This register will also update the BASE field of REMAP_OFFSET
//      this update will divide the INDEX from INST_OFFSET by the number of words
//      in an single logical atrast instruction 
//      (LW_GR3D_AT_INST_NUM_WORDS) 

// Register LWE297_ALU_INST_OFFSET_0  
#define LWE297_ALU_INST_OFFSET_0                            0x803
// current read or write target in INST_DATA
#define LWE297_ALU_INST_OFFSET_0_INDEX                             8:0

//
// Instruction table. 
// this array of instruction registers uses variant encodings within one
// register spec to allow single instructions to be pairs of adjacent writes
// The table below is 4* deeper to account for the 4 ALUs.
// The layout is
//    INST[0] = ALU0 instruction 0 even [OP DEST A]
//    INST[1] = ALU0 instruction 0 odd  [B C D]
//    INST[2] = ALU1 instruction 0 even [OP DEST A]
//       ...
//    INST[8] = ALU0 instruction 1 even [OP DEST A]
//       ...
//

// Register LWE297_ALU_INST_DATA_0  
#define LWE297_ALU_INST_DATA_0                              0x804
//   Operation (LWE297_ALU_OP)
#define LWE297_ALU_INST_DATA_0_OP                          31:27

//   Destination control (LWE297_ALU_RESSEL)
#define LWE297_ALU_INST_DATA_0_DEST                        26:13

//   A input control (LWE297_ALU_ARGSEL_ABC)
#define LWE297_ALU_INST_DATA_0_A                           12:0

//   B input control (LWE297_ALU_ARGSEL_ABC)
#define LWE297_ALU_INST_DATA_0_B                           31:19

//   C input control (LWE297_ALU_ARGSEL_ABC)
#define LWE297_ALU_INST_DATA_0_C                           18:6

//   D input control (LWE297_ALU_ARGSEL_D)
#define LWE297_ALU_INST_DATA_0_D                           5:0

//
// Descriptions of Instruction fields:
//
// --------------------------------------------------------------
// Argument Selector for A,B,C inputs (LWE297_ALU_ARGSEL_ABC)
// --------------------------------------------------------------
// 
// LWE297_ALU_ARGSEL_ABC
//     12:6  RSEL       register select index
//     5:5   MOD        select LOW or HIGH 10b (s1.8).  use with fixed-point precision.
//     4:4   SUB_1      input modifier:  subtract 1, only applicable to FX10 inputs (.HI or .LO)
//     3:3   PREC       choose either fixed-point input or floating-point input
//     2:2   ABS        input modifier:  absolute value
//     1:1   NEG        input modifier:  negate
//     0:0   X2         input modifier:  multiply by 2
//
// A,B and C can be any of
//  o up to 16 row registers (4 per row)
//  o 8 scratch registers (plus any of the unused rows)
//  o 32 globals
//  o 3 immediate values.
//  o constant 0.0 or 1.0
//  o x,y values in packed format (2 registers)
//  o kill code
//  o up to 16 predicate bits (4 per row)
//
// There are 4 input modifiers that can be applied to the A, B, and C inputs: subtract one, scale by 2, absolute, and negate.
//
// Register select (12:6) mapping:
//       000xxxx  Row register R0-R15.  Can be used as FP20 or dual FX10 pairs.
//       0010xxx  Scratch registers S0-S7.  Can be used as FP20 or dual FX10 pairs.
//       00110xx  ALU results RES0-RES3.  Can be used as FP20 or dual FX10 pairs.  
//                Note, the RES bus will normally be read the same way the intended destination would be read
//                (Fp20 for the Fp20 representation, or .HI or .LO for the FX10 representations), except for one case:  
//                when writing a predicate with the FP20 modifier, the RES bus will have the FP20 representation of the 
//                predicate value (0.0 or 1.0) rather than the FX10 representation. 
//       00111xx  Immediates IMM0-IMM2.  Can be used as FP20 or dual FX10 pairs.  Read-only.  Consumes
//                ALU3's instruction, which becomes a NOP.
//       0011111  Constant 0.0 and 1.0 as a FX10 pair.  .lo is 0.0, .hi is 1.0.  Read-only.
//       01xxxxx  Globals, G0-G31.  Can be used as FP20 or dual FX10 pairs.  G8-G31 are read-only.
//       100000x  X,Y registers. 11-bit values, which can be directly interepreted as an FP20 values.  Read-only.
//       1000010  PCOV.  Pixel coverage -- count of 4 vcaa bits plus the center coverage.  Read-only.
//                Value stored as FX10 in .LO.
//       1001xxx  Predicate registers as FX10 pairs.  P0.lo is predicate 0, P0.hi is predicate 1, etc.  Reads
//                as 0.0 or 1.0, can write as 0.0 or not 0.0, which maps to 1. Note than when
//                late VCAA is enabled, the VCAA bits are mapped to P0 and P1.
//       1010000  FF.  Front-face -- indicates that polygon is front-faced.  Stored from spanstart.  Read-only.  
//                Value stored as FX10 in .LO.
//       1010001  Kill code as FX10 value.  Only .lo is valid.  Reading returns 1.0 if pixel killed (or otherwise
//                not rendered) and 0.0 if pixel is live.  Writing any non-zero value will kill pixel, writing 0.0 will leave
//                current kill code state alone. 
//       others   Other values are undefined and should not be used.
//
//       Note: The value written to a destination by the immediately preceding instruction is only accessible using the RES input.
//             
//                Write to G[n] (where n is in the range 0-7) is mapped to G[8*interleave + n] (where interleave is defined
//                as the pixel number in the current quad).  Example below.
//             Writes to G0-G7 are mapped to G0-G7, G8-G15, G16-G23, or G24-G31 based on the pixel's interleave in the quad.  This allows
//             inter-pixel communication.  For example:
//                 G0 = R0;  // pixel 0's R0 is written to G0
//                           // pixel 1's R0 is written to G8
//                           // pixel 2's R0 is written to G16
//                           // pixel 3's R0 is written to G24
//                 R0 = G0;  // each pixel's R0 gets G0 (which is pixel 0's R0); there is no aliasing on reads

// Packet LWE297_ALU_ARGSEL_ABC
#define LWE297_ALU_ARGSEL_ABC_SIZE 13

// register select index
#define LWE297_ALU_ARGSEL_ABC_RSEL_ROW                    0
#define LWE297_ALU_ARGSEL_ABC_RSEL_R0                     0x00000000
#define LWE297_ALU_ARGSEL_ABC_RSEL_R1                     0x00000001
#define LWE297_ALU_ARGSEL_ABC_RSEL_R2                     0x00000002
#define LWE297_ALU_ARGSEL_ABC_RSEL_R3                     0x00000003
#define LWE297_ALU_ARGSEL_ABC_RSEL_R4                     0x00000004
#define LWE297_ALU_ARGSEL_ABC_RSEL_R5                     0x00000005
#define LWE297_ALU_ARGSEL_ABC_RSEL_R6                     0x00000006
#define LWE297_ALU_ARGSEL_ABC_RSEL_R7                     0x00000007
#define LWE297_ALU_ARGSEL_ABC_RSEL_R8                     0x00000008
#define LWE297_ALU_ARGSEL_ABC_RSEL_R9                     0x00000009
#define LWE297_ALU_ARGSEL_ABC_RSEL_R10                    0x0000000a
#define LWE297_ALU_ARGSEL_ABC_RSEL_R11                    0x0000000b
#define LWE297_ALU_ARGSEL_ABC_RSEL_R12                    0x0000000c
#define LWE297_ALU_ARGSEL_ABC_RSEL_R13                    0x0000000d
#define LWE297_ALU_ARGSEL_ABC_RSEL_R14                    0x0000000e
#define LWE297_ALU_ARGSEL_ABC_RSEL_R15                    0x0000000f
#define LWE297_ALU_ARGSEL_ABC_RSEL_S0                     0x00000010
#define LWE297_ALU_ARGSEL_ABC_RSEL_S1                     0x00000011
#define LWE297_ALU_ARGSEL_ABC_RSEL_S2                     0x00000012
#define LWE297_ALU_ARGSEL_ABC_RSEL_S3                     0x00000013
#define LWE297_ALU_ARGSEL_ABC_RSEL_S4                     0x00000014
#define LWE297_ALU_ARGSEL_ABC_RSEL_S5                     0x00000015
#define LWE297_ALU_ARGSEL_ABC_RSEL_S6                     0x00000016
#define LWE297_ALU_ARGSEL_ABC_RSEL_S7                     0x00000017
#define LWE297_ALU_ARGSEL_ABC_RSEL_RES0                   0x00000018
#define LWE297_ALU_ARGSEL_ABC_RSEL_RES1                   0x00000019
#define LWE297_ALU_ARGSEL_ABC_RSEL_RES2                   0x0000001a
#define LWE297_ALU_ARGSEL_ABC_RSEL_RES3                   0x0000001b
#define LWE297_ALU_ARGSEL_ABC_RSEL_IMM0                   0x0000001c
#define LWE297_ALU_ARGSEL_ABC_RSEL_IMM1                   0x0000001d
#define LWE297_ALU_ARGSEL_ABC_RSEL_IMM2                   0x0000001e
#define LWE297_ALU_ARGSEL_ABC_RSEL_C01                    0x0000001f
#define LWE297_ALU_ARGSEL_ABC_RSEL_G0                     0x00000020
#define LWE297_ALU_ARGSEL_ABC_RSEL_G1                     0x00000021
#define LWE297_ALU_ARGSEL_ABC_RSEL_G2                     0x00000022
#define LWE297_ALU_ARGSEL_ABC_RSEL_G3                     0x00000023
#define LWE297_ALU_ARGSEL_ABC_RSEL_G4                     0x00000024
#define LWE297_ALU_ARGSEL_ABC_RSEL_G5                     0x00000025
#define LWE297_ALU_ARGSEL_ABC_RSEL_G6                     0x00000026
#define LWE297_ALU_ARGSEL_ABC_RSEL_G7                     0x00000027
#define LWE297_ALU_ARGSEL_ABC_RSEL_G8                     0x00000028
#define LWE297_ALU_ARGSEL_ABC_RSEL_G9                     0x00000029
#define LWE297_ALU_ARGSEL_ABC_RSEL_G10                    0x0000002a
#define LWE297_ALU_ARGSEL_ABC_RSEL_G11                    0x0000002b
#define LWE297_ALU_ARGSEL_ABC_RSEL_G12                    0x0000002c
#define LWE297_ALU_ARGSEL_ABC_RSEL_G13                    0x0000002d
#define LWE297_ALU_ARGSEL_ABC_RSEL_G14                    0x0000002e
#define LWE297_ALU_ARGSEL_ABC_RSEL_G15                    0x0000002f
#define LWE297_ALU_ARGSEL_ABC_RSEL_G16                    0x00000030
#define LWE297_ALU_ARGSEL_ABC_RSEL_G17                    0x00000031
#define LWE297_ALU_ARGSEL_ABC_RSEL_G18                    0x00000032
#define LWE297_ALU_ARGSEL_ABC_RSEL_G19                    0x00000033
#define LWE297_ALU_ARGSEL_ABC_RSEL_G20                    0x00000034
#define LWE297_ALU_ARGSEL_ABC_RSEL_G21                    0x00000035
#define LWE297_ALU_ARGSEL_ABC_RSEL_G22                    0x00000036
#define LWE297_ALU_ARGSEL_ABC_RSEL_G23                    0x00000037
#define LWE297_ALU_ARGSEL_ABC_RSEL_G24                    0x00000038
#define LWE297_ALU_ARGSEL_ABC_RSEL_G25                    0x00000039
#define LWE297_ALU_ARGSEL_ABC_RSEL_G26                    0x0000003a
#define LWE297_ALU_ARGSEL_ABC_RSEL_G27                    0x0000003b
#define LWE297_ALU_ARGSEL_ABC_RSEL_G28                    0x0000003c
#define LWE297_ALU_ARGSEL_ABC_RSEL_G29                    0x0000003d
#define LWE297_ALU_ARGSEL_ABC_RSEL_G30                    0x0000003e
#define LWE297_ALU_ARGSEL_ABC_RSEL_G31                    0x0000003f
#define LWE297_ALU_ARGSEL_ABC_RSEL_P0                     0x00000040
#define LWE297_ALU_ARGSEL_ABC_RSEL_P1                     0x00000041
#define LWE297_ALU_ARGSEL_ABC_RSEL_P2                     0x00000042
#define LWE297_ALU_ARGSEL_ABC_RSEL_P3                     0x00000043
#define LWE297_ALU_ARGSEL_ABC_RSEL_P4                     0x00000044
#define LWE297_ALU_ARGSEL_ABC_RSEL_P5                     0x00000045
#define LWE297_ALU_ARGSEL_ABC_RSEL_P6                     0x00000046
#define LWE297_ALU_ARGSEL_ABC_RSEL_P7                     0x00000047
#define LWE297_ALU_ARGSEL_ABC_RSEL_X                      0x00000048
#define LWE297_ALU_ARGSEL_ABC_RSEL_Y                      0x00000049
#define LWE297_ALU_ARGSEL_ABC_RSEL_PCOV                   0x0000004a
#define LWE297_ALU_ARGSEL_ABC_RSEL_FF                     0x0000004b
#define LWE297_ALU_ARGSEL_ABC_RSEL_KC                     0x0000004c

// select LOW or HIGH 10b (s1.8).  use with fixed-point precision.
#define LWE297_ALU_ARGSEL_ABC_MOD_ROW                     0
#define LWE297_ALU_ARGSEL_ABC_MOD_L                       0x00000000
#define LWE297_ALU_ARGSEL_ABC_MOD_H                       0x00000001

// input modifier:  subtract 1, only applicable to FX10 inputs (.LO or .HI)
#define LWE297_ALU_ARGSEL_ABC_SUB_1_ROW                   0

// choose either fixed-point input or floating-point input
#define LWE297_ALU_ARGSEL_ABC_PREC_ROW                    0
#define LWE297_ALU_ARGSEL_ABC_PREC_FP                     0x00000000
#define LWE297_ALU_ARGSEL_ABC_PREC_FX                     0x00000001

// input modifier:  absolute value
#define LWE297_ALU_ARGSEL_ABC_ABS_ROW                     0

// input modifier:  negate
#define LWE297_ALU_ARGSEL_ABC_NEG_ROW                     0

// input modifier:  multiply by 2
#define LWE297_ALU_ARGSEL_ABC_X2_ROW                      0

// --------------------------------------------------------------
// Argument selector for D input (LWE297_ALU_ARGSEL_D)
// --------------------------------------------------------------
// D can only be B or C.  MOD can be set such that the D input 
// selects an the HI or LO half of B or C.  PREC determines whether to 
// use the FX10 half chosen by MOD or the full FP20.
//
//  LWE297_ALU_ARGSEL_D
//     5:5   RSEL     register select index - One of B or C
//     4:4   MOD      select LOW or HIGH 10b (s1.8)
//     3:3   SUB_1    input modifier:  subtract one, only applicable to FX10 inputs (.LO or .HI)
//     2:2   FUNC     Select A*B+C or A*B+C*D -- the latter effectively enables the D input
//     1:1   ABS      input modifier:  absolute
//     0:0   PREC     choose fixed-point or floating-point input
// The D input has only one input modifier, subtract one.
//

// Packet LWE297_ALU_ARGSEL_D
#define LWE297_ALU_ARGSEL_D_SIZE 6

// register select index - One of B or C
#define LWE297_ALU_ARGSEL_D_RSEL_ROW                      0
#define LWE297_ALU_ARGSEL_D_RSEL_B                        0x00000000
#define LWE297_ALU_ARGSEL_D_RSEL_C                        0x00000001

// select LOW or HIGH 10b (s1.8)
#define LWE297_ALU_ARGSEL_D_MOD_ROW                       0
#define LWE297_ALU_ARGSEL_D_MOD_L                 0x00000000
#define LWE297_ALU_ARGSEL_D_MOD_H                 0x00000001

// input modifier:  subtract one, only applicable to FX10 inputs (.LO or .HI)
#define LWE297_ALU_ARGSEL_D_SUB_1_ROW                     0

// Select A*B+C or A*B+C*D -- the latter effectively enables the D input
#define LWE297_ALU_ARGSEL_D_FUNC_ROW                      0
#define LWE297_ALU_ARGSEL_D_FUNC_MAD                      0x00000000
#define LWE297_ALU_ARGSEL_D_FUNC_DP2                      0x00000001

// input modifier:  absolute
#define LWE297_ALU_ARGSEL_D_ABS_ROW                       0

// choose either fixed-point input or floating-point input
#define LWE297_ALU_ARGSEL_D_PREC_ROW                      0
#define LWE297_ALU_ARGSEL_D_PREC_FP                       0x00000000
#define LWE297_ALU_ARGSEL_D_PREC_FX                       0x00000001

// --------------------------------------------------------------
// X and Y coordinates (ALU_LWE297_XY)
// --------------------------------------------------------------
// A coordinate is read as an FP20, where the actual coordinate is stored in the bottom 12 bits.  
// The FP20 exponent is loaded with 2^13 so that X,Y value can be interereted directly by subtracting 8192.
#define ALU_XY_EXP      44

// Packet LWE297_ALU_COORD
#define LWE297_ALU_COORD_SIZE 20

// static exponent field, set to ALU_XY_EXP (2^13)
#define LWE297_ALU_COORD_EXP_ROW                  0

// where the actual coordinate is stored
#define LWE297_ALU_COORD_COORD_ROW                        0

// stored as FP20
#define LWE297_ALU_COORD_FP20_ROW                 0

// --------------------------------------------------------------
// ALU Operations (LWE297_ALU_OP)
// --------------------------------------------------------------
// LWE297_ALU_OP
//     4:3  OP         opcode
//                     0=MAD
//                     1=MIN
//                     2=MAX
//                     3=CMP
//     2    SEND     send mult result to ALU N, see mapping above
//     1    RECV     use the mult result of the next ALU rather than C input
//     0    MMUL     turn on the second destination
//
// The ALU can compute one of the following per clock. The {*D} indicates
// an optional multiply
//
// o MAD = DEST = A*B +C{*D}
// o MIN = MIN (A*B, C*{D})
// o MAX = MAX (A*B, C{*D})
// o CMP = (A < 0 && A != -0) ? B: C{*D}
//
// Note that to use CMP on a predicate, you probably need an input modifer like NEG or SUB1.
// Also note that the CMP instruction matches the CMP instruction from ARB_fragment_program.
// The CMP instruction is different from that of DX9 and DX10 (which are also different from each other).
// Another note, C*{D} will be replaced by the previous ALU's multiply result if the RECV mux is turned on.
//
// The ALUs multipliers can be linked together to compute more complex functions like
// DP2A, DP3, DP4 etc.  The details are as follows:
//
// Each ALU functions like so fx2fp -> fpMULT -> fpADD -> fp2fx.  However, ALU0 has an ADD4 rather than an ADD2,
// and ALU2 has an ADD3.  These larger fpADDs can accept the outputs of the other ALU's multipliers for more 
// complex functions.  
//
// Each ALU has a RECV mux that chooses between the previous ALU's mult result or its own C input.  
// The RECV mux's result is used for all operators: MAD, MAX, MIN, and CMP.
// Each ALU besides ALU 0 has a SEND mux, which either 'sends' the result of the ALU's mult or 0: 
//   ALU 0, no SEND mux
//   ALU 1, SEND mux connects to ALU 0
//   ALU 2, SEND mux connects to ALU 0
//   ALU 3, SEND mux connects to ALU 2
//
// In table form, the interaction of the ALUs is shown below:
//   -Read horizontally as ALU N has an S or R output to ALU 0-3, where R stands for unconditional send
//   (countered by a conditional receive on the input side) and S stands for conditional send.
//   -Read vertically, ALU N has an S or R input from ALU 0-3.
//           0    1    2    3
//   ALU 0   -    R    -    - 
//       1   S    -    R    -
//       2   S    -    -    R
//       3   R    -    S    -
//
// SEND/RECV mux programming guide (- indicates don't enable either mux):
//   Function         ALU0      ALU1      ALU2      ALU3
//   4x MAD           -         -         -         -
//   2x DP2A          -         SEND      -         SEND
//   2x DP2           RECV      -         RECV      SEND
//   1x DP3A + 1xMAD  -         SEND      SEND      - 
//   1x DP3  + 1xMAD  RECV      SEND      -         - 
//   1x DP2a + 2xMAD  -         SEND      -         -
//   1x DP4           RECV      SEND      SEND      -   
//
//
// Finally, there is a dual-FP multiply mode that is enabled with the MMUL bit.  When enabled, instead
// of computing A*B+C{*D}, the quantities A*B and C{*D} are computed seperately and packed into a pair
// of FX10's.  The A*B quantity is written to the register half specified by the DEST field and the
// C{*D} parameter is written into the other half.  Any output mods are applied to both.

// Packet LWE297_ALU_OP
#define LWE297_ALU_OP_SIZE 5

// opcode
#define LWE297_ALU_OP_OP_ROW                      0
#define LWE297_ALU_OP_OP_MAD                      0x00000000
#define LWE297_ALU_OP_OP_MIN                      0x00000001
#define LWE297_ALU_OP_OP_MAX                      0x00000002
#define LWE297_ALU_OP_OP_CMP                      0x00000003

// send mult result to ALU N, see mapping above
#define LWE297_ALU_OP_SEND_ROW                    0

// use the mult result of the next ALU rather than C input
#define LWE297_ALU_OP_RECV_ROW                    0

// turn on the second destination
#define LWE297_ALU_OP_MMUL_ROW                    0

// --------------------------------------------------------------
// Destination Selector (LWE297_ALU_RESSEL)
// --------------------------------------------------------------
// Select destination and any output modifiers.  The destinations are the same list as the inputs, but note
// that that some of destinations are read-only, which is listed above.  The destination can be written as fixed-point
// or floating-point.
//
// Output modifiers:  scale by 0.5, 1, 2, 4; clamp between 0.0 and 1.0; compare result to 0 and set destination to 0.0/1.0
// Note, output modifiers are performed in the precision of the destination; this is most relevant to the CCs.
// Register example:
//     destination R0.LO, CC will be performed in FX10 precision
//     destination R0, CC will be performed in FP20 precision
// Predicate example:
//     destination P0.LO, CC will be performed in FX10 precision
//     destination P0, CC will be performed in FP20 precision (and written to P0.HI)
//     destination P0.FPLO, CC will be performed in FP20 precision (and written to P0.LO)
//
// LWE297_ALU_RESSEL
//     13:12  SCALE     output modifier:  output scale, *1, *2, *4 or /2
//                      0=X1
//                      1=X2
//                      2=X4
//                      3=DIV2
//     11:11  CLAMP     output modifier:  clamp to [0.0..1.0]
//     10:9   CC        output modifier:  output compare.  Set to 0.0/1.0 if result == 0.0 / >= 0.0 / > 0.0
//                                        if destination is a predicate, set 0.0/1.0 if result != 0
//                      0=NONE
//                      1=EQ
//                      2=GT
//                      3=GEQ
//     8:2    RSEL      destination register select index.  Follows same mapping as ARGSEL_ABC
//     1:0    DSTSEL    Destination select.  Only use FP20_L if sending an FP20 output to a register that shares 2 values (predicates).  
//                      FP20 should be used in all other cases.  When not writing a predicate, FP20_L will be considered a NOP and
//                      nothing will be written.  Note, the RES bus will have the FP20 representation of the predicate value (0.0 or 1.0)
//                      if the predicate is written with the FP20 or FP20_L modifier.
//                      0=FP20_L
//                      1=FX10_L
//                      2=FX10_H
//                      3=FP20
//

// Packet LWE297_ALU_RESSEL
#define LWE297_ALU_RESSEL_SIZE 14

// output modifier:  output scale, *1, *2, *4 or /2
#define LWE297_ALU_RESSEL_SCALE_ROW                       0
#define LWE297_ALU_RESSEL_SCALE_X1                        0x00000000
#define LWE297_ALU_RESSEL_SCALE_X2                        0x00000001
#define LWE297_ALU_RESSEL_SCALE_X4                        0x00000002
#define LWE297_ALU_RESSEL_SCALE_DIV2                      0x00000003

// output modifier:  clamp to [0.0..1.0]
#define LWE297_ALU_RESSEL_CLAMP_ROW                       0

// output modifier:  output compare.  Set to 0.0/1.0 if result == 0.0 / >= 0.0 / > 0.0
//                   if destination is a predicate, set 0.0/1.0 if result != 0
//                   Note, output modifiers are performed in the precision of the destination
#define LWE297_ALU_RESSEL_CC_ROW                  0
#define LWE297_ALU_RESSEL_CC_NONE                 0x00000000
#define LWE297_ALU_RESSEL_CC_SEQ                  0x00000001
#define LWE297_ALU_RESSEL_CC_SGT                  0x00000002
#define LWE297_ALU_RESSEL_CC_SGE                  0x00000003

// destination register select index.
#define LWE297_ALU_RESSEL_RSEL_ROW                        0
#define LWE297_ALU_RESSEL_RSEL_R0                 0x00000000
#define LWE297_ALU_RESSEL_RSEL_R1                 0x00000001
#define LWE297_ALU_RESSEL_RSEL_R2                 0x00000002
#define LWE297_ALU_RESSEL_RSEL_R3                 0x00000003
#define LWE297_ALU_RESSEL_RSEL_R4                 0x00000004
#define LWE297_ALU_RESSEL_RSEL_R5                 0x00000005
#define LWE297_ALU_RESSEL_RSEL_R6                 0x00000006
#define LWE297_ALU_RESSEL_RSEL_R7                 0x00000007
#define LWE297_ALU_RESSEL_RSEL_R8                 0x00000008
#define LWE297_ALU_RESSEL_RSEL_R9                 0x00000009
#define LWE297_ALU_RESSEL_RSEL_R10                        0x0000000a
#define LWE297_ALU_RESSEL_RSEL_R11                        0x0000000b
#define LWE297_ALU_RESSEL_RSEL_R12                        0x0000000c
#define LWE297_ALU_RESSEL_RSEL_R13                        0x0000000d
#define LWE297_ALU_RESSEL_RSEL_R14                        0x0000000e
#define LWE297_ALU_RESSEL_RSEL_R15                        0x0000000f
#define LWE297_ALU_RESSEL_RSEL_S0                 0x00000010
#define LWE297_ALU_RESSEL_RSEL_S1                 0x00000011
#define LWE297_ALU_RESSEL_RSEL_S2                 0x00000012
#define LWE297_ALU_RESSEL_RSEL_S3                 0x00000013
#define LWE297_ALU_RESSEL_RSEL_S4                 0x00000014
#define LWE297_ALU_RESSEL_RSEL_S5                 0x00000015
#define LWE297_ALU_RESSEL_RSEL_S6                 0x00000016
#define LWE297_ALU_RESSEL_RSEL_S7                 0x00000017
#define LWE297_ALU_RESSEL_RSEL_RES0                       0x00000018
#define LWE297_ALU_RESSEL_RSEL_RES1                       0x00000019
#define LWE297_ALU_RESSEL_RSEL_RES2                       0x0000001a
#define LWE297_ALU_RESSEL_RSEL_RES3                       0x0000001b
#define LWE297_ALU_RESSEL_RSEL_IMM0                       0x0000001c
#define LWE297_ALU_RESSEL_RSEL_IMM1                       0x0000001d
#define LWE297_ALU_RESSEL_RSEL_IMM2                       0x0000001e
#define LWE297_ALU_RESSEL_RSEL_C01                        0x0000001f
#define LWE297_ALU_RESSEL_RSEL_G0                 0x00000020
#define LWE297_ALU_RESSEL_RSEL_G1                 0x00000021
#define LWE297_ALU_RESSEL_RSEL_G2                 0x00000022
#define LWE297_ALU_RESSEL_RSEL_G3                 0x00000023
#define LWE297_ALU_RESSEL_RSEL_G4                 0x00000024
#define LWE297_ALU_RESSEL_RSEL_G5                 0x00000025
#define LWE297_ALU_RESSEL_RSEL_G6                 0x00000026
#define LWE297_ALU_RESSEL_RSEL_G7                 0x00000027
#define LWE297_ALU_RESSEL_RSEL_G8                 0x00000028
#define LWE297_ALU_RESSEL_RSEL_G9                 0x00000029
#define LWE297_ALU_RESSEL_RSEL_G10                        0x0000002a
#define LWE297_ALU_RESSEL_RSEL_G11                        0x0000002b
#define LWE297_ALU_RESSEL_RSEL_G12                        0x0000002c
#define LWE297_ALU_RESSEL_RSEL_G13                        0x0000002d
#define LWE297_ALU_RESSEL_RSEL_G14                        0x0000002e
#define LWE297_ALU_RESSEL_RSEL_G15                        0x0000002f
#define LWE297_ALU_RESSEL_RSEL_G16                        0x00000030
#define LWE297_ALU_RESSEL_RSEL_G17                        0x00000031
#define LWE297_ALU_RESSEL_RSEL_G18                        0x00000032
#define LWE297_ALU_RESSEL_RSEL_G19                        0x00000033
#define LWE297_ALU_RESSEL_RSEL_G20                        0x00000034
#define LWE297_ALU_RESSEL_RSEL_G21                        0x00000035
#define LWE297_ALU_RESSEL_RSEL_G22                        0x00000036
#define LWE297_ALU_RESSEL_RSEL_G23                        0x00000037
#define LWE297_ALU_RESSEL_RSEL_G24                        0x00000038
#define LWE297_ALU_RESSEL_RSEL_G25                        0x00000039
#define LWE297_ALU_RESSEL_RSEL_G26                        0x0000003a
#define LWE297_ALU_RESSEL_RSEL_G27                        0x0000003b
#define LWE297_ALU_RESSEL_RSEL_G28                        0x0000003c
#define LWE297_ALU_RESSEL_RSEL_G29                        0x0000003d
#define LWE297_ALU_RESSEL_RSEL_G30                        0x0000003e
#define LWE297_ALU_RESSEL_RSEL_G31                        0x0000003f
#define LWE297_ALU_RESSEL_RSEL_P0                 0x00000040
#define LWE297_ALU_RESSEL_RSEL_P1                 0x00000041
#define LWE297_ALU_RESSEL_RSEL_P2                 0x00000042
#define LWE297_ALU_RESSEL_RSEL_P3                 0x00000043
#define LWE297_ALU_RESSEL_RSEL_P4                 0x00000044
#define LWE297_ALU_RESSEL_RSEL_P5                 0x00000045
#define LWE297_ALU_RESSEL_RSEL_P6                 0x00000046
#define LWE297_ALU_RESSEL_RSEL_P7                 0x00000047
#define LWE297_ALU_RESSEL_RSEL_X                  0x00000048
#define LWE297_ALU_RESSEL_RSEL_Y                  0x00000049
#define LWE297_ALU_RESSEL_RSEL_PCOV                       0x0000004a
#define LWE297_ALU_RESSEL_RSEL_FF                 0x0000004b
#define LWE297_ALU_RESSEL_RSEL_KC                 0x0000004c

// Destination select.  Only use FP20_L if sending an FP20 output to a register that shares 2 values (predicates); FP20 should be used in all other cases.  When not writing a predicate, FP20_L will be considered a NOP and nothing will be written.  Note, the RES bus will have the FP20 representation of the predicate value (0.0 or 1.0) if the predicate is written with the FP20 or FP20_L modifier.  Output modifiers are performed in the precision of the destination.
#define LWE297_ALU_RESSEL_DSTSEL_ROW                      0
#define LWE297_ALU_RESSEL_DSTSEL_FP20                     0x00000003
#define LWE297_ALU_RESSEL_DSTSEL_FX10_H                   0x00000002
#define LWE297_ALU_RESSEL_DSTSEL_FX10_L                   0x00000001
#define LWE297_ALU_RESSEL_DSTSEL_FP20_L                   0x00000000

//
// P2CX table offset: controls what indirect entry in the p2cx table gets accessed.
// INDEX auto-increments with each access to P2CX_DATA.
//

// Register LWE297_ALU_P2CX_OFFSET_0  
#define LWE297_ALU_P2CX_OFFSET_0                            0x805
// current read or write
// target in P2CX_DATA
#define LWE297_ALU_P2CX_OFFSET_0_INDEX                             5:0

// P2CX does the following operation on the pixel packet CX bit for each row.
// The pixel indexes into the P2CX table by its sequence number
// 
//  -predicate is all the predicates where predicate[0] is P0.L and
//      predicate[15] is P7.H.
//  -op, mask, and reference come from the instruction
//  -op overlaps both mask and reference.
//
// switch(op)
// { 
// case EXECUTE:    cx = EXECUTE;       break;
// case NO_EXELWTE: cx = NO_EXELWTE;    break;
// case KEEP:       cx = cx;            break;
// case ILWERT:     cx = !cx;           break;
// default:
//      cx = ((predicate[15:0] & mask) == reference) ?
//              EXECUTE : NO_EXELWTE
//      break;
// }

// Register LWE297_ALU_P2CX_DATA_0  
#define LWE297_ALU_P2CX_DATA_0                              0x806
// Predicate mask used to mask the compare
#define LWE297_ALU_P2CX_DATA_0_MASK                        31:16

// Predicate value to compare against
#define LWE297_ALU_P2CX_DATA_0_REFERENCE                           15:0

// A small set of values are treated as opcodes
#define LWE297_ALU_P2CX_DATA_0_OPCODE                              31:0
#define LWE297_ALU_P2CX_DATA_0_OPCODE_KEEP                        0x00000000
#define LWE297_ALU_P2CX_DATA_0_OPCODE_ILWERT                      0x00000001
#define LWE297_ALU_P2CX_DATA_0_OPCODE_EXELWTE                     0x00000002
#define LWE297_ALU_P2CX_DATA_0_OPCODE_NO_EXELWTE                  0x00000003

//
// Global values (available as Gxx registers)
// G0-G31 are readable.  G8-G31 are read-only.
// An ALU write (not a register write) to G[n] (where n is in the range 0-7) is mapped to G[8*interleave + n] 
// (where interleave is defined as the pixel number in the quad, 0-3).  
// This allows inter-pixel communication.  For example:
//     G0 = R0;  // pixel 0's R0 is written to G0
//               // pixel 1's R0 is written to G8
//               // pixel 2's R0 is written to G16
//               // pixel 3's R0 is written to G24
//     R0 = G0;  // each pixel's R0 gets G0 (which is pixel 0's R0); there is no aliasing on reads

// Register LWE297_ALU_GLOBALS_0  
#define LWE297_ALU_GLOBALS_0                                0x820
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_0_L10                           9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_0_H10                           19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_0_VAL                           19:0


// Register LWE297_ALU_GLOBALS  
#define LWE297_ALU_GLOBALS                                  0x820
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_L10                             9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_H10                             19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_VAL                             19:0


// Register LWE297_ALU_GLOBALS_1  
#define LWE297_ALU_GLOBALS_1                                0x821
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_1_L10                           9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_1_H10                           19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_1_VAL                           19:0


// Register LWE297_ALU_GLOBALS_2  
#define LWE297_ALU_GLOBALS_2                                0x822
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_2_L10                           9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_2_H10                           19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_2_VAL                           19:0


// Register LWE297_ALU_GLOBALS_3  
#define LWE297_ALU_GLOBALS_3                                0x823
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_3_L10                           9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_3_H10                           19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_3_VAL                           19:0


// Register LWE297_ALU_GLOBALS_4  
#define LWE297_ALU_GLOBALS_4                                0x824
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_4_L10                           9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_4_H10                           19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_4_VAL                           19:0


// Register LWE297_ALU_GLOBALS_5  
#define LWE297_ALU_GLOBALS_5                                0x825
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_5_L10                           9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_5_H10                           19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_5_VAL                           19:0


// Register LWE297_ALU_GLOBALS_6  
#define LWE297_ALU_GLOBALS_6                                0x826
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_6_L10                           9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_6_H10                           19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_6_VAL                           19:0


// Register LWE297_ALU_GLOBALS_7  
#define LWE297_ALU_GLOBALS_7                                0x827
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_7_L10                           9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_7_H10                           19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_7_VAL                           19:0


// Register LWE297_ALU_GLOBALS_8  
#define LWE297_ALU_GLOBALS_8                                0x828
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_8_L10                           9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_8_H10                           19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_8_VAL                           19:0


// Register LWE297_ALU_GLOBALS_9  
#define LWE297_ALU_GLOBALS_9                                0x829
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_9_L10                           9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_9_H10                           19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_9_VAL                           19:0


// Register LWE297_ALU_GLOBALS_10  
#define LWE297_ALU_GLOBALS_10                               0x82a
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_10_L10                          9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_10_H10                          19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_10_VAL                          19:0


// Register LWE297_ALU_GLOBALS_11  
#define LWE297_ALU_GLOBALS_11                               0x82b
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_11_L10                          9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_11_H10                          19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_11_VAL                          19:0


// Register LWE297_ALU_GLOBALS_12  
#define LWE297_ALU_GLOBALS_12                               0x82c
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_12_L10                          9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_12_H10                          19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_12_VAL                          19:0


// Register LWE297_ALU_GLOBALS_13  
#define LWE297_ALU_GLOBALS_13                               0x82d
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_13_L10                          9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_13_H10                          19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_13_VAL                          19:0


// Register LWE297_ALU_GLOBALS_14  
#define LWE297_ALU_GLOBALS_14                               0x82e
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_14_L10                          9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_14_H10                          19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_14_VAL                          19:0


// Register LWE297_ALU_GLOBALS_15  
#define LWE297_ALU_GLOBALS_15                               0x82f
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_15_L10                          9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_15_H10                          19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_15_VAL                          19:0


// Register LWE297_ALU_GLOBALS_16  
#define LWE297_ALU_GLOBALS_16                               0x830
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_16_L10                          9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_16_H10                          19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_16_VAL                          19:0


// Register LWE297_ALU_GLOBALS_17  
#define LWE297_ALU_GLOBALS_17                               0x831
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_17_L10                          9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_17_H10                          19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_17_VAL                          19:0


// Register LWE297_ALU_GLOBALS_18  
#define LWE297_ALU_GLOBALS_18                               0x832
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_18_L10                          9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_18_H10                          19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_18_VAL                          19:0


// Register LWE297_ALU_GLOBALS_19  
#define LWE297_ALU_GLOBALS_19                               0x833
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_19_L10                          9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_19_H10                          19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_19_VAL                          19:0


// Register LWE297_ALU_GLOBALS_20  
#define LWE297_ALU_GLOBALS_20                               0x834
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_20_L10                          9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_20_H10                          19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_20_VAL                          19:0


// Register LWE297_ALU_GLOBALS_21  
#define LWE297_ALU_GLOBALS_21                               0x835
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_21_L10                          9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_21_H10                          19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_21_VAL                          19:0


// Register LWE297_ALU_GLOBALS_22  
#define LWE297_ALU_GLOBALS_22                               0x836
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_22_L10                          9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_22_H10                          19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_22_VAL                          19:0


// Register LWE297_ALU_GLOBALS_23  
#define LWE297_ALU_GLOBALS_23                               0x837
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_23_L10                          9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_23_H10                          19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_23_VAL                          19:0


// Register LWE297_ALU_GLOBALS_24  
#define LWE297_ALU_GLOBALS_24                               0x838
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_24_L10                          9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_24_H10                          19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_24_VAL                          19:0


// Register LWE297_ALU_GLOBALS_25  
#define LWE297_ALU_GLOBALS_25                               0x839
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_25_L10                          9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_25_H10                          19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_25_VAL                          19:0


// Register LWE297_ALU_GLOBALS_26  
#define LWE297_ALU_GLOBALS_26                               0x83a
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_26_L10                          9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_26_H10                          19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_26_VAL                          19:0


// Register LWE297_ALU_GLOBALS_27  
#define LWE297_ALU_GLOBALS_27                               0x83b
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_27_L10                          9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_27_H10                          19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_27_VAL                          19:0


// Register LWE297_ALU_GLOBALS_28  
#define LWE297_ALU_GLOBALS_28                               0x83c
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_28_L10                          9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_28_H10                          19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_28_VAL                          19:0


// Register LWE297_ALU_GLOBALS_29  
#define LWE297_ALU_GLOBALS_29                               0x83d
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_29_L10                          9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_29_H10                          19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_29_VAL                          19:0


// Register LWE297_ALU_GLOBALS_30  
#define LWE297_ALU_GLOBALS_30                               0x83e
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_30_L10                          9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_30_H10                          19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_30_VAL                          19:0


// Register LWE297_ALU_GLOBALS_31  
#define LWE297_ALU_GLOBALS_31                               0x83f
// 10b low subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_31_L10                          9:0

// 10b high subfield already in s1.8 format
#define LWE297_ALU_GLOBALS_31_H10                          19:10

// RAST_R format, same as pixel packet registers
#define LWE297_ALU_GLOBALS_31_VAL                          19:0

//
// Immediates can hold up to 3 FP20 values, 6 FX10 values,
// or combinations of the two precisions (i.e. 1 Fp20, 4 FX10)
//
//

// Packet LWE297_ALU_IMMEDIATE
#define LWE297_ALU_IMMEDIATE_SIZE 60

// Imediate2   as FP20
#define LWE297_ALU_IMMEDIATE_IMM2FP_ROW                   0

// Imediate2.H as FX10
#define LWE297_ALU_IMMEDIATE_IMM2FXH_ROW                  0

// Imediate2.L as FX10
#define LWE297_ALU_IMMEDIATE_IMM2FXL_ROW                  0

// Imediate1   as FP20
#define LWE297_ALU_IMMEDIATE_IMM1FP_ROW                   0

// Imediate1.H as FX10
#define LWE297_ALU_IMMEDIATE_IMM1FXH_ROW                  0

// Imediate1.L as FX10
#define LWE297_ALU_IMMEDIATE_IMM1FXL_ROW                  0

// Imediate0   as FP20
#define LWE297_ALU_IMMEDIATE_IMM0FP_ROW                   0

// Imediate0.H as FX10
#define LWE297_ALU_IMMEDIATE_IMM0FXH_ROW                  0

// Imediate0.L as FX10
#define LWE297_ALU_IMMEDIATE_IMM0FXL_ROW                  0


// Packet LWE297_ALU_DATA_VEC
#define LWE297_ALU_DATA_VEC_SIZE 659

#define LWE297_ALU_DATA_VEC_R0_ROW                        0

#define LWE297_ALU_DATA_VEC_R1_ROW                        0

#define LWE297_ALU_DATA_VEC_R2_ROW                        0

#define LWE297_ALU_DATA_VEC_R3_ROW                        0

#define LWE297_ALU_DATA_VEC_R4_ROW                        0

#define LWE297_ALU_DATA_VEC_R5_ROW                        0

#define LWE297_ALU_DATA_VEC_R6_ROW                        0

#define LWE297_ALU_DATA_VEC_R7_ROW                        0

#define LWE297_ALU_DATA_VEC_R8_ROW                        0

#define LWE297_ALU_DATA_VEC_R9_ROW                        0

#define LWE297_ALU_DATA_VEC_R10_ROW                       0

#define LWE297_ALU_DATA_VEC_R11_ROW                       0

#define LWE297_ALU_DATA_VEC_R12_ROW                       0

#define LWE297_ALU_DATA_VEC_R13_ROW                       0

#define LWE297_ALU_DATA_VEC_R14_ROW                       0

#define LWE297_ALU_DATA_VEC_R15_ROW                       0

#define LWE297_ALU_DATA_VEC_S0_ROW                        0

#define LWE297_ALU_DATA_VEC_S1_ROW                        0

#define LWE297_ALU_DATA_VEC_S2_ROW                        0

#define LWE297_ALU_DATA_VEC_S3_ROW                        0

#define LWE297_ALU_DATA_VEC_S4_ROW                        0

#define LWE297_ALU_DATA_VEC_S5_ROW                        0

#define LWE297_ALU_DATA_VEC_S6_ROW                        0

#define LWE297_ALU_DATA_VEC_S7_ROW                        0

#define LWE297_ALU_DATA_VEC_G0_ROW                        0

#define LWE297_ALU_DATA_VEC_G1_ROW                        0

#define LWE297_ALU_DATA_VEC_G2_ROW                        0

#define LWE297_ALU_DATA_VEC_G3_ROW                        0

#define LWE297_ALU_DATA_VEC_G4_ROW                        0

#define LWE297_ALU_DATA_VEC_G5_ROW                        0

#define LWE297_ALU_DATA_VEC_G6_ROW                        0

#define LWE297_ALU_DATA_VEC_G7_ROW                        0

#define LWE297_ALU_DATA_VEC_P0_ROW                        0

#define LWE297_ALU_DATA_VEC_P1_ROW                        0

#define LWE297_ALU_DATA_VEC_P2_ROW                        0

#define LWE297_ALU_DATA_VEC_P3_ROW                        0

#define LWE297_ALU_DATA_VEC_P4_ROW                        0

#define LWE297_ALU_DATA_VEC_P5_ROW                        0

#define LWE297_ALU_DATA_VEC_P6_ROW                        0

#define LWE297_ALU_DATA_VEC_P7_ROW                        0

#define LWE297_ALU_DATA_VEC_P8_ROW                        0

#define LWE297_ALU_DATA_VEC_P9_ROW                        0

#define LWE297_ALU_DATA_VEC_P10_ROW                       0

#define LWE297_ALU_DATA_VEC_P11_ROW                       0

#define LWE297_ALU_DATA_VEC_P12_ROW                       0

#define LWE297_ALU_DATA_VEC_P13_ROW                       0

#define LWE297_ALU_DATA_VEC_P14_ROW                       0

#define LWE297_ALU_DATA_VEC_P15_ROW                       0

#define LWE297_ALU_DATA_VEC_KC_ROW                        0

#define LWE297_ALU_DATA_VEC_R0_15_ROW                     0

#define LWE297_ALU_DATA_VEC_S0_7_ROW                      0


// Packet LWE297_ALU_DATA_WE
#define LWE297_ALU_DATA_WE_SIZE 81

#define LWE297_ALU_DATA_WE_R0_LO_ROW                      0

#define LWE297_ALU_DATA_WE_R0_HI_ROW                      0

#define LWE297_ALU_DATA_WE_R1_LO_ROW                      0

#define LWE297_ALU_DATA_WE_R1_HI_ROW                      0

#define LWE297_ALU_DATA_WE_R2_LO_ROW                      0

#define LWE297_ALU_DATA_WE_R2_HI_ROW                      0

#define LWE297_ALU_DATA_WE_R3_LO_ROW                      0

#define LWE297_ALU_DATA_WE_R3_HI_ROW                      0

#define LWE297_ALU_DATA_WE_R4_LO_ROW                      0

#define LWE297_ALU_DATA_WE_R4_HI_ROW                      0

#define LWE297_ALU_DATA_WE_R5_LO_ROW                      0

#define LWE297_ALU_DATA_WE_R5_HI_ROW                      0

#define LWE297_ALU_DATA_WE_R6_LO_ROW                      0

#define LWE297_ALU_DATA_WE_R6_HI_ROW                      0

#define LWE297_ALU_DATA_WE_R7_LO_ROW                      0

#define LWE297_ALU_DATA_WE_R7_HI_ROW                      0

#define LWE297_ALU_DATA_WE_R8_LO_ROW                      0

#define LWE297_ALU_DATA_WE_R8_HI_ROW                      0

#define LWE297_ALU_DATA_WE_R9_LO_ROW                      0

#define LWE297_ALU_DATA_WE_R9_HI_ROW                      0

#define LWE297_ALU_DATA_WE_R10_LO_ROW                     0

#define LWE297_ALU_DATA_WE_R10_HI_ROW                     0

#define LWE297_ALU_DATA_WE_R11_LO_ROW                     0

#define LWE297_ALU_DATA_WE_R11_HI_ROW                     0

#define LWE297_ALU_DATA_WE_R12_LO_ROW                     0

#define LWE297_ALU_DATA_WE_R12_HI_ROW                     0

#define LWE297_ALU_DATA_WE_R13_LO_ROW                     0

#define LWE297_ALU_DATA_WE_R13_HI_ROW                     0

#define LWE297_ALU_DATA_WE_R14_LO_ROW                     0

#define LWE297_ALU_DATA_WE_R14_HI_ROW                     0

#define LWE297_ALU_DATA_WE_R15_LO_ROW                     0

#define LWE297_ALU_DATA_WE_R15_HI_ROW                     0

#define LWE297_ALU_DATA_WE_S0_LO_ROW                      0

#define LWE297_ALU_DATA_WE_S0_HI_ROW                      0

#define LWE297_ALU_DATA_WE_S1_LO_ROW                      0

#define LWE297_ALU_DATA_WE_S1_HI_ROW                      0

#define LWE297_ALU_DATA_WE_S2_LO_ROW                      0

#define LWE297_ALU_DATA_WE_S2_HI_ROW                      0

#define LWE297_ALU_DATA_WE_S3_LO_ROW                      0

#define LWE297_ALU_DATA_WE_S3_HI_ROW                      0

#define LWE297_ALU_DATA_WE_S4_LO_ROW                      0

#define LWE297_ALU_DATA_WE_S4_HI_ROW                      0

#define LWE297_ALU_DATA_WE_S5_LO_ROW                      0

#define LWE297_ALU_DATA_WE_S5_HI_ROW                      0

#define LWE297_ALU_DATA_WE_S6_LO_ROW                      0

#define LWE297_ALU_DATA_WE_S6_HI_ROW                      0

#define LWE297_ALU_DATA_WE_S7_LO_ROW                      0

#define LWE297_ALU_DATA_WE_S7_HI_ROW                      0

#define LWE297_ALU_DATA_WE_G0_LO_ROW                      0

#define LWE297_ALU_DATA_WE_G0_HI_ROW                      0

#define LWE297_ALU_DATA_WE_G1_LO_ROW                      0

#define LWE297_ALU_DATA_WE_G1_HI_ROW                      0

#define LWE297_ALU_DATA_WE_G2_LO_ROW                      0

#define LWE297_ALU_DATA_WE_G2_HI_ROW                      0

#define LWE297_ALU_DATA_WE_G3_LO_ROW                      0

#define LWE297_ALU_DATA_WE_G3_HI_ROW                      0

#define LWE297_ALU_DATA_WE_G4_LO_ROW                      0

#define LWE297_ALU_DATA_WE_G4_HI_ROW                      0

#define LWE297_ALU_DATA_WE_G5_LO_ROW                      0

#define LWE297_ALU_DATA_WE_G5_HI_ROW                      0

#define LWE297_ALU_DATA_WE_G6_LO_ROW                      0

#define LWE297_ALU_DATA_WE_G6_HI_ROW                      0

#define LWE297_ALU_DATA_WE_G7_LO_ROW                      0

#define LWE297_ALU_DATA_WE_G7_HI_ROW                      0

#define LWE297_ALU_DATA_WE_P0_ROW                 0

#define LWE297_ALU_DATA_WE_P1_ROW                 0

#define LWE297_ALU_DATA_WE_P2_ROW                 0

#define LWE297_ALU_DATA_WE_P3_ROW                 0

#define LWE297_ALU_DATA_WE_P4_ROW                 0

#define LWE297_ALU_DATA_WE_P5_ROW                 0

#define LWE297_ALU_DATA_WE_P6_ROW                 0

#define LWE297_ALU_DATA_WE_P7_ROW                 0

#define LWE297_ALU_DATA_WE_P8_ROW                 0

#define LWE297_ALU_DATA_WE_P9_ROW                 0

#define LWE297_ALU_DATA_WE_P10_ROW                        0

#define LWE297_ALU_DATA_WE_P11_ROW                        0

#define LWE297_ALU_DATA_WE_P12_ROW                        0

#define LWE297_ALU_DATA_WE_P13_ROW                        0

#define LWE297_ALU_DATA_WE_P14_ROW                        0

#define LWE297_ALU_DATA_WE_P15_ROW                        0

#define LWE297_ALU_DATA_WE_KC_ROW                 0

#define LWE297_ALU_DATA_WE_R0_15_ROW                      0

#define LWE297_ALU_DATA_WE_S0_7_ROW                       0

// --------------------------------------------------------------------------
// 
// Copyright (c) 2004, LWPU Corp.
// All Rights Reserved.
// 
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of LWPU Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of LWPU Corp.
// 
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
// 
// --------------------------------------------------------------------------
// 
// LWE297_dw.spec
//
// OVERVIEW:
// --------------------------------------
// DWR lives at the end of the pixel pipe before recirlwlating to pseq
//
// DWR uses the instruction indexed by the pixel's sequence number to
// decide whether components of that row should be written to memory.
//
// DITHERING:
// --------------------------------------
// None of the 8b components undergoes dithering on write.
// Alpha, even if in reduced precision, never gets dithered.
// The RGB components with less than 8b of precision get dithered on
// write if the surface has the DITHER bit set in the SURFDESC
// register
//
// The exact dithering algorithm is specified in LWE297_pixelpath.spec.
// INST -- dwr instruction table
//
// OP -- Opcode.  No operation is performed if one of the following is true:
//   * OP is NOP
//   * CX bit of the pixel packet is NO_EXELWTE
//   * The ST_ENABLE field selected by CONDITION_SELECT ENABLE is set to DISABLE 
//   Otherwize ST, ST_R20, or ST_R80 will perform memory stores.
//
// SURF -- Surface index.  Indexes into SURFADDR and SURFDESC tables
//
// WRITE_KILLED -- If enabled pixels are written even if not in Z_PASS state
//                  This include S_FAIL Z_FAIL, NON_CENTER, KILL states.
//
// WRITE_NON_CENTER -- If enabled pixels are written even if in NON_CENTER state
//
// ARGS -- Opcode specific fields; described below.
//
//
// ST:  --non-register store
// Data is written to memory according to certain rules 
// controlled by the SURFACE_DESCRIPTOR.  The format is defined by the
// type field of the SURFACE_DESCRIPTOR.
// Supported formats: (S=stencil, C=coverage/predicate,
//                     L=luminance, A=alpha, B=blue, G=green, R=red, 
//                     Z=depth, P=pixel_packet)
//  8 bpp:  L8, A8, B2G3R3, S8, C4X4
// 16 bpp:  L8A8, B5G6R5, A1B5G5R5, B5G5R5A1, A4B4G4R4, B4G4R4A4, Z16, Z16NL
//          A16_float, L16_float
// 32 bpp: R8G8B8A8, B8G8R8A8, L16A16_float, R11G11B10_float
// 64 bpp: R16G16B16A16_float, 
//
// Not Supported: DXT1, DXT1C, DXT3, DXT5, ETC, ETC3, ETC5, LATC1, LATC2,
//                R10G10B10_float_A2, B8G8R8G8, G8B8G8R8
//
// The data from the store comes from the pixel register starting from R0 
// except for a few special cases (alpha, depth).  All formats except
// Z, S, C and _float formats will preform logic op after colwersion to output
// format if LOP_EN == ENABLE.
// Logic op is described in detail below. The raw destination color for LOP
// is sourced from R2R3
//
// If UPPER is set, the sources R0R1 and R2R3 are swapped.  For example: logic op
// raw will come from R2R3, and most pixel formats will start from R2.
//
// Format      Source  Dest_Format   Description
// L8          R0.L    bits ( 7: 0)  Luminance
//
// A8          R1.H    bits ( 7: 0)  Alpha
//
// B2G3R3      R0.L    bits ( 7: 5)  Red
//             R0.H    bits ( 4: 2)  Green
//             R1.L    bits ( 1: 0)  Blue
//
// S8          R0.L    bits ( 7: 0)  Stencil -- If this format is selected
//                                         and STENCIL_EN == ENABLE then 
//                                         stencil op is performed as
//                                         described below.
//
// C4X4        P0..P3  bits ( 3: 0)  Predicate bits
//                     bits ( 7: 4)  Padding
//
// L8A8        R0.L    bits ( 7: 0)  Luminance
//             R1.H    bits (15: 8)  Alpha
//
// B5G6R5      R0.L    bits (15:11)  Red
//             R0.H    bits (10: 5)  Green
//             R1.L    bits ( 4: 0)  Blue
//
// A1B5G5R5    R0.L    bits (15:11)  Red
//             R0.H    bits (10: 6)  Green
//             R1.L    bits ( 5: 1)  Blue
//             R1.H    bits ( 0: 0)  Alpha
//
// B5G5R5A1    R0.L    bits (14:10)  Red
//             R0.H    bits ( 9: 5)  Green
//             R1.L    bits ( 4: 0)  Blue
//             R1.H    bits (15:15)  Alpha
//
// A4B4G4R4    R0.L    bits (15:12)  Red
//             R0.H    bits (11: 8)  Green
//             R1.L    bits ( 7: 4)  Blue
//             R1.H    bits ( 3: 0)  Alpha
//
// B4G4R4A4    R0.L    bits (11: 8)  Red
//             R0.H    bits ( 7: 4)  Green
//             R1.L    bits ( 3: 0)  Blue
//             R1.H    bits (15:12)  Alpha
//
// Z16         R3      bits (15: 0)  Depth
// 
// Z16NL       R3      bits (15: 0)  Non-Linear Depth
//
// L16_float   R0      bits (15: 0)  Luminance
//
// A16_float   R1      bits (15: 0)  Alpha
//
// B8G8R8A8    R0.L    bits (23:16)  Red
//             R0.H    bits (15: 8)  Green
//             R1.L    bits ( 7: 0)  Blue
//             R1.H    bits (31:24)  Alpha
//
// R8G8B8A8    R0.L    bits ( 7: 0)  Red
//             R0.H    bits (15: 8)  Green
//             R1.L    bits (23:16)  Blue
//             R1.H    bits (31:24)  Alpha
//
// L16A16_float
//             R0      bits (15: 0)  Luminance
//             R1      bits (31:16)  Alpha
//
// R11G11B10_float
//             R0      bits (10: 0)  Red
//             R1      bits (21:11)  Green 
//             R2      bits (31:22)  Blue
// 
// R16G16B16A16_float
//             R0      bits (15: 0)  Red
//             R1      bits (31:16)  Green 
//             R2      bits (47:32)  Blue
//             R3      bits (63:48)  Alpha
//
// CONDITION_SELECT -- Selects which ST_ENABLE field can disable the ST
//
// If the ST instruction's CONDITION_SELECT field is set to:
//   * ALWAYS        -- the ST will ignore this register
//   * Z_WRITE       -- the ST will be disabled if 
//                      ((Z_TEST == DISABLE) 
//                       || (SURFACES_ENABLE[INST_DATA_SURF] == DISABLE))
//   * SURFACE_WRITE -- the ST will be disabled if 
//                            SURFACES_ENABLE[INST_DATA_SURF] == DISABLE
//
//
// ST_R20: 20 bit register store
// This opcode indicates a register store operation.  The only supported formats
// are P32_float and P128
//
// P32_float   R#.L    bits ( 9:   0) 
//             R#.H    bits ( 25: 16) 
//
// Pick byte enables set for one of RA, RB, RC, RD.  The rest are 
// disabled. RA, RB, RC, RD are selected by the lower two bits of the offset
// P128        R#.L    bits ( 9:   0)  RA.L  
//             R#.H    bits ( 25: 16)  RA.H 
//             R#.L    bits ( 41: 32)  RB.L
//             R#.H    bits ( 57: 48)  RB.H
//             R#.L    bits ( 73: 64)  RC.L
//             R#.H    bits ( 89: 80)  RC.H
//             R#.L    bits (105: 96)  RD.L
//             R#.H    bits (121:112)  RD.H
//
// REG selects which FP20 register will be stored
//
//
// OFFSET_REG_EN  select between OFFSET_IMM and OFFSET_REG for array index.
//
// OFFSET_IMM  If OFFSET_REG_EN == DISABLE then the OFFSET_IMM field is used
// to index into the register array
//
// OFFSET_REG, OFFSET_MOD -- If OFSET_REG_EN == ENABLE then the value in the
// selected 10 bit register is used to index into the register array 
//
// OFFSET_TYPE -- Selects between GLOBAL and LOCAL register store access.
// GLOBAL is shared by all pixels, LOCAL is unique to each pixel in the pipe
//
//
//
// ST_R80: 80 bit register store
// This opcode indicates a register store operation.  The only supported format
// is P128
//
// P128        R0.L    bits ( 9: 0)
//             R0.H    bits (25:16)
//             R1.L    bits (41:32)
//             R1.H    bits (57:48)
//             R2.L    bits (73:64)
//             R2.H    bits (89:80)
//             R3.L    bits (104:96)
//             R3.H    bits (112:121)
//
//
// OFFSET_REG_EN  select between OFFSET_IMM and OFFSET_REG for array index.
//
// OFFSET_IMM  If OFFSET_REG_EN == DISABLE then the OFFSET_IMM field is used
// to index into the register array
//
// OFFSET_REG, OFFSET_MOD -- If OFSET_REG_EN == ENABLE then the value in the
// selected 10 bit register is used to index into the register array 
//
// OFFSET_TYPE -- Selects between GLOBAL and LOCAL register store access.
// GLOBAL is shared by all pixels, LOCAL is unique to each pixel in the pipe
//
//
// GLOBAL register address is determined by 
//     SURFADDR + offset * bpp
// LOCAL register address is determined by 
//     SURFADDR + offset * bpp + pixelhash(x,y) * bpp 

// Packet ST_ARGS
#define ST_ARGS_SIZE 16

//Perform stencil op on stencil value before writing
#define ST_ARGS_STENCIL_EN_ROW                  0
#define ST_ARGS_STENCIL_EN_DISABLE                      0x00000000
#define ST_ARGS_STENCIL_EN_ENABLE                       0x00000001

// Perform logic op on color after dither
// but before writing
#define ST_ARGS_LOP_EN_ROW                      0
#define ST_ARGS_LOP_EN_DISABLE                  0x00000000
#define ST_ARGS_LOP_EN_ENABLE                   0x00000001

// select colors starting from R2 instead of R0
// this wraps, so inputs that were R0R1R2R3 will
// now be R2R3R0R1
#define ST_ARGS_UPPER_ROW                       0

// which ST_ENABLE to use when deciding to store
// or not.
#define ST_ARGS_CONDITION_SELECT_ROW                    0
#define ST_ARGS_CONDITION_SELECT_ALWAYS                 0x00000000
#define ST_ARGS_CONDITION_SELECT_Z_WRITE                        0x00000001
#define ST_ARGS_CONDITION_SELECT_SURFACE_WRITE                  0x00000002

#define ST_ARGS_RESERVED_ROW                    0


// Packet ST_R20_ARGS
#define ST_R20_ARGS_SIZE 16

// Which FP20 register to store
#define ST_R20_ARGS_REG_ROW                     0
#define ST_R20_ARGS_REG_R0                      0x00000000
#define ST_R20_ARGS_REG_R1                      0x00000001
#define ST_R20_ARGS_REG_R2                      0x00000002
#define ST_R20_ARGS_REG_R3                      0x00000003

// Which FX10 halves to store

// offset -- used for array formats, 
//           index into the array if
//           OFFSET_REG_EN == DISABLE
#define ST_R20_ARGS_OFFSET_IMM_ROW                      0

// which register contains the 8 bit offset
#define ST_R20_ARGS_OFFSET_REG_ROW                      0
#define ST_R20_ARGS_OFFSET_REG_R0                       0x00000000
#define ST_R20_ARGS_OFFSET_REG_R1                       0x00000001
#define ST_R20_ARGS_OFFSET_REG_R2                       0x00000002
#define ST_R20_ARGS_OFFSET_REG_R3                       0x00000003

// which half word contains the 8 bit offset
#define ST_R20_ARGS_OFFSET_MOD_ROW                      0
#define ST_R20_ARGS_OFFSET_MOD_L                        0x00000000
#define ST_R20_ARGS_OFFSET_MOD_H                        0x00000001

// enable offset reg
#define ST_R20_ARGS_OFFSET_REG_EN_ROW                   0
#define ST_R20_ARGS_OFFSET_REG_EN_DISABLE                       0x00000000
#define ST_R20_ARGS_OFFSET_REG_EN_ENABLE                        0x00000001

// Is the offset a local offset or global offset
// a local offset uses x,y,offset to determine
// address, a global offset just uses offset.
#define ST_R20_ARGS_OFFSET_TYPE_ROW                     0
#define ST_R20_ARGS_OFFSET_TYPE_LOCAL                   0x00000000
#define ST_R20_ARGS_OFFSET_TYPE_GLOBAL                  0x00000001


// Packet ST_R80_ARGS
#define ST_R80_ARGS_SIZE 16

// Which FX10 registers to store

// offset -- used for array formats, 
//          index into the array if
//          OFFSET_REG_EN == DISABLE
#define ST_R80_ARGS_OFFSET_IMM_ROW                      0

// which register contains the 8 bit offset
#define ST_R80_ARGS_OFFSET_REG_ROW                      0
#define ST_R80_ARGS_OFFSET_REG_R0                       0x00000000
#define ST_R80_ARGS_OFFSET_REG_R1                       0x00000001
#define ST_R80_ARGS_OFFSET_REG_R2                       0x00000002
#define ST_R80_ARGS_OFFSET_REG_R3                       0x00000003

// which half word contains the 8 bit offset
#define ST_R80_ARGS_OFFSET_MOD_ROW                      0
#define ST_R80_ARGS_OFFSET_MOD_L                        0x00000000
#define ST_R80_ARGS_OFFSET_MOD_H                        0x00000001

// enable offset reg
#define ST_R80_ARGS_OFFSET_REG_EN_ROW                   0
#define ST_R80_ARGS_OFFSET_REG_EN_DISABLE                       0x00000000
#define ST_R80_ARGS_OFFSET_REG_EN_ENABLE                        0x00000001

//Is the offset a local offset or global offset
//a local offset uses x,y,offset to determine
//address, a global offset just uses offset.
#define ST_R80_ARGS_OFFSET_TYPE_ROW                     0
#define ST_R80_ARGS_OFFSET_TYPE_LOCAL                   0x00000000
#define ST_R80_ARGS_OFFSET_TYPE_GLOBAL                  0x00000001

//
// Instruction table offset: controls what indirect entry in the instruction table gets accessed.
// INDEX auto-increments with each access to INST_DATA.
//

// Register LWE297_DW_INST_OFFSET_0  
#define LWE297_DW_INST_OFFSET_0                             0x900
// current read or write target in INST_DATA
#define LWE297_DW_INST_OFFSET_0_INDEX                              5:0

//
// Instruction indirect port.
//

// Register LWE297_DW_INST_DATA_0  // INST_DATA is indexed by INST_OFFSET, and will increment INST_OFFSET
// on reads or writes
//
#define LWE297_DW_INST_DATA_0                               0x901
// Opcode values can be:
// NOP     -- no store is performed
// ST      -- normal store to memory
// ST_R20  -- store a FP20 and C to memory
// ST_R80 -- store a FX10x8 to memory
#define LWE297_DW_INST_DATA_0_OP                           1:0
#define LWE297_DW_INST_DATA_0_OP_NOP                      0x00000000
#define LWE297_DW_INST_DATA_0_OP_ST                       0x00000001
#define LWE297_DW_INST_DATA_0_OP_ST_R20                   0x00000002
#define LWE297_DW_INST_DATA_0_OP_ST_R80                   0x00000003

// Specifies which surface descriptor to use
#define LWE297_DW_INST_DATA_0_SURF                         5:2

// If ENABLED write pixel even if not in Z_PASS state.
#define LWE297_DW_INST_DATA_0_WRITE_KILLED                         6:6
#define LWE297_DW_INST_DATA_0_WRITE_KILLED_DISABLE                        0x00000000
#define LWE297_DW_INST_DATA_0_WRITE_KILLED_ENABLE                 0x00000001

// If ENABLED write pixel even if in NON_CENTER state.
#define LWE297_DW_INST_DATA_0_WRITE_NON_CENTER                             7:7
#define LWE297_DW_INST_DATA_0_WRITE_NON_CENTER_DISABLE                    0x00000000
#define LWE297_DW_INST_DATA_0_WRITE_NON_CENTER_ENABLE                     0x00000001

// Should FDC try to hold on to this data
#define LWE297_DW_INST_DATA_0_CACHE_PERSISTENT                             8:8

// Should FDC throw away this data on read
#define LWE297_DW_INST_DATA_0_CACHE_READ_CLEAN                             9:9

// Arguments for opcode
// (ST_ARGS, ST_R20_ARGS, or ST_R80_ARGS)
#define LWE297_DW_INST_DATA_0_ARGS                         25:10

// all the fragment op control goes here (s=source, d=destination).  The result
// of these ops are written to the callwlated memory location (based on x,y and
// SURFDESC) m=mem[calcaddr] d=R0.l.
// KEEP        m = d
// ZERO        m = 0
// REPLACE     m = ref
// INCR        m = sat(d+1)
// DECR        m = sat(d-1)
// ILWERT      m = ~d
// INCR_WRAP   m = wrap(d+1)
// DECR_WRAP   m = wrap(d-1)
//
// logic op: (m=mem[calcaddr], s=formatcolwert(R0R1), d=raw(R2R3)
// CLEAR                  m = all bits cleared (0)
// AND                    m = s & d
// AND_REVERSE    m = s & ~d
// COPY                   m = s
// AND_ILWERTED   m = ~s & d
// NOOP                   m = d
// XOR                    m = s ^ d
// OR                     m = s | d
// NOR                    m = ~(s | d)
// EQUIV                  m = ~(s ^ d)
// ILWERT                 m = ~d
// OR_REVERSE     m = s | ~d
// COPY_ILWERTED  m = ~s
// OR_ILWERTED    m = ~s | d
// NAND                   m = ~(s & d)
// SET                    m = all bits set (0xffffffff)
// See S_OPERATION for stencil op details

// Register LWE297_DW_LOGIC_OP_0  
#define LWE297_DW_LOGIC_OP_0                                0x902
// logic op (always operates with R0R1 as source (s) 
// and R2R3 as destination (d))
#define LWE297_DW_LOGIC_OP_0_OP                            3:0
#define LWE297_DW_LOGIC_OP_0_OP_CLEAR                     0x00000000
#define LWE297_DW_LOGIC_OP_0_OP_AND                       0x00000001
#define LWE297_DW_LOGIC_OP_0_OP_AND_REVERSE                       0x00000002
#define LWE297_DW_LOGIC_OP_0_OP_COPY                      0x00000003
#define LWE297_DW_LOGIC_OP_0_OP_AND_ILWERTED                      0x00000004
#define LWE297_DW_LOGIC_OP_0_OP_NOOP                      0x00000005
#define LWE297_DW_LOGIC_OP_0_OP_XOR                       0x00000006
#define LWE297_DW_LOGIC_OP_0_OP_OR                        0x00000007
#define LWE297_DW_LOGIC_OP_0_OP_NOR                       0x00000008
#define LWE297_DW_LOGIC_OP_0_OP_EQUIV                     0x00000009
#define LWE297_DW_LOGIC_OP_0_OP_ILWERT                    0x0000000a
#define LWE297_DW_LOGIC_OP_0_OP_OR_REVERSE                        0x0000000b
#define LWE297_DW_LOGIC_OP_0_OP_COPY_ILWERTED                     0x0000000c
#define LWE297_DW_LOGIC_OP_0_OP_OR_ILWERTED                       0x0000000d
#define LWE297_DW_LOGIC_OP_0_OP_NAND                      0x0000000e
#define LWE297_DW_LOGIC_OP_0_OP_SET                       0x0000000f

// ST_ENABLE enables/disables properly flagged ST instructions
//
// If the ST instruction's CONDITION_SELECT field is set to:
//   * ALWAYS        -- the ST will ignore this register
//   * Z_WRITE       -- the ST will be disabled if 
//                      ((Z_TEST == DISABLE) 
//                       || (SURFACES_ENABLE[INST_DATA_SURF] == DISABLE))
//   * SURFACE_WRITE -- the ST will be disabled if 
//                            SURFACES_ENABLE[INST_DATA_SURF] == DISABLE

// Register LWE297_DW_ST_ENABLE_0  
#define LWE297_DW_ST_ENABLE_0                               0x903
#define LWE297_DW_ST_ENABLE_0_SURFACE_0_ST_ENABLE                          0:0
#define LWE297_DW_ST_ENABLE_0_SURFACE_0_ST_ENABLE_DISABLE                 0x00000000
#define LWE297_DW_ST_ENABLE_0_SURFACE_0_ST_ENABLE_ENABLE                  0x00000001

#define LWE297_DW_ST_ENABLE_0_SURFACE_1_ST_ENABLE                          1:1
#define LWE297_DW_ST_ENABLE_0_SURFACE_1_ST_ENABLE_DISABLE                 0x00000000
#define LWE297_DW_ST_ENABLE_0_SURFACE_1_ST_ENABLE_ENABLE                  0x00000001

#define LWE297_DW_ST_ENABLE_0_SURFACE_2_ST_ENABLE                          2:2
#define LWE297_DW_ST_ENABLE_0_SURFACE_2_ST_ENABLE_DISABLE                 0x00000000
#define LWE297_DW_ST_ENABLE_0_SURFACE_2_ST_ENABLE_ENABLE                  0x00000001

#define LWE297_DW_ST_ENABLE_0_SURFACE_3_ST_ENABLE                          3:3
#define LWE297_DW_ST_ENABLE_0_SURFACE_3_ST_ENABLE_DISABLE                 0x00000000
#define LWE297_DW_ST_ENABLE_0_SURFACE_3_ST_ENABLE_ENABLE                  0x00000001

#define LWE297_DW_ST_ENABLE_0_SURFACE_4_ST_ENABLE                          4:4
#define LWE297_DW_ST_ENABLE_0_SURFACE_4_ST_ENABLE_DISABLE                 0x00000000
#define LWE297_DW_ST_ENABLE_0_SURFACE_4_ST_ENABLE_ENABLE                  0x00000001

#define LWE297_DW_ST_ENABLE_0_SURFACE_5_ST_ENABLE                          5:5
#define LWE297_DW_ST_ENABLE_0_SURFACE_5_ST_ENABLE_DISABLE                 0x00000000
#define LWE297_DW_ST_ENABLE_0_SURFACE_5_ST_ENABLE_ENABLE                  0x00000001

#define LWE297_DW_ST_ENABLE_0_SURFACE_6_ST_ENABLE                          6:6
#define LWE297_DW_ST_ENABLE_0_SURFACE_6_ST_ENABLE_DISABLE                 0x00000000
#define LWE297_DW_ST_ENABLE_0_SURFACE_6_ST_ENABLE_ENABLE                  0x00000001

#define LWE297_DW_ST_ENABLE_0_SURFACE_7_ST_ENABLE                          7:7
#define LWE297_DW_ST_ENABLE_0_SURFACE_7_ST_ENABLE_DISABLE                 0x00000000
#define LWE297_DW_ST_ENABLE_0_SURFACE_7_ST_ENABLE_ENABLE                  0x00000001

#define LWE297_DW_ST_ENABLE_0_SURFACE_8_ST_ENABLE                          8:8
#define LWE297_DW_ST_ENABLE_0_SURFACE_8_ST_ENABLE_DISABLE                 0x00000000
#define LWE297_DW_ST_ENABLE_0_SURFACE_8_ST_ENABLE_ENABLE                  0x00000001

#define LWE297_DW_ST_ENABLE_0_SURFACE_9_ST_ENABLE                          9:9
#define LWE297_DW_ST_ENABLE_0_SURFACE_9_ST_ENABLE_DISABLE                 0x00000000
#define LWE297_DW_ST_ENABLE_0_SURFACE_9_ST_ENABLE_ENABLE                  0x00000001

#define LWE297_DW_ST_ENABLE_0_SURFACE_10_ST_ENABLE                         10:10
#define LWE297_DW_ST_ENABLE_0_SURFACE_10_ST_ENABLE_DISABLE                        0x00000000
#define LWE297_DW_ST_ENABLE_0_SURFACE_10_ST_ENABLE_ENABLE                 0x00000001

#define LWE297_DW_ST_ENABLE_0_SURFACE_11_ST_ENABLE                         11:11
#define LWE297_DW_ST_ENABLE_0_SURFACE_11_ST_ENABLE_DISABLE                        0x00000000
#define LWE297_DW_ST_ENABLE_0_SURFACE_11_ST_ENABLE_ENABLE                 0x00000001

#define LWE297_DW_ST_ENABLE_0_SURFACE_12_ST_ENABLE                         12:12
#define LWE297_DW_ST_ENABLE_0_SURFACE_12_ST_ENABLE_DISABLE                        0x00000000
#define LWE297_DW_ST_ENABLE_0_SURFACE_12_ST_ENABLE_ENABLE                 0x00000001

#define LWE297_DW_ST_ENABLE_0_SURFACE_13_ST_ENABLE                         13:13
#define LWE297_DW_ST_ENABLE_0_SURFACE_13_ST_ENABLE_DISABLE                        0x00000000
#define LWE297_DW_ST_ENABLE_0_SURFACE_13_ST_ENABLE_ENABLE                 0x00000001

#define LWE297_DW_ST_ENABLE_0_SURFACE_14_ST_ENABLE                         14:14
#define LWE297_DW_ST_ENABLE_0_SURFACE_14_ST_ENABLE_DISABLE                        0x00000000
#define LWE297_DW_ST_ENABLE_0_SURFACE_14_ST_ENABLE_ENABLE                 0x00000001

#define LWE297_DW_ST_ENABLE_0_SURFACE_15_ST_ENABLE                         15:15
#define LWE297_DW_ST_ENABLE_0_SURFACE_15_ST_ENABLE_DISABLE                        0x00000000
#define LWE297_DW_ST_ENABLE_0_SURFACE_15_ST_ENABLE_ENABLE                 0x00000001

#define LWE297_DW_ST_ENABLE_0_SURFACES_ENABLE                              15:0

// can disable ST with 
// CONDITION_SELECT == Z_WRITE
#define LWE297_DW_ST_ENABLE_0_Z_TEST                               16:16
#define LWE297_DW_ST_ENABLE_0_Z_TEST_DISABLE                      0x00000000
#define LWE297_DW_ST_ENABLE_0_Z_TEST_ENABLE                       0x00000001

// --------------------------------------------------------------------------
//
// Copyright (c) 2005, LWPU Corp.
// All Rights Reserved.
//
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of LWPU Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of LWPU Corp.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
//
// --------------------------------------------------------------------------
// 
// This file has all the reg definitions related to FDC unit in AR20
// This file is included by ar3d.spec
// --------------------------------------------------------------------------
// FDC notes:
//
// - FDC is a unified cache for the 3D QRAST, PSEQ, and DWR clients.
// Each read and write client has multiple 64-bit L1 latency-hiding
// buffers, and the L2 cache is a fully associative, 64 line x 256 bit =
// 2 KByte write-back cache that has tags based on the GPU address. 
// - FDC register accesses are received through the QRAST interface and
// are immediately updated even if there are outstanding FDC transactions
// later in the pipe (such as PSEQ/DWR). Thus changing FDC registers may
// have an affect on operations that entered the 3D pipe before the FDC
// register operation. Changing FDC registers is generally okay during 
// a non-idle 3D pipe, with exceptions noted in the register definitions.
// - FDC will flush the cache to MC in the background, and do a full flush
// when a Raise is received by DWR, or is the FLUSH register field is set.
//
// --------------------------------------------------------------------------
//
// register definitions
//
#define LW_FDC_MAX_LINES_CNT_WIDTH      9
//
// Main control register for FDC, notes:
//   flush: Note that fdc is auto-flushed on a gr3d raise/wait when
//          dwr receives the raise, and dwr will not release the raise
//          until the flush has completed. This register is provided
//          as an alternative way to flush the fdc cache without using
//          a raise/wait. The flush bit will be auto-reset to 0 after
//          flush is complete so sw can poll this register to determine
//          when the flush is complete. The 3d pipe should be idle before
//          writing to this flush register. The reason is that fdc will
//          receive the register write at its qrast ports, but fdc does not
//          know whether dwr is active or idle, so dwr may still be
//          writing when fdc does the flush. If the 3d pipe is not idle,
//          Fdc still guarantees correctness (ie, no data will be dropped
//          or corrupted), but there is no guarantee on whether active
//          dwr writes made it in before the flush and will be flushed to
//          memory or whether they are too late and will remain dirty
//          in the cache.
//
//   ilwalidate: the pipeline MUST be idle before ilwalidating the fdc
//               cache, otherwise corruption/hw freeze can occur
//               The proper way to ilwalidate the cache is:
//                 (1) issue raise/wait to idle pipeline (which also forces a flush)
//                 (2) write 1 to CONTROL.ILWALIDATE
//                 (3) issue raise/wait to ensure reads don't get into
//                     pipeline before fdc receives ilwalidate request
//
// Programming note regarding fdc buffer synchronization:
// (1) if fdc is only reading from a buffer that another (non-fdc) unit needs 
//     to write to, then fdc should be idle while the other unit is writing,
//     and fdc must be ilwalidated before starting to read the modified buffer   
// (2) if fdc is only writing to a buffer that another (non-fdc) unit needs to
//     read from, then fdc must be flushed before the other unit starts reading
//     from the buffer, and fdc should be idle while the other unit is reading
// (3) if fdc is reading from and writing to a buffer that another (non-fdc)
//     unit needs to access to, then fdc should be flushed, then the other unit
//     can begin accessing the buffer while fdc remains idle, and after the 
//     other unit is done accessing the buffer, fdc must be ilwalidated.
//

// Register LWE297_FDC_CONTROL_0  // FDC Main Control Register
#define LWE297_FDC_CONTROL_0                                0xa00
// ilwalidate entire cache, auto-reset to 0 when complete
#define LWE297_FDC_CONTROL_0_ILWALIDATE                            0:0

// flush entire cache, auto-reset to zero when complete
#define LWE297_FDC_CONTROL_0_FLUSH                         1:1

// keep request interface arbitration between QRAST z and
// stencil+vcaa in strict order 
#define LWE297_FDC_CONTROL_0_STRICT_RI_ARB                         2:2

// keep L2 arbitration between QRAST z and stencil+vcaa 
// in strict order
#define LWE297_FDC_CONTROL_0_STRICT_L2_ARB                         3:3

// disable auto flush feature
#define LWE297_FDC_CONTROL_0_DISABLE_AUTO_FLUSH                            4:4

// command to clear persistent bits
// of all cache lines
#define LWE297_FDC_CONTROL_0_PERSISTENT_CLEAR                              5:5

// If set to 1, memory reads have absolute priority
// when writing data to L2. 
// If set to 0, ping-pong arbitration between memory
// reads writing to L2 client writing to L2 applies.
#define LWE297_FDC_CONTROL_0_STRICT_MC_WR_ARB                              6:6

// causes fdc to ignore the persistent attribute
// of all client requests (everything marked as
// non-persistent)
#define LWE297_FDC_CONTROL_0_DISABLE_PERSISTENT                            7:7

// causes fdc to ignore the read_clean attribute
// of all client requests (everything marked as 
// non-read_clean)
#define LWE297_FDC_CONTROL_0_DISABLE_READ_CLEAN                            8:8

// keep request interface arbitration between PSEQ/DWR and
// QRAST clients in strict order 
#define LWE297_FDC_CONTROL_0_STRICT_DP_Q_RI_ARB                            9:9

// FDC MCCIF client assignment. This bit controls whether FDC
// splits MC accesses between MCCIFs according to their
// destination or according to the which memory bank is being
// accessed EXT_INT:  Internal/External memory
// EVEN_ODD: Even/Odd memory accesses 
#define LWE297_FDC_CONTROL_0_MCCIF_PORT_ASSIGN                             10:10
#define LWE297_FDC_CONTROL_0_MCCIF_PORT_ASSIGN_INIT_ENUM                  EVEN_ODD
#define LWE297_FDC_CONTROL_0_MCCIF_PORT_ASSIGN_EXT_INT                    0x00000000
#define LWE297_FDC_CONTROL_0_MCCIF_PORT_ASSIGN_EVEN_ODD                   0x00000001

// allow each read buffer to lock at least one cache line
// even if client hit max line count
#define LWE297_FDC_CONTROL_0_READ_BUF_MIN_LINE                             11:11

//
// status register
//

// Register LWE297_FDC_STATUS_0  // FDC Status Register
#define LWE297_FDC_STATUS_0                                 0xa01
// set when flush completed
#define LWE297_FDC_STATUS_0_FLUSH_DONE                             0:0

// csim simulation use only
// set to 1 when self-checking fdc csim
// code detects an error at shutdown
#define LWE297_FDC_STATUS_0_CSIM_SHUTDOWN_STATUS                           31:31

//
// Client max line counts
// - *_NO_SHADER_DEFAULT are used by sw to reprogram the max lines
//   registers when pseq is not active
//
#define LWE297_FDC_MAX_QZ_LINES_NO_SHADER_DEFAULT 511

// Register LWE297_FDC_MAX_QZ_LINES_0  // Maximum Line Count for QRAST Z Reads
#define LWE297_FDC_MAX_QZ_LINES_0                           0xa02
// max number of L2 cache lines allowed
// to be locked by qrast z 
#define LWE297_FDC_MAX_QZ_LINES_0_MAX_QZ_LINES                             8:0

#define LWE297_FDC_MAX_QV_LINES_NO_SHADER_DEFAULT 511

// Register LWE297_FDC_MAX_QV_LINES_0  // Maximum Line Count for QRAST VCAA Reads
#define LWE297_FDC_MAX_QV_LINES_0                           0xa03
// max number of L2 cache lines allowed
// to be locked by qrast vcaa
#define LWE297_FDC_MAX_QV_LINES_0_MAX_QV_LINES                             8:0

#define LWE297_FDC_MAX_QS_LINES_NO_SHADER_DEFAULT 511

// Register LWE297_FDC_MAX_QS_LINES_0  // Maximum Line Count for QRAST Stencil Reads
#define LWE297_FDC_MAX_QS_LINES_0                           0xa04
// max number of L2 cache lines allowed
// to be locked by qrast stencil
#define LWE297_FDC_MAX_QS_LINES_0_MAX_QS_LINES                             8:0

#define LWE297_FDC_MAX_PS_LINES_NO_SHADER_DEFAULT 48

// Register LWE297_FDC_MAX_PS_LINES_0  // Maximum Line Count for PSEQ Reads
#define LWE297_FDC_MAX_PS_LINES_0                           0xa05
// max number of L2 cache lines allowed
// to be locked by pseq
#define LWE297_FDC_MAX_PS_LINES_0_MAX_PS_LINES                             8:0

#define LWE297_FDC_MAX_Q_LINES_NO_SHADER_DEFAULT  48

// Register LWE297_FDC_MAX_Q_LINES_0  // Maximum Line Count for Combined QRAST Reads
#define LWE297_FDC_MAX_Q_LINES_0                            0xa06
// max number of L2 cache lines allowed
// to be locked by pseq
#define LWE297_FDC_MAX_Q_LINES_0_MAX_Q_LINES                               8:0

#define LWE297_FDC_MAX_Q_P_LINES_NO_SHADER_DEFAULT        48

// Register LWE297_FDC_MAX_Q_P_LINES_0  // Maximum Line Count for combines QRAST & PSEQ Reads
#define LWE297_FDC_MAX_Q_P_LINES_0                                  0xa07
// max number of L2 cache lines allowed
// to be locked by pseq
#define LWE297_FDC_MAX_Q_P_LINES_0_MAX_Q_P_LINES                           8:0


// Register LWE297_FDC_FLUSH_CTL_0  // FDC Flush Control
#define LWE297_FDC_FLUSH_CTL_0                              0xa08
#define LWE297_FDC_FLUSH_CTL_0_DISABLE_AGGRESSIVE_FLUSH1                           17:17

#define LWE297_FDC_FLUSH_CTL_0_DISABLE_AGGRESSIVE_FLUSH0                           16:16

// Defines for how long the L2 arbiter can stall Flush
// access to L2 
// automatic flush proceeds to the next dirty line.
#define LWE297_FDC_FLUSH_CTL_0_MAX_FLUSH_STALLS                            12:8

// Sets the number of clock cycles to wait before
// automatic flush proceeds to the next dirty line.
#define LWE297_FDC_FLUSH_CTL_0_AUTO_FLUSH_DELAY                            7:0

//      L1 input timeout
#define LW_FDC_L1_TIMEOUT_CNT_W 5

// Register LWE297_FDC_L1_TIMEOUT_0  // FDC L1 Coalescing Timeout Control
#define LWE297_FDC_L1_TIMEOUT_0                             0xa09
// Timeout (down)counter preset for dwr client
#define LWE297_FDC_L1_TIMEOUT_0_D_TIMEOUT                          28:24

// Timeout (down)counter preset for qrast write clients
#define LWE297_FDC_L1_TIMEOUT_0_QW_TIMEOUT                         20:16

// Timeout (down)counter preset for pseq client
#define LWE297_FDC_L1_TIMEOUT_0_P_TIMEOUT                          12:8

// Timeout (down)counter preset for qrast read clients
#define LWE297_FDC_L1_TIMEOUT_0_QR_TIMEOUT                         4:0


// Register LWE297_FDC_INSTRUMENT_0  // statistics enable method - gates stat collection for FDC
#define LWE297_FDC_INSTRUMENT_0                             0xa0a
// Enables Performance Monitoring
#define LWE297_FDC_INSTRUMENT_0_STAT_EN                            0:0

// Second-level clock enable override register
//
// This can override the 2nd level clock enables in case of malfunction.
// Only exposed to software when needed.
//

// Register LWE297_FDC_CLKEN_OVERRIDE_0  
#define LWE297_FDC_CLKEN_OVERRIDE_0                                 0xa0b
// Fine Grain override for the gr3dfdcclk
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDC_CLKEN_OVR                          0:0
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDC_CLKEN_OVR_INIT_ENUM                       CLK_GATED
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDC_CLKEN_OVR_CLK_GATED                       0x00000000
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDC_CLKEN_OVR_CLK_ALWAYS_ON                   0x00000001

// Fine Grain override for the gr3dfdcprclk
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCPR_CLKEN_OVR                        1:1
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCPR_CLKEN_OVR_INIT_ENUM                     CLK_GATED
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCPR_CLKEN_OVR_CLK_GATED                     0x00000000
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCPR_CLKEN_OVR_CLK_ALWAYS_ON                 0x00000001

// Fine Grain override for the gr3dfdczrclk
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCZR_CLKEN_OVR                        2:2
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCZR_CLKEN_OVR_INIT_ENUM                     CLK_GATED
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCZR_CLKEN_OVR_CLK_GATED                     0x00000000
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCZR_CLKEN_OVR_CLK_ALWAYS_ON                 0x00000001

// Fine Grain override for the gr3dfdcsrclk
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCSR_CLKEN_OVR                        3:3
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCSR_CLKEN_OVR_INIT_ENUM                     CLK_GATED
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCSR_CLKEN_OVR_CLK_GATED                     0x00000000
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCSR_CLKEN_OVR_CLK_ALWAYS_ON                 0x00000001

// Fine Grain override for the gr3dfdcvrclk
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCVR_CLKEN_OVR                        4:4
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCVR_CLKEN_OVR_INIT_ENUM                     CLK_GATED
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCVR_CLKEN_OVR_CLK_GATED                     0x00000000
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCVR_CLKEN_OVR_CLK_ALWAYS_ON                 0x00000001

// Fine Grain override for the gr3dfdcdwclk
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCDW_CLKEN_OVR                        5:5
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCDW_CLKEN_OVR_INIT_ENUM                     CLK_GATED
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCDW_CLKEN_OVR_CLK_GATED                     0x00000000
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCDW_CLKEN_OVR_CLK_ALWAYS_ON                 0x00000001

// Fine Grain override for the gr3dfdczwclk
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCZW_CLKEN_OVR                        6:6
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCZW_CLKEN_OVR_INIT_ENUM                     CLK_GATED
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCZW_CLKEN_OVR_CLK_GATED                     0x00000000
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCZW_CLKEN_OVR_CLK_ALWAYS_ON                 0x00000001

// Fine Grain override for the gr3dfdcswclk
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCSW_CLKEN_OVR                        7:7
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCSW_CLKEN_OVR_INIT_ENUM                     CLK_GATED
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCSW_CLKEN_OVR_CLK_GATED                     0x00000000
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCSW_CLKEN_OVR_CLK_ALWAYS_ON                 0x00000001

// Fine Grain override for the gr3dfdcvwclk
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCVW_CLKEN_OVR                        8:8
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCVW_CLKEN_OVR_INIT_ENUM                     CLK_GATED
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCVW_CLKEN_OVR_CLK_GATED                     0x00000000
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCVW_CLKEN_OVR_CLK_ALWAYS_ON                 0x00000001

// Fine Grain override for the gr3dfdcsbclk
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCSB_CLKEN_OVR                        9:9
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCSB_CLKEN_OVR_INIT_ENUM                     CLK_GATED
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCSB_CLKEN_OVR_CLK_GATED                     0x00000000
#define LWE297_FDC_CLKEN_OVERRIDE_0_FDCSB_CLKEN_OVR_CLK_ALWAYS_ON                 0x00000001

//
// Memory Client Interface Async Fifo Optimization Register
// This can only be changed while the pipeline is completely idle.
// Read-only instance.
//
// Memory Client Interface Fifo Control Register.
// The registers below allow to optimize the synchronization timing in
// the memory client asynchronous fifos. When they can be used depend on
// the client and memory controller clock ratio.
// Additionally, the RDMC_RDFAST/RDCL_RDFAST fields can increase power
// consumption if the asynchronous fifo is implemented as a real ram.
// There is no power impact on latch-based fifos. Flipflop-based fifos
// do not use these fields.
// See recommended settings below.
//
// !! IMPORTANT !!
// The register fields can only be changed when the memory client async
// fifos are empty.
//
// The register field ending with WRCL_MCLE2X (if any) can be set to improve
// async fifo synchronization on the write side by one client clock cycle if
// the memory controller clock frequency is less or equal to twice the client
// clock frequency:
//
//      mcclk_freq <= 2 * clientclk_freq
//
// The register field ending with WRMC_CLLE2X (if any) can be set to improve
// async fifo synchronization on the write side by one memory controller clock
// cycle if the client clock frequency is less or equal to twice the memory
// controller clock frequency:
//
//      clientclk_freq <= 2 * mcclk_freq
//
// The register field ending with RDMC_RDFAST (if any) can be set to improve async
// fifo synchronization on the read side by one memory controller clock cycle.
//
// !! WARNING !!
// RDMC_RDFAST can be used along with WRCL_MCLE2X only when:
//
//       mcclk_freq <= clientclk_freq
//
// The register field ending with RDCL_RDFAST (if any) can be set to improve async
// fifo synchronization on the read side by one client clock cycle.
//
// !! WARNING !!
// RDCL_RDFAST can be used along with WRMC_CLLE2X only when:
//
//       clientclk_freq <= mcclk_freq
//
// RECOMMENDED SETTINGS
// # Client writing to fifo, memory controller reading from fifo
// - mcclk_freq <= clientclk_freq
//     You can enable both RDMC_RDFAST and WRCL_CLLE2X. If one of the fifos is
//     a real ram and power is a concern, you should avoid enabling RDMC_RDFAST.
// - clientclk_freq < mcclk_freq <= 2 * clientclk_freq
//     You can enable RDMC_RDFAST or WRCL_MCLE2X, but because the client clock
//     is slower, you should enable only WRCL_MCLE2X.
// - 2 * clientclk_freq < mcclk_freq
//     You can only enable RDMC_RDFAST. If one of the fifos is a real ram and
//     power is a concern, you should avoid enabling RDMC_RDFAST.
//
// # Memory controller writing to fifo, client reading from fifo
// - clientclk_freq <= mcclk_freq
//     You can enable both RDCL_RDFAST and WRMC_CLLE2X. If one of the fifos is
//     a real ram and power is a concern, you should avoid enabling RDCL_RDFAST.
// - mcclk_freq < clientclk_freq <= 2 * mcclk_freq
//     You can enable RDCL_RDFAST or WRMC_CLLE2X, but because the memory controller
//     clock is slower, you should enable only WRMC_CLLE2X.
// - 2 * mcclk_freq < clientclk_freq
//     You can only enable RDCL_RDFAST. If one of the fifos is a real ram and
//     power is a concern, you should avoid enabling RDCL_RDFAST.
//

// Register LWE297_FDC_LW_MCCIF_FIFOCTRL_RO_0  
#define LWE297_FDC_LW_MCCIF_FIFOCTRL_RO_0                           0xa0c
#define LWE297_FDC_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRCL_MCLE2X                             0:0
#define LWE297_FDC_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRCL_MCLE2X_INIT_ENUM                  DISABLE
#define LWE297_FDC_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRCL_MCLE2X_DISABLE                    0x00000000
#define LWE297_FDC_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRCL_MCLE2X_ENABLE                     0x00000001

#define LWE297_FDC_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDMC_RDFAST                             1:1
#define LWE297_FDC_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDMC_RDFAST_INIT_ENUM                  DISABLE
#define LWE297_FDC_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDMC_RDFAST_DISABLE                    0x00000000
#define LWE297_FDC_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDMC_RDFAST_ENABLE                     0x00000001

#define LWE297_FDC_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRMC_CLLE2X                             2:2
#define LWE297_FDC_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRMC_CLLE2X_INIT_ENUM                  DISABLE
#define LWE297_FDC_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRMC_CLLE2X_DISABLE                    0x00000000
#define LWE297_FDC_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_WRMC_CLLE2X_ENABLE                     0x00000001

#define LWE297_FDC_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDCL_RDFAST                             3:3
#define LWE297_FDC_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDCL_RDFAST_INIT_ENUM                  DISABLE
#define LWE297_FDC_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDCL_RDFAST_DISABLE                    0x00000000
#define LWE297_FDC_LW_MCCIF_FIFOCTRL_RO_0_LW_MCCIF_RDCL_RDFAST_ENABLE                     0x00000001

// last two blocks (2 * 2^LWE297_ADDRBITS_PER_UNIT) are reserved for global registers
// Global Definitions here
// SURFADDR -- base address for framebuffer surfaces
// Note:
//   There are logically N surfaces, and the instruction set allows the
//   drawing surface, the z surface, the stencil surface, the coverage surface,
//   the register spill surface to be chosen amongst any of them.  However,
//   different surfaaces should remain seperate because there is no guarantee
//   of coherence between them by the hardware.
//   FDC was designed to use 32B
//   cache lines stored in alternate banks.  If
//   a surface wraps a cacheline off the end of
//   one line and into the beginning of the next
//   line, there can be a loss of performance
//   because one cacheline resides in two lines.
//   See bug 201949 for details.  Bottom line is
//   while functional down to 16B alignment,
//   better performance is obtained with 32B
//   alignment.

// Register LWE297_GLOBAL_SURFADDR_0  
#define LWE297_GLOBAL_SURFADDR_0                            0xe00
// This surface base address must be LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES aligned
// Address map is described in project_<project>.spec.
// For example, MG20's address map is described in
// project_mg20.spec
//
// While LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES alignment will work, LW_GR3D_SURF_ADDRESS_ALIGNMENT_FAST_BYTES alignment
// may provide better performance in some cases
#define LWE297_GLOBAL_SURFADDR_0_BASE_ADDRESS                              31:0


// Register LWE297_GLOBAL_SURFADDR  
#define LWE297_GLOBAL_SURFADDR                              0xe00
// This surface base address must be LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES aligned
// Address map is described in project_<project>.spec.
// For example, MG20's address map is described in
// project_mg20.spec
//
// While LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES alignment will work, LW_GR3D_SURF_ADDRESS_ALIGNMENT_FAST_BYTES alignment
// may provide better performance in some cases
#define LWE297_GLOBAL_SURFADDR_BASE_ADDRESS                        31:0


// Register LWE297_GLOBAL_SURFADDR_1  
#define LWE297_GLOBAL_SURFADDR_1                            0xe01
// This surface base address must be LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES aligned
// Address map is described in project_<project>.spec.
// For example, MG20's address map is described in
// project_mg20.spec
//
// While LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES alignment will work, LW_GR3D_SURF_ADDRESS_ALIGNMENT_FAST_BYTES alignment
// may provide better performance in some cases
#define LWE297_GLOBAL_SURFADDR_1_BASE_ADDRESS                              31:0


// Register LWE297_GLOBAL_SURFADDR_2  
#define LWE297_GLOBAL_SURFADDR_2                            0xe02
// This surface base address must be LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES aligned
// Address map is described in project_<project>.spec.
// For example, MG20's address map is described in
// project_mg20.spec
//
// While LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES alignment will work, LW_GR3D_SURF_ADDRESS_ALIGNMENT_FAST_BYTES alignment
// may provide better performance in some cases
#define LWE297_GLOBAL_SURFADDR_2_BASE_ADDRESS                              31:0


// Register LWE297_GLOBAL_SURFADDR_3  
#define LWE297_GLOBAL_SURFADDR_3                            0xe03
// This surface base address must be LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES aligned
// Address map is described in project_<project>.spec.
// For example, MG20's address map is described in
// project_mg20.spec
//
// While LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES alignment will work, LW_GR3D_SURF_ADDRESS_ALIGNMENT_FAST_BYTES alignment
// may provide better performance in some cases
#define LWE297_GLOBAL_SURFADDR_3_BASE_ADDRESS                              31:0


// Register LWE297_GLOBAL_SURFADDR_4  
#define LWE297_GLOBAL_SURFADDR_4                            0xe04
// This surface base address must be LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES aligned
// Address map is described in project_<project>.spec.
// For example, MG20's address map is described in
// project_mg20.spec
//
// While LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES alignment will work, LW_GR3D_SURF_ADDRESS_ALIGNMENT_FAST_BYTES alignment
// may provide better performance in some cases
#define LWE297_GLOBAL_SURFADDR_4_BASE_ADDRESS                              31:0


// Register LWE297_GLOBAL_SURFADDR_5  
#define LWE297_GLOBAL_SURFADDR_5                            0xe05
// This surface base address must be LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES aligned
// Address map is described in project_<project>.spec.
// For example, MG20's address map is described in
// project_mg20.spec
//
// While LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES alignment will work, LW_GR3D_SURF_ADDRESS_ALIGNMENT_FAST_BYTES alignment
// may provide better performance in some cases
#define LWE297_GLOBAL_SURFADDR_5_BASE_ADDRESS                              31:0


// Register LWE297_GLOBAL_SURFADDR_6  
#define LWE297_GLOBAL_SURFADDR_6                            0xe06
// This surface base address must be LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES aligned
// Address map is described in project_<project>.spec.
// For example, MG20's address map is described in
// project_mg20.spec
//
// While LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES alignment will work, LW_GR3D_SURF_ADDRESS_ALIGNMENT_FAST_BYTES alignment
// may provide better performance in some cases
#define LWE297_GLOBAL_SURFADDR_6_BASE_ADDRESS                              31:0


// Register LWE297_GLOBAL_SURFADDR_7  
#define LWE297_GLOBAL_SURFADDR_7                            0xe07
// This surface base address must be LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES aligned
// Address map is described in project_<project>.spec.
// For example, MG20's address map is described in
// project_mg20.spec
//
// While LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES alignment will work, LW_GR3D_SURF_ADDRESS_ALIGNMENT_FAST_BYTES alignment
// may provide better performance in some cases
#define LWE297_GLOBAL_SURFADDR_7_BASE_ADDRESS                              31:0


// Register LWE297_GLOBAL_SURFADDR_8  
#define LWE297_GLOBAL_SURFADDR_8                            0xe08
// This surface base address must be LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES aligned
// Address map is described in project_<project>.spec.
// For example, MG20's address map is described in
// project_mg20.spec
//
// While LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES alignment will work, LW_GR3D_SURF_ADDRESS_ALIGNMENT_FAST_BYTES alignment
// may provide better performance in some cases
#define LWE297_GLOBAL_SURFADDR_8_BASE_ADDRESS                              31:0


// Register LWE297_GLOBAL_SURFADDR_9  
#define LWE297_GLOBAL_SURFADDR_9                            0xe09
// This surface base address must be LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES aligned
// Address map is described in project_<project>.spec.
// For example, MG20's address map is described in
// project_mg20.spec
//
// While LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES alignment will work, LW_GR3D_SURF_ADDRESS_ALIGNMENT_FAST_BYTES alignment
// may provide better performance in some cases
#define LWE297_GLOBAL_SURFADDR_9_BASE_ADDRESS                              31:0


// Register LWE297_GLOBAL_SURFADDR_10  
#define LWE297_GLOBAL_SURFADDR_10                           0xe0a
// This surface base address must be LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES aligned
// Address map is described in project_<project>.spec.
// For example, MG20's address map is described in
// project_mg20.spec
//
// While LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES alignment will work, LW_GR3D_SURF_ADDRESS_ALIGNMENT_FAST_BYTES alignment
// may provide better performance in some cases
#define LWE297_GLOBAL_SURFADDR_10_BASE_ADDRESS                             31:0


// Register LWE297_GLOBAL_SURFADDR_11  
#define LWE297_GLOBAL_SURFADDR_11                           0xe0b
// This surface base address must be LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES aligned
// Address map is described in project_<project>.spec.
// For example, MG20's address map is described in
// project_mg20.spec
//
// While LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES alignment will work, LW_GR3D_SURF_ADDRESS_ALIGNMENT_FAST_BYTES alignment
// may provide better performance in some cases
#define LWE297_GLOBAL_SURFADDR_11_BASE_ADDRESS                             31:0


// Register LWE297_GLOBAL_SURFADDR_12  
#define LWE297_GLOBAL_SURFADDR_12                           0xe0c
// This surface base address must be LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES aligned
// Address map is described in project_<project>.spec.
// For example, MG20's address map is described in
// project_mg20.spec
//
// While LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES alignment will work, LW_GR3D_SURF_ADDRESS_ALIGNMENT_FAST_BYTES alignment
// may provide better performance in some cases
#define LWE297_GLOBAL_SURFADDR_12_BASE_ADDRESS                             31:0


// Register LWE297_GLOBAL_SURFADDR_13  
#define LWE297_GLOBAL_SURFADDR_13                           0xe0d
// This surface base address must be LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES aligned
// Address map is described in project_<project>.spec.
// For example, MG20's address map is described in
// project_mg20.spec
//
// While LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES alignment will work, LW_GR3D_SURF_ADDRESS_ALIGNMENT_FAST_BYTES alignment
// may provide better performance in some cases
#define LWE297_GLOBAL_SURFADDR_13_BASE_ADDRESS                             31:0


// Register LWE297_GLOBAL_SURFADDR_14  
#define LWE297_GLOBAL_SURFADDR_14                           0xe0e
// This surface base address must be LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES aligned
// Address map is described in project_<project>.spec.
// For example, MG20's address map is described in
// project_mg20.spec
//
// While LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES alignment will work, LW_GR3D_SURF_ADDRESS_ALIGNMENT_FAST_BYTES alignment
// may provide better performance in some cases
#define LWE297_GLOBAL_SURFADDR_14_BASE_ADDRESS                             31:0


// Register LWE297_GLOBAL_SURFADDR_15  
#define LWE297_GLOBAL_SURFADDR_15                           0xe0f
// This surface base address must be LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES aligned
// Address map is described in project_<project>.spec.
// For example, MG20's address map is described in
// project_mg20.spec
//
// While LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES alignment will work, LW_GR3D_SURF_ADDRESS_ALIGNMENT_FAST_BYTES alignment
// may provide better performance in some cases
#define LWE297_GLOBAL_SURFADDR_15_BASE_ADDRESS                             31:0

// This table describes surface properties.
// In the nomenclature Cc below, 'C' represents the color component,
//  and 'c' is the number of bits for that component.
//
// There is support for both D3D style packing (B at the ls end, then G,
// then R, then A), as well as OGL style packing (A at the ls end, then B,
// then G, then R), for in-memory format.  However, no matter what the memory
// packing arrangement is, the internal pipeline is arranged so that R
// is always at the LS end, then G, then B, then A.
//
// All color formats are described in little endian format below, as 4-tuples
// in (red, green, blue, alpha) order.
//
//      A8           --  8bpp; produces (0x00,0x00,0x00,A8)
//      A16_float    -- 16bpp; produces (0.0,A20)
//      L8           --  8bpp; produces (L8,L8,L8,0xFF)
//      L16_float    -- 16bpp; produces (L20,1.0)
//      L8A8         -- 16bpp; produces (L8,L8,L8,A8)
//      L16A16_float -- 32bpp; produces (L20,A20)
//      B2G3R3       --  8bpp; produces (R3,G3,B2,0xFF)
//      B5G6R5       -- 16bpp; produces (R5,G6,B5,0xFF)
//      R11G11B10_float
//                   -- 32bpp; produces (R20,G20,B20)
//      B5G5R5A1     -- 16bpp; produces (R5,G5,B5,A1)
//      A1B5G5R5     -- 16bpp; produces (R5,G5,B5,A1)
//      B4G4R4A4     -- 16bpp; produces (R4,G4,B4,A4)
//      A4B4G4R4     -- 16bpp; produces (R4,G4,B4,A4)
//      B8G8R8A8     -- 32bpp; produces (R8,G8,B8,A8)
//      R8G8B8A8     -- 32bpp; produces (R8,G8,B8,A8)
//      R16G16B16A16_float
//                   -- 64bpp; produces (R20,G20,B20,A20)
//      R10G10B10_float_A2
//                   -- 32bpp; produces (R20,G20,B20,A20) (sc25 P1)
//      B8G8R8G8     -- 32bpp; compressed YUV 4:2:2 texture (EXT_texture_compression_422)
//                      produces (R8,G8,B8,0xFF) (sc25 only)
//      G8B8G8R8     -- 32bpp; compressed YUV 4:2:2 texture (EXT_texture_compression_422)
//                      produces (R8,G8,B8,0xFF) (sc25 only)
//      DXT1         -- compressed texture with transparency
//      DXT1C        -- compressed texture with black
//      DXT3         -- compressed texture with explicit transparency
//      DXT5         -- compressed texture with encoded transparency
//      ETC          -- compressed ETC1 texture (from GLES2.0 spec)
//      ETC3         -- compressed ETC1 texture with DXT3 explicit transparency
//      ETC5         -- compressed ETC1 texture with DXT5 encoded transparency
//      LATC1        -- compressed unsigned luminance texture
//      LATC2        -- compressed unsigned luminance texture with encoded transparency
//      Z16          -- 16bpp; 16b Z
//      Z16NL        -- 16bpp; 16b Z
//
// Most entries are fixed point values.  where all ones indicates 1.0 and
// all zeros indicates 0.0.
//
// The 16_float format is
//             <15>    sign (S)
//             <14:10> exponent (E)
//             < 9: 0> mantissa (M)
//    (-1)^S * 0.0                        if E == 0 and M == 0,
//    (-1)^S * 2^-14 * (M / 2^10)         if E == 0 and M !- 0, (denorm)
//    (-1)^S * 2^(E-15) * (1 + M / 2^10), if 0 < E < 31,
//    (-1)^S * 2^(E-15) * (1 + M / 2^10), if E == 31 and M == 0,
//    (-1)^S * 2^(E-15) * (1 + M / 2^10), if E == 31 and M != 0
//
// The 11_float format is
//             <10: 6> exponent (E)
//             < 5: 0> mantissa (M)
//    0.0,                      if E == 0 and M == 0,
//    2^-14 * (M / 2^6),        if E == 0 and M != 0, (denorm)
//    2^(E-15) * (1 + M / 2^6), if 0 < E < 31,
//    2^(E-15) * (1 + M / 2^6), if E == 31 and M == 0,
//    2^(E-15) * (1 + M / 2^6), if E == 31 and M != 0
//
// The 10_float formats are
//
// R11G11B10_float:
//             < 9: 5> exponent (E)
//             < 4: 0> mantissa (M)
//    0.0,                      if E == 0 and M == 0,
//    2^-14 * (M / 2^5),        if E == 0 and M != 0, (denorm)
//    2^(E-15) * (1 + M / 2^5), if 0 < E < 31,
//    2^(E-15) * (1 + M / 2^5), if E == 31 and M == 0,
//    2^(E-15) * (1 + M / 2^5), if E == 31 and M != 0
//
// R10G10B10_float_A2
//             <31:30> alpha
//             <29:26> blue exponent (E)
//             <25:20> blue mantissa (M)
//             <19:16> green exponent (E)
//             <15:10> green mantissa (M)
//             < 9: 6> red exponent (E)
//             < 5: 0> red mantissa (M)
//    0.0,                      if E == 0 and M == 0,
//    2^-6 * (M / 2^6),         if E == 0 and M != 0, (denorm)
//    2^(E-7) * (1 + M / 2^6),  if 0 < E < 15,
//    2^(E-7) * (1 + M / 2^6),  if E == 15 and M == 0,
//    2^(E-7) * (1 + M / 2^6),  if E == 15 and M != 0
//
//
// Bit field assignments for the surface formats in memory is:
//
// B2G3R3      <1:0>    blue
//             <4:2>    green
//             <7:5>    red
//
// B5G6R5      <4:0>    blue
//             <10:5>   green
//             <15:11>  red
//
// A4B4G4R4    <3:0>    alpha
//             <7:4>    blue
//             <11:8>   green
//             <15:12>  red
//
// B4G4R4A4    <3:0>    blue
//             <7:4>    green
//             <11:8>   red
//             <15:12>  alpha
//
// A1B5G5R5    <0>      alpha
//             <5:1>    blue
//             <10:6>   green
//             <15:11>  red
//
// B5G5R5A1    <4:0>    blue
//             <9:5>    green
//             <14:10>  red
//             <15>     alpha
//
// A8          <7:0>    alpha
//
// A16_float   <15:0>   alpha (fp16)
//
// L8          <7:0>    luminance
//
// L16_float   <15:0>   luminance (fp16)
//
// L8A8        <7:0>    luminance
//             <15:8>   alpha
//
// L16A16_float<15:0>   luminance (fp16)
//             <31:16>  alpha (fp16)
//
// R16G16B16A16_float
//             <15:0>   red (fp16)
//             <31:16>  green (fp16)
//             <47:32>  blue (fp16)
//             <63:48>  alpha (fp16)
//
// R11G11B10_float
//             <10:0>   red (fp11 - 6e5)
//             <21:11>  green (fp11 - 6e5)
//             <31:22>  blue (fp10 - 5e5)
//
// R10G10B10_float_A2
//             <9:0>    red (fp10 - 6e4)
//             <19:10>  green (fp10 - 6e4)
//             <29:20>  blue (fp10 - 6e4)
//             <31:30>  alpha
//
// B8G8R8A8    <7:0>    blue
//             <15:8>   green
//             <23:16>  red
//             <31:24>  alpha
//
// R8G8B8A8    <7:0>    red
//             <15:8>   green
//             <23:16>  blue
//             <31:24>  alpha
//
// Z16         <15:0>   16 bit linear depth
//
// Z16NL       <12:0>   the remaining msb bits after removing the first 7 leading
//                      ones from the 20 bit linear depth
//             <15:13>  leading ones count from the 20 bit linear depth
//
// B8G8R8G8    <7:0>    blue0
//             <15:8>   green0
//             <23:16>  red
//             <31:24>  green1
//
//             If (x%2 == 0) then
//                 color = (red, green0, blue); alpha = 0xFF
//             else
//                 color = (red, green1, blue); alpha = 0xFF
//
// G8B8G8R8    <7:0>    green0
//             <15:8>   blue
//             <23:16>  green1
//             <31:24>  red
//
//             If (x%2 == 0) then
//                 color = (red, green0, blue); alpha = 0xFF
//             else
//                 color = (red, green1, blue); alpha = 0xFF
//
// DXT1        < 4: 0>    color0.blue
//             <10: 5>    color0.green
//             <15:11>    color0.red
//             <20:16>    color1.blue
//             <26:21>    color1.green
//             <31:27>    color1.red
//             <33:32>    index (0,0)
//             <35:34>    index (0,1)
//             <37:36>    index (0,2)
//             <39:38>    index (0,3)
//             <41:40>    index (1,0)
//             <43:42>    index (1,1)
//             <45:44>    index (1,2)
//             <47:46>    index (1,3)
//             <49:48>    index (2,0)
//             <51:50>    index (2,1)
//             <53:52>    index (2,2)
//             <55:54>    index (2,3)
//             <57:56>    index (3,0)
//             <59:58>    index (3,1)
//             <61:60>    index (3,2)
//             <63:62>    index (3,3)
//
//             idx = index(y%4, x%4)
//             (r0,g0,b0) = expand555to888(color0)
//             (r1,g1,b1) = expand555to888(color1)
//             If (color0 <= color1) then
//                 // the block has alpha
//                 switch (idx)
//                   case 0: alpha = FF; color = (r0,g0,b0)
//                   case 1: alpha = FF; color = (r1,g1,b1)
//                   case 2: alpha = FF; color = (rgb0+rgb1)/2
//                   case 3: alpha = 00; color = (00,00,00)
//                 endswitch
//             else
//                 // the block has no alpha
//                 switch (idx)
//                   case 0: alpha = FF; color = (r0,g0,b0)
//                   case 1: alpha = FF; color = (r1,g1,b1)
//                   case 2: alpha = FF; color = (2*rgb0+rgb1+1)/3
//                   case 3: alpha = FF; color = (rgb0+2*rgb1+1)/3
//                 endswitch
//
// DXT1C       Identical to DXT1, except that in the one case that
//             produces transparency, opaque black is produced instead
//             (color0 <= color1 && idx=3).
//
// DXT3
//           <  3:  0>    alpha (0,0)
//           <  7:  4>    alpha (0,1)
//           < 11:  8>    alpha (0,2)
//           < 15: 12>    alpha (0,3)
//           < 19: 16>    alpha (1,0)
//           < 23: 20>    alpha (1,1)
//           < 27: 24>    alpha (1,2)
//           < 31: 28>    alpha (1,3)
//           < 35: 32>    alpha (2,0)
//           < 39: 36>    alpha (2,1)
//           < 43: 40>    alpha (2,2)
//           < 47: 44>    alpha (2,3)
//           < 51: 48>    alpha (3,0)
//           < 55: 52>    alpha (3,1)
//           < 59: 56>    alpha (3,2)
//           < 63: 60>    alpha (3,3)
//           < 67: 64>    color0.blue
//           < 74: 68>    color0.green
//           < 79: 75>    color0.red
//           < 84: 80>    color1.blue
//           < 90: 85>    color1.green
//           < 95: 91>    color1.red
//           < 97: 96>    index (0,0)
//           < 99: 98>    index (0,1)
//           <101:100>    index (0,2)
//           <103:102>    index (0,3)
//           <105:104>    index (1,0)
//           <107:106>    index (1,1)
//           <109:108>    index (1,2)
//           <111:110>    index (1,3)
//           <113:112>    index (2,0)
//           <115:114>    index (2,1)
//           <117:116>    index (2,2)
//           <119:118>    index (2,3)
//           <121:120>    index (3,0)
//           <123:122>    index (3,1)
//           <125:124>    index (3,2)
//           <127:126>    index (3,3)
//
//           Color is computed the same as DXT1 except the color
//           compare "if (color0 <= color1)" is changed to "if (FALSE)".
//           In other words, the color is always in 4 color mode.
//
//           alpha = expand4to8(alpha(y%4, x%4))
//
//
// DXT5      <  7:  0>    alpha_0
//           < 15:  8>    alpha_1
//           < 18: 16>    index_a (0,0)
//           < 21: 19>    index_a (0,1)
//           < 24: 22>    index_a (0,2)
//           < 27: 25>    index_a (0,3)
//           < 30: 28>    index_a (1,0)
//           < 33: 31>    index_a (1,1)
//           < 36: 34>    index_a (1,2)
//           < 39: 37>    index_a (1,3)
//           < 42: 40>    index_a (2,0)
//           < 45: 43>    index_a (2,1)
//           < 48: 46>    index_a (2,2)
//           < 51: 49>    index_a (2,3)
//           < 54: 52>    index_a (3,0)
//           < 57: 55>    index_a (3,1)
//           < 60: 58>    index_a (3,2)
//           < 63: 61>    index_a (3,3)
//           < 67: 64>    color0.blue
//           < 74: 68>    color0.green
//           < 79: 75>    color0.red
//           < 84: 80>    color1.blue
//           < 90: 85>    color1.green
//           < 95: 91>    color1.red
//           < 97: 96>    index (0,0)
//           < 99: 98>    index (0,1)
//           <101:100>    index (0,2)
//           <103:102>    index (0,3)
//           <105:104>    index (1,0)
//           <107:106>    index (1,1)
//           <109:108>    index (1,2)
//           <111:110>    index (1,3)
//           <113:112>    index (2,0)
//           <115:114>    index (2,1)
//           <117:116>    index (2,2)
//           <119:118>    index (2,3)
//           <121:120>    index (3,0)
//           <123:122>    index (3,1)
//           <125:124>    index (3,2)
//           <127:126>    index (3,3)
//
//           Color is computed exactly as DXT3 is.
//
//           idx = index_a(y%4, x%4)
//
//           //8-alpha or 6-alpha block?
//           if (alpha_0 > alpha_1) then
//               //8-alpha block.
//               switch(idx)
//                 case 0: alpha = alpha_0;
//                 case 1: alpha = alpha_1
//                 case 2: alpha = (6 * alpha_0 + 1 * alpha_1 + 3) / 7;
//                 case 3: alpha = (5 * alpha_0 + 2 * alpha_1 + 3) / 7;
//                 case 4: alpha = (4 * alpha_0 + 3 * alpha_1 + 3) / 7;
//                 case 5: alpha = (3 * alpha_0 + 4 * alpha_1 + 3) / 7;
//                 case 6: alpha = (2 * alpha_0 + 5 * alpha_1 + 3) / 7;
//                 case 7: alpha = (1 * alpha_0 + 6 * alpha_1 + 3) / 7;
//               endswitch
//           else
//               //6-alpha block.
//               switch(idx)
//                 case 0: alpha = alpha_0;
//                 case 1: alpha = alpha_1
//                 case 2: alpha = (4 * alpha_0 + 1 * alpha_1 + 2) / 5;
//                 case 3: alpha = (3 * alpha_0 + 2 * alpha_1 + 2) / 5;
//                 case 4: alpha = (2 * alpha_0 + 3 * alpha_1 + 2) / 5;
//                 case 5: alpha = (1 * alpha_0 + 4 * alpha_1 + 2) / 5;
//                 case 6: alpha = 0;
//                 case 7: alpha = 255;
//               endswitch
//
//           The Ericsson Texture Compression (ETC) format is defined in OpenGL ES.
// ETC       < 63: 0>     ETC color block
//
// ETC3      < 63: 0>     DXT3 alpha block with ETC pixel layout
//           <127:64>     ETC color block
//
// ETC5      < 63: 0>     DXT5 alpha block with ETC pixel layout
//           <127:64>     ETC color block
//
//           Only unsigned LATC is supported, the signed mode can be implemented in the shader.
// LATC1     < 63: 0>     DXT5 alpha block
//                        Produces (A,A,A,0xFF).
//
// LATC2     < 63: 0>     DXT5 alpha block 0
//           <127:64>     DXT5 alpha block 1
//                        Produces (A0,A0,A0,A1)
//
// Texture storage -- This should go in the LWE297_tex.spec file -- mmahan
//
// Besides normal mipmaps, ar3d supports non-mipmapped textures of rectangluar
// shapes whose dimensions are power of two as a degenerate case of a mipmap,
// by setting both LOD_MIN and LOD_MAX to 0 (effectively disabling mipmapping).
// Ar3d does _not_ support non-mipmapped rectangular textures whose dimensions
// are not powers of 2 (simply referred to as 'rectangular textures' in GL
// lingo), i.e. it does not support the Lwpu defined OpenGL extension
// GL_LW_texture_rectangle.  Another way of saying it is whether mipmapped or
// not, all textures in AR01 must have dimensions that are powers of two.
// MG20, however, supports non-mipmapped non-power-of-2 textures, lwbemaps,
// and texture arrays.
//
// The levels of a mipmap are stored in conselwtive (abutting) blocks of
// memory, but each level may contain some padding based on the row length
// restrictions as detailed below. The levels of a mipmap are stored such
// that the starting address of level N+1 is higher than the starting address
// of level N. So mipmap level 0 is stored at the lowest address, followed by
// level 1 above it, and so on.
//
// A row must be a multiple of a LW_GR3D_TEX_MIN_STRIDE_BYTES in length.
// For SC15, this value is 16 bytes.  So for a texture of width W texels and
// height H texels we program the HW with a height of H and a pitch of
//     (width * (bpp/8) + 16-1) / 16.
//
// There is also the requirement that a given mipmap level must be at least
// LW_GR3D_TEX_MIN_SIZE_BYTES in size.  This only matters for the smallest
// maps.  For SC15, this is value is 16 bytes.
//
// Another requirement is that a given texture level must begin at an
// aligned memory address, given by LW_GR3D_TEX_ALIGNMENT_BYTES.  For SC15,
// this quantity is 16 bytes.
//
// Textures can be stored linearly (QUADLIN = 0) or swizzled (QUADLIN = 1).
// The storage convention is orthogonal to the texture format. The basic
// organizational unit of texture memory is a texture cache line, which on
// sc15 is 16 bytes.  Symbolically it is defined as LW_DF_TEXLINE_BYTES_LOG2
// and LW_DF_TEXLINE_BYTES.
//
// A texture cache line is comprised of bytes stored in little endian fashion.
//
// In linear mode, texels are stored as follows:
//
// 64bpp: D< 63:  0> = texel (x,  y)
//        D<127: 64> = texel (x+1,y)
//
// 32bpp: D< 31:  0> = texel (x,  y)
//        D< 63: 32> = texel (x+1,y)
//        D< 95: 64> = texel (x+2,y)
//        D<127: 96> = texel (x+3,y)
//
// 16bpp: D< 15:  0> = texel (x,  y)
//        D< 31: 16> = texel (x+1,y)
//        D< 47: 32> = texel (x+2,y)
//        D< 63: 48> = texel (x+3,y)
//        D< 79: 64> = texel (x+4,y)
//        D< 95: 80> = texel (x+5,y)
//        D<111: 96> = texel (x+6,y)
//        D<127:112> = texel (x+7,y)
//
//  8bpp: D<  7:  0> = texel (x,  y)
//        D< 15:  8> = texel (x+1,y)
//        D< 23: 16> = texel (x+2,y)
//        D< 31: 24> = texel (x+3,y)
//        D< 39: 32> = texel (x+4,y)
//        D< 47: 40> = texel (x+5,y)
//        D< 55: 48> = texel (x+6,y)
//        D< 63: 56> = texel (x+7,y)
//        D< 71: 64> = texel (x+8,y)
//        D< 79: 72> = texel (x+9,y)
//        D< 87: 80> = texel (x+10,y)
//        D< 95: 88> = texel (x+11,y)
//        D<103: 96> = texel (x+12,y)
//        D<111:104> = texel (x+13,y)
//        D<119:112> = texel (x+14,y)
//        D<127:120> = texel (x+15,y)
//
//  4bpp: D<  3:  0> = texel (x,   y)
//        D<  7:  4> = texel (x+1, y)
//        D< 11:  8> = texel (x+2, y)
//        ...
//        D<115:112> = texel (x+20,y)
//        D<119:116> = texel (x+29,y)
//        D<123:120> = texel (x+30,y)
//        D<127:124> = texel (x+31,y)
//
//  DXT1, DXT1C, DXT3, DXT5: Not allowed
//
// Swizzled mode mixes the texels from 2 or 4 adjacent rows for higher
// performance memory access, thus organizing the surface into tiles,
// which are 2x2 texels for 32bpp formats, 4x2 texels for 16bpp formats,
// 4x4 texels for 8bpp formats, and 8x4 texels for 4 bpp formats.  64bit
// DXT formats store 4x4-texel compressed texture blocks in 2x1 tiles.
// 128bit DXT formats store a single 4x4-texel compressed texture block
// in a tile.
//
//  Texels are stored as follows in swizzled mode:
//
// 64bpp: D< 63:  0> = texel (x  ,y)       y must be even
//        D<127: 64> = texel (x  ,y+1)       
// 
// 32bpp: D< 31:  0> = texel (x  ,y)       x and y are both even
//        D< 63: 32> = texel (x+1,y)
//        D< 95: 64> = texel (x  ,y+1)
//        D<127: 96> = texel (x+1,y+1)
//
// 16bpp: D< 15:  0> = texel (x  ,y)       x must be divisible by 4
//        D< 31: 16> = texel (x+1,y)       y must be even
//        D< 47: 32> = texel (x+2,y)
//        D< 63: 48> = texel (x+3,y)
//        D< 79: 64> = texel (x  ,y+1)
//        D< 95: 80> = texel (x+1,y+1)
//        D<111: 96> = texel (x+2,y+1)
//        D<127:112> = texel (x+3,y+1)
//
//  8bpp: D<  7:  0> = texel (x  ,y)       x must be divisible by 4
//        D< 15:  8> = texel (x+1,y)       y must be divisible by 4
//        D< 23: 16> = texel (x+2,y)
//        D< 31: 24> = texel (x+3,y)
//        D< 39: 32> = texel (x  ,y+1)
//        D< 47: 40> = texel (x+1,y+1)
//        D< 55: 48> = texel (x+2,y+1)
//        D< 63: 56> = texel (x+3,y+1)
//        D< 71: 64> = texel (x  ,y+2)
//        D< 79: 72> = texel (x+1,y+2)
//        D< 87: 80> = texel (x+2,y+2)
//        D< 95: 88> = texel (x+3,y+2)
//        D<103: 96> = texel (x  ,y+3)
//        D<111:104> = texel (x+1,y+3)
//        D<119:112> = texel (x+2,y+3)
//        D<127:120> = texel (x+3,y+3)
//
//  4bpp: D<  3:  0> = texel (x  ,y)       x must be divisible by 8
//        D<  7:  4> = texel (x+1,y)       y must be divisible by 4
//        D< 11:  8> = texel (x+2,y)
//        D< 15: 12> = texel (x+3,y)
//        D< 19: 16> = texel (x+4,y)
//        D< 23: 20> = texel (x+5,y)
//        D< 27: 24> = texel (x+6,y)
//        D< 31: 28> = texel (x+7,y)
//        D< 35: 32> = texel (x,  y+1)
//        D< 39: 36> = texel (x+1,y+1)
//        D< 43: 40> = texel (x+2,y+1)
//        D< 47: 44> = texel (x+3,y+1)
//        D< 51: 48> = texel (x+4,y+1)
//        D< 55: 52> = texel (x+5,y+1)
//        D< 59: 56> = texel (x+6,y+1)
//        D< 63: 60> = texel (x+7,y+1)
//        D< 67: 64> = texel (x  ,y+2)
//        D< 71: 68> = texel (x+1,y+2)
//        D< 75: 72> = texel (x+2,y+2)
//        D< 79: 76> = texel (x+3,y+2)
//        D< 83: 80> = texel (x+4,y+2)
//        D< 87: 84> = texel (x+5,y+2)
//        D< 91: 88> = texel (x+6,y+2)
//        D< 95: 92> = texel (x+7,y+2)
//        D< 99: 96> = texel (x  ,y+3)
//        D<103:100> = texel (x+1,y+3)
//        D<107:104> = texel (x+2,y+3)
//        D<111:108> = texel (x+3,y+3)
//        D<115:112> = texel (x+4,y+3)
//        D<119:116> = texel (x+5,y+3)
//        D<123:120> = texel (x+6,y+3)
//        D<127:124> = texel (x+7,y+3)
//
//  DXT1, DXT1C, ETC, LATC1:
//        D< 63:  0> = compressed_texel (x, y)   x must be divisible by 8
//        D<127: 64> = compressed_texel (x+4, y) y must be divisible by 4
//
//  DXT3, DXT5, ETC3, ETC5, LATC2:
//        D<127:  0> = compressed_texel (x, y)   x must be divisible by 4
//                                               y must be divisible by 4
//
//
// Note that in a swizzled format, the pad bytes to make the row a multiple
// of a cache line are not contiguous. In general, the pad bytes will occupy
// the bytes of a line whose associated texel coordinates are outside the
// texture the defined texture rectangle. For example, with a 2x8 texture
// using a 8bpp format, bytes 2,3,6,7,10,11,14,15 of each of the two lines
// constituting the texture are filled with pad bytes.  Any value will do
// since they aren't referenced by the hardware, but filling them with 0x00
// is recommended.  A visual display of this is shown below.
//
//     2x8 texture      memory
//      +-----+        +---------------------------------+
//      | a b |        | a b . . c d . . e f . . g h . . |
//      | c d |        +---------------------------------+
//      | e f |        | i j . . k l . . m n . . o p . . |
//      | g h |        +---------------------------------+
//      | i j |
//      | k l |
//      | m n |
//      | o p |
//      +-----+
//
// In general, GL has a requirement that one can update arbitrary rectangular
// subregions of a texture via the glTexSubImage2D (transfer from system
// memory to video memory) and glCopyTexSubImage2D (transfer from video
// memory to video memory) functions. Note that this leads to non-contiguous
// writes (and in the case of glCopyTexSubImage2D, non-contigiuous reads),
// and in the case of 4bpp texels requires RMW accesses at the byte level.
//
// Example (assumes 16b subcomponents are ls to ms (a is 15:0, b is
// 31:16, etc):
//
// mipmap level 8x4, 8bpp   storage tiled, pitch=16, height=4
//
// a b c d e f g h           +---------+---------+---------+---------+
// i j k l m n o p           | a b i j | c d k l | e f m n | g h o p |
// q r s t u v w x           +---------+---------+---------+---------+
// y z ? @ $ % & =           | q r y z | s t ? @ | t u $ % | w x & = |
//                           +---------+---------+---------+---------+
//
// download new subimage (1,1)-(3,3) inclusive:
//
// a b c d e f g h           +---------+---------+---------+---------+
// i * * * m n o p           | a b i * | c d * * | e f m n | g h o p |
// q * . . u v w x           +---------+---------+---------+---------+
// y * . . $ % & =           | q * y * | . . . . | t u $ % | w x & = |
//                           +---------+---------+---------+---------+
//
// The SC15 blit engine does not support scatter/gather operations to
// support reading from or writing to a rectangular region that is part
// of a surface that uses swizzled storage. When transferring texture data
// from system memory to video memory, SW must perform a gather operation
// to fill in T$ lines in proper order during the host blit. The blitter
// can only be used to copy an inscribed rectangle of the desired region
// which is aligned at tile boundaries. In the above example this means
// the rectangle (2,2)-(3,3).
//
// For vidmem-to-vidmem transfers, SW must provide gather/scatter operation
// for all texels of the region outside of the blittable rectangle inside
// the copied region.
//
//
// In MG20, both linear and swizzled textures can be tiled by setting the
// LAYOUT field in TEXDESC register to either TILED_LINEAR or TILED_SWIZZLED.
// Tiling attempts to distribute ddr bank accesses evenly to minimize page
// breaks, by xor'ing the msb of the bank number 
// (addr[LW_MC_POORMANS_TILING_ADDR_BIT]) with the lsb of the row number 
// (addr[LW_MC_POORMANS_TILING_ADDR_XOR]) to form a new address.
//      offset  = f(u,v)
//      address = base + offset
//      if (tiling)
//          address[LW_MC_POORMANS_TILING_ADDR_BIT] ^= address[LW_MC_POORMANS_TILING_ADDR_XOR]
//
// In AP15, a new tile mode (xytiled) was added.  This tile mode is dolwmented
// in //hw/ar/doc/<project>/mc/tiling/AP15_programmers_guide.doc
// This new tiling mode is controlled by SURFDESC for render surfaces, and 
// TEXDESC for textures.  Swizzling in xytiled mode is altered.
// 
// for 64, 32, 16 bits per pixel:
//   new_xbytes = (xbytes & ~0x8) | ((ylines & 0x1) << 3);
//   new_ylines = (ylines & ~0x1) | ((xbytes & 0x8) >> 3);
//
// for 8, 4 bits per pixel:
//   new_xbytes = (xbytes & ~0xc) | ((ylines & 0x3) << 2);
//   new_ylines = (ylines & ~0x3) | ((xbytes & 0xc) >> 2);
//
// visually this looks like this:
// 
//   * >= 16 bits per pixel
//       Each entry represents 64 bits
//       Linear:
//       00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f ....
//       10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f
//       20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f
//       30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f
//       40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f
//       50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f
//       60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f
//       .
//       .
//       .
//
//       Swizzled:
//       00 10 02 12 04 14 06 16 08 18 0a 1a 0c 1c 0e 1e ....
//       01 11 03 13 05 15 07 17 09 19 0c 1b 0d 1d 0f 1f
//       20 30 22 32 24 34 26 36 28 38 2a 3a 2c 3c 2e 3e
//       21 31 23 33 25 35 27 37 29 39 2c 3b 2d 3d 2f 3f
//       40 50 42 52 44 54 46 56 48 58 4a 5a 4c 5c 4e 5e
//       41 51 43 53 45 55 47 57 49 59 4c 5b 4d 5d 4f 5f
//       60 .. 62 .. 64 .. 66 .. 68 .. 6a .. 6c .. 6e ..
//       61 .. 63 .. 65 .. 67 .. 69 .. 6c .. 6d .. 6f ..
//
//   * <= 8 bits per pixel
//       Each entry represents 32 bits
//       Linear:
//       00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f ....
//       10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f
//       20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f
//       30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f
//       40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f
//       50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f
//       60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f
//       .
//       .
//       .
//
//       Swizzled:
//       00 10 20 30 04 14 24 34 08 18 28 38 0c 1c 2c 3c ....
//       01 11 21 31 05 15 25 35 09 19 29 39 0d 1d 2d 3d
//       02 12 22 32 06 16 26 36 0a 1a 2a 3a 0e 1e 2e 3e
//       03 13 23 33 07 17 27 37 0b 1b 2b 3b 0f 1f 2f 3f
//       40 50 60 .. 44 54 64 .. 48 58 68 .. 4c 5c 6c ..
//       41 51 61 .. 45 55 65 .. 49 59 69 .. 4d 5d 6d ..
//       42 52 62 .. 46 56 66 .. 4a 5a 6a .. 4e 5e 6e ..
//       43 53 63 .. 47 57 67 .. 4b 5b 6b .. 4f 5f 6f ..
//       .
//       .
//       .
//
// Notes:
//    * xytiled surfaces must be multiples of LW_MC_TILE_WIDTH bytes wide
//      and LW_MC_TILE_HEIGHT tall
//    * textures have special rules, see the TEXDESC register for more details
//
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// Notes on SURFDESC
//
// ARRAY_STRIDE
// Units are bytes
// Used by P32_float and P128 formats.  Overlaps with the STRIDE field so don't
// write both fields in the same regiser. Indicates How many bytes between
// array entries for the same pixel.  Must be a multiple of
// LW_GR3D_SURF_BYTE_QUANTUM (bytes), or equivalently,
// LW_GR3D_SURF_W_QUANTUM (16b pixels).
// The ARRAY_STRIDE must also follow the following rule for LOCAL OFFSET_TYPES
// (see PSEQ.INST for info about OFFSET_TYPES)
//   Surface Format  Rule
//   P32_float       ARRAY_STRIDE >= ((PIX_ATTR.MAX_QID + 1) * 4 * 4
//   P128            ARRAY_STRIDE >= ((PIX_ATTR.MAX_QID + 1) * 4 * 16
//
// STRIDE
// Units are bytes.
// Used by all surface formats except P32_float and P128 float. Overlaps
// with the ARRAY_STRIDE field, so don't write both fields in the same register.
// For non-texture surfaces, the stride must be non-zero and must be a
// multiple of LW_GR3D_SURF_BYTE_QUANTUM (bytes), or equivalently,
// LW_GR3D_SURF_W_QUANTUM (16b pixels).
//
// QUADLIN
// When this signal is TILED in means that each 128b chuck of memory
// has swizzled pixel order which are described in detail above.
//
// UNDITHER
// The surface should be dithered on writes or undithered on reads using the
// DITHER table described below
// --------------------------------------------------------------------------
//
// The width of a surface (stride) must be a positive multiple of a certain
// number, which can be viewed in terms of 16b pixels or bytes.
//
// Additionally, FDC was designed to use 32B cache lines stored in
// alternate banks.  If a surface wraps a cacheline off the end of one
// line and into the beginning of the next line, there can be a loss of
// performance because one cacheline resides in two lines.  See bug
// 201949 for details.  Bottom line is while functional down to 16B
// alignment, better performance is obtained with 32B alignment.
//
// Note that some units place restrictions on the SURFDESC index
// associated with some surfaces.  In particular, QRAST only supports
// the depth buffer in the SURFDESC index given by LW_GR3D_Z_SURF_PTR,
// the stencil buffer in the SURFDESC index given by
// LW_GR3D_S_SURF_PTR, and the coverage buffer in the SURFDESC index
// given by LW_GR3D_V_SURF_PTR
// Also Note that if any of the Z_SURF S_SURF or V_SURF surfaces have
// STRUCTURE set to XY_TILED, they all must have STRUCTURE set to XY_TILED
// for example Z_SURF of XY_TILED and S_SURF of TILED is not allowed.
#define LW_GR3D_SURF_W_QUANTUM  8
// 8 16b pixels
#define LW_GR3D_SURF_BYTE_QUANTUM       16
// 16 bytes

// Register LWE297_GLOBAL_SURFDESC_0  
#define LWE297_GLOBAL_SURFDESC_0                            0xe10
// page tiling LINEAR   -- no tiling
// TILED    -- tiled by adjusting address:
// XY_TILED -- tiled by adjusting x/y
#define LWE297_GLOBAL_SURFDESC_0_STRUCTURE                         26:25
#define LWE297_GLOBAL_SURFDESC_0_STRUCTURE_LINEAR                 0x00000000
#define LWE297_GLOBAL_SURFDESC_0_STRUCTURE_TILED                  0x00000001
#define LWE297_GLOBAL_SURFDESC_0_STRUCTURE_XY_TILED                       0x00000002

// Array stride in bytes (must be 1d surface)
#define LWE297_GLOBAL_SURFDESC_0_ARRAY_STRIDE                              24:8

// Surface stride in bytes
#define LWE297_GLOBAL_SURFDESC_0_STRIDE                            23:8

// Surface format
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT                               7:2
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_C4X4                 0x00000000
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_A8                   0x00000001
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_L8                   0x00000002
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_S8                   0x00000003
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_L8A8                 0x00000004
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_B2G3R3                       0x00000005
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_B5G6R5                       0x00000006
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_B5G5R5A1                     0x00000007
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_B4G4R4A4                     0x00000008
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_A1B5G5R5                     0x00000009
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_A4B4G4R4                     0x0000000a
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_Z16                  0x0000000b
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_Z16NL                        0x0000000c
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_R8G8B8A8                     0x0000000d
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_B8G8R8A8                     0x0000000e
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_A16_float                    0x0000000f
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_L16_float                    0x00000010
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_L16A16_float                 0x00000011
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_R16G16B16A16_float                   0x00000012
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_R11G11B10_float                      0x00000013
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_P128                 0x00000014
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_P32_float                    0x00000015
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_DXT1                 0x00000016
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_DXT1C                        0x00000017
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_DXT3                 0x00000018
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_DXT5                 0x00000019
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_ETC                  0x0000001a
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_ETC3                 0x0000001b
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_ETC5                 0x0000001c
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_LATC1                        0x0000001d
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_LATC2                        0x0000001e
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_B8G8R8G8                     0x0000001f
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_G8B8G8R8                     0x00000020
#define LWE297_GLOBAL_SURFDESC_0_SURF_FORMAT_R10G10B10_float_A2                   0x00000021

// SC25+ only (ignored in mg20) When this signal is TILED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
#define LWE297_GLOBAL_SURFDESC_0_QUADLIN                           1:1
#define LWE297_GLOBAL_SURFDESC_0_QUADLIN_LINEAR                   0x00000000
#define LWE297_GLOBAL_SURFDESC_0_QUADLIN_TILED                    0x00000001

// The surface should be dithered on write, and undithered on read.
#define LWE297_GLOBAL_SURFDESC_0_DITHER                            0:0
#define LWE297_GLOBAL_SURFDESC_0_DITHER_DISABLE                   0x00000000
#define LWE297_GLOBAL_SURFDESC_0_DITHER_ENABLE                    0x00000001


// Register LWE297_GLOBAL_SURFDESC  
#define LWE297_GLOBAL_SURFDESC                              0xe10
// page tiling LINEAR   -- no tiling
// TILED    -- tiled by adjusting address:
// XY_TILED -- tiled by adjusting x/y
#define LWE297_GLOBAL_SURFDESC_STRUCTURE                           26:25
#define LWE297_GLOBAL_SURFDESC_STRUCTURE_LINEAR                   0x00000000
#define LWE297_GLOBAL_SURFDESC_STRUCTURE_TILED                    0x00000001
#define LWE297_GLOBAL_SURFDESC_STRUCTURE_XY_TILED                 0x00000002

// Array stride in bytes (must be 1d surface)
#define LWE297_GLOBAL_SURFDESC_ARRAY_STRIDE                        24:8

// Surface stride in bytes
#define LWE297_GLOBAL_SURFDESC_STRIDE                              23:8

// Surface format
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT                         7:2
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_C4X4                   0x00000000
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_A8                     0x00000001
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_L8                     0x00000002
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_S8                     0x00000003
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_L8A8                   0x00000004
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_B2G3R3                 0x00000005
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_B5G6R5                 0x00000006
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_B5G5R5A1                       0x00000007
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_B4G4R4A4                       0x00000008
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_A1B5G5R5                       0x00000009
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_A4B4G4R4                       0x0000000a
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_Z16                    0x0000000b
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_Z16NL                  0x0000000c
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_R8G8B8A8                       0x0000000d
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_B8G8R8A8                       0x0000000e
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_A16_float                      0x0000000f
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_L16_float                      0x00000010
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_L16A16_float                   0x00000011
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_R16G16B16A16_float                     0x00000012
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_R11G11B10_float                        0x00000013
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_P128                   0x00000014
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_P32_float                      0x00000015
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_DXT1                   0x00000016
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_DXT1C                  0x00000017
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_DXT3                   0x00000018
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_DXT5                   0x00000019
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_ETC                    0x0000001a
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_ETC3                   0x0000001b
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_ETC5                   0x0000001c
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_LATC1                  0x0000001d
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_LATC2                  0x0000001e
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_B8G8R8G8                       0x0000001f
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_G8B8G8R8                       0x00000020
#define LWE297_GLOBAL_SURFDESC_SURF_FORMAT_R10G10B10_float_A2                     0x00000021

// SC25+ only (ignored in mg20) When this signal is TILED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
#define LWE297_GLOBAL_SURFDESC_QUADLIN                             1:1
#define LWE297_GLOBAL_SURFDESC_QUADLIN_LINEAR                     0x00000000
#define LWE297_GLOBAL_SURFDESC_QUADLIN_TILED                      0x00000001

// The surface should be dithered on write, and undithered on read.
#define LWE297_GLOBAL_SURFDESC_DITHER                              0:0
#define LWE297_GLOBAL_SURFDESC_DITHER_DISABLE                     0x00000000
#define LWE297_GLOBAL_SURFDESC_DITHER_ENABLE                      0x00000001


// Register LWE297_GLOBAL_SURFDESC_1  
#define LWE297_GLOBAL_SURFDESC_1                            0xe11
// page tiling LINEAR   -- no tiling
// TILED    -- tiled by adjusting address:
// XY_TILED -- tiled by adjusting x/y
#define LWE297_GLOBAL_SURFDESC_1_STRUCTURE                         26:25
#define LWE297_GLOBAL_SURFDESC_1_STRUCTURE_LINEAR                 0x00000000
#define LWE297_GLOBAL_SURFDESC_1_STRUCTURE_TILED                  0x00000001
#define LWE297_GLOBAL_SURFDESC_1_STRUCTURE_XY_TILED                       0x00000002

// Array stride in bytes (must be 1d surface)
#define LWE297_GLOBAL_SURFDESC_1_ARRAY_STRIDE                              24:8

// Surface stride in bytes
#define LWE297_GLOBAL_SURFDESC_1_STRIDE                            23:8

// Surface format
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT                               7:2
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_C4X4                 0x00000000
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_A8                   0x00000001
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_L8                   0x00000002
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_S8                   0x00000003
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_L8A8                 0x00000004
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_B2G3R3                       0x00000005
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_B5G6R5                       0x00000006
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_B5G5R5A1                     0x00000007
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_B4G4R4A4                     0x00000008
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_A1B5G5R5                     0x00000009
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_A4B4G4R4                     0x0000000a
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_Z16                  0x0000000b
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_Z16NL                        0x0000000c
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_R8G8B8A8                     0x0000000d
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_B8G8R8A8                     0x0000000e
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_A16_float                    0x0000000f
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_L16_float                    0x00000010
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_L16A16_float                 0x00000011
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_R16G16B16A16_float                   0x00000012
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_R11G11B10_float                      0x00000013
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_P128                 0x00000014
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_P32_float                    0x00000015
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_DXT1                 0x00000016
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_DXT1C                        0x00000017
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_DXT3                 0x00000018
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_DXT5                 0x00000019
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_ETC                  0x0000001a
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_ETC3                 0x0000001b
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_ETC5                 0x0000001c
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_LATC1                        0x0000001d
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_LATC2                        0x0000001e
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_B8G8R8G8                     0x0000001f
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_G8B8G8R8                     0x00000020
#define LWE297_GLOBAL_SURFDESC_1_SURF_FORMAT_R10G10B10_float_A2                   0x00000021

// SC25+ only (ignored in mg20) When this signal is TILED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
#define LWE297_GLOBAL_SURFDESC_1_QUADLIN                           1:1
#define LWE297_GLOBAL_SURFDESC_1_QUADLIN_LINEAR                   0x00000000
#define LWE297_GLOBAL_SURFDESC_1_QUADLIN_TILED                    0x00000001

// The surface should be dithered on write, and undithered on read.
#define LWE297_GLOBAL_SURFDESC_1_DITHER                            0:0
#define LWE297_GLOBAL_SURFDESC_1_DITHER_DISABLE                   0x00000000
#define LWE297_GLOBAL_SURFDESC_1_DITHER_ENABLE                    0x00000001


// Register LWE297_GLOBAL_SURFDESC_2  
#define LWE297_GLOBAL_SURFDESC_2                            0xe12
// page tiling LINEAR   -- no tiling
// TILED    -- tiled by adjusting address:
// XY_TILED -- tiled by adjusting x/y
#define LWE297_GLOBAL_SURFDESC_2_STRUCTURE                         26:25
#define LWE297_GLOBAL_SURFDESC_2_STRUCTURE_LINEAR                 0x00000000
#define LWE297_GLOBAL_SURFDESC_2_STRUCTURE_TILED                  0x00000001
#define LWE297_GLOBAL_SURFDESC_2_STRUCTURE_XY_TILED                       0x00000002

// Array stride in bytes (must be 1d surface)
#define LWE297_GLOBAL_SURFDESC_2_ARRAY_STRIDE                              24:8

// Surface stride in bytes
#define LWE297_GLOBAL_SURFDESC_2_STRIDE                            23:8

// Surface format
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT                               7:2
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_C4X4                 0x00000000
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_A8                   0x00000001
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_L8                   0x00000002
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_S8                   0x00000003
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_L8A8                 0x00000004
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_B2G3R3                       0x00000005
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_B5G6R5                       0x00000006
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_B5G5R5A1                     0x00000007
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_B4G4R4A4                     0x00000008
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_A1B5G5R5                     0x00000009
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_A4B4G4R4                     0x0000000a
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_Z16                  0x0000000b
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_Z16NL                        0x0000000c
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_R8G8B8A8                     0x0000000d
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_B8G8R8A8                     0x0000000e
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_A16_float                    0x0000000f
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_L16_float                    0x00000010
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_L16A16_float                 0x00000011
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_R16G16B16A16_float                   0x00000012
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_R11G11B10_float                      0x00000013
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_P128                 0x00000014
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_P32_float                    0x00000015
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_DXT1                 0x00000016
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_DXT1C                        0x00000017
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_DXT3                 0x00000018
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_DXT5                 0x00000019
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_ETC                  0x0000001a
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_ETC3                 0x0000001b
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_ETC5                 0x0000001c
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_LATC1                        0x0000001d
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_LATC2                        0x0000001e
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_B8G8R8G8                     0x0000001f
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_G8B8G8R8                     0x00000020
#define LWE297_GLOBAL_SURFDESC_2_SURF_FORMAT_R10G10B10_float_A2                   0x00000021

// SC25+ only (ignored in mg20) When this signal is TILED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
#define LWE297_GLOBAL_SURFDESC_2_QUADLIN                           1:1
#define LWE297_GLOBAL_SURFDESC_2_QUADLIN_LINEAR                   0x00000000
#define LWE297_GLOBAL_SURFDESC_2_QUADLIN_TILED                    0x00000001

// The surface should be dithered on write, and undithered on read.
#define LWE297_GLOBAL_SURFDESC_2_DITHER                            0:0
#define LWE297_GLOBAL_SURFDESC_2_DITHER_DISABLE                   0x00000000
#define LWE297_GLOBAL_SURFDESC_2_DITHER_ENABLE                    0x00000001


// Register LWE297_GLOBAL_SURFDESC_3  
#define LWE297_GLOBAL_SURFDESC_3                            0xe13
// page tiling LINEAR   -- no tiling
// TILED    -- tiled by adjusting address:
// XY_TILED -- tiled by adjusting x/y
#define LWE297_GLOBAL_SURFDESC_3_STRUCTURE                         26:25
#define LWE297_GLOBAL_SURFDESC_3_STRUCTURE_LINEAR                 0x00000000
#define LWE297_GLOBAL_SURFDESC_3_STRUCTURE_TILED                  0x00000001
#define LWE297_GLOBAL_SURFDESC_3_STRUCTURE_XY_TILED                       0x00000002

// Array stride in bytes (must be 1d surface)
#define LWE297_GLOBAL_SURFDESC_3_ARRAY_STRIDE                              24:8

// Surface stride in bytes
#define LWE297_GLOBAL_SURFDESC_3_STRIDE                            23:8

// Surface format
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT                               7:2
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_C4X4                 0x00000000
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_A8                   0x00000001
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_L8                   0x00000002
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_S8                   0x00000003
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_L8A8                 0x00000004
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_B2G3R3                       0x00000005
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_B5G6R5                       0x00000006
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_B5G5R5A1                     0x00000007
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_B4G4R4A4                     0x00000008
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_A1B5G5R5                     0x00000009
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_A4B4G4R4                     0x0000000a
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_Z16                  0x0000000b
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_Z16NL                        0x0000000c
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_R8G8B8A8                     0x0000000d
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_B8G8R8A8                     0x0000000e
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_A16_float                    0x0000000f
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_L16_float                    0x00000010
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_L16A16_float                 0x00000011
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_R16G16B16A16_float                   0x00000012
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_R11G11B10_float                      0x00000013
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_P128                 0x00000014
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_P32_float                    0x00000015
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_DXT1                 0x00000016
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_DXT1C                        0x00000017
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_DXT3                 0x00000018
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_DXT5                 0x00000019
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_ETC                  0x0000001a
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_ETC3                 0x0000001b
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_ETC5                 0x0000001c
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_LATC1                        0x0000001d
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_LATC2                        0x0000001e
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_B8G8R8G8                     0x0000001f
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_G8B8G8R8                     0x00000020
#define LWE297_GLOBAL_SURFDESC_3_SURF_FORMAT_R10G10B10_float_A2                   0x00000021

// SC25+ only (ignored in mg20) When this signal is TILED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
#define LWE297_GLOBAL_SURFDESC_3_QUADLIN                           1:1
#define LWE297_GLOBAL_SURFDESC_3_QUADLIN_LINEAR                   0x00000000
#define LWE297_GLOBAL_SURFDESC_3_QUADLIN_TILED                    0x00000001

// The surface should be dithered on write, and undithered on read.
#define LWE297_GLOBAL_SURFDESC_3_DITHER                            0:0
#define LWE297_GLOBAL_SURFDESC_3_DITHER_DISABLE                   0x00000000
#define LWE297_GLOBAL_SURFDESC_3_DITHER_ENABLE                    0x00000001


// Register LWE297_GLOBAL_SURFDESC_4  
#define LWE297_GLOBAL_SURFDESC_4                            0xe14
// page tiling LINEAR   -- no tiling
// TILED    -- tiled by adjusting address:
// XY_TILED -- tiled by adjusting x/y
#define LWE297_GLOBAL_SURFDESC_4_STRUCTURE                         26:25
#define LWE297_GLOBAL_SURFDESC_4_STRUCTURE_LINEAR                 0x00000000
#define LWE297_GLOBAL_SURFDESC_4_STRUCTURE_TILED                  0x00000001
#define LWE297_GLOBAL_SURFDESC_4_STRUCTURE_XY_TILED                       0x00000002

// Array stride in bytes (must be 1d surface)
#define LWE297_GLOBAL_SURFDESC_4_ARRAY_STRIDE                              24:8

// Surface stride in bytes
#define LWE297_GLOBAL_SURFDESC_4_STRIDE                            23:8

// Surface format
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT                               7:2
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_C4X4                 0x00000000
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_A8                   0x00000001
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_L8                   0x00000002
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_S8                   0x00000003
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_L8A8                 0x00000004
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_B2G3R3                       0x00000005
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_B5G6R5                       0x00000006
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_B5G5R5A1                     0x00000007
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_B4G4R4A4                     0x00000008
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_A1B5G5R5                     0x00000009
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_A4B4G4R4                     0x0000000a
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_Z16                  0x0000000b
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_Z16NL                        0x0000000c
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_R8G8B8A8                     0x0000000d
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_B8G8R8A8                     0x0000000e
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_A16_float                    0x0000000f
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_L16_float                    0x00000010
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_L16A16_float                 0x00000011
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_R16G16B16A16_float                   0x00000012
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_R11G11B10_float                      0x00000013
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_P128                 0x00000014
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_P32_float                    0x00000015
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_DXT1                 0x00000016
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_DXT1C                        0x00000017
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_DXT3                 0x00000018
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_DXT5                 0x00000019
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_ETC                  0x0000001a
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_ETC3                 0x0000001b
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_ETC5                 0x0000001c
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_LATC1                        0x0000001d
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_LATC2                        0x0000001e
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_B8G8R8G8                     0x0000001f
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_G8B8G8R8                     0x00000020
#define LWE297_GLOBAL_SURFDESC_4_SURF_FORMAT_R10G10B10_float_A2                   0x00000021

// SC25+ only (ignored in mg20) When this signal is TILED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
#define LWE297_GLOBAL_SURFDESC_4_QUADLIN                           1:1
#define LWE297_GLOBAL_SURFDESC_4_QUADLIN_LINEAR                   0x00000000
#define LWE297_GLOBAL_SURFDESC_4_QUADLIN_TILED                    0x00000001

// The surface should be dithered on write, and undithered on read.
#define LWE297_GLOBAL_SURFDESC_4_DITHER                            0:0
#define LWE297_GLOBAL_SURFDESC_4_DITHER_DISABLE                   0x00000000
#define LWE297_GLOBAL_SURFDESC_4_DITHER_ENABLE                    0x00000001


// Register LWE297_GLOBAL_SURFDESC_5  
#define LWE297_GLOBAL_SURFDESC_5                            0xe15
// page tiling LINEAR   -- no tiling
// TILED    -- tiled by adjusting address:
// XY_TILED -- tiled by adjusting x/y
#define LWE297_GLOBAL_SURFDESC_5_STRUCTURE                         26:25
#define LWE297_GLOBAL_SURFDESC_5_STRUCTURE_LINEAR                 0x00000000
#define LWE297_GLOBAL_SURFDESC_5_STRUCTURE_TILED                  0x00000001
#define LWE297_GLOBAL_SURFDESC_5_STRUCTURE_XY_TILED                       0x00000002

// Array stride in bytes (must be 1d surface)
#define LWE297_GLOBAL_SURFDESC_5_ARRAY_STRIDE                              24:8

// Surface stride in bytes
#define LWE297_GLOBAL_SURFDESC_5_STRIDE                            23:8

// Surface format
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT                               7:2
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_C4X4                 0x00000000
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_A8                   0x00000001
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_L8                   0x00000002
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_S8                   0x00000003
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_L8A8                 0x00000004
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_B2G3R3                       0x00000005
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_B5G6R5                       0x00000006
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_B5G5R5A1                     0x00000007
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_B4G4R4A4                     0x00000008
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_A1B5G5R5                     0x00000009
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_A4B4G4R4                     0x0000000a
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_Z16                  0x0000000b
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_Z16NL                        0x0000000c
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_R8G8B8A8                     0x0000000d
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_B8G8R8A8                     0x0000000e
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_A16_float                    0x0000000f
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_L16_float                    0x00000010
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_L16A16_float                 0x00000011
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_R16G16B16A16_float                   0x00000012
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_R11G11B10_float                      0x00000013
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_P128                 0x00000014
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_P32_float                    0x00000015
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_DXT1                 0x00000016
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_DXT1C                        0x00000017
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_DXT3                 0x00000018
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_DXT5                 0x00000019
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_ETC                  0x0000001a
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_ETC3                 0x0000001b
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_ETC5                 0x0000001c
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_LATC1                        0x0000001d
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_LATC2                        0x0000001e
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_B8G8R8G8                     0x0000001f
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_G8B8G8R8                     0x00000020
#define LWE297_GLOBAL_SURFDESC_5_SURF_FORMAT_R10G10B10_float_A2                   0x00000021

// SC25+ only (ignored in mg20) When this signal is TILED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
#define LWE297_GLOBAL_SURFDESC_5_QUADLIN                           1:1
#define LWE297_GLOBAL_SURFDESC_5_QUADLIN_LINEAR                   0x00000000
#define LWE297_GLOBAL_SURFDESC_5_QUADLIN_TILED                    0x00000001

// The surface should be dithered on write, and undithered on read.
#define LWE297_GLOBAL_SURFDESC_5_DITHER                            0:0
#define LWE297_GLOBAL_SURFDESC_5_DITHER_DISABLE                   0x00000000
#define LWE297_GLOBAL_SURFDESC_5_DITHER_ENABLE                    0x00000001


// Register LWE297_GLOBAL_SURFDESC_6  
#define LWE297_GLOBAL_SURFDESC_6                            0xe16
// page tiling LINEAR   -- no tiling
// TILED    -- tiled by adjusting address:
// XY_TILED -- tiled by adjusting x/y
#define LWE297_GLOBAL_SURFDESC_6_STRUCTURE                         26:25
#define LWE297_GLOBAL_SURFDESC_6_STRUCTURE_LINEAR                 0x00000000
#define LWE297_GLOBAL_SURFDESC_6_STRUCTURE_TILED                  0x00000001
#define LWE297_GLOBAL_SURFDESC_6_STRUCTURE_XY_TILED                       0x00000002

// Array stride in bytes (must be 1d surface)
#define LWE297_GLOBAL_SURFDESC_6_ARRAY_STRIDE                              24:8

// Surface stride in bytes
#define LWE297_GLOBAL_SURFDESC_6_STRIDE                            23:8

// Surface format
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT                               7:2
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_C4X4                 0x00000000
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_A8                   0x00000001
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_L8                   0x00000002
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_S8                   0x00000003
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_L8A8                 0x00000004
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_B2G3R3                       0x00000005
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_B5G6R5                       0x00000006
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_B5G5R5A1                     0x00000007
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_B4G4R4A4                     0x00000008
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_A1B5G5R5                     0x00000009
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_A4B4G4R4                     0x0000000a
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_Z16                  0x0000000b
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_Z16NL                        0x0000000c
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_R8G8B8A8                     0x0000000d
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_B8G8R8A8                     0x0000000e
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_A16_float                    0x0000000f
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_L16_float                    0x00000010
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_L16A16_float                 0x00000011
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_R16G16B16A16_float                   0x00000012
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_R11G11B10_float                      0x00000013
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_P128                 0x00000014
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_P32_float                    0x00000015
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_DXT1                 0x00000016
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_DXT1C                        0x00000017
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_DXT3                 0x00000018
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_DXT5                 0x00000019
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_ETC                  0x0000001a
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_ETC3                 0x0000001b
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_ETC5                 0x0000001c
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_LATC1                        0x0000001d
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_LATC2                        0x0000001e
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_B8G8R8G8                     0x0000001f
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_G8B8G8R8                     0x00000020
#define LWE297_GLOBAL_SURFDESC_6_SURF_FORMAT_R10G10B10_float_A2                   0x00000021

// SC25+ only (ignored in mg20) When this signal is TILED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
#define LWE297_GLOBAL_SURFDESC_6_QUADLIN                           1:1
#define LWE297_GLOBAL_SURFDESC_6_QUADLIN_LINEAR                   0x00000000
#define LWE297_GLOBAL_SURFDESC_6_QUADLIN_TILED                    0x00000001

// The surface should be dithered on write, and undithered on read.
#define LWE297_GLOBAL_SURFDESC_6_DITHER                            0:0
#define LWE297_GLOBAL_SURFDESC_6_DITHER_DISABLE                   0x00000000
#define LWE297_GLOBAL_SURFDESC_6_DITHER_ENABLE                    0x00000001


// Register LWE297_GLOBAL_SURFDESC_7  
#define LWE297_GLOBAL_SURFDESC_7                            0xe17
// page tiling LINEAR   -- no tiling
// TILED    -- tiled by adjusting address:
// XY_TILED -- tiled by adjusting x/y
#define LWE297_GLOBAL_SURFDESC_7_STRUCTURE                         26:25
#define LWE297_GLOBAL_SURFDESC_7_STRUCTURE_LINEAR                 0x00000000
#define LWE297_GLOBAL_SURFDESC_7_STRUCTURE_TILED                  0x00000001
#define LWE297_GLOBAL_SURFDESC_7_STRUCTURE_XY_TILED                       0x00000002

// Array stride in bytes (must be 1d surface)
#define LWE297_GLOBAL_SURFDESC_7_ARRAY_STRIDE                              24:8

// Surface stride in bytes
#define LWE297_GLOBAL_SURFDESC_7_STRIDE                            23:8

// Surface format
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT                               7:2
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_C4X4                 0x00000000
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_A8                   0x00000001
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_L8                   0x00000002
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_S8                   0x00000003
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_L8A8                 0x00000004
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_B2G3R3                       0x00000005
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_B5G6R5                       0x00000006
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_B5G5R5A1                     0x00000007
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_B4G4R4A4                     0x00000008
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_A1B5G5R5                     0x00000009
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_A4B4G4R4                     0x0000000a
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_Z16                  0x0000000b
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_Z16NL                        0x0000000c
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_R8G8B8A8                     0x0000000d
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_B8G8R8A8                     0x0000000e
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_A16_float                    0x0000000f
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_L16_float                    0x00000010
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_L16A16_float                 0x00000011
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_R16G16B16A16_float                   0x00000012
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_R11G11B10_float                      0x00000013
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_P128                 0x00000014
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_P32_float                    0x00000015
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_DXT1                 0x00000016
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_DXT1C                        0x00000017
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_DXT3                 0x00000018
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_DXT5                 0x00000019
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_ETC                  0x0000001a
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_ETC3                 0x0000001b
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_ETC5                 0x0000001c
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_LATC1                        0x0000001d
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_LATC2                        0x0000001e
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_B8G8R8G8                     0x0000001f
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_G8B8G8R8                     0x00000020
#define LWE297_GLOBAL_SURFDESC_7_SURF_FORMAT_R10G10B10_float_A2                   0x00000021

// SC25+ only (ignored in mg20) When this signal is TILED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
#define LWE297_GLOBAL_SURFDESC_7_QUADLIN                           1:1
#define LWE297_GLOBAL_SURFDESC_7_QUADLIN_LINEAR                   0x00000000
#define LWE297_GLOBAL_SURFDESC_7_QUADLIN_TILED                    0x00000001

// The surface should be dithered on write, and undithered on read.
#define LWE297_GLOBAL_SURFDESC_7_DITHER                            0:0
#define LWE297_GLOBAL_SURFDESC_7_DITHER_DISABLE                   0x00000000
#define LWE297_GLOBAL_SURFDESC_7_DITHER_ENABLE                    0x00000001


// Register LWE297_GLOBAL_SURFDESC_8  
#define LWE297_GLOBAL_SURFDESC_8                            0xe18
// page tiling LINEAR   -- no tiling
// TILED    -- tiled by adjusting address:
// XY_TILED -- tiled by adjusting x/y
#define LWE297_GLOBAL_SURFDESC_8_STRUCTURE                         26:25
#define LWE297_GLOBAL_SURFDESC_8_STRUCTURE_LINEAR                 0x00000000
#define LWE297_GLOBAL_SURFDESC_8_STRUCTURE_TILED                  0x00000001
#define LWE297_GLOBAL_SURFDESC_8_STRUCTURE_XY_TILED                       0x00000002

// Array stride in bytes (must be 1d surface)
#define LWE297_GLOBAL_SURFDESC_8_ARRAY_STRIDE                              24:8

// Surface stride in bytes
#define LWE297_GLOBAL_SURFDESC_8_STRIDE                            23:8

// Surface format
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT                               7:2
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_C4X4                 0x00000000
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_A8                   0x00000001
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_L8                   0x00000002
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_S8                   0x00000003
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_L8A8                 0x00000004
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_B2G3R3                       0x00000005
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_B5G6R5                       0x00000006
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_B5G5R5A1                     0x00000007
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_B4G4R4A4                     0x00000008
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_A1B5G5R5                     0x00000009
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_A4B4G4R4                     0x0000000a
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_Z16                  0x0000000b
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_Z16NL                        0x0000000c
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_R8G8B8A8                     0x0000000d
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_B8G8R8A8                     0x0000000e
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_A16_float                    0x0000000f
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_L16_float                    0x00000010
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_L16A16_float                 0x00000011
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_R16G16B16A16_float                   0x00000012
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_R11G11B10_float                      0x00000013
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_P128                 0x00000014
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_P32_float                    0x00000015
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_DXT1                 0x00000016
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_DXT1C                        0x00000017
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_DXT3                 0x00000018
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_DXT5                 0x00000019
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_ETC                  0x0000001a
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_ETC3                 0x0000001b
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_ETC5                 0x0000001c
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_LATC1                        0x0000001d
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_LATC2                        0x0000001e
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_B8G8R8G8                     0x0000001f
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_G8B8G8R8                     0x00000020
#define LWE297_GLOBAL_SURFDESC_8_SURF_FORMAT_R10G10B10_float_A2                   0x00000021

// SC25+ only (ignored in mg20) When this signal is TILED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
#define LWE297_GLOBAL_SURFDESC_8_QUADLIN                           1:1
#define LWE297_GLOBAL_SURFDESC_8_QUADLIN_LINEAR                   0x00000000
#define LWE297_GLOBAL_SURFDESC_8_QUADLIN_TILED                    0x00000001

// The surface should be dithered on write, and undithered on read.
#define LWE297_GLOBAL_SURFDESC_8_DITHER                            0:0
#define LWE297_GLOBAL_SURFDESC_8_DITHER_DISABLE                   0x00000000
#define LWE297_GLOBAL_SURFDESC_8_DITHER_ENABLE                    0x00000001


// Register LWE297_GLOBAL_SURFDESC_9  
#define LWE297_GLOBAL_SURFDESC_9                            0xe19
// page tiling LINEAR   -- no tiling
// TILED    -- tiled by adjusting address:
// XY_TILED -- tiled by adjusting x/y
#define LWE297_GLOBAL_SURFDESC_9_STRUCTURE                         26:25
#define LWE297_GLOBAL_SURFDESC_9_STRUCTURE_LINEAR                 0x00000000
#define LWE297_GLOBAL_SURFDESC_9_STRUCTURE_TILED                  0x00000001
#define LWE297_GLOBAL_SURFDESC_9_STRUCTURE_XY_TILED                       0x00000002

// Array stride in bytes (must be 1d surface)
#define LWE297_GLOBAL_SURFDESC_9_ARRAY_STRIDE                              24:8

// Surface stride in bytes
#define LWE297_GLOBAL_SURFDESC_9_STRIDE                            23:8

// Surface format
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT                               7:2
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_C4X4                 0x00000000
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_A8                   0x00000001
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_L8                   0x00000002
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_S8                   0x00000003
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_L8A8                 0x00000004
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_B2G3R3                       0x00000005
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_B5G6R5                       0x00000006
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_B5G5R5A1                     0x00000007
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_B4G4R4A4                     0x00000008
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_A1B5G5R5                     0x00000009
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_A4B4G4R4                     0x0000000a
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_Z16                  0x0000000b
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_Z16NL                        0x0000000c
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_R8G8B8A8                     0x0000000d
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_B8G8R8A8                     0x0000000e
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_A16_float                    0x0000000f
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_L16_float                    0x00000010
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_L16A16_float                 0x00000011
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_R16G16B16A16_float                   0x00000012
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_R11G11B10_float                      0x00000013
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_P128                 0x00000014
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_P32_float                    0x00000015
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_DXT1                 0x00000016
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_DXT1C                        0x00000017
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_DXT3                 0x00000018
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_DXT5                 0x00000019
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_ETC                  0x0000001a
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_ETC3                 0x0000001b
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_ETC5                 0x0000001c
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_LATC1                        0x0000001d
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_LATC2                        0x0000001e
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_B8G8R8G8                     0x0000001f
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_G8B8G8R8                     0x00000020
#define LWE297_GLOBAL_SURFDESC_9_SURF_FORMAT_R10G10B10_float_A2                   0x00000021

// SC25+ only (ignored in mg20) When this signal is TILED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
#define LWE297_GLOBAL_SURFDESC_9_QUADLIN                           1:1
#define LWE297_GLOBAL_SURFDESC_9_QUADLIN_LINEAR                   0x00000000
#define LWE297_GLOBAL_SURFDESC_9_QUADLIN_TILED                    0x00000001

// The surface should be dithered on write, and undithered on read.
#define LWE297_GLOBAL_SURFDESC_9_DITHER                            0:0
#define LWE297_GLOBAL_SURFDESC_9_DITHER_DISABLE                   0x00000000
#define LWE297_GLOBAL_SURFDESC_9_DITHER_ENABLE                    0x00000001


// Register LWE297_GLOBAL_SURFDESC_10  
#define LWE297_GLOBAL_SURFDESC_10                           0xe1a
// page tiling LINEAR   -- no tiling
// TILED    -- tiled by adjusting address:
// XY_TILED -- tiled by adjusting x/y
#define LWE297_GLOBAL_SURFDESC_10_STRUCTURE                        26:25
#define LWE297_GLOBAL_SURFDESC_10_STRUCTURE_LINEAR                        0x00000000
#define LWE297_GLOBAL_SURFDESC_10_STRUCTURE_TILED                 0x00000001
#define LWE297_GLOBAL_SURFDESC_10_STRUCTURE_XY_TILED                      0x00000002

// Array stride in bytes (must be 1d surface)
#define LWE297_GLOBAL_SURFDESC_10_ARRAY_STRIDE                             24:8

// Surface stride in bytes
#define LWE297_GLOBAL_SURFDESC_10_STRIDE                           23:8

// Surface format
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT                              7:2
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_C4X4                        0x00000000
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_A8                  0x00000001
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_L8                  0x00000002
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_S8                  0x00000003
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_L8A8                        0x00000004
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_B2G3R3                      0x00000005
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_B5G6R5                      0x00000006
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_B5G5R5A1                    0x00000007
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_B4G4R4A4                    0x00000008
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_A1B5G5R5                    0x00000009
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_A4B4G4R4                    0x0000000a
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_Z16                 0x0000000b
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_Z16NL                       0x0000000c
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_R8G8B8A8                    0x0000000d
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_B8G8R8A8                    0x0000000e
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_A16_float                   0x0000000f
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_L16_float                   0x00000010
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_L16A16_float                        0x00000011
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_R16G16B16A16_float                  0x00000012
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_R11G11B10_float                     0x00000013
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_P128                        0x00000014
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_P32_float                   0x00000015
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_DXT1                        0x00000016
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_DXT1C                       0x00000017
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_DXT3                        0x00000018
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_DXT5                        0x00000019
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_ETC                 0x0000001a
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_ETC3                        0x0000001b
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_ETC5                        0x0000001c
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_LATC1                       0x0000001d
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_LATC2                       0x0000001e
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_B8G8R8G8                    0x0000001f
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_G8B8G8R8                    0x00000020
#define LWE297_GLOBAL_SURFDESC_10_SURF_FORMAT_R10G10B10_float_A2                  0x00000021

// SC25+ only (ignored in mg20) When this signal is TILED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
#define LWE297_GLOBAL_SURFDESC_10_QUADLIN                          1:1
#define LWE297_GLOBAL_SURFDESC_10_QUADLIN_LINEAR                  0x00000000
#define LWE297_GLOBAL_SURFDESC_10_QUADLIN_TILED                   0x00000001

// The surface should be dithered on write, and undithered on read.
#define LWE297_GLOBAL_SURFDESC_10_DITHER                           0:0
#define LWE297_GLOBAL_SURFDESC_10_DITHER_DISABLE                  0x00000000
#define LWE297_GLOBAL_SURFDESC_10_DITHER_ENABLE                   0x00000001


// Register LWE297_GLOBAL_SURFDESC_11  
#define LWE297_GLOBAL_SURFDESC_11                           0xe1b
// page tiling LINEAR   -- no tiling
// TILED    -- tiled by adjusting address:
// XY_TILED -- tiled by adjusting x/y
#define LWE297_GLOBAL_SURFDESC_11_STRUCTURE                        26:25
#define LWE297_GLOBAL_SURFDESC_11_STRUCTURE_LINEAR                        0x00000000
#define LWE297_GLOBAL_SURFDESC_11_STRUCTURE_TILED                 0x00000001
#define LWE297_GLOBAL_SURFDESC_11_STRUCTURE_XY_TILED                      0x00000002

// Array stride in bytes (must be 1d surface)
#define LWE297_GLOBAL_SURFDESC_11_ARRAY_STRIDE                             24:8

// Surface stride in bytes
#define LWE297_GLOBAL_SURFDESC_11_STRIDE                           23:8

// Surface format
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT                              7:2
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_C4X4                        0x00000000
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_A8                  0x00000001
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_L8                  0x00000002
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_S8                  0x00000003
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_L8A8                        0x00000004
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_B2G3R3                      0x00000005
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_B5G6R5                      0x00000006
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_B5G5R5A1                    0x00000007
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_B4G4R4A4                    0x00000008
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_A1B5G5R5                    0x00000009
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_A4B4G4R4                    0x0000000a
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_Z16                 0x0000000b
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_Z16NL                       0x0000000c
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_R8G8B8A8                    0x0000000d
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_B8G8R8A8                    0x0000000e
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_A16_float                   0x0000000f
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_L16_float                   0x00000010
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_L16A16_float                        0x00000011
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_R16G16B16A16_float                  0x00000012
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_R11G11B10_float                     0x00000013
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_P128                        0x00000014
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_P32_float                   0x00000015
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_DXT1                        0x00000016
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_DXT1C                       0x00000017
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_DXT3                        0x00000018
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_DXT5                        0x00000019
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_ETC                 0x0000001a
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_ETC3                        0x0000001b
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_ETC5                        0x0000001c
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_LATC1                       0x0000001d
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_LATC2                       0x0000001e
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_B8G8R8G8                    0x0000001f
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_G8B8G8R8                    0x00000020
#define LWE297_GLOBAL_SURFDESC_11_SURF_FORMAT_R10G10B10_float_A2                  0x00000021

// SC25+ only (ignored in mg20) When this signal is TILED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
#define LWE297_GLOBAL_SURFDESC_11_QUADLIN                          1:1
#define LWE297_GLOBAL_SURFDESC_11_QUADLIN_LINEAR                  0x00000000
#define LWE297_GLOBAL_SURFDESC_11_QUADLIN_TILED                   0x00000001

// The surface should be dithered on write, and undithered on read.
#define LWE297_GLOBAL_SURFDESC_11_DITHER                           0:0
#define LWE297_GLOBAL_SURFDESC_11_DITHER_DISABLE                  0x00000000
#define LWE297_GLOBAL_SURFDESC_11_DITHER_ENABLE                   0x00000001


// Register LWE297_GLOBAL_SURFDESC_12  
#define LWE297_GLOBAL_SURFDESC_12                           0xe1c
// page tiling LINEAR   -- no tiling
// TILED    -- tiled by adjusting address:
// XY_TILED -- tiled by adjusting x/y
#define LWE297_GLOBAL_SURFDESC_12_STRUCTURE                        26:25
#define LWE297_GLOBAL_SURFDESC_12_STRUCTURE_LINEAR                        0x00000000
#define LWE297_GLOBAL_SURFDESC_12_STRUCTURE_TILED                 0x00000001
#define LWE297_GLOBAL_SURFDESC_12_STRUCTURE_XY_TILED                      0x00000002

// Array stride in bytes (must be 1d surface)
#define LWE297_GLOBAL_SURFDESC_12_ARRAY_STRIDE                             24:8

// Surface stride in bytes
#define LWE297_GLOBAL_SURFDESC_12_STRIDE                           23:8

// Surface format
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT                              7:2
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_C4X4                        0x00000000
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_A8                  0x00000001
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_L8                  0x00000002
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_S8                  0x00000003
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_L8A8                        0x00000004
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_B2G3R3                      0x00000005
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_B5G6R5                      0x00000006
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_B5G5R5A1                    0x00000007
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_B4G4R4A4                    0x00000008
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_A1B5G5R5                    0x00000009
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_A4B4G4R4                    0x0000000a
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_Z16                 0x0000000b
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_Z16NL                       0x0000000c
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_R8G8B8A8                    0x0000000d
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_B8G8R8A8                    0x0000000e
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_A16_float                   0x0000000f
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_L16_float                   0x00000010
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_L16A16_float                        0x00000011
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_R16G16B16A16_float                  0x00000012
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_R11G11B10_float                     0x00000013
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_P128                        0x00000014
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_P32_float                   0x00000015
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_DXT1                        0x00000016
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_DXT1C                       0x00000017
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_DXT3                        0x00000018
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_DXT5                        0x00000019
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_ETC                 0x0000001a
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_ETC3                        0x0000001b
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_ETC5                        0x0000001c
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_LATC1                       0x0000001d
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_LATC2                       0x0000001e
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_B8G8R8G8                    0x0000001f
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_G8B8G8R8                    0x00000020
#define LWE297_GLOBAL_SURFDESC_12_SURF_FORMAT_R10G10B10_float_A2                  0x00000021

// SC25+ only (ignored in mg20) When this signal is TILED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
#define LWE297_GLOBAL_SURFDESC_12_QUADLIN                          1:1
#define LWE297_GLOBAL_SURFDESC_12_QUADLIN_LINEAR                  0x00000000
#define LWE297_GLOBAL_SURFDESC_12_QUADLIN_TILED                   0x00000001

// The surface should be dithered on write, and undithered on read.
#define LWE297_GLOBAL_SURFDESC_12_DITHER                           0:0
#define LWE297_GLOBAL_SURFDESC_12_DITHER_DISABLE                  0x00000000
#define LWE297_GLOBAL_SURFDESC_12_DITHER_ENABLE                   0x00000001


// Register LWE297_GLOBAL_SURFDESC_13  
#define LWE297_GLOBAL_SURFDESC_13                           0xe1d
// page tiling LINEAR   -- no tiling
// TILED    -- tiled by adjusting address:
// XY_TILED -- tiled by adjusting x/y
#define LWE297_GLOBAL_SURFDESC_13_STRUCTURE                        26:25
#define LWE297_GLOBAL_SURFDESC_13_STRUCTURE_LINEAR                        0x00000000
#define LWE297_GLOBAL_SURFDESC_13_STRUCTURE_TILED                 0x00000001
#define LWE297_GLOBAL_SURFDESC_13_STRUCTURE_XY_TILED                      0x00000002

// Array stride in bytes (must be 1d surface)
#define LWE297_GLOBAL_SURFDESC_13_ARRAY_STRIDE                             24:8

// Surface stride in bytes
#define LWE297_GLOBAL_SURFDESC_13_STRIDE                           23:8

// Surface format
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT                              7:2
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_C4X4                        0x00000000
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_A8                  0x00000001
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_L8                  0x00000002
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_S8                  0x00000003
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_L8A8                        0x00000004
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_B2G3R3                      0x00000005
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_B5G6R5                      0x00000006
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_B5G5R5A1                    0x00000007
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_B4G4R4A4                    0x00000008
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_A1B5G5R5                    0x00000009
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_A4B4G4R4                    0x0000000a
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_Z16                 0x0000000b
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_Z16NL                       0x0000000c
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_R8G8B8A8                    0x0000000d
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_B8G8R8A8                    0x0000000e
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_A16_float                   0x0000000f
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_L16_float                   0x00000010
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_L16A16_float                        0x00000011
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_R16G16B16A16_float                  0x00000012
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_R11G11B10_float                     0x00000013
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_P128                        0x00000014
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_P32_float                   0x00000015
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_DXT1                        0x00000016
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_DXT1C                       0x00000017
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_DXT3                        0x00000018
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_DXT5                        0x00000019
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_ETC                 0x0000001a
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_ETC3                        0x0000001b
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_ETC5                        0x0000001c
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_LATC1                       0x0000001d
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_LATC2                       0x0000001e
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_B8G8R8G8                    0x0000001f
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_G8B8G8R8                    0x00000020
#define LWE297_GLOBAL_SURFDESC_13_SURF_FORMAT_R10G10B10_float_A2                  0x00000021

// SC25+ only (ignored in mg20) When this signal is TILED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
#define LWE297_GLOBAL_SURFDESC_13_QUADLIN                          1:1
#define LWE297_GLOBAL_SURFDESC_13_QUADLIN_LINEAR                  0x00000000
#define LWE297_GLOBAL_SURFDESC_13_QUADLIN_TILED                   0x00000001

// The surface should be dithered on write, and undithered on read.
#define LWE297_GLOBAL_SURFDESC_13_DITHER                           0:0
#define LWE297_GLOBAL_SURFDESC_13_DITHER_DISABLE                  0x00000000
#define LWE297_GLOBAL_SURFDESC_13_DITHER_ENABLE                   0x00000001


// Register LWE297_GLOBAL_SURFDESC_14  
#define LWE297_GLOBAL_SURFDESC_14                           0xe1e
// page tiling LINEAR   -- no tiling
// TILED    -- tiled by adjusting address:
// XY_TILED -- tiled by adjusting x/y
#define LWE297_GLOBAL_SURFDESC_14_STRUCTURE                        26:25
#define LWE297_GLOBAL_SURFDESC_14_STRUCTURE_LINEAR                        0x00000000
#define LWE297_GLOBAL_SURFDESC_14_STRUCTURE_TILED                 0x00000001
#define LWE297_GLOBAL_SURFDESC_14_STRUCTURE_XY_TILED                      0x00000002

// Array stride in bytes (must be 1d surface)
#define LWE297_GLOBAL_SURFDESC_14_ARRAY_STRIDE                             24:8

// Surface stride in bytes
#define LWE297_GLOBAL_SURFDESC_14_STRIDE                           23:8

// Surface format
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT                              7:2
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_C4X4                        0x00000000
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_A8                  0x00000001
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_L8                  0x00000002
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_S8                  0x00000003
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_L8A8                        0x00000004
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_B2G3R3                      0x00000005
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_B5G6R5                      0x00000006
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_B5G5R5A1                    0x00000007
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_B4G4R4A4                    0x00000008
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_A1B5G5R5                    0x00000009
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_A4B4G4R4                    0x0000000a
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_Z16                 0x0000000b
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_Z16NL                       0x0000000c
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_R8G8B8A8                    0x0000000d
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_B8G8R8A8                    0x0000000e
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_A16_float                   0x0000000f
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_L16_float                   0x00000010
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_L16A16_float                        0x00000011
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_R16G16B16A16_float                  0x00000012
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_R11G11B10_float                     0x00000013
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_P128                        0x00000014
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_P32_float                   0x00000015
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_DXT1                        0x00000016
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_DXT1C                       0x00000017
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_DXT3                        0x00000018
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_DXT5                        0x00000019
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_ETC                 0x0000001a
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_ETC3                        0x0000001b
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_ETC5                        0x0000001c
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_LATC1                       0x0000001d
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_LATC2                       0x0000001e
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_B8G8R8G8                    0x0000001f
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_G8B8G8R8                    0x00000020
#define LWE297_GLOBAL_SURFDESC_14_SURF_FORMAT_R10G10B10_float_A2                  0x00000021

// SC25+ only (ignored in mg20) When this signal is TILED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
#define LWE297_GLOBAL_SURFDESC_14_QUADLIN                          1:1
#define LWE297_GLOBAL_SURFDESC_14_QUADLIN_LINEAR                  0x00000000
#define LWE297_GLOBAL_SURFDESC_14_QUADLIN_TILED                   0x00000001

// The surface should be dithered on write, and undithered on read.
#define LWE297_GLOBAL_SURFDESC_14_DITHER                           0:0
#define LWE297_GLOBAL_SURFDESC_14_DITHER_DISABLE                  0x00000000
#define LWE297_GLOBAL_SURFDESC_14_DITHER_ENABLE                   0x00000001


// Register LWE297_GLOBAL_SURFDESC_15  
#define LWE297_GLOBAL_SURFDESC_15                           0xe1f
// page tiling LINEAR   -- no tiling
// TILED    -- tiled by adjusting address:
// XY_TILED -- tiled by adjusting x/y
#define LWE297_GLOBAL_SURFDESC_15_STRUCTURE                        26:25
#define LWE297_GLOBAL_SURFDESC_15_STRUCTURE_LINEAR                        0x00000000
#define LWE297_GLOBAL_SURFDESC_15_STRUCTURE_TILED                 0x00000001
#define LWE297_GLOBAL_SURFDESC_15_STRUCTURE_XY_TILED                      0x00000002

// Array stride in bytes (must be 1d surface)
#define LWE297_GLOBAL_SURFDESC_15_ARRAY_STRIDE                             24:8

// Surface stride in bytes
#define LWE297_GLOBAL_SURFDESC_15_STRIDE                           23:8

// Surface format
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT                              7:2
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_C4X4                        0x00000000
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_A8                  0x00000001
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_L8                  0x00000002
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_S8                  0x00000003
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_L8A8                        0x00000004
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_B2G3R3                      0x00000005
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_B5G6R5                      0x00000006
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_B5G5R5A1                    0x00000007
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_B4G4R4A4                    0x00000008
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_A1B5G5R5                    0x00000009
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_A4B4G4R4                    0x0000000a
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_Z16                 0x0000000b
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_Z16NL                       0x0000000c
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_R8G8B8A8                    0x0000000d
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_B8G8R8A8                    0x0000000e
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_A16_float                   0x0000000f
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_L16_float                   0x00000010
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_L16A16_float                        0x00000011
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_R16G16B16A16_float                  0x00000012
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_R11G11B10_float                     0x00000013
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_P128                        0x00000014
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_P32_float                   0x00000015
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_DXT1                        0x00000016
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_DXT1C                       0x00000017
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_DXT3                        0x00000018
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_DXT5                        0x00000019
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_ETC                 0x0000001a
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_ETC3                        0x0000001b
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_ETC5                        0x0000001c
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_LATC1                       0x0000001d
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_LATC2                       0x0000001e
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_B8G8R8G8                    0x0000001f
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_G8B8G8R8                    0x00000020
#define LWE297_GLOBAL_SURFDESC_15_SURF_FORMAT_R10G10B10_float_A2                  0x00000021

// SC25+ only (ignored in mg20) When this signal is TILED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
#define LWE297_GLOBAL_SURFDESC_15_QUADLIN                          1:1
#define LWE297_GLOBAL_SURFDESC_15_QUADLIN_LINEAR                  0x00000000
#define LWE297_GLOBAL_SURFDESC_15_QUADLIN_TILED                   0x00000001

// The surface should be dithered on write, and undithered on read.
#define LWE297_GLOBAL_SURFDESC_15_DITHER                           0:0
#define LWE297_GLOBAL_SURFDESC_15_DITHER_DISABLE                  0x00000000
#define LWE297_GLOBAL_SURFDESC_15_DITHER_ENABLE                   0x00000001

// Notes on PIX_ATTR
// Specifies First Sequence, Num Rows, Max Quad Id
// This register must be programmed correctly
// before any pixels enter the pipeline.  The FIRST_SEQUENCE
// is only used when in passthrough mode (LWE297_PSEQ_CTL.fMAX_OUT==0)
// otherwise the FIRST_SEQUENCE comes from the LWE297_PSEQ_COMMAND table

// Register LWE297_GLOBAL_PIX_ATTR_0  
#define LWE297_GLOBAL_PIX_ATTR_0                            0xe20
// Set the number of rows minus 1 that RS will
// populate in the RAST_R packet (i.e. setting
// to 0 indicates 1 row).  Up to 4 rows are
// allowed
#define LWE297_GLOBAL_PIX_ATTR_0_NUM_ROWS                          1:0

// first sequence number for a program
#define LWE297_GLOBAL_PIX_ATTR_0_FIRST_SEQUENCE                            13:8

// max quad_id
// What point do we wrap the QID values generated by
// pseq (in quads so the size of the field is
// LW_MAX_FRAGMENT_LOOP_DEPTH_LOG2-2)
// For best performance this should set to follow this rule:
// MAX_QID >= (PSEQ_CTL.MAX_OUT - 1) / (4 * (PIX_ATTR.NUM_ROWS + 1))
// Larger MAX_QID values will require larger P32_float 
// or P128 surface array_strides.  See SURFDESC's 
// ARRAY_STRIDE field.  
// If lowering the value of this field, LWE297_PSEQ_QUAD_ID register 
// must be written to 0.
#define LWE297_GLOBAL_PIX_ATTR_0_MAX_QID                           31:24

//
// NUM_TRIS and TRI_ROWS control the organization of the TRAM, which is used to pass attributes to
// the fragment shader.  NUM_TRIS indicates the maximum number of conlwrrent triangles permitted in the fragment pipe.
// The more, the better for performance.  TRI_ROWS indicates the number of TRAM rows per triangle.  Constraints.
// 1. NUM_TRIS * TRI_ROWS <= LW_GR3D_TRAM_ROWS
// 2. NUM_TRIS >= 2  (i.e., two or more triangles in flight)
// 3. TRI_ROWS > 0
//
// This register cannot be changed while pixels are in flight in the pixel pipe.
// a RAISE/WAIT or SYNCPT.RD_DONE before changing this register will be sufficient.
// see bugid: 309929

// Register LWE297_GLOBAL_TRI_ATTR_0  
#define LWE297_GLOBAL_TRI_ATTR_0                            0xe21
// number of triangles in ATRAST triangle RAM
// (max LW_GR3D_TRAM_ROWS)
#define LWE297_GLOBAL_TRI_ATTR_0_NUM_TRIS                          6:0

// number of rows per triangle in triangle RAM
// (max floor(LW_GR3D_TRAM_ROWS/NUM_TRIS))
#define LWE297_GLOBAL_TRI_ATTR_0_TRI_ROWS                          14:8

//
// INST_OFFSET
//   this instruction indecates the offset PSEQ_INST_OFFSET,
//   ATRAST_REMAP_OFFSET, TEX_INST_OFFSET, ALU_REMAP_OFFSET,
//   P2CX_OFFSET, and DW_INST_OFFSET (measured in sequence numbers)
//
//   because this is in sequence numbers instead of words there is
//   an adjustement based on the size of the unit's instructions
//   PSEQ_INST_OFFSET = INST_OFFSET * LW_GR3D_PIXPKT_PSEQ_INST_NUM_WORDS
//   AT_REMAP_OFSET   = INST_OFFSET * LW_GR3D_PIXPKT_INST_NUM_WORDS
//   TEX_INST_OFFSET  = INST_OFFSET * LW_GR3D_PIXPKT_TEX_INST_NUM_WORDS
//   ALU_REMAP_OFSET  = INST_OFFSET * LW_GR3D_PIXPKT_INST_NUM_WORDS
//   DW_INST_OFFSET   = INST_OFFSET * LW_GR3D_PIXPKT_DW_INST_NUM_WORDS
//   P2CX_OFFSET      = INST_OFFSET * LW_GR3D_PIXPKT_P2CX_INST_NUM_WORDS

// Register LWE297_GLOBAL_INST_OFFSET_0  
#define LWE297_GLOBAL_INST_OFFSET_0                                 0xe22
// Sequence Offset
#define LWE297_GLOBAL_INST_OFFSET_0_INDEX                          5:0

// RAISE method, software now updates this directly (no more RAISE packet)
// When the host sees a raise returned from 3d, all of 3d's read and write memory
// accesses before the raise have finished.

// Register LWE297_GLOBAL_RAISE_0  
#define LWE297_GLOBAL_RAISE_0                               0xe23
// GK Module Latches SIGNAL value on its final loop
// through the pipeline to send to Host module
#define LWE297_GLOBAL_RAISE_0_SIGNAL                               4:0

// channel ID to send raise to
#define LWE297_GLOBAL_RAISE_0_CHANNEL                              11:8

#define LWE297_GLOBAL_RAISE_0_SYNCPT_INCR                          31:31
#define LWE297_GLOBAL_RAISE_0_SYNCPT_INCR_DISABLE                 0x00000000
#define LWE297_GLOBAL_RAISE_0_SYNCPT_INCR_ENABLE                  0x00000001

// REFCNT method, software updates this directly
// When the host sees a refcnt returned from 3d, all of 3d's memory read memory
// accesses have finished.

// Register LWE297_GLOBAL_REFCNT_0  
#define LWE297_GLOBAL_REFCNT_0                              0xe24
// GK Module Latches VALUE on its final loop and updates the host
#define LWE297_GLOBAL_REFCNT_0_VALUE                               31:0

#define LWE297_GLOBAL_REFCNT_0_SYNCPT_INCR                         31:31
#define LWE297_GLOBAL_REFCNT_0_SYNCPT_INCR_DISABLE                        0x00000000
#define LWE297_GLOBAL_REFCNT_0_SYNCPT_INCR_ENABLE                 0x00000001

// statistics enable method (gates stat collection as it flows down the pipeline)

// Register LWE297_GLOBAL_INSTRUMENT_0  
#define LWE297_GLOBAL_INSTRUMENT_0                                  0xe25
// Enables Performance Monitoring
#define LWE297_GLOBAL_INSTRUMENT_0_STAT_EN                         0:0

//
// DITHER: This is a dither tables
// shared between pseq and dw. 
// pseq uses the table to undither surfaces that
// have DITHER == ENABLE, and dw uses the table to dither surfaces that
// have DITHER == ENABLE.
// The values in the table are setup for 8->5 bit colwersions (really N->(N-3)):
//
//  76543210 <-- 8-bit value
// +     210 <-- dither value
//  --------
//  43210    <-- 5-bit result (truncated)
//
// 8->6 colwersions look like:
//
//  76543210 <-- 8-bit value
// +      21 <-- dither value >> 1
//  --------
//  543210   <-- 6-bit result (truncated)
//
// in addition, in order to spread the energy of the dither pattern around, each
// component (R, G, B, A) uses a translated version of the dither table:
//
// R : dither[(x & 1)][(y & 1)]
// G : dither[((x + 1) & 1)][(y & 1)]
// B : dither[(x & 1)][((y + 1) & 1)]
// A : dither[((x + 1) & 1)][((y + 1) & 1)]
//
// DW and PSEQ interpret the lookup table entries as signed values biased by +4 -- they subtract
// 4 from the table entry to yield a dither value in [-4,3].
// DW adds this value to perform dither, while PSEQ performs an undither
// operation by subtracting the same value.
// Note that undithering needs to clamp results to the legal range of values [0..1].
//

// Register LWE297_GLOBAL_DITHER_TABLE_0  // X_Y
#define LWE297_GLOBAL_DITHER_TABLE_0                                0xe26
// should color writes dither result alpha (only useful for dest alpha)?
#define LWE297_GLOBAL_DITHER_TABLE_0_DITHER_ALPHA                          12:12
#define LWE297_GLOBAL_DITHER_TABLE_0_DITHER_ALPHA_DISABLE                 0x00000000
#define LWE297_GLOBAL_DITHER_TABLE_0_DITHER_ALPHA_ENABLE                  0x00000001

// dither value at x+1,y+1
#define LWE297_GLOBAL_DITHER_TABLE_0_ONE_ONE                               11:9

// dither value at x+1,y+0
#define LWE297_GLOBAL_DITHER_TABLE_0_ONE_ZERO                              8:6

// dither value at x+0,y+1
#define LWE297_GLOBAL_DITHER_TABLE_0_ZERO_ONE                              5:3

// dither value at x+0,y+0
#define LWE297_GLOBAL_DITHER_TABLE_0_ZERO_ZERO                             2:0

//To flush the texture cache
//This can be done a couple of ways.
//1. Will be flushed if below FLUSH register is written to with a 1.
//2. Any write to the texture surface descriptor table (TEXDESC) will also cause a flush
//3. Any write to the texture surface address table (TEXADDR) will also cause a flush
//4. Also the cache will be disabled(continuously flushed) if texctl is set to LWE297_TEX_TEXCTL_0_TEXTURE_CACHE_EN_DISABLE
//
// Note: the FLUSH.TEXTURE bit is a 1-shot: After setting it to 1, it doesn't
//       have to be manually reset to 0
//
// FLUSH.QRAST is a setting which is generated and consumed in QRAST.  It is used to make sure
// that QRAST is not holding onto a triangle ID for a triangle which has been entirely killed.
// Note that QRAST consumes all FLUSH packets that have this bit set.

// Register LWE297_GLOBAL_FLUSH_0  
#define LWE297_GLOBAL_FLUSH_0                               0xe27
// Explicitly flush the texture cache.
#define LWE297_GLOBAL_FLUSH_0_TEXTURE                              0:0

// Internally generated/consumed packet in qrast to flush out TIDs.
#define LWE297_GLOBAL_FLUSH_0_QRAST                        1:1

// This packet is used in DW and QRAST to define the stencil operation.

// Packet STENCIL_OP
#define STENCIL_OP_SIZE 3

#define STENCIL_OP_OP_ROW                       0
#define STENCIL_OP_OP_ZERO                      0x00000000
#define STENCIL_OP_OP_KEEP                      0x00000001
#define STENCIL_OP_OP_REPLACE                   0x00000002
#define STENCIL_OP_OP_INCR                      0x00000003
#define STENCIL_OP_OP_DECR                      0x00000004
#define STENCIL_OP_OP_ILWERT                    0x00000005
#define STENCIL_OP_OP_INCR_WRAP                 0x00000006
#define STENCIL_OP_OP_DECR_WRAP                 0x00000007

// S_OPERATION defines the stencil surface and the associated stencil
// update operations.  For stencil operations, we need two entries.  The
// first entry is for front facing triangles.  The second entry is
// for back facing triangles.  Most of this packet is used by DW and RAST
// in AR20.  S_FAIL, Z_FAIL, and ZPASS are per-face and come from StencilOp()
// S_WR_MASK, also per face, comes from StencilMask().  S_REF is the per
// face value from StencilFunc().

// Register LWE297_GLOBAL_S_OPERATION_0  
#define LWE297_GLOBAL_S_OPERATION_0                                 0xe28
//stencil op when the pixel is in S_FAIL state
#define LWE297_GLOBAL_S_OPERATION_0_S_FAIL                         2:0

//stencil op when the pixel is in Z_FAIL state
#define LWE297_GLOBAL_S_OPERATION_0_Z_FAIL                         5:3

//stencil op when the pixel is in Z_PASS state
#define LWE297_GLOBAL_S_OPERATION_0_Z_PASS                         8:6

//stencil write mask (8 bits)
#define LWE297_GLOBAL_S_OPERATION_0_S_WR_MASK                              16:9

//stencil reference (8 bits)
#define LWE297_GLOBAL_S_OPERATION_0_S_REF                          24:17


// Register LWE297_GLOBAL_S_OPERATION  
#define LWE297_GLOBAL_S_OPERATION                           0xe28
//stencil op when the pixel is in S_FAIL state
#define LWE297_GLOBAL_S_OPERATION_S_FAIL                           2:0

//stencil op when the pixel is in Z_FAIL state
#define LWE297_GLOBAL_S_OPERATION_Z_FAIL                           5:3

//stencil op when the pixel is in Z_PASS state
#define LWE297_GLOBAL_S_OPERATION_Z_PASS                           8:6

//stencil write mask (8 bits)
#define LWE297_GLOBAL_S_OPERATION_S_WR_MASK                        16:9

//stencil reference (8 bits)
#define LWE297_GLOBAL_S_OPERATION_S_REF                            24:17


// Register LWE297_GLOBAL_S_OPERATION_1  
#define LWE297_GLOBAL_S_OPERATION_1                                 0xe29
//stencil op when the pixel is in S_FAIL state
#define LWE297_GLOBAL_S_OPERATION_1_S_FAIL                         2:0

//stencil op when the pixel is in Z_FAIL state
#define LWE297_GLOBAL_S_OPERATION_1_Z_FAIL                         5:3

//stencil op when the pixel is in Z_PASS state
#define LWE297_GLOBAL_S_OPERATION_1_Z_PASS                         8:6

//stencil write mask (8 bits)
#define LWE297_GLOBAL_S_OPERATION_1_S_WR_MASK                              16:9

//stencil reference (8 bits)
#define LWE297_GLOBAL_S_OPERATION_1_S_REF                          24:17

// SPILLSURFADDR contains the base address of a pixel spill surface
// pseq's command EXECUTE.SPILL will use this surface to temporarily store
// pixels data while the fragment pipe is reloaded with instruction data.
//
// The pixel spill surface should be large enough to hold all the packets
// in the pipeline.  Each packet uses 16 bytes, and  the number of packets
// allowed in the pipeline is determined by the LWE297_PSEQ_CTL register
// Total size in bytes = ((LWE297_PSEQ_CTL.MAX_OUT + 17) * 16)

// Register LWE297_GLOBAL_SPILLSURFADDR_0  
#define LWE297_GLOBAL_SPILLSURFADDR_0                               0xe2a
// This spill surface base address must be aligned to LW_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES
// Address map is described in project_<project>.spec.
// For example, MG20's address map is described in project_mg20.spec
// LW_GR3D_SURF_ADDRESS_ALIGNMENT_FAST_BYTES alignment will provide better performance, but less flexibility
#define LWE297_GLOBAL_SPILLSURFADDR_0_BASE_ADDRESS                         31:0

//
// Memory Client Interface Async Fifo Optimization Register
// This can only be changed while the pipeline is completely idle.
//
// Memory Client Interface Fifo Control Register.
// The registers below allow to optimize the synchronization timing in
// the memory client asynchronous fifos. When they can be used depend on
// the client and memory controller clock ratio.
// Additionally, the RDMC_RDFAST/RDCL_RDFAST fields can increase power
// consumption if the asynchronous fifo is implemented as a real ram.
// There is no power impact on latch-based fifos. Flipflop-based fifos
// do not use these fields.
// See recommended settings below.
//
// !! IMPORTANT !!
// The register fields can only be changed when the memory client async
// fifos are empty.
//
// The register field ending with WRCL_MCLE2X (if any) can be set to improve
// async fifo synchronization on the write side by one client clock cycle if
// the memory controller clock frequency is less or equal to twice the client
// clock frequency:
//
//      mcclk_freq <= 2 * clientclk_freq
//
// The register field ending with WRMC_CLLE2X (if any) can be set to improve
// async fifo synchronization on the write side by one memory controller clock
// cycle if the client clock frequency is less or equal to twice the memory
// controller clock frequency:
//
//      clientclk_freq <= 2 * mcclk_freq
//
// The register field ending with RDMC_RDFAST (if any) can be set to improve async
// fifo synchronization on the read side by one memory controller clock cycle.
//
// !! WARNING !!
// RDMC_RDFAST can be used along with WRCL_MCLE2X only when:
//
//       mcclk_freq <= clientclk_freq
//
// The register field ending with RDCL_RDFAST (if any) can be set to improve async
// fifo synchronization on the read side by one client clock cycle.
//
// !! WARNING !!
// RDCL_RDFAST can be used along with WRMC_CLLE2X only when:
//
//       clientclk_freq <= mcclk_freq
//
// RECOMMENDED SETTINGS
// # Client writing to fifo, memory controller reading from fifo
// - mcclk_freq <= clientclk_freq
//     You can enable both RDMC_RDFAST and WRCL_CLLE2X. If one of the fifos is
//     a real ram and power is a concern, you should avoid enabling RDMC_RDFAST.
// - clientclk_freq < mcclk_freq <= 2 * clientclk_freq
//     You can enable RDMC_RDFAST or WRCL_MCLE2X, but because the client clock
//     is slower, you should enable only WRCL_MCLE2X.
// - 2 * clientclk_freq < mcclk_freq
//     You can only enable RDMC_RDFAST. If one of the fifos is a real ram and
//     power is a concern, you should avoid enabling RDMC_RDFAST.
//
// # Memory controller writing to fifo, client reading from fifo
// - clientclk_freq <= mcclk_freq
//     You can enable both RDCL_RDFAST and WRMC_CLLE2X. If one of the fifos is
//     a real ram and power is a concern, you should avoid enabling RDCL_RDFAST.
// - mcclk_freq < clientclk_freq <= 2 * mcclk_freq
//     You can enable RDCL_RDFAST or WRMC_CLLE2X, but because the memory controller
//     clock is slower, you should enable only WRMC_CLLE2X.
// - 2 * mcclk_freq < clientclk_freq
//     You can only enable RDCL_RDFAST. If one of the fifos is a real ram and
//     power is a concern, you should avoid enabling RDCL_RDFAST.
//

// Register LWE297_GLOBAL_LW_MCCIF_FIFOCTRL_0  
#define LWE297_GLOBAL_LW_MCCIF_FIFOCTRL_0                           0xe2b
#define LWE297_GLOBAL_LW_MCCIF_FIFOCTRL_0_LW_MCCIF_WRCL_MCLE2X                             0:0
#define LWE297_GLOBAL_LW_MCCIF_FIFOCTRL_0_LW_MCCIF_WRCL_MCLE2X_INIT_ENUM                  DISABLE
#define LWE297_GLOBAL_LW_MCCIF_FIFOCTRL_0_LW_MCCIF_WRCL_MCLE2X_DISABLE                    0x00000000
#define LWE297_GLOBAL_LW_MCCIF_FIFOCTRL_0_LW_MCCIF_WRCL_MCLE2X_ENABLE                     0x00000001

#define LWE297_GLOBAL_LW_MCCIF_FIFOCTRL_0_LW_MCCIF_RDMC_RDFAST                             1:1
#define LWE297_GLOBAL_LW_MCCIF_FIFOCTRL_0_LW_MCCIF_RDMC_RDFAST_INIT_ENUM                  DISABLE
#define LWE297_GLOBAL_LW_MCCIF_FIFOCTRL_0_LW_MCCIF_RDMC_RDFAST_DISABLE                    0x00000000
#define LWE297_GLOBAL_LW_MCCIF_FIFOCTRL_0_LW_MCCIF_RDMC_RDFAST_ENABLE                     0x00000001

#define LWE297_GLOBAL_LW_MCCIF_FIFOCTRL_0_LW_MCCIF_WRMC_CLLE2X                             2:2
#define LWE297_GLOBAL_LW_MCCIF_FIFOCTRL_0_LW_MCCIF_WRMC_CLLE2X_INIT_ENUM                  DISABLE
#define LWE297_GLOBAL_LW_MCCIF_FIFOCTRL_0_LW_MCCIF_WRMC_CLLE2X_DISABLE                    0x00000000
#define LWE297_GLOBAL_LW_MCCIF_FIFOCTRL_0_LW_MCCIF_WRMC_CLLE2X_ENABLE                     0x00000001

#define LWE297_GLOBAL_LW_MCCIF_FIFOCTRL_0_LW_MCCIF_RDCL_RDFAST                             3:3
#define LWE297_GLOBAL_LW_MCCIF_FIFOCTRL_0_LW_MCCIF_RDCL_RDFAST_INIT_ENUM                  DISABLE
#define LWE297_GLOBAL_LW_MCCIF_FIFOCTRL_0_LW_MCCIF_RDCL_RDFAST_DISABLE                    0x00000000
#define LWE297_GLOBAL_LW_MCCIF_FIFOCTRL_0_LW_MCCIF_RDCL_RDFAST_ENABLE                     0x00000001

// --------------------------------------------------------------------------
//
// Copyright (c) 2004, LWPU Corp.
// All Rights Reserved.
//
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of LWPU Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of LWPU Corp.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
//
// --------------------------------------------------------------------------
//
// ########################## Internal packet definitions ######################
//
// This file contains implementation details that programmers don't need to see
#define AR_SNAP_BITS    4
#define SETUP_PACKET_WIDTH      96
#define SETUP_SB_WIDTH  11
// Global defines
//--------------------------------------
//FP20 used all over the
//3d pipe. TD stands for 3d.
//---------------------------------------

// Packet TD_FLOAT
#define TD_FLOAT_SIZE 20

#define TD_FLOAT_FLOAT_ROW                      0

#define TD_FLOAT_MANT_ROW                       0

#define TD_FLOAT_EXP_ROW                        0

#define TD_FLOAT_SIGN_ROW                       0


// Packet IEEE_FLOAT
#define IEEE_FLOAT_SIZE 32

#define IEEE_FLOAT_FLOAT_ROW                    0

#define IEEE_FLOAT_MANT_ROW                     0

#define IEEE_FLOAT_EXP_ROW                      0

#define IEEE_FLOAT_SIGN_ROW                     0

// FP22 used in ATRAST

// Packet FP22_FLOAT
#define FP22_FLOAT_SIZE 22

#define FP22_FLOAT_FLOAT_ROW                    0

#define FP22_FLOAT_MANT_ROW                     0

#define FP22_FLOAT_EXP_ROW                      0

#define FP22_FLOAT_SIGN_ROW                     0

// FP16 used in DWR

// Packet FP16_FLOAT
#define FP16_FLOAT_SIZE 16

#define FP16_FLOAT_FLOAT_ROW                    0

#define FP16_FLOAT_MANT_ROW                     0

#define FP16_FLOAT_EXP_ROW                      0

#define FP16_FLOAT_SIGN_ROW                     0

// FP11 used in DWR

// Packet FP11_FLOAT
#define FP11_FLOAT_SIZE 11

#define FP11_FLOAT_FLOAT_ROW                    0

#define FP11_FLOAT_MANT_ROW                     0

#define FP11_FLOAT_EXP_ROW                      0

// 5e5 FP10 used in DWR

// Packet FP10_FLOAT
#define FP10_FLOAT_SIZE 10

#define FP10_FLOAT_FLOAT_ROW                    0

#define FP10_FLOAT_MANT_ROW                     0

#define FP10_FLOAT_EXP_ROW                      0

// 6e4 FP10 used in DWR

// Packet FP10_6E4_FLOAT
#define FP10_6E4_FLOAT_SIZE 10

#define FP10_6E4_FLOAT_FLOAT_ROW                        0

#define FP10_6E4_FLOAT_MANT_ROW                 0

#define FP10_6E4_FLOAT_EXP_ROW                  0

//----------------------
// define for FX10 used in the
// 3d pipe. TD stands for 3d
//-----------------------

// Packet TD_FIX
#define TD_FIX_SIZE 10

#define TD_FIX_FIX_ROW                  0

#define TD_FIX_FRAC_ROW                 0

#define TD_FIX_INT_ROW                  0

#define TD_FIX_SIGN_ROW                 0

//----------------------------
//FX10 constants
//----------------------------
#define TD_FIX_ZERO     0
#define TD_FIX_ZERO_SIGN        0
#define TD_FIX_ZERO_INT 0
#define TD_FIX_ZERO_FRAC        0
#define TD_FIX_ONE      256
#define TD_FIX_ONE_SIGN 0
#define TD_FIX_ONE_INT  1
#define TD_FIX_ONE_FRAC 0
#define TD_FIX_MINUS_ONE        768
#define TD_FIX_MINUS_ONE_SIGN   1
#define TD_FIX_MINUS_ONE_INT    1
#define TD_FIX_MINUS_ONE_FRAC   0
//----------------------------
//FP20 constants
//----------------------------
#define TD_FLOAT_ZERO   0
#define TD_FLOAT_ZERO_SIGN      0
#define TD_FLOAT_ZERO_MANT      0
#define TD_FLOAT_ZERO_EXP       0
#define TD_FLOAT_ONE    253952
#define TD_FLOAT_ONE_SIGN       0
#define TD_FLOAT_ONE_MANT       0
#define TD_FLOAT_ONE_EXP        31
#define TD_FLOAT_MINUS_ONE      778240
#define TD_FLOAT_MINUS_ONE_SIGN 1
#define TD_FLOAT_MINUS_ONE_MANT 0
#define TD_FLOAT_MINUS_ONE_EXP  31
#define TD_FLOAT_MINUS_MAX      1048575
#define TD_FLOAT_MINUS_MAX_SIGN 1
#define TD_FLOAT_MINUS_MAX_MANT 8191
#define TD_FLOAT_MINUS_MAX_EXP  63
#define TD_FLOAT_PLUS_MAX       524287
#define TD_FLOAT_PLUS_MAX_SIGN  0
#define TD_FLOAT_PLUS_MAX_MANT  8191
#define TD_FLOAT_PLUS_MAX_EXP   63
//----------------------------
//IEEE float constants
//----------------------------
#define IEEE_FLOAT_PLUS_ZERO    0
#define IEEE_FLOAT_PLUS_ZERO_SIGN       0
#define IEEE_FLOAT_PLUS_ZERO_MANT       0
#define IEEE_FLOAT_PLUS_ZERO_EXP        0
#define IEEE_FLOAT_MINUS_ZERO   -2147483648
#define IEEE_FLOAT_MINUS_ZERO_SIGN      1
#define IEEE_FLOAT_MINUS_ZERO_MANT      0
#define IEEE_FLOAT_MINUS_ZERO_EXP       0
#define IEEE_FLOAT_PLUS_INF     2139095040
#define IEEE_FLOAT_PLUS_INF_SIGN        0
#define IEEE_FLOAT_PLUS_INF_MANT        0
#define IEEE_FLOAT_PLUS_INF_EXP 255
#define IEEE_FLOAT_MINUS_INF    -8388608
#define IEEE_FLOAT_MINUS_INF_SIGN       1
#define IEEE_FLOAT_MINUS_INF_MANT       0
#define IEEE_FLOAT_MINUS_INF_EXP        255
#define IEEE_FLOAT_ONE  1065353216
#define IEEE_FLOAT_ONE_SIGN     0
#define IEEE_FLOAT_ONE_MANT     0
#define IEEE_FLOAT_ONE_EXP      127
#define IEEE_FLOAT_MINUS_ONE    -1082130432
#define IEEE_FLOAT_MINUS_ONE_SIGN       1
#define IEEE_FLOAT_MINUS_ONE_MANT       0
#define IEEE_FLOAT_MINUS_ONE_EXP        127
//----------------------------
//FP22 constants
//----------------------------
#define FP22_FLOAT_ZERO 0
#define FP22_FLOAT_ZERO_SIGN    0
#define FP22_FLOAT_ZERO_MANT    0
#define FP22_FLOAT_ZERO_EXP     0
#define FP22_FLOAT_ONE  1015808
#define FP22_FLOAT_ONE_SIGN     0
#define FP22_FLOAT_ONE_MANT     0
#define FP22_FLOAT_ONE_EXP      31
#define FP22_FLOAT_MINUS_ONE    3112960
#define FP22_FLOAT_MINUS_ONE_SIGN       1
#define FP22_FLOAT_MINUS_ONE_MANT       0
#define FP22_FLOAT_MINUS_ONE_EXP        31
#define FP22_FLOAT_MINUS_MAX    4194303
#define FP22_FLOAT_MINUS_MAX_SIGN       1
#define FP22_FLOAT_MINUS_MAX_MANT       16383
#define FP22_FLOAT_MINUS_MAX_EXP        63
#define FP22_FLOAT_PLUS_MAX     2097151
#define FP22_FLOAT_PLUS_MAX_SIGN        0
#define FP22_FLOAT_PLUS_MAX_MANT        16383
#define FP22_FLOAT_PLUS_MAX_EXP 63
//
// SC25 clip/setup
//

// Packet CLIP2SETUP_COV
#define CLIP2SETUP_COV_SIZE 112

#define CLIP2SETUP_COV_TAG_ROW                  0
#define CLIP2SETUP_COV_TAG_REG                  0x00000000
#define CLIP2SETUP_COV_TAG_PRIM                 0x00000001
#define CLIP2SETUP_COV_TAG_XY                   0x00000002
#define CLIP2SETUP_COV_TAG_RHW                  0x00000003

#define CLIP2SETUP_COV_DATA_ROW                 0


// Packet CLIP2SETUP_COV_REG
#define CLIP2SETUP_COV_REG_SIZE 56

#define CLIP2SETUP_COV_REG_TAG_ROW                      0
#define CLIP2SETUP_COV_REG_TAG_REG                      0x00000000
#define CLIP2SETUP_COV_REG_TAG_PRIM                     0x00000001
#define CLIP2SETUP_COV_REG_TAG_XY                       0x00000002
#define CLIP2SETUP_COV_REG_TAG_RHW                      0x00000003

#define CLIP2SETUP_COV_REG_READ_ROW                     0

#define CLIP2SETUP_COV_REG_ADDR_ROW                     0

#define CLIP2SETUP_COV_REG_DATA_ROW                     0

#define CLIP2SETUP_COV_REG_CHANNEL_ROW                  0


// Packet CLIP2SETUP_COV_PRIM
#define CLIP2SETUP_COV_PRIM_SIZE 106

#define CLIP2SETUP_COV_PRIM_TAG_ROW                     0
#define CLIP2SETUP_COV_PRIM_TAG_REG                     0x00000000
#define CLIP2SETUP_COV_PRIM_TAG_PRIM                    0x00000001
#define CLIP2SETUP_COV_PRIM_TAG_XY                      0x00000002
#define CLIP2SETUP_COV_PRIM_TAG_RHW                     0x00000003

#define CLIP2SETUP_COV_PRIM_PRIM_TYPE_ROW                       0
#define CLIP2SETUP_COV_PRIM_PRIM_TYPE_POINT                     0x00000001
#define CLIP2SETUP_COV_PRIM_PRIM_TYPE_LINE                      0x00000002
#define CLIP2SETUP_COV_PRIM_PRIM_TYPE_TRI                       0x00000003

// triangle id
#define CLIP2SETUP_COV_PRIM_TID_ROW                     0

// S27.8
#define CLIP2SETUP_COV_PRIM_AREA_ROW                    0

// S13.4
#define CLIP2SETUP_COV_PRIM_X3_ROW                      0

// S13.4
#define CLIP2SETUP_COV_PRIM_Y3_ROW                      0


// Packet CLIP2SETUP_COV_XY
#define CLIP2SETUP_COV_XY_SIZE 112

#define CLIP2SETUP_COV_XY_TAG_ROW                       0
#define CLIP2SETUP_COV_XY_TAG_REG                       0x00000000
#define CLIP2SETUP_COV_XY_TAG_PRIM                      0x00000001
#define CLIP2SETUP_COV_XY_TAG_XY                        0x00000002
#define CLIP2SETUP_COV_XY_TAG_RHW                       0x00000003

#define CLIP2SETUP_COV_XY_FACE_ROW                      0
#define CLIP2SETUP_COV_XY_FACE_FRONT                    0x00000000
#define CLIP2SETUP_COV_XY_FACE_BACK                     0x00000001

// S13.4
#define CLIP2SETUP_COV_XY_X0_ROW                        0

// S13.4
#define CLIP2SETUP_COV_XY_Y0_ROW                        0

// S13.4
#define CLIP2SETUP_COV_XY_X1_ROW                        0

// S13.4
#define CLIP2SETUP_COV_XY_Y1_ROW                        0

// S13.4
#define CLIP2SETUP_COV_XY_X2_ROW                        0

// S13.4
#define CLIP2SETUP_COV_XY_Y2_ROW                        0


// Packet CLIP2SETUP_COV_RHW
#define CLIP2SETUP_COV_RHW_SIZE 100

#define CLIP2SETUP_COV_RHW_TAG_ROW                      0
#define CLIP2SETUP_COV_RHW_TAG_REG                      0x00000000
#define CLIP2SETUP_COV_RHW_TAG_PRIM                     0x00000001
#define CLIP2SETUP_COV_RHW_TAG_XY                       0x00000002
#define CLIP2SETUP_COV_RHW_TAG_RHW                      0x00000003

#define CLIP2SETUP_COV_RHW_RHW0_ROW                     0

#define CLIP2SETUP_COV_RHW_RHW1_ROW                     0

#define CLIP2SETUP_COV_RHW_RHW2_ROW                     0


// Packet CLIP2SETUP_Z
#define CLIP2SETUP_Z_SIZE 73

#define CLIP2SETUP_Z_Z0_ROW                     0

#define CLIP2SETUP_Z_DZDX_ROW                   0

#define CLIP2SETUP_Z_DZDY_ROW                   0

// exponent, commmon to both DZDX and DZDY
#define CLIP2SETUP_Z_EXP_ROW                    0

// triangle id
#define CLIP2SETUP_Z_TID_ROW                    0


// Packet CLIP2ATRAST_TRAM
#define CLIP2ATRAST_TRAM_SIZE 270

#define CLIP2ATRAST_TRAM_C0_ROW                 0

#define CLIP2ATRAST_TRAM_C0_LO_ROW                      0

#define CLIP2ATRAST_TRAM_C0_HI_ROW                      0

#define CLIP2ATRAST_TRAM_C1_ROW                 0

#define CLIP2ATRAST_TRAM_C1_LO_ROW                      0

#define CLIP2ATRAST_TRAM_C1_HI_ROW                      0

#define CLIP2ATRAST_TRAM_C2_ROW                 0

#define CLIP2ATRAST_TRAM_C2_LO_ROW                      0

#define CLIP2ATRAST_TRAM_C2_HI_ROW                      0

#define CLIP2ATRAST_TRAM_C3_ROW                 0

#define CLIP2ATRAST_TRAM_C3_LO_ROW                      0

#define CLIP2ATRAST_TRAM_C3_HI_ROW                      0

#define CLIP2ATRAST_TRAM_TRAM_ROW_ROW                   0

// half-column write enables
#define CLIP2ATRAST_TRAM_WE_ROW                 0

//
// TRAM_BF_HP and LP describe one high- or low-precision block-float column (C0/...) of CLIP2SETUP_ATTR
//

// Packet TRAM_BF_HP
#define TRAM_BF_HP_SIZE 63

// S1.17
#define TRAM_BF_HP_DP0_MANT_ROW                 0

// S1.17
#define TRAM_BF_HP_DP1_MANT_ROW                 0

// S1.17
#define TRAM_BF_HP_P2_MANT_ROW                  0

// 6
#define TRAM_BF_HP_EXP_ROW                      0


// Packet TRAM_BF_LP
#define TRAM_BF_LP_SIZE 32

// S1.8
#define TRAM_BF_LP_DP0_MANT_ROW                 0

// S1.8
#define TRAM_BF_LP_DP1_MANT_ROW                 0

// S1.8
#define TRAM_BF_LP_P2_MANT_ROW                  0

// 2
#define TRAM_BF_LP_EXP_ROW                      0

// this is for setup->atrast z-plane parameters

// Packet TRAM_BF_ZP64
#define TRAM_BF_ZP64_SIZE 64

// S1.17
#define TRAM_BF_ZP64_DZDX_MANT_ROW                      0

// S1.17
#define TRAM_BF_ZP64_DZDY_MANT_ROW                      0

// .20.1
#define TRAM_BF_ZP64_Z0_ROW                     0

// 5 - common to DZDX and DZDY
#define TRAM_BF_ZP64_EXP_ROW                    0


// Packet SETUP2QRAST_QR
#define SETUP2QRAST_QR_SIZE 40

#define SETUP2QRAST_QR_Q_ROW                    0

#define SETUP2QRAST_QR_Q_MANT_ROW                       0

#define SETUP2QRAST_QR_Q_SIGN_ROW                       0

#define SETUP2QRAST_QR_R_ROW                    0

#define SETUP2QRAST_QR_R_MANT_ROW                       0

#define SETUP2QRAST_QR_R_SIGN_ROW                       0

// Setup to Qrast packets defined below
//

// Packet SETUP2QRAST
#define SETUP2QRAST_SIZE 110

#define SETUP2QRAST_DATA_ROW                    0

#define SETUP2QRAST_TAG_ROW                     0
#define SETUP2QRAST_TAG_REG                     0x00000000
#define SETUP2QRAST_TAG_Z                       0x00000001
#define SETUP2QRAST_TAG_C                       0x00000002
#define SETUP2QRAST_TAG_DCDX                    0x00000003
#define SETUP2QRAST_TAG_C_DCDX0                 0x00000004
#define SETUP2QRAST_TAG_C_DCDX1                 0x00000005
#define SETUP2QRAST_TAG_DCDY_DCDX0                      0x00000006
#define SETUP2QRAST_TAG_DCDY_DCDX1                      0x00000007
#define SETUP2QRAST_TAG_XY                      0x00000008

// CAUTION!!!!!!!!!
// While changing the packet sizes below, do not forget to change the PD field also

// Packet SETUP2QRAST_REG
#define SETUP2QRAST_REG_SIZE 110

#define SETUP2QRAST_REG_DATA_ROW                        0

#define SETUP2QRAST_REG_ADDR_ROW                        0

#define SETUP2QRAST_REG_BLK_NUM_ROW                     0
#define SETUP2QRAST_REG_BLK_NUM_CTL                     0x00000000
#define SETUP2QRAST_REG_BLK_NUM_IDX                     0x00000001
#define SETUP2QRAST_REG_BLK_NUM_VPE                     0x00000002
#define SETUP2QRAST_REG_BLK_NUM_SU                      0x00000003
#define SETUP2QRAST_REG_BLK_NUM_QR                      0x00000004
#define SETUP2QRAST_REG_BLK_NUM_PSEQ                    0x00000005
#define SETUP2QRAST_REG_BLK_NUM_AT                      0x00000006
#define SETUP2QRAST_REG_BLK_NUM_TEX                     0x00000007
#define SETUP2QRAST_REG_BLK_NUM_ALU                     0x00000008
#define SETUP2QRAST_REG_BLK_NUM_DW                      0x00000009
#define SETUP2QRAST_REG_BLK_NUM_FDC                     0x0000000a
#define SETUP2QRAST_REG_BLK_NUM_GLB1                    0x0000000e
#define SETUP2QRAST_REG_BLK_NUM_GLB2                    0x0000000f

#define SETUP2QRAST_REG_BLK_ADDR_ROW                    0

#define SETUP2QRAST_REG_READ_ROW                        0

#define SETUP2QRAST_REG_CHANNEL_ROW                     0

#define SETUP2QRAST_REG_PD_ROW                  0

#define SETUP2QRAST_REG_TAG_ROW                 0
#define SETUP2QRAST_REG_TAG_REG                 0x00000000
#define SETUP2QRAST_REG_TAG_Z                   0x00000001
#define SETUP2QRAST_REG_TAG_C                   0x00000002
#define SETUP2QRAST_REG_TAG_DCDX                        0x00000003
#define SETUP2QRAST_REG_TAG_C_DCDX0                     0x00000004
#define SETUP2QRAST_REG_TAG_C_DCDX1                     0x00000005
#define SETUP2QRAST_REG_TAG_DCDY_DCDX0                  0x00000006
#define SETUP2QRAST_REG_TAG_DCDY_DCDX1                  0x00000007
#define SETUP2QRAST_REG_TAG_XY                  0x00000008

// CAUTION!!!!!!!!!
// While changing the packet sizes below, do not forget to change the PD field also

// Packet SETUP2QRAST_Z
#define SETUP2QRAST_Z_SIZE 110

#define SETUP2QRAST_Z_Z0_ROW                    0

#define SETUP2QRAST_Z_DZDX_ROW                  0

#define SETUP2QRAST_Z_DZDY_ROW                  0

// exponent, commmon to both DZDX and DZDY
#define SETUP2QRAST_Z_EXP_ROW                   0

// triangle id
#define SETUP2QRAST_Z_TID_ROW                   0

#define SETUP2QRAST_Z_PD_ROW                    0

#define SETUP2QRAST_Z_TAG_ROW                   0
#define SETUP2QRAST_Z_TAG_REG                   0x00000000
#define SETUP2QRAST_Z_TAG_Z                     0x00000001
#define SETUP2QRAST_Z_TAG_C                     0x00000002
#define SETUP2QRAST_Z_TAG_DCDX                  0x00000003
#define SETUP2QRAST_Z_TAG_C_DCDX0                       0x00000004
#define SETUP2QRAST_Z_TAG_C_DCDX1                       0x00000005
#define SETUP2QRAST_Z_TAG_DCDY_DCDX0                    0x00000006
#define SETUP2QRAST_Z_TAG_DCDY_DCDX1                    0x00000007
#define SETUP2QRAST_Z_TAG_XY                    0x00000008

// CAUTION!!!!!!!!!
// While changing the packet sizes below, do not forget to change the PD field also

// Packet SETUP2QRAST_C
#define SETUP2QRAST_C_SIZE 110

#define SETUP2QRAST_C_A_ROW                     0

#define SETUP2QRAST_C_B_ROW                     0

#define SETUP2QRAST_C_UPPER_IN_EDGE_ROW                 0

#define SETUP2QRAST_C_UPPER_OUT_EDGE_ROW                        0

#define SETUP2QRAST_C_LOWER_IN_EDGE_ROW                 0

#define SETUP2QRAST_C_LOWER_OUT_EDGE_ROW                        0

#define SETUP2QRAST_C_FACE_ROW                  0
#define SETUP2QRAST_C_FACE_FRONT                        0x00000000
#define SETUP2QRAST_C_FACE_BACK                 0x00000001

#define SETUP2QRAST_C_PD_ROW                    0

#define SETUP2QRAST_C_TAG_ROW                   0
#define SETUP2QRAST_C_TAG_REG                   0x00000000
#define SETUP2QRAST_C_TAG_Z                     0x00000001
#define SETUP2QRAST_C_TAG_C                     0x00000002
#define SETUP2QRAST_C_TAG_DCDX                  0x00000003
#define SETUP2QRAST_C_TAG_C_DCDX0                       0x00000004
#define SETUP2QRAST_C_TAG_C_DCDX1                       0x00000005
#define SETUP2QRAST_C_TAG_DCDY_DCDX0                    0x00000006
#define SETUP2QRAST_C_TAG_DCDY_DCDX1                    0x00000007
#define SETUP2QRAST_C_TAG_XY                    0x00000008

// CAUTION!!!!!!!!!
// While changing the packet sizes below, do not forget to change the PD field also

// Packet SETUP2QRAST_DCDX
#define SETUP2QRAST_DCDX_SIZE 110

#define SETUP2QRAST_DCDX_DADX_ROW                       0

#define SETUP2QRAST_DCDX_DBDX_ROW                       0

#define SETUP2QRAST_DCDX_DGDX_ROW                       0

#define SETUP2QRAST_DCDX_DGPDX_ROW                      0

#define SETUP2QRAST_DCDX_PD_ROW                 0

#define SETUP2QRAST_DCDX_TAG_ROW                        0
#define SETUP2QRAST_DCDX_TAG_REG                        0x00000000
#define SETUP2QRAST_DCDX_TAG_Z                  0x00000001
#define SETUP2QRAST_DCDX_TAG_C                  0x00000002
#define SETUP2QRAST_DCDX_TAG_DCDX                       0x00000003
#define SETUP2QRAST_DCDX_TAG_C_DCDX0                    0x00000004
#define SETUP2QRAST_DCDX_TAG_C_DCDX1                    0x00000005
#define SETUP2QRAST_DCDX_TAG_DCDY_DCDX0                 0x00000006
#define SETUP2QRAST_DCDX_TAG_DCDY_DCDX1                 0x00000007
#define SETUP2QRAST_DCDX_TAG_XY                 0x00000008

// CAUTION!!!!!!!!!
// While changing the packet sizes below, do not forget to change the PD field also
// Note that the R field needs an extra 4 bits because the dcdx we are dividing by
// is padded by 4 bits (so that it is aligned to C).

// Packet SETUP2QRAST_C_DCDX0
#define SETUP2QRAST_C_DCDX0_SIZE 110

#define SETUP2QRAST_C_DCDX0_A_DADX_ROW                  0

#define SETUP2QRAST_C_DCDX0_A_DADX_Q_ROW                        0

#define SETUP2QRAST_C_DCDX0_A_DADX_R_ROW                        0

#define SETUP2QRAST_C_DCDX0_B_DBDX_ROW                  0

#define SETUP2QRAST_C_DCDX0_B_DBDX_Q_ROW                        0

#define SETUP2QRAST_C_DCDX0_B_DBDX_R_ROW                        0

#define SETUP2QRAST_C_DCDX0_PD_ROW                      0

#define SETUP2QRAST_C_DCDX0_TAG_ROW                     0
#define SETUP2QRAST_C_DCDX0_TAG_REG                     0x00000000
#define SETUP2QRAST_C_DCDX0_TAG_Z                       0x00000001
#define SETUP2QRAST_C_DCDX0_TAG_C                       0x00000002
#define SETUP2QRAST_C_DCDX0_TAG_DCDX                    0x00000003
#define SETUP2QRAST_C_DCDX0_TAG_C_DCDX0                 0x00000004
#define SETUP2QRAST_C_DCDX0_TAG_C_DCDX1                 0x00000005
#define SETUP2QRAST_C_DCDX0_TAG_DCDY_DCDX0                      0x00000006
#define SETUP2QRAST_C_DCDX0_TAG_DCDY_DCDX1                      0x00000007
#define SETUP2QRAST_C_DCDX0_TAG_XY                      0x00000008

// CAUTION!!!!!!!!!
// While changing the packet sizes below, do not forget to change the PD field also
// Note that the R field needs an extra 4 bits because the dcdx we are dividing by
// is padded by 4 bits (so that it is aligned to C).

// Packet SETUP2QRAST_C_DCDX1
#define SETUP2QRAST_C_DCDX1_SIZE 110

#define SETUP2QRAST_C_DCDX1_G_DGDX_ROW                  0

#define SETUP2QRAST_C_DCDX1_G_DGDX_Q_ROW                        0

#define SETUP2QRAST_C_DCDX1_G_DGDX_R_ROW                        0

#define SETUP2QRAST_C_DCDX1_G_P_DGPDX_ROW                       0

#define SETUP2QRAST_C_DCDX1_G_P_DGPDX_Q_ROW                     0

#define SETUP2QRAST_C_DCDX1_G_P_DGPDX_R_ROW                     0

#define SETUP2QRAST_C_DCDX1_PD_ROW                      0

#define SETUP2QRAST_C_DCDX1_TAG_ROW                     0
#define SETUP2QRAST_C_DCDX1_TAG_REG                     0x00000000
#define SETUP2QRAST_C_DCDX1_TAG_Z                       0x00000001
#define SETUP2QRAST_C_DCDX1_TAG_C                       0x00000002
#define SETUP2QRAST_C_DCDX1_TAG_DCDX                    0x00000003
#define SETUP2QRAST_C_DCDX1_TAG_C_DCDX0                 0x00000004
#define SETUP2QRAST_C_DCDX1_TAG_C_DCDX1                 0x00000005
#define SETUP2QRAST_C_DCDX1_TAG_DCDY_DCDX0                      0x00000006
#define SETUP2QRAST_C_DCDX1_TAG_DCDY_DCDX1                      0x00000007
#define SETUP2QRAST_C_DCDX1_TAG_XY                      0x00000008

// CAUTION!!!!!!!!!
// While changing the packet sizes below, do not forget to change the PD field also

// Packet SETUP2QRAST_DCDY_DCDX0
#define SETUP2QRAST_DCDY_DCDX0_SIZE 110

#define SETUP2QRAST_DCDY_DCDX0_DADY_DADX_ROW                    0

#define SETUP2QRAST_DCDY_DCDX0_DADY_DADX_Q_ROW                  0

#define SETUP2QRAST_DCDY_DCDX0_DADY_DADX_R_ROW                  0

#define SETUP2QRAST_DCDY_DCDX0_DBDY_DBDX_ROW                    0

#define SETUP2QRAST_DCDY_DCDX0_DBDY_DBDX_Q_ROW                  0

#define SETUP2QRAST_DCDY_DCDX0_DBDY_DBDX_R_ROW                  0

#define SETUP2QRAST_DCDY_DCDX0_PD_ROW                   0

#define SETUP2QRAST_DCDY_DCDX0_TAG_ROW                  0
#define SETUP2QRAST_DCDY_DCDX0_TAG_REG                  0x00000000
#define SETUP2QRAST_DCDY_DCDX0_TAG_Z                    0x00000001
#define SETUP2QRAST_DCDY_DCDX0_TAG_C                    0x00000002
#define SETUP2QRAST_DCDY_DCDX0_TAG_DCDX                 0x00000003
#define SETUP2QRAST_DCDY_DCDX0_TAG_C_DCDX0                      0x00000004
#define SETUP2QRAST_DCDY_DCDX0_TAG_C_DCDX1                      0x00000005
#define SETUP2QRAST_DCDY_DCDX0_TAG_DCDY_DCDX0                   0x00000006
#define SETUP2QRAST_DCDY_DCDX0_TAG_DCDY_DCDX1                   0x00000007
#define SETUP2QRAST_DCDY_DCDX0_TAG_XY                   0x00000008

// CAUTION!!!!!!!!!
// While changing the packet sizes below, do not forget to change the PD field also

// Packet SETUP2QRAST_DCDY_DCDX1
#define SETUP2QRAST_DCDY_DCDX1_SIZE 110

#define SETUP2QRAST_DCDY_DCDX1_DGDY_DGDX_ROW                    0

#define SETUP2QRAST_DCDY_DCDX1_DGDY_DGDX_Q_ROW                  0

#define SETUP2QRAST_DCDY_DCDX1_DGDY_DGDX_R_ROW                  0

#define SETUP2QRAST_DCDY_DCDX1_DGPDY_DGPDX_ROW                  0

#define SETUP2QRAST_DCDY_DCDX1_DGPDY_DGPDX_Q_ROW                        0

#define SETUP2QRAST_DCDY_DCDX1_DGPDY_DGPDX_R_ROW                        0

#define SETUP2QRAST_DCDY_DCDX1_PD_ROW                   0

#define SETUP2QRAST_DCDY_DCDX1_TAG_ROW                  0
#define SETUP2QRAST_DCDY_DCDX1_TAG_REG                  0x00000000
#define SETUP2QRAST_DCDY_DCDX1_TAG_Z                    0x00000001
#define SETUP2QRAST_DCDY_DCDX1_TAG_C                    0x00000002
#define SETUP2QRAST_DCDY_DCDX1_TAG_DCDX                 0x00000003
#define SETUP2QRAST_DCDY_DCDX1_TAG_C_DCDX0                      0x00000004
#define SETUP2QRAST_DCDY_DCDX1_TAG_C_DCDX1                      0x00000005
#define SETUP2QRAST_DCDY_DCDX1_TAG_DCDY_DCDX0                   0x00000006
#define SETUP2QRAST_DCDY_DCDX1_TAG_DCDY_DCDX1                   0x00000007
#define SETUP2QRAST_DCDY_DCDX1_TAG_XY                   0x00000008

// CAUTION!!!!!!!!!
// While changing the packet sizes below, do not forget to change the PD field also

// Packet SETUP2QRAST_XY
#define SETUP2QRAST_XY_SIZE 110

#define SETUP2QRAST_XY_XMIN_ROW                 0

#define SETUP2QRAST_XY_XMAX_ROW                 0

#define SETUP2QRAST_XY_YMIN_ROW                 0

#define SETUP2QRAST_XY_YMAX_ROW                 0

#define SETUP2QRAST_XY_YMID_IN_ROW                      0

#define SETUP2QRAST_XY_YMID_OUT_ROW                     0

#define SETUP2QRAST_XY_PD_ROW                   0

#define SETUP2QRAST_XY_TAG_ROW                  0
#define SETUP2QRAST_XY_TAG_REG                  0x00000000
#define SETUP2QRAST_XY_TAG_Z                    0x00000001
#define SETUP2QRAST_XY_TAG_C                    0x00000002
#define SETUP2QRAST_XY_TAG_DCDX                 0x00000003
#define SETUP2QRAST_XY_TAG_C_DCDX0                      0x00000004
#define SETUP2QRAST_XY_TAG_C_DCDX1                      0x00000005
#define SETUP2QRAST_XY_TAG_DCDY_DCDX0                   0x00000006
#define SETUP2QRAST_XY_TAG_DCDY_DCDX1                   0x00000007
#define SETUP2QRAST_XY_TAG_XY                   0x00000008

//
// setup to atrast slopes bus
//

// Packet SETUP2ATRAST_SLOPES
#define SETUP2ATRAST_SLOPES_SIZE 81

// includes C0, DCDX, DCDY
#define SETUP2ATRAST_SLOPES_DATA_ROW                    0

// S14.16 e6
#define SETUP2ATRAST_SLOPES_C0_ROW                      0

// S1.16 e6
#define SETUP2ATRAST_SLOPES_DCDX_ROW                    0

// S1.16 e6
#define SETUP2ATRAST_SLOPES_DCDY_ROW                    0

// common exponent among c0/dcdx/dcdy
#define SETUP2ATRAST_SLOPES_EXP_ROW                     0

#define SETUP2ATRAST_SLOPES_TID_ROW                     0

#define SETUP2ATRAST_SLOPES_TAG_ROW                     0
#define SETUP2ATRAST_SLOPES_TAG_ALPHA                   0x00000000
#define SETUP2ATRAST_SLOPES_TAG_BETA                    0x00000001
#define SETUP2ATRAST_SLOPES_TAG_GAMMA                   0x00000002

// S14.16

// Packet SETUP2ATRAST_SLOPES_C0
#define SETUP2ATRAST_SLOPES_C0_SIZE 31

#define SETUP2ATRAST_SLOPES_C0_C0_ROW                   0

#define SETUP2ATRAST_SLOPES_C0_SIGN_ROW                 0

#define SETUP2ATRAST_SLOPES_C0_INT_ROW                  0

#define SETUP2ATRAST_SLOPES_C0_FRAC_ROW                 0


// Packet SETUP2ATRAST_SLOPES_DCDXDY
#define SETUP2ATRAST_SLOPES_DCDXDY_SIZE 18

#define SETUP2ATRAST_SLOPES_DCDXDY_DCDX_ROW                     0

#define SETUP2ATRAST_SLOPES_DCDXDY_DCDY_ROW                     0

#define SETUP2ATRAST_SLOPES_DCDXDY_SIGN_ROW                     0

#define SETUP2ATRAST_SLOPES_DCDXDY_INT_ROW                      0

#define SETUP2ATRAST_SLOPES_DCDXDY_FRAC_ROW                     0

// QRAST to CLIP packet

// Packet QRAST2CLIP
#define QRAST2CLIP_SIZE 6

#define QRAST2CLIP_TID_ROW                      0

// PSEQ to QRAST packet

// Packet PSEQ2QRAST
#define PSEQ2QRAST_SIZE 6

// which tri is done
#define PSEQ2QRAST_TRI_ID_ROW                   0

// read/raise/refcnt return values from GRGK

// Packet GK2SETUP_RDAT
#define GK2SETUP_RDAT_SIZE 38

#define GK2SETUP_RDAT_DATA_ROW                  0

#define GK2SETUP_RDAT_CHANNEL_ROW                       0

#define GK2SETUP_RDAT_TYPE_ROW                  0
#define GK2SETUP_RDAT_TYPE_REGISTER                     0x00000000
#define GK2SETUP_RDAT_TYPE_RAISE                        0x00000001
#define GK2SETUP_RDAT_TYPE_REFCNT                       0x00000002
#define GK2SETUP_RDAT_TYPE_CTXSW_ACK                    0x00000003

// Packet to define Alpha Perspective and Beta Perspective
// for the high-recision IPAs
// This packet is used by qrast and atrast in the IPAs

// Packet BARY_C_PER_HI
#define BARY_C_PER_HI_SIZE 16

#define BARY_C_PER_HI_FRAC_ROW                  0

#define BARY_C_PER_HI_INT_ROW                   0

#define BARY_C_PER_HI_SIGN_ROW                  0

// Packet to define Alpha Perspective and Beta Perspective
// for the lo-recision IPAs

// Packet BARY_C_PER_LO
#define BARY_C_PER_LO_SIZE 12

#define BARY_C_PER_LO_FRAC_ROW                  0

#define BARY_C_PER_LO_INT_ROW                   0

#define BARY_C_PER_LO_SIGN_ROW                  0

// OBSOLETE, use PIXPKT instead
#define RASTER_SB_WIDTH 7

// Packet RS_SB
#define RS_SB_SIZE 7

#define RS_SB_TAG_ROW                   0

#define RS_SB_KILL_PIX_ROW                      0

#define RS_SB_ODD_ROW                   0

#define RS_SB_SEQ_ROW                   0

// 3d unit to 3d unit register writes.  Not software visible.
#define RASTER_PACKET_WIDTH     80
#define RASTER_PACKET_ARG_WIDTH 20
// there are four of these 20b fields in a RASTER.
// it can carry a packed 5555 argb, a 16b Z, a pair of 10b interps, or
// an S or T coordinate.  in the last case, the bottom 4b contain the
// high or low 4b of the LOD value.  After the TEX_address stage, the S&T
// are replaced with an assortment of values to avoid having to put them
// in a sideband FIFO.

// Packet RAST_R
#define RAST_R_SIZE 40

// whole register
#define RAST_R_R_ROW                    0

// blue component from B5G5R5A5
#define RAST_R_BLUE_ROW                 0

// green component from B5G5R5A5
#define RAST_R_GREEN_ROW                        0

// red component from B5G5R5A5
#define RAST_R_RED_ROW                  0

// alpha component from B5G5R5A5
#define RAST_R_ALPHA_ROW                        0

// low RAST_H-format parameter
#define RAST_R_L10_ROW                  0

// high RAST_H-format parameter
#define RAST_R_H10_ROW                  0

// iterated Z value
#define RAST_R_Z_ROW                    0

// low 3 bits of alpha from B4G6R5A8
#define RAST_R_ALPHA_LOW_ROW                    0

// low 1 bit of green from B5G6R5A8
#define RAST_R_GREEN_LOW_ROW                    0

// lod (packed with texcoords as frac (s) and int (t))
#define RAST_R_TEX_LOD_ROW                      0

// generic texcoord
#define RAST_R_TEX_ROW                  0

// fractional LOD  <<--- here and below are overlays for S,T --->>
#define RAST_R_TEX_LODF_ROW                     0

// pipelined SURFDESC QUADLIN
#define RAST_R_TEX_QUADLIN_ROW                  0

// pipelined SURFDESC SURF_FORMAT
#define RAST_R_TEX_FORMAT_ROW                   0

// # of fraction bits of T to use in bilerp
#define RAST_R_TEX_T_FRAC_ROW                   0

// # of fraction bits of S to use in bilerp
#define RAST_R_TEX_S_FRAC_ROW                   0

// 1 means bilerp texel has collapsed the T dimension
#define RAST_R_TEX_SAME_T_ROW                   0

// 1 means bilerp texel has collapsed the S dimension
#define RAST_R_TEX_SAME_S_ROW                   0

// 1=bilerp, 0=point sample
#define RAST_R_TEX_BILIN_ROW                    0

// Bit 3 of bank 0's memory address
#define RAST_R_TEX_ADR_BNK0_BIT3_ROW                    0

// Bit 3 of bank 1's memory address
#define RAST_R_TEX_ADR_BNK1_BIT3_ROW                    0

// Bit 3 of bank 2's memory address
#define RAST_R_TEX_ADR_BNK2_BIT3_ROW                    0

// Bit 3 of bank 3's memory address
#define RAST_R_TEX_ADR_BNK3_BIT3_ROW                    0

// bit mask for the in line address
#define RAST_R_TEX_IN_LINE_MSK_ROW                      0

// reserved
#define RAST_R_TEX_UNUSED_ROW                   0

// define for s1.8

// Packet RAST_H
#define RAST_H_SIZE 10

#define RAST_H_FX10_ROW                 0

#define RAST_H_FRACTION_ROW                     0

#define RAST_H_INT_ROW                  0

#define RAST_H_SIGN_ROW                 0

// a pixel packet goes down the pipeline, containing nothing, a register
// access, or a row of pixel information.  The bulk of it is the 80b wide
// RASTER field, which itself is really four 20b fields stuck together.
// There are also some sideband fields describing what the packet contains.
// SEQ is essentially an instruction pointer -- each unit uses this to figure
// out what operations to perform on the row.  It is meaningless on register
// accesses but should be set to 0.  Although there is some historical confusion
// over it, TAG is meaningless if KILL is set; if KILL is set, TAG is ignored
// and the information is a dead pixel.  Only the DW cares about the difference.
//
// In the interest of power conservation, only the necessary fields should
// be propagated on clock edges, based on packet contents.
//
// The valid combinations of sideband information is as follows:
//
//   valid, kill, tag, odd
//     0     x     x    x   -- ignore this cycle, don't propagate anything bug valid
//     1     0     0   0/1  -- live even or odd pixel; propagate everything
//     1     1     x   0/1  -- dead even or odd pixel; propagate all flags
//     1     0     1    x   -- live reg read or write; propagate everything

// Packet PIXPKT
#define PIXPKT_SIZE 87

// sequence # -- which instruction to apply to row
#define PIXPKT_SEQ_ROW                  0

// 1=dead pixel, 0=live pixel or register access
#define PIXPKT_KILL_ROW                 0

// meaningless if KILL, else 1=register, 0=pixel
#define PIXPKT_TAG_ROW                  0
#define PIXPKT_TAG_PIX                  0x00000000
#define PIXPKT_TAG_REG                  0x00000001

// indicates even (0) or odd (1) pixel of a pair
#define PIXPKT_X_ROW                    0

// if pixel (tag=0) four packed 20b fields, else register access
#define PIXPKT_RASTER_ROW                       0

#define PIXPKT_R0_ROW                   0

#define PIXPKT_R1_ROW                   0

#define PIXPKT_R2_ROW                   0

#define PIXPKT_R3_ROW                   0


// Packet GK_PIXPKT
#define GK_PIXPKT_SIZE 88

// indicates that the pixel packet has been stalled by the scoreboard
#define GK_PIXPKT_SBSTALLED_ROW                 0

// sequence # -- which instruction to apply to row
#define GK_PIXPKT_SEQ_ROW                       0

// 1=dead pixel, 0=live pixel or register access
#define GK_PIXPKT_KILL_ROW                      0

// meaningless if KILL, else 1=register, 0=pixel
#define GK_PIXPKT_TAG_ROW                       0
#define GK_PIXPKT_TAG_PIX                       0x00000000
#define GK_PIXPKT_TAG_REG                       0x00000001

// indicates even (0) or odd (1) pixel of a pair
#define GK_PIXPKT_X_ROW                 0

// if pixel (tag=0) four packed 20b fields, else register access
#define GK_PIXPKT_RASTER_ROW                    0

#define GK_PIXPKT_R0_ROW                        0

#define GK_PIXPKT_R1_ROW                        0

#define GK_PIXPKT_R2_ROW                        0

#define GK_PIXPKT_R3_ROW                        0


// Packet REG_WRITE
#define REG_WRITE_SIZE 54

#define REG_WRITE_DATA_ROW                      0

#define REG_WRITE_ADDR_ROW                      0

#define REG_WRITE_BLK_ADDR_ROW                  0

#define REG_WRITE_BLK_NUM_ROW                   0
#define REG_WRITE_BLK_NUM_VTX                   0x00000000
#define REG_WRITE_BLK_NUM_SETUP                 0x00000001
#define REG_WRITE_BLK_NUM_RS                    0x00000002
#define REG_WRITE_BLK_NUM_GK                    0x00000003
#define REG_WRITE_BLK_NUM_DF                    0x00000004
#define REG_WRITE_BLK_NUM_ALU                   0x00000005
#define REG_WRITE_BLK_NUM_ALU0                  0x00000006
#define REG_WRITE_BLK_NUM_ALU1                  0x00000007
#define REG_WRITE_BLK_NUM_ALU2                  0x00000008
#define REG_WRITE_BLK_NUM_ALU3                  0x00000009
#define REG_WRITE_BLK_NUM_DW                    0x0000000a
#define REG_WRITE_BLK_NUM_FDC                   0x0000000b
#define REG_WRITE_BLK_NUM_GLB1                  0x0000000e
#define REG_WRITE_BLK_NUM_GLB2                  0x0000000f

#define REG_WRITE_GLB_ROW                       0

#define REG_WRITE_READ_ROW                      0

// channel for register transaction (needed for RAISE/REFCNT writes as well as reads!)
#define REG_WRITE_CHANNEL_ROW                   0

// obsolete (reads always recirc exactly once)
#define REG_WRITE_READ_DONE_ROW                 0

// obsolete, use CHANNEL
#define REG_WRITE_READ_CHAN_ROW                 0


// Packet SCOREBOARD_FLUSH
#define SCOREBOARD_FLUSH_SIZE 14

// 4 Bit mask of valid pixel pairs
#define SCOREBOARD_FLUSH_MASK_ROW                       0

// 9 bit hash address entry {x[6:3],y[4:0]}
#define SCOREBOARD_FLUSH_HASH_ROW                       0

// data is valid
#define SCOREBOARD_FLUSH_VALID_ROW                      0

// -------------------------------------------------------------------
//    GRGK stuff
// -------------------------------------------------------------------
#define LWE297_GK_MAX_LOOP_CNT    8100
#define LWE297_GK_BLK_SB_WIDTH    64
#define LWE297_GK_BLK_SB_WD_INDEX 6
#define LWE297_GK_BLK_SB_DEPTH    32
#define LWE297_GK_BLK_SB_DP_INDEX 5
// -------------------------------------------------------------------
//    TEX stuff
// -------------------------------------------------------------------
//pixpkt latency hiding fifo
#define LW_TEX_PKTFIFO_DEPTH    150
//random stuff bank miss and such
#define LW_TEX_STUFFFIFO_DEPTH  150
#define LW_TEX_RESULTFIFO_DEPTH 150
#define LW_TEX_LODSKIPFIFO_DEPTH        32
// tex inputfifo
//define LW_TEX_INPUTFIFO_DEPTH 8;
// Packet internal to DF block.
// This is the data bundle that lives in the zfifo.
//packet ZFIFO
//   79:0     0   raster          // pixel packet
//   111:80   0   inst            // zifo_inst instruction
//   112      0   pixdone         // pixel done status
//   113      0   tag             // tag/pixel flag
//   114      0   kill            // dead pixel flag
//  118:115  0   seq             // instruction sequence number
//  119      0   flush           // flush ucache status
//;
// Packet internal to DF block.
// This is the data bundle that lives in the cfifo.
//packet CFIFO
//   79:0     0   raster          // pixel packet
//   111:80   0   inst            // zifo_inst instruction
//   112      0   pixdone         // pixel done status
//   113      0   tag             // tag/pixel flag
//   114      0   kill            // dead pixel flag
//   118:115  0   seq             // instruction sequence number
//   123:119  0   pixfmt          // pixel format
//;
// Packet internal to DF block.
// This is the data bundle that lives in the texfifo.

// Packet TEXSTUFFFIFO
#define TEXSTUFFFIFO_SIZE 118

//  Bit 3 of memory address for bank 3
#define TEXSTUFFFIFO_Bnk2_mem_addr_s0_orig_ROW                  0

//  Bit 3 of memory address for bank 2
#define TEXSTUFFFIFO_Bnk0_mem_addr_s0_orig_ROW                  0

//bit 4 of memory addr,selects upper, lower 128 bit chunk
#define TEXSTUFFFIFO_align_Bnk02_ROW                    0

//bit 4 of memory addr,selects upper, lower 128 bit chunk
#define TEXSTUFFFIFO_align_Bnk13_ROW                    0

//s0
#define TEXSTUFFFIFO_s0_ROW                     0

//s1
#define TEXSTUFFFIFO_s1_ROW                     0

//t0
#define TEXSTUFFFIFO_t0_ROW                     0

//t1
#define TEXSTUFFFIFO_t1_ROW                     0

//says this is the last weight for aw or tri-linear.
#define TEXSTUFFFIFO_awtw_last_ROW                      0

//says if the aniso weight and tri weight is valid.(says if doing trilinear or aniso
#define TEXSTUFFFIFO_awtw_ROW                   0

//aniso weigth and trilinear weight combo
#define TEXSTUFFFIFO_awtw_weight_ROW                    0

//linear vs swizzled
#define TEXSTUFFFIFO_layout_ROW                 0

//surface format being read
#define TEXSTUFFFIFO_surf_format_ROW                    0

//fractionla part of t
#define TEXSTUFFFIFO_t_frac_ROW                 0

//fractionla part of s
#define TEXSTUFFFIFO_s_frac_ROW                 0

//whether doing bilinear
#define TEXSTUFFFIFO_bilinear_ROW                       0

//in line address mask
#define TEXSTUFFFIFO_in_line_add_msk_ROW                        0

// upper left texel of four falls in this bank
#define TEXSTUFFFIFO_ul_bnk_ROW                 0

// tex missed on bank 3
#define TEXSTUFFFIFO_Bnk3_miss_req_ROW                  0

// tex missed on bank 2
#define TEXSTUFFFIFO_Bnk2_miss_req_ROW                  0

// tex missed on bank 1
#define TEXSTUFFFIFO_Bnk1_miss_req_ROW                  0

// tex missed on bank 0
#define TEXSTUFFFIFO_Bnk0_miss_req_ROW                  0

//  Bit 3 of memory address for bank 3
#define TEXSTUFFFIFO_Bnk0Bnk2_sm2big_mem_addr_ROW                       0

//  Bit 3 of memory address for bank 3
#define TEXSTUFFFIFO_Bnk1Bnk3_sm2big_mem_addr_ROW                       0

//  Bit 3 of memory address for bank 1
#define TEXSTUFFFIFO_Bnk2_mem_addr_s0_ROW                       0

//  Bit 3 of memory address for bank 0
#define TEXSTUFFFIFO_Bnk0_mem_addr_s0_ROW                       0

// which of bank 0's 32 lines to use
#define TEXSTUFFFIFO_Bnk0_entry_ROW                     0

// bank 0 hit
#define TEXSTUFFFIFO_Bnk0_hit_ROW                       0

// which of bank 1's 32 lines to use
#define TEXSTUFFFIFO_Bnk1_entry_ROW                     0

// bank 1 hit
#define TEXSTUFFFIFO_Bnk1_hit_ROW                       0

// which of bank 2's 32 lines to use
#define TEXSTUFFFIFO_Bnk2_entry_ROW                     0

// bank 2 hit
#define TEXSTUFFFIFO_Bnk2_hit_ROW                       0

// which of bank 3's 32 lines to use
#define TEXSTUFFFIFO_Bnk3_entry_ROW                     0

// bank 3 hit
#define TEXSTUFFFIFO_Bnk3_hit_ROW                       0

// bank miss 0&2 served by same DMC cycle
#define TEXSTUFFFIFO_merge_bnk02_ROW                    0

// bank miss 1&3 served by same DMC cycle
#define TEXSTUFFFIFO_merge_bnk13_ROW                    0

// pixel instruction
#define TEXSTUFFFIFO_instr_ROW                  0

// bottom few bits of integer S and T.
#define TEXSTUFFFIFO_in_line_address_ROW                        0


// Packet TEXRESULTFIFO
#define TEXRESULTFIFO_SIZE 43

//says data was a float
#define TEXRESULTFIFO_lwrrent_float_ROW                 0

//float format
#define TEXRESULTFIFO_float_format_ROW                  0

//used to decide dest of pix
#define TEXRESULTFIFO_sloc_ROW                  0

//used to decide dest of pix
#define TEXRESULTFIFO_tloc_ROW                  0

//pixel or reg data
#define TEXRESULTFIFO_data_ROW                  0

// this communicates the semi-unpacked texel data between the texture cache
// and LW_GRDF_TEX_FORMAT_clw.  the packet has to hold 4b-32b texels as
// well as DXT1 and possible DXT3/DXT5 data.

// Packet TEX_RAWTEX
#define TEX_RAWTEX_SIZE 60

// just  4b texel
#define TEX_RAWTEX_RAW4_ROW                     0

// just  8b texel
#define TEX_RAWTEX_RAW8_ROW                     0

// just 16b texel
#define TEX_RAWTEX_RAW16_ROW                    0

// just 32b texel
#define TEX_RAWTEX_RAW32_ROW                    0

// DXT low color
#define TEX_RAWTEX_COLOR0_ROW                   0

// DXT high color
#define TEX_RAWTEX_COLOR1_ROW                   0

// DXT RGB interpolation index
#define TEX_RAWTEX_RGB_IDX_ROW                  0

// all bits needed for DXT1
#define TEX_RAWTEX_DXT1_ROW                     0

// DXT3 4b alpha
#define TEX_RAWTEX_A_DXT3_ROW                   0

// all bits needed for DXT3
#define TEX_RAWTEX_DXT3_ROW                     0

// DXT5 alpha interpolation index
#define TEX_RAWTEX_A_IDX_ROW                    0

// DXT5 alpha1 < alpha0
#define TEX_RAWTEX_A1LESS_ROW                   0

// DXT5 lesser of alpha0 and alpha1
#define TEX_RAWTEX_ALOWER_ROW                   0

// DXT5 abs(alpha0-alpha1)
#define TEX_RAWTEX_ADELTA_ROW                   0

// all bits needed for DXT5
#define TEX_RAWTEX_DXT5_ROW                     0

//r1 for individual mode
#define TEX_RAWTEX_ETC_S1_R1_INDIV_ROW                  0

//g1 for individual mode
#define TEX_RAWTEX_ETC_S1_G1_INDIV_ROW                  0

//b1 for individual mode
#define TEX_RAWTEX_ETC_S1_B1_INDIV_ROW                  0

//r2 for subblock 2 individual mode
#define TEX_RAWTEX_ETC_S2_R2_INDIV_ROW                  0

//g2 for subblock 2 individual mode
#define TEX_RAWTEX_ETC_S2_G2_INDIV_ROW                  0

//b2 for subblock 2 individual mode
#define TEX_RAWTEX_ETC_S2_B2_INDIV_ROW                  0

//r1 for sub1 in diff mode
#define TEX_RAWTEX_ETC_S1_R1_DIFF_ROW                   0

//g1 for sub1 in diff mode
#define TEX_RAWTEX_ETC_S1_G1_DIFF_ROW                   0

//b1 for sub1 in diff mode
#define TEX_RAWTEX_ETC_S1_B1_DIFF_ROW                   0

//dr2 for diff mode
#define TEX_RAWTEX_ETC_S2_DR2_DIFF_ROW                  0

//dg2 for diff mode
#define TEX_RAWTEX_ETC_S2_DG2_DIFF_ROW                  0

//db2 for diff mode
#define TEX_RAWTEX_ETC_S2_DB2_DIFF_ROW                  0

//etc flip bit 0=2x4 1=4x2
#define TEX_RAWTEX_ETC_FLIPBIT_ROW                      0

//etc diff bit 0 individual mode
#define TEX_RAWTEX_ETC_DIFF_ROW                 0

//etc table 1 code word
#define TEX_RAWTEX_ETC_CW1_ROW                  0

//etc tablle 2 code word
#define TEX_RAWTEX_ETC_CW2_ROW                  0

//code word modifier 0
#define TEX_RAWTEX_ETC_CW_M0_ROW                        0

//code word modifier 1
#define TEX_RAWTEX_ETC_CW_M1_ROW                        0

//code word modifier 2
#define TEX_RAWTEX_ETC_CW_M2_ROW                        0

//code word modifier 3
#define TEX_RAWTEX_ETC_CW_M3_ROW                        0

//all bits needed for etc1
#define TEX_RAWTEX_ETC_ROW                      0

//where color data is
#define TEX_RAWTEX_ETC_COLOR_ROW                        0

//pixel index msb
#define TEX_RAWTEX_ETC_PIXIDX_MSB_ROW                   0

//pixel index lsb
#define TEX_RAWTEX_ETC_PIXIDX_LSB_ROW                   0

//0 = 1 1 = 2
#define TEX_RAWTEX_ETC_SUBBLOCK_ROW                     0

//alpha for etc3
#define TEX_RAWTEX_ETC3_A_ROW                   0

//etc3 bits
#define TEX_RAWTEX_ETC3_ROW                     0

// DXT5 alpha interpolation index
#define TEX_RAWTEX_ETC5_A_IDX_ROW                       0

// DXT5 alpha1 < alpha0
#define TEX_RAWTEX_ETC5_A1LESS_ROW                      0

// DXT5 lesser of alpha0 and alpha1
#define TEX_RAWTEX_ETC5_ALOWER_ROW                      0

// DXT5 abs(alpha0-alpha1)
#define TEX_RAWTEX_ETC5_ADELTA_ROW                      0

//etc5 bits
#define TEX_RAWTEX_ETC5_ROW                     0

// latc2 2nd alpha interpolation index
#define TEX_RAWTEX_A_IDX_1_ROW                  0

// latc2 2nd alpha alpha1 < alpha0
#define TEX_RAWTEX_A1LESS_1_ROW                 0

// latc 2nd alpha lesser of alpha0 and alpha1
#define TEX_RAWTEX_ALOWER_1_ROW                 0

// latc2 2nd alpha abs(alpha0-alpha1)
#define TEX_RAWTEX_ADELTA_1_ROW                 0

// dependent variables -- don't change the stuff below
// number of bits required to hold pix address within T$ line.
// for 256b lines, tile ranges from 64x1 to 8x8
#define LWE297_TEX_INLINE_ADDR_SIZE       7
// enough for up to 256b cachelines
#define LWE297_TEX_INLINE_S_ADDR_SIZE     4
// S[3:0]
#define LWE297_TEX_INLINE_T_ADDR_SIZE     3
// S[6:4] or T[2:0]
// ========== GRDF FIFO DEFINITIONS ==========
// The GRDF latency hiding FIFOs are sized by these parameters below.
// Each is explained a bit before it is defined.  Keep in mind that the
// depth of the Z/C/TEX FIFOs is in terms of PIXPKT rows, which is not
// necessarily the same as a pixel.  Also, the memory system may be
// clocked at a different rate than lwclk, so the latencies of the
// two sides of the async interface need to be accounted for.  also,
// each request is for 128b of data, so if the memory controller is
// more narrow than that, each request oclwpies multiple mclk cycles.
// This defines the depth of the FIFO between the Z request and and the
// Z compare stages.  It has two purposes: the first purpose is to hold
// pixel information until the requested old Z value comes back from the
// DMC.  The second purpose is to provide some elasticity to the pipeline
// in case the downstream pipe stalls, allowing the Z stage to keep getting
// work done.
//
// In the worst case, there is one request made to the DMC for each pixel,
// and pixels may be processed on per clock.  More typically, there is one
// request each 6-8 pixels, and each pixel take two to four clocks.  In the
// worst case, the FIFO must be at least as deep as the DF_DMC_FIFO_DEPTH
// parameter; this sets the lower bound on the size.  For better
// performance, this FIFO should be bigger than that.
// it doesn't need to be this big, but it is the smallest ramgen can make
//define LW_DF_ZFIFO_DEPTH 64;
// This defines the depth of the FIFO between the C request and and the
// C update stages.  Its purpose is analagous to that of DF_ZFIFO_DEPTH,
// and the same reasoning applies.  However, its depth is independent
// of DF_ZFIFO_DEPTH, other than both are constrained to be at least as
// large as DF_DMC_FIFO_DEPTH.
// it doesn't need to be this big, but it is the smallest ramgen can make
//define LW_DF_CFIFO_DEPTH 64;
// This defines the depth of the FIFO between the TEX request stage and
// the TEX cache stage.  Because the TEX stage is given highest priority
// in the DMCIF, it doesn't need to be as deep as the Z and C FIFOs.
// Also, a pixel can result in one to eight DMC requests, so there is less
// need to have a multiple of the DMC_FIFO depth.
// it doesn't need to be this big, but it is the smallest ramgen can make
//define LW_TEX_TFIFO_DEPTH 64;
// tex inputfifo
//define TEX_INPUTFIFO_DEPTH 2;
//define TEX_INPUTFIFO_WIDTH 96;
// -------------------------------------------------------------------
//    GRALU stuff
// -------------------------------------------------------------------
// The programmer sees two 20b TEMP registers and four 20b CONST registers.
// The CONST registers can be referenced by all pixels, but the TEMP
// registers should only be referenced between the rows of one pixel for
// a given pass.  That is, imagine that the TEMP registers are ilwalidated
// before the first row of a given pass.
//
// In HW, there is a two-way interleave of pixels in the pipeline in order
// to hide the two-clock ALU computation latency so that the results of
// row N's computation can be written to the TEMP and used by row (N+1)'s
// computation.
// There are 4 constant registers in 2 banks for a pixel to use.  Only one
// bank of constants can be used at one time, and are selected by the BANK
// field of the alu INST0 register.   Constants are implemented using a
// single register for each and are not context switched like TEMP
// registers.  A single constant register is readable from either context,
// but can only be written using a register write.
//
// Constants are useful for holding constant values, but since they
// are not writable using the result of the ALU, they cannot forward
// values from one row of the instruction to the next.  A TEMP
// register should be used instead.
// -------------------------------------------------------------------
//    DWR stuff
// -------------------------------------------------------------------
#define DW_CACHE_LINE_SIZE      128
// used by cmod/dwr
// display use BGRA and dw now conforms.
// If there is code that uses RGBA, it should be corrected

// Packet DW_PAYLD
#define DW_PAYLD_SIZE 80

#define DW_PAYLD_BLUE_0_ROW                     0

#define DW_PAYLD_GREEN_0_ROW                    0

#define DW_PAYLD_RED_0_ROW                      0

#define DW_PAYLD_ALPHA_0_ROW                    0

#define DW_PAYLD_RED_1_ROW                      0

#define DW_PAYLD_GREEN_1_ROW                    0

#define DW_PAYLD_BLUE_1_ROW                     0

#define DW_PAYLD_ALPHA_1_ROW                    0


// Packet DW_COLOR_FMT10
#define DW_COLOR_FMT10_SIZE 10

#define DW_COLOR_FMT10_SIGN_ROW                 0

#define DW_COLOR_FMT10_INT_ROW                  0

#define DW_COLOR_FMT10_FRACTION_ROW                     0

#define DW_COLOR_FMT10_COLOR_ROW                        0


// Packet DW_MEM_PKT
#define DW_MEM_PKT_SIZE 179

#define DW_MEM_PKT_MEM_PAYLD_0_ROW                      0

#define DW_MEM_PKT_MEM_PAYLD_1_ROW                      0

#define DW_MEM_PKT_MEM_PAYLD_2_ROW                      0

#define DW_MEM_PKT_MEM_PAYLD_3_ROW                      0

#define DW_MEM_PKT_ADDR_ROW                     0

#define DW_MEM_PKT_BE_ROW                       0

#define DW_MEM_PKT_PKT_TYPE_ROW                 0
#define DW_MEM_PKT_PKT_TYPE_CVAL                        0x00000000
#define DW_MEM_PKT_PKT_TYPE_ZVAL                        0x00000001

// PS for pixel seen.  Include written, killed, skipped.

// Packet DW_SB_PKT
#define DW_SB_PKT_SIZE 17

#define DW_SB_PKT_TYPE_ROW                      0
#define DW_SB_PKT_TYPE_CVAL                     0x00000000
#define DW_SB_PKT_TYPE_ZVAL                     0x00000001
#define DW_SB_PKT_TYPE_BOTH                     0x00000002
#define DW_SB_PKT_TYPE_PS                       0x00000003
#define DW_SB_PKT_TYPE_RAISE                    0x00000004

// 4 Bit mask of valid pixel pairs
#define DW_SB_PKT_MASK_ROW                      0

// 7 bit hash address entry
#define DW_SB_PKT_HASH_ROW                      0

// data is valid
#define DW_SB_PKT_VALID_ROW                     0


// Packet DW_SB_PS_CACHE
#define DW_SB_PS_CACHE_SIZE 8

#define DW_SB_PS_CACHE_PIX0_ROW                 0

#define DW_SB_PS_CACHE_PIX1_ROW                 0

#define DW_SB_PS_CACHE_PIX2_ROW                 0

#define DW_SB_PS_CACHE_PIX3_ROW                 0

#define DW_SB_PS_CACHE_PIX4_ROW                 0

#define DW_SB_PS_CACHE_PIX5_ROW                 0

#define DW_SB_PS_CACHE_PIX6_ROW                 0

#define DW_SB_PS_CACHE_PIX7_ROW                 0

// this is highly related to the SCOREBOARD_FLUSH packet type.  it used to
// be that DWR internally used the same type, but when it was generalized
// very late in the sc15 design cycle to handle 8b to 32b pixels and not
// just 16b pixels, the pixel pair mask had to be grown.  there wasn't time
// to change the rest of the design, so internally DWR has a fifo with
// the wide pixel masks that a small state machine breaks down into chunks
// that GRGK already knows how to deal with.
//

// Packet DW_SBFIFO
#define DW_SBFIFO_SIZE 18

// color surface was written
#define DW_SBFIFO_WRITE_C_ROW                   0

// depth surface was written
#define DW_SBFIFO_WRITE_Z_ROW                   0

// 8 bit mask of valid pixel pairs
#define DW_SBFIFO_MASK_ROW                      0

// y[4:0] part of it
#define DW_SBFIFO_HASH_Y_ROW                    0

// x[6:4] part of it; x[3] is recovered from mask
#define DW_SBFIFO_HASH_X_ROW                    0

// PR for pair

// Packet DW_SB_MASK
#define DW_SB_MASK_SIZE 4

#define DW_SB_MASK_PR0_ROW                      0

#define DW_SB_MASK_PR1_ROW                      0

#define DW_SB_MASK_PR2_ROW                      0

#define DW_SB_MASK_PR3_ROW                      0


// Packet FAKE_VID_PIXEL
#define FAKE_VID_PIXEL_SIZE 54

#define FAKE_VID_PIXEL_CMD_ROW                  0
#define FAKE_VID_PIXEL_CMD_PIX                  0x00000000
#define FAKE_VID_PIXEL_CMD_LASTH_PIX                    0x00000001
#define FAKE_VID_PIXEL_CMD_LASTV_PIX                    0x00000002

#define FAKE_VID_PIXEL_X_ROW                    0

#define FAKE_VID_PIXEL_Y_ROW                    0

#define FAKE_VID_PIXEL_RED_ROW                  0

#define FAKE_VID_PIXEL_GREEN_ROW                        0

#define FAKE_VID_PIXEL_BLUE_ROW                 0

//
// Internal packet definitions for geometry interfaces
//
// Much of this is tied to the lw46 definitions
//
// HACK HACK HACK - the log2() defines don't want to pass through...
//#define IBB    LW_GR3D_VPE_IBUF_BITS
//#define OBB    LW_GR3D_VPE_OBUF_BITS
//#define IBRB   LW_GR3D_VPE_IBUF_RAM_BITS
//#define OBRB   LW_GR3D_VPE_OBUF_RAM_BITS
//#define VRB    LW_GR3D_VPE_RAMBITS
// OK, we'll do this the hard way...
#define IBUF_BITS       3
#define OBUF_BITS       4
#define IBUF_RAM_BITS   6
#define OBUF_RAM_BITS   6
// idx2clip interface - host traffic inbound to rest of pipe

// Packet IDX2CLIP
#define IDX2CLIP_SIZE 49

// register write data or read result data
#define IDX2CLIP_DATA_ROW                       0

// register address
#define IDX2CLIP_ADDR_ROW                       0

// transaction type, read=1, write=0
#define IDX2CLIP_READ_ROW                       0

// host channel ID (for RAISE/REFCNT/READ)
#define IDX2CLIP_CHANNEL_ROW                    0

// pseq2idx interface - host traffic outbound from rest of pipe

// Packet PSEQ2IDX
#define PSEQ2IDX_SIZE 38

// read data
#define PSEQ2IDX_DATA_ROW                       0

// destination channel
#define PSEQ2IDX_CHANNEL_ROW                    0

// response type
#define PSEQ2IDX_TYPE_ROW                       0
#define PSEQ2IDX_TYPE_READ                      0x00000000
#define PSEQ2IDX_TYPE_RAISE                     0x00000001
#define PSEQ2IDX_TYPE_REFCNT                    0x00000002

// idx2vpe packet - attribute data and VPE state, plus some other stuff

// Packet IDX2VPE
#define IDX2VPE_SIZE 190

// x component, insn 127:96, or bundle ID
#define IDX2VPE_DATA_0_ROW                      0

// y component, insn  95:64, or bundle data
#define IDX2VPE_DATA_1_ROW                      0

// z component, insn  63:32
#define IDX2VPE_DATA_2_ROW                      0

// w component, insn  31:0
#define IDX2VPE_DATA_3_ROW                      0

// IBUF RAM address
#define IDX2VPE_ADDR_ROW                        0

// IBUF load valid
#define IDX2VPE_VALID_ROW                       0

// write enable mask, or ibuf slot(2:0)
#define IDX2VPE_MASK_ROW                        0

// const/insn/bundle addr, or obuf slot(2:0)
#define IDX2VPE_VABCTXADDR_ROW                  0

// transform cmd
#define IDX2VPE_COMMAND_ROW                     0
#define IDX2VPE_COMMAND_NOP                     0x00000000
#define IDX2VPE_COMMAND_VAB                     0x00000001
#define IDX2VPE_COMMAND_XFPR                    0x00000002
#define IDX2VPE_COMMAND_PASSTHR                 0x00000005
#define IDX2VPE_COMMAND_CONST                   0x0000000b

// command bus is valid (launch if VAB)
#define IDX2VPE_LAUNCH_ROW                      0

// debug register settings
#define IDX2VPE_PRI_DEBUG_ROW                   0

// thread controls
#define IDX2VPE_PRI_CTRL_ROW                    0

// clear OBUF in-use flag
#define IDX2VPE_OBUF_AVAIL_ROW                  0

// stat collection enable
#define IDX2VPE_STEN_ROW                        0

// VPE bundle addresses (passed in DATA_0)
#define VPE_GE_PROGRAM_CTRL_BUNDLE      204
#define VPE_ATTRIBINPUTMASK_BUNDLE      205
#define VPE_ATTRIBOUTPUTMASK_BUNDLE     206
#define VPE_GEOM_STALL_BUNDLE   224
#define VPE_GE_PROGRAM_TIMEOUT_BUNDLE   227
#define VPE_GE_CONST_LIMITS_BUNDLE      231
#define VPE_BRANCHBITS_BUNDLE   237
#define VPE_PIPE_NOP_BUNDLE     497
// VPE bundle layouts for non-trival bundles...

// Packet VPE_GE_PROGRAM_CTRL
#define VPE_GE_PROGRAM_CTRL_SIZE 32

#define VPE_GE_PROGRAM_CTRL_PROGRAM_START_ROW                   0

#define VPE_GE_PROGRAM_CTRL_SIGNED_ZERO_COMPARE_ROW                     0
#define VPE_GE_PROGRAM_CTRL_SIGNED_ZERO_COMPARE_UNEQUAL                 0x00000000
#define VPE_GE_PROGRAM_CTRL_SIGNED_ZERO_COMPARE_EQUAL                   0x00000001

#define VPE_GE_PROGRAM_CTRL_MODE_ROW                    0
#define VPE_GE_PROGRAM_CTRL_MODE_FIXED                  0x00000000
#define VPE_GE_PROGRAM_CTRL_MODE_PROGRAM                        0x00000002
#define VPE_GE_PROGRAM_CTRL_MODE_PROGRAM_V2                     0x00000003
#define VPE_GE_PROGRAM_CTRL_MODE_PROGRAM_V3                     0x00000001


// Packet VPE_GEOM_STALL
#define VPE_GEOM_STALL_SIZE 17

#define VPE_GEOM_STALL_STALL_ROW                        0

#define VPE_GEOM_STALL_FLUSH_ROW                        0


// Packet VPE_GE_PROGRAM_TIMEOUT
#define VPE_GE_PROGRAM_TIMEOUT_SIZE 17

#define VPE_GE_PROGRAM_TIMEOUT_COUNT_ROW                        0

#define VPE_GE_PROGRAM_TIMEOUT_REGISTER_COUNT_ROW                       0
#define VPE_GE_PROGRAM_TIMEOUT_REGISTER_COUNT_RC32                      0x00000000
#define VPE_GE_PROGRAM_TIMEOUT_REGISTER_COUNT_RC48                      0x00000001


// Packet VPE_GE_CONST_LIMITS
#define VPE_GE_CONST_LIMITS_SIZE 26

#define VPE_GE_CONST_LIMITS_MIN_ROW                     0

#define VPE_GE_CONST_LIMITS_MAX_ROW                     0

// vpe2idx interface - reference counts and status

// Packet VPE2IDX
#define VPE2IDX_SIZE 7

// All IBUFs free and fifo empty
#define VPE2IDX_IDLE_ROW                        0

// Decrement mode counter by 0/1/2
#define VPE2IDX_RETIRE_MODE_ROW                 0

// RETIRE_IBUF signal is valid
#define VPE2IDX_RETIRE_VALID_ROW                        0

// Retire this IBUF
#define VPE2IDX_RETIRE_IBUF_ROW                 0

// idx2vpe_readaddr interface - const/iram read requests

// Packet IDX2VPE_READADDR
#define IDX2VPE_READADDR_SIZE 9

// address
#define IDX2VPE_READADDR_ADDR_ROW                       0

// which ram to read
#define IDX2VPE_READADDR_WHICH_ROW                      0
#define IDX2VPE_READADDR_WHICH_CONST                    0x00000000
#define IDX2VPE_READADDR_WHICH_INSN                     0x00000001

// vpe2idx_readdata - const/iram read response

// Packet VPE2IDX_READDATA
#define VPE2IDX_READDATA_SIZE 128

// read result from const/insn ram
#define VPE2IDX_READDATA_DATA_ROW                       0

// clip2idx interface - reference counts

// Packet CLIP2IDX
#define CLIP2IDX_SIZE 32

// decrement counter for obufs due to lwll
#define CLIP2IDX_LWLL_ROW                       0

// decrement counter for obufs due to pos. read
#define CLIP2IDX_READ_ROW                       0

// vpe2clip interface - reference counts

// Packet VPE2CLIP
#define VPE2CLIP_SIZE 9

// thread completed for this obuf
#define VPE2CLIP_DONE_ROW                       0

// obuf size in attributes
#define VPE2CLIP_OBUF_STRIDE_ROW                        0

// this is the unified position/attribute bus instead of seperate as in lw4x
// clip2vpe_attraddr interface

// Packet CLIP2VPE_ATTRADDR
#define CLIP2VPE_ATTRADDR_SIZE 11

// OBUF ram address to read (attr or pos)
#define CLIP2VPE_ATTRADDR_READADDR_ROW                  0

// OBUF slot to read (if POS_VALID)
#define CLIP2VPE_ATTRADDR_OBUFADDR_ROW                  0

// If true, reading position (attribute 0)
#define CLIP2VPE_ATTRADDR_POS_VALID_ROW                 0

// vpe2clip_attrdata interface

// Packet VPE2CLIP_ATTRDATA
#define VPE2CLIP_ATTRDATA_SIZE 149

// attribute x component
#define VPE2CLIP_ATTRDATA_ATTR_0_ROW                    0

// attribute y component
#define VPE2CLIP_ATTRDATA_ATTR_1_ROW                    0

// attribute z component
#define VPE2CLIP_ATTRDATA_ATTR_2_ROW                    0

// attribute w component
#define VPE2CLIP_ATTRDATA_ATTR_3_ROW                    0

// which components were written (only valid if attribute was written)
#define VPE2CLIP_ATTRDATA_WRITTEN_ROW                   0

// which attributes were written (only valid if pos_valid set)
#define VPE2CLIP_ATTRDATA_ATTRIBUTES_ROW                        0

// this was a position read
#define VPE2CLIP_ATTRDATA_POS_VALID_ROW                 0

// -------------------------------------------------------------------
//    SC25 stuff
// -------------------------------------------------------------------
//below are the PAYLOADs for PIXSHDRPKT

// Packet PIXSHADERPKT
#define PIXSHADERPKT_SIZE 100

// previously the kill code, now a packet state
#define PIXSHADERPKT_STATE_ROW                  0
#define PIXSHADERPKT_STATE_REGISTER                     0x00000000
#define PIXSHADERPKT_STATE_SPANSTART                    0x00000001
#define PIXSHADERPKT_STATE_Z_PASS                       0x00000002
#define PIXSHADERPKT_STATE_Z_FAIL                       0x00000003
#define PIXSHADERPKT_STATE_S_FAIL                       0x00000004
#define PIXSHADERPKT_STATE_KILL                 0x00000005
#define PIXSHADERPKT_STATE_NON_CENTER                   0x00000006

// debug bit.  set based on conditions and
//      INSTRUMENT.STAT_EN used to filter debug/stats
#define PIXSHADERPKT_DBG_ROW                    0

// contains fields for PIXSHADERPKT_PIX,
// PIXSHADERPKT_SPAN, or PIXSHADERPKT_REG.
#define PIXSHADERPKT_PAYLOAD_ROW                        0

//
//below are the different shader packet types
//
// PIXELS

// Packet PIXSHADERPKT_PIX
#define PIXSHADERPKT_PIX_SIZE 100

// previously the kill code, now a packet state
#define PIXSHADERPKT_PIX_STATE_ROW                      0
#define PIXSHADERPKT_PIX_STATE_Z_PASS                   0x00000002
#define PIXSHADERPKT_PIX_STATE_Z_FAIL                   0x00000003
#define PIXSHADERPKT_PIX_STATE_S_FAIL                   0x00000004
#define PIXSHADERPKT_PIX_STATE_KILL                     0x00000005
#define PIXSHADERPKT_PIX_STATE_NON_CENTER                       0x00000006

// DBG bit (used for filtering debug and stats)
#define PIXSHADERPKT_PIX_DBG_ROW                        0

// Which pixel of the quad does this packet
// ,-------.    belong to.
// | 0 | 1 |
// |---+---|
// | 2 | 3 |
// `-------'
#define PIXSHADERPKT_PIX_INTERLEAVE_ROW                 0

// Sequence number -- used to index instruction
// tables or remap tables
#define PIXSHADERPKT_PIX_SEQ_ROW                        0

// set if this pixel is scoreboarded (and needs to
// clear the scoreboard when killed).
#define PIXSHADERPKT_PIX_SB_ROW                 0

// bit which is used for conditional execute
#define PIXSHADERPKT_PIX_CX_ROW                 0
#define PIXSHADERPKT_PIX_CX_EXELWTE                     0x00000000
#define PIXSHADERPKT_PIX_CX_NO_EXELWTE                  0x00000001

// VCAA bits for the first row of the pixel
#define PIXSHADERPKT_PIX_VCAA_ROW                       0

// predicate bits for all but the first row
// of the pixel
#define PIXSHADERPKT_PIX_PREDICATE_ROW                  0

// provides dx and dy for next quad
// dy[4:3] comes from interleave 0
// dy[2:1] comes from interleave 1
// dx[4:3] comes from interleave 2
// dx[2:1] comes from interleave 3
#define PIXSHADERPKT_PIX_DELTA_ROW                      0

// register fields
#define PIXSHADERPKT_PIX_RASTER_ROW                     0

//FP20
#define PIXSHADERPKT_PIX_R0_ROW                 0

//FX10
#define PIXSHADERPKT_PIX_R0_HI_ROW                      0

//FX10
#define PIXSHADERPKT_PIX_R0_LO_ROW                      0

//FP20
#define PIXSHADERPKT_PIX_R1_ROW                 0

//FX10
#define PIXSHADERPKT_PIX_R1_HI_ROW                      0

//FX10
#define PIXSHADERPKT_PIX_R1_LO_ROW                      0

//FP20
#define PIXSHADERPKT_PIX_R2_ROW                 0

//FX10
#define PIXSHADERPKT_PIX_R2_HI_ROW                      0

//FX10
#define PIXSHADERPKT_PIX_R2_LO_ROW                      0

//FP20
#define PIXSHADERPKT_PIX_R3_ROW                 0

//FX10
#define PIXSHADERPKT_PIX_R3_HI_ROW                      0

//FX10
#define PIXSHADERPKT_PIX_R3_LO_ROW                      0

//
// SPANSTARTS

// Packet PIXSHADERPKT_SPAN
#define PIXSHADERPKT_SPAN_SIZE 100

// previously the kill code, now a packet state
#define PIXSHADERPKT_SPAN_STATE_ROW                     0
#define PIXSHADERPKT_SPAN_STATE_SPANSTART                       0x00000001

// DBG bit (used for filtering debug and stats)
#define PIXSHADERPKT_SPAN_DBG_ROW                       0

// sequence # what is the seq for the first row
// of pixels to follow
#define PIXSHADERPKT_SPAN_SEQ_ROW                       0

// Quad Identifier for the next pixel quad.
// Unique for each quad in the
// pseq->dw loop and used by ST/LD_R20 and
// ST/LD_R80 addressing.
// should have a value between 0 and PSEQ_CTL.fMAX_QID.
#define PIXSHADERPKT_SPAN_QID_ROW                       0

// bit to indicate the oldest spanstart in the pipe
#define PIXSHADERPKT_SPAN_HEAD_ROW                      0

// bit to indicate if dw should spill this and
// following pixels
#define PIXSHADERPKT_SPAN_SPILL_ROW                     0

// bit to indicate if triangle is front or back facing
#define PIXSHADERPKT_SPAN_FACE_ROW                      0
#define PIXSHADERPKT_SPAN_FACE_FRONT                    0x00000000
#define PIXSHADERPKT_SPAN_FACE_BACK                     0x00000001

// which tri
// used by atrast for tram lookup, and pseq
// for quad count update to qr
// span_x and span_y provide x,y for the
// next pixel quad.
#define PIXSHADERPKT_SPAN_TRI_ID_ROW                    0

// x<11: 1> = SPAN_X, x< 0: 0> = 0
#define PIXSHADERPKT_SPAN_SPAN_X_ROW                    0

// y<11: 1> = SPAN_Y, y< 0: 0> = 0
#define PIXSHADERPKT_SPAN_SPAN_Y_ROW                    0

//
// REGISTERS

// Packet PIXSHADERPKT_REG
#define PIXSHADERPKT_REG_SIZE 100

// Packet state
#define PIXSHADERPKT_REG_STATE_ROW                      0
#define PIXSHADERPKT_REG_STATE_REGISTER                 0x00000000

// DBG bit (used for filtering debug and stats)
#define PIXSHADERPKT_REG_DBG_ROW                        0

// extra data written to ADDR if DATA1_WR_EN is set
#define PIXSHADERPKT_REG_DATA1_ROW                      0

// channel for register transaction (needed for
// RAISE/REFCNT writes as well as reads!)
#define PIXSHADERPKT_REG_CHANNEL_ROW                    0

// set if data1 has register data to write
#define PIXSHADERPKT_REG_DATA1_WR_EN_ROW                        0

// set for register reads
#define PIXSHADERPKT_REG_READ_ROW                       0

// set if dw stores register reads (P1 feature)
#define PIXSHADERPKT_REG_DW_ST_ROW                      0

// bits that point at the block
#define PIXSHADERPKT_REG_BLK_NUM_ROW                    0
#define PIXSHADERPKT_REG_BLK_NUM_CTL                    0x00000000
#define PIXSHADERPKT_REG_BLK_NUM_IDX                    0x00000001
#define PIXSHADERPKT_REG_BLK_NUM_VPE                    0x00000002
#define PIXSHADERPKT_REG_BLK_NUM_SU                     0x00000003
#define PIXSHADERPKT_REG_BLK_NUM_QR                     0x00000004
#define PIXSHADERPKT_REG_BLK_NUM_PSEQ                   0x00000005
#define PIXSHADERPKT_REG_BLK_NUM_AT                     0x00000006
#define PIXSHADERPKT_REG_BLK_NUM_TEX                    0x00000007
#define PIXSHADERPKT_REG_BLK_NUM_ALU                    0x00000008
#define PIXSHADERPKT_REG_BLK_NUM_DW                     0x00000009
#define PIXSHADERPKT_REG_BLK_NUM_FDC                    0x0000000a
#define PIXSHADERPKT_REG_BLK_NUM_GLB1                   0x0000000e
#define PIXSHADERPKT_REG_BLK_NUM_GLB2                   0x0000000f

// offset within the block
#define PIXSHADERPKT_REG_BLK_ADDR_ROW                   0

// whole address
#define PIXSHADERPKT_REG_ADDR_ROW                       0

// read/write data
#define PIXSHADERPKT_REG_DATA_ROW                       0

//------- NON W NORMALIZED BARY DEFINITIONS----------------//
// DCDX/DCDY width is 18 (LW_GR3D_XRES_LOG2) + 1 (SIGN) + 4 (SNAP) + 1 (OVERFLOW)
#define BARY_DC_WIDTH   18
#define BARY_C_WIDTH    37
//------- W NORMALIZED BARY DEFINITIONS----------------//
// 4 bits of magic needed to account for W factor in DC
//#define BARY_W_C_WIDTH_I (2*BARY_W_DC_WIDTH_I + 1)
#define BARY_W_DC_WIDTH 22
#define BARY_W_C_WIDTH  38
//---------------------------------------------------------//
// QRAST slopes RAM stuff
#define QRAST_SL_RAM_WIDTH      228
//------- LWBEMAP FACE DEFINITIONS -------//
// The lwbe flattens like this:
//   2
// 1 4 0 5
//   3
//
//define LWBEMAP_FACE_POSITIVE_X   0;
//define LWBEMAP_FACE_NEGATIVE_X   1;
//define LWBEMAP_FACE_POSITIVE_Y   2;
//define LWBEMAP_FACE_NEGATIVE_Y   3;
//define LWBEMAP_FACE_POSITIVE_Z   4;
//define LWBEMAP_FACE_NEGATIVE_Z   5;
// three bit field to encode the above values
//define LWBEMAP_FACE_SIZE  3;

// Packet LWBEMAP_FACE
#define LWBEMAP_FACE_SIZE 3

//lwbemap
#define LWBEMAP_FACE_FACE_ROW                   0
#define LWBEMAP_FACE_FACE_POSITIVE_X                    0x00000000
#define LWBEMAP_FACE_FACE_NEGATIVE_X                    0x00000001
#define LWBEMAP_FACE_FACE_POSITIVE_Y                    0x00000002
#define LWBEMAP_FACE_FACE_NEGATIVE_Y                    0x00000003
#define LWBEMAP_FACE_FACE_POSITIVE_Z                    0x00000004
#define LWBEMAP_FACE_FACE_NEGATIVE_Z                    0x00000005

// -------------------------------------------------------------------
//    FDC stuff
// -------------------------------------------------------------------
// some general defines for FDC
// For qrast clients. qrast latency hiding FIFO is 64 deep.
#define LW_FDC_PSEQ_CLIENT_LATENCY      32
#define LW_FDC_CLIENT_LATENCY   150
// defines in LWE297_fdc.spec
// --------------------------------------------------------------------------
//
// Copyright (c) 2005, LWPU Corp.
// All Rights Reserved.
//
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of LWPU Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of LWPU Corp.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
//
// --------------------------------------------------------------------------
// 
// This file has all the internal packet definitions related to FDC unit in AR20
// This file is included by LWE297_internal.spec
// Internal FDC defines
//
//      Misc. MC bus sizes.
// 
//
//      defines for vmod/cmod
//
#define LW_FDC_MC_AW    32
#define LW_FDC_MC_WDLOG2        5
#define LW_FDC_MC_MW    256
#define LW_FDC_ADDR_WIDTH       29
#define LW_FDC_DATA_WIDTH       64
#define LW_FDC_BE_WIDTH 8
#define LW_FDC_OFFS_WIDTH       2
#define LW_FDC_TAG_WIDTH        27
//      SPLIT MC accesses between SRAM/DRAM or odd/even
#define LW_FDC_USE_SPLIT_MC_ODD_EVEN    0
//      DRAM/SRAM
//      ODD/EVEN
// 0 -> even=xt  /  odd=int
// 1 -> even=int /  odd=xt
//      chose which one we want in RTL or C-model based on 
//      LW_FDC_SPLIT_MC_ODD_EVEN (unless register to program)
#define LW_FDC_XMEM_SPLITBIT    26
#define LW_FDC_XMEM_SELECT      0
#define LW_FDC_ODD_EVEN_SPLITBIT        0
#define LW_FDC_ODD_EVEN_SELECT  0
//
// scoreboard packet for fdc
//   QUAD_X - 10 bits.
//   QUAD_Y - 10 bits.
//   MASK - 4 bit pixel mask. [2][2]
//
// Need those defines
//
//      L2 defines
//
#define LW_FDC_L2_SIZE  32768
#define LW_FDC_L2_LINE_SIZE     256
#define LW_FDC_L2_LINES 128
#define LW_FDC_L2_SETS  1
#define LW_FDC_L2_WAYS  128
#define LW_FDC_L2_MEM_COLUMNS   4
#define LW_FDC_L2_MEM_SEGMENTS  2
#define LW_FDC_L2_MEM_SEGMENTS_LOG2     1
#define LW_FDC_L2_MEM_BANKS     8
// bit-width of max reads count per read_clean L2 line before 
// dirty line is marked as clean
//define LW_FDC_READ_CLEAN_CNT_WIDTH     LW_FDC_OFFS_WIDTH
#define LW_FDC_READ_CLEAN_CNT_WIDTH     1
//      PRNG for random line replacement uses primitive polynomials with 
//      sequence length 2^n - 1.
//      Polynomial:
//      P(x) = C(n)*x^n + C(n-1)*x^(n-1) + C(n-2)*x^(n-2) + ... + C(1)*x^1 + C(0)*x^0
//      (C(n) and C(0) are 1)
//      written as C(n)C(n-1),,,C(1)
//      n = 16  10001000000001011 [16,12,3,1,0]
//
//      LFSR implementation:
//      need to colwert simple polynomial into modular polynomial (=flip)
//      n = 16  11010000000010001 [16,15,13,4,0] = pol[16:0]
//
//      fb = lfsr[n-1] (lfsr[n-1]*pol[n])       // pol[n] always 1
//      lfsr[n-1] = lfsr[n-2] + fb*pol[n-1] 
//      lfsr[n-2] = lfsr[n-3] + fb*pol[n-2] 
//      ...
//      lfsr[1]   = lfsr[0]   + fb*pol[1] 
//      lfsr[0]   =           + fb (fb*pol[0])  // pol[0] always 1
// polynomials:
// LFSR size
#define LW_FDC_REPL_LFSR_SIZE   16
#define LW_FDC_REPL_POL 106513
//
//      L1 defines
//
//
//      ADDRESS packet: Tag/Offset. shared between all FDC L1 packets
//

// Packet LW_FDC_REQ_ADDRESS
#define LW_FDC_REQ_ADDRESS_SIZE 29

#define LW_FDC_REQ_ADDRESS_TAG_ROW                      0

#define LW_FDC_REQ_ADDRESS_OFFSET_ROW                   0

//      2.) maximum requests per 64 bit address
#define LW_FDC_L1RREQ_MAXREQ    4
#define LW_FDC_L1RREQ_MAXREQ_CNT_WIDTH  2
//
//      3.) Pending queue FIFO defines
//      3a.) FIFO depths & widths (read only)
//           Write pend Q is only 2 deep (for pipelining)
//#define FDC_L1RREQ_QFIFO_DEPTH          8
//#define FDC_L1RREQ_QFIFO_DEPTH          ((FDC_CLIENT_LATENCY+3)/4)
//#define FDC_L1RREQ_QFIFO_DEPTH          ((FDC_CLIENT_LATENCY+3)>>2)
#define LW_FDC_L1RREQ_SV_QFIFO_DEPTH    38
#define LW_FDC_L1RREQ_Z_QFIFO_DEPTH     75
#define LW_FDC_L1RREQ_P_QFIFO_DEPTH     32
//      3b.) Packet for L1 read pending queue

// Packet LW_FDC_L1RREQ_PENDQUEUE
#define LW_FDC_L1RREQ_PENDQUEUE_SIZE 13

#define LW_FDC_L1RREQ_PENDQUEUE_RELEASE_ROW                     0

#define LW_FDC_L1RREQ_PENDQUEUE_REQ_MODE_ROW                    0
#define LW_FDC_L1RREQ_PENDQUEUE_REQ_MODE_PIXEL                  0x00000000
#define LW_FDC_L1RREQ_PENDQUEUE_REQ_MODE_REGISTER                       0x00000001

// register address encode address packet overlap
#define LW_FDC_L1RREQ_PENDQUEUE_LINE_MODE_ROW                   0
#define LW_FDC_L1RREQ_PENDQUEUE_LINE_MODE_L64BIT                        0x00000000
#define LW_FDC_L1RREQ_PENDQUEUE_LINE_MODE_L128BIT                       0x00000001

#define LW_FDC_L1RREQ_PENDQUEUE_REG_ENC_ADDRESS_ROW                     0

#define LW_FDC_L1RREQ_PENDQUEUE_LINE_ROW                        0

#define LW_FDC_L1RREQ_PENDQUEUE_OFFSET_ROW                      0

#define LW_FDC_L1RREQ_PENDQUEUE_COUNT_ROW                       0

//      3b.) Packet for L1 write pending queue
#define LW_FDC_L1WREQ_PENDQUEUE_BE_BASE 75
#define LW_FDC_L1WREQ_PENDQUEUE_DATA_BASE       11

// Packet LW_FDC_L1WREQ_PENDQUEUE
#define LW_FDC_L1WREQ_PENDQUEUE_SIZE 83

// register data overlap
#define LW_FDC_L1WREQ_PENDQUEUE_BE_ROW                  0

#define LW_FDC_L1WREQ_PENDQUEUE_REG_DATA_ROW                    0

#define LW_FDC_L1WREQ_PENDQUEUE_DATA_ROW                        0

//these 2 overlap
#define LW_FDC_L1WREQ_PENDQUEUE_RELEASE_ROW                     0

#define LW_FDC_L1WREQ_PENDQUEUE_REQ_MODE_ROW                    0
#define LW_FDC_L1WREQ_PENDQUEUE_REQ_MODE_PIXEL                  0x00000000
#define LW_FDC_L1WREQ_PENDQUEUE_REQ_MODE_REGISTER                       0x00000001

// register address encode address packet overlap
#define LW_FDC_L1WREQ_PENDQUEUE_LINE_MODE_ROW                   0
#define LW_FDC_L1WREQ_PENDQUEUE_LINE_MODE_L64BIT                        0x00000000
#define LW_FDC_L1WREQ_PENDQUEUE_LINE_MODE_L128BIT                       0x00000001

#define LW_FDC_L1WREQ_PENDQUEUE_REG_ENC_ADDRESS_ROW                     0

#define LW_FDC_L1WREQ_PENDQUEUE_LINE_ROW                        0

#define LW_FDC_L1WREQ_PENDQUEUE_OFFSET_ROW                      0

#define LW_FDC_L1WREQH_PENDQUEUE_BE_BASE        75
#define LW_FDC_L1WREQH_PENDQUEUE_DATA_BASE      11

// Packet LW_FDC_L1WREQH_PENDQUEUE
#define LW_FDC_L1WREQH_PENDQUEUE_SIZE 112

#define LW_FDC_L1WREQH_PENDQUEUE_ADDRESS_ROW                    0

// register data overlap
#define LW_FDC_L1WREQH_PENDQUEUE_BE_ROW                 0

#define LW_FDC_L1WREQH_PENDQUEUE_REG_DATA_ROW                   0

#define LW_FDC_L1WREQH_PENDQUEUE_DATA_ROW                       0

//these 2 overlap
#define LW_FDC_L1WREQH_PENDQUEUE_RELEASE_ROW                    0

#define LW_FDC_L1WREQH_PENDQUEUE_REQ_MODE_ROW                   0
#define LW_FDC_L1WREQH_PENDQUEUE_REQ_MODE_PIXEL                 0x00000000
#define LW_FDC_L1WREQH_PENDQUEUE_REQ_MODE_REGISTER                      0x00000001

// register address encode address packet overlap
#define LW_FDC_L1WREQH_PENDQUEUE_LINE_MODE_ROW                  0
#define LW_FDC_L1WREQH_PENDQUEUE_LINE_MODE_L64BIT                       0x00000000
#define LW_FDC_L1WREQH_PENDQUEUE_LINE_MODE_L128BIT                      0x00000001

#define LW_FDC_L1WREQH_PENDQUEUE_REG_ENC_ADDRESS_ROW                    0

#define LW_FDC_L1WREQH_PENDQUEUE_LINE_ROW                       0

#define LW_FDC_L1WREQH_PENDQUEUE_OFFSET_ROW                     0

// Register address packet

// Packet LW_FDC_REQ_REG_ADDR
#define LW_FDC_REQ_REG_ADDR_SIZE 12

#define LW_FDC_REQ_REG_ADDR_BLK_NUM_ROW                 0

#define LW_FDC_REQ_REG_ADDR_BLK_ADDR_ROW                        0

// Register address encode packet

// Packet LW_FDC_REQ_REG_ADDR_ENC
#define LW_FDC_REQ_REG_ADDR_ENC_SIZE 9

#define LW_FDC_REQ_REG_ADDR_ENC_BLK_NUM_ROW                     0
#define LW_FDC_REQ_REG_ADDR_ENC_BLK_NUM_FDC                     0x00000000
#define LW_FDC_REQ_REG_ADDR_ENC_BLK_NUM_GLOBAL                  0x00000001

#define LW_FDC_REQ_REG_ADDR_ENC_BLK_ADDR_ROW                    0
#define LW_FDC_REQ_REG_ADDR_ENC_BLK_ADDR_GLOBAL_LW_MCCIF                        0x00000000
#define LW_FDC_REQ_REG_ADDR_ENC_BLK_ADDR_OTHER                  0x0000000f

// MC queue sizes
#define LW_FDC_MCQ_RD_QFIFO_WIDTH       8
#define LW_FDC_MCQ_WR_QFIFO_WIDTH       7
#define LW_FDC_MCQ_WR_DRAM_PEND_QFIFO_DEPTH     32
#define LW_FDC_MCQ_RD_DRAM_PEND_QFIFO_DEPTH     32

// Packet LW_FDC_MC_QUEUE
#define LW_FDC_MC_QUEUE_SIZE 7

#define LW_FDC_MC_QUEUE_LINE_ROW                        0

//      11.) SB interface FIFO depth
#define LW_FDC_SB_QFIFO_DEPTH   16
//
//      Packet for L2 line state
//

// Packet LW_FDC_L2LINESTAT
#define LW_FDC_L2LINESTAT_SIZE 9

#define LW_FDC_L2LINESTAT_REQCNT_ROW                    0

#define LW_FDC_L2LINESTAT_DIRTY_ROW                     0

#define LW_FDC_L2LINESTAT_LOCKED_ROW                    0

#define LW_FDC_L2LINESTAT_MCDONE_ROW                    0

#define LW_FDC_L2LINESTAT_COMPLETE_ROW                  0

#define LW_FDC_L2LINESTAT_PERSISTENT_ROW                        0

#define LW_FDC_L2LINESTAT_READCLEAN_ROW                 0

//
//      Packet for RD client request to cache control
//

// Packet LW_FDC_RD_CLIENT_REQ
#define LW_FDC_RD_CLIENT_REQ_SIZE 28

#define LW_FDC_RD_CLIENT_REQ_PERSISTENT_ROW                     0

#define LW_FDC_RD_CLIENT_REQ_TAG_ROW                    0

//
//      Packet for WR client request to cache control
//

// Packet LW_FDC_WR_CLIENT_REQ
#define LW_FDC_WR_CLIENT_REQ_SIZE 29

#define LW_FDC_WR_CLIENT_REQ_READCLEAN_ROW                      0

#define LW_FDC_WR_CLIENT_REQ_PERSISTENT_ROW                     0

#define LW_FDC_WR_CLIENT_REQ_TAG_ROW                    0

//
//      Read request Packet Cache control to MC
//

// Packet LW_FDC_MCQ_READ
#define LW_FDC_MCQ_READ_SIZE 35

#define LW_FDC_MCQ_READ_BUF_SWAP_ROW                    0

#define LW_FDC_MCQ_READ_LINE_ROW                        0

#define LW_FDC_MCQ_READ_ADDRESS_ROW                     0

//
//      Read data Packet MC to L2
//

// Packet LW_FDC_MCQ_RDATA
#define LW_FDC_MCQ_RDATA_SIZE 264

#define LW_FDC_MCQ_RDATA_BUF_SWAP_ROW                   0

#define LW_FDC_MCQ_RDATA_DATA_ROW                       0

#define LW_FDC_MCQ_RDATA_LINE_ROW                       0

//
//      Write request Packet Flush to MC
//

// Packet LW_FDC_MCQ_WRITE
#define LW_FDC_MCQ_WRITE_SIZE 322

#define LW_FDC_MCQ_WRITE_DATA_ROW                       0

#define LW_FDC_MCQ_WRITE_BE_ROW                 0

#define LW_FDC_MCQ_WRITE_LINE_ROW                       0

#define LW_FDC_MCQ_WRITE_ADDRESS_ROW                    0

//
//      Processed/collapsed scoreboard packet.
//

// Packet LW_FDC_SB_CHECK
#define LW_FDC_SB_CHECK_SIZE 32

#define LW_FDC_SB_CHECK_BYTES_PER_PIXEL_ROW                     0
#define LW_FDC_SB_CHECK_BYTES_PER_PIXEL_BPP1                    0x00000000
#define LW_FDC_SB_CHECK_BYTES_PER_PIXEL_BPP2                    0x00000001
#define LW_FDC_SB_CHECK_BYTES_PER_PIXEL_BPP4                    0x00000002
#define LW_FDC_SB_CHECK_BYTES_PER_PIXEL_BPP8                    0x00000003

#define LW_FDC_SB_CHECK_QUAD_Y_ROW                      0

#define LW_FDC_SB_CHECK_QUAD_X_ROW                      0

#define LW_FDC_SB_CHECK_BYTEMASK_ROW                    0


// Packet LW_FDC_SB_PKT
#define LW_FDC_SB_PKT_SIZE 30

#define LW_FDC_SB_PKT_PAYLOAD_ROW                       0

#define LW_FDC_SB_PKT_QUAD_Y_ROW                        0

#define LW_FDC_SB_PKT_QUAD_X_ROW                        0

#define LW_FDC_SB_PKT_MASK_ROW                  0

//
// packet defs for read request for L1 clients
//
//
// Generic packet for PSEQ & QRAST read request clients
//
//   - REQ_MODE selects if request is fdc register read (REGISTER) or
//   pixel/data read (PIXEL). For PIXEL access, fields REQ_MODE,
//   LINE_MODE, ADDRESS, and PERSISTENT are valid. For REGISTER access,
//   fields REQ_MODE, REG_ADDR, REG_BLK_ADDR, and REG_BLK_NUM are valid.
//   - in PIXEL mode, LINE_MODE selects if request is for 64 bit or 128
//   bit data. If L128BIT is selected, both clients request buses should
//   be in sync with the 128 bit request.
//   - in PIXEL mode, ADDRESS is L1 cache size truncated address (8 byte)
//   - in PIXEL mode, PERSISTENT is a hint bit from client that, if set,
//   indicates that this line is likely to be reaccessed, and therefore
//   fdc should try to keep this line in the cache as long as possible.
//

// Packet LW_FDC_RREQ
#define LW_FDC_RREQ_SIZE 32

// persistent hint bit (PIXEL only)
// note: {REG_UNUSED,REG_ADDR}, {REG_UNUSED,REG_BLK_NUM,REG_BLK_ADDR} and {ADDRESS} overlap
#define LW_FDC_RREQ_PERSISTENT_ROW                      0

// REG read address - unused/reserved
#define LW_FDC_RREQ_REG_UNUSED_ROW                      0

// REG read address - bits that point at the block
#define LW_FDC_RREQ_REG_BLK_NUM_ROW                     0
#define LW_FDC_RREQ_REG_BLK_NUM_CTL                     0x00000000
#define LW_FDC_RREQ_REG_BLK_NUM_IDX                     0x00000001
#define LW_FDC_RREQ_REG_BLK_NUM_VPE                     0x00000002
#define LW_FDC_RREQ_REG_BLK_NUM_SU                      0x00000003
#define LW_FDC_RREQ_REG_BLK_NUM_QR                      0x00000004
#define LW_FDC_RREQ_REG_BLK_NUM_PSEQ                    0x00000005
#define LW_FDC_RREQ_REG_BLK_NUM_AT                      0x00000006
#define LW_FDC_RREQ_REG_BLK_NUM_TEX                     0x00000007
#define LW_FDC_RREQ_REG_BLK_NUM_ALU                     0x00000008
#define LW_FDC_RREQ_REG_BLK_NUM_DW                      0x00000009
#define LW_FDC_RREQ_REG_BLK_NUM_FDC                     0x0000000a
#define LW_FDC_RREQ_REG_BLK_NUM_GLB1                    0x0000000e
#define LW_FDC_RREQ_REG_BLK_NUM_GLB2                    0x0000000f

// REG read address - offset within the block
#define LW_FDC_RREQ_REG_BLK_ADDR_ROW                    0

// REG read address - whole address (needed for global MCCIF reg decode)
#define LW_FDC_RREQ_REG_ADDR_ROW                        0

// PIXEL read address Tag
#define LW_FDC_RREQ_TAG_ROW                     0

// PIXEL read address offset
#define LW_FDC_RREQ_OFFSET_ROW                  0

// PIXEL read address - L1 cache size truncated address (8 byte)
#define LW_FDC_RREQ_ADDRESS_ROW                 0

// selects if PIXEL request is in 64 bit or 128 bit mode
#define LW_FDC_RREQ_LINE_MODE_ROW                       0
#define LW_FDC_RREQ_LINE_MODE_L64BIT                    0x00000000
#define LW_FDC_RREQ_LINE_MODE_L128BIT                   0x00000001

// selects if request is fdc register read (REGISTER) or
//    pixel/data read (PIXEL). Only QRAST Z client is allowed
//    to access fdc registers
#define LW_FDC_RREQ_REQ_MODE_ROW                        0
#define LW_FDC_RREQ_REQ_MODE_PIXEL                      0x00000000
#define LW_FDC_RREQ_REQ_MODE_REGISTER                   0x00000001

//
// Generic packet for PSEQ & QRAST read data clients
//

// Packet LW_FDC_READ_DATA
#define LW_FDC_READ_DATA_SIZE 64

// reserved when register read access
#define LW_FDC_READ_DATA_REG_UNUSED_ROW                 0

// register read data
#define LW_FDC_READ_DATA_REG_DATA_ROW                   0

// pixel read data
#define LW_FDC_READ_DATA_DATA_ROW                       0

//
// packet for write request for L1 clients
//
//
// Generic packet for DW & QRAST write request
//
//   - REQ_MODE selects if request is fdc register write (REGISTER) or
//   pixel/data write (PIXEL). For PIXEL access, fields REQ_MODE,
//   LINE_MODE, ADDRESS, DATA, BE, PERSISTENT, READ_CLEAN, SB_MASK,
//   SB_QUAD_X, SB_QUAD_Y, SB_BYTES_PER_PIXEL are valid. For REGISTER
//   access, fields REQ_MODE, REG_ADDR, REG_BLK_ADDR, REG_BLK_NUM, and
//   REG_DATA are valid.
//   - in PIXEL mode, LINE_MODE selects if request is for 64 bit or 128
//   bit data. If L128BIT is selected, both clients request buses should
//   be in sync with the 128 bit request.
//   - in PIXEL mode, ADDRESS is L1 cache size truncated address (8 byte)
//   - in PIXEL mode, PERSISTENT is a hint bit from client that, if set,
//   indicates that this line is likely to be reaccessed, and therefore
//   fdc should try to keep this line in the cache as long as possible.
//   - in PIXEL mode, READ_CLEAN is a hint bit from client that, if set,
//   indicates that this line is a temporary buffer, and once read, can be
//   discarded even if it has not been flushed to main memory.
//   - in PIXEL mode, SB_MASK is a per quad pixel scoreboard valid mask.
//   To indicate an invalid scoreboard data, set all bits to zero.
// use this packet for REQ_MODE=PIXEL
#define LW_FDC_WREQ_DATA_BASE   31
#define LW_FDC_WREQ_BE_BASE     95

// Packet LW_FDC_WREQ
#define LW_FDC_WREQ_SIZE 133

// scoreboard surface format (PIXEL only)
#define LW_FDC_WREQ_SB_BYTES_PER_PIXEL_ROW                      0
#define LW_FDC_WREQ_SB_BYTES_PER_PIXEL_BPP1                     0x00000000
#define LW_FDC_WREQ_SB_BYTES_PER_PIXEL_BPP2                     0x00000001
#define LW_FDC_WREQ_SB_BYTES_PER_PIXEL_BPP4                     0x00000002
#define LW_FDC_WREQ_SB_BYTES_PER_PIXEL_BPP8                     0x00000003

// scoreboard quad y position (PIXEL only)
#define LW_FDC_WREQ_SB_QUAD_Y_ROW                       0

// scoreboard quad x position (PIXEL only)
#define LW_FDC_WREQ_SB_QUAD_X_ROW                       0

// scoreboard valid quad mask (PIXEL only)
// note: SB_CLEAR and all other SB_ overlap
#define LW_FDC_WREQ_SB_MASK_ROW                 0

// scoreboard clear packet (all combined - PIXEL only)
#define LW_FDC_WREQ_SB_CLEAR_ROW                        0

// read_clean hint bit (PIXEL only)
#define LW_FDC_WREQ_READ_CLEAN_ROW                      0

// persistent hint bit (PIXEL only)
#define LW_FDC_WREQ_PERSISTENT_ROW                      0

// PIXEL write per byte enables (8 bits).
// note: {REG_DATA_UNUSED,REG_DATA} and DATA overlap
#define LW_FDC_WREQ_BE_ROW                      0

// REG write data - unused/reserved
#define LW_FDC_WREQ_REG_DATA_UNUSED_ROW                 0

// REG write data
#define LW_FDC_WREQ_REG_DATA_ROW                        0

// PIXEL write data - L1 cache size (8 bytes) aligned data
// note: {REG_UNUSED,REG_ADDR}, {REG_UNUSED,REG_BLK_NUM,REG_BLK_ADDR} and {ADDRESS} overlap
#define LW_FDC_WREQ_DATA_ROW                    0

// REG read address - unused/reserved
#define LW_FDC_WREQ_REG_UNUSED_ROW                      0

// REG read address - bits that point at the block
#define LW_FDC_WREQ_REG_BLK_NUM_ROW                     0
#define LW_FDC_WREQ_REG_BLK_NUM_CTL                     0x00000000
#define LW_FDC_WREQ_REG_BLK_NUM_IDX                     0x00000001
#define LW_FDC_WREQ_REG_BLK_NUM_VPE                     0x00000002
#define LW_FDC_WREQ_REG_BLK_NUM_SU                      0x00000003
#define LW_FDC_WREQ_REG_BLK_NUM_QR                      0x00000004
#define LW_FDC_WREQ_REG_BLK_NUM_PSEQ                    0x00000005
#define LW_FDC_WREQ_REG_BLK_NUM_AT                      0x00000006
#define LW_FDC_WREQ_REG_BLK_NUM_TEX                     0x00000007
#define LW_FDC_WREQ_REG_BLK_NUM_ALU                     0x00000008
#define LW_FDC_WREQ_REG_BLK_NUM_DW                      0x00000009
#define LW_FDC_WREQ_REG_BLK_NUM_FDC                     0x0000000a
#define LW_FDC_WREQ_REG_BLK_NUM_GLB1                    0x0000000e
#define LW_FDC_WREQ_REG_BLK_NUM_GLB2                    0x0000000f

// REG read address - offset within the block
#define LW_FDC_WREQ_REG_BLK_ADDR_ROW                    0

// REG read address - whole address (needed for global MCCIF reg decode)
#define LW_FDC_WREQ_REG_ADDR_ROW                        0

// PIXEL read address Tag
#define LW_FDC_WREQ_TAG_ROW                     0

// PIXEL read address offset
#define LW_FDC_WREQ_OFFSET_ROW                  0

// PIXEL write address - L1 cache size truncated address (8 byte)
#define LW_FDC_WREQ_ADDRESS_ROW                 0

// selects if PIXEL request is in 64 bit or 128 bit mode
#define LW_FDC_WREQ_LINE_MODE_ROW                       0
#define LW_FDC_WREQ_LINE_MODE_L64BIT                    0x00000000
#define LW_FDC_WREQ_LINE_MODE_L128BIT                   0x00000001

// selects if request is fdc register write (REGISTER) or
//    pixel/data write (PIXEL). Only QRAST Z client is allowed
//    to access fdc registers
#define LW_FDC_WREQ_REQ_MODE_ROW                        0
#define LW_FDC_WREQ_REQ_MODE_PIXEL                      0x00000000
#define LW_FDC_WREQ_REQ_MODE_REGISTER                   0x00000001

////////////////////////////////////////////////////////////////////////
// NON-PIXSHADERPKT input FIFO depths
////////////////////////////////////////////////////////////////////////
#define SETUP2QRAST_INPUTFIFO_DEPTH     1
////////////////////////////////////////////////////////////////////////
// PIXSHADERPKT input FIFO depths
////////////////////////////////////////////////////////////////////////
#define QRAST2PSEQ_INPUTFIFO_DEPTH      1
// informative only
#define DWR2PSEQ_INPUTFIFO_DEPTH        5
#define PSEQ2ATRAST_INPUTFIFO_DEPTH     1
#define ATRAST2TEX_INPUTFIFO_DEPTH      1
#define TEX2ALU_INPUTFIFO_DEPTH 1
#define ALU2DWR_INPUTFIFO_DEPTH 1
////////////////////////////////////////////////////////////////////////
// internal pseq specs
////////////////////////////////////////////////////////////////////////
// --------------------------------------------------------------------------
//
// Copyright (c) 2004, LWPU Corp.
// All Rights Reserved.
//
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of LWPU Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of LWPU Corp.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
//
// --------------------------------------------------------------------------
//
// ########################## Internal packet definitions ######################
//
// This file contains implementation details that programmers don't need to see.
// pseq latency hiding fifo
#define PSEQ_DATAFETCH_FIFO_DEPTH       112
#define PSEQ_SB_FIFO_DEPTH      4
#define PSEQ_IDX_FIFO_DEPTH     4
// pseq latency sideband fifo

// Packet PSEQ_SIDEBAND
#define PSEQ_SIDEBAND_SIZE 4

#define PSEQ_SIDEBAND_DEST_ROW                  0
#define PSEQ_SIDEBAND_DEST_PASS_THROUGH                 0x00000000
#define PSEQ_SIDEBAND_DEST_UPPER_PIPE                   0x00000001
#define PSEQ_SIDEBAND_DEST_SPILL                        0x00000002
#define PSEQ_SIDEBAND_DEST_GATHER                       0x00000003

#define PSEQ_SIDEBAND_BUFFER1_ROW                       0

#define PSEQ_SIDEBAND_BUFFER0_ROW                       0

// pseq latency data fifo is SIDEBAND + PIXSHADERPKT

// Packet PSEQ_DATAFETCH
#define PSEQ_DATAFETCH_SIZE 104

#define PSEQ_DATAFETCH_PSEQ_SIDEBAND_ROW                        0

#define PSEQ_DATAFETCH_PIXSHADERPKT_ROW                 0

//
// GATHER
//  based on pixshaderpkt and used in pixshaderpkt fifos

// Packet PIXSHADERPKT_GATHER
#define PIXSHADERPKT_GATHER_SIZE 100

#define PIXSHADERPKT_GATHER_DATA_ROW                    0

// byte offset within the 128 bit cacheline for the
// gather return data 
#define PIXSHADERPKT_GATHER_BYTE_OFFSET_ROW                     0

//
// MOP
//  based on pixshaderpkt and used in pixshaderpkt fifos

// Packet PIXSHADERPKT_MOP
#define PIXSHADERPKT_MOP_SIZE 100

#define PIXSHADERPKT_MOP_DATA_ROW                       0

// the current PC value.  used by the lower part of pseq to init dbg bits after a spill
#define PIXSHADERPKT_MOP_PC_ROW                 0

#define PIXSHADERPKT_MOP_SPILL_ROW                      0

#define PIXSHADERPKT_MOP_START_SEQ_ROW                  0

//////////////////////////////
// internal atrast specs
//////////////////////////////
// --------------------------------------------------------------------------
//
// Copyright (c) 2004, LWPU Corp.
// All Rights Reserved.
//
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of LWPU Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of LWPU Corp.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
//
// --------------------------------------------------------------------------
//
// ########################## Internal packet definitions ######################
//
// This file contains implementation details that programmers don't need to see.

// Packet ATRAST_W_FLOAT
#define ATRAST_W_FLOAT_SIZE 25

#define ATRAST_W_FLOAT_MANT_ROW                 0

#define ATRAST_W_FLOAT_EXP_ROW                  0

#define ATRAST_W_FLOAT_SIGN_ROW                 0


// Packet ATRAST_AB_FLOAT
#define ATRAST_AB_FLOAT_SIZE 22

#define ATRAST_AB_FLOAT_MANT_ROW                        0

#define ATRAST_AB_FLOAT_EXP_ROW                 0

#define ATRAST_AB_FLOAT_SIGN_ROW                        0


// Packet ATRAST_AB_BLK_FLT
#define ATRAST_AB_BLK_FLT_SIZE 34

// S1.16
#define ATRAST_AB_BLK_FLT_AB_HP_MANT_ROW                        0

// S1.8
#define ATRAST_AB_BLK_FLT_AB_LP_MANT_ROW                        0

// 6 excess 31
#define ATRAST_AB_BLK_FLT_EXP_ROW                       0

// This parameter reduces the fractional bits used in the HP IPA.  It works for values of [0..17] inclusive.
#define ATRAST_HP_IPA_REDUCE_BITS       12
//////////////////////////////
// internal vpe specs
//////////////////////////////
//
// Note - colwerted from the original project_LWE297_vpe.spec since this
// shouldn't have been propagated into project.h
//
// in colwersion, we moved the end-of-line comments to the beginning of
// the line, changed #define to define, and added a semicolon at end-of-line.
// 
// all this was done via emacs key macros, so apologies for the formatting...
//
// of course, since simspec doesn't understand defines based on other defines,
// some of these need some additional hand-tweaking...  sigh.
#define LW_GR3D_VPE_CMDQ_RAM_DEPTH      8
#define LW_GR3D_VPE_CMDQ_WIDTH  18
#define LW_GR3D_VPE_DPATH_WIDTH 32
#define LW_GR3D_VPE_NUM_COMPONENTS      4
#define LW_GR3D_VPE_DPATH_BUS_WIDTH     128
#define LW_GR3D_VPE_CTX_SIZE    256
#define LW_GR3D_VPE_PROGRAM_LENGTH      256
// Keep hard-coded to 10 since making it s
#define LW_GR3D_VPE_CTX_ADDR_BITS       10
#define LW_GR3D_VPE_CMD_ADDR_BITS       10
#define LW_GR3D_VPE_CC_BITS     3
#define LW_GR3D_VPE_CC_REG_WIDTH        12
#define LW_GR3D_VPE_XFSIDBAND_WIDTH     17
#define LW_GR3D_VPE_MODE_BITS   1
#define LW_GR3D_VPE_INSTR_LIMIT 65536
#define LW_GR3D_VPE_INSTR_LIMIT_BITS    16
#define LW_GR3D_VPE_PRO_ADDR_BITS       8
#define LW_GR3D_VPE_PROGRAM_LD_WIDTH    127
#define LW_GR3D_VPE_THREAD_BITS 1
//
// vpe instruction/ucode related defines.
//
// Operand type
// Operand not used
#define LW_GR3D_VPE_INSTR_OPR_TYPE_ILWAL        0
// Position shadow for operand C (rankine only)
#define LW_GR3D_VPE_INSTR_OPR_TYPE_POS  0
// Register 
#define LW_GR3D_VPE_INSTR_OPR_TYPE_REG  1
// I-buffer
#define LW_GR3D_VPE_INSTR_OPR_TYPE_BUF  2
// Context 
#define LW_GR3D_VPE_INSTR_OPR_TYPE_CTX  3
// Operand extract type (per component output)
// Select x_in
#define LW_GR3D_VPE_INSTR_EXTR_X        0
// Select y_in
#define LW_GR3D_VPE_INSTR_EXTR_Y        1
// Select z_in
#define LW_GR3D_VPE_INSTR_EXTR_Z        2
// Select w_in
#define LW_GR3D_VPE_INSTR_EXTR_W        3
// Compare functions
#define LW_GR3D_VPE_INSTR_CC_FALSE      0
#define LW_GR3D_VPE_INSTR_CC_LT 1
#define LW_GR3D_VPE_INSTR_CC_EQ 2
#define LW_GR3D_VPE_INSTR_CC_LE 3
#define LW_GR3D_VPE_INSTR_CC_GT 4
#define LW_GR3D_VPE_INSTR_CC_NE 5
#define LW_GR3D_VPE_INSTR_CC_GE 6
#define LW_GR3D_VPE_INSTR_CC_TRUE       7
// Vector opcodes:
// no operation
#define LW_GR3D_VPE_INSTR_V_NOP 0
// move
#define LW_GR3D_VPE_INSTR_V_MOV 1
// multiply
#define LW_GR3D_VPE_INSTR_V_MUL 2
// add
#define LW_GR3D_VPE_INSTR_V_ADD 3
// multiply and add
#define LW_GR3D_VPE_INSTR_V_MAD 4
// 3 component dot product
#define LW_GR3D_VPE_INSTR_V_DP3 5
// 
#define LW_GR3D_VPE_INSTR_V_DPH 6
// 4 component dot product
#define LW_GR3D_VPE_INSTR_V_DP4 7
// DIS,  PASB
#define LW_GR3D_VPE_INSTR_V_DST 8
// minimum value select
#define LW_GR3D_VPE_INSTR_V_MIN 9
// maximum value select
#define LW_GR3D_VPE_INSTR_V_MAX 10
// set on less than
#define LW_GR3D_VPE_INSTR_V_SLT 11
// set on greater than and equal
#define LW_GR3D_VPE_INSTR_V_SGE 12
// address register load (floor)
#define LW_GR3D_VPE_INSTR_V_ARL 13
// FRC,  PASB
#define LW_GR3D_VPE_INSTR_V_FRC 14
// FLR,  PASB
#define LW_GR3D_VPE_INSTR_V_FLR 15
// SEQ,  PASB
#define LW_GR3D_VPE_INSTR_V_SEQ 16
// SFL,  PASB
#define LW_GR3D_VPE_INSTR_V_SFL 17
// SGT,  PASB
#define LW_GR3D_VPE_INSTR_V_SGT 18
// SLE,  PASB
#define LW_GR3D_VPE_INSTR_V_SLE 19
// SNE,  PASB
#define LW_GR3D_VPE_INSTR_V_SNE 20
// STR,  PASB 
#define LW_GR3D_VPE_INSTR_V_STR 21
// SSG,  PASB
#define LW_GR3D_VPE_INSTR_V_SSG 22
// address register load (round)
#define LW_GR3D_VPE_INSTR_V_ARR 23
// address register move
#define LW_GR3D_VPE_INSTR_V_MVA 24
// texture load
#define LW_GR3D_VPE_INSTR_V_TXL 25
// push address register onto stack
#define LW_GR3D_VPE_INSTR_V_PSH 26
// pop an address register from the stack
#define LW_GR3D_VPE_INSTR_V_POP 27
// reserved
#define LW_GR3D_VPE_INSTR_V_RSV0        28
// reserved
#define LW_GR3D_VPE_INSTR_V_RSV1        29
// reserved
#define LW_GR3D_VPE_INSTR_V_RSV2        30
// reserved
#define LW_GR3D_VPE_INSTR_V_RSV3        31
// Scalar opcodes
// no operation
#define LW_GR3D_VPE_INSTR_S_NOP 0
// move
#define LW_GR3D_VPE_INSTR_S_MOV 1
// reciprocal
#define LW_GR3D_VPE_INSTR_S_RCP 2
// clamped reciprocal
#define LW_GR3D_VPE_INSTR_S_RCC 3
// reciprocal square root
#define LW_GR3D_VPE_INSTR_S_RSQ 4
// exponent
#define LW_GR3D_VPE_INSTR_S_EXP 5
// logarithm
#define LW_GR3D_VPE_INSTR_S_LOG 6
// 
#define LW_GR3D_VPE_INSTR_S_LIT 7
// branch from jumptable  // Kelvin only!
#define LW_GR3D_VPE_INSTR_S_BRA 8
// branch immediate
#define LW_GR3D_VPE_INSTR_S_BRI 9
// call from jumptable    // Kelvin only!
#define LW_GR3D_VPE_INSTR_S_CLA 10
// call on immediate
#define LW_GR3D_VPE_INSTR_S_CLI 11
// return
#define LW_GR3D_VPE_INSTR_S_RET 12
// log base 2
#define LW_GR3D_VPE_INSTR_S_LG2 13
// power of 2
#define LW_GR3D_VPE_INSTR_S_EX2 14
// sine
#define LW_GR3D_VPE_INSTR_S_SIN 15
// cosine
#define LW_GR3D_VPE_INSTR_S_COS 16
// branch on boolean constant
#define LW_GR3D_VPE_INSTR_S_BRB 17
// call on boolean constant
#define LW_GR3D_VPE_INSTR_S_CLB 18
// push address register onto stack
#define LW_GR3D_VPE_INSTR_S_PSH 19
// push address register onto stack
#define LW_GR3D_VPE_INSTR_S_POP 20
// reserved
#define LW_GR3D_VPE_INSTR_S_RSV0        21
// reserved
#define LW_GR3D_VPE_INSTR_S_RSV1        22
// reserved
#define LW_GR3D_VPE_INSTR_S_RSV2        23
// reserved
#define LW_GR3D_VPE_INSTR_S_RSV3        24
// reserved
#define LW_GR3D_VPE_INSTR_S_RSV4        25
// reserved
#define LW_GR3D_VPE_INSTR_S_RSV5        26
// reserved
#define LW_GR3D_VPE_INSTR_S_RSV6        27
// reserved
#define LW_GR3D_VPE_INSTR_S_RSV7        28
// reserved
#define LW_GR3D_VPE_INSTR_S_RSV8        29
// reserved
#define LW_GR3D_VPE_INSTR_S_RSV9        30
// reserved
#define LW_GR3D_VPE_INSTR_S_RSVA        31
//
//
// already in LWE297_vpe #define LW_GR3D_VPE_INSTR_REG_NOP        0x3f    // No-write option ;
// No-write from Rankine
#define LW_GR3D_VPE_RANKINE_REG_NOP     31
// Select the scalar data for OUT_SEL or CC_WR_SEL
#define LW_GR3D_VPE_INSTR_SEL_SCALAR    0
// Select the vector data for OUT_SEL or CC_WR_SEL
#define LW_GR3D_VPE_INSTR_SEL_VECTOR    1
//
// Fixed Function Microcode
#define LW_GR3D_VPE_PROG_TYPE_FFU       0
// Vertex Shader 1.0
#define LW_GR3D_VPE_PROG_TYPE_VS1       2
// Vertex Shader 2.0
#define LW_GR3D_VPE_PROG_TYPE_VS2       3
// Vertex Shader 3.0
#define LW_GR3D_VPE_PROG_TYPE_VS3       1
//
//
// VPE Control Field Enumerants
//
// Stage 1 operand multiplexer select
// Operand A mux width 
#define LW_GR3D_VPE_CTL_ASEL_WIDTH      3
//0b000         // Select position shadow
#define LW_GR3D_VPE_CTL_ASEL_IPOS       0
//0b001         // Select ibuf
#define LW_GR3D_VPE_CTL_ASEL_IBUF       1
//0b010         // Select context
#define LW_GR3D_VPE_CTL_ASEL_CTX        2
//0b100         // Select register 
#define LW_GR3D_VPE_CTL_ASEL_REG        4
//0b101         // Select adder result bus
#define LW_GR3D_VPE_CTL_ASEL_ADD_RSLT   5
//0b110         // Select multiplier result bus
#define LW_GR3D_VPE_CTL_ASEL_MUL_RSLT   6
//0b111 // Select scaler result bus (only for internal dual-issue)
#define LW_GR3D_VPE_CTL_ASEL_SCA_RSLT   7
// Operand B mux width 
#define LW_GR3D_VPE_CTL_BSEL_WIDTH      3
//0b000         // Select position shadow
#define LW_GR3D_VPE_CTL_BSEL_IPOS       0
//0b001         // Select ibuf
#define LW_GR3D_VPE_CTL_BSEL_IBUF       1
//0b010         // Select context
#define LW_GR3D_VPE_CTL_BSEL_CTX        2
//0b100         // Select register 
#define LW_GR3D_VPE_CTL_BSEL_REG        4
//0b101         // Select adder result bus
#define LW_GR3D_VPE_CTL_BSEL_ADD_RSLT   5
//0b110         // Select multiplier result bus
#define LW_GR3D_VPE_CTL_BSEL_MUL_RSLT   6
//0b111 // Select scaler result bus (only for internal dual-issue)
#define LW_GR3D_VPE_CTL_BSEL_SCA_RSLT   7
// Operand C mux width 
#define LW_GR3D_VPE_CTL_CSEL_WIDTH      3
//0b000         // Select position shadow
#define LW_GR3D_VPE_CTL_CSEL_IPOS       0
//0b001         // Select ibuf
#define LW_GR3D_VPE_CTL_CSEL_IBUF       1
//0b010         // Select context
#define LW_GR3D_VPE_CTL_CSEL_CTX        2
//0b100         // Select register 
#define LW_GR3D_VPE_CTL_CSEL_REG        4
//0b101         // Select adder result bus
#define LW_GR3D_VPE_CTL_CSEL_ADD_RSLT   5
//0b110         // Select multiplier result bus
#define LW_GR3D_VPE_CTL_CSEL_MUL_RSLT   6
//0b111         // Select scaler result bus (only for internal dual-issue)
#define LW_GR3D_VPE_CTL_CSEL_SCA_RSLT   7
// Stage 3 addin multiplexer select
//0b10          // Select adder result bypass bus
#define LW_GR3D_VPE_CTL_ADD_SEL_ADD_RSLT        2
//0b11          // Select scaler result bypass bus
#define LW_GR3D_VPE_CTL_ADD_SEL_SCA_RSLT        3
//b00           // Select passthru operand
#define LW_GR3D_VPE_CTL_ADD_SEL_PASS    0
// Cheop control decode definition
// IBuf tag (VAB Slot) definition
// LGG XXX SHOULD COME FROM .REF SYSTEM:
//b00000                // Cheop IBUF position (also used for any non-vertex data storage)
#define LW_GR3D_VPE_CTL_IBUF_RADDR_POS  0
//0b00001               // Cheop IBUF weight
#define LW_GR3D_VPE_CTL_IBUF_RADDR_WT   1
//0b00010               // Cheop IBUF normal
#define LW_GR3D_VPE_CTL_IBUF_RADDR_NRL  2
//0b00011               // Cheop IBUF diffuse
#define LW_GR3D_VPE_CTL_IBUF_RADDR_C0   3
//0b00100               // Cheop IBUF spelwlar
#define LW_GR3D_VPE_CTL_IBUF_RADDR_C1   4
//0b00101               // Cheop IBUF weight
#define LW_GR3D_VPE_CTL_IBUF_RADDR_FOG  5
//0b00110               // Cheop IBUF weight
#define LW_GR3D_VPE_CTL_IBUF_RADDR_PS   6
//0b00111               // Cheop IBUF back diffuse
#define LW_GR3D_VPE_CTL_IBUF_RADDR_C2   7
//0b01000               // Cheop IBUF back spelwlar
#define LW_GR3D_VPE_CTL_IBUF_RADDR_C3   8
//0b01000               // Cheop IBUF texture 0
#define LW_GR3D_VPE_CTL_IBUF_RADDR_T0   8
//0b01001               // Cheop IBUF texture 1
#define LW_GR3D_VPE_CTL_IBUF_RADDR_T1   9
//0b01010               // Cheop IBUF texture 2
#define LW_GR3D_VPE_CTL_IBUF_RADDR_T2   10
//0b01011               // Cheop IBUF texture 3
#define LW_GR3D_VPE_CTL_IBUF_RADDR_T3   11
//0b01100               // Cheop IBUF texture 4
#define LW_GR3D_VPE_CTL_IBUF_RADDR_T4   12
//0b01101               // Cheop IBUF texture 5
#define LW_GR3D_VPE_CTL_IBUF_RADDR_T5   13
//0b01110               // Cheop IBUF texture 6
#define LW_GR3D_VPE_CTL_IBUF_RADDR_T6   14
//0b01111               // Cheop IBUF texture 7
#define LW_GR3D_VPE_CTL_IBUF_RADDR_T7   15
// Multiplier opcodes
//0b00000
#define LW_GR3D_VPE_CTL_MUL_OP_MULT     0
//0b00001
#define LW_GR3D_VPE_CTL_MUL_OP_DIST     1
//0b00010
#define LW_GR3D_VPE_CTL_MUL_OP_PASA     2
//0b00011
#define LW_GR3D_VPE_CTL_MUL_OP_MULP     3
//0b00100               
#define LW_GR3D_VPE_CTL_MUL_OP_MIN      4
//0b00101               
#define LW_GR3D_VPE_CTL_MUL_OP_MAX      5
//0b00110               
#define LW_GR3D_VPE_CTL_MUL_OP_SLT      6
//0b00111               
#define LW_GR3D_VPE_CTL_MUL_OP_SGE      7
//0b01000               
#define LW_GR3D_VPE_CTL_MUL_OP_FLR      8
//0b01001               
#define LW_GR3D_VPE_CTL_MUL_OP_FRC      9
//0b01010               
#define LW_GR3D_VPE_CTL_MUL_OP_SEQ      10
//0b01011               
#define LW_GR3D_VPE_CTL_MUL_OP_SFL      11
//0b01100               
#define LW_GR3D_VPE_CTL_MUL_OP_SNE      12
//0b01101               
#define LW_GR3D_VPE_CTL_MUL_OP_SSG      13
//0b01110               
#define LW_GR3D_VPE_CTL_MUL_OP_STR      14
//0b01111               
#define LW_GR3D_VPE_CTL_MUL_OP_SGT      15
//0b10000               
#define LW_GR3D_VPE_CTL_MUL_OP_SLE      16
// Adder opcodes
//0b000         // x=x_a+x_b; y=y_a+y_b; z=z_a+z_b; w=w_a+w_b ( 4 x 1 add)
#define LW_GR3D_VPE_CTL_ADD_OP_ADDT     0
//0b010         // x=x_b+y_b+z_b; y=x_b+y_b+z_b; z=x_b+y_b+z_b; w=x_b+y_b+z_b  (3-to-1 adds)
#define LW_GR3D_VPE_CTL_ADD_OP_SUM3     2
//0b011         // x=x_b+y_b+z_b+w_b; y=x_b+y_b+z_b+w_b; z=x_b+y_b+z_b+w_b; w=x_b+y_b+z_b+w_b
#define LW_GR3D_VPE_CTL_ADD_OP_SUM4     3
//0b101         // x=x_a; y=y_a; z=z_a; w=w_a
#define LW_GR3D_VPE_CTL_ADD_OP_PASA     5
//0b110         // x=x_b; y=y_b; z=z_b; w=w_b
#define LW_GR3D_VPE_CTL_ADD_OP_PASB     6
// SCA opcodes
//0b0000                // nop
#define LW_GR3D_VPE_CTL_SCA_OP_NOP      0
//0b0001                // o=1.0/a
#define LW_GR3D_VPE_CTL_SCA_OP_ILW      1
//0b0010                // o=1.0/a with a defined max and min
#define LW_GR3D_VPE_CTL_SCA_OP_CILW     2
//0b0011                // o=1.0/sqrt(a)
#define LW_GR3D_VPE_CTL_SCA_OP_ISQ      3
//0b0100                // pass vector
#define LW_GR3D_VPE_CTL_SCA_OP_MOV      4
//0b0101                // o=2**a
#define LW_GR3D_VPE_CTL_SCA_OP_EXP      5
//0b0110                // o=log2(a)
#define LW_GR3D_VPE_CTL_SCA_OP_LOG      6
//0b0111                // o=a**x
#define LW_GR3D_VPE_CTL_SCA_OP_PWR      7
//0b1000                // o=sin(x)
#define LW_GR3D_VPE_CTL_SCA_OP_SIN      8
//0b1001                // o=cos(x)
#define LW_GR3D_VPE_CTL_SCA_OP_COS      9
//0b1010                // o=x**2
#define LW_GR3D_VPE_CTL_SCA_OP_EX2      10
//0b1011                // o=log2x
#define LW_GR3D_VPE_CTL_SCA_OP_LG2      11
// REG mask
// Write W
#define LW_GR3D_VPE_CTL_REG_WMSK_W      0
// Write Z
#define LW_GR3D_VPE_CTL_REG_WMSK_Z      1
// Write Y
#define LW_GR3D_VPE_CTL_REG_WMSK_Y      2
// Write X
#define LW_GR3D_VPE_CTL_REG_WMSK_X      3
// RAM mask
// Write W
#define LW_GR3D_VPE_CTL_RAM_WMSK_W      0
// Write Z
#define LW_GR3D_VPE_CTL_RAM_WMSK_Z      1
// Write Y
#define LW_GR3D_VPE_CTL_RAM_WMSK_Y      2
// Write X
#define LW_GR3D_VPE_CTL_RAM_WMSK_X      3
// WT buffer types (indexed-addressing)
// Tag location for UC0, UC1, UC2
#define LW_GR3D_VPE_UC012_TAG   5
// Tag location for UC3, UC4, UC5
#define LW_GR3D_VPE_UC345_TAG   6
// Obuf types 
// position
#define LW_GR3D_VPE_OBUF_POS    0
// back diffuse color
#define LW_GR3D_VPE_OBUF_BDIFF  1
// back spelwlar color
#define LW_GR3D_VPE_OBUF_BSPEC  2
// front diffuse color
#define LW_GR3D_VPE_OBUF_DIFF   3
// front spelwlar color
#define LW_GR3D_VPE_OBUF_SPEC   4
// Fog/PS/UserClip 0-1
#define LW_GR3D_VPE_OBUF_FPU    5
// UserClip 2-5
#define LW_GR3D_VPE_OBUF_UCP    6
// -- lw30 relic for 1/w --
#define LW_GR3D_VPE_OBUF_RSVD   7
// texture 0
#define LW_GR3D_VPE_OBUF_T0     8
// texture 1
#define LW_GR3D_VPE_OBUF_T1     9
// texture 2
#define LW_GR3D_VPE_OBUF_T2     10
// texture 3
#define LW_GR3D_VPE_OBUF_T3     11
// texture 4
#define LW_GR3D_VPE_OBUF_T4     12
// texture 5
#define LW_GR3D_VPE_OBUF_T5     13
// texture 6 
#define LW_GR3D_VPE_OBUF_T6     14
// texture 7
#define LW_GR3D_VPE_OBUF_T7     15
// -- lw30 relic for Fog/W --
#define LW_GR3D_VPE_OBUF_FOGW   16
// User Clip 0
#define LW_GR3D_VPE_OBUF_UC0    17
// User Clip 1
#define LW_GR3D_VPE_OBUF_UC1    18
// User Clip 2
#define LW_GR3D_VPE_OBUF_UC2    19
// User Clip 3
#define LW_GR3D_VPE_OBUF_UC3    20
// User Clip 4
#define LW_GR3D_VPE_OBUF_UC4    21
// User Clip 5
#define LW_GR3D_VPE_OBUF_UC5    22
// FOG
#define LW_GR3D_VPE_OBUF_FOG    23
// Point Size
#define LW_GR3D_VPE_OBUF_PS     24
// Obuf buffer not-valid
#define LW_GR3D_VPE_OBUF_NOP    31
/////////////////////////////////////////////// obsolete defines //////////////////////////////////////////
// position -- delete this one --
#define LW_GR3D_VPE_CTL_OBUF_POS        0
// back diffuse color
#define LW_GR3D_VPE_OBUF_C2     1
// back spelwlar color
#define LW_GR3D_VPE_OBUF_C3     2
// front diffuse color
#define LW_GR3D_VPE_OBUF_C0     3
// front spelwlar color
#define LW_GR3D_VPE_OBUF_C1     4
// 0: ctx;  1: o-buffer
#define XF_INSTR_OUT_TYPE_FIELD 11
// Opcode field width
// Opcode field width
#define XF_INSTR_OPCODE_WIDTH   10
// Operand field width
// cheop ctx ram address width  lw25?
#define XF_INSTR_CTX_WIDTH      8
// ibuf address width  lw25?
#define XF_INSTR_IBUF_WIDTH     4
// Operand RA field width  lw25?
#define XF_INSTR_RA_WIDTH       4
// Operand RB field width  lw25?
#define XF_INSTR_RB_WIDTH       4
// Operand RC field width  lw25?
#define XF_INSTR_RC_WIDTH       4
// Destination RT field width  lw25?
#define XF_INSTR_RT_WIDTH       4
// Destination buffer/ctx field width  lw25?
#define XF_INSTR_OUT_WIDTH      9
// Operand type
// Context 
#define XF_INSTR_OPR_TYPE_CTX   3
// I-buffer
#define XF_INSTR_OPR_TYPE_BUF   2
// Register 
#define XF_INSTR_OPR_TYPE_REG   1
// operand not used
#define XF_INSTR_OPR_TYPE_ILWAL 0
// position shadow for operand C
#define XF_INSTR_OPR_TYPE_POS   0
// Operand extract type (per component output)
// select x_in
#define XF_INSTR_EXTR_X 0
// select y_in
#define XF_INSTR_EXTR_Y 1
// select z_in
#define XF_INSTR_EXTR_Z 2
// select w_in
#define XF_INSTR_EXTR_W 3
// Opcode field width
// Opcode field width
#define XF_INSTR_OPCODE_WIDTH   10
// Operand field width
// cheop ctx ram address width  lw25?
#define XF_INSTR_CTX_WIDTH      8
// ibuf address width  lw25?
#define XF_INSTR_IBUF_WIDTH     4
// Operand RA field width  lw25?
#define XF_INSTR_RA_WIDTH       4
// Operand RB field width  lw25?
#define XF_INSTR_RB_WIDTH       4
// Operand RC field width  lw25?
#define XF_INSTR_RC_WIDTH       4
// Operand extract field width  lw25?
#define XF_INSTR_EXTR_WIDTH     2
// Destination RT field width  lw25?
#define XF_INSTR_RT_WIDTH       4
// Destination buffer/ctx field width  lw25?
#define XF_INSTR_OUT_WIDTH      9
//Compare functions:
//
// CLM - note these had #define CC_FALSE|XF_INSTR_CC_FALSE 0
// I assume vmod doesn't use the first one.
#define XF_INSTR_CC_FALSE       0
#define XF_INSTR_CC_LT  1
#define XF_INSTR_CC_LT  1
#define XF_INSTR_CC_EQ  2
#define XF_INSTR_CC_LE  3
#define XF_INSTR_CC_GT  4
#define XF_INSTR_CC_NE  5
#define XF_INSTR_CC_GE  6
#define XF_INSTR_CC_TRUE        7
//MLU ALU opcodes:
// NOP,  NOP
#define XF_V_NOP        0
// PASA, PASB
#define XF_V_MOV        1
// MULT, PASB
#define XF_V_MUL        2
// PASA, ADD
#define XF_V_ADD        3
// MULT, ADD
#define XF_V_MAD        4
// MULT, SUM3
#define XF_V_DP3        5
// MULB, SUM4
#define XF_V_DPH        6
// MULT, SUM4
#define XF_V_DP4        7
// DIS,  PASB
#define XF_V_DST        8
// MIN,  PASB
#define XF_V_MIN        9
// MAX,  PASB
#define XF_V_MAX        10
// SLE,  PASB
#define XF_V_SLT        11
// SGE,  PASB
#define XF_V_SGE        12
// address register load (floor)
#define XF_V_ARL        13
// FRC,  PASB
#define XF_V_FRC        14
// FLR,  PASB
#define XF_V_FLR        15
// SEQ,  PASB
#define XF_V_SEQ        16
// SFL,  PASB
#define XF_V_SFL        17
// SGT,  PASB
#define XF_V_SGT        18
// SLE,  PASB
#define XF_V_SLE        19
// SNE,  PASB
#define XF_V_SNE        20
// STR,  PASB 
#define XF_V_STR        21
// SSG,  PASB
#define XF_V_SSG        22
// address register load (round)
#define XF_V_ARR        23
// address register move
#define XF_V_MVA        24
// reserved
#define XF_V_RSV0       25
// reserved
#define XF_V_RSV1       26
// reserved
#define XF_V_RSV2       27
// reserved
#define XF_V_RSV3       28
// reserved
#define XF_V_RSV4       29
// reserved
#define XF_V_RSV5       30
// reserved
#define XF_V_RSV6       31
//ILU opcodes:
#define XF_S_NOP        0
#define XF_S_MOV        1
// reciprocal
#define XF_S_RCP        2
// clamped reciprocal
#define XF_S_RCC        3
// reciprocal square root
#define XF_S_RSQ        4
#define XF_S_EXP        5
#define XF_S_LOG        6
#define XF_S_LIT        7
// branch on address reg
#define XF_S_BRA        8
// branch immediate
#define XF_S_BRI        9
// call   on address reg 
#define XF_S_CLA        10
// call   immediate
#define XF_S_CLI        11
// return
#define XF_S_RET        12
#define XF_S_LG2        13
#define XF_S_EX2        14
#define XF_S_SIN        15
#define XF_S_COS        16
// reserved
#define XF_S_RSV0       17
// reserved
#define XF_S_RSV1       18
// reserved
#define XF_S_RSV2       19
// reserved
#define XF_S_RSV3       20
// reserved
#define XF_S_RSV4       21
// reserved
#define XF_S_RSV5       22
// reserved
#define XF_S_RSV6       23
// reserved
#define XF_S_RSV7       24
// reserved
#define XF_S_RSV8       25
// reserved
#define XF_S_RSV9       26
// reserved
#define XF_S_RSVa       27
// reserved
#define XF_S_RSVb       28
// reserved
#define XF_S_RSVc       29
// reserved
#define XF_S_RSVd       30
// reserved
#define XF_S_RSVe       31
// 
// Program and thread management
//
// Number of bits in a bundle address.
#define LW_GR3D_VPE_BUNDLE_ADDR_BITS    9
// IO BUS Width
// Sideband's launch width
#define LW_GR3D_VPE_XFCMD_WIDTH 5
#define LW_GR3D_VPE_CICO_BUS_WIDTH      65
#define LW_GR3D_VPE_CTX_LWRIE_USER      512
#define LW_GR3D_VPE_CTX_LWRIE_PRIV      32
//#define LW_GR3D_VPE_CTX_LWRIE_SIZE  LW_GR3D_VPE_CTX_LWRIE_USER + LW_GR3D_VPE_CTX_LWRIE_PRIV ;
#define LW_GR3D_VPE_CTX_LWRIE_SIZE      256
#define LW_GR3D_VPE_AR_INDEX_BITS       11
#define LW_GR3D_VPE_OFF_REG_WIDTH       44
// Issue window size  lw25?
#define LW_GR3D_VPE_ISSUE_WINDOW_SIZE   2
// Obuf buffer not-valid
#define LW_GR3D_VPE_OBUF_NOP    31
#define VPE_4X_INSTR_WIDTH      127
#define VPE_4X_INSTR_CTX_ADDR_WIDTH     10
#define VPE_4X_INSTR_RT_ADDR_WIDTH      6
#define VPE_4X_INSTR_OPCODE_V_WIDTH     5
#define VPE_4X_INSTR_OPCODE_S_WIDTH     5
#define VPE_4X_INSTR_SEL_SCALAR 0
#define VPE_4X_INSTR_LAST_LSB   0
#define VPE_4X_INSTR_RC_MSB     28
#define VPE_4X_INSTR_RC_LSB     23
// from geometry_if ATTR_BITS   BITS(NUM_ATTR), derek
#define LW_GR3D_VPE_ATTR_BITS   4
// branch stack size
#define LW_GR3D_VPE_STACK_SIZE  8
#define LW_GR3D_VPE_STACK_ADDR_BITS     3
// branch stack size for Rankine Class
#define LW_GR3D_VPE_RANKINE_STACK_SIZE  4
// for IDX-VPE read back channel address bus
#define LW_GR3D_VPE_READ_ADDR_BITS      9
#define LW_GR3D_VPE_READ_DATA_WIDTH     128
///////////////////////////////////////////////////////////////////////////////////////////////////////////

//
// REGISTER LIST
//
#define LIST_LWE297_REGS(_op_) \
_op_(LWE297_CTL_INCR_SYNCPT_0) \
_op_(LWE297_CTL_INCR_SYNCPT_CNTRL_0) \
_op_(LWE297_CTL_INCR_SYNCPT_ERROR_0) \
_op_(LWE297_CTL_INTSTATUS_0) \
_op_(LWE297_CTL_INTENABLE_0) \
_op_(LWE297_CTL_CTXSW_0) \
_op_(LWE297_CTL_STAT_0) \
_op_(LWE297_CTL_STAT) \
_op_(LWE297_CTL_STAT_1) \
_op_(LWE297_CTL_STAT_CLK_COUNT_0) \
_op_(LWE297_CTL_STAT_CLK_COUNT) \
_op_(LWE297_CTL_STAT_CLK_COUNT_1) \
_op_(LWE297_CTL_STAT_XFER_COUNT_0) \
_op_(LWE297_CTL_STAT_XFER_COUNT) \
_op_(LWE297_CTL_STAT_XFER_COUNT_1) \
_op_(LWE297_CTL_STAT_WAIT_COUNT_0) \
_op_(LWE297_CTL_STAT_WAIT_COUNT) \
_op_(LWE297_CTL_STAT_WAIT_COUNT_1) \
_op_(LWE297_CTL_STAT_EN_COUNT_0) \
_op_(LWE297_CTL_STAT_EN_COUNT) \
_op_(LWE297_CTL_STAT_EN_COUNT_1) \
_op_(LWE297_IDX_ATTRIBUTE_0) \
_op_(LWE297_IDX_ATTRIBUTE) \
_op_(LWE297_IDX_ATTRIBUTE_1) \
_op_(LWE297_IDX_ATTRIBUTE_2) \
_op_(LWE297_IDX_ATTRIBUTE_3) \
_op_(LWE297_IDX_ATTRIBUTE_4) \
_op_(LWE297_IDX_ATTRIBUTE_5) \
_op_(LWE297_IDX_ATTRIBUTE_6) \
_op_(LWE297_IDX_ATTRIBUTE_7) \
_op_(LWE297_IDX_ATTRIBUTE_8) \
_op_(LWE297_IDX_ATTRIBUTE_9) \
_op_(LWE297_IDX_ATTRIBUTE_10) \
_op_(LWE297_IDX_ATTRIBUTE_11) \
_op_(LWE297_IDX_ATTRIBUTE_12) \
_op_(LWE297_IDX_ATTRIBUTE_13) \
_op_(LWE297_IDX_ATTRIBUTE_14) \
_op_(LWE297_IDX_ATTRIBUTE_15) \
_op_(LWE297_IDX_ATTRIBUTE_16) \
_op_(LWE297_IDX_ATTRIBUTE_17) \
_op_(LWE297_IDX_ATTRIBUTE_18) \
_op_(LWE297_IDX_ATTRIBUTE_19) \
_op_(LWE297_IDX_ATTRIBUTE_20) \
_op_(LWE297_IDX_ATTRIBUTE_21) \
_op_(LWE297_IDX_ATTRIBUTE_22) \
_op_(LWE297_IDX_ATTRIBUTE_23) \
_op_(LWE297_IDX_ATTRIBUTE_24) \
_op_(LWE297_IDX_ATTRIBUTE_25) \
_op_(LWE297_IDX_ATTRIBUTE_26) \
_op_(LWE297_IDX_ATTRIBUTE_27) \
_op_(LWE297_IDX_ATTRIBUTE_28) \
_op_(LWE297_IDX_ATTRIBUTE_29) \
_op_(LWE297_IDX_ATTRIBUTE_30) \
_op_(LWE297_IDX_ATTRIBUTE_31) \
_op_(LWE297_IDX_ATTR_MASK_0) \
_op_(LWE297_IDX_INDEX_BASE_0) \
_op_(LWE297_IDX_SET_PRIM_0) \
_op_(LWE297_IDX_DRAW_PRIM_0) \
_op_(LWE297_IDX_IDX_CTL_0) \
_op_(LWE297_IDX_IDX_STAT_0) \
_op_(LWE297_IDX_LW_MCCIF_FIFOCTRL_RO_0) \
_op_(LWE297_VPE_MODE_0) \
_op_(LWE297_VPE_TIMEOUT_0) \
_op_(LWE297_VPE_CONST_READ_LIMIT_0) \
_op_(LWE297_VPE_BRANCHBITS_0) \
_op_(LWE297_VPE_START_0) \
_op_(LWE297_VPE_INST_OFFSET_0) \
_op_(LWE297_VPE_INST_DATA_0) \
_op_(LWE297_VPE_CONST_OFFSET_0) \
_op_(LWE297_VPE_CONST_DATA_0) \
_op_(LWE297_VPE_GEOM_STALL_0) \
_op_(LWE297_VPE_VPE_CTRL_0) \
_op_(LWE297_VPE_VPE_DEBUG_0) \
_op_(LWE297_SU_INST_0) \
_op_(LWE297_SU_INST) \
_op_(LWE297_SU_INST_1) \
_op_(LWE297_SU_INST_2) \
_op_(LWE297_SU_INST_3) \
_op_(LWE297_SU_INST_4) \
_op_(LWE297_SU_INST_5) \
_op_(LWE297_SU_INST_6) \
_op_(LWE297_SU_INST_7) \
_op_(LWE297_SU_INST_8) \
_op_(LWE297_SU_INST_9) \
_op_(LWE297_SU_INST_10) \
_op_(LWE297_SU_INST_11) \
_op_(LWE297_SU_INST_12) \
_op_(LWE297_SU_INST_13) \
_op_(LWE297_SU_INST_14) \
_op_(LWE297_SU_INST_15) \
_op_(LWE297_SU_INST_16) \
_op_(LWE297_SU_INST_17) \
_op_(LWE297_SU_INST_18) \
_op_(LWE297_SU_INST_19) \
_op_(LWE297_SU_INST_20) \
_op_(LWE297_SU_INST_21) \
_op_(LWE297_SU_INST_22) \
_op_(LWE297_SU_INST_23) \
_op_(LWE297_SU_INST_24) \
_op_(LWE297_SU_INST_25) \
_op_(LWE297_SU_INST_26) \
_op_(LWE297_SU_INST_27) \
_op_(LWE297_SU_INST_28) \
_op_(LWE297_SU_INST_29) \
_op_(LWE297_SU_INST_30) \
_op_(LWE297_SU_INST_31) \
_op_(LWE297_SU_INST_32) \
_op_(LWE297_SU_INST_33) \
_op_(LWE297_SU_INST_34) \
_op_(LWE297_SU_INST_35) \
_op_(LWE297_SU_INST_36) \
_op_(LWE297_SU_INST_37) \
_op_(LWE297_SU_INST_38) \
_op_(LWE297_SU_INST_39) \
_op_(LWE297_SU_INST_40) \
_op_(LWE297_SU_INST_41) \
_op_(LWE297_SU_INST_42) \
_op_(LWE297_SU_INST_43) \
_op_(LWE297_SU_INST_44) \
_op_(LWE297_SU_INST_45) \
_op_(LWE297_SU_INST_46) \
_op_(LWE297_SU_INST_47) \
_op_(LWE297_SU_INST_48) \
_op_(LWE297_SU_INST_49) \
_op_(LWE297_SU_INST_50) \
_op_(LWE297_SU_INST_51) \
_op_(LWE297_SU_INST_52) \
_op_(LWE297_SU_INST_53) \
_op_(LWE297_SU_INST_54) \
_op_(LWE297_SU_INST_55) \
_op_(LWE297_SU_INST_56) \
_op_(LWE297_SU_INST_57) \
_op_(LWE297_SU_INST_58) \
_op_(LWE297_SU_INST_59) \
_op_(LWE297_SU_INST_60) \
_op_(LWE297_SU_INST_61) \
_op_(LWE297_SU_INST_62) \
_op_(LWE297_SU_INST_63) \
_op_(LWE297_SU_DRAW_POINT_0) \
_op_(LWE297_SU_DRAW_LINE_0) \
_op_(LWE297_SU_DRAW_TRI_0) \
_op_(LWE297_SU_PARAM_0) \
_op_(LWE297_SU_ZBIAS_0) \
_op_(LWE297_SU_ZFACTOR_0) \
_op_(LWE297_SU_POINT_PARAM_0) \
_op_(LWE297_SU_POINT_WIDTH_2_0) \
_op_(LWE297_SU_POINT_MAX_S_0) \
_op_(LWE297_SU_POINT_MAX_T_0) \
_op_(LWE297_SU_POINT_MIN_S_0) \
_op_(LWE297_SU_POINT_MIN_T_0) \
_op_(LWE297_SU_LINE_PARAM_0) \
_op_(LWE297_SU_LINE_WIDTH_2_0) \
_op_(LWE297_SU_LINE_MAX_ATTR_W_0) \
_op_(LWE297_SU_LINE_MIN_ATTR_W_0) \
_op_(LWE297_SU_SCISSOR_X_0) \
_op_(LWE297_SU_SCISSOR_Y_0) \
_op_(LWE297_SU_VIEWPORT_X_0) \
_op_(LWE297_SU_VIEWPORT_Y_0) \
_op_(LWE297_SU_VIEWPORT_Z_0) \
_op_(LWE297_SU_VIEWPORT_W_0) \
_op_(LWE297_SU_VIEWPORT_H_0) \
_op_(LWE297_SU_VIEWPORT_D_0) \
_op_(LWE297_SU_GUARDBAND_W_0) \
_op_(LWE297_SU_GUARDBAND_H_0) \
_op_(LWE297_SU_GUARDBAND_D_0) \
_op_(LWE297_SU_UCPLANE_0) \
_op_(LWE297_SU_UCPLANE) \
_op_(LWE297_SU_CLKEN_OVERRIDE_0) \
_op_(LWE297_SU_CLIP_CLKEN_OVERRIDE_0) \
_op_(LWE297_QR_S_TEST_0) \
_op_(LWE297_QR_S_TEST) \
_op_(LWE297_QR_S_TEST_1) \
_op_(LWE297_QR_S_CTRL_0) \
_op_(LWE297_QR_Z_TEST_0) \
_op_(LWE297_QR_Z_MIN_0) \
_op_(LWE297_QR_Z_MAX_0) \
_op_(LWE297_QR_RAST_OPERATION_0) \
_op_(LWE297_QR_RAST_SCISSOR_SNAP_0) \
_op_(LWE297_QR_RAST_SCISSOR_MIN_0) \
_op_(LWE297_QR_RAST_SCISSOR_MAX_0) \
_op_(LWE297_QR_RAST_BBOX_MIN_0) \
_op_(LWE297_QR_RAST_BBOX_MAX_0) \
_op_(LWE297_QR_SB_OPERATION_0) \
_op_(LWE297_QR_QRAST_CLKEN_OVERRIDE_0) \
_op_(LWE297_QR_VCAA_OPERATION_0) \
_op_(LWE297_QR_OUTPUT_TO_SHADER_0) \
_op_(LWE297_QR_QRAST_DEBUG_0) \
_op_(LWE297_QR_QRAST_LIMITS_0) \
_op_(LWE297_PSEQ_FLUSH_0) \
_op_(LWE297_PSEQ_CTL_0) \
_op_(LWE297_PSEQ_TIMEOUT_0) \
_op_(LWE297_PSEQ_PC_0) \
_op_(LWE297_PSEQ_COMMAND_0) \
_op_(LWE297_PSEQ_COMMAND) \
_op_(LWE297_PSEQ_COMMAND_1) \
_op_(LWE297_PSEQ_COMMAND_2) \
_op_(LWE297_PSEQ_COMMAND_3) \
_op_(LWE297_PSEQ_COMMAND_4) \
_op_(LWE297_PSEQ_COMMAND_5) \
_op_(LWE297_PSEQ_COMMAND_6) \
_op_(LWE297_PSEQ_COMMAND_7) \
_op_(LWE297_PSEQ_COMMAND_8) \
_op_(LWE297_PSEQ_COMMAND_9) \
_op_(LWE297_PSEQ_COMMAND_10) \
_op_(LWE297_PSEQ_COMMAND_11) \
_op_(LWE297_PSEQ_COMMAND_12) \
_op_(LWE297_PSEQ_COMMAND_13) \
_op_(LWE297_PSEQ_COMMAND_14) \
_op_(LWE297_PSEQ_COMMAND_15) \
_op_(LWE297_PSEQ_COMMAND_16) \
_op_(LWE297_PSEQ_COMMAND_17) \
_op_(LWE297_PSEQ_COMMAND_18) \
_op_(LWE297_PSEQ_COMMAND_19) \
_op_(LWE297_PSEQ_COMMAND_20) \
_op_(LWE297_PSEQ_COMMAND_21) \
_op_(LWE297_PSEQ_COMMAND_22) \
_op_(LWE297_PSEQ_COMMAND_23) \
_op_(LWE297_PSEQ_COMMAND_24) \
_op_(LWE297_PSEQ_COMMAND_25) \
_op_(LWE297_PSEQ_COMMAND_26) \
_op_(LWE297_PSEQ_COMMAND_27) \
_op_(LWE297_PSEQ_COMMAND_28) \
_op_(LWE297_PSEQ_COMMAND_29) \
_op_(LWE297_PSEQ_COMMAND_30) \
_op_(LWE297_PSEQ_COMMAND_31) \
_op_(LWE297_PSEQ_INST_OFFSET_0) \
_op_(LWE297_PSEQ_INST_DATA_0) \
_op_(LWE297_PSEQ_DBG_X_0) \
_op_(LWE297_PSEQ_DBG_Y_0) \
_op_(LWE297_PSEQ_DBG_CTL_0) \
_op_(LWE297_PSEQ_QUAD_ID_0) \
_op_(LWE297_PSEQ_DWR_IF_STATE_0) \
_op_(LWE297_AT_REMAP_OFFSET_0) \
_op_(LWE297_AT_REMAP_DATA_0) \
_op_(LWE297_AT_REMAP_DATA_4X_0) \
_op_(LWE297_AT_INST_OFFSET_0) \
_op_(LWE297_AT_INST_DATA_0) \
_op_(LWE297_AT_CONSTANT0_0) \
_op_(LWE297_AT_CONSTANT0) \
_op_(LWE297_AT_CONSTANT0_1) \
_op_(LWE297_AT_CONSTANT0_2) \
_op_(LWE297_AT_CONSTANT0_3) \
_op_(LWE297_AT_TRAM_OFFSET_0) \
_op_(LWE297_AT_TRAM_DATA_0) \
_op_(LWE297_AT_CLKEN_OVERRIDE_0) \
_op_(LWE297_TEX_INST_OFFSET_0) \
_op_(LWE297_TEX_INST_DATA_0) \
_op_(LWE297_TEX_COLORKEY_0) \
_op_(LWE297_TEX_TEXADDR_0) \
_op_(LWE297_TEX_TEXADDR) \
_op_(LWE297_TEX_TEXADDR_1) \
_op_(LWE297_TEX_TEXADDR_2) \
_op_(LWE297_TEX_TEXADDR_3) \
_op_(LWE297_TEX_TEXADDR_4) \
_op_(LWE297_TEX_TEXADDR_5) \
_op_(LWE297_TEX_TEXADDR_6) \
_op_(LWE297_TEX_TEXADDR_7) \
_op_(LWE297_TEX_TEXADDR_8) \
_op_(LWE297_TEX_TEXADDR_9) \
_op_(LWE297_TEX_TEXADDR_10) \
_op_(LWE297_TEX_TEXADDR_11) \
_op_(LWE297_TEX_TEXADDR_12) \
_op_(LWE297_TEX_TEXADDR_13) \
_op_(LWE297_TEX_TEXADDR_14) \
_op_(LWE297_TEX_TEXADDR_15) \
_op_(LWE297_TEX_TEXDESC_0) \
_op_(LWE297_TEX_TEXDESC) \
_op_(LWE297_TEX_TEXDESC_1) \
_op_(LWE297_TEX_TEXDESC_2) \
_op_(LWE297_TEX_TEXDESC_3) \
_op_(LWE297_TEX_TEXDESC_4) \
_op_(LWE297_TEX_TEXDESC_5) \
_op_(LWE297_TEX_TEXDESC_6) \
_op_(LWE297_TEX_TEXDESC_7) \
_op_(LWE297_TEX_TEXDESC_8) \
_op_(LWE297_TEX_TEXDESC_9) \
_op_(LWE297_TEX_TEXDESC_10) \
_op_(LWE297_TEX_TEXDESC_11) \
_op_(LWE297_TEX_TEXDESC_12) \
_op_(LWE297_TEX_TEXDESC_13) \
_op_(LWE297_TEX_TEXDESC_14) \
_op_(LWE297_TEX_TEXDESC_15) \
_op_(LWE297_TEX_TEXDESC_16) \
_op_(LWE297_TEX_TEXDESC_17) \
_op_(LWE297_TEX_TEXDESC_18) \
_op_(LWE297_TEX_TEXDESC_19) \
_op_(LWE297_TEX_TEXDESC_20) \
_op_(LWE297_TEX_TEXDESC_21) \
_op_(LWE297_TEX_TEXDESC_22) \
_op_(LWE297_TEX_TEXDESC_23) \
_op_(LWE297_TEX_TEXDESC_24) \
_op_(LWE297_TEX_TEXDESC_25) \
_op_(LWE297_TEX_TEXDESC_26) \
_op_(LWE297_TEX_TEXDESC_27) \
_op_(LWE297_TEX_TEXDESC_28) \
_op_(LWE297_TEX_TEXDESC_29) \
_op_(LWE297_TEX_TEXDESC_30) \
_op_(LWE297_TEX_TEXDESC_31) \
_op_(LWE297_TEX_TEXCTL_0) \
_op_(LWE297_TEX_CLKEN_OVERRIDE_0) \
_op_(LWE297_TEX_LW_MCCIF_FIFOCTRL_RO_0) \
_op_(LWE297_ALU_REMAP_OFFSET_0) \
_op_(LWE297_ALU_REMAP_DATA_0) \
_op_(LWE297_ALU_REMAP_DATA_4X_0) \
_op_(LWE297_ALU_INST_OFFSET_0) \
_op_(LWE297_ALU_INST_DATA_0) \
_op_(LWE297_ALU_P2CX_OFFSET_0) \
_op_(LWE297_ALU_P2CX_DATA_0) \
_op_(LWE297_ALU_GLOBALS_0) \
_op_(LWE297_ALU_GLOBALS) \
_op_(LWE297_ALU_GLOBALS_1) \
_op_(LWE297_ALU_GLOBALS_2) \
_op_(LWE297_ALU_GLOBALS_3) \
_op_(LWE297_ALU_GLOBALS_4) \
_op_(LWE297_ALU_GLOBALS_5) \
_op_(LWE297_ALU_GLOBALS_6) \
_op_(LWE297_ALU_GLOBALS_7) \
_op_(LWE297_ALU_GLOBALS_8) \
_op_(LWE297_ALU_GLOBALS_9) \
_op_(LWE297_ALU_GLOBALS_10) \
_op_(LWE297_ALU_GLOBALS_11) \
_op_(LWE297_ALU_GLOBALS_12) \
_op_(LWE297_ALU_GLOBALS_13) \
_op_(LWE297_ALU_GLOBALS_14) \
_op_(LWE297_ALU_GLOBALS_15) \
_op_(LWE297_ALU_GLOBALS_16) \
_op_(LWE297_ALU_GLOBALS_17) \
_op_(LWE297_ALU_GLOBALS_18) \
_op_(LWE297_ALU_GLOBALS_19) \
_op_(LWE297_ALU_GLOBALS_20) \
_op_(LWE297_ALU_GLOBALS_21) \
_op_(LWE297_ALU_GLOBALS_22) \
_op_(LWE297_ALU_GLOBALS_23) \
_op_(LWE297_ALU_GLOBALS_24) \
_op_(LWE297_ALU_GLOBALS_25) \
_op_(LWE297_ALU_GLOBALS_26) \
_op_(LWE297_ALU_GLOBALS_27) \
_op_(LWE297_ALU_GLOBALS_28) \
_op_(LWE297_ALU_GLOBALS_29) \
_op_(LWE297_ALU_GLOBALS_30) \
_op_(LWE297_ALU_GLOBALS_31) \
_op_(LWE297_DW_INST_OFFSET_0) \
_op_(LWE297_DW_INST_DATA_0) \
_op_(LWE297_DW_LOGIC_OP_0) \
_op_(LWE297_DW_ST_ENABLE_0) \
_op_(LWE297_FDC_CONTROL_0) \
_op_(LWE297_FDC_STATUS_0) \
_op_(LWE297_FDC_MAX_QZ_LINES_0) \
_op_(LWE297_FDC_MAX_QV_LINES_0) \
_op_(LWE297_FDC_MAX_QS_LINES_0) \
_op_(LWE297_FDC_MAX_PS_LINES_0) \
_op_(LWE297_FDC_MAX_Q_LINES_0) \
_op_(LWE297_FDC_MAX_Q_P_LINES_0) \
_op_(LWE297_FDC_FLUSH_CTL_0) \
_op_(LWE297_FDC_L1_TIMEOUT_0) \
_op_(LWE297_FDC_INSTRUMENT_0) \
_op_(LWE297_FDC_CLKEN_OVERRIDE_0) \
_op_(LWE297_FDC_LW_MCCIF_FIFOCTRL_RO_0) \
_op_(LWE297_GLOBAL_SURFADDR_0) \
_op_(LWE297_GLOBAL_SURFADDR) \
_op_(LWE297_GLOBAL_SURFADDR_1) \
_op_(LWE297_GLOBAL_SURFADDR_2) \
_op_(LWE297_GLOBAL_SURFADDR_3) \
_op_(LWE297_GLOBAL_SURFADDR_4) \
_op_(LWE297_GLOBAL_SURFADDR_5) \
_op_(LWE297_GLOBAL_SURFADDR_6) \
_op_(LWE297_GLOBAL_SURFADDR_7) \
_op_(LWE297_GLOBAL_SURFADDR_8) \
_op_(LWE297_GLOBAL_SURFADDR_9) \
_op_(LWE297_GLOBAL_SURFADDR_10) \
_op_(LWE297_GLOBAL_SURFADDR_11) \
_op_(LWE297_GLOBAL_SURFADDR_12) \
_op_(LWE297_GLOBAL_SURFADDR_13) \
_op_(LWE297_GLOBAL_SURFADDR_14) \
_op_(LWE297_GLOBAL_SURFADDR_15) \
_op_(LWE297_GLOBAL_SURFDESC_0) \
_op_(LWE297_GLOBAL_SURFDESC) \
_op_(LWE297_GLOBAL_SURFDESC_1) \
_op_(LWE297_GLOBAL_SURFDESC_2) \
_op_(LWE297_GLOBAL_SURFDESC_3) \
_op_(LWE297_GLOBAL_SURFDESC_4) \
_op_(LWE297_GLOBAL_SURFDESC_5) \
_op_(LWE297_GLOBAL_SURFDESC_6) \
_op_(LWE297_GLOBAL_SURFDESC_7) \
_op_(LWE297_GLOBAL_SURFDESC_8) \
_op_(LWE297_GLOBAL_SURFDESC_9) \
_op_(LWE297_GLOBAL_SURFDESC_10) \
_op_(LWE297_GLOBAL_SURFDESC_11) \
_op_(LWE297_GLOBAL_SURFDESC_12) \
_op_(LWE297_GLOBAL_SURFDESC_13) \
_op_(LWE297_GLOBAL_SURFDESC_14) \
_op_(LWE297_GLOBAL_SURFDESC_15) \
_op_(LWE297_GLOBAL_PIX_ATTR_0) \
_op_(LWE297_GLOBAL_TRI_ATTR_0) \
_op_(LWE297_GLOBAL_INST_OFFSET_0) \
_op_(LWE297_GLOBAL_RAISE_0) \
_op_(LWE297_GLOBAL_REFCNT_0) \
_op_(LWE297_GLOBAL_INSTRUMENT_0) \
_op_(LWE297_GLOBAL_DITHER_TABLE_0) \
_op_(LWE297_GLOBAL_FLUSH_0) \
_op_(LWE297_GLOBAL_S_OPERATION_0) \
_op_(LWE297_GLOBAL_S_OPERATION) \
_op_(LWE297_GLOBAL_S_OPERATION_1) \
_op_(LWE297_GLOBAL_SPILLSURFADDR_0) \
_op_(LWE297_GLOBAL_LW_MCCIF_FIFOCTRL_0)


//
// ADDRESS SPACES
//

#define BASE_ADDRESS_LWE297_CTL   0x00000000
#define BASE_ADDRESS_LWE297_IDX   0x00000100
#define BASE_ADDRESS_LWE297_VPE   0x00000200
#define BASE_ADDRESS_LWE297_SU    0x00000300
#define BASE_ADDRESS_LWE297_QR    0x00000400
#define BASE_ADDRESS_LWE297_PSEQ  0x00000500
#define BASE_ADDRESS_LWE297_AT    0x00000600
#define BASE_ADDRESS_LWE297_TEX   0x00000700
#define BASE_ADDRESS_LWE297_ALU   0x00000800
#define BASE_ADDRESS_LWE297_DW    0x00000900
#define BASE_ADDRESS_LWE297_FDC   0x00000a00
#define BASE_ADDRESS_LWE297_GLOBAL        0x00000e00

//
// AR3D REGISTER BANKS
//

#define LWE297_CTL0_FIRST_REG 0x0000 // AR3D_CTL_INCR_SYNCPT_0
#define LWE297_CTL0_LAST_REG 0x0002 // AR3D_CTL_INCR_SYNCPT_ERROR_0
#define LWE297_CTL1_FIRST_REG 0x0008 // AR3D_CTL_INTSTATUS_0
#define LWE297_CTL1_LAST_REG 0x000a // AR3D_CTL_CTXSW_0
#define LWE297_CTL2_FIRST_REG 0x000c // AR3D_CTL_STAT_0
#define LWE297_CTL2_LAST_REG 0x0015 // AR3D_CTL_STAT_EN_COUNT_1
#define LWE297_IDX0_FIRST_REG 0x0100 // AR3D_IDX_ATTRIBUTE_0
#define LWE297_IDX0_LAST_REG 0x0126 // AR3D_IDX_LW_MCCIF_FIFOCTRL_RO_0
#define LWE297_VPE0_FIRST_REG 0x0200 // AR3D_VPE_MODE_0
#define LWE297_VPE0_LAST_REG 0x020b // AR3D_VPE_VPE_DEBUG_0
#define LWE297_SU0_FIRST_REG 0x0300 // AR3D_SU_INST_0
#define LWE297_SU0_LAST_REG 0x035b // AR3D_SU_UCPLANE_0
#define LWE297_SU1_FIRST_REG 0x0363 // AR3D_SU_CLKEN_OVERRIDE_0
#define LWE297_SU1_LAST_REG 0x0364 // AR3D_SU_CLIP_CLKEN_OVERRIDE_0
#define LWE297_QR0_FIRST_REG 0x0400 // AR3D_QR_S_TEST_0
#define LWE297_QR0_LAST_REG 0x0411 // AR3D_QR_QRAST_LIMITS_0
#define LWE297_PSEQ0_FIRST_REG 0x0500 // AR3D_PSEQ_FLUSH_0
#define LWE297_PSEQ0_LAST_REG 0x0503 // AR3D_PSEQ_PC_0
#define LWE297_PSEQ1_FIRST_REG 0x0520 // AR3D_PSEQ_COMMAND_0
#define LWE297_PSEQ1_LAST_REG 0x0546 // AR3D_PSEQ_DWR_IF_STATE_0
#define LWE297_AT0_FIRST_REG 0x0600 // AR3D_AT_REMAP_OFFSET_0
#define LWE297_AT0_LAST_REG 0x0604 // AR3D_AT_INST_DATA_0
#define LWE297_AT1_FIRST_REG 0x0608 // AR3D_AT_CONSTANT0_0
#define LWE297_AT1_LAST_REG 0x060e // AR3D_AT_CLKEN_OVERRIDE_0
#define LWE297_TEX0_FIRST_REG 0x0700 // AR3D_TEX_INST_OFFSET_0
#define LWE297_TEX0_LAST_REG 0x0702 // AR3D_TEX_COLORKEY_0
#define LWE297_TEX1_FIRST_REG 0x0710 // AR3D_TEX_TEXADDR_0
#define LWE297_TEX1_LAST_REG 0x0742 // AR3D_TEX_LW_MCCIF_FIFOCTRL_RO_0
#define LWE297_ALU0_FIRST_REG 0x0800 // AR3D_ALU_REMAP_OFFSET_0
#define LWE297_ALU0_LAST_REG 0x0806 // AR3D_ALU_P2CX_DATA_0
#define LWE297_ALU1_FIRST_REG 0x0820 // AR3D_ALU_GLOBALS_0
#define LWE297_ALU1_LAST_REG 0x083f // AR3D_ALU_GLOBALS_31
#define LWE297_DW0_FIRST_REG 0x0900 // AR3D_DW_INST_OFFSET_0
#define LWE297_DW0_LAST_REG 0x0903 // AR3D_DW_ST_ENABLE_0
#define LWE297_FDC0_FIRST_REG 0x0a00 // AR3D_FDC_CONTROL_0
#define LWE297_FDC0_LAST_REG 0x0a0c // AR3D_FDC_LW_MCCIF_FIFOCTRL_RO_0
#define LWE297_GLOBAL0_FIRST_REG 0x0e00 // AR3D_GLOBAL_SURFADDR_0
#define LWE297_GLOBAL0_LAST_REG 0x0e2b // AR3D_GLOBAL_LW_MCCIF_FIFOCTRL_0

#ifndef _MK_ENUM_CONST
  #define _MK_ENUM_CONST(_constant_) (_constant_ ## UL)
#endif
#ifndef _MK_ADDR_CONST
  #define _MK_ADDR_CONST(_constant_) _constant_
#endif

#endif // ifndef _e297_h_

