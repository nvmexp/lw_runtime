/*
 * SPDX-FileCopyrightText: Copyright (c) 2020-2022 LWPU CORPORATION & AFFILIATES. All rights reserved.
 * SPDX-License-Identifier: MIT
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once

#include <lwtypes.h>
#if defined(_MSC_VER)
#pragma warning(disable:4324)
#endif

//
// This file was generated with FINN, an LWPU coding tool.
// Source file: ctrl/ctrl2080/ctrl2080internal.finn
//
#if (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)
//
// Please edit the original FINN IDL file to create desired edits in this header
// See https://confluence.lwpu.com/display/CORERM/FINN for more info on how to
// edit FINN.
//
#endif // (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)

#include "lwimpshared.h"



#include "ctrl/ctrl2080/ctrl2080base.h"

#include "ctrl/ctrl2080/ctrl2080gpu.h"
#include "ctrl/ctrl2080/ctrl2080gr.h"        /* Some controls derivative of 2080gr */
#include "ctrl/ctrl0080/ctrl0080msenc.h"     /* LW0080_CTRL_MSENC_CAPS_TBL_SIZE    */
#include "ctrl/ctrl0080/ctrl0080bsp.h"       /* LW0080_CTRL_BSP_CAPS_TBL_SIZE      */
#include "ctrl/ctrl2080/ctrl2080fifo.h"      /* LW2080_CTRL_FIFO_UPDATE_CHANNEL_INFO */
#include "ctrl/ctrl0000/ctrl0000system.h"
/*!
 * LW2080_CTRL_CMD_INTERNAL_DISPLAY_GET_STATIC_INFO
 *
 *    This command obtains information from physical RM for use by CPU-RM.
 *
 *   feHwSysCap
 *     Display IP v03_00 and later.
 *     Contents of capability register.
 *
 *   windowPresentMask
 *     Display IP v03_00 and later.
 *     Mask for the present WINDOWs actually on the current chip.
 *   bFbRemapperEnabled
 *     Display IP v02_01 and later.
 *     Indicates that the display remapper HW exists and is enabled.
 */

#define LW2080_CTRL_CMD_INTERNAL_DISPLAY_GET_STATIC_INFO (0x20800a01) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_DISPLAY_GET_STATIC_INFO_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_DISPLAY_GET_STATIC_INFO_PARAMS_MESSAGE_ID (0x1U)

typedef struct LW2080_CTRL_INTERNAL_DISPLAY_GET_STATIC_INFO_PARAMS {
    LwU32  feHwSysCap;
    LwU32  windowPresentMask;
    LwBool bFbRemapperEnabled;
} LW2080_CTRL_INTERNAL_DISPLAY_GET_STATIC_INFO_PARAMS;

#if (!defined(LWRM_PUBLISHED_PENDING_IP_REVIEW) || LWRM_PUBLISHED_PENDING_IP_REVIEW == 1)


/*!
 * @ref LW2080_CTRL_CMD_GR_CTXSW_ZLWLL_MODE
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_CTXSW_ZLWLL_MODE             (0x20800a02) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x2" */

/*!
 * @ref LW2080_CTRL_CMD_GR_CTXSW_PM_MODE
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_CTXSW_PM_MODE                (0x20800a03) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x3" */

/*!
 * @ref LW2080_CTRL_CMD_GR_CTXSW_ZLWLL_BIND
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_CTXSW_ZLWLL_BIND             (0x20800a04) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x4" */

/*!
 * @ref LW2080_CTRL_CMD_GR_CTXSW_PM_BIND
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_CTXSW_PM_BIND                (0x20800a05) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x5" */

/*!
 * @ref LW2080_CTRL_CMD_GR_SET_GPC_TILE_MAP
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_SET_GPC_TILE_MAP             (0x20800a06) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x6" */

/*!
 * @ref LW2080_CTRL_CMD_GR_CTXSW_SMPC_MODE
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_CTXSW_SMPC_MODE              (0x20800a07) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x7" */

/*!
 * @ref LW2080_CTRL_CMD_GR_SET_CTXSW_PREEMPTION_MODE
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_SET_CTXSW_PREEMPTION_MODE    (0x20800a08) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x8" */

/*!
 * @ref LW2080_CTRL_CMD_GR_CTXSW_PREEMPTION_BIND
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_CTXSW_PREEMPTION_BIND        (0x20800a09) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x9" */

/*!
 * @ref LW2080_CTRL_CMD_GR_PC_SAMPLING_MODE
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_PC_SAMPLING_MODE             (0x20800a0a) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0xA" */

/*!
 * @ref LW2080_CTRL_CMD_GR_SET_DELAY_CILP_PREEMPT
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_SET_DELAY_CILP_PREEMPT       (0x20800a0b) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0xB" */

/*!
 * @ref LW2080_CTRL_CMD_GR_GET_CTXSW_STATS
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_GET_CTXSW_STATS              (0x20800a0c) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0xC" */

/*!
 * @ref LW2080_CTRL_CMD_GR_SET_GFXP_TIMEOUT
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_SET_GFXP_TIMEOUT             (0x20800a0d) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0xD" */

/*!
 * @ref LW2080_CTRL_CMD_GR_GET_LWRRENT_RESIDENT_CHANNEL
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_GET_LWRRENT_RESIDENT_CHANNEL (0x20800a0e) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0xE" */

/*!
 * @ref LW2080_CTRL_CMD_GR_GET_VAT_ALARM_DATA
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_GET_VAT_ALARM_DATA           (0x20800a0f) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0xF" */

/*!
 * @ref LW2080_CTRL_CMD_GR_GFX_POOL_QUERY_SIZE
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_GFX_POOL_QUERY_SIZE          (0x20800a10) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x10" */

/*!
 * @ref LW2080_CTRL_CMD_GR_GFX_POOL_INITIALIZE
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_GFX_POOL_INITIALIZE          (0x20800a11) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x11" */

/*!
 * @ref LW2080_CTRL_CMD_GR_GFX_POOL_ADD_SLOTS
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_GFX_POOL_ADD_SLOTS           (0x20800a12) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x12" */

/*!
 * @ref LW2080_CTRL_CMD_GR_GFX_POOL_REMOVE_SLOTS
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_GFX_POOL_REMOVE_SLOTS        (0x20800a13) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x13" */

/*!
 * @ref LW2080_CTRL_CMD_GR_REG_ACCESS
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_REG_ACCESS                   (0x20800a15) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x15" */

/*!
 * @ref LW2080_CTRL_CMD_GR_SET_CONTEXT_OVERRIDE
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_SET_CONTEXT_OVERRIDE         (0x20800a16) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x16" */

/*!
 * @ref LW2080_CTRL_CMD_GR_SET_TPC_PARTITION_MODE
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_SET_TPC_PARTITION_MODE       (0x20800a17) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x17" */

/*!
 * @ref LW2080_CTRL_CMD_GR_SET_CTXSW_TEST_STATE
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_SET_CTXSW_TEST_STATE         (0x20800a19) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x19" */

/*!
 * @ref LW2080_CTRL_CMD_GR_PROCESS_PREEMPTION_STATS
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_PROCESS_PREEMPTION_STATS     (0x20800a1a) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x1A" */

/*!
 * @ref LW2080_CTRL_CMD_GR_GET_GPC_TILE_MAP
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_GET_GPC_TILE_MAP             (0x20800a1b) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x1B" */

//
// MemorySystem settings that are static after GPU state init/load is finished.
//
// Fields are shared between the VGPU guest/GSP Client as well as the VGPU
// host/GSP-RM.
//
#define LW2080_CTRL_INTERNAL_MEMSYS_GET_STATIC_CONFIG_PARAMS_MESSAGE_ID (0x1LW)

typedef struct LW2080_CTRL_INTERNAL_MEMSYS_GET_STATIC_CONFIG_PARAMS {
    /*! Determines if RM should use 1 to 1 Comptagline allocation policy */
    LwBool bOneToOneComptagLineAllocation;

    /*! Determines if RM should use 1 to 4 Comptagline allocation policy */
    LwBool bUseOneToFourComptagLineAllocation;

    /*! Determines if RM should use raw Comptagline allocation policy */
    LwBool bUseRawModeComptaglineAllocation;

    /*! Has COMPBIT_BACKING_SIZE been overridden to zero (i.e. disabled)? */
    LwBool bDisableCompbitBacking;

    /*! Determine if we need to disable post L2 compression */
    LwBool bDisablePostL2Compression;

    /*! Is ECC DRAM feature supported? */
    LwBool bEnabledEccFBPA;

    LwBool bL2PreFill;

    /*! L2 cache size */
    LW_DECLARE_ALIGNED(LwU64 l2CacheSize, 8);

    LwBool bReservedMemAtBottom;

    /*! Indicate whether fpba is present or not */
    LwBool bFbpaPresent;

    /*! Size covered by one comptag */
    LwU32  comprPageSize;

    /*! log32(comprPageSize) */
    LwU32  comprPageShift;

    /*! Maximum number of pages that can be dynamaically blacklisted */
    LwU16  maximumBlacklistPages;

    /*! RAM type */
    LwU32  ramType;

    /*! LTC count */
    LwU32  ltcCount;

    /*! LTS per LTC count */
    LwU32  ltsPerLtcCount;

    /*! Ampere PLC bug */
    LwBool bDisablePlcForCertainOffsetsBug3046774;
} LW2080_CTRL_INTERNAL_MEMSYS_GET_STATIC_CONFIG_PARAMS;

/*!
 * Retrieve Memory System Static data.
 */
#define LW2080_CTRL_CMD_INTERNAL_MEMSYS_GET_STATIC_CONFIG        (0x20800a1c) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_MEMSYS_GET_STATIC_CONFIG_PARAMS_MESSAGE_ID" */

/*
 * LW2080_CTRL_CMD_INTERNAL_REGISTER_UVM_ACCESS_CNTR_BUFFER
 *
 * This command sends access counter buffer pages allocated by CPU-RM
 * to be setup and enabled in physical RM.
 *
 * bufferSize
 *   Size of the access counter buffer to register.
 *
 * bufferPteArray
 *   Pages of access counter buffer.
 *
 * Possible status values returned are:
 *   LW_OK
 */
#define LW2080_CTRL_CMD_INTERNAL_UVM_REGISTER_ACCESS_CNTR_BUFFER (0x20800a1d) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_UVM_REGISTER_ACCESS_CNTR_BUFFER_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_UVM_ACCESS_CNTR_BUFFER_MAX_PAGES    64
#define LW2080_CTRL_INTERNAL_UVM_REGISTER_ACCESS_CNTR_BUFFER_PARAMS_MESSAGE_ID (0x1DU)

typedef struct LW2080_CTRL_INTERNAL_UVM_REGISTER_ACCESS_CNTR_BUFFER_PARAMS {
    LwU32 bufferSize;
    LW_DECLARE_ALIGNED(LwU64 bufferPteArray[LW2080_CTRL_INTERNAL_UVM_ACCESS_CNTR_BUFFER_MAX_PAGES], 8);
} LW2080_CTRL_INTERNAL_UVM_REGISTER_ACCESS_CNTR_BUFFER_PARAMS;

/*
 * LW2080_CTRL_CMD_INTERNAL_UVM_UNREGISTER_ACCESS_CNTR_BUFFER
 *
 * This command requests physical RM to disable the access counter buffer.
 *
 * Possible status values returned are:
 *   LW_OK
 */
#define LW2080_CTRL_CMD_INTERNAL_UVM_UNREGISTER_ACCESS_CNTR_BUFFER (0x20800a1e) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x1E" */

/* LWRM_PUBLISHED_PENDING_IP_REVIEW */
#endif // (!defined(LWRM_PUBLISHED_PENDING_IP_REVIEW) || LWRM_PUBLISHED_PENDING_IP_REVIEW == 1)



/*
 * LW2080_CTRL_CMD_INTERNAL_UVM_SERVICE_ACCESS_CNTR_BUFFER
 *
 * This command requests physical RM to service the access counter buffer.
 *
 * Possible status values returned are:
 *   LW_OK
 */
#define LW2080_CTRL_CMD_INTERNAL_UVM_SERVICE_ACCESS_CNTR_BUFFER    (0x20800a21) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x21" */

/*
 * LW2080_CTRL_CMD_INTERNAL_UVM_GET_ACCESS_CNTR_BUFFER_SIZE
 *
 * This command retrieves the access counter buffer size from physical RM.
 *
 * bufferSize[OUT]
 *   Size of the access counter buffer.
 *
 * Possible status values returned are:
 *   LW_OK
 */
#define LW2080_CTRL_CMD_INTERNAL_UVM_GET_ACCESS_CNTR_BUFFER_SIZE   (0x20800a29) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_UVM_GET_ACCESS_CNTR_BUFFER_SIZE_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_UVM_GET_ACCESS_CNTR_BUFFER_SIZE_PARAMS_MESSAGE_ID (0x29U)

typedef struct LW2080_CTRL_INTERNAL_UVM_GET_ACCESS_CNTR_BUFFER_SIZE_PARAMS {
    LwU32 bufferSize;
} LW2080_CTRL_INTERNAL_UVM_GET_ACCESS_CNTR_BUFFER_SIZE_PARAMS;

#define LW2080_CTRL_INTERNAL_GR_MAX_ENGINES          8

/*!
 * @ref LW2080_CTRL_CMD_GR_GET_CAPS_V2
 */
#define LW2080_CTRL_CMD_INTERNAL_STATIC_KGR_GET_CAPS (0x20800a1f) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x1F" */

#if (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)

#define LW2080_CTRL_CMD_INTERNAL_STATIC_GR_GET_CAPS  (0x20800a20) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x20" */
/* LWRM_UNPUBLISHED */
#endif // (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)



typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_CAPS {
    LwU8 capsTbl[LW0080_CTRL_GR_CAPS_TBL_SIZE];
} LW2080_CTRL_INTERNAL_STATIC_GR_CAPS;
typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_GET_CAPS_PARAMS {
    LW2080_CTRL_INTERNAL_STATIC_GR_CAPS engineCaps[LW2080_CTRL_INTERNAL_GR_MAX_ENGINES];
} LW2080_CTRL_INTERNAL_STATIC_GR_GET_CAPS_PARAMS;

/*!
 * @ref LW2080_CTRL_CMD_GR_GET_GLOBAL_SM_ORDER
 * @ref LW2080_CTRL_CMD_GR_GET_SM_TO_GPC_TPC_MAPPINGS
 */
#define LW2080_CTRL_CMD_INTERNAL_STATIC_KGR_GET_GLOBAL_SM_ORDER (0x20800a22) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x22" */

#if (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)

#define LW2080_CTRL_CMD_INTERNAL_STATIC_GR_GET_GLOBAL_SM_ORDER  (0x20800a23) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x23" */
/* LWRM_UNPUBLISHED */
#endif // (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)



#define LW2080_CTRL_INTERNAL_GR_MAX_SM                          240

typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_GLOBAL_SM_ORDER {
    struct {
        LwU16 gpcId;
        LwU16 localTpcId;
        LwU16 localSmId;
        LwU16 globalTpcId;
        LwU16 virtualGpcId;
        LwU16 migratableTpcId;
    } globalSmId[LW2080_CTRL_INTERNAL_GR_MAX_SM];

    LwU16 numSm;
    LwU16 numTpc;
} LW2080_CTRL_INTERNAL_STATIC_GR_GLOBAL_SM_ORDER;

typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_GET_GLOBAL_SM_ORDER_PARAMS {
    LW2080_CTRL_INTERNAL_STATIC_GR_GLOBAL_SM_ORDER globalSmOrder[LW2080_CTRL_INTERNAL_GR_MAX_ENGINES];
} LW2080_CTRL_INTERNAL_STATIC_GR_GET_GLOBAL_SM_ORDER_PARAMS;

#if (!defined(LWRM_PUBLISHED_PENDING_IP_REVIEW) || LWRM_PUBLISHED_PENDING_IP_REVIEW == 1)


/*!
 * Retrieve BSP Static data.
 */
#define LW2080_CTRL_CMD_INTERNAL_BSP_GET_CAPS (0x20800a24) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_BSP_GET_CAPS_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_CMD_INTERNAL_MAX_BSPS     8

typedef struct LW2080_CTRL_INTERNAL_BSP_CAPS {
    LwU8 capsTbl[LW0080_CTRL_BSP_CAPS_TBL_SIZE];
} LW2080_CTRL_INTERNAL_BSP_CAPS;

#define LW2080_CTRL_INTERNAL_BSP_GET_CAPS_PARAMS_MESSAGE_ID (0x24U)

typedef struct LW2080_CTRL_INTERNAL_BSP_GET_CAPS_PARAMS {
    LW2080_CTRL_INTERNAL_BSP_CAPS caps[LW2080_CTRL_CMD_INTERNAL_MAX_BSPS];
    LwBool                        valid[LW2080_CTRL_CMD_INTERNAL_MAX_BSPS];
} LW2080_CTRL_INTERNAL_BSP_GET_CAPS_PARAMS;

/*!
 * Retrieve MSENC Static data.
 */
#define LW2080_CTRL_CMD_INTERNAL_MSENC_GET_CAPS (0x20800a25) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_MSENC_GET_CAPS_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_CMD_INTERNAL_MAX_MSENCS     3

typedef struct LW2080_CTRL_INTERNAL_MSENC_CAPS {
    LwU8 capsTbl[LW0080_CTRL_MSENC_CAPS_TBL_SIZE];
} LW2080_CTRL_INTERNAL_MSENC_CAPS;

#define LW2080_CTRL_INTERNAL_MSENC_GET_CAPS_PARAMS_MESSAGE_ID (0x25U)

typedef struct LW2080_CTRL_INTERNAL_MSENC_GET_CAPS_PARAMS {
    LW2080_CTRL_INTERNAL_MSENC_CAPS caps[LW2080_CTRL_CMD_INTERNAL_MAX_MSENCS];
    LwBool                          valid[LW2080_CTRL_CMD_INTERNAL_MAX_MSENCS];
} LW2080_CTRL_INTERNAL_MSENC_GET_CAPS_PARAMS;

/* LWRM_PUBLISHED_PENDING_IP_REVIEW */
#endif // (!defined(LWRM_PUBLISHED_PENDING_IP_REVIEW) || LWRM_PUBLISHED_PENDING_IP_REVIEW == 1)



#define LW2080_CTRL_INTERNAL_GR_MAX_GPC                             12
#define LW2080_CTRL_INTERNAL_MAX_TPC_PER_GPC_COUNT                  10

/*!
 * @ref LW2080_CTRL_CMD_GR_GET_GPC_MASK
 * @ref LW2080_CTRL_CMD_GR_GET_TPC_MASK
 * @ref LW2080_CTRL_CMD_GR_GET_PHYS_GPC_MASK
 */
#define LW2080_CTRL_CMD_INTERNAL_STATIC_KGR_GET_FLOORSWEEPING_MASKS (0x20800a26) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x26" */

#if (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)

#define LW2080_CTRL_CMD_INTERNAL_STATIC_GR_GET_FLOORSWEEPING_MASKS  (0x20800a27) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x27" */
/* LWRM_UNPUBLISHED */
#endif // (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)



typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_FLOORSWEEPING_MASKS {
    LwU32 gpcMask;

    /*!
     * tpcMask is indexed by logical GPC ID for MIG case
     * and indexed by physical GPC ID for non-MIG case
     */
    LwU32 tpcMask[LW2080_CTRL_INTERNAL_GR_MAX_GPC];

    /*!
     * tpcCount is always indexed by logical GPC ID
     */
    LwU32 tpcCount[LW2080_CTRL_INTERNAL_GR_MAX_GPC];
    LwU32 physGpcMask;
    LwU32 mmuPerGpc[LW2080_CTRL_INTERNAL_GR_MAX_GPC];

    LwU32 tpcToPesMap[LW2080_CTRL_INTERNAL_MAX_TPC_PER_GPC_COUNT];
    LwU32 numPesPerGpc[LW2080_CTRL_INTERNAL_GR_MAX_GPC];

    /*!
     * zlwllMask is always indexed by physical GPC ID
     */
    LwU32 zlwllMask[LW2080_CTRL_INTERNAL_GR_MAX_GPC];
} LW2080_CTRL_INTERNAL_STATIC_GR_FLOORSWEEPING_MASKS;

typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_GET_FLOORSWEEPING_MASKS_PARAMS {
    /*!
     * floorsweeping masks which are indexed via local GR index
     */
    LW2080_CTRL_INTERNAL_STATIC_GR_FLOORSWEEPING_MASKS floorsweepingMasks[LW2080_CTRL_INTERNAL_GR_MAX_ENGINES];
} LW2080_CTRL_INTERNAL_STATIC_GR_GET_FLOORSWEEPING_MASKS_PARAMS;

/*
 * LW2080_CTRL_CMD_KGR_GET_CTX_BUFFER_PTES
 *
 * This command returns physical addresses of specified context buffer.
 * To obtain addresses of whole buffer firstPage has to be advanced on
 * subsequent ilwocations of the control until whole buffer is probed.
 * If the buffer is contiguous, only single address will be returned by
 * this control.
 *
 *    bufferType[IN]
 *      Buffer type as returned by GET_CTX_BUFFER_INFO.
 *
 *    firstPage[IN]
 *      Index of the first page to return in 'physAddrs' array.
 *
 *    numPages[OUT]
 *      Number of entries filled in 'physAddrs' array. This will be 0
 *      if firstPage is greater or equal to number of pages managed by 'hBuffer'.
 *
 *    physAddrs[OUT]
 *      Physical addresses of pages comprising specified buffer.
 *
 *    bNoMorePages[OUT]
 *      End of buffer reached. Either 'physAddrs' contains last page of the
 *      buffer or 'firstPage' specifies index past the buffer.
 */
#define LW2080_CTRL_KGR_MAX_BUFFER_PTES         128
#define LW2080_CTRL_CMD_KGR_GET_CTX_BUFFER_PTES (0x20800a28) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_KGR_GET_CTX_BUFFER_PTES_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_KGR_GET_CTX_BUFFER_PTES_PARAMS_MESSAGE_ID (0x28U)

typedef struct LW2080_CTRL_KGR_GET_CTX_BUFFER_PTES_PARAMS {
    LwHandle hUserClient;
    LwHandle hChannel;
    LwU32    bufferType;
    LwU32    firstPage;
    LwU32    numPages;
    LW_DECLARE_ALIGNED(LwU64 physAddrs[LW2080_CTRL_KGR_MAX_BUFFER_PTES], 8);
    LwBool   bNoMorePages;
} LW2080_CTRL_KGR_GET_CTX_BUFFER_PTES_PARAMS;

/*!
 * @ref LW0080_CTRL_CMD_GR_GET_INFO
 * @ref LW0080_CTRL_CMD_GR_GET_INFO_V2
 * @ref LW2080_CTRL_CMD_GR_GET_INFO
 * @ref LW2080_CTRL_CMD_GR_GET_INFO_V2
 */
#define LW2080_CTRL_CMD_INTERNAL_STATIC_KGR_GET_INFO (0x20800a2a) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x2A" */

#if (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)

#define LW2080_CTRL_CMD_INTERNAL_STATIC_GR_GET_INFO  (0x20800a2b) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x2B" */
/* LWRM_UNPUBLISHED */
#endif // (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)



/*!
 * @ref LW2080_CTRL_GR_INFO
 */
typedef struct LW2080_CTRL_INTERNAL_GR_INFO {
    LwU32 index;
    LwU32 data;
} LW2080_CTRL_INTERNAL_GR_INFO;

typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_INFO {
    LW2080_CTRL_INTERNAL_GR_INFO infoList[LW0080_CTRL_GR_INFO_MAX_SIZE];
} LW2080_CTRL_INTERNAL_STATIC_GR_INFO;
typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_GET_INFO_PARAMS {
    LW2080_CTRL_INTERNAL_STATIC_GR_INFO engineInfo[LW2080_CTRL_INTERNAL_GR_MAX_ENGINES];
} LW2080_CTRL_INTERNAL_STATIC_GR_GET_INFO_PARAMS;

/*!
 * @ref LW2080_CTRL_CMD_GR_GET_ZLWLL_INFO
 */
#define LW2080_CTRL_CMD_INTERNAL_STATIC_KGR_GET_ZLWLL_INFO (0x20800a2c) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x2C" */

#if (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)

#define LW2080_CTRL_CMD_INTERNAL_STATIC_GR_GET_ZLWLL_INFO  (0x20800a2d) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x2D" */
/* LWRM_UNPUBLISHED */
#endif // (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)



typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_ZLWLL_INFO {
    LwU32 widthAlignPixels;
    LwU32 heightAlignPixels;
    LwU32 pixelSquaresByAliquots;
    LwU32 aliquotTotal;
    LwU32 zlwllRegionByteMultiplier;
    LwU32 zlwllRegionHeaderSize;
    LwU32 zlwllSubregionHeaderSize;
    LwU32 subregionCount;
    LwU32 subregionWidthAlignPixels;
    LwU32 subregionHeightAlignPixels;
} LW2080_CTRL_INTERNAL_STATIC_GR_ZLWLL_INFO;

typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_GET_ZLWLL_INFO_PARAMS {
    LW2080_CTRL_INTERNAL_STATIC_GR_ZLWLL_INFO engineZlwllInfo[LW2080_CTRL_INTERNAL_GR_MAX_ENGINES];
} LW2080_CTRL_INTERNAL_STATIC_GR_GET_ZLWLL_INFO_PARAMS;

/*!
 * @ref LW2080_CTRL_CMD_GR_GET_ROP_INFO
 */
#define LW2080_CTRL_CMD_INTERNAL_STATIC_KGR_GET_ROP_INFO (0x20800a2e) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x2E" */

#if (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)

#define LW2080_CTRL_CMD_INTERNAL_STATIC_GR_GET_ROP_INFO  (0x20800a2f) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x2F" */
/* LWRM_UNPUBLISHED */
#endif // (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)



typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_ROP_INFO {
    LwU32 ropUnitCount;
    LwU32 ropOperationsFactor;
    LwU32 ropOperationsCount;
} LW2080_CTRL_INTERNAL_STATIC_GR_ROP_INFO;

typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_GET_ROP_INFO_PARAMS {
    LW2080_CTRL_INTERNAL_STATIC_GR_ROP_INFO engineRopInfo[LW2080_CTRL_INTERNAL_GR_MAX_ENGINES];
} LW2080_CTRL_INTERNAL_STATIC_GR_GET_ROP_INFO_PARAMS;

/*!
 * @ref LW2080_CTRL_CMD_GR_GET_PPC_MASK
 */
#define LW2080_CTRL_CMD_INTERNAL_STATIC_KGR_GET_PPC_MASKS (0x20800a30) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x30" */

#if (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)

#define LW2080_CTRL_CMD_INTERNAL_STATIC_GR_GET_PPC_MASKS  (0x20800a31) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x31" */
/* LWRM_UNPUBLISHED */
#endif // (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)



typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_PPC_MASKS {
    LwU32 mask[LW2080_CTRL_INTERNAL_GR_MAX_GPC];
} LW2080_CTRL_INTERNAL_STATIC_GR_PPC_MASKS;

typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_GET_PPC_MASKS_PARAMS {
    LW2080_CTRL_INTERNAL_STATIC_GR_PPC_MASKS enginePpcMasks[LW2080_CTRL_INTERNAL_GR_MAX_ENGINES];
} LW2080_CTRL_INTERNAL_STATIC_GR_GET_PPC_MASKS_PARAMS;

/*!
 * @ref LW2080_CTRL_CMD_GR_GET_ENGINE_CONTEXT_PROPERTIES
 * @ref LW2080_CTRL_CMD_GR_GET_ATTRIBUTE_BUFFER_SIZE
 */
#define LW2080_CTRL_CMD_INTERNAL_STATIC_KGR_GET_CONTEXT_BUFFERS_INFO   (0x20800a32) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x32" */

#if (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)

#define LW2080_CTRL_CMD_INTERNAL_STATIC_GR_GET_CONTEXT_BUFFERS_INFO    (0x20800a33) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x33" */
/* LWRM_UNPUBLISHED */
#endif // (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)



#define LW2080_CTRL_INTERNAL_ENGINE_CONTEXT_PROPERTIES_ENGINE_ID_COUNT 0x19

typedef struct LW2080_CTRL_INTERNAL_ENGINE_CONTEXT_BUFFER_INFO {
    LwU32 size;
    LwU32 alignment;
} LW2080_CTRL_INTERNAL_ENGINE_CONTEXT_BUFFER_INFO;

typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_CONTEXT_BUFFERS_INFO {
    LW2080_CTRL_INTERNAL_ENGINE_CONTEXT_BUFFER_INFO engine[LW2080_CTRL_INTERNAL_ENGINE_CONTEXT_PROPERTIES_ENGINE_ID_COUNT];
} LW2080_CTRL_INTERNAL_STATIC_GR_CONTEXT_BUFFERS_INFO;

typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_GET_CONTEXT_BUFFERS_INFO_PARAMS {
    LW2080_CTRL_INTERNAL_STATIC_GR_CONTEXT_BUFFERS_INFO engineContextBuffersInfo[LW2080_CTRL_INTERNAL_GR_MAX_ENGINES];
} LW2080_CTRL_INTERNAL_STATIC_GR_GET_CONTEXT_BUFFERS_INFO_PARAMS;

/*!
 * @ref LW2080_CTRL_CMD_GR_GET_SM_ISSUE_RATE_MODIFIER
 */
#define LW2080_CTRL_CMD_INTERNAL_STATIC_KGR_GET_SM_ISSUE_RATE_MODIFIER (0x20800a34) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x34" */

#if (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)

#define LW2080_CTRL_CMD_INTERNAL_STATIC_GR_GET_SM_ISSUE_RATE_MODIFIER  (0x20800a35) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x35" */
/* LWRM_UNPUBLISHED */
#endif // (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)



typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_SM_ISSUE_RATE_MODIFIER {
    LwU8 imla0;
    LwU8 fmla16;
    LwU8 dp;
    LwU8 fmla32;
    LwU8 ffma;
    LwU8 imla1;
    LwU8 imla2;
    LwU8 imla3;
    LwU8 imla4;
} LW2080_CTRL_INTERNAL_STATIC_GR_SM_ISSUE_RATE_MODIFIER;

typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_GET_SM_ISSUE_RATE_MODIFIER_PARAMS {
    LW2080_CTRL_INTERNAL_STATIC_GR_SM_ISSUE_RATE_MODIFIER smIssueRateModifier[LW2080_CTRL_INTERNAL_GR_MAX_ENGINES];
} LW2080_CTRL_INTERNAL_STATIC_GR_GET_SM_ISSUE_RATE_MODIFIER_PARAMS;

/*
 * LW2080_CTRL_INTERNAL_GPU_GET_CHIP_INFO_PARAMS
 *
 * This command obtains information from physical RM for use by CPU-RM.
 */

#define LW2080_CTRL_CMD_INTERNAL_GPU_GET_CHIP_INFO      (0x20800a36) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_GPU_GET_CHIP_INFO_PARAMS_MESSAGE_ID" */

/*
 * Maximum number of register bases to return.
 * These are indexed by LW_REG_BASE_* constants from gpu.h, and this value needs
 * to be updated if LW_REG_BASE_LAST ever goes over it. See the ct_assert() in gpu.h
 */
#define LW2080_CTRL_INTERNAL_GET_CHIP_INFO_REG_BASE_MAX 16
#define LW2080_CTRL_INTERNAL_GPU_GET_CHIP_INFO_PARAMS_MESSAGE_ID (0x36U)

typedef struct LW2080_CTRL_INTERNAL_GPU_GET_CHIP_INFO_PARAMS {
    LwU8   chipSubRev;
    LwU32  emulationRev1;
    LwBool isCmpSku;
    LwU32  bar1Size;
    LwU32  pciDeviceId;
    LwU32  pciSubDeviceId;
    LwU32  pciRevisionId;
    LwU32  regBases[LW2080_CTRL_INTERNAL_GET_CHIP_INFO_REG_BASE_MAX];
} LW2080_CTRL_INTERNAL_GPU_GET_CHIP_INFO_PARAMS;

/**
 * LW2080_CTRL_CMD_INTERNAL_GR_SET_FECS_TRACE_HW_ENABLE
 *
 * Set whether or not context switch logging is enabled
 *
 * bEnable
 *    Enable/Disable status for context switch logging
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_SET_FECS_TRACE_HW_ENABLE (0x20800a37) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_GR_SET_FECS_TRACE_HW_ENABLE_PARAMS_MESSAGE_ID" */

/**
 * LW2080_CTRL_CMD_INTERNAL_GR_GET_FECS_TRACE_HW_ENABLE
 *
 * Retrieve whether or not context switch logging is enabled
 *
 * bEnable
 *    Enable/Disable status for context switch logging
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_GET_FECS_TRACE_HW_ENABLE (0x20800a38) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_GR_GET_FECS_TRACE_HW_ENABLE_PARAMS_MESSAGE_ID" */

typedef struct LW2080_CTRL_INTERNAL_GR_FECS_TRACE_HW_ENABLE_PARAMS {
    LW_DECLARE_ALIGNED(LW2080_CTRL_GR_ROUTE_INFO grRouteInfo, 8);
    LwBool bEnable;
} LW2080_CTRL_INTERNAL_GR_FECS_TRACE_HW_ENABLE_PARAMS;
#define LW2080_CTRL_INTERNAL_GR_SET_FECS_TRACE_HW_ENABLE_PARAMS_MESSAGE_ID (0x37U)

typedef LW2080_CTRL_INTERNAL_GR_FECS_TRACE_HW_ENABLE_PARAMS LW2080_CTRL_INTERNAL_GR_SET_FECS_TRACE_HW_ENABLE_PARAMS;
#define LW2080_CTRL_INTERNAL_GR_GET_FECS_TRACE_HW_ENABLE_PARAMS_MESSAGE_ID (0x38U)

typedef LW2080_CTRL_INTERNAL_GR_FECS_TRACE_HW_ENABLE_PARAMS LW2080_CTRL_INTERNAL_GR_GET_FECS_TRACE_HW_ENABLE_PARAMS;

/**
 * LW2080_CTRL_CMD_INTERNAL_GR_SET_FECS_TRACE_RD_OFFSET
 *
 * Set read offset into FECS context switch trace record
 *
 * offset
 *   Value indicating number of records by which to offset
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_SET_FECS_TRACE_RD_OFFSET (0x20800a39) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_GR_SET_FECS_TRACE_RD_OFFSET_PARAMS_MESSAGE_ID" */

/**
 * LW2080_CTRL_CMD_INTERNAL_GR_SET_FECS_TRACE_WR_OFFSET
 *
 * Set write offset into FECS context switch trace record
 *
 * offset
 *   Value indicating number of records by which to offset
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_SET_FECS_TRACE_WR_OFFSET (0x20800a3a) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_GR_SET_FECS_TRACE_WR_OFFSET_PARAMS_MESSAGE_ID" */

/**
 * LW2080_CTRL_CMD_INTERNAL_GR_GET_FECS_TRACE_RD_OFFSET
 *
 * Get read offset into FECS context switch trace record
 *
 * offset
 *   Value indicating number of records by which to offset
 */

#define LW2080_CTRL_CMD_INTERNAL_GR_GET_FECS_TRACE_RD_OFFSET (0x20800a3b) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_GR_GET_FECS_TRACE_RD_OFFSET_PARAMS_MESSAGE_ID" */

typedef struct LW2080_CTRL_INTERNAL_GR_FECS_TRACE_OFFSET_PARAMS {
    LW_DECLARE_ALIGNED(LW2080_CTRL_GR_ROUTE_INFO grRouteInfo, 8);
    LwU32 offset;
} LW2080_CTRL_INTERNAL_GR_FECS_TRACE_OFFSET_PARAMS;

#define LW2080_CTRL_INTERNAL_GR_SET_FECS_TRACE_RD_OFFSET_PARAMS_MESSAGE_ID (0x39U)

typedef LW2080_CTRL_INTERNAL_GR_FECS_TRACE_OFFSET_PARAMS LW2080_CTRL_INTERNAL_GR_SET_FECS_TRACE_RD_OFFSET_PARAMS;
#define LW2080_CTRL_INTERNAL_GR_SET_FECS_TRACE_WR_OFFSET_PARAMS_MESSAGE_ID (0x3AU)

typedef LW2080_CTRL_INTERNAL_GR_FECS_TRACE_OFFSET_PARAMS LW2080_CTRL_INTERNAL_GR_SET_FECS_TRACE_WR_OFFSET_PARAMS;
#define LW2080_CTRL_INTERNAL_GR_GET_FECS_TRACE_RD_OFFSET_PARAMS_MESSAGE_ID (0x3BU)

typedef LW2080_CTRL_INTERNAL_GR_FECS_TRACE_OFFSET_PARAMS LW2080_CTRL_INTERNAL_GR_GET_FECS_TRACE_RD_OFFSET_PARAMS;

/**
 * LW2080_CTRL_CMD_INTERNAL_STATIC_GR_GET_FECS_RECORD_SIZE
 * LW2080_CTRL_CMD_INTERNAL_STATIC_KGR_GET_FECS_RECORD_SIZE
 *
 * Get size of FECS record
 *
 * fecsRecordSize
 *   Size of FECS record
 */
#if (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)

#define LW2080_CTRL_CMD_INTERNAL_STATIC_GR_GET_FECS_RECORD_SIZE  (0x20800a3c) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_STATIC_GR_GET_FECS_RECORD_SIZE_PARAMS_MESSAGE_ID" */
/* LWRM_UNPUBLISHED */
#endif // (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)



#define LW2080_CTRL_CMD_INTERNAL_STATIC_KGR_GET_FECS_RECORD_SIZE (0x20800a3d) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_CMD_INTERNAL_STATIC_KGR_GET_FECS_RECORD_SIZE_PARAMS_MESSAGE_ID" */

typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_GET_FECS_RECORD_SIZE {
    LwU32 fecsRecordSize;
} LW2080_CTRL_INTERNAL_STATIC_GR_GET_FECS_RECORD_SIZE;

#define LW2080_CTRL_INTERNAL_STATIC_GR_GET_FECS_RECORD_SIZE_PARAMS_MESSAGE_ID (0x3LW)

typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_GET_FECS_RECORD_SIZE_PARAMS {
    LW2080_CTRL_INTERNAL_STATIC_GR_GET_FECS_RECORD_SIZE fecsRecordSize[LW2080_CTRL_INTERNAL_GR_MAX_ENGINES];
} LW2080_CTRL_INTERNAL_STATIC_GR_GET_FECS_RECORD_SIZE_PARAMS;
#define LW2080_CTRL_CMD_INTERNAL_STATIC_KGR_GET_FECS_RECORD_SIZE_PARAMS_MESSAGE_ID (0x3DU)

typedef LW2080_CTRL_INTERNAL_STATIC_GR_GET_FECS_RECORD_SIZE_PARAMS LW2080_CTRL_CMD_INTERNAL_STATIC_KGR_GET_FECS_RECORD_SIZE_PARAMS;

/**
 * LW2080_CTRL_CMD_INTERNAL_STATIC_GR_GET_FECS_TRACE_DEFINES
 * LW2080_CTRL_CMD_INTERNAL_STATIC_KGR_GET_FECS_TRACE_DEFINES
 *
 * Get HW defines used to extract information from FECS records
 *
 * fecsRecordSize
 *  Size of FECS record
 *
 * timestampHiTagMask
 *  Mask for high bits of raw timestamp to extract tag
 *
 * timestampHiTagShift
 *  Shift for high bits of raw timestamp to extract tag
 *
 * timestampVMask
 *  Mask to extract timestamp from raw timestamp
 *
 * numLowerBitsZeroShift
 *  Number of bits timestamp is shifted by
 */
#if (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)

#define LW2080_CTRL_CMD_INTERNAL_STATIC_GR_GET_FECS_TRACE_DEFINES  (0x20800a3e) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x3E" */
/* LWRM_UNPUBLISHED */
#endif // (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)



#define LW2080_CTRL_CMD_INTERNAL_STATIC_KGR_GET_FECS_TRACE_DEFINES (0x20800a3f) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x3F" */

typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_GET_FECS_TRACE_DEFINES {
    LwU32 fecsRecordSize;
    LwU32 timestampHiTagMask;
    LwU8  timestampHiTagShift;
    LW_DECLARE_ALIGNED(LwU64 timestampVMask, 8);
    LwU8  numLowerBitsZeroShift;
} LW2080_CTRL_INTERNAL_STATIC_GR_GET_FECS_TRACE_DEFINES;

typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_GET_FECS_TRACE_DEFINES_PARAMS {
    LW_DECLARE_ALIGNED(LW2080_CTRL_INTERNAL_STATIC_GR_GET_FECS_TRACE_DEFINES fecsTraceDefines[LW2080_CTRL_INTERNAL_GR_MAX_ENGINES], 8);
} LW2080_CTRL_INTERNAL_STATIC_GR_GET_FECS_TRACE_DEFINES_PARAMS;

/**
 * LW2080_CTRL_CMD_INTERNAL_GET_DEVICE_INFO_TABLE
 * 
 * Parse the DEVICE_INFO2_TABLE on the physical side and return it to kernel.
 */
typedef struct LW2080_CTRL_INTERNAL_DEVICE_INFO {
    LwU32 faultId;
    LwU32 instanceId;
    LwU32 typeEnum;
    LwU32 resetId;
    LwU32 devicePriBase;
    LwU32 isEngine;
    LwU32 rlEngId;
    LwU32 runlistPriBase;
} LW2080_CTRL_INTERNAL_DEVICE_INFO;
#define LW2080_CTRL_CMD_INTERNAL_DEVICE_INFO_MAX_ENTRIES 88

#define LW2080_CTRL_CMD_INTERNAL_GET_DEVICE_INFO_TABLE   (0x20800a40) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_GET_DEVICE_INFO_TABLE_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_GET_DEVICE_INFO_TABLE_PARAMS_MESSAGE_ID (0x40U)

typedef struct LW2080_CTRL_INTERNAL_GET_DEVICE_INFO_TABLE_PARAMS {
    LwU32                            numEntries;
    LW2080_CTRL_INTERNAL_DEVICE_INFO deviceInfoTable[LW2080_CTRL_CMD_INTERNAL_DEVICE_INFO_MAX_ENTRIES];
} LW2080_CTRL_INTERNAL_GET_DEVICE_INFO_TABLE_PARAMS;

#define LW2080_CTRL_CMD_INTERNAL_GPU_GET_USER_REGISTER_ACCESS_MAP              (0x20800a41) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_GPU_GET_USER_REGISTER_ACCESS_MAP_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_GPU_USER_REGISTER_ACCESS_MAP_MAX_COMPRESSED_SIZE  4096
#define LW2080_CTRL_INTERNAL_GPU_USER_REGISTER_ACCESS_MAP_MAX_PROFILING_RANGES 4096

#define LW2080_CTRL_INTERNAL_GPU_GET_USER_REGISTER_ACCESS_MAP_PARAMS_MESSAGE_ID (0x41U)

typedef struct LW2080_CTRL_INTERNAL_GPU_GET_USER_REGISTER_ACCESS_MAP_PARAMS {
    LwU32 userRegisterAccessMapSize;
    LwU32 compressedSize;
    LwU8  compressedData[LW2080_CTRL_INTERNAL_GPU_USER_REGISTER_ACCESS_MAP_MAX_COMPRESSED_SIZE];
    LwU32 profilingRangesSize;
    LwU8  profilingRanges[LW2080_CTRL_INTERNAL_GPU_USER_REGISTER_ACCESS_MAP_MAX_PROFILING_RANGES];
} LW2080_CTRL_INTERNAL_GPU_GET_USER_REGISTER_ACCESS_MAP_PARAMS;

typedef struct LW2080_CTRL_INTERNAL_CONSTRUCTED_FALCON_INFO {
    LwU32 engDesc;
    LwU32 ctxAttr;
    LwU32 ctxBufferSize;
    LwU32 addrSpaceList;
    LwU32 registerBase;
} LW2080_CTRL_INTERNAL_CONSTRUCTED_FALCON_INFO;
#define LW2080_CTRL_CMD_INTERNAL_MAX_CONSTRUCTED_FALCONS     0x40

#define LW2080_CTRL_CMD_INTERNAL_GET_CONSTRUCTED_FALCON_INFO (0x20800a42) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_GET_CONSTRUCTED_FALCON_INFO_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_GET_CONSTRUCTED_FALCON_INFO_PARAMS_MESSAGE_ID (0x42U)

typedef struct LW2080_CTRL_INTERNAL_GET_CONSTRUCTED_FALCON_INFO_PARAMS {
    LwU32                                        numConstructedFalcons;
    LW2080_CTRL_INTERNAL_CONSTRUCTED_FALCON_INFO constructedFalconsTable[LW2080_CTRL_CMD_INTERNAL_MAX_CONSTRUCTED_FALCONS];
} LW2080_CTRL_INTERNAL_GET_CONSTRUCTED_FALCON_INFO_PARAMS;

/**
 * Get GR PDB properties synchronized between Kernel and Physical
 *
 * bPerSubCtxheaderSupported
 *   @ref PDB_PROP_GR_SUPPORTS_PER_SUBCONTEXT_CONTEXT_HEADER
 */
#if (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)

#define LW2080_CTRL_CMD_INTERNAL_STATIC_GR_GET_PDB_PROPERTIES  (0x20800a47) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x47" */
/* LWRM_UNPUBLISHED */
#endif // (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)



#define LW2080_CTRL_CMD_INTERNAL_STATIC_KGR_GET_PDB_PROPERTIES (0x20800a48) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x48" */

typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_PDB_PROPERTIES {
    LwBool bPerSubCtxheaderSupported;
} LW2080_CTRL_INTERNAL_STATIC_GR_PDB_PROPERTIES;

typedef struct LW2080_CTRL_INTERNAL_STATIC_GR_GET_PDB_PROPERTIES_PARAMS {
    LW2080_CTRL_INTERNAL_STATIC_GR_PDB_PROPERTIES pdbTable[LW2080_CTRL_INTERNAL_GR_MAX_ENGINES];
} LW2080_CTRL_INTERNAL_STATIC_GR_GET_PDB_PROPERTIES_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_DISPLAY_WRITE_INST_MEM
 *
 *   This command writes instance memory information in the display hardware registers.
 *
 *   instMemPhysAddr
 *     GPU physical address or IOVA address of the display instance memory.
 *
 *   instMemSize
 *     Size of the display instance memory.
 *
 *   instMemAddrSpace
 *     Address space of the display instance memory.
 *
 *   instMemCpuCacheAttr
 *     Cache attribute of the display instance memory.
 */
#define LW2080_CTRL_CMD_INTERNAL_DISPLAY_WRITE_INST_MEM (0x20800a49) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_DISPLAY_WRITE_INST_MEM_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_DISPLAY_WRITE_INST_MEM_PARAMS_MESSAGE_ID (0x49U)

typedef struct LW2080_CTRL_INTERNAL_DISPLAY_WRITE_INST_MEM_PARAMS {
    LW_DECLARE_ALIGNED(LwU64 instMemPhysAddr, 8);
    LW_DECLARE_ALIGNED(LwU64 instMemSize, 8);
    LwU32 instMemAddrSpace;
    LwU32 instMemCpuCacheAttr;
} LW2080_CTRL_INTERNAL_DISPLAY_WRITE_INST_MEM_PARAMS;

/*
 * LW2080_CTRL_INTERNAL_GPU_RECOVER_ALL_COMPUTE_CONTEXTS
 *
 * This command issues RC recovery for all compute contexts running on the given GPU.
 */
#define LW2080_CTRL_CMD_INTERNAL_RECOVER_ALL_COMPUTE_CONTEXTS (0x20800a4a) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x4A" */

/*!
 * LW2080_CTRL_CMD_INTERNAL_DISPLAY_GET_IP_VERSION
 *
 *    This command obtains IP version of display engine for use by Kernel RM.
 *
 *   ipVersion
 *     IP Version of display engine.
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_NOT_SUPPORTED - DISP has been disabled
 */
#define LW2080_CTRL_CMD_INTERNAL_DISPLAY_GET_IP_VERSION       (0x20800a4b) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_DISPLAY_GET_IP_VERSION_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_DISPLAY_GET_IP_VERSION_PARAMS_MESSAGE_ID (0x4BU)

typedef struct LW2080_CTRL_INTERNAL_DISPLAY_GET_IP_VERSION_PARAMS {
    LwU32 ipVersion;
} LW2080_CTRL_INTERNAL_DISPLAY_GET_IP_VERSION_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_GPU_GET_SMC_MODE
 *
 *  This command determines the current status of MIG MODE from Physical RM.
 *
 *  smcMode [OUT]
 *     Current MIG MODE of the GPU. Values range LW2080_CTRL_GPU_INFO_GPU_SMC_MODE*
 */
#define LW2080_CTRL_CMD_INTERNAL_GPU_GET_SMC_MODE (0x20800a4c) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_GPU_GET_SMC_MODE_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_GPU_GET_SMC_MODE_PARAMS_MESSAGE_ID (0x4LW)

typedef struct LW2080_CTRL_INTERNAL_GPU_GET_SMC_MODE_PARAMS {
    LwU32 smcMode;
} LW2080_CTRL_INTERNAL_GPU_GET_SMC_MODE_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_DISPLAY_SETUP_RG_LINE_INTR
 *
 *   head
 *     This parameter specifies the head for which the callback is to be registered/unregistered. This value must be
 *     less than the maximum number of heads supported by the GPU subdevice.
 *
 *   rgLineNum
 *     This indicates the RG scanout line number on which the callback will be exelwted.
 *
 *   intrLine
 *     Enable: [out] Which interrupt line was allocated for this head.
 *     Disable: [in] Which interrupt line to deallocate.
 *
 *   bEnable
 *     Should we allocate or deallocate an interrupt line?
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_GENERIC - There was no available interrupt to allocate.
 *   LW_ERR_ILWALID_ARGUMENT
 */

#define LW2080_CTRL_CMD_INTERNAL_DISPLAY_SETUP_RG_LINE_INTR (0x20800a4d) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_DISPLAY_SETUP_RG_LINE_INTR_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_DISPLAY_SETUP_RG_LINE_INTR_PARAMS_MESSAGE_ID (0x4DU)

typedef struct LW2080_CTRL_INTERNAL_DISPLAY_SETUP_RG_LINE_INTR_PARAMS {
    LwU32  head;
    LwU32  rgLineNum;
    LwU32  intrLine;
    LwBool bEnable;
} LW2080_CTRL_INTERNAL_DISPLAY_SETUP_RG_LINE_INTR_PARAMS;

#if (!defined(LWRM_PUBLISHED_PENDING_IP_REVIEW) || LWRM_PUBLISHED_PENDING_IP_REVIEW == 1)


/*!
 * LW2080_CTRL_INTERNAL_MIGMGR_PROFILE_INFO
 *
 * Description of a supported GPU instance.
 *
 *   partitionFlag [OUT]
 *     Allocation flag to be used to allocate a partition with this profile.
 *
 *   grCount [OUT]
 *     # GR engines
 *
 *   gpcCount [OUT]
 *     # total gpcs
 *
 *   veidCount [OUT]
 *     # total veids
 *
 *   smCount [OUT]
 *     # total SMs
 *
 *   ceCount [OUT]
 *     # CE engines
 *
 *   lwEncCount [OUT]
 *     # LWENC engines
 *
 *   lwDecCount [OUT]
 *     # LWDEC engines
 *
 *   lwJpgCount [OUT]
 *     # LWJPG engines
 *
 *   lwOfaCount [OUT]
 *     # LWOFA engines
 */
#define LW2080_CTRL_INTERNAL_GRMGR_PARTITION_MAX_TYPES      10
#define LW2080_CTRL_CMD_INTERNAL_STATIC_MIGMGR_GET_PROFILES (0x20800a4f) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x4F" */

typedef struct LW2080_CTRL_INTERNAL_MIGMGR_PROFILE_INFO {
    LwU32 partitionFlag;
    LwU32 grCount;
    LwU32 gpcCount;
    LwU32 veidCount;
    LwU32 smCount;
    LwU32 ceCount;
    LwU32 lwEncCount;
    LwU32 lwDecCount;
    LwU32 lwJpgCount;
    LwU32 lwOfaCount;
} LW2080_CTRL_INTERNAL_MIGMGR_PROFILE_INFO;

/*!
 * LW2080_CTRL_INTERNAL_STATIC_MIGMGR_GET_PROFILES_PARAMS
 *
 * Returns the list of supported GPU instance profiles.
 *
 *   count [OUT]
 *     Number of supported profiles.
 *
 *   table [OUT]
 *     Supported profiles.
 */
typedef struct LW2080_CTRL_INTERNAL_STATIC_MIGMGR_GET_PROFILES_PARAMS {
    LwU32                                    count;
    LW2080_CTRL_INTERNAL_MIGMGR_PROFILE_INFO table[LW2080_CTRL_INTERNAL_GRMGR_PARTITION_MAX_TYPES];
} LW2080_CTRL_INTERNAL_STATIC_MIGMGR_GET_PROFILES_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_MEMSYS_SET_PARTITIONABLE_MEM
 *
 *  This command instructs the physical MemorySystem to set up memory partitioning
 *  exterior boundaries in hardware.
 *
 *  partitionableMemSize [input]
 *      Size of the partitionable memory in bytes
 *
 *  bottomRsvdSize [input]
 *      Size of the reserved region below partitionable memory in bytes
 *
 *  topRsvdSize [input]
 *      Size of the reserved region above partitionable memory in bytes
 *
 *  partitionableStartAddr [output]
 *      Start address of the partitionable memory, aligned to HW constraints
 *
 *  partitionableEndAddr [output]
 *      End address of the partitionable memory, aligned to HW constraints
 */
#define LW2080_CTRL_CMD_INTERNAL_MEMSYS_SET_PARTITIONABLE_MEM (0x20800a51) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_MEMSYS_SET_PARTITIONABLE_MEM_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_MEMSYS_SET_PARTITIONABLE_MEM_PARAMS_MESSAGE_ID (0x51U)

typedef struct LW2080_CTRL_INTERNAL_MEMSYS_SET_PARTITIONABLE_MEM_PARAMS {
    LW_DECLARE_ALIGNED(LwU64 partitionableMemSize, 8);
    LW_DECLARE_ALIGNED(LwU64 bottomRsvdSize, 8);
    LW_DECLARE_ALIGNED(LwU64 topRsvdSize, 8);
    LW_DECLARE_ALIGNED(LwU64 partitionableStartAddr, 8);
    LW_DECLARE_ALIGNED(LwU64 partitionableEndAddr, 8);
} LW2080_CTRL_INTERNAL_MEMSYS_SET_PARTITIONABLE_MEM_PARAMS;

/*!
 * LW2080_CTRL_INTERNAL_STATIC_MIGMGR_GET_PARTITIONABLE_ENGINES_PARAMS
 *
 *   engineMask [OUT]
 *      Returns mask of partitionable engine types (see LW2080_ENGINE_TYPE_*)
 */
#define LW2080_CTRL_CMD_INTERNAL_STATIC_MIGMGR_GET_PARTITIONABLE_ENGINES (0x20800a52) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x52" */

typedef struct LW2080_CTRL_INTERNAL_STATIC_MIGMGR_GET_PARTITIONABLE_ENGINES_PARAMS {
    LW_DECLARE_ALIGNED(LwU64 engineMask, 8);
} LW2080_CTRL_INTERNAL_STATIC_MIGMGR_GET_PARTITIONABLE_ENGINES_PARAMS;

/*!
 * LW2080_CTRL_INTERNAL_MEMDESC_INFO
 *
 * A generic container structure representing a memory region to be used as a
 * component of other control call parameters.
 *
 */
typedef struct LW2080_CTRL_INTERNAL_MEMDESC_INFO {
    LW_DECLARE_ALIGNED(LwU64 base, 8);
    LW_DECLARE_ALIGNED(LwU64 size, 8);
    LW_DECLARE_ALIGNED(LwU64 alignment, 8);
    LwU32 addressSpace;
    LwU32 cpuCacheAttrib;
} LW2080_CTRL_INTERNAL_MEMDESC_INFO;

#define LW2080_CTRL_INTERNAL_FIFO_MAX_RUNLIST_BUFFERS         2
#define LW2080_CTRL_INTERNAL_FIFO_MAX_RUNLIST_ID              64
/*!
 * LW2080_CTRL_INTERNAL_FIFO_PROMOTE_RUNLIST_BUFFERS_PARAMS
 *
 * Promote a single partition's runlist buffers allocated by kernel Client RM to Physical RM
 *
 *   rlBuffers [IN]
 *     2D array of runlist buffers for a single partition
 *
 *   runlistIdMask [IN]
 *     Mask of runlists belonging to partition
 *
 */
#define LW2080_CTRL_CMD_INTERNAL_FIFO_PROMOTE_RUNLIST_BUFFERS (0x20800a53) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_FIFO_PROMOTE_RUNLIST_BUFFERS_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_FIFO_PROMOTE_RUNLIST_BUFFERS_PARAMS_MESSAGE_ID (0x53U)

typedef struct LW2080_CTRL_INTERNAL_FIFO_PROMOTE_RUNLIST_BUFFERS_PARAMS {
    LW_DECLARE_ALIGNED(LW2080_CTRL_INTERNAL_MEMDESC_INFO rlBuffers[LW2080_CTRL_INTERNAL_FIFO_MAX_RUNLIST_ID][LW2080_CTRL_INTERNAL_FIFO_MAX_RUNLIST_BUFFERS], 8);
    LW_DECLARE_ALIGNED(LwU64 runlistIdMask, 8);
    LwU32 swizzId;
} LW2080_CTRL_INTERNAL_FIFO_PROMOTE_RUNLIST_BUFFERS_PARAMS;

/* LWRM_PUBLISHED_PENDING_IP_REVIEW */
#endif // (!defined(LWRM_PUBLISHED_PENDING_IP_REVIEW) || LWRM_PUBLISHED_PENDING_IP_REVIEW == 1)



#define LW2080_CTRL_CMD_INTERNAL_DISPLAY_SET_IMP_INIT_INFO (0x20800a54) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_DISPLAY_SET_IMP_INIT_INFO_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_DISPLAY_SET_IMP_INIT_INFO_PARAMS_MESSAGE_ID (0x54U)

typedef struct LW2080_CTRL_INTERNAL_DISPLAY_SET_IMP_INIT_INFO_PARAMS {
    TEGRA_IMP_IMPORT_DATA tegraImpImportData;
} LW2080_CTRL_INTERNAL_DISPLAY_SET_IMP_INIT_INFO_PARAMS;

#if (!defined(LWRM_PUBLISHED_PENDING_IP_REVIEW) || LWRM_PUBLISHED_PENDING_IP_REVIEW == 1)


/*!
 * LW2080_CTRL_CMD_INTERNAL_BUS_BIND_LOCAL_GFID_FOR_P2P
 *
 * Binds local GFID for SR-IOV P2P requests
 *
 *   localGfid [IN]
 *     GFID to bind in the P2P source GPU
 *
 *   peerId [IN]
 *     Peer ID of the P2P destination GPU
 */
#define LW2080_CTRL_CMD_INTERNAL_BUS_BIND_LOCAL_GFID_FOR_P2P (0x20800a55) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_BUS_BIND_LOCAL_GFID_FOR_P2P_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_BUS_BIND_LOCAL_GFID_FOR_P2P_PARAMS_MESSAGE_ID (0x55U)

typedef struct LW2080_CTRL_INTERNAL_BUS_BIND_LOCAL_GFID_FOR_P2P_PARAMS {
    LwU32 localGfid;
    LwU32 peerId;
} LW2080_CTRL_INTERNAL_BUS_BIND_LOCAL_GFID_FOR_P2P_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_BUS_BIND_REMOTE_GFID_FOR_P2P
 *
 * Binds remote GFID for SR-IOV P2P requests
 *
 *   remoteGfid [IN]
 *     GFID to bind in the P2P destination GPU
 */
#define LW2080_CTRL_CMD_INTERNAL_BUS_BIND_REMOTE_GFID_FOR_P2P (0x20800a56) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_BUS_BIND_REMOTE_GFID_FOR_P2P_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_BUS_BIND_REMOTE_GFID_FOR_P2P_PARAMS_MESSAGE_ID (0x56U)

typedef struct LW2080_CTRL_INTERNAL_BUS_BIND_REMOTE_GFID_FOR_P2P_PARAMS {
    LwU32 remoteGfid;
} LW2080_CTRL_INTERNAL_BUS_BIND_REMOTE_GFID_FOR_P2P_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_BUS_FLUSH_WITH_SYSMEMBAR
 *
 * This command triggers a sysmembar to flush VIDMEM writes.
 * This command accepts no parameters.
 *
 */
#define LW2080_CTRL_CMD_INTERNAL_BUS_FLUSH_WITH_SYSMEMBAR    (0x20800a70) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x70" */

/*
 * LW2080_CTRL_CMD_INTERNAL_BUS_SETUP_P2P_MAILBOX_LOCAL
 *
 * Setup local PCIE P2P Mailbox
 *
 * local2Remote[IN]
 *   Local peer ID of remote gpu on local gpu
 *
 * remote2Local[IN]
 *   Remote peer ID of local gpu on remote gpu
 *
 * localP2PDomainRemoteAddr[IN]
 *   P2P domain remote address on local gpu
 *
 * remoteP2PDomainLocalAddr[IN]
 *   P2P domain local address on remote gpu
 *
 * remoteWMBoxLocalAddr[IN]
 *   Local mailbox address on remote gpu
 *
 * p2pWmbTag[OUT]
 *   Tag for mailbox to transport from local to remote GPU
 *
 * bNeedWarBug999673[IN]
 *   Set to true if WAR for bug 999673 is required
 *
 * Possible status values returned are:
 *  LW_OK
 *  LW_ERR_NOT_SUPPORTED
 */
#define LW2080_CTRL_CMD_INTERNAL_BUS_SETUP_P2P_MAILBOX_LOCAL (0x20800a71) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_CMD_INTERNAL_BUS_SETUP_P2P_MAILBOX_LOCAL_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_CMD_INTERNAL_BUS_SETUP_P2P_MAILBOX_LOCAL_PARAMS_MESSAGE_ID (0x71U)

typedef struct LW2080_CTRL_CMD_INTERNAL_BUS_SETUP_P2P_MAILBOX_LOCAL_PARAMS {
    LwU32  local2Remote;
    LwU32  remote2Local;
    LW_DECLARE_ALIGNED(LwU64 localP2PDomainRemoteAddr, 8);
    LW_DECLARE_ALIGNED(LwU64 remoteP2PDomainLocalAddr, 8);
    LW_DECLARE_ALIGNED(LwU64 remoteWMBoxLocalAddr, 8);
    LW_DECLARE_ALIGNED(LwU64 p2pWmbTag, 8);
    LwBool bNeedWarBug999673;
} LW2080_CTRL_CMD_INTERNAL_BUS_SETUP_P2P_MAILBOX_LOCAL_PARAMS;

 /*
 * LW2080_CTRL_CMD_INTERNAL_BUS_SETUP_P2P_MAILBOX_REMOTE
 *
 * Setup remote PCIE P2P Mailbox
 *
 * local2Remote[IN]
 *   Local peer ID of remote gpu on local gpu
 *
 * remote2Local[IN]
 *   Remote peer ID of local gpu on remote gpu
 *
 * localP2PDomainRemoteAddr[IN]
 *   P2P domain remote address on local gpu
 *
 * remoteP2PDomainLocalAddr[IN]
 *   P2P domain local address on remote gpu
 *
 * remoteWMBoxAddrU64[IN]
 *   Mailbox address on remote gpu
 *
 * p2pWmbTag[IN]
 *   Tag for mailbox to transport from local to remote GPU
 *
 * Possible status values returned are:
 *  LW_OK
 *  LW_ERR_NOT_SUPPORTED
 */
#define LW2080_CTRL_CMD_INTERNAL_BUS_SETUP_P2P_MAILBOX_REMOTE (0x20800a72) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_CMD_INTERNAL_BUS_SETUP_P2P_MAILBOX_REMOTE_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_CMD_INTERNAL_BUS_SETUP_P2P_MAILBOX_REMOTE_PARAMS_MESSAGE_ID (0x72U)

typedef struct LW2080_CTRL_CMD_INTERNAL_BUS_SETUP_P2P_MAILBOX_REMOTE_PARAMS {
    LwU32 local2Remote;
    LwU32 remote2Local;
    LW_DECLARE_ALIGNED(LwU64 localP2PDomainRemoteAddr, 8);
    LW_DECLARE_ALIGNED(LwU64 remoteP2PDomainLocalAddr, 8);
    LW_DECLARE_ALIGNED(LwU64 remoteWMBoxAddrU64, 8);
    LW_DECLARE_ALIGNED(LwU64 p2pWmbTag, 8);
} LW2080_CTRL_CMD_INTERNAL_BUS_SETUP_P2P_MAILBOX_REMOTE_PARAMS;

/*
 * LW2080_CTRL_CMD_INTERNAL_BUS_DESTROY_P2P_MAILBOX
 *
 * Destroy PCIE P2P Mailbox
 *
 * peerIdx[IN]
 *   Peer ID of the P2P destination GPU
 *
 * bNeedWarBug999673[IN]
 *   Set to true if WAR for bug 999673 is required
 *
 * Possible status values returned are:
 *  LW_OK
 *  LW_ERR_NOT_SUPPORTED
 */
#define LW2080_CTRL_CMD_INTERNAL_BUS_DESTROY_P2P_MAILBOX (0x20800a73) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_BUS_DESTROY_P2P_MAILBOX_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_BUS_DESTROY_P2P_MAILBOX_PARAMS_MESSAGE_ID (0x73U)

typedef struct LW2080_CTRL_INTERNAL_BUS_DESTROY_P2P_MAILBOX_PARAMS {
    LwU32  peerIdx;
    LwBool bNeedWarBug999673;
} LW2080_CTRL_INTERNAL_BUS_DESTROY_P2P_MAILBOX_PARAMS;

/*
 * LW2080_CTRL_CMD_INTERNAL_BUS_CREATE_C2C_PEER_MAPPING
 *
 * Create C2C mapping to a given peer GPU
 *
 * peerId[IN]
 *   Peer ID for local to remote GPU
 *
 * Possible status values returned are:
 *  LW_OK
 *  LW_ERR_NOT_SUPPORTED
 */
#define LW2080_CTRL_CMD_INTERNAL_BUS_CREATE_C2C_PEER_MAPPING (0x20800a74) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_BUS_CREATE_C2C_PEER_MAPPING_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_BUS_CREATE_C2C_PEER_MAPPING_PARAMS_MESSAGE_ID (0x74U)

typedef struct LW2080_CTRL_INTERNAL_BUS_CREATE_C2C_PEER_MAPPING_PARAMS {
    LwU32 peerId;
} LW2080_CTRL_INTERNAL_BUS_CREATE_C2C_PEER_MAPPING_PARAMS;

/*
 * LW2080_CTRL_CMD_INTERNAL_BUS_REMOVE_C2C_PEER_MAPPING
 *
 * Remove C2C mapping to a given peer GPU
 *
 * peerId[IN]
 *   Peer ID for local to remote GPU
 *
 * Possible status values returned are:
 *  LW_OK
 *  LW_ERR_NOT_SUPPORTED
 */
#define LW2080_CTRL_CMD_INTERNAL_BUS_REMOVE_C2C_PEER_MAPPING (0x20800a75) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_BUS_REMOVE_C2C_PEER_MAPPING_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_BUS_REMOVE_C2C_PEER_MAPPING_PARAMS_MESSAGE_ID (0x75U)

typedef struct LW2080_CTRL_INTERNAL_BUS_REMOVE_C2C_PEER_MAPPING_PARAMS {
    LwU32 peerId;
} LW2080_CTRL_INTERNAL_BUS_REMOVE_C2C_PEER_MAPPING_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_VMMU_GET_SPA_FOR_GPA_ENTRIES
 *
 * Retrieves the corresponding SPAs (per the given GFID's VMMU mappings)
 * for the given array of GPAs.
 *
 *   gfid [IN]
 *     GFID to translate GPAs for
 *
 *   numEntries [IN]
 *     Number of entries (<= LW2080_CTRL_CMD_INTERNAL_VMMU_GET_SPA_FOR_GPA_ENTRIES)
 *     to translate (i.e. number of elements in gpaEntries)
 *
 *   gpaEntries [IN]
 *     Array of GPAs to translate
 *
 *   spaEntries [OUT]
 *     Resulting array of SPAs
 */
#define LW2080_CTRL_CMD_INTERNAL_VMMU_GET_SPA_FOR_GPA_ENTRIES (0x20800a57) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_VMMU_GET_SPA_FOR_GPA_ENTRIES_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_VMMU_MAX_SPA_FOR_GPA_ENTRIES     128

#define LW2080_CTRL_INTERNAL_VMMU_GET_SPA_FOR_GPA_ENTRIES_PARAMS_MESSAGE_ID (0x57U)

typedef struct LW2080_CTRL_INTERNAL_VMMU_GET_SPA_FOR_GPA_ENTRIES_PARAMS {
    LwU32 gfid;
    LwU32 numEntries;
    LW_DECLARE_ALIGNED(LwU64 gpaEntries[LW2080_CTRL_INTERNAL_VMMU_MAX_SPA_FOR_GPA_ENTRIES], 8);
    LW_DECLARE_ALIGNED(LwU64 spaEntries[LW2080_CTRL_INTERNAL_VMMU_MAX_SPA_FOR_GPA_ENTRIES], 8);
} LW2080_CTRL_INTERNAL_VMMU_GET_SPA_FOR_GPA_ENTRIES_PARAMS;
/* LWRM_PUBLISHED_PENDING_IP_REVIEW */
#endif // (!defined(LWRM_PUBLISHED_PENDING_IP_REVIEW) || LWRM_PUBLISHED_PENDING_IP_REVIEW == 1)



/*!
 * LW2080_CTRL_CMD_INTERNAL_DISPLAY_CHANNEL_PUSHBUFFER
 *
 * Pass required pushbuffer parameters from kernel RM to Physical RM
 *
 *   addressSpace [IN]
 *     Address space of pushbuffer whtether it is ADDR_SYSMEM or ADDR_FBMEM
 *
 *   physicalAddr [IN]
 *     Physical address of pushbuffer
 *
 *   addressSpace [IN]
 *     Limit of the pushbuffer address, it should be less than 4K
 *
 *   cacheSnoop [IN]
 *     Cachesnoop supported or not
 *
 *   channelInstance [IN]
 *     Channel instance pass by the client to get corresponding dispchannel
 *
 *   hclass [IN]
 *     External class ID pass by the client to get the channel class
 *
 *   valid [IN]
 *     This bit indicates whether pushbuffer parameters are valid or not
 *
 */
#define LW2080_CTRL_CMD_INTERNAL_DISPLAY_CHANNEL_PUSHBUFFER (0x20800a58) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_DISPLAY_CHANNEL_PUSHBUFFER_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_DISPLAY_CHANNEL_PUSHBUFFER_PARAMS_MESSAGE_ID (0x58U)

typedef struct LW2080_CTRL_INTERNAL_DISPLAY_CHANNEL_PUSHBUFFER_PARAMS {
    LwU32  addressSpace;
    LW_DECLARE_ALIGNED(LwU64 physicalAddr, 8);
    LW_DECLARE_ALIGNED(LwU64 limit, 8);
    LwU32  cacheSnoop;
    LwU32  hclass;
    LwU32  channelInstance;
    LwBool valid;
} LW2080_CTRL_INTERNAL_DISPLAY_CHANNEL_PUSHBUFFER_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_GMMU_GET_STATIC_INFO
 *
 *   This command obtains information from physical RM for use by CPU-RM.
 *
 *   replayableFaultBufferSize
 *     Default size of replayable fault buffer
 *
 *   nonReplayableFaultBufferSize
 *     Default size of non-replayable fault buffer
 *
 */

#define LW2080_CTRL_CMD_INTERNAL_GMMU_GET_STATIC_INFO (0x20800a59) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_GMMU_GET_STATIC_INFO_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_GMMU_GET_STATIC_INFO_PARAMS_MESSAGE_ID (0x59U)

typedef struct LW2080_CTRL_INTERNAL_GMMU_GET_STATIC_INFO_PARAMS {
    LwU32 replayableFaultBufferSize;
    LwU32 nonReplayableFaultBufferSize;
} LW2080_CTRL_INTERNAL_GMMU_GET_STATIC_INFO_PARAMS;

/*!
 * @ref LW2080_CTRL_CMD_GR_GET_CTXSW_MODES
 */
#define LW2080_CTRL_CMD_INTERNAL_GR_GET_CTXSW_MODES           (0x20800a5a) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x5A" */

/*!
 * LW2080_CTRL_CMD_INTERNAL_FB_GET_HEAP_RESERVATION_SIZE
 *
 * Get heap reservation size needed by different module
 */
#define LW2080_CTRL_CMD_INTERNAL_FB_GET_HEAP_RESERVATION_SIZE (0x20800a5b) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_FB_GET_HEAP_RESERVATION_SIZE_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_FB_GET_HEAP_RESERVATION_SIZE_PARAMS_MESSAGE_ID (0x5BU)

typedef struct LW2080_CTRL_INTERNAL_FB_GET_HEAP_RESERVATION_SIZE_PARAMS {
    LwU32 moduleIndex;
    LwU32 size;
} LW2080_CTRL_INTERNAL_FB_GET_HEAP_RESERVATION_SIZE_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_INTR_GET_KERNEL_TABLE
 *
 *   tableLen [OUT]
 *     Number of valid records in table field.
 *
 *   table    [OUT]
 *     Interrupt table for Kernel RM.
 */
#define LW2080_CTRL_CMD_INTERNAL_INTR_GET_KERNEL_TABLE (0x20800a5c) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_INTR_GET_KERNEL_TABLE_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_INTR_MAX_TABLE_SIZE       128

typedef struct LW2080_CTRL_INTERNAL_INTR_GET_KERNEL_TABLE_ENTRY {
    LwU16 engineIdx;
    LwU32 pmcIntrMask;
    LwU32 vectorStall;
    LwU32 vectorNonStall;
} LW2080_CTRL_INTERNAL_INTR_GET_KERNEL_TABLE_ENTRY;

#define LW2080_CTRL_INTERNAL_INTR_GET_KERNEL_TABLE_PARAMS_MESSAGE_ID (0x5LW)

typedef struct LW2080_CTRL_INTERNAL_INTR_GET_KERNEL_TABLE_PARAMS {
    LwU32                                            tableLen;
    LW2080_CTRL_INTERNAL_INTR_GET_KERNEL_TABLE_ENTRY table[LW2080_CTRL_INTERNAL_INTR_MAX_TABLE_SIZE];
} LW2080_CTRL_INTERNAL_INTR_GET_KERNEL_TABLE_PARAMS;

/* Index to retrieve the needed heap space for specific module */
#define LW2080_CTRL_INTERNAL_FB_GET_HEAP_RESERVATION_SIZE_GR           (0x00000000)

/*
 * LW2080_CTRL_CMD_INTERNAL_PERF_PERFMON_CLIENT_RESERVATION_CHECK
 *
 * Checking if the reservation / release of the PERFMON HW is possible
 *
 *   bReservation [IN]
 *     LW_TRUE -> request for reservation, LW_FALSE -> request for release
 *
 */
#define LW2080_CTRL_CMD_INTERNAL_PERF_PERFMON_CLIENT_RESERVATION_CHECK (0x20800a98) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_PERF_PERFMON_CLIENT_RESERVATION_CHECK_PARAMS_MESSAGE_ID" */


#define LW2080_CTRL_INTERNAL_PERF_PERFMON_CLIENT_RESERVATION_CHECK_PARAMS_MESSAGE_ID (0x98U)

typedef struct LW2080_CTRL_INTERNAL_PERF_PERFMON_CLIENT_RESERVATION_CHECK_PARAMS {
    LwBool bReservation;
} LW2080_CTRL_INTERNAL_PERF_PERFMON_CLIENT_RESERVATION_CHECK_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_PERF_PERFMON_CLIENT_RESERVATION_SET
 *
 * Reserving / Releasing PERFMON HW
 *
 *   bReservation [IN]
 *     LW_TRUE -> request for reservation, LW_FALSE -> request for release
 *
 *   bClientHandlesGrGating [IN]
 *     DM-TODO: Add comment for this
 *
 *   bRmHandlesIdleSlow [IN]
 *     If the IDLE slowdown is required
 *
 */
#define LW2080_CTRL_CMD_INTERNAL_PERF_PERFMON_CLIENT_RESERVATION_SET (0x20800a99) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_PERF_PERFMON_CLIENT_RESERVATION_SET_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_PERF_PERFMON_CLIENT_RESERVATION_SET_PARAMS_MESSAGE_ID (0x99U)

typedef struct LW2080_CTRL_INTERNAL_PERF_PERFMON_CLIENT_RESERVATION_SET_PARAMS {
    LwBool bReservation;
    LwBool bClientHandlesGrGating;
    LwBool bRmHandlesIdleSlow;
} LW2080_CTRL_INTERNAL_PERF_PERFMON_CLIENT_RESERVATION_SET_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_DISPLAY_GET_ACTIVE_DISPLAY_DEVICES
 *
 * Get active display devices
 *
 *   displayMask [OUT]
 *     Get the mask of the active display devices in VBIOS
 *
 *   numHeads [OUT]
 *     Number of heads display supported.
 *
 */
#define LW2080_CTRL_CMD_INTERNAL_DISPLAY_GET_ACTIVE_DISPLAY_DEVICES (0x20800a5d) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_DISPLAY_GET_ACTIVE_DISPLAY_DEVICES_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_DISPLAY_GET_ACTIVE_DISPLAY_DEVICES_PARAMS_MESSAGE_ID (0x5DU)

typedef struct LW2080_CTRL_INTERNAL_DISPLAY_GET_ACTIVE_DISPLAY_DEVICES_PARAMS {

    LwU32 displayMask;
    LwU32 numHeads;
} LW2080_CTRL_INTERNAL_DISPLAY_GET_ACTIVE_DISPLAY_DEVICES_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_FIFO_UPDATE_CHANNEL_INFO
 *
 * This command is an internal command sent from Kernel RM to Physical RM
 * to update the channel info params for an existing channel
 *
 * Please see description of LW2080_CTRL_CMD_FIFO_UPDATE_CHANNEL_INFO for more information.

 *   params [IN]
 *      Same input params as used for LW2080_CTRL_CMD_FIFO_UPDATE_CHANNEL_INFO
 */
#define LW2080_CTRL_CMD_INTERNAL_FIFO_UPDATE_CHANNEL_INFO                      (0x20800a5e) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x5E" */

/*
 * LW2080_CTRL_INTERNAL_STATIC_MIGMGR_GET_SWIZZ_ID_FB_MEM_PAGE_RANGES
 *
 * Get FB Mem page ranges for all possible swizzIds
 *
 *   fbMemPageRanges [OUT]
 *      Mem page ranges for each swizzId in the form of {lo, hi}
 */
#define LW2080_CTRL_CMD_INTERNAL_STATIC_MIGMGR_GET_SWIZZ_ID_FB_MEM_PAGE_RANGES (0x20800a60) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_STATIC_MIGMGR_GET_SWIZZ_ID_FB_MEM_PAGE_RANGES_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_MAX_SWIZZ_ID                                      15

typedef struct LW2080_CTRL_INTERNAL_LW_RANGE {
    LW_DECLARE_ALIGNED(LwU64 lo, 8);
    LW_DECLARE_ALIGNED(LwU64 hi, 8);
} LW2080_CTRL_INTERNAL_LW_RANGE;

#define LW2080_CTRL_INTERNAL_STATIC_MIGMGR_GET_SWIZZ_ID_FB_MEM_PAGE_RANGES_PARAMS_MESSAGE_ID (0x60U)

typedef struct LW2080_CTRL_INTERNAL_STATIC_MIGMGR_GET_SWIZZ_ID_FB_MEM_PAGE_RANGES_PARAMS {
    LW_DECLARE_ALIGNED(LW2080_CTRL_INTERNAL_LW_RANGE fbMemPageRanges[LW2080_CTRL_INTERNAL_MAX_SWIZZ_ID], 8);
} LW2080_CTRL_INTERNAL_STATIC_MIGMGR_GET_SWIZZ_ID_FB_MEM_PAGE_RANGES_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_FIFO_GET_NUM_CHANNELS
 *
 * This command is an internal command sent from Kernel RM to Physical RM
 * to get number of channels for a given runlist ID
 *
 *   runlistId   [IN]
 *   numChannels [OUT]
 */
#define LW2080_CTRL_CMD_INTERNAL_FIFO_GET_NUM_CHANNELS (0x20800a61) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_FIFO_GET_NUM_CHANNELS_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_FIFO_GET_NUM_CHANNELS_PARAMS_MESSAGE_ID (0x61U)

typedef struct LW2080_CTRL_INTERNAL_FIFO_GET_NUM_CHANNELS_PARAMS {
    LwU32 runlistId;
    LwU32 numChannels;
} LW2080_CTRL_INTERNAL_FIFO_GET_NUM_CHANNELS_PARAMS;

/*!
 * @ref LW2080_CTRL_CMD_INTERNAL_STATIC_KMIGMGR_GET_PROFILES
 * @ref LW2080_CTRL_CMD_INTERNAL_STATIC_MIGMGR_GET_PROFILES
 */
#define LW2080_CTRL_CMD_INTERNAL_STATIC_KMIGMGR_GET_PROFILES                    (0x20800a63) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x63" */

/*!
 * @ref LW2080_CTRL_CMD_INTERNAL_STATIC_KMIGMGR_GET_VALID_SWIZZID_MASK
 * @ref LW2080_CTRL_CMD_INTERNAL_STATIC_MIGMGR_GET_VALID_SWIZZID_MASK
 */
#define LW2080_CTRL_CMD_INTERNAL_STATIC_KMIGMGR_GET_VALID_SWIZZID_MASK          (0x20800a64) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x64" */

/*!
 * LW2080_CTRL_CMD_INTERNAL_STATIC_KMIGMGR_GET_PARTITIONABLE_ENGINES
 * LW2080_CTRL_CMD_INTERNAL_STATIC_MIGMGR_GET_PARTITIONABLE_ENGINES
 */
#define LW2080_CTRL_CMD_INTERNAL_STATIC_KMIGMGR_GET_PARTITIONABLE_ENGINES       (0x20800a65) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x65" */

/*!
 * LW2080_CTRL_CMD_INTERNAL_STATIC_KMIGMGR_GET_SWIZZ_ID_FB_MEM_PAGE_RANGES
 * LW2080_CTRL_CMD_INTERNAL_STATIC_MIGMGR_GET_SWIZZ_ID_FB_MEM_PAGE_RANGES
 */
#define LW2080_CTRL_CMD_INTERNAL_STATIC_KMIGMGR_GET_SWIZZ_ID_FB_MEM_PAGE_RANGES (0x20800a66) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x66" */

/*!
 * LW2080_CTRL_CMD_INTERNAL_KMEMSYS_GET_MIG_MEMORY_CONFIG
 * LW2080_CTRL_CMD_INTERNAL_MEMSYS_GET_MIG_MEMORY_CONFIG
 *
 * This command retrieves memory config from HW
 *
 *   memBoundaryCfgA [OUT]
 *      Memory boundary config A (4KB aligned)
 *
 *   memBoundaryCfgB [OUT]
 *      Memory boundary config B (4KB aligned)
 *
 *   memBoundaryCfgC [OUT]
 *      Memory boundary config C (64KB aligned)
 *
 *   memBoundaryCfg [OUT]
 *      Memory boundary config (64KB aligned)
 *      
 *   memBoundaryCfgValInit [OUT]
 *      Memory boundary config initial value (64KB aligned)
 */
#define LW2080_CTRL_CMD_INTERNAL_KMEMSYS_GET_MIG_MEMORY_CONFIG                  (0x20800a67) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x67" */
#define LW2080_CTRL_CMD_INTERNAL_MEMSYS_GET_MIG_MEMORY_CONFIG                   (0x20800a68) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x68" */

typedef struct LW2080_CTRL_INTERNAL_MEMSYS_GET_MIG_MEMORY_CONFIG_PARAMS {
    LW_DECLARE_ALIGNED(LwU64 memBoundaryCfgA, 8);
    LW_DECLARE_ALIGNED(LwU64 memBoundaryCfgB, 8);
    LwU32 memBoundaryCfgC;
    LwU32 memBoundaryCfg;
    LwU32 memBoundaryCfgValInit;
} LW2080_CTRL_INTERNAL_MEMSYS_GET_MIG_MEMORY_CONFIG_PARAMS;

#define LW2080_CTRL_CMD_INTERNAL_MEMSYS_GET_MIG_MEMORY_PARTITION_TABLE  (0x20800a6b) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_MEMSYS_GET_MIG_MEMORY_PARTITION_TABLE_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_MEMSYS_GET_MIG_MEMORY_PARTITION_TABLE_SIZE 8

#define LW2080_CTRL_INTERNAL_MEMSYS_GET_MIG_MEMORY_PARTITION_TABLE_PARAMS_MESSAGE_ID (0x6BU)

typedef struct LW2080_CTRL_INTERNAL_MEMSYS_GET_MIG_MEMORY_PARTITION_TABLE_PARAMS {
    LwU32 data[LW2080_CTRL_INTERNAL_MEMSYS_GET_MIG_MEMORY_PARTITION_TABLE_SIZE];
} LW2080_CTRL_INTERNAL_MEMSYS_GET_MIG_MEMORY_PARTITION_TABLE_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_RC_WATCHDOG_TIMEOUT
 *
 * Ilwoke RC recovery after watchdog timeout is hit.
 */
#define LW2080_CTRL_CMD_INTERNAL_RC_WATCHDOG_TIMEOUT     (0x20800a6a) /* finn: Evaluated from "((FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x6a)" */

/* !
 *  This command disables lwca limit activation at teardown of the client.
 */
#define LW2080_CTRL_CMD_INTERNAL_PERF_LWDA_LIMIT_DISABLE (0x20800a7a) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x7A" */

/*
 *  This command is cleaning up OPTP when a client is found to have
 *  been terminated unexpectedly.
 */
#define LW2080_CTRL_CMD_INTERNAL_PERF_OPTP_CLI_CLEAR     (0x20800a7c) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x7C" */


/*!
 * This command can be used to boost P-State up one level or to the highest for a limited
 * duration for the associated subdevice. Boosts from different clients are being tracked
 * independently. Note that there are other factors that can limit P-States so the resulting
 * P-State may differ from expectation.
 *
 *   flags
 *     This parameter specifies the actual command. _CLEAR is to clear existing boost.
 *     _BOOST_1LEVEL is to boost P-State one level higher. _BOOST_TO_MAX is to boost
 *     to the highest P-State.
 *   duration
 *     This parameter specifies the duration of the boost in seconds. This has to be less
 *     than LW2080_CTRL_PERF_BOOST_DURATION_MAX.
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_ILWALID_PARAM_STRUCT
 *   LW_ERR_ILWALID_ARGUMENT
 */
#define LW2080_CTRL_CMD_INTERNAL_PERF_BOOST_SET_2X       (0x20800a9a) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_PERF_BOOST_SET_PARAMS_2X_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_PERF_BOOST_SET_PARAMS_2X_MESSAGE_ID (0x9AU)

typedef struct LW2080_CTRL_INTERNAL_PERF_BOOST_SET_PARAMS_2X {

    LwBool flags;
    LwU32  duration;
} LW2080_CTRL_INTERNAL_PERF_BOOST_SET_PARAMS_2X;

#define LW2080_CTRL_INTERNAL_PERF_SYNC_GPU_BOOST_LIMITS_PSTATE   0U
#define LW2080_CTRL_INTERNAL_PERF_SYNC_GPU_BOOST_LIMITS_GPCCLK   1U
#define LW2080_CTRL_INTERNAL_PERF_SYNC_GPU_BOOST_LIMITS_LAST     LW2080_CTRL_INTERNAL_PERF_SYNC_GPU_BOOST_LIMITS_GPCCLK
#define LW2080_CTRL_INTERNAL_PERF_SYNC_GPU_BOOST_LIMITS_NUM      (0x2U) /* finn: Evaluated from "LW2080_CTRL_INTERNAL_PERF_SYNC_GPU_BOOST_LIMITS_LAST + 1" */

/*!
 * LW2080_CTRL_CMD_INTERNAL_PERF_GPU_BOOST_SYNC_SET_CONTROL
 *
 * Activate/Deactivate GPU Boost Sync algorithm
 *
 *   bActivate [IN]
 *     GPU Boost Sync algorithm:
 *      LW_TRUE  -> activate
 *      LW_FALSE -> deactivate
 *
 */
#define LW2080_CTRL_CMD_INTERNAL_PERF_GPU_BOOST_SYNC_SET_CONTROL (0x20800a7e) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_PERF_GPU_BOOST_SYNC_CONTROL_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_PERF_GPU_BOOST_SYNC_CONTROL_PARAMS_MESSAGE_ID (0x7EU)

typedef struct LW2080_CTRL_INTERNAL_PERF_GPU_BOOST_SYNC_CONTROL_PARAMS {
    LwBool bActivate;
} LW2080_CTRL_INTERNAL_PERF_GPU_BOOST_SYNC_CONTROL_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_PERF_GPU_BOOST_SYNC_SET_LIMITS
 *
 * Apply given limits to a specific subdevice
 *
 *   flags [IN]
 *     DM-TODO: write description here
 *
 *   bBridgeless [IN]
 *     Bridgeless information, for now supporting only MIO bridges
 * 
 *   lwrrLimits
 *     Array of limits that will be applied
 *
 */
#define LW2080_CTRL_CMD_INTERNAL_PERF_GPU_BOOST_SYNC_SET_LIMITS (0x20800a7f) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_PERF_GPU_BOOST_SYNC_SET_LIMITS_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_PERF_GPU_BOOST_SYNC_SET_LIMITS_PARAMS_MESSAGE_ID (0x7FU)

typedef struct LW2080_CTRL_INTERNAL_PERF_GPU_BOOST_SYNC_SET_LIMITS_PARAMS {
    LwU32  flags;
    LwBool bBridgeless;
    LwU32  lwrrLimits[LW2080_CTRL_INTERNAL_PERF_SYNC_GPU_BOOST_LIMITS_NUM];
} LW2080_CTRL_INTERNAL_PERF_GPU_BOOST_SYNC_SET_LIMITS_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_PERF_GPU_BOOST_SYNC_GET_INFO
 *
 * Data for GPU Boost Sync structure initialization
 *
 *   hysteresisus [OUT]
 *     Hysteresis value for GPU Boost synchronization hysteresis algorithm.
 *
 *   bHystersisEnable [OUT]
 *     hysteresis algorithm for SLI GPU Boost synchronization:
 *      LW_TRUE  -> enabled,
 *      LW_FALSE -> disabled
 * 
 *   bSliGpuBoostSyncEnable [OUT]
 *     SLI GPU Boost feature is:
 *      LW_TRUE  -> enabled,
 *      LW_FALSE -> disabled
 *
 */
#define LW2080_CTRL_CMD_INTERNAL_PERF_GPU_BOOST_SYNC_GET_INFO (0x20800a80) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_PERF_GPU_BOOST_SYNC_GET_INFO_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_PERF_GPU_BOOST_SYNC_GET_INFO_PARAMS_MESSAGE_ID (0x80U)

typedef struct LW2080_CTRL_INTERNAL_PERF_GPU_BOOST_SYNC_GET_INFO_PARAMS {
    LW_DECLARE_ALIGNED(LwU64 hysteresisus, 8);
    LwBool bHystersisEnable;
    LwBool bSliGpuBoostSyncEnable;
} LW2080_CTRL_INTERNAL_PERF_GPU_BOOST_SYNC_GET_INFO_PARAMS;

/*
 * LW2080_CTRL_CMD_INTERNAL_GMMU_REGISTER_FAULT_BUFFER
 *
 * This command sends replayable fault buffer pages allocated by CPU-RM
 * to be setup and enabled in physical RM.
 *
 * hClient
 *   Client handle.
 *
 * hObject
 *   Object handle.
 *
 * faultBufferSize
 *   Size of the replayable fault buffer to register.
 *
 * faultBufferPteArray
 *   Pages of replayable fault buffer.
 *
 * Possible status values returned are:
 *   LW_OK
 */
#define LW2080_CTRL_CMD_INTERNAL_GMMU_REGISTER_FAULT_BUFFER (0x20800a9b) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_GMMU_REGISTER_FAULT_BUFFER_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_GMMU_FAULT_BUFFER_MAX_PAGES    256
#define LW2080_CTRL_INTERNAL_GMMU_REGISTER_FAULT_BUFFER_PARAMS_MESSAGE_ID (0x9BU)

typedef struct LW2080_CTRL_INTERNAL_GMMU_REGISTER_FAULT_BUFFER_PARAMS {
    LwHandle hClient;
    LwHandle hObject;
    LwU32    faultBufferSize;
    LW_DECLARE_ALIGNED(LwU64 faultBufferPteArray[LW2080_CTRL_INTERNAL_GMMU_FAULT_BUFFER_MAX_PAGES], 8);
} LW2080_CTRL_INTERNAL_GMMU_REGISTER_FAULT_BUFFER_PARAMS;

/*
 * LW2080_CTRL_CMD_INTERNAL_GMMU_UNREGISTER_FAULT_BUFFER
 *
 * This command requests physical RM to disable the replayable fault buffer.
 *
 * Possible status values returned are:
 *   LW_OK
 */
#define LW2080_CTRL_CMD_INTERNAL_GMMU_UNREGISTER_FAULT_BUFFER             (0x20800a9c) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x9C" */

/*
 * LW2080_CTRL_CMD_INTERNAL_GMMU_REGISTER_CLIENT_SHADOW_FAULT_BUFFER
 *
 * This command sends client shadow fault buffer pages allocated by CPU-RM
 * to be setup and enabled in physical RM.
 *
 * shadowFaultBufferQueuePhysAddr
 *   Physical address of shadow fault buffer queue.
 *
 * faultBufferSize
 *   Size of the client shadow fault buffer to register.
 *
 * shadowFaultBufferPteArray
 *   Pages of client shadow fault buffer.
 *
 * Possible status values returned are:
 *   LW_OK
 */
#define LW2080_CTRL_CMD_INTERNAL_GMMU_REGISTER_CLIENT_SHADOW_FAULT_BUFFER (0x20800a9d) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_GMMU_REGISTER_CLIENT_SHADOW_FAULT_BUFFER_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_GMMU_CLIENT_SHADOW_FAULT_BUFFER_MAX_PAGES    1500
#define LW2080_CTRL_INTERNAL_GMMU_REGISTER_CLIENT_SHADOW_FAULT_BUFFER_PARAMS_MESSAGE_ID (0x9DU)

typedef struct LW2080_CTRL_INTERNAL_GMMU_REGISTER_CLIENT_SHADOW_FAULT_BUFFER_PARAMS {
    LW_DECLARE_ALIGNED(LwU64 shadowFaultBufferQueuePhysAddr, 8);
    LwU32 shadowFaultBufferSize;
    LW_DECLARE_ALIGNED(LwU64 shadowFaultBufferPteArray[LW2080_CTRL_INTERNAL_GMMU_CLIENT_SHADOW_FAULT_BUFFER_MAX_PAGES], 8);
} LW2080_CTRL_INTERNAL_GMMU_REGISTER_CLIENT_SHADOW_FAULT_BUFFER_PARAMS;

/*
 * LW2080_CTRL_CMD_INTERNAL_GMMU_UNREGISTER_CLIENT_SHADOW_FAULT_BUFFER
 *
 * This command requests physical RM to disable the client shadow fault buffer.
 *
 * Possible status values returned are:
 *   LW_OK
 */
#define LW2080_CTRL_CMD_INTERNAL_GMMU_UNREGISTER_CLIENT_SHADOW_FAULT_BUFFER (0x20800a9e) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x9E" */

/*!
 * LW2080_CTRL_CMD_INTERNAL_PERF_BOOST_SET_3X
 *
 * This command can be used to boost P-State the highest for a limited
 * duration for the associated subdevice. Boosts from different clients are being tracked
 * independently. Note that there are other factors that can limit P-States so the resulting
 * P-State may differ from expectation.
 *
 *   flags [IN]
 *     This parameter specifies the actual command. _CLEAR is to clear existing boost.
 *     and _BOOST_TO_MAX is to boost to the highest P-State.
 *
 *   boostDuration [IN]
 *     This parameter specifies the duration of the boost in seconds. This has to be less
 *     than LW2080_CTRL_PERF_BOOST_DURATION_MAX.
 *
 *   gfId [IN]
 *     This specifies Id of the Kernel RM that is requesting the Boost
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_ILWALID_PARAM_STRUCT
 *   LW_ERR_ILWALID_ARGUMENT *
 */
#define LW2080_CTRL_CMD_INTERNAL_PERF_BOOST_SET_3X                          (0x20800aa0) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_PERF_BOOST_SET_PARAMS_3X_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_PERF_BOOST_SET_PARAMS_3X_MESSAGE_ID (0xA0U)

typedef struct LW2080_CTRL_INTERNAL_PERF_BOOST_SET_PARAMS_3X {

    LwU32 flags;
    LwU32 boostDuration;
    LwU32 gfId;
} LW2080_CTRL_INTERNAL_PERF_BOOST_SET_PARAMS_3X;

/*!
 * LW2080_CTRL_CMD_INTERNAL_PERF_BOOST_CLEAR_3X
 *
 * Clear the boost for specific Kernel RM
 *
 *   bIsLwdaClient [IN]
 *     Specifies if the request is for clearing the LWCA boost or regular boost
 *     LW_TRUE -> LWCA boost, LW_FALSE otherwise
 *
 *   gfId [IN]
 *     Specifies Id of the Kernel RM that is requesting Boost clear
 *
 */
#define LW2080_CTRL_CMD_INTERNAL_PERF_BOOST_CLEAR_3X (0x20800aa1) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_PERF_BOOST_CLEAR_PARAMS_3X_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_PERF_BOOST_CLEAR_PARAMS_3X_MESSAGE_ID (0xA1U)

typedef struct LW2080_CTRL_INTERNAL_PERF_BOOST_CLEAR_PARAMS_3X {

    LwBool bIsLwdaClient;
    LwU32  gfId;
} LW2080_CTRL_INTERNAL_PERF_BOOST_CLEAR_PARAMS_3X;

/*
 * LW2080_CTRL_CMD_INTERNAL_STATIC_GRMGR_GET_SKYLINE_INFO
 *
 * Retrieves skyline information about the GPU. Params are sized to lwrrently known max
 * values, but will need to be modified in the future should that change.
 */
#define LW2080_CTRL_CMD_INTERNAL_STATIC_GRMGR_GET_SKYLINE_INFO          (0x208038a2) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_GRMGR_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_STATIC_GRMGR_GET_SKYLINE_INFO_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_GRMGR_SKYLINE_INFO_MAX_SKYLINES            8
#define LW2080_CTRL_INTERNAL_GRMGR_SKYLINE_INFO_MAX_NON_SINGLETON_VGPCS 8
/*!
 * LW2080_CTRL_INTERNAL_GRMGR_SKYLINE_INFO
 * skylineVgpcSize[OUT]
 *      - TPC count of non-singleton VGPCs
 * singletolwgpcMask[OUT]
 *      - Mask of active Singletons
 * maxInstances[OUT]
 *      - Max allowed instances of this skyline conlwrrently on a GPU
 * computeSizeFlag
 *      - One of LW2080_CTRL_GPU_PARTITION_FLAG_COMPUTE_SIZE_* flags which is associated with this skyline
 * numNonSingletolwgpcs
 *      - Number of VGPCs with non-zero TPC counts which are not singletons
 */
typedef struct LW2080_CTRL_INTERNAL_GRMGR_SKYLINE_INFO {
    LwU8  skylineVgpcSize[LW2080_CTRL_INTERNAL_GRMGR_SKYLINE_INFO_MAX_NON_SINGLETON_VGPCS];
    LwU32 singletolwgpcMask;
    LwU32 maxInstances;
    LwU32 computeSizeFlag;
    LwU32 numNonSingletolwgpcs;
} LW2080_CTRL_INTERNAL_GRMGR_SKYLINE_INFO;

/*!
 * LW2080_CTRL_INTERNAL_STATIC_GRMGR_GET_SKYLINE_INFO_PARAMS
 * skylineTable[OUT]
 *      - TPC count of non-singleton VGPCs
 *      - Mask of singleton vGPC IDs active
 *      - Max Instances of this skyline possible conlwrrently
 *      - Associated compute size with the indexed skyline
 *      - Number of VGPCs with non-zero TPC counts which are not singletons
 * validEntries[OUT]
 *      - Number of entries which contain valid info in skylineInfo
 */
#define LW2080_CTRL_INTERNAL_STATIC_GRMGR_GET_SKYLINE_INFO_PARAMS_MESSAGE_ID (0xA2U)

typedef struct LW2080_CTRL_INTERNAL_STATIC_GRMGR_GET_SKYLINE_INFO_PARAMS {
    LW2080_CTRL_INTERNAL_GRMGR_SKYLINE_INFO skylineTable[LW2080_CTRL_INTERNAL_GRMGR_SKYLINE_INFO_MAX_SKYLINES];
    LwU32                                   validEntries;
} LW2080_CTRL_INTERNAL_STATIC_GRMGR_GET_SKYLINE_INFO_PARAMS;

/*!
 * @ref LW2080_CTRL_CMD_GPU_SET_PARTITIONING_MODE
 */
#define LW2080_CTRL_CMD_INTERNAL_MIGMGR_SET_PARTITIONING_MODE  (0x20800aa3) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0xA3" */

/*!
 * @ref LW2080_CTRL_CMD_GPU_CONFIGURE_PARTITION
 */
#define LW2080_CTRL_CMD_INTERNAL_MIGMGR_CONFIGURE_GPU_INSTANCE (0x20800aa4) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0xA4" */

/*!
 * @ref LW2080_CTRL_CMD_GPU_SET_PARTITIONS
 */
#define LW2080_CTRL_CMD_INTERNAL_MIGMGR_SET_GPU_INSTANCES      (0x20800aa5) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0xA5" */

/*!
 * @ref LW2080_CTRL_CMD_GPU_GET_PARTITIONS
 */
#define LW2080_CTRL_CMD_INTERNAL_MIGMGR_GET_GPU_INSTANCES      (0x20800aa6) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0xA6" */

/*!
 * LW2080_CTRL_CMD_INTERNAL_MEMSYS_SET_ZBC_REFERENCED
 *
 * Tell Physical RM whether any ZBC-kind surfaces are allocated.
 * If PF and all VFs report false, ZBC table can be flushed by Physical RM.
 *
 *   bZbcReferenced [IN]
 *     LW_TRUE -> ZBC-kind (and no _SKIP_ZBCREFCOUNT flag) are allocated in Kernel RM
 *
 */
#define LW2080_CTRL_CMD_INTERNAL_MEMSYS_SET_ZBC_REFERENCED     (0x20800a69) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_MEMSYS_SET_ZBC_REFERENCED_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_MEMSYS_SET_ZBC_REFERENCED_PARAMS_MESSAGE_ID (0x69U)

typedef struct LW2080_CTRL_INTERNAL_MEMSYS_SET_ZBC_REFERENCED_PARAMS {
    LwBool bZbcSurfacesExist;
} LW2080_CTRL_INTERNAL_MEMSYS_SET_ZBC_REFERENCED_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_KMIGMGR_EXPORT_GPU_INSTANCE
 *
 * Export the resource and placement information about a gpu instance such that a
 * similar gpu instance can be recreated from scratch in the same position on the
 * same or similar GPU. Note that different GPUs may have different physical
 * resources due to floorsweeping, and an imported gpu instance is not guaranteed
 * to get the exact same resources as the exported gpu instance, but the imported
 * gpu instance should behave identically with respect to fragmentation and
 * placement / span positioning.
 */
#define LW2080_CTRL_CMD_INTERNAL_KMIGMGR_EXPORT_GPU_INSTANCE                     (0x20800aa7) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0xA7" */
#define LW2080_CTRL_CMD_INTERNAL_MIGMGR_EXPORT_GPU_INSTANCE                      (0x20800aa8) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0xA8" */

/*!
 * LW2080_CTRL_CMD_INTERNAL_KMIGMGR_IMPORT_GPU_INSTANCE
 *
 * Create a gpu instance resembling the exported instance info. Note that
 * different GPUs may have different physical resources due to floorsweeping,
 * and an imported gpu instance is not guaranteed to get the exact same resources
 * as the exported gpu instance, but the imported gpu instance should behave
 * identically with respect to fragmentation and placement / span positioning.
 */
#define LW2080_CTRL_CMD_INTERNAL_KMIGMGR_IMPORT_GPU_INSTANCE                     (0x20800aa9) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0xA9" */
#define LW2080_CTRL_CMD_INTERNAL_MIGMGR_IMPORT_GPU_INSTANCE                      (0x20800aaa) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0xAA" */

#define LW2080_CTRL_INTERNAL_KMIGMGR_EXPORTED_GPU_INSTANCE_MAX_ENGINES_MASK_SIZE 4
typedef struct LW2080_CTRL_INTERNAL_KMIGMGR_EXPORTED_GPU_INSTANCE_INFO {
    LW_DECLARE_ALIGNED(LwU64 enginesMask[LW2080_CTRL_INTERNAL_KMIGMGR_EXPORTED_GPU_INSTANCE_MAX_ENGINES_MASK_SIZE], 8);
    LwU32 partitionFlags;
    LwU32 gpcMask;
    LwU32 veidOffset;
    LwU32 veidCount;
} LW2080_CTRL_INTERNAL_KMIGMGR_EXPORTED_GPU_INSTANCE_INFO;

typedef struct LW2080_CTRL_INTERNAL_KMIGMGR_IMPORT_EXPORT_GPU_INSTANCE_PARAMS {
    LwU32 swizzId;
    LW_DECLARE_ALIGNED(LW2080_CTRL_INTERNAL_KMIGMGR_EXPORTED_GPU_INSTANCE_INFO info, 8);
} LW2080_CTRL_INTERNAL_KMIGMGR_IMPORT_EXPORT_GPU_INSTANCE_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_MEMSYS_L2_ILWALIDATE_EVICT
 *
 * Ilwalidate and/or evict the L2 cache
 *
 *   flags [IN]
 *     flags that specify required actions
 *
 */
#define LW2080_CTRL_CMD_INTERNAL_MEMSYS_L2_ILWALIDATE_EVICT (0x20800a6c) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_MEMSYS_L2_ILWALIDATE_EVICT_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_MEMSYS_L2_ILWALIDATE_EVICT_PARAMS_MESSAGE_ID (0x6lw)

typedef struct LW2080_CTRL_INTERNAL_MEMSYS_L2_ILWALIDATE_EVICT_PARAMS {
    LwU32 flags;
} LW2080_CTRL_INTERNAL_MEMSYS_L2_ILWALIDATE_EVICT_PARAMS;

#define LW2080_CTRL_INTERNAL_MEMSYS_L2_ILWALIDATE_EVICT_FLAGS_ALL          (0x00000001)
#define LW2080_CTRL_INTERNAL_MEMSYS_L2_ILWALIDATE_EVICT_FLAGS_FIRST        (0x00000002)
#define LW2080_CTRL_INTERNAL_MEMSYS_L2_ILWALIDATE_EVICT_FLAGS_LAST         (0x00000004)
#define LW2080_CTRL_INTERNAL_MEMSYS_L2_ILWALIDATE_EVICT_FLAGS_NORMAL       (0x00000008)
#define LW2080_CTRL_INTERNAL_MEMSYS_L2_ILWALIDATE_EVICT_FLAGS_CLEAN        (0x00000010)
#define LW2080_CTRL_INTERNAL_MEMSYS_L2_ILWALIDATE_EVICT_FLAGS_WAIT_FB_PULL (0x00000020)

/*!
 * LW2080_CTRL_CMD_INTERNAL_MEMSYS_FLUSH_L2_ALL_RAMS_AND_CACHES
 *
 * Flush all L2 Rams and Caches using the ELPG flush
 *
 */
#define LW2080_CTRL_CMD_INTERNAL_MEMSYS_FLUSH_L2_ALL_RAMS_AND_CACHES       (0x20800a6d) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x6D" */

#if (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)

/*
 * LW2080_CTRL_CMD_INTERNAL_CLW_COPY
 *
 * This command copies counter data to the shared buffer.
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_ILWALID_ARGUMENT
 *   LW_ERR_ILWALID_ADDRESS
 */
#define LW2080_CTRL_CMD_INTERNAL_CLW_COPY                                  (0x20800aab) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0xAB" */

/* LWRM_UNPUBLISHED */
#endif // (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)



/*!
 * LW2080_CTRL_CMD_INTERNAL_BIF_GET_STATIC_INFO
 *
 * This command obtains information from physical RM for use by CPU-RM
 *
 * Data fields ->
 *   bPcieGen4Capable - tells whether PCIe is Gen4 capable
 */
#define LW2080_CTRL_CMD_INTERNAL_BIF_GET_STATIC_INFO                       (0x20800aac) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_BIF_GET_STATIC_INFO_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_BIF_GET_STATIC_INFO_PARAMS_MESSAGE_ID (0xalw)

typedef struct LW2080_CTRL_INTERNAL_BIF_GET_STATIC_INFO_PARAMS {
    LwBool bPcieGen4Capable;
    LwBool bIsC2CLinkUp;
    LW_DECLARE_ALIGNED(LwU64 dmaWindowStartAddress, 8);
} LW2080_CTRL_INTERNAL_BIF_GET_STATIC_INFO_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_HSHUB_PEER_CONN_CONFIG
 *
 * Program HSHUB Peer Conn Config space.
 *
 *    programPeerMask[IN]
 *      If nonzero, the peer mask for programming peers based on hshub connectivity.
 *
 *    ilwalidatePeerMask[IN]
 *      If nonzero, the peer mask for ilwalidating peers.
 *
 *    programPciePeerMask[IN]
 *      If nonzero, the peer mask for programming peers in pcie case.
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_WARN_NOTHING_TO_DO
 *     If all peer masks are zero.
 */
#define LW2080_CTRL_CMD_INTERNAL_HSHUB_PEER_CONN_CONFIG (0x20800a88) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_HSHUB_PEER_CONN_CONFIG_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_HSHUB_PEER_CONN_CONFIG_PARAMS_MESSAGE_ID (0x88U)

typedef struct LW2080_CTRL_INTERNAL_HSHUB_PEER_CONN_CONFIG_PARAMS {
    LwU32 programPeerMask;
    LwU32 ilwalidatePeerMask;
    LwU32 programPciePeerMask;
} LW2080_CTRL_INTERNAL_HSHUB_PEER_CONN_CONFIG_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_HSHUB_FIRST_LINK_PEER_ID
 *
 * Given a mask of link ids, find the first with a valid peerId.
 *
 *    linkMask[IN]
 *      Mask of linkIds to check.
 *
 *    peerId[OUT]
 *      The peerId for the lowest-index link with a valid peerId, if any.
 *      If none found, LW2080_CTRLINTERNAL_HSHUB_FIRST_LINK_PEER_ID_ILWALID_PEER (return value will still be LW_OK).
 *
 * Possible status values returned are:
 *   LW_OK
 *   
 */
#define LW2080_CTRL_CMD_INTERNAL_HSHUB_FIRST_LINK_PEER_ID          (0x20800a89) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_HSHUB_FIRST_LINK_PEER_ID_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_HSHUB_FIRST_LINK_PEER_ID_ILWALID_PEER 0xffffffff

#define LW2080_CTRL_INTERNAL_HSHUB_FIRST_LINK_PEER_ID_PARAMS_MESSAGE_ID (0x89U)

typedef struct LW2080_CTRL_INTERNAL_HSHUB_FIRST_LINK_PEER_ID_PARAMS {
    LwU32 linkMask;
    LwU32 peerId;
} LW2080_CTRL_INTERNAL_HSHUB_FIRST_LINK_PEER_ID_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_HSHUB_GET_HSHUB_ID_FOR_LINKS
 *
 * Get the Hshub Ids connected to the other end of links.
 *
 *    linkMask[IN]
 *      A mask of link ids to query.
 *
 *    hshubIds[OUT]
 *      For each set bit in the link mask, the peer Hshub Id.
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_WARN_NOTHING_TO_DO
 *     If the mask is zero.
 */
#define LW2080_CTRL_CMD_INTERNAL_HSHUB_GET_HSHUB_ID_FOR_LINKS        (0x20800a8a) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_HSHUB_GET_HSHUB_ID_FOR_LINKS_PARAMS_MESSAGE_ID" */
#define LW2080_CTRL_INTERNAL_HSHUB_GET_HSHUB_ID_FOR_LINKS_TABLE_SIZE 32

#define LW2080_CTRL_INTERNAL_HSHUB_GET_HSHUB_ID_FOR_LINKS_PARAMS_MESSAGE_ID (0x8aU)

typedef struct LW2080_CTRL_INTERNAL_HSHUB_GET_HSHUB_ID_FOR_LINKS_PARAMS {
    LwU32 linkMask;
    LwU8  hshubIds[LW2080_CTRL_INTERNAL_HSHUB_GET_HSHUB_ID_FOR_LINKS_TABLE_SIZE];
} LW2080_CTRL_INTERNAL_HSHUB_GET_HSHUB_ID_FOR_LINKS_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_HSHUB_GET_NUM_UNITS
 *
 * Return the number of HSHUB units.
 *
 *    numHshubs[OUT]
 *
 * Possible status values returned are:
 *   LW_OK
 */
#define LW2080_CTRL_CMD_INTERNAL_HSHUB_GET_NUM_UNITS (0x20800a8b) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_HSHUB_GET_NUM_UNITS_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_HSHUB_GET_NUM_UNITS_PARAMS_MESSAGE_ID (0x8bU)

typedef struct LW2080_CTRL_INTERNAL_HSHUB_GET_NUM_UNITS_PARAMS {
    LwU32 numHshubs;
} LW2080_CTRL_INTERNAL_HSHUB_GET_NUM_UNITS_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_HSHUB_NEXT_HSHUB_ID
 *
 * Return the next hshubId after the given hshubId.
 *
 *    hshubId[IN/OUT]
 *
 * Possible status values returned are:
 *   LW_OK
 */
#define LW2080_CTRL_CMD_INTERNAL_HSHUB_NEXT_HSHUB_ID (0x20800a8c) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_HSHUB_NEXT_HSHUB_ID_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_HSHUB_NEXT_HSHUB_ID_PARAMS_MESSAGE_ID (0x8lw)

typedef struct LW2080_CTRL_INTERNAL_HSHUB_NEXT_HSHUB_ID_PARAMS {
    LwU8 hshubId;
} LW2080_CTRL_INTERNAL_HSHUB_NEXT_HSHUB_ID_PARAMS;

/*
 * LW2080_CTRL_CMD_INTERNAL_LWLINK_ENABLE_COMPUTE_PEER_ADDR
 *
 * Enable compute peer addressing mode
 * This command accepts no parameters.
 */

#define LW2080_CTRL_CMD_INTERNAL_LWLINK_ENABLE_COMPUTE_PEER_ADDR (0x20800aad) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0xad" */

/*
 * LW2080_CTRL_CMD_INTERNAL_LWLINK_GET_SET_LWSWITCH_FABRIC_ADDR
 *
 * Get/Set LWSwitch fabric address for FLA
 *
 * [In] bGet
 *     Whether to get or set the LWSwitch fabric address
 * [In/Out] addr
 *     Address that is to be set or retrieved.
 */
#define LW2080_CTRL_INTERNAL_LWLINK_GET_SET_LWSWITCH_FABRIC_ADDR_PARAMS_MESSAGE_ID (0xaeU)

typedef struct LW2080_CTRL_INTERNAL_LWLINK_GET_SET_LWSWITCH_FABRIC_ADDR_PARAMS {
    LwBool bGet;
    LW_DECLARE_ALIGNED(LwU64 addr, 8);
} LW2080_CTRL_INTERNAL_LWLINK_GET_SET_LWSWITCH_FABRIC_ADDR_PARAMS;

#define LW2080_CTRL_CMD_INTERNAL_LWLINK_GET_SET_LWSWITCH_FABRIC_ADDR (0x20800aae) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_LWLINK_GET_SET_LWSWITCH_FABRIC_ADDR_PARAMS_MESSAGE_ID" */

/*!
 * LW2080_CTRL_CMD_INTERNAL_BIF_GET_ASPM_L1_FLAGS
 *
 * This command obtains information from physical RM for use by CPU-RM
 *
 * Data fields ->
 *   bCyaMaskL1
 *   bEnableAspmDtL1
 */
#define LW2080_CTRL_CMD_INTERNAL_BIF_GET_ASPM_L1_FLAGS               (0x20800ab0) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_BIF_GET_ASPM_L1_FLAGS_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_BIF_GET_ASPM_L1_FLAGS_PARAMS_MESSAGE_ID (0xb0U)

typedef struct LW2080_CTRL_INTERNAL_BIF_GET_ASPM_L1_FLAGS_PARAMS {
    LwBool bCyaMaskL1;
    LwBool bEnableAspmDtL1;
} LW2080_CTRL_INTERNAL_BIF_GET_ASPM_L1_FLAGS_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_PERF_CF_CONTROLLERS_SET_MAX_VGPU_VM_COUNT
 *
 * Sets number of VM slots that are active in VGPU's scheduler
 *
 *   maxActiveVGpuVMCount [IN]
 *     Number of VM slots that are active in vGPU's scheduler.
 *
 * Possible status values returned are:
 * LW_OK
 * LW_ERR_OUT_OF_RANGE - Passed value is out of range
 * LW_ERR_NO_MEMORY    - Out of memory
 */
#define LW2080_CTRL_CMD_INTERNAL_PERF_CF_CONTROLLERS_SET_MAX_VGPU_VM_COUNT              (0x20800ab1) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_PERF_CF_CONTROLLERS_SET_MAX_VGPU_VM_COUNT_PARAMS_MESSAGE_ID" */

/*!
 * Maximum value of VM slots that are active in vGPU's scheduler.
 */
#define LW2080_CTRL_CMD_INTERNAL_PERF_CF_CONTROLLERS_MAX_ACTIVE_VGPU_VM_COUNT_MAX_VALUE 32

#define LW2080_CTRL_INTERNAL_PERF_CF_CONTROLLERS_SET_MAX_VGPU_VM_COUNT_PARAMS_MESSAGE_ID (0xB1U)

typedef struct LW2080_CTRL_INTERNAL_PERF_CF_CONTROLLERS_SET_MAX_VGPU_VM_COUNT_PARAMS {
    LwU8 maxActiveVGpuVMCount;
} LW2080_CTRL_INTERNAL_PERF_CF_CONTROLLERS_SET_MAX_VGPU_VM_COUNT_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_MEMSYS_DISABLE_LWLINK_PEERS
 *
 * Disable all LWLINK FB peers
 *
 */
#define LW2080_CTRL_CMD_INTERNAL_MEMSYS_DISABLE_LWLINK_PEERS         (0x20800a6e) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0x6E" */

/*!
 * LW2080_CTRL_CMD_INTERNAL_MEMSYS_PROGRAM_RAW_COMPRESSION_MODE
 *
 * Program GPU in raw / legacy compression mode
 *
 */
#define LW2080_CTRL_CMD_INTERNAL_MEMSYS_PROGRAM_RAW_COMPRESSION_MODE (0x20800a6f) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_MEMSYS_PROGRAM_RAW_COMPRESSION_MODE_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_MEMSYS_PROGRAM_RAW_COMPRESSION_MODE_PARAMS_MESSAGE_ID (0x6fU)

typedef struct LW2080_CTRL_INTERNAL_MEMSYS_PROGRAM_RAW_COMPRESSION_MODE_PARAMS {
    LwBool bRawMode;
} LW2080_CTRL_INTERNAL_MEMSYS_PROGRAM_RAW_COMPRESSION_MODE_PARAMS;

#if (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)

/*
 * LW2080_CTRL_CMD_INTERNAL_CLW_MAP
 *
 * This command gets the shared buffer memory descriptor from the CPU-RM and maps to it
 * in physical-RM.
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_ILWALID_ARGUMENT
 *   LW_ERR_ILWALID_ADDRESS
 */
#define LW2080_CTRL_CMD_INTERNAL_CLW_MAP   (0x20800ab3) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0xB3" */

/*
 * LW2080_CTRL_CMD_INTERNAL_CLW_UNMAP
 *
 * This command unmaps the shared buffer memory mapping in physical-RM
 *
 * Possible status values returned are:
 *   LW_OK
 */
#define LW2080_CTRL_CMD_INTERNAL_CLW_UNMAP (0x20800ab4) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | 0xB4" */

/*!
 * LW2080_CTRL_INTERNAL_SET_P2P_CAPS_PEER_INFO
 *
 * [in] gpuId
 *   GPU ID.
 * [in] p2pCaps
 *   Peer to peer capabilities discovered between the GPUs.
 *   See LW0000_CTRL_CMD_SYSTEM_GET_P2P_CAPS_V2 for the list of valid values.
 * [in] p2pOptimalReadCEs
 *   Mask of CEs to use for p2p reads over Lwlink.
 * [in] p2pOptimalWriteCEs
 *   Mask of CEs to use for p2p writes over Lwlink.
 * [in] p2pCapsStatus
 *   Status of all supported p2p capabilities.
 *   See LW0000_CTRL_CMD_SYSTEM_GET_P2P_CAPS_V2 for the list of valid values.
 * [in] busPeerId
 *   Bus peer ID. For an invalid or a non-existent peer this field
 *   has the value LW0000_CTRL_SYSTEM_GET_P2P_CAPS_ILWALID_PEER.
 */
typedef struct LW2080_CTRL_INTERNAL_SET_P2P_CAPS_PEER_INFO {
    LwU32 gpuId;
    LwU32 p2pCaps;
    LwU32 p2pOptimalReadCEs;
    LwU32 p2pOptimalWriteCEs;
    LwU8  p2pCapsStatus[LW0000_CTRL_P2P_CAPS_INDEX_TABLE_SIZE];
    LwU32 busPeerId;
} LW2080_CTRL_INTERNAL_SET_P2P_CAPS_PEER_INFO;

/*!
 * LW2080_CTRL_CMD_INTERNAL_SET_P2P_CAPS
 *
 * An internal call to propagate the peer to peer capabilities of peer GPUs
 * to the Physical RM. These capabilities are to be consumed by the vGPU GSP plugin.
 * This control is used to both add and and update the peer to peer capabilities.
 * The existing GPU entries will be updated and those which don't exist will be added.
 * Use LW2080_CTRL_CMD_INTERNAL_REMOVE_P2P_CAPS to remove the added entries.
 *
 *   [in] peerGpuCount
 *     The number of the peerGpuInfos entries.
 *   [in] peerGpuInfos
 *     The array of LW2080_CTRL_CMD_INTERNAL_SET_P2P_CAPS entries, describing
 *     the peer to peer capabilities of the specified GPUs.
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_ILWALID_ARGUMENT - Invalid peerGpuCount
 *   LW_ERR_INSUFFICIENT_RESOURCES - Total GPU count exceeds the maximum value
 */
#define LW2080_CTRL_CMD_INTERNAL_SET_P2P_CAPS (0x20800ab5) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_SET_P2P_CAPS_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_SET_P2P_CAPS_PARAMS_MESSAGE_ID (0xB5U)

typedef struct LW2080_CTRL_INTERNAL_SET_P2P_CAPS_PARAMS {
    LwU32                                       peerGpuCount;
    LW2080_CTRL_INTERNAL_SET_P2P_CAPS_PEER_INFO peerGpuInfos[LW0000_CTRL_SYSTEM_MAX_ATTACHED_GPUS];
} LW2080_CTRL_INTERNAL_SET_P2P_CAPS_PARAMS;

/*!
 * LW2080_CTRL_CMD_INTERNAL_REMOVE_P2P_CAPS
 *
 * An internal call to remove the cached peer to peer capabilities of peer GPUs
 * from the Physical RM.
 *
 *   [in] peerGpuIdCount
 *     The number of the peerGpuIds entries.
 *   [in] peerGpuIds
 *     The array of GPU IDs, specifying the GPU for which the entries need to be removed.
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_ILWALID_ARGUMENT - Invalid peerGpuIdCount
 *   LW_ERR_OBJECT_NOT_FOUND - Invalid peerGpuIds[] entry
 */
#define LW2080_CTRL_CMD_INTERNAL_REMOVE_P2P_CAPS (0x20800ab6) /* finn: Evaluated from "(FINN_LW20_SUBDEVICE_0_INTERNAL_INTERFACE_ID << 8) | LW2080_CTRL_INTERNAL_REMOVE_P2P_CAPS_PARAMS_MESSAGE_ID" */

#define LW2080_CTRL_INTERNAL_REMOVE_P2P_CAPS_PARAMS_MESSAGE_ID (0xB6U)

typedef struct LW2080_CTRL_INTERNAL_REMOVE_P2P_CAPS_PARAMS {
    LwU32 peerGpuIdCount;
    LwU32 peerGpuIds[LW0000_CTRL_SYSTEM_MAX_ATTACHED_GPUS];
} LW2080_CTRL_INTERNAL_REMOVE_P2P_CAPS_PARAMS;
/* LWRM_UNPUBLISHED */
#endif // (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)



/* ctrl2080internal_h */
