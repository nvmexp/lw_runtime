/*
* _LWRM_COPYRIGHT_BEGIN_
*
* Copyright 2007-2021 by LWPU Corporation.  All rights reserved.  All
* information contained herein is proprietary and confidential to LWPU
* Corporation.  Any use, reproduction, or disclosure without the written
* permission of LWPU Corporation is prohibited.
*
* _LWRM_COPYRIGHT_END_
*/

#pragma once

#include <lwtypes.h>
#if defined(_MSC_VER)
#pragma warning(disable:4324)
#endif

//
// This file was generated with FINN, an LWPU coding tool.
// Source file: ctrl/ctrla06f/ctrla06fgpfifo.finn
//
#if (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)
//
// Please edit the original FINN IDL file to create desired edits in this header
// See https://confluence.lwpu.com/display/CORERM/FINN for more info on how to
// edit FINN.
//
#endif // (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)




#include "ctrl/ctrla06f/ctrla06fbase.h"

/*
 * LWA06F_CTRL_GET_CLASS_ENGINEID
 *
 * Please see description of LW906F_CTRL_GET_CLASS_ENGINEID for more information.
 *
 */
#define LWA06F_CTRL_GET_CLASS_ENGINEID (0xa06f0101) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GPFIFO_A_GPFIFO_INTERFACE_ID << 8) | 0x1" */

typedef LW906F_CTRL_GET_CLASS_ENGINEID_PARAMS LWA06F_CTRL_GET_CLASS_ENGINEID_PARAMS;

// FINN PORT: The below type was generated by the FINN port to
// ensure that all API's have a unique structure associated
// with them!
#define LWA06F_CTRL_GET_CLASS_ENGINEID_FINN_PARAMS_MESSAGE_ID (0x1U)

typedef struct LWA06F_CTRL_GET_CLASS_ENGINEID_FINN_PARAMS {
    LWA06F_CTRL_GET_CLASS_ENGINEID_PARAMS params;
} LWA06F_CTRL_GET_CLASS_ENGINEID_FINN_PARAMS;



/*
 * LWA06F_CTRL_RESET_CHANNEL
 *
 * Please see description of LW906F_CTRL_RESET_CHANNEL for more information.
 */
#define LWA06F_CTRL_CMD_RESET_CHANNEL (0xa06f0102) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GPFIFO_A_GPFIFO_INTERFACE_ID << 8) | 0x2" */

typedef LW906F_CTRL_CMD_RESET_CHANNEL_PARAMS LWA06F_CTRL_CMD_RESET_CHANNEL_PARAMS;

// FINN PORT: The below type was generated by the FINN port to
// ensure that all API's have a unique structure associated
// with them!
#define LWA06F_CTRL_CMD_RESET_CHANNEL_FINN_PARAMS_MESSAGE_ID (0x2U)

typedef struct LWA06F_CTRL_CMD_RESET_CHANNEL_FINN_PARAMS {
    LWA06F_CTRL_CMD_RESET_CHANNEL_PARAMS params;
} LWA06F_CTRL_CMD_RESET_CHANNEL_FINN_PARAMS;



/*
 * LWA06F_CTRL_CMD_GPFIFO_SCHEDULE
 *
 * This command schedules a channel in hardware. This command should be called
 * after objects have been allocated on the channel or a call to
 * LWA06F_CTRL_CMD_BIND has been made.
 *
 * bEnable
 *   This parameter indicates whether or not the channel should be scheduled in hardware.
 *   When set, the channel will be enabled in addition to being added to the appropriate runlist.
 *   When not set, the channel will be disabled and removed from runlist.
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_ILWALID_OBJECT_HANDLE
 *   LW_ERR_ILWALID_STATE
 *   LW_ERR_ILWALID_OPERATION
 *
 */
#define LWA06F_CTRL_CMD_GPFIFO_SCHEDULE (0xa06f0103) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GPFIFO_A_GPFIFO_INTERFACE_ID << 8) | LWA06F_CTRL_GPFIFO_SCHEDULE_PARAMS_MESSAGE_ID" */
#define LWA06F_CTRL_GPFIFO_SCHEDULE_PARAMS_MESSAGE_ID (0x3U)

typedef struct LWA06F_CTRL_GPFIFO_SCHEDULE_PARAMS {
    LwBool bEnable;
    LwBool bSkipSubmit;
} LWA06F_CTRL_GPFIFO_SCHEDULE_PARAMS;

/*
 * LWA06F_CTRL_CMD_BIND
 *
 * This command uses the given engine to configure the channel for scheduling.
 * It alleviates the need to call LWA06F_CTRL_CMD_GPFIFO_SCHEDULE after objects
 * have been allocated.  However, it requires that the caller know which engine
 * they want to be able to execute on the channel.  Once this has been called
 * only objects that can be allocated on the specified engine or other engines
 * allowed to coexist on the channel will be allowed.  See
 * LW2080_CTRL_CMD_GPU_GET_ENGINE_PARTNERLIST to determine which engines can
 * share a parent.
 *
 * engineType
 *   This parameter specifies an LW2080_ENGINE_TYPE value indicating the
 *   engine to which this channel should be bound.
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_ILWALID_ARGUMENT
 *   LW_ERR_ILWALID_STATE
 */
#define LWA06F_CTRL_CMD_BIND (0xa06f0104) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GPFIFO_A_GPFIFO_INTERFACE_ID << 8) | LWA06F_CTRL_BIND_PARAMS_MESSAGE_ID" */

#define LWA06F_CTRL_BIND_PARAMS_MESSAGE_ID (0x4U)

typedef struct LWA06F_CTRL_BIND_PARAMS {
    LwU32 engineType;
} LWA06F_CTRL_BIND_PARAMS;



/*
 * LWA06F_CTRL_CMD_GET_MMU_FAULT_INFO
 *
 * Please see description of LW906F_CTRL_CMD_GET_MMU_FAULT_INFO for more information.
 *   
 */
#define LWA06F_CTRL_CMD_GET_MMU_FAULT_INFO (0xa06f0107) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GPFIFO_A_GPFIFO_INTERFACE_ID << 8) | 0x7" */

typedef LW906F_CTRL_GET_MMU_FAULT_INFO_PARAMS LWA06F_CTRL_GET_MMU_FAULT_INFO_PARAMS;

// FINN PORT: The below type was generated by the FINN port to
// ensure that all API's have a unique structure associated
// with them!
#define LWA06F_CTRL_CMD_GET_MMU_FAULT_INFO_FINN_PARAMS_MESSAGE_ID (0x7U)

typedef struct LWA06F_CTRL_CMD_GET_MMU_FAULT_INFO_FINN_PARAMS {
    LW_DECLARE_ALIGNED(LWA06F_CTRL_GET_MMU_FAULT_INFO_PARAMS params, 8);
} LWA06F_CTRL_CMD_GET_MMU_FAULT_INFO_FINN_PARAMS;



/*
 * LWA06F_CTRL_CMD_SET_ERROR_NOTIFIER
 *
 * This command sets the channel error notifier of the target channel.
 *   bNotifyEachChannelInTSG
 *     When true, the error notifier will be set on every channel in
 *     the TSG that contains the channel.
 * 
 * Possible status values returned are:
 *   LW_OK
 */
#define LWA06F_CTRL_CMD_SET_ERROR_NOTIFIER (0xa06f0108) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GPFIFO_A_GPFIFO_INTERFACE_ID << 8) | LWA06F_CTRL_SET_ERROR_NOTIFIER_PARAMS_MESSAGE_ID" */

#define LWA06F_CTRL_SET_ERROR_NOTIFIER_PARAMS_MESSAGE_ID (0x8U)

typedef struct LWA06F_CTRL_SET_ERROR_NOTIFIER_PARAMS {
    LwBool bNotifyEachChannelInTSG;
} LWA06F_CTRL_SET_ERROR_NOTIFIER_PARAMS;

/*
 * LWA06F_CTRL_CMD_SET_INTERLEAVE_LEVEL
 *
 * Symmetric to LWA06C_CTRL_CMD_SET_INTERLEAVE_LEVEL, applied to the individual
 * target channel.
 *
 * When belonging to a TSG, same interleave level will be set to every channel
 * in the TSG.
 *
 * channelInterleaveLevel
 *   Input parameter. One of:
 *       - LWA06C_CTRL_INTERLEAVE_LEVEL_LOW
 *       - LWA06C_CTRL_INTERLEAVE_LEVEL_MEDIUM
 *       - LWA06C_CTRL_INTERLEAVE_LEVEL_HIGH
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_ILWALID_ARGUMENT
 *   LW_ERR_ILWALID_STATE
 *   LW_ERR_INSUFFICIENT_PERMISSIONS
 */
#define LWA06F_CTRL_CMD_SET_INTERLEAVE_LEVEL (0xa06f0109) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GPFIFO_A_GPFIFO_INTERFACE_ID << 8) | 0x9" */

/*
 * LWA06F_CTRL_CMD_GET_INTERLEAVE_LEVEL
 *
 * Returns the target channel's interleave level.
 *
 * channelInterleaveLevel
 *   Output parameter. One of:
 *       - LWA06C_CTRL_INTERLEAVE_LEVEL_LOW
 *       - LWA06C_CTRL_INTERLEAVE_LEVEL_MEDIUM
 *       - LWA06C_CTRL_INTERLEAVE_LEVEL_HIGH
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_ILWALID_ARGUMENT
 *   LW_ERR_ILWALID_STATE
 */
#define LWA06F_CTRL_CMD_GET_INTERLEAVE_LEVEL (0xa06f0110) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GPFIFO_A_GPFIFO_INTERFACE_ID << 8) | 0x10" */

typedef struct LWA06F_CTRL_INTERLEAVE_LEVEL_PARAMS {
    LwU32 channelInterleaveLevel;
} LWA06F_CTRL_INTERLEAVE_LEVEL_PARAMS;

/*
 * LWA06F_CTRL_CMD_RESTART_RUNLIST
 *
 * This command expires the current timeslice and restarts the runlist the given
 * channel belongs to. This effectively preempts the current channel on the
 * corresponding engine.
 *
 * This is useful for clients to trigger preemption manually and reduce start
 * latency for higher priority channels as they are added first to the runlist
 * if LW0080_CTRL_FIFO_RUNLIST_SCHED_POLICY_CHANNEL_INTERLEAVED policy is
 * configured.
 *
 * This command interacts with the scheduler and may cause certain low priority
 * channels to starve under certain cirlwmstances. Therefore, it is only
 * available to privileged clients.
 *
 *   bForceRestart
 *     Input parameter. If LW_FALSE, the runlist restart will be skipped
 *     whenever the given channel (or its group) is already running on the
 *     corresponding engine.
 *
 *   bBypassWait
 *     Input parameter. If LW_TRUE, the command will return immediately after
 *     issuing the hardware preemption request, without actually waiting for the
 *     context switch to complete.
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_ILWALID_ARGUMENT
 *   LW_ERR_ILWALID_STATE
 */
#define LWA06F_CTRL_CMD_RESTART_RUNLIST (0xa06f0111) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GPFIFO_A_GPFIFO_INTERFACE_ID << 8) | LWA06F_CTRL_RESTART_RUNLIST_PARAMS_MESSAGE_ID" */

#define LWA06F_CTRL_RESTART_RUNLIST_PARAMS_MESSAGE_ID (0x11U)

typedef struct LWA06F_CTRL_RESTART_RUNLIST_PARAMS {
    LwBool bForceRestart;
    LwBool bBypassWait;
} LWA06F_CTRL_RESTART_RUNLIST_PARAMS;

/*
 * LWA06F_CTRL_CMD_STOP_CHANNEL
 *
 * This command is used to stop the channel
 *
 * Stopping the channel here means disabling and unbinding the channel and removing it from runlist.
 * So, if the channel needs to run again, it has to be scheduled, bound and enabled again.
 * If we fail to preempt channel or remove it from runlist, then we RC the channel.
 * Also set an error notifier to notify user space that channel is stopped.
 *
 *   bImmediate
 *     Input parameter. If LW_FALSE, we will wait for default RM timeout 
 *     for channel to idle. If LW_TRUE, we don't wait for channel to idle.
 *     If channel is not idle, we forcefully preempt it off the runlist.
 *     If the preempt times out, we will RC the channel.
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_ILWALID_ARGUMENT
 *   LW_ERR_ILWALID_STATE
 */
#define LWA06F_CTRL_CMD_STOP_CHANNEL (0xa06f0112) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GPFIFO_A_GPFIFO_INTERFACE_ID << 8) | LWA06F_CTRL_STOP_CHANNEL_PARAMS_MESSAGE_ID" */

#define LWA06F_CTRL_STOP_CHANNEL_PARAMS_MESSAGE_ID (0x12U)

typedef struct LWA06F_CTRL_STOP_CHANNEL_PARAMS {
    LwBool bImmediate;
} LWA06F_CTRL_STOP_CHANNEL_PARAMS;

/* _ctrla06fgpfifo_h_ */
