/*
* _LWRM_COPYRIGHT_BEGIN_
*
* Copyright 2007-2021 by LWPU Corporation.  All rights reserved.  All
* information contained herein is proprietary and confidential to LWPU
* Corporation.  Any use, reproduction, or disclosure without the written
* permission of LWPU Corporation is prohibited.
*
* _LWRM_COPYRIGHT_END_
*/

#pragma once

#include <lwtypes.h>
#if defined(_MSC_VER)
#pragma warning(disable:4324)
#endif

//
// This file was generated with FINN, an LWPU coding tool.
// Source file: ctrl/ctrla06c.finn
//
#if (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)
//
// Please edit the original FINN IDL file to create desired edits in this header
// See https://confluence.lwpu.com/display/CORERM/FINN for more info on how to
// edit FINN.
//
#endif // (!defined(LWRM_UNPUBLISHED) || LWRM_UNPUBLISHED == 1)




/*
 * KEPLER_CHANNEL_GROUP_A control commands and parameters
 *
 * A channel group is a collection of channels which are exelwted in a specific
 * order by hardware.  Hardware will not move from one channel in the group
 * until it is finished exelwting all its work or gives up control to the next
 * channel.
 *
 * Channels are added to the group by allocating them as a child of the
 * KEPLER_CHANNEL_GROUP_A object.
 *
 * A channel in a channel group may be restricted with respect to what objects
 * can be allocated on it and what APIs are allowed to operate on the channel.
 * For more details on specifics of how groups behave see the Software and
 * Hardware dolwmetation for the specific architecture in which you are
 * interested.
 *
 */

#include "ctrl/ctrlxxxx.h"
#include "ctrl/ctrla06f.h"          /* A06C is partially derived from A06F */

#include "ctrl/ctrl2080/ctrl2080internal.h" /* For LW2080_CTRL_INTERNAL_MEMDESC_INFO */
#include "ctrl/ctrlc36f.h"                  /* For LWC36F_CTRL_CMD_GPFIFO_FAULT_METHOD_BUFFER_MAX_RUNQUEUES */

#define LWA06C_CTRL_CMD(cat,idx)  \
    LWXXXX_CTRL_CMD(0xA06C, LWA06C_CTRL_##cat, idx)

/* KEPLER_CHANNEL_GROUP_A command categories (6bits) */
#define LWA06C_CTRL_RESERVED (0x00)
#define LWA06C_CTRL_GPFIFO   (0x01)
#define LWA06C_CTRL_INTERNAL (0x02)

/*
 * LWA06C_CTRL_CMD_NULL
 *
 * Please see description of LW906D_CTRL_CMD_NULL.
 *
 */
#define LWA06C_CTRL_CMD_NULL (0xa06c0000) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GROUP_A_RESERVED_INTERFACE_ID << 8) | 0x0" */





/*
 * LWA06C_CTRL_CMD_GPFIFO_SCHEDULE
 *
 * This command schedules a channel group in hardware. This command should be
 * called after objects have been allocated on the channel or a call to
 * LWA06C_CTRL_CMD_BIND has been made.
 *
 * See LWA06F_CTRL_CMD_GPFIFO_SCHEDULE for parameter definitions.
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_ILWALID_OBJECT_HANDLE
 *   LW_ERR_ILWALID_STATE
 *   LW_ERR_ILWALID_OPERATION
 *
 */
#define LWA06C_CTRL_CMD_GPFIFO_SCHEDULE (0xa06c0101) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GROUP_A_GPFIFO_INTERFACE_ID << 8) | 0x1" */
typedef LWA06F_CTRL_GPFIFO_SCHEDULE_PARAMS LWA06C_CTRL_GPFIFO_SCHEDULE_PARAMS;

// FINN PORT: The below type was generated by the FINN port to
// ensure that all API's have a unique structure associated
// with them!
#define LWA06C_CTRL_CMD_GPFIFO_SCHEDULE_FINN_PARAMS_MESSAGE_ID (0x1U)

typedef struct LWA06C_CTRL_CMD_GPFIFO_SCHEDULE_FINN_PARAMS {
    LWA06C_CTRL_GPFIFO_SCHEDULE_PARAMS params;
} LWA06C_CTRL_CMD_GPFIFO_SCHEDULE_FINN_PARAMS;




/*
 * LWA06C_CTRL_CMD_BIND
 *
 * This command uses the given engine to configure the group for scheduling.
 * It alleviates the need to call LWA06C_CTRL_CMD_GPFIFO_SCHEDULE after objects
 * have been allocated.  However, it requires that the caller know which engine
 * they want to be able to execute in the group.  Once this has been called
 * only objects that can be allocated on the specified engine or other engines
 * allowed to coexist in the group will be allowed.  See
 * LW2080_CTRL_CMD_GPU_GET_ENGINE_PARTNERLIST to determine which engines can
 * share a parent.
 *
 * See LWA06F_CTRL_CMD_BIND for parameter definitions.
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_ILWALID_ARGUMENT
 *   LW_ERR_ILWALID_STATE
 */
#define LWA06C_CTRL_CMD_BIND (0xa06c0102) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GROUP_A_GPFIFO_INTERFACE_ID << 8) | LWA06C_CTRL_BIND_PARAMS_MESSAGE_ID" */

#define LWA06C_CTRL_BIND_PARAMS_MESSAGE_ID (0x2U)

typedef LWA06F_CTRL_BIND_PARAMS LWA06C_CTRL_BIND_PARAMS;

/*
 * LWA06C_CTRL_CMD_SET_TIMESLICE
 *
 * This command modifies the timeslice for a channel group.  Hardware may not
 * support all possible values, so the input will be rounded down to a valid
 * hardware value.
 *
 * This takes effect immediately, meaning the channel may be forced off of the
 * GPU so the change can be made.
 *
 * timesliceUs
 *   This parameter is an input containing the desired timeslice in microseconds
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_ILWALID_ARGUMENT
 *   LW_ERR_ILWALID_STATE
 */
#define LWA06C_CTRL_CMD_SET_TIMESLICE (0xa06c0103) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GROUP_A_GPFIFO_INTERFACE_ID << 8) | 0x3" */

/*
 * LWA06C_CTRL_CMD_GET_TIMESLICE
 *
 * This command returns the timeslice for a channel group.  If
 * LWA06C_CTRL_CMD_SET_TIMESLICE has been used this call will return the exact
 * value passed to that function, which may not be exactly what is programmed
 * to hardware (see LWA06C_CTRL_CMD_SET_TIMESLICE for more details).
 *
 * timesliceUs
 *   This parameter is an output containing current timeslice in microseconds.
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_ILWALID_ARGUMENT
 *   LW_ERR_ILWALID_STATE
 */
#define LWA06C_CTRL_CMD_GET_TIMESLICE (0xa06c0104) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GROUP_A_GPFIFO_INTERFACE_ID << 8) | 0x4" */

typedef struct LWA06C_CTRL_TIMESLICE_PARAMS {
    LW_DECLARE_ALIGNED(LwU64 timesliceUs, 8);
} LWA06C_CTRL_TIMESLICE_PARAMS;

/*
 * LWA06C_CTRL_CMD_PREEMPT
 *
 * This command preempts a channel group. It optionally waits for the preempt to
 * complete before returning.
 *
 * bWait
 *   If bWait evaluates to LW_TRUE then this control call waits till the preempt
 *   completes, else it returns immediately after issuing the preempt.  Calling
 *   this control call multiple times with bWait = LW_FALSE without waiting for
 *   the preempt to complete by some other means can lead to undefined results.
 * bManualTimeout
 *   If bManualTimer evaluates to LW_TRUE then timeoutUs will be used as the
 *   timeout value.
 * timeoutUs
 *   The desired timeout in microseconds. Only used if bManualTimeout evaluates
 *   to LW_TRUE. The maximum value of timeoutUs is
 *   LWA06C_CTRL_CMD_PREEMPT_MAX_MANUAL_TIMEOUT_US.
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_ILWALID_ARGUMENT
 *   LW_ERR_ILWALID_STATE
 *
 */
#define LWA06C_CTRL_CMD_PREEMPT (0xa06c0105) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GROUP_A_GPFIFO_INTERFACE_ID << 8) | LWA06C_CTRL_PREEMPT_PARAMS_MESSAGE_ID" */

#define LWA06C_CTRL_PREEMPT_PARAMS_MESSAGE_ID (0x5U)

typedef struct LWA06C_CTRL_PREEMPT_PARAMS {
    LwBool bWait;
    LwBool bManualTimeout;
    LwU32  timeoutUs;
} LWA06C_CTRL_PREEMPT_PARAMS;

#define LWA06C_CTRL_CMD_PREEMPT_MAX_MANUAL_TIMEOUT_US (1000000) // 1 second

/*
 * LWA06C_CTRL_CMD_GET_INFO
 *
 * This command returns information about the channel group.
 *
 * tsgID
 *   Output parameter containing the hardware TSG ID for this channel group.
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_ILWALID_OBJECT
 *   LW_ERR_ILWALID_ARGUMENT
 *
 */
#define LWA06C_CTRL_CMD_GET_INFO                      (0xa06c0106) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GROUP_A_GPFIFO_INTERFACE_ID << 8) | LWA06C_CTRL_GET_INFO_PARAMS_MESSAGE_ID" */

#define LWA06C_CTRL_GET_INFO_PARAMS_MESSAGE_ID (0x6U)

typedef struct LWA06C_CTRL_GET_INFO_PARAMS {
    LwU32 tsgID;
} LWA06C_CTRL_GET_INFO_PARAMS;

/*
 * LWA06C_CTRL_CMD_SET_INTERLEAVE_LEVEL
 *
 * Used to change the target TSG's interleave level in the runlist. The
 * interleave level indicates how often channels in the TSG appear in the
 * runlist according to the following policy:
 *
 *       - LOW:    Appear once
 *       - MEDIUM: If L > 0, appear L times
 *                 Else, appear once
 *       - HIGH:   If L > 0, appear (M + 1) * L times
 *                 Else if M > 0, appear M times
 *                 Else, appear once
 *  where
 *       - L = # of LOW interleave level TSGs
 *       - M = # of MEDIUM interleave level TSGs
 *
 * For safety reasons, setting this property requires PRIVILEGED user level.
 *
 * tsgInterleaveLevel
 *   Input parameter. One of:
 *       - LWA06C_CTRL_INTERLEAVE_LEVEL_LOW
 *       - LWA06C_CTRL_INTERLEAVE_LEVEL_MEDIUM
 *       - LWA06C_CTRL_INTERLEAVE_LEVEL_HIGH
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_ILWALID_ARGUMENT
 *   LW_ERR_ILWALID_STATE
 *   LW_ERR_INSUFFICIENT_PERMISSIONS
 */
#define LWA06C_CTRL_CMD_SET_INTERLEAVE_LEVEL (0xa06c0107) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GROUP_A_GPFIFO_INTERFACE_ID << 8) | 0x7" */

/*
 * LWA06C_CTRL_CMD_GET_INTERLEAVE_LEVEL
 *
 * Returns the target TSG's interleave level.
 *
 * tsgInterleaveLevel
 *   Output parameter. One of:
 *       - LWA06C_CTRL_INTERLEAVE_LEVEL_LOW
 *       - LWA06C_CTRL_INTERLEAVE_LEVEL_MEDIUM
 *       - LWA06C_CTRL_INTERLEAVE_LEVEL_HIGH
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_ILWALID_ARGUMENT
 *   LW_ERR_ILWALID_STATE
 */
#define LWA06C_CTRL_CMD_GET_INTERLEAVE_LEVEL (0xa06c0108) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GROUP_A_GPFIFO_INTERFACE_ID << 8) | 0x8" */

typedef struct LWA06C_CTRL_INTERLEAVE_LEVEL_PARAMS {
    LwU32 tsgInterleaveLevel;
} LWA06C_CTRL_INTERLEAVE_LEVEL_PARAMS;

#define LWA06C_CTRL_INTERLEAVE_LEVEL_LOW       (0x00000000)
#define LWA06C_CTRL_INTERLEAVE_LEVEL_MEDIUM    (0x00000001)
#define LWA06C_CTRL_INTERLEAVE_LEVEL_HIGH      (0x00000002)

/*
 * LWA06C_CTRL_CMD_PROGRAM_VIDMEM_PROMOTE
 * This ctrl call is deprecated in favor of LW0090_CTRL_CMD_PROGRAM_VIDMEM_PROMOTE.
 * @see LW0090_CTRL_CMD_PROGRAM_VIDMEM_PROMOTE
 */
#define LWA06C_CTRL_CMD_PROGRAM_VIDMEM_PROMOTE (0xa06c0109) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GROUP_A_GPFIFO_INTERFACE_ID << 8) | LWA06C_CTRL_PROGRAM_VIDMEM_PROMOTE_PARAMS_MESSAGE_ID" */

typedef enum LWA06C_CTRL_PROGRAM_VIDMEM_PROMOTE_SIZE {
    LWA06C_CTRL_PROGRAM_VIDMEM_PROMOTE_SIZE_NONE = 0,
    LWA06C_CTRL_PROGRAM_VIDMEM_PROMOTE_SIZE_64B = 1,
    LWA06C_CTRL_PROGRAM_VIDMEM_PROMOTE_SIZE_128B = 2,
} LWA06C_CTRL_PROGRAM_VIDMEM_PROMOTE_SIZE;

typedef struct LWA06C_CTRL_PROGRAM_VIDMEM_PROMOTE_FIELD {
    LWA06C_CTRL_PROGRAM_VIDMEM_PROMOTE_SIZE size;
} LWA06C_CTRL_PROGRAM_VIDMEM_PROMOTE_FIELD;

#define LWA06C_CTRL_PROGRAM_VIDMEM_PROMOTE_PARAMS_MESSAGE_ID (0x9U)

typedef struct LWA06C_CTRL_PROGRAM_VIDMEM_PROMOTE_PARAMS {
    LWA06C_CTRL_PROGRAM_VIDMEM_PROMOTE_FIELD l1;
    LWA06C_CTRL_PROGRAM_VIDMEM_PROMOTE_FIELD t1;
} LWA06C_CTRL_PROGRAM_VIDMEM_PROMOTE_PARAMS;

/*!
 * LWA06C_CTRL_CMD_INTERNAL_PROMOTE_FAULT_METHOD_BUFFERS
 *
 * This control call is used to
 * - set the fault method buffer addresses in vGpu host / GSP after the fault
 *   method buffers are allocated by vGpu guest / GSP_CLIENT during channel
 *   group allocation
 * - destroy the method buffer memory descriptors during channel group free
 *
 * methodBufferMemdesc [input]
 *   Details about the memory allocated for method buffer for each runqueue.
 *   If the size of the memory region is zero, the descriptor will be destroyed.
 *
 * bar2Addr [input]
 *   CPU invisible BAR2 address that the method buffer is mapped to for each
 *   runqueue
 *
 * numValidEntries [input]
 *   The number of valid entries upto
 *   LWC36F_CTRL_CMD_GPFIFO_FAULT_METHOD_BUFFER_MAX_RUNQUEUES actually filled in
 *   the control call parameters.
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_ILWALID_ARGUMENT
 */
#define LWA06C_CTRL_CMD_INTERNAL_PROMOTE_FAULT_METHOD_BUFFERS           (0xa06c010a) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GROUP_A_GPFIFO_INTERFACE_ID << 8 | LWA06C_CTRL_INTERNAL_PROMOTE_FAULT_METHOD_BUFFERS_PARAMS_MESSAGE_ID)" */

#define LWA06C_CTRL_INTERNAL_PROMOTE_FAULT_METHOD_BUFFERS_MAX_RUNQUEUES (LWC36F_CTRL_CMD_GPFIFO_FAULT_METHOD_BUFFER_MAX_RUNQUEUES)

#define LWA06C_CTRL_INTERNAL_PROMOTE_FAULT_METHOD_BUFFERS_PARAMS_MESSAGE_ID (0xaU)

typedef struct LWA06C_CTRL_INTERNAL_PROMOTE_FAULT_METHOD_BUFFERS_PARAMS {
#if (!defined(LWRM_PUBLISHED_PENDING_IP_REVIEW) || LWRM_PUBLISHED_PENDING_IP_REVIEW == 1)
    LW_DECLARE_ALIGNED(LW2080_CTRL_INTERNAL_MEMDESC_INFO methodBufferMemdesc[LWA06C_CTRL_INTERNAL_PROMOTE_FAULT_METHOD_BUFFERS_MAX_RUNQUEUES], 8);
#endif // (!defined(LWRM_PUBLISHED_PENDING_IP_REVIEW) || LWRM_PUBLISHED_PENDING_IP_REVIEW == 1)

    LW_DECLARE_ALIGNED(LwU64 bar2Addr[LWA06C_CTRL_INTERNAL_PROMOTE_FAULT_METHOD_BUFFERS_MAX_RUNQUEUES], 8);
    LwU32 numValidEntries;
} LWA06C_CTRL_INTERNAL_PROMOTE_FAULT_METHOD_BUFFERS_PARAMS;

/*
 * LWA06C_CTRL_CMD_MAKE_REALTIME
 *
 * Promote the specified TSG to realtime, or demote to non-realtime,
 * depending on the given bRealtime parameter. A realtime TSG will have the
 * highest interleave level when the scheduling policy is CHANNEL_INTERLEAVED,
 * and will also precede any non-realtime channel/TSG in the order channels are
 * added to the corresponding runlist.
 *
 * Whenever a realtime TSG is added to a runlist, all non-realtime channels/TSGs
 * are made preemptible by setting a COMPUTE preemption mode to CTA.
 *
 * Preemption modes for realtime TSGs remain WFI.
 *
 * A client must then issue a LWA06F_CTRL_CMD_RESTART_RUNLIST control call when
 * kicking off work on a realtime TSG to preempt non-realtime channels and
 * restart the runlist such that the realtime TSG will start exelwting next.
 *
 *   bRealtime
 *     Whether the TSG is to be promoted to/demoted from realtime.
 *
 * Possible status values returned are:
 *   LW_OK
 *   LW_ERR_ILWALID_ARGUMENT
 *   LW_ERR_ILWALID_PARAMETER
 *   LW_ERR_ILWALID_OBJECT
 *   LW_ERR_ILWALID_STATE
 *   LW_ERR_NOT_SUPPORTED
 */
#define LWA06C_CTRL_CMD_MAKE_REALTIME (0xa06c0110) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GROUP_A_GPFIFO_INTERFACE_ID << 8) | LWA06C_CTRL_MAKE_REALTIME_PARAMS_MESSAGE_ID" */

#define LWA06C_CTRL_MAKE_REALTIME_PARAMS_MESSAGE_ID (0x10U)

typedef struct LWA06C_CTRL_MAKE_REALTIME_PARAMS {
    LwBool bRealtime;
} LWA06C_CTRL_MAKE_REALTIME_PARAMS;



/*
 * LWA06C_CTRL_CMD_INTERNAL_GPFIFO_SCHEDULE
 *
 * This command is an internal command sent from Kernel RM to Physical RM
 * to schedule a channel group in hardware.
 *
 * Please see description of LWA06C_CTRL_CMD_GPFIFO_SCHEDULE for more information.
 *
 */
#define LWA06C_CTRL_CMD_INTERNAL_GPFIFO_SCHEDULE (0xa06c0201) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GROUP_A_INTERNAL_INTERFACE_ID << 8) | 0x1" */

/* 
 * LWA06C_CTRL_CMD_INTERNAL_SET_TIMESLICE
 *
 * This command is an internal command sent from Kernel RM to Physical RM
 * to modify the timeslice for a channel group in hardware.
 *
 * Please see description of LWA06C_CTRL_CMD_SET_TIMESLICE for more information.
 *
 */
#define LWA06C_CTRL_CMD_INTERNAL_SET_TIMESLICE   (0xa06c0202) /* finn: Evaluated from "(FINN_KEPLER_CHANNEL_GROUP_A_INTERNAL_INTERFACE_ID << 8) | 0x2" */

/* _ctrla06c.h_ */

