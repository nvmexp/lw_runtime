/*
 * lwscicommon_transportutils.c
 *
 * Transport Utility functions for LwSci*
 *
 * Copyright (c) 2019-2022, LWPU CORPORATION. All rights reserved.
 *
 * LWPU Corporation and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from LWPU Corporation is strictly prohibited.
 */

#include "lwscicommon_transportutils_priv.h"
#include "lwscicommon_covanalysis.h"

/** \brief Magic number to identify transport object.
 *
 */
#define LWSCICOMMON_TRANSPORT_MAGIC  0xBADDF00DU
#define CRC32_START_VALUE 0xFFFFFFFFU
#define CRC32_XOR_VALUE 0xFFFFFFFFU

static bool LwSciCommonTransportIsValidBuf(
    const LwSciCommonTransportBuf* buf)
{
    bool valid = false;

    LWSCI_FNENTRY("");

    valid = ((buf != NULL) && (buf->magic == LWSCICOMMON_TRANSPORT_MAGIC));

    LWSCI_FNEXIT("");
    return valid;
}

static uint32_t callwlateCRC32(
    const uint8_t *dataPtr,
    uint64_t dataSize)
{
    /* CRC32 (IEEE-802.3 CRC32 Ethernet Standard) lookup table
     *   - Width        = 32
     *   - Poly         = 0x04C11DB7
     *   - XorIn        = 0xFFFFFFFF
     *   - ReflectIn    = true
     *   - XorOut       = 0xFFFFFFFF
     *   - ReflectOut   = true
     *   - Algorithm    = table-driven
     *   - Check Value  = 0xCBF43926
     *
     * Generated by the following routine
     * int i, j;
     * unsigned int crc;
     * for (i = 0; i < 256; i++) {
     *   crc = i;
     *   for (j = 0; j < 8; j++) {
     *     crc = (crc >> 1) ^ ((crc & 1) ? 0xEDB88320L : 0);
     *   }
     *   Crc32Table[i] = crc;
     * }
     */
    static const uint32_t lookupTableCrc32[256U] = {
    0x00000000U, 0x77073096U, 0xEE0E612LW, 0x990951BAU, 0x076DC419U,
    0x706AF48FU, 0xE963A535U, 0x9E6495A3U, 0x0EDB8832U, 0x79DCB8A4U,
    0xE0D5E91EU, 0x97D2D988U, 0x09B64C2BU, 0x7EB17CBDU, 0xE7B82D07U,
    0x90BF1D91U, 0x1DB71064U, 0x6AB020F2U, 0xF3B97148U, 0x84BE41DEU,
    0x1ADAD47DU, 0x6DDDE4EBU, 0xF4D4B551U, 0x83D385C7U, 0x136C9856U,
    0x646BA8C0U, 0xFD62F97AU, 0x8A65C9ELW, 0x14015C4FU, 0x63066CD9U,
    0xFA0F3D63U, 0x8D080DF5U, 0x3B6E20C8U, 0x4C69105EU, 0xD56041E4U,
    0xA2677172U, 0x3C03E4D1U, 0x4B04D447U, 0xD20D85FDU, 0xA50AB56BU,
    0x35B5A8FAU, 0x42B2986LW, 0xDBBBC9D6U, 0xACBCF940U, 0x32D86CE3U,
    0x45DF5C75U, 0xDCD60DCFU, 0xABD13D59U, 0x26D930ALW, 0x51DE003AU,
    0xC8D75180U, 0xBFD06116U, 0x21B4F4B5U, 0x56B3C423U, 0xCFBA9599U,
    0xB8BDA50FU, 0x2802B89EU, 0x5F058808U, 0xC60CD9B2U, 0xB10BE924U,
    0x2F6F7C87U, 0x58684C11U, 0xC1611DABU, 0xB6662D3DU, 0x76DC4190U,
    0x01DB7106U, 0x98D220BLW, 0xEFD5102AU, 0x71B18589U, 0x06B6B51FU,
    0x9FBFE4A5U, 0xE8B8D433U, 0x7807C9A2U, 0x0F00F934U, 0x9609A88EU,
    0xE10E9818U, 0x7F6A0DBBU, 0x086D3D2DU, 0x91646C97U, 0xE6635C01U,
    0x6B6B51F4U, 0x1C6C6162U, 0x856530D8U, 0xF262004EU, 0x6C0695EDU,
    0x1B01A57BU, 0x8208F4C1U, 0xF50FC457U, 0x65B0D9C6U, 0x12B7E950U,
    0x8BBEB8EAU, 0xFCB9887LW, 0x62DD1DDFU, 0x15DA2D49U, 0x8CD37CF3U,
    0xFBD44C65U, 0x4DB26158U, 0x3AB551CEU, 0xA3BC0074U, 0xD4BB30E2U,
    0x4ADFA541U, 0x3DD895D7U, 0xA4D1C46DU, 0xD3D6F4FBU, 0x4369E96AU,
    0x346ED9FLW, 0xAD678846U, 0xDA60B8D0U, 0x44042D73U, 0x33031DE5U,
    0xAA0A4C5FU, 0xDD0D7CC9U, 0x5005713LW, 0x270241AAU, 0xBE0B1010U,
    0xC90C2086U, 0x5768B525U, 0x206F85B3U, 0xB966D409U, 0xCE61E49FU,
    0x5EDEF90EU, 0x29D9C998U, 0xB0D09822U, 0xC7D7A8B4U, 0x59B33D17U,
    0x2EB40D81U, 0xB7BD5C3BU, 0xC0BA6CADU, 0xEDB88320U, 0x9ABFB3B6U,
    0x03B6E20LW, 0x74B1D29AU, 0xEAD54739U, 0x9DD277AFU, 0x04DB2615U,
    0x73DC1683U, 0xE3630B12U, 0x94643B84U, 0x0D6D6A3EU, 0x7A6A5AA8U,
    0xE40ECF0BU, 0x9309FF9DU, 0x0A00AE27U, 0x7D079EB1U, 0xF00F9344U,
    0x8708A3D2U, 0x1E01F268U, 0x6906C2FEU, 0xF762575DU, 0x806567CBU,
    0x196C3671U, 0x6E6B06E7U, 0xFED41B76U, 0x89D32BE0U, 0x10DA7A5AU,
    0x67DD4ACLW, 0xF9B9DF6FU, 0x8EBEEFF9U, 0x17B7BE43U, 0x60B08ED5U,
    0xD6D6A3E8U, 0xA1D1937EU, 0x38D8C2C4U, 0x4FDFF252U, 0xD1BB67F1U,
    0xA6BC5767U, 0x3FB506DDU, 0x48B2364BU, 0xD80D2BDAU, 0xAF0A1B4LW,
    0x36034AF6U, 0x41047A60U, 0xDF60EFC3U, 0xA867DF55U, 0x316E8EEFU,
    0x4669BE79U, 0xCB61B38LW, 0xBC66831AU, 0x256FD2A0U, 0x5268E236U,
    0xCC0C7795U, 0xBB0B4703U, 0x220216B9U, 0x5505262FU, 0xC5BA3BBEU,
    0xB2BD0B28U, 0x2BB45A92U, 0x5CB36A04U, 0xC2D7FFA7U, 0xB5D0CF31U,
    0x2CD99E8BU, 0x5BDEAE1DU, 0x9B64C2B0U, 0xEC63F226U, 0x756AA39LW,
    0x026D930AU, 0x9C0906A9U, 0xEB0E363FU, 0x72076785U, 0x05005713U,
    0x95BF4A82U, 0xE2B87A14U, 0x7BB12BAEU, 0x0CB61B38U, 0x92D28E9BU,
    0xE5D5BE0DU, 0x7CDCEFB7U, 0x0BDBDF21U, 0x86D3D2D4U, 0xF1D4E242U,
    0x68DDB3F8U, 0x1FDA836EU, 0x81BE16CDU, 0xF6B9265BU, 0x6FB077E1U,
    0x18B74777U, 0x88085AE6U, 0xFF0F6A70U, 0x66063BCAU, 0x11010B5LW,
    0x8F659EFFU, 0xF862AE69U, 0x616BFFD3U, 0x166CCF45U, 0xA00AE278U,
    0xD70DD2EEU, 0x4E048354U, 0x3903B3C2U, 0xA7672661U, 0xD06016F7U,
    0x4969474DU, 0x3E6E77DBU, 0xAED16A4AU, 0xD9D65ADLW, 0x40DF0B66U,
    0x37D83BF0U, 0xA9BCAE53U, 0xDEBB9EC5U, 0x47B2CF7FU, 0x30B5FFE9U,
    0xBDBDF21LW, 0xCABAC28AU, 0x53B39330U, 0x24B4A3A6U, 0xBAD03605U,
    0xCDD70693U, 0x54DE5729U, 0x23D967BFU, 0xB3667A2EU, 0xC4614AB8U,
    0x5D681B02U, 0x2A6F2B94U, 0xB40BBE37U, 0xC30C8EA1U, 0x5A05DF1BU,
    0x2D02EF8D};

    /* initial value for CRC32-callwlation */
    uint32_t crcValue = CRC32_START_VALUE;
    uint32_t lookUpValue = 0U;
    uint64_t index = 0UL;
    uint32_t lookUpIndex = 0U;

    for (index = 0UL; index < dataSize; index++) {
        lookUpIndex = ((uint32_t)dataPtr[index] ^ ((uint32_t)crcValue)) & 0xFFU;
        lookUpValue = lookupTableCrc32[lookUpIndex];
        crcValue = lookUpValue ^ (crcValue >> 8U);
    }

    /* XOR value for CRC32-callwlation */
    crcValue ^= CRC32_XOR_VALUE;

    return crcValue;
}

static void LwSciCommonComputeChecksum(
    LwSciCommonTransportHeader* hdr)
{
    const void* checkSumStart = NULL;
    uint64_t checkSumSize = 0U;
    uint8_t subStatus = OP_FAIL;

    LWSCI_FNENTRY("");

    u64Sub(hdr->size, sizeof(hdr->checksum), &checkSumSize, &subStatus);
    if (OP_SUCCESS != subStatus) {
        LWSCI_ERR_STR("Size callwlation for checksumSize has overflown\n");
        /* This case can only oclwre when LwSciCommonTransportHeader structure
         *  is corrupted by external entity */
        LwSciCommonPanic();
    }

    checkSumStart = (const void*)&hdr->msgMagic;
    LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 11_5), "LwSciCommon-ADV-MISRAC2012-005")
    hdr->checksum = (uint64_t)callwlateCRC32((const uint8_t *)checkSumStart, checkSumSize);

    LWSCI_INFO("output: checksum: %lX\n", hdr->checksum);

    LWSCI_FNEXIT("");
}

static bool LwSciCommolwerifyChecksum(
    const LwSciCommonTransportHeader* hdr)
{
    bool isChecksumValid = false;
    uint64_t computedCrc = 0x0U;
    const void* checkSumStart = NULL;
    uint64_t checkSumSize = 0U;
    uint8_t subStatus = OP_FAIL;

    LWSCI_FNENTRY("");

    LWSCI_INFO("input: checksum: %lX\n", hdr->checksum);

    u64Sub(hdr->size, sizeof(hdr->checksum), &checkSumSize, &subStatus);
    if (OP_SUCCESS != subStatus) {
        LWSCI_ERR_STR("Size callwlation for checksumSize has overflown\n");
        LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 15_1), "LwSciCommon-ADV-MISRAC2012-006")
        goto ret;
    }

    checkSumStart = (const void*)&hdr->msgMagic;
    LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 11_5), "LwSciCommon-ADV-MISRAC2012-005")
    computedCrc = (uint64_t)callwlateCRC32((const uint8_t *)checkSumStart, checkSumSize);

    LWSCI_INFO("output: computed checksum: %lX\n", computedCrc);

    if (computedCrc != hdr->checksum) {
        LWSCI_ERR_STR("Checksum invalid. Corrupted buffer\n");
        LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 15_1), "LwSciCommon-ADV-MISRAC2012-006")
        goto ret;
    }

    isChecksumValid = true;

ret:
    LWSCI_FNEXIT("");
    return(isChecksumValid);
}

LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 8_7), "LwSciCommon-ADV-MISRAC2012-009")
LwSciError LwSciCommonTransportAllocTxBufferForKeys(
    LwSciCommonTransportParams bufParams,
    size_t totalValueSize,
    LwSciCommonTransportBuf** txbuf)
{
    LwSciCommonTransportBuf* transBuf = NULL;
    LwSciCommonTransportHeader* hdr = NULL;
    LwSciError scierr = LwSciError_Success;
    uint32_t keyCount = bufParams.keyCount;
    size_t allocsize = 0;

    LWSCI_FNENTRY("");

    if ((0UL == keyCount) || (0UL == totalValueSize) || (NULL == txbuf)) {
        LWSCI_ERR_STR("Invalid input args: ");
        LWSCI_ERR_UINT("Keycount:  ", keyCount);
        LWSCI_ERR_ULONG("Valuesize:  ", totalValueSize);
        LwSciCommonPanic();
    }

    LWSCI_INFO("Inputs-Version: %lu Keycount: %u Valuesize: %zu Buffer: %p\n",
                 bufParams.msgVersion, keyCount, totalValueSize, txbuf);

    LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 11_5), "LwSciCommon-ADV-MISRAC2012-005")
    transBuf = (LwSciCommonTransportBuf*)LwSciCommonCalloc(1, sizeof(LwSciCommonTransportBuf));
    if (NULL == transBuf) {
        LWSCI_ERR_STR("Failed to allocate transport buf.\n");
        scierr = LwSciError_InsufficientMemory;
        LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 15_1), "LwSciCommon-ADV-MISRAC2012-006")
        goto ret;
    }

    LWCOV_ALLOWLIST_BEGIN(LWCOV_MISRA(Directive, 4_9), "LwSciCommon-ADV-MISRAC2012-004")
    allocsize = ADJUSTED_SIZEOF(LwSciCommonTransportHeader) +
                (keyCount * ADJUSTED_SIZEOF(LwSciCommonTransportKey)) + totalValueSize;
    LWCOV_ALLOWLIST_END(LWCOV_MISRA(Directive, 4_9))
    transBuf->bufPtr = LwSciCommonCalloc(1, allocsize);
    if (NULL == transBuf->bufPtr) {
        LWSCI_ERR_STR("Failed to allocate transport buffer data\n");
        scierr = LwSciError_InsufficientMemory;
        LwSciCommonFree(transBuf);
        LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 15_1), "LwSciCommon-ADV-MISRAC2012-006")
        goto ret;
    }

    /* Initalize the transport header */
    LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 11_5), "LwSciCommon-ADV-MISRAC2012-005")
    hdr = (LwSciCommonTransportHeader *)transBuf->bufPtr;
    hdr->checksum = 0;
    hdr->msgMagic = bufParams.msgMagic;
    hdr->version = bufParams.msgVersion;
    hdr->size = allocsize;
    hdr->keyCount = keyCount;

    /* Initialize the buffer */
    transBuf->allocatedKeyCount = keyCount;
    transBuf->magic = LWSCICOMMON_TRANSPORT_MAGIC;
    transBuf->rdKeyCount = 0U;
    transBuf->wrKeyCount = 0U;
    transBuf->sizeAllocated = allocsize;
    /* Header initialized. */
    LWCOV_ALLOWLIST_BEGIN(LWCOV_MISRA(Directive, 4_9), "LwSciCommon-ADV-MISRAC2012-004")
    transBuf->sizerd = ADJUSTED_SIZEOF(*hdr);
    transBuf->sizewr = ADJUSTED_SIZEOF(*hdr);
    LWCOV_ALLOWLIST_END(LWCOV_MISRA(Directive, 4_9))

    *txbuf = transBuf;

    LWSCI_INFO("Outputs- txbuf: %p, transport hdr: %p, allocsize: %zu\n",
                    *txbuf, hdr, allocsize);

ret:
    LWSCI_FNEXIT("");
    return (scierr);
}

LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 8_7), "LwSciCommon-ADV-MISRAC2012-009")
LwSciError LwSciCommonTransportAppendKeyValuePair(
    LwSciCommonTransportBuf* txbuf,
    uint32_t key,
    size_t length,
    const void* value)
{
    LwSciError scierr = LwSciError_Success;
    LwSciCommonTransportKey* addKey = NULL;
    size_t appendSize = 0UL;
    size_t tmpSum;
    uint32_t tmpCount = 0U;
    uint8_t addStatus = OP_FAIL;

    LWSCI_FNENTRY("");

    if ((false == LwSciCommonTransportIsValidBuf(txbuf)) ||
        (NULL == value) || (0UL == length)) {
        LWSCI_ERR_STR("Invalid input args.");
        LWSCI_ERR_ULONG("Length:  \n", length);
        LwSciCommonPanic();
    }

    LWSCI_INFO("Inputs - txbuf: %p key: %x value: %p length: %zu sizewr: %zu\n",
                   txbuf, key, value, length, txbuf->sizewr);

    LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Directive, 4_9), "LwSciCommon-ADV-MISRAC2012-004")
    appendSize = ADJUSTED_SIZEOF(LwSciCommonTransportKey) + length;

    sizeAdd(txbuf->sizewr, appendSize, &tmpSum, &addStatus);
    if (OP_SUCCESS != addStatus) {
        LWSCI_ERR_STR("Arithmetic overflow\n");
        scierr = LwSciError_Overflow;
        LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 15_1), "LwSciCommon-ADV-MISRAC2012-006")
        goto ret;
    }

    if (tmpSum > txbuf->sizeAllocated) {
        LWSCI_ERR_STR("Transport Buffer Out of Space.\n");
        scierr = LwSciError_NoSpace;
        LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 15_1), "LwSciCommon-ADV-MISRAC2012-006")
        goto ret;
    }

    addStatus = OP_FAIL;
    u32Add(txbuf->wrKeyCount, 1U, &tmpCount, &addStatus);
    if (OP_SUCCESS != addStatus) {
        LWSCI_ERR_STR("Integer Overflow.\n");
        scierr = LwSciError_Overflow;
        LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 15_1), "LwSciCommon-ADV-MISRAC2012-006")
        goto ret;
    }

    // Append key value pair, update txbuf state
    LWCOV_ALLOWLIST_BEGIN(LWCOV_MISRA(Rule, 11_5), "LwSciCommon-ADV-MISRAC2012-005")
    LWCOV_ALLOWLIST_BEGIN(LWCOV_MISRA(Rule, 18_4), "LwSciCommon-ADV-MISRAC2012-007")
    addKey = (LwSciCommonTransportKey *)
                (void*)((uint8_t *)txbuf->bufPtr + txbuf->sizewr);
    LWCOV_ALLOWLIST_END(LWCOV_MISRA(Rule, 11_5))
    LWCOV_ALLOWLIST_END(LWCOV_MISRA(Rule, 18_4))

    addKey->key = key;
    addKey->length = length;
    LwSciCommonMemcpyS(addKey->value, length, value, length);

    txbuf->sizewr = tmpSum;
    txbuf->wrKeyCount = tmpCount;

    LWSCI_INFO("Outputs - size added: %zu Total sizewr: %zu wrkeycount: %d\n",
                          appendSize, txbuf->sizewr, txbuf->wrKeyCount);

ret:
    LWSCI_FNEXIT("");
    return (scierr);
}

LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 8_7), "LwSciCommon-ADV-MISRAC2012-009")
void LwSciCommonTransportPrepareBufferForTx(
    LwSciCommonTransportBuf* txbuf,
    void** descBufPtr,
    size_t* descBufSize)
{
    LWSCI_FNENTRY("");

    if ((false == LwSciCommonTransportIsValidBuf(txbuf)) ||
        (NULL == descBufPtr) || (NULL == descBufSize)) {
        LWSCI_ERR_STR("Invalid Input args: ");
        LwSciCommonPanic();
    }

    LWSCI_INFO("txbuf: %p descBufPtr: %p descBufSize: %p\n", txbuf, descBufPtr,
               descBufSize);

    if ((txbuf->sizewr != txbuf->sizeAllocated) ||
        (txbuf->wrKeyCount != txbuf->allocatedKeyCount)) {
        /*
         * User is trying to send the buffer even before completely
         * utilizing the buffer space. This won't create any runtime
         * issues, but likely indicates some programmer error */
        LwSciCommonPanic();
    }

    LWCOV_ALLOWLIST_BEGIN(LWCOV_MISRA(Rule, 11_5), "LwSciCommon-ADV-MISRAC2012-005")
    LwSciCommonComputeChecksum(
                (LwSciCommonTransportHeader *)txbuf->bufPtr);
    LWCOV_ALLOWLIST_END(LWCOV_MISRA(Rule, 11_5))


    *descBufPtr = txbuf->bufPtr;
    /* Transfer ownership to the caller */
    txbuf->bufPtr = NULL;
    *descBufSize = txbuf->sizewr;
    LWSCI_INFO("*descBufPtr: %p descBufSize: %zu\n",
                        *descBufPtr, *descBufSize);

    LWSCI_FNEXIT("");
}

LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 8_7), "LwSciCommon-ADV-MISRAC2012-009")
LwSciError LwSciCommonTransportGetRxBufferAndParams(
    const void* bufPtr,
    size_t bufSize,
    LwSciCommonTransportBuf** rxbuf,
    LwSciCommonTransportParams* params)
{
    LwSciError scierr = LwSciError_Success;
    LwSciCommonTransportBuf* transBuf = NULL;
    LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 11_5), "LwSciCommon-ADV-MISRAC2012-005")
    const LwSciCommonTransportHeader* hdr = (const LwSciCommonTransportHeader *)bufPtr;

    LWSCI_FNENTRY("");

    // These variables are controlled by LwSci APIs and are not exposed to the
    // caller of any Public API. As such, we can panic here since this
    // indicates incorrect usage.
    if ((NULL == rxbuf) || (NULL == params)) {
        LwSciCommonPanic();
    }

    // These variables are exposed to the caller of a Public API. We can't
    // panic here, so we return an error code instead.
    if ((NULL == bufPtr) || (0UL == bufSize)) {
        LWSCI_ERR_STR("Invalid input arguments. \n");
        scierr = LwSciError_BadParameter;
        LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 15_1), "LwSciCommon-ADV-MISRAC2012-006")
        goto ret;
    }

    /*
     * Validate the buffer.
     * Step-1: Validate the size.
     * Step-2: Validate the checksum.
     */
    if (bufSize < hdr->size) {
        LWSCI_ERR_STR("Received buffer size doesn't match with size in header.\n");
        scierr = LwSciError_BadParameter;
        LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 15_1), "LwSciCommon-ADV-MISRAC2012-006")
        goto ret;
    }

    if (false == LwSciCommolwerifyChecksum(hdr)) {
        LWSCI_ERR_STR("Corrupted Buffer. Checksum not matching.\n");
        scierr = LwSciError_BadParameter;
        LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 15_1), "LwSciCommon-ADV-MISRAC2012-006")
        goto ret;
    }

    LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 11_5), "LwSciCommon-ADV-MISRAC2012-005")
    transBuf = (LwSciCommonTransportBuf*)LwSciCommonCalloc(1, sizeof(LwSciCommonTransportBuf));
    if (NULL == transBuf) {
        LWSCI_ERR_STR("Failed to allocate transport Buffer.");
        scierr = LwSciError_InsufficientMemory;
        LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 15_1), "LwSciCommon-ADV-MISRAC2012-006")
        goto ret;
    }

    transBuf->bufPtr = LwSciCommonCalloc(1, bufSize);
    if (NULL == transBuf->bufPtr) {
        LWSCI_ERR_STR("Failed to allocate transport buffer data\n");
        scierr = LwSciError_InsufficientMemory;
        LwSciCommonFree(transBuf);
        LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 15_1), "LwSciCommon-ADV-MISRAC2012-006")
        goto ret;
    }

    LwSciCommonMemcpyS(transBuf->bufPtr, bufSize, bufPtr, bufSize);
    transBuf->sizeAllocated = bufSize;
    transBuf->magic = LWSCICOMMON_TRANSPORT_MAGIC;
    /* Header is validated */
    transBuf->sizewr = hdr->size;
    LWCOV_ALLOWLIST_BEGIN(LWCOV_MISRA(Directive, 4_9), "LwSciCommon-ADV-MISRAC2012-004")
    LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 11_5), "LwSciCommon-ADV-MISRAC2012-005")
    transBuf->sizerd = ADJUSTED_SIZEOF(*hdr);
    LWCOV_ALLOWLIST_END(LWCOV_MISRA(Directive, 4_9))
    transBuf->allocatedKeyCount = hdr->keyCount;
    transBuf->wrKeyCount = hdr->keyCount;
    transBuf->rdKeyCount = 0U;

    params->msgMagic = hdr->msgMagic;
    params->msgVersion = hdr->version;
    params->keyCount = hdr->keyCount;

    *rxbuf = transBuf;

ret:
    LWSCI_FNEXIT("");
    return (scierr);

}

LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 8_7), "LwSciCommon-ADV-MISRAC2012-009")
LwSciError LwSciCommonTransportGetNextKeyValuePair(
    LwSciCommonTransportBuf* rxbuf,
    uint32_t* key,
    size_t* length,
    const void** value,
    bool* rdFinish)
{
    LwSciError scierr = LwSciError_Success;
    const LwSciCommonTransportKey* rdKey = NULL;
    size_t rdBytes = 0UL;
    size_t keyLen = 0UL;
    size_t tmpSum = 0UL, tmpSizeRead = 0UL;
    uint8_t addStatus1 = OP_FAIL, addStatus2 = OP_FAIL, addStatus3 = OP_FAIL;

    LWSCI_FNENTRY("");

    if ((false == LwSciCommonTransportIsValidBuf(rxbuf)) ||
        (NULL == key) || (NULL == length) || (NULL == value) ||
        (NULL == rdFinish)) {
        LWSCI_ERR_STR("Invalid input arguments to read Transport buffer.");
        LwSciCommonPanic();
    }

    LWSCI_INFO("Inputs - rxbuf: %p keyptr: %p lengthptr: %p"
               "valueptr: %p rdFinish: %p\n",
               rxbuf, key, length, value, rdFinish);

    LWCOV_ALLOWLIST_BEGIN(LWCOV_MISRA(Directive, 4_9), "LwSciCommon-ADV-MISRAC2012-004")
    LWCOV_ALLOWLIST_BEGIN(LWCOV_MISRA(Rule, 11_5), "LwSciCommon-ADV-MISRAC2012-005")
    LWCOV_ALLOWLIST_BEGIN(LWCOV_MISRA(Rule, 18_4), "LwSciCommon-ADV-MISRAC2012-007")
    rdKey = (const LwSciCommonTransportKey *)
                (const void*)((const uint8_t *)rxbuf->bufPtr + rxbuf->sizerd);
    LWCOV_ALLOWLIST_END(LWCOV_MISRA(Rule, 11_5))
    LWCOV_ALLOWLIST_END(LWCOV_MISRA(Rule, 18_4))

    keyLen = rdKey->length;
    LWCOV_ALLOWLIST_BEGIN(LWCOV_MISRA(Directive, 4_9), "LwSciCommon-ADV-MISRAC2012-004")
    tmpSum = ADJUSTED_SIZEOF(LwSciCommonTransportKey) + keyLen;
    if (ADJUSTED_SIZEOF(LwSciCommonTransportKey) > tmpSum) {
        LWCOV_ALLOWLIST_END(LWCOV_MISRA(Directive, 4_9))
        LWSCI_ERR_STR("Integer Overflow\n");
        scierr = LwSciError_Overflow;
        LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 15_1), "LwSciCommon-ADV-MISRAC2012-006")
        goto ret;
    }
    rdBytes = tmpSum;

    sizeAdd(rxbuf->sizerd, keyLen, &tmpSum, &addStatus1);
    sizeAdd(rxbuf->sizerd, rdBytes, &tmpSizeRead, &addStatus2);
    u32Add(rxbuf->rdKeyCount, 1U, &(rxbuf->rdKeyCount), &addStatus3);

    if (tmpSum > rxbuf->sizewr) {
        LWSCI_ERR_STR("Goof-up while reading !! Read pointer Overflowed\n");
        scierr = LwSciError_Overflow;
        LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 15_1), "LwSciCommon-ADV-MISRAC2012-006")
        goto ret;
    }

    if (OP_SUCCESS != (addStatus1 & addStatus2 & addStatus3)) {
        LWSCI_ERR_STR("Integer Overflow\n");
        scierr = LwSciError_Overflow;
        LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 15_1), "LwSciCommon-ADV-MISRAC2012-006")
        goto ret;
    }

    rxbuf->sizerd = tmpSizeRead;
    *key = rdKey->key;
    *length = keyLen;
    *value = rdKey->value;
    *rdFinish = false;

    if (rxbuf->sizerd == rxbuf->sizewr) {
        LWSCI_INFO("Read Complete.\n");
        *rdFinish = true;
        /* Reinitialize the read size. */
        LWCOV_ALLOWLIST_BEGIN(LWCOV_MISRA(Directive, 4_9), "LwSciCommon-ADV-MISRAC2012-004")
        LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 11_5), "LwSciCommon-ADV-MISRAC2012-005")
        rxbuf->sizerd = ADJUSTED_SIZEOF(LwSciCommonTransportHeader);
        LWCOV_ALLOWLIST_END(LWCOV_MISRA(Directive, 4_9))
    }

    LWSCI_INFO("Outputs - sizerd: %zu key: %x length: %zu "
               "value: %p rdFinish: %d\n",
               rxbuf->sizerd, *key, *length, *value, *rdFinish);

ret:
    LWSCI_FNEXIT("");
    return (scierr);
}

LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 8_7), "LwSciCommon-ADV-MISRAC2012-009")
void LwSciCommonTransportBufferFree(
    LwSciCommonTransportBuf* buf)
{
    LWSCI_FNENTRY("");

    if (false == LwSciCommonTransportIsValidBuf(buf)) {
        LWSCI_ERR_STR("Invalid input args.");
        LwSciCommonPanic();
    }

    /*
     * Free buf->bufPtr if haven't transferred the ownership yet.
     */
    if (NULL != buf->bufPtr) {
        LwSciCommonFree(buf->bufPtr);
        buf->bufPtr = NULL;
    }

    LwSciCommonFree(buf);

    LWSCI_FNEXIT("");
}

#if (LW_IS_SAFETY == 0)
void LwSciCommonTransportDumpBuffer(
    LwSciCommonTransportBuf* buf)
{
    size_t i = 0;
    size_t printsz = 0;
    const LwSciCommonTransportHeader *hdr = (const LwSciCommonTransportHeader *)buf->bufPtr;

    /* hdr may be unused if LWSCI_LWRRENT_LOG_LEVEL >= LWSCI_INFO_LOG_LEVEL
     * evaluates to false */
    (void)hdr;

    LWSCI_FNENTRY("");

    if (false == LwSciCommonTransportIsValidBuf(buf)) {
        LWSCI_ERR_STR("Buffer Invalid. Cannot dump the buffer. \n");
        LWCOV_ALLOWLIST_LINE(LWCOV_MISRA(Rule, 15_1), "LwSciCommon-ADV-MISRAC2012-006")
        goto ret;
    }

    LWSCI_INFO("Buffer Details: \n");
    LWSCI_INFO("Allocated Size: %zu Size-Read: %zu Size-Written: %zu\n",
               buf->sizeAllocated, buf->sizerd, buf->sizewr);
    LWSCI_INFO("Allocated KeyCount: %d Keys-Read: %d Keys-Written: %d\n",
               buf->allocatedKeyCount, buf->rdKeyCount, buf->wrKeyCount);

    LWSCI_INFO("Message Header (Size %zu): \n", ADJUSTED_SIZEOF(*hdr));
    LWSCI_INFO("Checksum: %lX MsgMagic: 0x%x Version: %lu \n",
                hdr->checksum, hdr->msgMagic, hdr->version);
    LWSCI_INFO("Total Buffer Size: %zu KeyCount: %d \n",
                hdr->size, hdr->keyCount);

    printsz = (buf->sizewr - ADJUSTED_SIZEOF(LwSciCommonTransportHeader));
    LWSCI_INFO("Message Data(Size %zu): ", printsz);
    for (i = 0; i < printsz; i++) {
         if (0U == (i % 20U)) {
             LWSCI_INFO("\n");
         }
         LWSCI_INFO(" %02X ", hdr->payload[i]);
    }

ret:
    LWSCI_FNEXIT("");
}
#endif
