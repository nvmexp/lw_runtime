/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2019-2020 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */

#include <list>

#include "lwswitch.h"
#include "interrupts/lwswitch_intr.h"
#include "lwmisc.h"

#include "lr10/dev_route_ip.h"
#include "lr10/dev_ingress_ip.h"
#include "lr10/dev_egress_ip.h"
#include "lr10/dev_tstate_ip.h"
#include "lr10/dev_sourcetrack_ip.h"
#include "lr10/dev_nxbar_tc_global_ip.h"
#include "lr10/dev_nxbar_tile_ip.h"
#include "lr10/dev_lwltlc_ip.h"
#include "lr10/dev_lwlipt_ip.h"
#include "lr10/dev_lwlipt_lnk_ip.h"

class LWSwitchDeviceTestIntrLr10
    : public LWSwitchDeviceTestIntr
{
public:
    LWSwitchDeviceTestIntrLr10():LWSwitchDeviceTestIntr(LWSWITCH_GET_INFO_INDEX_ARCH_LR10)
    {};
};

class LWSwitchDeviceTestIntrDisabledLr10
    : public LWSwitchDeviceTestIntrLr10
    {};

class LWSwitchDeviceTestLwlIntrLr10
    : public LWSwitchDeviceTestIntrLr10
    {};

class LWSwitchDeviceTestLwlIntrDisabledLr10
    : public LWSwitchDeviceTestIntrLr10
    {};

#define LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY(block, hw_error, sw_error, bUnbind)            \
        LWSwitchIntrTestParams(REGISTER_RW_ENGINE_NPORT,                                     \
            DRF_NUM(_##block, _ERR_REPORT_INJECT_0, _##hw_error, 1),                         \
            LW_##block##_ERR_REPORT_INJECT_0, LWSWITCH_ERR_HW_NPORT_##block##_##sw_error,    \
            bUnbind, "NPORT_" #block "_" #hw_error)

#define LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(block, hw_error, sw_error)           \
            LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY(block, hw_error, sw_error, LW_FALSE)

#define LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(block, hw_error, sw_error)               \
            LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY(block, hw_error, sw_error, LW_TRUE)

#define LWSWITCH_INTR_INJECT_NXBAR_TILE_LIST_ENTRY_FATAL(hw_error, sw_error)                 \
        LWSwitchIntrTestParams(REGISTER_RW_ENGINE_TILE,                                      \
            DRF_NUM(_NXBAR_TILE, _ERR_REPORT_INJECT, _##hw_error, 1),                        \
            LW_NXBAR_TILE_ERR_REPORT_INJECT, LWSWITCH_ERR_HW_NXBAR_TILE_##sw_error,          \
            LW_TRUE, "NXBAR_TILE" "_" #hw_error)

#define LW_NXBAR_TC_TILEOUT_ERR_REPORT_INJECT(tileout)  (LW_NXBAR_TC_TILEOUT0_ERR_REPORT_INJECT +  \
        tileout * (LW_NXBAR_TC_TILEOUT1_ERR_REPORT_INJECT - LW_NXBAR_TC_TILEOUT0_ERR_REPORT_INJECT))

#define LWSWITCH_INTR_INJECT_NXBAR_TILEOUTX_LIST_ENTRY_FATAL(tileout, hw_error, sw_error)  \
        LWSwitchIntrTestParams(REGISTER_RW_ENGINE_NXBAR,                                   \
            DRF_NUM(_NXBAR_TC_TILEOUT0, _ERR_REPORT_INJECT, _##hw_error, 1),               \
            LW_NXBAR_TC_TILEOUT_ERR_REPORT_INJECT(tileout),                                \
            LWSWITCH_ERR_HW_NXBAR_TILEOUT_##sw_error,                                      \
            LW_TRUE, "NXBAR_TILEOUT" #tileout "_" #hw_error)

#define LWSWITCH_INTR_INJECT_NXBAR_TILEOUT_LIST_ENTRY_FATAL(hw_error, sw_error)            \
        {LWSWITCH_INTR_INJECT_NXBAR_TILEOUTX_LIST_ENTRY_FATAL(0, hw_error, sw_error)},     \
        {LWSWITCH_INTR_INJECT_NXBAR_TILEOUTX_LIST_ENTRY_FATAL(1, hw_error, sw_error)},     \
        {LWSWITCH_INTR_INJECT_NXBAR_TILEOUTX_LIST_ENTRY_FATAL(2, hw_error, sw_error)},     \
        {LWSWITCH_INTR_INJECT_NXBAR_TILEOUTX_LIST_ENTRY_FATAL(3, hw_error, sw_error)},     \
        {LWSWITCH_INTR_INJECT_NXBAR_TILEOUTX_LIST_ENTRY_FATAL(4, hw_error, sw_error)},     \
        {LWSWITCH_INTR_INJECT_NXBAR_TILEOUTX_LIST_ENTRY_FATAL(5, hw_error, sw_error)},     \
        {LWSWITCH_INTR_INJECT_NXBAR_TILEOUTX_LIST_ENTRY_FATAL(6, hw_error, sw_error)},     \
        {LWSWITCH_INTR_INJECT_NXBAR_TILEOUTX_LIST_ENTRY_FATAL(7, hw_error, sw_error)},     \
        {LWSWITCH_INTR_INJECT_NXBAR_TILEOUTX_LIST_ENTRY_FATAL(8, hw_error, sw_error)}

#define LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY(block, injRegInst, hw_error, sw_error, bUnbind)       \
        LWSwitchIntrTestParams(REGISTER_RW_ENGINE_LWLTLC,                                            \
            DRF_NUM(_LWLTLC_##block, _ERR_REPORT_INJECT_##injRegInst, _##hw_error, 1),               \
            LW_LWLTLC_##block##_ERR_REPORT_INJECT_##injRegInst, LWSWITCH_ERR_HW_LWLTLC_##sw_error,   \
            bUnbind, "LWLTLC_" #block "_" #injRegInst "_" #hw_error)

#define LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_NON_FATAL(block, injRegInst, hw_error, sw_error)  \
            LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY(block, injRegInst, hw_error, sw_error, LW_FALSE)

#define LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(block, injRegInst, hw_error, sw_error)  \
            LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY(block, injRegInst, hw_error, sw_error, LW_TRUE)

#define LWSWITCH_INTR_INJECT_LWLIPT_LIST_ENTRY(block, domain, hw_error, sw_error, bUnbind)  \
        LWSwitchIntrTestParams(REGISTER_RW_ENGINE_##block,                                  \
            DRF_NUM(_##domain, _ERR_REPORT_INJECT_0, _##hw_error, 1),                       \
            LW_##domain##_ERR_REPORT_INJECT_0, LWSWITCH_ERR_HW_##block##_##sw_error,        \
            bUnbind, #domain "_" #hw_error)

#define LWSWITCH_INTR_INJECT_LWLIPT_LIST_ENTRY_NON_FATAL(block, domain, hw_error, sw_error) \
            LWSWITCH_INTR_INJECT_LWLIPT_LIST_ENTRY(block, domain, hw_error, sw_error, LW_FALSE)

#define LWSWITCH_INTR_INJECT_LWLIPT_LIST_ENTRY_FATAL(block, domain, hw_error, sw_error) \
            LWSWITCH_INTR_INJECT_LWLIPT_LIST_ENTRY(block, domain, hw_error, sw_error, LW_TRUE)

static const std::list<LWSwitchIntrTestParams> g_deviceIntrTestListLr10 = {

    // Route Nport test cases
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(ROUTE, ROUTEBUFERR, ROUTEBUFERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(ROUTE, NOPORTDEFINEDERR, NOPORTDEFINEDERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(ROUTE, ILWALIDROUTEPOLICYERR, ILWALIDROUTEPOLICYERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(ROUTE, GLT_ECC_DBE_ERR, GLT_ECC_DBE_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(ROUTE, PDCTRLPARERR, PDCTRLPARERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(ROUTE, LWS_ECC_LIMIT_ERR, LWS_ECC_LIMIT_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(ROUTE, LWS_ECC_DBE_ERR, LWS_ECC_DBE_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(ROUTE, CDTPARERR, CDTPARERR),

    // Ingress Nport test cases
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(INGRESS, CMDDECODEERR, CMDDECODEERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(INGRESS, REQCONTEXTMISMATCHERR, REQCONTEXTMISMATCHERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(INGRESS, ACLFAIL, ACLFAIL),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(INGRESS, NCISOC_HDR_ECC_LIMIT_ERR, NCISOC_HDR_ECC_LIMIT_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(INGRESS, NCISOC_HDR_ECC_DBE_ERR, NCISOC_HDR_ECC_DBE_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(INGRESS, ILWALIDVCSET, ILWALIDVCSET),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(INGRESS, ADDRBOUNDSERR, ADDRBOUNDSERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(INGRESS, RIDTABCFGERR, RIDTABCFGERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(INGRESS, RLANTABCFGERR, RLANTABCFGERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(INGRESS, REMAPTAB_ECC_DBE_ERR, REMAPTAB_ECC_DBE_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(INGRESS, RIDTAB_ECC_DBE_ERR, RIDTAB_ECC_DBE_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(INGRESS, RLANTAB_ECC_DBE_ERR, RLANTAB_ECC_DBE_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(INGRESS, NCISOC_PARITY_ERR, NCISOC_PARITY_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(INGRESS, ADDRTYPEERR, ADDRTYPEERR),

    // Egress Nport test cases
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, EGRESSBUFERR, EGRESSBUFERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, PKTROUTEERR, PKTROUTEERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, SEQIDERR, SEQIDERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(EGRESS, NXBAR_HDR_ECC_LIMIT_ERR, NXBAR_HDR_ECC_LIMIT_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, NXBAR_HDR_ECC_DBE_ERR, NXBAR_HDR_ECC_DBE_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(EGRESS, RAM_OUT_HDR_ECC_LIMIT_ERR, RAM_OUT_HDR_ECC_LIMIT_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, RAM_OUT_HDR_ECC_DBE_ERR, RAM_OUT_HDR_ECC_DBE_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, NCISOCCREDITOVFL, NCISOCCREDITOVFL),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, REQTGTIDMISMATCHERR, REQTGTIDMISMATCHERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, RSPREQIDMISMATCHERR, RSPREQIDMISMATCHERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(EGRESS, URRSPERR, DROPNPURRSPERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(EGRESS, PRIVRSPERR, PRIVRSPERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(EGRESS, HWRSPERR, HWRSPERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, NXBAR_HDR_PARITY_ERR, NXBAR_HDR_PARITY_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, NCISOC_CREDIT_PARITY_ERR, NCISOC_CREDIT_PARITY_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, NXBAR_FLITTYPE_MISMATCH_ERR, NXBAR_FLITTYPE_MISMATCH_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, CREDIT_TIME_OUT_ERR, CREDIT_TIME_OUT_ERR),

    // Tstate Nport Test cases
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(TSTATE, TAGPOOLBUFERR, TAGPOOLBUFERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(TSTATE, TAGPOOL_ECC_LIMIT_ERR, TAGPOOL_ECC_LIMIT_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(TSTATE, TAGPOOL_ECC_DBE_ERR, TAGPOOL_ECC_DBE_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(TSTATE, CRUMBSTOREBUFERR, CRUMBSTOREBUFERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(TSTATE, CRUMBSTORE_ECC_LIMIT_ERR, CRUMBSTORE_ECC_LIMIT_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(TSTATE, CRUMBSTORE_ECC_DBE_ERR, CRUMBSTORE_ECC_DBE_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(TSTATE, ATO_ERR, ATO_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(TSTATE, CAMRSP_ERR, CAMRSP_ERR),

    // Sourcetrack Nport Test cases
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(SOURCETRACK, CREQ_TCEN0_CRUMBSTORE_ECC_LIMIT_ERR, CREQ_TCEN0_CRUMBSTORE_ECC_LIMIT_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(SOURCETRACK, CREQ_TCEN1_CRUMBSTORE_ECC_LIMIT_ERR, CREQ_TCEN1_CRUMBSTORE_ECC_LIMIT_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(SOURCETRACK, CREQ_TCEN0_CRUMBSTORE_ECC_DBE_ERR, CREQ_TCEN0_CRUMBSTORE_ECC_DBE_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(SOURCETRACK, CREQ_TCEN1_CRUMBSTORE_ECC_DBE_ERR, CREQ_TCEN1_CRUMBSTORE_ECC_DBE_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(SOURCETRACK, SOURCETRACK_TIME_OUT_ERR, SOURCETRACK_TIME_OUT_ERR),

    // Nxbar TILE Test cases
    LWSWITCH_INTR_INJECT_NXBAR_TILE_LIST_ENTRY_FATAL(INGRESS_BUFFER_OVERFLOW, INGRESS_BUFFER_OVERFLOW),
    LWSWITCH_INTR_INJECT_NXBAR_TILE_LIST_ENTRY_FATAL(INGRESS_BUFFER_UNDERFLOW, INGRESS_BUFFER_UNDERFLOW),
    LWSWITCH_INTR_INJECT_NXBAR_TILE_LIST_ENTRY_FATAL(EGRESS_CREDIT_OVERFLOW, EGRESS_CREDIT_OVERFLOW),
    LWSWITCH_INTR_INJECT_NXBAR_TILE_LIST_ENTRY_FATAL(EGRESS_CREDIT_UNDERFLOW, EGRESS_CREDIT_UNDERFLOW),
    LWSWITCH_INTR_INJECT_NXBAR_TILE_LIST_ENTRY_FATAL(INGRESS_NON_BURSTY_PKT, INGRESS_NON_BURSTY_PKT),
    LWSWITCH_INTR_INJECT_NXBAR_TILE_LIST_ENTRY_FATAL(INGRESS_NON_STICKY_PKT, INGRESS_NON_STICKY_PKT),
    LWSWITCH_INTR_INJECT_NXBAR_TILE_LIST_ENTRY_FATAL(INGRESS_BURST_GT_9_DATA_VC, INGRESS_BURST_GT_9_DATA_VC),
    LWSWITCH_INTR_INJECT_NXBAR_TILE_LIST_ENTRY_FATAL(INGRESS_PKT_ILWALID_DST, INGRESS_PKT_ILWALID_DST),
    LWSWITCH_INTR_INJECT_NXBAR_TILE_LIST_ENTRY_FATAL(INGRESS_PKT_PARITY_ERROR, INGRESS_PKT_PARITY_ERROR),

    // Nxbar TILEOUT Test cases
    LWSWITCH_INTR_INJECT_NXBAR_TILEOUT_LIST_ENTRY_FATAL(INGRESS_BUFFER_OVERFLOW, INGRESS_BUFFER_OVERFLOW),
    LWSWITCH_INTR_INJECT_NXBAR_TILEOUT_LIST_ENTRY_FATAL(INGRESS_BUFFER_UNDERFLOW, INGRESS_BUFFER_UNDERFLOW),
    LWSWITCH_INTR_INJECT_NXBAR_TILEOUT_LIST_ENTRY_FATAL(EGRESS_CREDIT_OVERFLOW, EGRESS_CREDIT_OVERFLOW),
    LWSWITCH_INTR_INJECT_NXBAR_TILEOUT_LIST_ENTRY_FATAL(EGRESS_CREDIT_UNDERFLOW, EGRESS_CREDIT_UNDERFLOW),
    LWSWITCH_INTR_INJECT_NXBAR_TILEOUT_LIST_ENTRY_FATAL(INGRESS_NON_BURSTY_PKT, INGRESS_NON_BURSTY_PKT),
    LWSWITCH_INTR_INJECT_NXBAR_TILEOUT_LIST_ENTRY_FATAL(INGRESS_NON_STICKY_PKT, INGRESS_NON_STICKY_PKT),
    LWSWITCH_INTR_INJECT_NXBAR_TILEOUT_LIST_ENTRY_FATAL(INGRESS_BURST_GT_9_DATA_VC, INGRESS_BURST_GT_9_DATA_VC),
    LWSWITCH_INTR_INJECT_NXBAR_TILEOUT_LIST_ENTRY_FATAL(EGRESS_CDT_PARITY_ERROR, EGRESS_CDT_PARITY_ERROR),
};

TEST_P(LWSwitchDeviceTestIntrLr10, IntrTest)
{
    if (skipTest())
    {
        return;
    }

    injectErrorAndWaitForEvent();

    ASSERT_EQ(validateError(), 0);
}

static const std::list<LWSwitchIntrTestParams> g_deviceDisabledIntrListLr10 = {

    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(TSTATE, TD_TID_RAMBUFERR, TD_TID_RAMBUFERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(TSTATE, TD_TID_RAM_ECC_LIMIT_ERR, TD_TID_RAM_ECC_LIMIT_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(TSTATE, TD_TID_RAM_ECC_DBE_ERR, TD_TID_RAM_ECC_DBE_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(INGRESS, REMAPTAB_ECC_LIMIT_ERR, REMAPTAB_ECC_LIMIT_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(INGRESS, RIDTAB_ECC_LIMIT_ERR, RIDTAB_ECC_LIMIT_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(INGRESS, RLANTAB_ECC_LIMIT_ERR, RLANTAB_ECC_LIMIT_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(ROUTE, GLT_ECC_LIMIT_ERR, GLT_ECC_LIMIT_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(ROUTE, TRANSDONERESVERR, TRANSDONERESVERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(SOURCETRACK, CREQ_TCEN0_TD_CRUMBSTORE_ECC_DBE_ERR, CREQ_TCEN0_TD_CRUMBSTORE_ECC_DBE_ERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(SOURCETRACK, CREQ_TCEN0_TD_CRUMBSTORE_ECC_LIMIT_ERR, CREQ_TCEN0_TD_CRUMBSTORE_ECC_LIMIT_ERR),
};

TEST_P(LWSwitchDeviceTestIntrDisabledLr10, IntrDisabledInject)
{
    if (skipTest())
    {
        return;
    }

    // Disabled interrupts shouldn't fire on injection nor log error data.
    setDisabledIntrTestMode();

    injectErrorAndWaitForEvent();

    ASSERT_EQ(validateError(), 0);

    // Unbind on teardown is not necessary as no errors were injected.
    skipUnbindOnTeardown();
}

// List of LWLink TX/RX_LNK interrupts
static const std::list<LWSwitchIntrTestParams> g_deviceIntrLwlTestListLr10 = {

    // TX_0 LWLTLC error test cases
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX_LNK, 0, TXDLCREDITPARITYERR, TXDLCREDITPARITYERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX_LNK, 0, CREQ_RAM_HDR_ECC_DBE_ERR, TX_LNK_CREQ_RAM_HDR_ECC_DBE_ERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_NON_FATAL(TX_LNK, 0, CREQ_RAM_DAT_ECC_DBE_ERR, TX_LNK_CREQ_RAM_DAT_ECC_DBE_ERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_NON_FATAL(TX_LNK, 0, CREQ_RAM_ECC_LIMIT_ERR, TX_LNK_CREQ_RAM_ECC_LIMIT_ERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX_LNK, 0, RSP_RAM_HDR_ECC_DBE_ERR, TX_LNK_RSP_RAM_HDR_ECC_DBE_ERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_NON_FATAL(TX_LNK, 0, RSP_RAM_DAT_ECC_DBE_ERR, TX_LNK_RSP_RAM_DAT_ECC_DBE_ERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_NON_FATAL(TX_LNK, 0, RSP_RAM_ECC_LIMIT_ERR, TX_LNK_RSP_RAM_ECC_LIMIT_ERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX_LNK, 0, COM_RAM_HDR_ECC_DBE_ERR, TX_LNK_COM_RAM_HDR_ECC_DBE_ERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_NON_FATAL(TX_LNK, 0, COM_RAM_DAT_ECC_DBE_ERR, TX_LNK_COM_RAM_DAT_ECC_DBE_ERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_NON_FATAL(TX_LNK, 0, COM_RAM_ECC_LIMIT_ERR, TX_LNK_COM_RAM_ECC_LIMIT_ERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_NON_FATAL(TX_LNK, 0, RSP1_RAM_ECC_LIMIT_ERR, TX_LNK_RSP1_RAM_ECC_LIMIT_ERR),

    // RX_0 LWLTLC error test cases
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 0, RXDLHDRPARITYERR, RXDLHDRPARITYERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 0, RXDLDATAPARITYERR, RXDLDATAPARITYERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 0, RXDLCTRLPARITYERR, RXDLCTRLPARITYERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 0, RXILWALIDAEERR, RXILWALIDAEERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 0, RXILWALIDBEERR, RXILWALIDBEERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 0, RXILWALIDADDRALIGNERR, RXILWALIDADDRALIGNERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 0, RXPKTLENERR, RXPKTLENERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 0, RSVCMDENCERR, RSVCMDENCERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 0, RSVDATLENENCERR, RSVDATLENENCERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 0, RSVPKTSTATUSERR, RSVPKTSTATUSERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 0, RSVCACHEATTRPROBEREQERR, RSVCACHEATTRPROBEREQERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 0, RSVCACHEATTRPROBERSPERR, RSVCACHEATTRPROBERSPERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 0, DATLENGTRMWREQMAXERR, DATLENGTRMWREQMAXERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 0, DATLENLTATRRSPMINERR, DATLENLTATRRSPMINERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 0, ILWALIDCACHEATTRPOERR, ILWALIDCACHEATTRPOERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 0, ILWALIDCRERR, ILWALIDCRERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 0, ILWALID_COLLAPSED_RESPONSE_ERR, RX_LNK_ILWALID_COLLAPSED_RESPONSE_ERR),

    // RX_1 LWLTLC error test cases
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 1, RXHDROVFERR, RXHDROVFERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 1, RXDATAOVFERR, RXDATAOVFERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 1, STOMPDETERR, STOMPDETERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_NON_FATAL(RX_LNK, 1, AN1_HEARTBEAT_TIMEOUT_ERR, RX_LNK_AN1_HEARTBEAT_TIMEOUT_ERR),

    // LWLIPT COMMON
    LWSWITCH_INTR_INJECT_LWLIPT_LIST_ENTRY_FATAL(LWLIPT, LWLIPT_COMMON, CLKCTL_ILLEGAL_REQUEST, CLKCTL_ILLEGAL_REQUEST),
    LWSWITCH_INTR_INJECT_LWLIPT_LIST_ENTRY_FATAL(LWLIPT, LWLIPT_COMMON, RSTSEQ_PLL_TIMEOUT, RSTSEQ_PLL_TIMEOUT),
    LWSWITCH_INTR_INJECT_LWLIPT_LIST_ENTRY_FATAL(LWLIPT, LWLIPT_COMMON, RSTSEQ_PHYARB_TIMEOUT, RSTSEQ_PHYARB_TIMEOUT),

    // LWLIPT LNK
    LWSWITCH_INTR_INJECT_LWLIPT_LIST_ENTRY_FATAL(LWLIPT_LNK, LWLIPT_LNK, RSTSEQ_PHYCTL_TIMEOUT, RSTSEQ_PHYCTL_TIMEOUT),
    LWSWITCH_INTR_INJECT_LWLIPT_LIST_ENTRY_FATAL(LWLIPT_LNK, LWLIPT_LNK, RSTSEQ_CLKCTL_TIMEOUT, RSTSEQ_CLKCTL_TIMEOUT),
};

TEST_P(LWSwitchDeviceTestLwlIntrLr10, IntrLwlTest)
{
    if (skipTest())
    {
        return;
    }

    if (getLinkInitializedMask() != 0)
    {
        printf("[ SKIPPED ] The links are not in INIT or INVALID (RESET) state. "
               "This test suite only supports running on a system with "
               "uninitialized lwlinks. Run \"lwpu-smi -r\" to reset "
               "the HW. Refer to the README for more information.\n");
        return;
    }

    initLinks();

    injectErrorAndWaitForEvent();

    ASSERT_EQ(validateError(), 0);

    shutdownLinks();
}

static const std::list<LWSwitchIntrTestParams> g_deviceIntrLwlTestListDisabledLr10 = {

    // TX LNK errors
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX_LNK, 0, RSP1_RAM_HDR_ECC_DBE_ERR, TX_LNK_RSP1_RAM_HDR_ECC_DBE_ERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX_LNK, 0, RSP1_RAM_DAT_ECC_DBE_ERR, TX_LNK_RSP1_RAM_DAT_ECC_DBE_ERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX_LNK, 1, AN1_TIMEOUT_VC0, TX_LNK_AN1_TIMEOUT_VC0),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX_LNK, 1, AN1_TIMEOUT_VC1, TX_LNK_AN1_TIMEOUT_VC1),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX_LNK, 1, AN1_TIMEOUT_VC2, TX_LNK_AN1_TIMEOUT_VC2),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX_LNK, 1, AN1_TIMEOUT_VC3, TX_LNK_AN1_TIMEOUT_VC3),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX_LNK, 1, AN1_TIMEOUT_VC4, TX_LNK_AN1_TIMEOUT_VC4),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX_LNK, 1, AN1_TIMEOUT_VC5, TX_LNK_AN1_TIMEOUT_VC5),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX_LNK, 1, AN1_TIMEOUT_VC6, TX_LNK_AN1_TIMEOUT_VC6),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX_LNK, 1, AN1_TIMEOUT_VC7, TX_LNK_AN1_TIMEOUT_VC7),

    // RX LNK errors
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 0, RXRSPSTATUS_HW_ERR, RX_LNK_RXRSPSTATUS_HW_ERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 0, RXRSPSTATUS_UR_ERR, RX_LNK_RXRSPSTATUS_UR_ERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_NON_FATAL(RX_LNK, 0, RXRSPSTATUS_PRIV_ERR, RX_LNK_RXRSPSTATUS_PRIV_ERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX_LNK, 1, RXPOISONERR, RXPOISONERR),

    // LWLIPT LNK
    LWSWITCH_INTR_INJECT_LWLIPT_LIST_ENTRY_FATAL(LWLIPT_LNK, LWLIPT_LNK, SLEEPWHILEACTIVELINK, SLEEPWHILEACTIVELINK),
};

TEST_P(LWSwitchDeviceTestLwlIntrDisabledLr10, IntrLwlDisabledInject)
{
    if (skipTest())
    {
        return;
    }

    // Disabled interrupts shouldn't fire on injection nor log error data.
    setDisabledIntrTestMode();

    if (getLinkInitializedMask() != 0)
    {
        printf("[ SKIPPED ] The links are not in INIT or INVALID (RESET) state. "
               "This test suite only supports running on a system with "
               "uninitialized lwlinks. Run \"lwpu-smi -r\" to reset "
               "the HW. Refer to the README for more information.\n");
        return;
    }

    initLinks();

    injectErrorAndWaitForEvent();

    ASSERT_EQ(validateError(), 0);

    shutdownLinks();

    // Unbind on teardown is not necessary as no errors were injected.
    skipUnbindOnTeardown();
}

INSTANTIATE_TEST_CASE_P(IntrTestLr10, LWSwitchDeviceTestIntrLr10, ::testing::ValuesIn(g_deviceIntrTestListLr10), getTestNameString);
INSTANTIATE_TEST_CASE_P(IntrTestLr10, LWSwitchDeviceTestIntrDisabledLr10, ::testing::ValuesIn(g_deviceDisabledIntrListLr10), getTestNameString);
//
// TODO : There tests needs to initialize and train links before injecting errors.
//        initLinks() is lwrrently failing, tracked in bug 2876587.
// INSTANTIATE_TEST_CASE_P(IntrTestLr10, LWSwitchDeviceTestLwlIntrLr10, ::testing::ValuesIn(g_deviceIntrLwlTestListLr10), getTestNameString);
// INSTANTIATE_TEST_CASE_P(IntrTestLr10, LWSwitchDeviceTestLwlIntrDisabledLr10, ::testing::ValuesIn(g_deviceIntrLwlTestListDisabledLr10), getTestNameString);
//
