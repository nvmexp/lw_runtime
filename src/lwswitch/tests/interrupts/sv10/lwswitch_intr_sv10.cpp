/* _LWRM_COPYRIGHT_BEGIN_
 *
 * Copyright 2018-2019 by LWPU Corporation.  All rights reserved.  All
 * information contained herein is proprietary and confidential to LWPU
 * Corporation.  Any use, reproduction, or disclosure without the written
 * permission of LWPU Corporation is prohibited.
 *
 * _LWRM_COPYRIGHT_END_
 */


#include <list>

#include "lwswitch.h"
#include "interrupts/lwswitch_intr.h"
#include "lwmisc.h"

#include "ioctl_dev_lwswitch.h"
#include "ioctl_dev_internal_lwswitch.h"
#include "svnp01/dev_ftstate_ip.h"
#include "svnp01/dev_egress_ip.h"
#include "svnp01/dev_route_ip.h"
#include "svnp01/dev_ingress_ip.h"
#include "svnp01/dev_lwlctrl_ip.h"
#include "svnp01/dev_lwltlc_ip.h"

using namespace lwswitch;

class LWSwitchDeviceTestIntrSv10
    : public LWSwitchDeviceTestIntr
{
public:
    LWSwitchDeviceTestIntrSv10():LWSwitchDeviceTestIntr(LWSWITCH_GET_INFO_INDEX_ARCH_SV10)
    {};
};

class LWSwitchDeviceTestIntrPortResetSv10
    : public LWSwitchDeviceTestIntrSv10
    {};

class LWSwitchDeviceTestIntrDisabledSv10
    : public LWSwitchDeviceTestIntrSv10
    {};

class LWSwitchDeviceTestLwlIntrSv10
    : public LWSwitchDeviceTestIntrSv10
    {};

int main(int argc, char **argv);

#define LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY(block, error, bUnbind)            \
        LWSwitchIntrTestParams(REGISTER_RW_ENGINE_NPORT,                        \
            DRF_NUM(_##block, _ERR_INJECT_0, _##error, 1),                      \
            LW_##block##_ERR_INJECT_0, LWSWITCH_ERR_HW_NPORT_##block##_##error, \
            bUnbind, "NPORT_" #block "_" #error)

#define LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(block, error)           \
            LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY(block, error, LW_FALSE)

#define LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(block, error)               \
            LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY(block, error, LW_TRUE)

#define LWSWITCH_INTR_INJECT_SIOCTRL_LIST_ENTRY(block, error, bUnbind)              \
        {LWSwitchIntrTestParams(REGISTER_RW_ENGINE_SIOCTRL,                         \
            DRF_NUM(_LWLCTRL, _##block##_0_ERR_INJECT_0, _##error, 1),              \
            LW_LWLCTRL_##block##_0_ERR_INJECT_0, LWSWITCH_ERR_HW_LWLCTRL_##error,   \
            bUnbind, "LWLCTRL_" #block "_0_" #error)},                              \
        {LWSwitchIntrTestParams(REGISTER_RW_ENGINE_SIOCTRL,                         \
            DRF_NUM(_LWLCTRL, _##block##_1_ERR_INJECT_0, _##error, 1),              \
            LW_LWLCTRL_##block##_1_ERR_INJECT_0, LWSWITCH_ERR_HW_LWLCTRL_##error,   \
            bUnbind, "LWLCTRL_" #block "_1_" #error)}

#define LWSWITCH_INTR_INJECT_SIOCTRL_LIST_ENTRY_FATAL(block, error)             \
            LWSWITCH_INTR_INJECT_SIOCTRL_LIST_ENTRY(block, error, LW_TRUE)

#define LWSWITCH_INTR_INJECT_SIOCTRL_LIST_ENTRY_NON_FATAL(block, error)         \
            LWSWITCH_INTR_INJECT_SIOCTRL_LIST_ENTRY(block, error, LW_FALSE)

#define LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY(block, injRegInst, error, bUnbind)       \
        LWSwitchIntrTestParams(REGISTER_RW_ENGINE_LWLTLC,                               \
            DRF_NUM(_LWLTLC_##block, _ERR_INJECT_##injRegInst, _##error, 1),            \
            LW_LWLTLC_##block##_ERR_INJECT_##injRegInst, LWSWITCH_ERR_HW_LWLTLC_##error,\
            bUnbind, "LWLTLC_" #block "_" #injRegInst "_" #error)

#define LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_NON_FATAL(block, injRegInst, error)      \
            LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY(block, injRegInst, error, LW_FALSE)

#define LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(block, injRegInst, error)          \
            LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY(block, injRegInst, error, LW_TRUE)

// List of interrupt test cases
static const std::list<LWSwitchIntrTestParams> g_deviceIntrTestListSv10 = {

    // FSTATE NPORT error test cases
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(FSTATE, SINGLEBITECCLIMITERR_FLUSHREQSTORE),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(FSTATE, SINGLEBITECCLIMITERR_CRUMBSTORE),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(FSTATE, SINGLEBITECCLIMITERR_TAGSTORE),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(FSTATE, UNCORRECTABLEECCERR_FLUSHREQSTORE),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(FSTATE, UNCORRECTABLEECCERR_CRUMBSTORE),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(FSTATE, UNCORRECTABLEECCERR_TAGSTORE),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(FSTATE, TAGPOOLBUFERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(FSTATE, CRUMBSTOREBUFERR),

    // TSTATE NPORT error test cases
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(TSTATE, TAGPOOLBUFERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(TSTATE, CRUMBSTOREBUFERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(TSTATE, SINGLEBITECCLIMITERR_CRUMBSTORE),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(TSTATE, SINGLEBITECCLIMITERR_TAGSTORE),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(TSTATE, UNCORRECTABLEECCERR_CRUMBSTORE),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(TSTATE, UNCORRECTABLEECCERR_TAGSTORE),

    // EGRESS NPORT error test cases
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(EGRESS, EGRESSBUFERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(EGRESS, PKTROUTEERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(EGRESS, ECCSINGLEBITLIMITERR0),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, ECCHDRDOUBLEBITERR0),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(EGRESS, ECCDATADOUBLEBITERR0),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(EGRESS, ECCSINGLEBITLIMITERR1),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, ECCHDRDOUBLEBITERR1),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(EGRESS, ECCDATADOUBLEBITERR1),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, NCISOCHDRCREDITOVFL),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, NCISOCDATACREDITOVFL),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, ADDRMATCHERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, TAGCOUNTERR),
    // TO-DO: Add coverage for commented interrupts below
    // (LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, FLUSHRSPERR))
    // (LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, DROPNPURRSPERR))
    // (LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, POISONERR))

    // ROUTE NPORT error test cases
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(ROUTE, ROUTEBUFERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(ROUTE, NOPORTDEFINEDERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(ROUTE, ILWALIDROUTEPOLICYERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(ROUTE, ECCLIMITERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(ROUTE, TRANSDONERESVERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(ROUTE, UNCORRECTABLEECCERR),

    // INGRESS NPORT error test cases
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(INGRESS, CMDDECODEERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(INGRESS, BDFMISMATCHERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(INGRESS, BUBBLEDETECT),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(INGRESS, ACLFAIL),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(INGRESS, ECCHDRDOUBLEBITERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(INGRESS, ILWALIDCMD),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(INGRESS, ILWALIDVCSET),
    // TO-DO: Add coverage for commented interrupts below
    // (LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(INGRESS, PKTPOISONSET))

    // CLKCROSS SIOCTRL error test cases
    LWSWITCH_INTR_INJECT_SIOCTRL_LIST_ENTRY_NON_FATAL(CLKCROSS, INGRESSECCSOFTLIMITERR),
    LWSWITCH_INTR_INJECT_SIOCTRL_LIST_ENTRY_FATAL(CLKCROSS, INGRESSECCHDRDOUBLEBITERR),
    LWSWITCH_INTR_INJECT_SIOCTRL_LIST_ENTRY_NON_FATAL(CLKCROSS, INGRESSECCDATADOUBLEBITERR),
    LWSWITCH_INTR_INJECT_SIOCTRL_LIST_ENTRY_NON_FATAL(CLKCROSS, INGRESSBUFFERERR),
    LWSWITCH_INTR_INJECT_SIOCTRL_LIST_ENTRY_NON_FATAL(CLKCROSS, EGRESSECCSOFTLIMITERR),
    LWSWITCH_INTR_INJECT_SIOCTRL_LIST_ENTRY_FATAL(CLKCROSS, EGRESSECCHDRDOUBLEBITERR),
    LWSWITCH_INTR_INJECT_SIOCTRL_LIST_ENTRY_NON_FATAL(CLKCROSS, EGRESSECCDATADOUBLEBITERR),
    LWSWITCH_INTR_INJECT_SIOCTRL_LIST_ENTRY_NON_FATAL(CLKCROSS, EGRESSBUFFERERR)
};

TEST_P(LWSwitchDeviceTestIntrSv10, IntrTest)
{
    if (skipTest())
    {
        return;
    }

    injectErrorAndWaitForEvent();

    ASSERT_EQ(validateError(), 0);
}

// List of LWLink TX/RX interrupts
static const std::list<LWSwitchIntrTestParams> g_deviceIntrLwlTestListSv10 = {

    // TX LWLTLC error test cases
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX, 0, TXHDRCREDITOVFERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX, 0, TXDATACREDITOVFERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX, 0, TXDLCREDITOVFERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX, 0, TXDLCREDITPARITYERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX, 0, TXRAMHDRPARITYERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX, 0, TXRAMDATAPARITYERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX, 0, TXUNSUPVCOVFERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX, 0, TXSTOMPDET),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX, 0, TARGETERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(TX, 0, UNSUPPORTEDREQUESTERR),
    // Add coverage for TXPOISONDET

    // RX IJNJECT_0 LWLTLC error test case list
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 0, RXDLHDRPARITYERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 0, RXDLDATAPARITYERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 0, RXDLCTRLPARITYERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 0, RXRAMDATAPARITYERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 0, RXRAMHDRPARITYERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 0, RXILWALIDAEERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 0, RXILWALIDBEERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 0, RXILWALIDADDRALIGNERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 0, RXPKTLENERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 0, RSVCMDENCERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 0, RSVDATLENENCERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 0, RSVADDRTYPEERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 0, RSVRSPSTATUSERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 0, RSVPKTSTATUSERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 0, RSVCACHEATTRPROBEREQERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 0, RSVCACHEATTRPROBERSPERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 0, DATLENGTATOMICREQMAXERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 0, DATLENGTRMWREQMAXERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 0, DATLENLTATRRSPMINERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 0, ILWALIDCACHEATTRPOERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 0, ILWALIDCRERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 0, RXRESPSTATUSUNSUPPORTEDREQUESTERR),
    // Add coverage for RXRESPSTATUSTARGETERR

    // RX IJNJECT_1 LWLTLC error test case list
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 1, STOMPDETERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 1, RXUNSUPVCOVFERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 1, RXUNSUPLWLINKCREDITRELERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 1, RXUNSUPNCISOCCREDITRELERR),
    // Add coverage for RXPOISONERR, CORRECTABLEINTERNALERR
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 1, RXHDROVFERR),
    LWSWITCH_INTR_INJECT_LWLTLC_LIST_ENTRY_FATAL(RX, 1, RXDATAOVFERR)
};

TEST_P(LWSwitchDeviceTestLwlIntrSv10, IntrLwlTest)
{
    if (skipTest())
    {
        return;
    }

    if (getLinkInitializedMask() != 0)
    {
        printf("[ SKIPPED ] The links are not in INIT or INVALID (RESET) state. "
               "This test suite only supports running on a system with "
               "uninitialized lwlinks. Run \"lwpu-smi -r\" to reset "
               "the HW. Refer to the README for more information.\n");
        return;
    }

    initLinks();

    injectErrorAndWaitForEvent();

    ASSERT_EQ(validateError(), 0);
}

// List of test cases for FATAL error injection followed by port reset
static const std::list<LWSwitchIntrTestParams> g_deviceIntrPortResetTestListSv10 = {
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(FSTATE, UNCORRECTABLEECCERR_FLUSHREQSTORE),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(FSTATE, UNCORRECTABLEECCERR_CRUMBSTORE),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(FSTATE, UNCORRECTABLEECCERR_TAGSTORE),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(FSTATE, TAGPOOLBUFERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(FSTATE, CRUMBSTOREBUFERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(TSTATE, TAGPOOLBUFERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(TSTATE, CRUMBSTOREBUFERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(TSTATE, UNCORRECTABLEECCERR_CRUMBSTORE),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(TSTATE, UNCORRECTABLEECCERR_TAGSTORE),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, ECCHDRDOUBLEBITERR0),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, ECCHDRDOUBLEBITERR1),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, NCISOCHDRCREDITOVFL),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, NCISOCDATACREDITOVFL),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, ADDRMATCHERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(EGRESS, TAGCOUNTERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(ROUTE, ROUTEBUFERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(ROUTE, TRANSDONERESVERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(ROUTE, UNCORRECTABLEECCERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(INGRESS, CMDDECODEERR),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(INGRESS, BUBBLEDETECT),
    LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_FATAL(INGRESS, ECCHDRDOUBLEBITERR),
    LWSWITCH_INTR_INJECT_SIOCTRL_LIST_ENTRY_FATAL(CLKCROSS, INGRESSECCHDRDOUBLEBITERR),
    LWSWITCH_INTR_INJECT_SIOCTRL_LIST_ENTRY_FATAL(CLKCROSS, EGRESSECCHDRDOUBLEBITERR)
};

TEST_P(LWSwitchDeviceTestIntrPortResetSv10, IntrFatalWithPortReset)
{
    if (skipTest())
    {
        return;
    }

    injectErrorAndWaitForEvent();

    ASSERT_EQ(validateError(), 0);

    resetPorts(0x3);

    injectErrorAndWaitForEvent();

    ASSERT_EQ(validateError(), 0);

    resetPorts(0x3);

    // Unbind on teardown is not necessary due to resetting the ports.
    skipUnbindOnTeardown();
}
TEST_P(LWSwitchDeviceTestIntrPortResetSv10, IntrFatalRepeat)
{
    if (skipTest())
    {
        return;
    }

    injectErrorAndWaitForEvent();

    ASSERT_EQ(validateError(), 0);

    // Repeated fatal error injection is expected to not fire or log interrupts.
    setDisabledIntrTestMode();

    injectErrorAndWaitForEvent();

    ASSERT_EQ(validateError(), 0);

    resetPorts(0x3);

    // Unbind on teardown is not necessary due to resetting the ports.
    skipUnbindOnTeardown();
}

static const std::list<LWSwitchIntrTestParams> g_deviceDisabledIntrListSv10 = {
    (LWSWITCH_INTR_INJECT_NPORT_LIST_ENTRY_NON_FATAL(INGRESS, ECCSOFTLIMITERR))
};

TEST_P(LWSwitchDeviceTestIntrDisabledSv10, IntrDisabledInject)
{
    if (skipTest())
    {
        return;
    }

    // Disabled interrupts shouldn't fire on injection nor log error data.
    setDisabledIntrTestMode();

    injectErrorAndWaitForEvent();

    ASSERT_EQ(validateError(), 0);

    // Unbind on teardown is not necessary as no errors were injected.
    skipUnbindOnTeardown();
}

INSTANTIATE_TEST_CASE_P(IntrTestSv10, LWSwitchDeviceTestIntrSv10, ::testing::ValuesIn(g_deviceIntrTestListSv10), getTestNameString);
INSTANTIATE_TEST_CASE_P(IntrTestSv10, LWSwitchDeviceTestLwlIntrSv10, ::testing::ValuesIn(g_deviceIntrLwlTestListSv10), getTestNameString);
INSTANTIATE_TEST_CASE_P(IntrTestSv10, LWSwitchDeviceTestIntrPortResetSv10, ::testing::ValuesIn(g_deviceIntrPortResetTestListSv10), getTestNameString);
INSTANTIATE_TEST_CASE_P(IntrTestSv10, LWSwitchDeviceTestIntrDisabledSv10, ::testing::ValuesIn(g_deviceDisabledIntrListSv10), getTestNameString);
